Ctrig Assembler v5.4
Made by Ninfia

Version : v5.4
Latest Update : 20220421
Compatible With Tep v1.0 & v2.0
Ctrig Assembler Official Guide Book

------------------------------------------------------------------------------------------

『Ctrig Assembler v5.4 Guide Book Index 』

------------------------------------------------------------------------------------------

｡˙+ﾟ 목차 ｡+.ﾟ
A. 설치방법
B. 사용시 주의사항
C. 예제맵 및 Debug.py 사용방법
D. CtrigAsm 함수목록

E. CtrigAsm 예제
F. CB Paint 함수목록
G. CB Paint 예제
H. 전역변수 목록
I. Index 자동할당 목록

J. Cp트릭 사용함수 목록
K. 내부함수 목록
L. Vi() 사용가능함수 목록
M. STRCTRIG 적용방법
N. CPLP 프로텍터 적용방법

O. 도형 추출기 사용방법
P. 썸네일 편집기 사용방법
Q. 사진 변환기 사용방법
R. Visual Studio 연계법
2

------------------------------------------------------------------------------------------

『 A. 설치방법 』

------------------------------------------------------------------------------------------

｡˙+ﾟ Ctrig Assembler 구성품｡+.ﾟ
.Lua 파일
(Tep전용)

.Py 파일
(eudplib)

(구) 도형
생성함수

Tep 파일
(scmdraft)

어셈블러
본체

예제맵
(euddraft)

도형생성
함수본체

8인용맵
전용코드

외부루아
로더
(Tep 2.0)

어그로용
썸네일

어셈블러
가이드북

(기타)공중
밀림방지

스트링
변환함수

1. lua 폴더 → scmdraft2의 lua 폴더로 복사 (lua 폴더가 없으면 만들어서 복사)
(Loader.lua는 scmdraft2 폴더에 바로 복사)

3

------------------------------------------------------------------------------------------

『 A. 설치방법 』

------------------------------------------------------------------------------------------

｡˙+ﾟ Ctrig Assembler 구성품｡+.ﾟ

.Lua 파일
(Tep전용)

.Py 파일
(eudplib)

Tep 파일
(scmdraft)

어셈블러
플러그인

예제맵
(euddraft)

8인용맵
전용코드

디버그용
플러그인

어그로용
썸네일

어셈블러
가이드북

Eudx
플러그인

Eudeditor 2 사용예시

2. .py 폴더 → euddraft의 plugins 폴더로 복사
(권장버전 0.8.3.6~0.9.2.0)
Euddraft .eds 사용예시

어셈블러 플러그인 적용
디버그용 플러그인 적용(선택)
Euddraft 플러그인 삽입 설정에서
CPLP 사용시 반드시 Freeze를 꺼줘야 함
4

------------------------------------------------------------------------------------------

『 A. 설치방법 』

------------------------------------------------------------------------------------------

｡˙+ﾟ Ctrig Assembler 구성품｡+.ﾟ
.Lua 파일
(Tep전용)

.Py 파일
(eudplib)

Tep 파일
(scmdraft)

예제맵
(euddraft)

Tep v1.0

8인용맵
전용코드

어그로용
썸네일

어셈블러
가이드북

Tep v2.0
(로더필요)

3. Tep 폴더 → scmdraft2의 plugins 폴더로 복사 (Tep v1.0, v2.0이 이미 있으면 통과)
Tep v1.0
장점 : EUDX O / 코드유지 O / 함수 자동완성 O / 외부루아 O
단점 : 최적화 X
Tep v2.0
장점 : EUDX O / 코드유지 O / 최적화 O
단점 : 함수 자동완성 X / 외부루아 X → v2.0 전용 외부루아 로더 사용시 가능
5

------------------------------------------------------------------------------------------

『 A. 설치방법 』

------------------------------------------------------------------------------------------

｡˙+ﾟ Ctrig Assembler 구성품｡+.ﾟ

외부루아 로더
(.Lua 파일)

Tep v2.0
외부루아

Tep v2.0
외부루아
+개수제한X

Tep v2.0
외부루아
+VSCode
+개수제한X

Tep v2.0
외부루아
+VSCode

4. Loader 폴더 → scmdraft2 폴더로 복사 (Loader, LoaderX, Loader2, Loader2X.lua)

6

------------------------------------------------------------------------------------------

『 A. 설치방법 』

------------------------------------------------------------------------------------------

｡˙+ﾟ (선택) Tep v2.0 외부루아 설치법 ｡+.ﾟ
Tep v2.0 맨 위에 다음 코드를 붙여넣는다.
(scmdraft2 설치 폴더의 경로에서 \를 \\로 바꾼 뒤 주소 입력칸에 붙여넣는다.)
Curdir="scmdraft 설치경로(\를 \\로 바꿔야함)"
Dofile(Curdir.."/Loader.lua")

↓파일탐색기의 경로창 클릭 후 경로 복사

주소 입력칸에
복사한 경로 붙여넣은 후
CTRL+H로 \를 \\로
모두 바꾼다.

완성된 외부루아 로더 코드를 복사한 뒤 Tep v2.0의 맨 위에 붙여넣는다.
(F5를 눌러서 컴파일이 성공하면 설치완료)

7

------------------------------------------------------------------------------------------

『 A. 설치방법 』

------------------------------------------------------------------------------------------

｡˙+ﾟ (선택) Tep v2.0 트리거 개수 제한 해제법 (Loader2.lua) ｡+.ﾟ
Tep v2.0에 다음 코드를 붙여넣는다.
(scmdraft2 설치 폴더의 경로에서 \를 \\로 바꾼 뒤 주소 입력칸에 붙여넣는다.)
Curdir=" scmdraft 설치경로(\를 \\로 바꿔야함)"
Mapdir="맵파일 경로(\를 \\로 바꿔야함)".."\\".."맵파일 이름(.scx 제외)"
__StringArray = {} __UPUSCheckArray = {}
__TRIGChkptr = io.open(Mapdir.."__TRIG.chk", "wb")
Dofile(Curdir.."/Loader2.lua")
__InitTrigger()
---------------------------------- 코드 삽입 영역 --------------------------------__PopStringArray()
io.close(__TRIGchkptr)
Ex) 맵파일이 D:\ddd의 폴더 내부에 있고, 맵파일의 이름이 ASDF.scx인 경우
맵 파일 경로는 D:\\ddd를, 맵 파일 이름은 ASDF를 입력한다.
코드 삽입 영역에 Tep 트리거 코드를 입력하면 된다.
완성된 외부루아 로더 코드를 복사한 뒤 Tep v2.0에 붙여넣는다.
(F5를 눌러서 컴파일이 성공하면 설치완료)
※ Loader2(X).lua 사용시 반드시 STRCtrig를 사용해야 하며, euddraft 0.9.5.3이상을 사용해야함

※ 컴파일 완료시 맵파일이 있는 경로에 맵파일 이름__TRIG.chk가 생성되며,
STRCtrigAsm.exe에서 입력된 맵파일의 경로에 트리거 파일(__TRIG.chk)을 감지할 경우
Loader2(X).lua가 생성한 트리거 파일을 사용해 P1~P8TRIG.chk를 생성함
※ 주의 : Loader2(X).lua를 사용하지 않더라도 맵파일이 있는 폴더에
맵파일 이름__TRIG.chk가 남아있을 경우, STRCtrig에서는 Loader2(X)모드로 작동함

8

------------------------------------------------------------------------------------------

『 A. 설치방법 』

------------------------------------------------------------------------------------------

｡˙+ﾟ Tep 표준 설치 방법｡+.ﾟ
Tep에 다음 코드를 그대로 붙여넣은 뒤 맵 정보를 각각의 함수에 입력한다.
(이미 트리거가 있는 맵일경우 기존의 모든 트리거들을 트리거 삽입구역에 넣는다.

--↓ Tep에 그대로 붙여넣기---------------------------------------SetForces({},{},{},{},{})
SetFixedPlayer()
StartCtrig()
Cjump(AllPlayers,0)
-- 여기에 변수, 배열 및 Include류 함수 선언 -CJumpEnd(AllPlayers,0)

트리거 삽입구역
EndCtrig()
-- 에러 체크 함수 선언 위치 ---↑Tep에 그대로 붙여넣기---------------------------------------SetForces : 맵의 세력(Force)에 해당하는 플레이어들을 입력
SetForces({Force1},{Force2},{Force3},{Force4},{Allplayers})
Ex) ↓다음과 같은 맵의 경우 (P1~P6까지 사용)
SetForces({P1},{P2,P3},{P4,P5,P6},{},{P1,P2,P3,P4,P5,P6})

9

------------------------------------------------------------------------------------------

『 A. 설치방법 』

------------------------------------------------------------------------------------------

｡˙+ﾟ Tep 표준 설치 방법｡+.ﾟ
Tep에 다음 코드를 그대로 붙여넣은 뒤 맵 정보를 각각의 함수에 입력한다.
(이미 트리거가 있는 맵일경우 기존의 모든 트리거들을 트리거 삽입구역에 넣는다.

--↓ Tep에 그대로 붙여넣기---------------------------------------SetForces({},{},{},{},{})
SetFixedPlayer()
StartCtrig()
Cjump(AllPlayers,0)
-- 여기에 변수, 배열 및 Include류 함수 선언 -CJumpEnd(AllPlayers,0)

트리거 삽입구역
EndCtrig()
-- 에러 체크 함수 선언 위치 ---↑Tep에 그대로 붙여넣기---------------------------------------SetFixedPlayer : 고정 플레이어(컴퓨터 등)을 입력
SetForces({Force1},{Force2},{Force3},{Force4},{Allplayers})
Ex) P1~P5가 플레이어, P6~P7이 컴퓨터일 경우
SetFixedPlayer(P6) 또는 SetFixedPlayer(P7)
StartCtrig ~ EndCtrig 사이에서만 어셈블러 트리거를 사용할 수 있다.
CJump ~ CJumpEnd 사이에 변수, 배열, Include 함수를 선언하는 것을 권장함

10

------------------------------------------------------------------------------------------

『 B. 사용시 주의사항 』

-----------------------------------------------------------------------------------------1. 코드 사용량에 따라 맵 실행 후 몇 초간 로딩시간이 걸릴 수도 있습니다.
2. Tep 트리거 갯수 총합 65536개 이상일 때 scmdraft 오류가 발생할 수 있습니다.
(트리거 개수 65536개 이상 사용시 Loader2(X).lua 사용 필수 → A.설치방법을 참고)
3. Euddraft의 트리거 인라이닝 기능과 호환되지 않습니다.
(PRT_SetInliningRate(0) 기본적용, CPLP 사용시 Freeze:0 적용필수)
4. 전역변수를 임의로 건드리거나 내부함수를 임의로 호출하는 경우
오류가 발생할 수 있습니다.
5. Tep v1.0으로 작업하는 경우 코드 사용량이 많을 경우 렉이 걸릴 수 있습니다.
6. 0x58A364 (P1 마린 데스값)은 임의로 값이 변경 될 수 있습니다.
(P1 마린 데스값 사용방법은 부록예제 #-2 참고)

7. Tep의 코드 유지가 어떠한 이유로 풀린 경우 원본 코드를 복구 할 수 없습니다.
(작업한 뒤 Tep 코드를 메모장에 항상 따로 저장하는 것을 추천)
(C:\Users\사용자이름\AppData\Roaming\TEP v1.0 또는
C:\Users\사용자이름\AppData\Roaming\TEP v2.0 폴더에
마지막으로 컴파일 한 코드가 저장되어 있습니다.) – 덮어쓴 경우 사라지므로 주의
8. 다른 eudplib 플러그인에서 TRIG단락을 건드리는 경우 오류가 발생할 수 있습니다.
9. Eudplib STRx 미적용 구 버전(0.8.9.9.0 미만)에서는 호환되지 않을 수도 있습니다.
10. 어셈블러 패치마다 내부 함수와 일반함수의 내부구조는 변경 될 수 있습니다.
11. 2개 이상의 다른 버전의 Tep을 같이 쓰거나 클래식 트리거를 사용하는 경우
Tep의 코드 유지가 풀릴 수 있습니다.
12. 어셈블러 조건 및 액션 사용시 해당 트리거의 1번째 조건에 Label()을 삽입해야 적용됨

※ (추가) Scmdraft2에서 String Corruption 발생 원인
1. ParseString(String) 사용후 해당 String을 실제 액션으로 사용하지 않았을 때 발생
(Disabled(DisplayText(Text)) 삽입으로 해결가능)
2. Action() (ActionID 0x40이상) 액션 아래에 ParseString() 사용 액션을 삽입하는 경우
(ActionID를 0x40이하로 바꾼다)
3. DisplayText, PlayWav등 ParseString() 사용 액션을 함수의 인자로 그대로 전달한 후
2회이상 해당 액션을 삽입하는 경우
(액션 전체 대신 String을 따로 입력받아 함수 내부에서 액션에 스트링을 삽입해
트리거에 삽입하여 해결한다. - CopyCpAction 사용 권장)

11

------------------------------------------------------------------------------------------

『 C. 예제맵 및 Debug.py 사용방법 』

------------------------------------------------------------------------------------------

｡˙+ﾟ Ctrig Assembler 구성품｡+.ﾟ
.Lua 파일
(Tep전용)

.Py 파일
(eudplib)

Tep 파일
(scmdraft)

예제맵
(euddraft)

어셈블러
예제맵

8인용맵
전용코드

어그로용
썸네일

어셈블러
가이드북

도형함수
예제맵

필요한 예제맵을 선택해서 euddraft 폴더에 복사 또는 eudeditor2에 연결한다.

12

------------------------------------------------------------------------------------------

『 C. 예제맵 및 Debug.py 사용방법 』

------------------------------------------------------------------------------------------

｡˙+ﾟ어셈블러 예제맵 ｡+.ﾟ
--↓ Tep에 그대로 붙여넣기 ----------------------------------------------------------------SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P1)
어셈블러
StartCtrig()
가이드북
--↓ 이곳에 예제를 붙여넣기 ----------------------------------------------------------------CJump(AllPlayers,0)
CJumpEnd(AllPlayers,0)

예제 삽입 부분

--↑ 이곳에 예제를 붙여넣기 ----------------------------------------------------------------이하 생략

Testmap TRIG.txt를 그대로 복사해 Tep의 기존 트리거들을 모두 지운 후 붙여넣는다.
(Tep v2.0 사용시 맨 위에 외부루아 로더 코드도 함께 복사해야함)

←Tep v1.0
Tep v2.0→

E. CtrigAsm 예제편에 있는 예제를 그대로 복사 후 예제 삽입 부분에 붙여넣고
Euddraft 또는 eudeditor2로 컴파일하여 해당 예제에 대한 결과를 직접 확인한다.

← 부록예제 #-4를
Tep v2.0에
삽입한 모습

13

------------------------------------------------------------------------------------------

『 C. 예제맵 및 Debug.py 사용방법 』

------------------------------------------------------------------------------------------

｡˙+ﾟ도형함수 예제맵 ｡+.ﾟ
어셈블러 예제맵과 마찬가지로 예제맵 TRIG.txt를 그대로 복사해
Tep의 기존 트리거들을 모두 지운 후 붙여넣는다.
(Tep v2.0 사용시 맨 위에 외부루아 로더 코드도 함께 복사해야함)
G. CX Paint 예제편에 있는 예제를 그대로 복사 후 예제 삽입 부분에 붙여넣고
Euddraft 또는 eudeditor2로 컴파일하여 해당 예제에 대한 결과를 직접 확인한다.

｡˙+ﾟDebug.py 사용법 ｡+.ﾟ
Euddraft 또는 eudeditor2에서 [Debug]를 입력해 플러그인을 추가할 수 있으며
0x58F448의 값으로 실시간으로 기능사용 여부를 제어할 수 있다.
모든 기능은 플레이어 관계없이 사용가능함

(2)

(3)

(1)

1) 13번째 줄에 0x58F450~0x58F47C의 값을 Hex로 표시함
SetMemoryX(0x58F448,SetTo,1,1); 로 해당 기능을 사용할 수 있다.
2) 채팅 1~8번째 줄에 0x58F480~0x58F4FC의 값을 Hex로 표시함
SetMemoryX(0x58F448,SetTo,2,2); 로 해당 기능을 사용할 수 있다.
3) 채팅으로 ||AAAAAA BBBBBBBB 입력시 SetMemory(0xAAAAAA,SetTo,0xBBBBBBBB);
액션을 실행함 (0xAAAAAA는 0x500000이상 0x700000이하만 작동함)
SetMemoryX(0x58F448,SetTo,4,4); 로 해당 기능을 사용할 수 있다.
4) 채팅으로 ##AAAAAAAA BBBBBBBB 입력시 SetMemory(0xAAAAAAAA,SetTo,0xBBBBBBBB);
액션을 실행함, SetMemoryX(0x58F448,SetTo,0x24,0x24); 로 해당 기능을 사용할 수 있다.

5) 채팅으로 @@ReadV# CCCCCCCC 입력시(#는 1~4) 5번째 줄에 f_dwread(0xCCCCCCCC)
의 결과를 출력함, SetMemoryX(0x58F448,SetTo,0x10,0x10); 로 해당 기능을 사용할 수 있다.
14

------------------------------------------------------------------------------------------

『 D. CtrigAsm 함수목록 』

------------------------------------------------------------------------------------------

｡˙+ﾟ 0. 목차 ｡+.ﾟ
1장 : 맵 정보 입력 관련
2장 : CtrigAsm 설치 관련 함수
3장 : 기본 내장 조건/액션 함수 (.Py 직접 연동 함수)
4장 : 기본 오류 체크 함수 (선택)
5장 : 표준 입출력 및 변환 함수
6장 : 변수/배열 선언 및 호출 함수
7장 : DoActions류 트리거 생성 함수
8장 : Ctrig 파생 조건/액션 함수
9장 : Cp트릭 관련 및 CunitCtrig 함수
10장 : 제어문 관련 함수 (CStruct)
11장 : SafeRead류 데이터 읽기 관련 함수
12장 : 매크로 함수형 최종 연산 함수 (C)
13장 : 함수 호출형 함수 정의 선언 함수 (Include)
14장 : 함수 호출형 최종 연산 함수 (f_)
15장 : 중간 연산자 관련 함수 (_)

16장 : 변수 삽입형 조건/액션 함수 (T)
17장 : 특수 조건 관련 함수 (TT)
18장 : 기타 편의기능 관련 함수
19장 : 기타 스트링 관련 함수
20장 : CreateUnitShape.lua 함수
21장 : 사용자 정의 추가 함수
22장 : 64비트 변수 연산 함수 (W)
23장 : 구조체 변수 연산 함수 (SV)
24장 : 논리 조건 연산 함수 (_T)
25장 : 바이트 단위 R/W 함수 (byte)
26장 : 이상 스트링 편집 및 출력 함수 (CAPrint)
27장 : 비공유 데이터 전송 함수 (NSQC.py)
28장 : 순수 총알생성 함수 (언리미터 필요)
29장 : 파일 I/O 및 CGRP 삽입 함수
# : 부록 설명
15

------------------------------------------------------------------------------------------

『 1장 : 맵 정보 입력 관련 』

------------------------------------------------------------------------------------------

SetForces({Force1},{Force2},{Force3},{Force4},{Allplayers})
: 맵의 Force1 ~ 4, Allplayers 에 해당하는 플레이어 정보를 입력하는 함수
Force1 : Force1에 해당하는 플레이어들을 입력
Force2 : Force2에 해당하는 플레이어들을 입력
Force3 : Force3에 해당하는 플레이어들을 입력
Force4 : Force4에 해당하는 플레이어들을 입력
AllPlayers : 맵에 존재하는 모든 플레이어들을 입력
ex) SetForces({P1,P3},{P2},{},{},{P1,P2,P3}) (P1,P3 = Force1, P2 = Force2, P1,P2,P3 = AllPlayers)

[예제 1-1] 참고
SetFixedPlayer(Player)
: 맵에서 플레이 도중에 나가지 않고 항상 존재하는 기준 플레이어를 설정함 (NDeaths용)
Player : 맵에 패배하지 않고 항상 남아있는 플레이어를 입력 (컴퓨터 등)
ex) SetFixedPlayer(P7) (P7 = 컴퓨터)

16

------------------------------------------------------------------------------------------

『 2장 : CtrigAsm 설치 관련 함수 』

------------------------------------------------------------------------------------------

StartCtrig(STRX,IncludePlayer,NSQC,STRCTRIG,AbsolutePath,CFunc,CStack,LStack)
: CtrigAsm을 시작하는 위치를 표시하는 함수 (Tep 맨 위에 StartCtrig() 입력)
STRX : 1입력시 맵의 스트링을 STRX단락으로 인식함 (비우거나 0 입력시 STR단락으로 입력됨)
(eudplib 0.8.9.9이상 버전으로 컴파일시 무조건 1을 입력)
IncludePlayer : 호출형 함수를 삽입할 플레이어를 입력 (미입력시 AllPlayers로 입력됨)
NSQC : NSQCVArray의 길이를 설정함 (비우거나 0입력시 미사용, 27단원 참고)
리턴값 : 생성된 NSQCVArray 배열 (NSQC에 n 입력시 [1] ~ [n]까지 사용가능)
STRCTRIG : 1입력시 STRCtrigAssembler 사용으로 입력됨 (비우거나 0입력시 미사용으로 입력됨)

AbsolutePath : 파일의 입출력 경로를 설정함 (CSSave, File I/O에서 사용됨, 비우면 미사용)
※ 절대 경로를 입력, 경로 입력시 윈도우 탐색기의 주소를 복사 한 뒤 \를 \\로 바꿔서 입력
CFunc : CFunc의 전달 인자의 최대갯수를 설정함 (기본값 16)
CStack : CStack의 스택 최대값을 설정함 (기본값 64)
LStack : LStack의 스택 최대값을 설정함 (기본값 32)

EndCtrig()
: CtrigAsm을 끝내는 위치를 표시하는 함수
ex) Tep 맨 아래에 EndCtrig() 입력

※ 주의 : StartCtrig()와 EndCtrig()는 각각 1번밖에 사용불가
※ StartCtrig ~ EndCtrig 사이의 트리거만 어셈블러 플러그인이 적용됨
------------------------------------------------------------------------------------------

일반 트리거만 삽입가능 (Eud Editor1 등)
StartCtrig()

어셈블러 플러그인 적용 구간
EndCtrig()

일반 트리거만 삽입가능 (EudTurbo() 등)
17

------------------------------------------------------------------------------------------

『 3장 : 기본 내장 조건/액션 함수 (.Py 직접 연동 함수)』

------------------------------------------------------------------------------------------

Label(Index)
: 트리거의 Label(식별자)를 붙이는 함수, 트리거의 첫번째 조건에 넣어서 사용
트리거에서 Ctrig 조건/액션을 사용할 때도 필요함. (Index=0 이면 단순 Ctrig사용)
Index : 해당 트리거에 붙일 식별자 (0x0 ~ 0x1FFFF, 기본값 0)
ex) Trigger {players = {P1},conditions = {Label(0x1000);}} : 이 트리거는 P1의 Label = 0x1000으로 식별됨
Trigger {players = {P1},conditions = {Label(0);}} : 해당 트리거에서 Ctrig 조건/액션을 사용함. (식별 안함)

CtrigX(Player,Index,Address,Next,Type,Value,Mask)

: 기본 Ctrig 조건, MemoryX(EPD(Ctrig),Type,Value,Mask) 형식으로 .py에서 변환됨
Player : 트리거의 플레이어(체크 플레이어) - P1 ~ P8(각각 0~7), CurrentPlayer = "X" 으로 입력함
Index : 트리거의 Label Index - Label 함수로 입력한 식별자 Index를 입력 ("X" 입력시 CurrentTrig로 입력됨)
Address : 트리거의 사용할 부분의 주소 - 일반적으로 0x0 ~ 0x968 사이를 입력 (4바이트 입력가능)
Next : 트리거의 Next - 해당 Label을 기준으로 Next 만큼 뒤에 있는 트리거를 선택함 (4바이트 입력가능)
-1 : 바로 앞의 트리거 / 0 : 사용안함 / 1 : 바로 뒤의 트리거 / 2 : 2칸 뒤의 트리거 / n : n칸 뒤의 트리거
Type : 조건 연산자 - AtLeast / Exactly / AtMost
Value : 조건 연산값 / Mask : 조건 EUDX Mask (기본값 0xFFFFFFFF)

ex) CtrigX("X",0x1000,0x15C,"X",Exactly,1234,0xFFFF)
→ MemoryX(CurrentPlayer의 Label:0x1000인 트리거의 0x15C(1번째 액션 Value)부분,Exactly,1234,0xFFFF);

CtrigX(P2,0x1001,0x4,2,AtLeast,0x4000)
→ MemoryX(P2의 Label:0x1001인 트리거의 2칸뒤의 트리거의 0x4(Next)부분,AtLeast,0x4000,0xFFFFFFFF);

CtrigX("X","X",0x20,-1,AtMost,1)
→ MemoryX(CurrentPlayer의 CurrentTrig의 바로 앞 트리거의 0x20(2번째 조건의 EPD)부분,AtMost,1,0xFFFFFFFF);

ex) [예제 3-1] 참고

18

------------------------------------------------------------------------------------------

『 3장 : 기본 내장 조건/액션 함수 (.Py 직접 연동 함수)』

------------------------------------------------------------------------------------------

SetCtrigX(Player1,Index1,Address1,Next1,Type,Player2,Index2,Address2,EPD2,Next2,Mask)
: 기본 Ctrig 액션, SetMemoryX(EPD(Ctrig1),Type,EPD(Ctrig2) or Ctrig2,Mask) 형식으로 .py에서 변환됨

Player1 : Ctrig1의 트리거 플레이어
Index1 : Ctrig1의 트리거 Index
Address1 : Ctrig1의 트리거의 사용할 부분의 주소
Next1 : Ctrig1의 트리거 Next
Type : 액션 연산자 - SetTo / Add / Subtract
Player2 : Ctrig2의 트리거 플레이어
Index2 : Ctrig2의 트리거 Index
Address2 : Ctrig2의 트리거의 사용할 부분의 주소
EPD2 : Ctrig2의 트리거 주소 반환값 타입을 선택 (0 = Offset으로 변환 / 1 = EPD로 변환)

Next2 : Ctrig2의 트리거 Next
Mask : 액션 EUDX Mask (기본값 0xFFFFFFFF)
ex) SetCtrigX("X",0x1000,0x17C,1,SetTo,P2,0x1001,0x0,0,0)
→ SetMemoryX(CurrentPlayer의 Label:0x1000인 트리거의 바로 뒤 트리거의 0x17C(2번째 액션의 Value)부분,SetTo
,P2의 Label:0x1001인 트리거의 0x0(Prev)부분,0xFFFFFFFF);

SetCtrigX(P1,"X",0x178,0,Add,P2,0x10,0x15C,1,0,0xFFFFFF)
→ SetMemoryX(P1의 CurrentTrig의 0x178(2번째 액션의 EPD)부분,Add
,EPD(P2의 Label:0x10인 트리거의 0x15C(1번째 액션의 Value)부분),0xFFFFFF);

ex) [예제 3-2] 참고
SetCtrig1X(Player1,Index1,Address1,Next1,Type,Value,Mask)
: 기본 Ctrig 액션, SetMemoryX(EPD(Ctrig),Type,Value,Mask) 형식으로 .py에서 변환됨
Player1 : Ctrig의 트리거 플레이어
Index1 : Ctrig의 트리거 Index
Address1 : Ctrig의 트리거의 사용할 부분의 주소
Next1 : Ctrig의 트리거 Next
Type : 액션 연산자 - SetTo / Add / Subtract
Mask : 액션 EUDX Mask (기본값 0xFFFFFFFF)
ex) SetCtrig1X("X","X",0x15C,0,SetTo,0,0xFFFF)
→ SetMemoryX(CurrentPlayer의 CurrentTrig의 0x15C(1번째 액션의 Value)부분,SetTo,0,0xFFFF);

ex) [예제 3-1] 참고
19

------------------------------------------------------------------------------------------

『 3장 : 기본 내장 조건/액션 함수 (.Py 직접 연동 함수)』

-----------------------------------------------------------------------------------------SetCtrig2X(Offset,Type,Player2,Index2,Address2,EPD2,Next2,Mask)
: 기본 Ctrig 액션, SetMemoryX(Offset,Type,EPD(Ctrig) or Ctrig,Mask) 형식으로 .py에서 변환됨

Offset : 액션 Offset ("Cp" 입력시 CurrentPlayer 입력됨)
Type : 액션 연산자 - SetTo / Add / Subtract
Player2 : Ctrig의 트리거 플레이어
Index2 : Ctrig의 트리거 Index
Address2 : Ctrig의 트리거의 사용할 부분의 주소
EPD2 : Ctrig의 트리거 주소 반환값 타입을 선택 (0 = Offset으로 변환 / 1 = EPD로 변환)

Next2 : Ctrig의 트리거 Next
Mask : 액션 EUDX Mask (기본값 0xFFFFFFFF)
ex) SetCtrig2X("Cp",SetTo,P1,0x10,0x15C,1,0)
→ SetDeathsX(CurrentPlayer,SetTo,EPD(P1의 Label:0x10인 트리거의 0x15C(1번째 액션의 Value)부분),0,0xFFFFFFFF);

※ 트리거의 주소(Address) 부분 설명은 5. 표준 입출력 및 변환 함수 참고

20

------------------------------------------------------------------------------------------

『 4장 : 기본 오류 체크 함수 (선택) 』

-----------------------------------------------------------------------------------------ErrorCheck()
: 기본적인 Ctrig문법 오류를 체크하는 함수
구성 함수 : AllocCheck() - Index 자동 할당 overflow 체크
LabelCheck() - Index 중복 사용 체크
ControlCheck() - 제어문 입력 오류(짝 안맞음 등) 체크
※ 사용시 EndCtrig() 바로 밑에 입력해서 사용해야함

PushErrorMsg(Message)
: 컴파일 시 특정 메시지를 포함한 컴파일 오류창을 띄우는 함수
(사용자 정의 함수 제작시 오류 발생을 알리거나 예외를 처리할 경우 사용)
Message : 출력할 메시지 (스트링으로 입력)
Ex) [예제 4-1] 참고
PushRecoverCpMsg(Flag) ※ 고급
: 해당 함수 실행 후 RecoverCp()가 실행되면 컴파일 오류창을 띄우는 함수
(Cp트릭 사용시 Cp트릭 사용함수의 RecoverCp로 인해 Cp값 변경이 있는지 확인할 때 사용)

Flag : 0 = Push 기능을 끔 / 1 = Push 기능을 켬 (기본값 1)
Ex) [예제 4-2] 참고
PushValueMsg(…)
: 컴파일 시 특정 변수의 값을 띄우는 함수 (디버깅용)
… (가변인자) : 스트링, 변수, 배열(단일만), nil 무제한 입력가능

스트링 & nil & 변수(10진법) : 그대로 입력 (A,B,C,….)
변수(16진법) : {X,"x"} 또는 {X,"X"} 입력
변수(실수형) : {X,"f"} 또는 {X,"F"} 입력
배열 : {Arr,"X"}, {Arr,"x"} (16진법) / {Arr,"F"}, {Arr,"f"} (실수형) / {Arr} (10진법)
Ex) [예제 4-3] 참고

21

------------------------------------------------------------------------------------------

『 5장 : 표준 입출력 및 변환 함수 』

-----------------------------------------------------------------------------------------CAddr(Section,Line,Next)
: Ctrig의 주소(Address) 부분의 입력을 도와주는 함수
Section : 트리거의 구성요소를 선택
Line : 액션/조건 의 줄 수를 입력 (조건 : 1~16 / 액션 : 1~64)
Next : 트리거의 Next를 입력 (주소+0x970*Next)
※ 트리거의 주소(Address)

+0x0 : Prev - 이전 트리거의 주소 ("Prev")
+0x4 : Next - 다음 트리거의 주소 ("Next")
+0x8 + 0x14*i - i번째 줄의 조건의 Mask ("CMask")
+0xC + 0x14*i - i번째 줄의 조건의 EPD ("CEPD")
+0x10 + 0x14*i - i번째 줄의 조건의 Type ("CType")
+0x14 + 0x14*i - i번째 줄의 조건의 Value ("CValue")
+0x18 + 0x14*i - i번째 줄의 조건의 Flag ("CFlag")
+0x148 + 0x20*i - i번째 줄의 액션의 Mask ("Mask")
+0x14C + 0x20*i - i번째 줄의 액션의 StrId ("Str")
+0x150 + 0x20*i - i번째 줄의 액션의 WavId ("Wav")
+0x154 + 0x20*i - i번째 줄의 액션의 Time ("Time")
+0x158 + 0x20*i - i번째 줄의 액션의 EPD ("EPD")
+0x15C + 0x20*i - i번째 줄의 액션의 Value ("Value")

+0x160 + 0x20*i - i번째 줄의 액션의 Type ("Type")
+0x164 + 0x20*i - i번째 줄의 액션의 Flag ("Flag")
+0x948 - "Internal" - 체크 플레이어 및 트리거 Flag
ex) CAddr("Prev") → 0x0 / CAddr("CEPD",2) → 0x20 / CAddr("Value",3,1) → 0x19C + 0x970

Ex) [예제 5-1] 참고

22

------------------------------------------------------------------------------------------

『 5장 : 표준 입출력 및 변환 함수 』

-----------------------------------------------------------------------------------------DtoA(Player,UnitId)
: 일반 데스값의 주소(Offset)값을 가져오는 함수
Player : 데스값의 플레이어 (P1 ~ P12)
UnitId : 유닛 이름 (숫자도 입력가능)

ex) DtoA(P1,"Terran Marine") → 0x58A364 / [예제 5-2] 참고

Forward(Move) ※ 고급
: 제어문의 Index를 가져오는 함수, Struct()와 함께 사용한다.

Move : 리턴할 제어문 index의 위치 편차값 (바로 뒤의 제어문의 index의 위치 = 0)

ex) Forward() → 바로 뒤의 CStruct의 Index 반환 (IndexAlloc을 반환함) / [예제 5-3] 참고

Struct(Type,Number) ※ 고급
: Forward()의 Move를 채울 때 사용하는 함수
Type : 제어문의 종류
Number : 해당 제어문의 갯수
ex) Forward(Struct("CWhile",1)) → Forward(4) → 바로 뒤의 CWhile 뒤의 제어문의 Index를 반환 /

[예제 5-4] 참고

Forward(Struct("CIfX",4)+Struct("DoWhile",1)) → Forward(6) →

바로 뒤의 CIfX CIfX ~ CElseIf ~ CElse ~ CIfXEnd), DoWhile 뒤의 제어문의 Index를 반환
※ CIf : 2 / NIf : 3 / CWhile(CLoop) : 3 / NWhile(NLoop) : 4 / DoWhile : 2
/ CFor : 4 / CIfX : 개당 2 / NIfX : 개당 2 만큼 Index 자동 할당됨

Ccode(Index,Line)
: CDeaths, NDeaths의 식별 Code를 만드는 함수
Index : CVariable의 Index / Line : 데스값을 저장할 위치 (CDeaths : 0~479 / NDeaths : 0~59)

ex) Ccode(0x1000,249) → index : 0x1000인 CVariable의 249번째 칸의 Code를 반환

V(Index,Player,Next)
: 변수 정보를 입력하는 함수

Index : 변수의 Index / Player : 변수의 Player("X"→CurrentPlayer) / Next : 변수의 Next
ex) V(0x10) → CurrentPlayer의 Index:0x10인 변수를 입력 / [예제 5-5] 참고
V(0x10,P1) → P1의 Index:0x10인 변수를 입력
V(0x10,P1,1) → P1의 Index:0x10인 변수의 다음 변수를 입력

Vi(Index,Deviation,Player,Next)
: 변수 정보 + 편차값을 입력하는 함수
Deviation : 편차값 (상수)

ex) V(0x10,1) → CurrentPlayer의 Index:0x10인 변수값 + 1 을 입력 / [예제 5-6] 참고

23

------------------------------------------------------------------------------------------

『 5장 : 표준 입출력 및 변환 함수 』

-----------------------------------------------------------------------------------------X(Lua_Variable)
: V()를 lua 문법으로 편리하게 사용하는 함수

ex) Var1 = {P1,0x10,0}
X(Var1) → P1의 label:0x10인 변수를 입력 / [예제 5-5] 참고
※ Variable 데이터 양식 = {Player,Index,Next,"V"}

Mem(Player,Index,Address,Next,EPDflag)
: Ctrig메모리의 주소를 입력하는 함수
Player : 트리거의 Player
Index : 트리거의 Index
Address : 선택할 부분의 Address
Next : 트리거의 Next
EPDflag : SetMemX, T액션의 Value부분에 Ctrig주소를 입력할 방식을 선택 (0 = Value, 1 = EPD), (기본값 0)

ex) Mem(P1,0x10,0x15C,1) → P1의 Index:0x10인 트리거의 바로 다음 트리거의 0x15C부분을 입력
Mem(P1,0x10,0x158,0,1) → EPD(P1의 Index:0x10인 트리거의 0x158부분의 주소)를 입력 / [예제 5-5] 참고

_Mem(Variable,Address,Next,EPDflag)
: 변수 데이터를 Ctrig메모리 데이터로 변환하는 함수
Variable : 변수 데이터 (V, VArr(상수인덱스)) 입력
Address : 변수 트리거의 선택할 영역의 주소 (기본값 0x15C)
Next : 변수 트리거의 Next (기본값 0)
EPDflag : SetMemX, T액션의 Value부분에 Ctrig주소를 입력할 방식을 선택 (0 = Value, 1 = EPD), (기본값 0)

ex) _Mem(V(0x10)) → Mem("X",0x10,0x15C,0) / [예제 5-5] 참고
_Mem(V(0x10,P1,1),0x4,2,1) → Mem(P1,0x10,0x4,1+2,1)

_Ccode(Player,Code,EPDflag)
: CDeaths 데이터를 Ctrig메모리 데이터로 변환하는 함수
Player : CDeaths 플레이어 입력("X" / P1~P8)
Code : CDeaths Code() 값 입력
EPDflag : SetMemX, T액션의 Value부분에 Ctrig주소를 입력할 방식을 선택 (0 = Value, 1 = EPD), (기본값 0)

ex) [예제 8-3] 참고

_Ncode(Player,Code,EPDflag)
: NDeaths 데이터를 Ctrig메모리 데이터로 변환하는 함수
Player : NDeaths 플레이어 입력(P1~P8)
Code : NDeaths Code() 값 입력
EPDflag : SetMemX, T액션의 Value부분에 Ctrig주소를 입력할 방식을 선택 (0 = Value, 1 = EPD), (기본값 0)

ex) [예제 8-3] 참고

24

------------------------------------------------------------------------------------------

『 5장 : 표준 입출력 및 변환 함수 』

-----------------------------------------------------------------------------------------Arr(Array,Index,Player)
: 메모리 배열의 주소를 입력하는 함수
Array : 배열 헤더 (CArray 리턴값 입력)
Index : 배열의 인덱스 : 상수 or 변수 입력 - Vi 입력 가능
Player : 배열의 Player 입력 (기본값 "X")
ex) Arr(Arr1,0) → Arr1[0]의 주소를 반환함 / [예제 5-6] 참고

Arr(Arr1,V(0x10),P1) → P1의 Arr1[V(0x10)]의 주소를 반환함
Arr(Arr1,Vi(0x10,12)) → Arr1[V(0x10)+12]의 주소를 반환함
※ Arr의 인덱스는 0부터 시작함 / 상수 인덱스 : Mem 타입 반환 / 변수 인덱스 : Arr 타입 반환

ArrX(Array,Index,Player)
: Arr()의 최적화용 함수
Index가 상수 → Arr()과 동일함
Index가 변수 → Index에 ConvertArr의 Dest에 넣었던 변수를 입력 (Index에 Vi 입력 불가)

ex) ArrX(Arr1,0) : Arr(Arr,0)과 동일 / [예제 5-6] 참고
ArrX(Arr1,V(0x10),P1) : ConvertArr 부분 참고
ArrX(Arr1,Vi(0x10,12)) : 사용불가

ConvertArr(PlayerID,Dest,Source)
: Arr, ArrX용 인덱스값 변환 함수
PlayerID : 트리거 체크 플레이어
Dest : ((Source+Vi)/301)&0xFFFFFFFE) (epd) (인덱스값을 Arr에 맞게 변환)

Source : 배열의 변수 Index (V(i) 입력 가능)
ex) [예제 5-6] 참고
※ TRIG 단락 Ctrig영역 중 0x968, 0x96C부분은 지원하지 않는 오프셋으로,
맵 실행 도중 EUD에러에 걸리지 않게 이 부분을 자동으로 건너뛰는 기능을 함
※ 변수 Index가 602*4 이하인 경우 연산 없이 바로 건너뜀

25

------------------------------------------------------------------------------------------

『 5장 : 표준 입출력 및 변환 함수 』

-----------------------------------------------------------------------------------------VArr(VArray,Index,Player)
: 변수 배열을 입력하는 함수
VArray : 변수배열 헤더 (CVArray 또는 GetVArray의 리턴값 입력)
Index : 변수배열의 인덱스 : 상수 or 변수 입력 - Vi 입력 가능
Player : 변수배열의 Player 입력 (기본값 "X")
ex) VArr(VArr1,0) → VArr1[0]를 반환함 / [예제 5-7] 참고

VArr(VArr1,V(0x10),P1) → P1의 VArr1[V(0x10)]를 반환함
VArr(VArr1,Vi(0x10,12)) → VArr1[V(0x10)+12]를 반환함
※ VArr의 인덱스는 0부터 시작함 / 상수 인덱스 : 변수 타입 반환 / 변수 인덱스 : VArr 타입 반환

VArrX(VArray,Index,Index4,Player)
: VArr()의 최적화용 함수
Index가 상수 → Index4는 입력 필요X
Index가 변수 → Index, Index4에 각각 ConvertVArr의 Dest, Dest4에 넣었던 변수를 입력

(Index에 Vi 입력 가능, 입력시 Index4 자동적용)
ex) VArrX(VArr1,0) : VArr(VArr,0)과 동일 / [예제 5-7] 참고
VArrX(VArr1,V(0x10),V(0x11),P1) : ConvertVArr 부분 참고
VArrX(VArr1,Vi(0x10,12),V(0x11)) : ConvertVArr 부분 참고

ConvertVArr(PlayerID,Dest,Dest4,Source,Size)
: VArr, VArrX용 인덱스값 변환 함수
PlayerID : 트리거 체크 플레이어

Dest : (Source+Vi)*604 (epd), Dest4 : (Source+Vi)*2416 (Offset) (인덱스값을 VArr에 맞게 변환)
Source : 배열의 변수 Index (V(i) 입력 가능)
Size : 배열의 크기 (최적화용, 기본값 4095)
ex) [예제 5-7] 참고
※ VArray의 간격은 0x970으로, Dest에는 *604(epd), Dest4에는 *2416(Offset)을 대입함 (각각 Index, Index4)

26

------------------------------------------------------------------------------------------

『 6장 : 변수/배열 선언 및 호출 함수 』

-----------------------------------------------------------------------------------------※ 변수 선언 함수는 반드시 Tep 맨 위의 CJump(0) 사이에 넣어야 합니다.
(단, 특정 위치에서 항상 실행되게 사용하려면 상관없음)

CVariable(Player,Index)
: 변수 선언 함수
Player : 변수 트리거의 체크 플레이어
Index : 변수 트리거의 할당할 Index
ex) CVariable(P1,0x10) → P1의 Index:0x10인 변수 선언 (GetVArray로 VArray처럼 사용가능)
for i = 0x10, 0x1F do CVariable(Force1,i) end → Force1의 Index:0x10~0x1F인 변수16개 연속해서 선언

CVariable2(Player,Index,Offset,Type,Value,Mask)
: CVariable()에서 초기값을 설정할 수 있는 함수
Player : 변수 트리거의 체크 플레이어
Index : 변수 트리거의 할당할 Index
Offset : 변수 트리거의 초기 Offset값 (기본값 0x58A364)
Type : 변수 트리거의 초기 Type값 (기본값 SetTo)
Value : 변수 트리거의 초기 Value값 (기본값 0)
Mask : 변수 트리거의 초기 Mask값 (기본값 0xFFFFFFFF)
ex) CVariable2(P1,0x10) → P1의 Index:0x10인 변수 선언 - SetMemoryX(0x58A364,SetTo,0,0xFFFFFFFF); 적용
CVariable2(P1,0x10,0x58F500,Add,1234,0xFFFF) → P1의 Index:0x10인 변수 선언 - SetMemoryX(0x58F500,Add,1234,0xFFFF); 적용

CDb(PlayerID,ByteSize)
: ByteSize 만큼의 CArray를 할당해주는 함수 (ByteSize가 0x1000000이상이면 할당 불가)
PlayerID : 배열 트리거의 체크 플레이어
ByteSize : 선언할 배열의 용량 (ByteSize가 0x400000이상이면 할당 불가)
ex) Arr1 = CDb(P1,0x4000) → 0x4000을 담을수있는 P1 CArray를 선언

CArray(PlayerID,Size)
: Size 만큼의 크기를 갖는 CArray를 선언하는 함수 (Size가 2465792이상이면 선언 불가)
PlayerID : 배열 트리거의 체크 플레이어
Size : 선언할 배열의 크기 (Size가 618496이상이면 선언 불가)
ex) Arr1 = CArray(P1,100) → Arr1[0] ~ Arr1[99] 까지 사용가능한 P1 CArray를 선언
※ CArray의 값은 맵 실행시 초기화를 따로 시켜줘야합니다. (기본값이 0이 아닐수 있음)

27

------------------------------------------------------------------------------------------

『 6장 : 변수/배열 선언 및 호출 함수 』

-----------------------------------------------------------------------------------------CVArray(PlayerID,Size)
: Size 만큼의 크기를 갖는 CVArray를 선언하는 함수
PlayerID : 배열 트리거의 체크 플레이어
Size : 선언할 배열의 크기 (Size가 4096이상이면 선언 불가)
ex) VArr1 = CVArray(P1,100) → VArr1[0] ~ VArr1[99] 까지 사용가능한 P1 CVArray를 선언

GetVArray(Header,Size)
: 연속된 CVariable을 VArray로 묶어주는 함수 (index 범위는 연속된 변수가 끝날 때까지)
Header : 변수 배열의 시작점 (V타입 변수를 입력, 인덱스 0번 변수가 됨)
Size : 배열의 크기 (최적화용, 기본값 4095)
ex) VArr1 = GetVArray(V(0x10)) → V(0x10)을 시작위치로 갖는 VArray를 선언 / [예제 6-1] 참고
VArr1 = GetVArray(V(0x10,"X",4)) → V(0x10)의 4칸 뒤의 변수를 시작위치로 갖는 VArray를 선언

28

------------------------------------------------------------------------------------------

『 6장 : 변수/배열 선언 및 호출 함수 』

-----------------------------------------------------------------------------------------CallLabel1(Player,Index,Next)
: 특정 플레이어 Label이 Index인 변수를 호출할때 사용 (액션5개) (RecoverNext 사용)
Player : 호출트리거의 체크 플레이어 (P1 ~ P8,"X"=CurrentPlayer)
Index : 호출트리거의 Index
Next : 호출트리거의 Next

CallLabel2(Player,Index,Next)
: CallLabel1과 함께 사용하는 함수 (바로 다음 트리거에 삽입) (액션1개)
Player, Index, Next는 CallLabel1과 동일하게 입력
ex) DoActionsX(P1,CallLabel1(P2,0x10)) → P2의 index:0x10인 트리거 호출 (RecoverNext 사용)
DoActionsX(P1,CallLabel2(P2,0x10)) → P2의 index:0x10인 트리거의 RecoverNext Flag 복구
※ CallLabel1과 CallLabel2는 반드시 함께 사용해야 합니다.
ex) [예제 6-1] 참고

CallLabelAlways(Player,Index,Next)
: 특정 플레이어 Label이 Index인 변수를 호출할때 사용 (액션2개) (RecoverNext 사용안함)
Player : 호출트리거의 체크 플레이어 (P1 ~ P8,"X"=CurrentPlayer)
Index : 호출트리거의 Index
Next : 호출트리거의 Next
ex) DoActionsX(P1,CallLabelAlways(P2,0x10)) → P2의 index:0x10인 트리거 호출 (RecoverNext 사용안함)

※ CallLabelAlways를 사용하는 트리거는 반드시 조건이 Label(0); 하나뿐이여야 합니다.
(Always() 같은 트리거 실행에 영향 안주는 조건도 가능)

CallVariable(PlayerID,Player,Index,Next,Conditions,Actions)
: 변수를 호출하는 트리거 생성 함수
PlayerID : 트리거의 체크 플레이어
Player : 호출트리거의 체크 플레이어 (P1 ~ P8,"X"=CurrentPlayer)
Index : 호출트리거의 Index
Next : 호출트리거의 Next
Conditions : 트리거의 조건 (비우면 RecoverNext 사용안함)
Actions : 트리거의 액션
ex) CallVariable(P1,P2,0x10,0,"X") → P2의 index:0x10인 변수를 호출하는 P1트리거 생성 (RecoverNext 사용안함)

CallVariable(P1,P2,0x10,0,{Memory(0x58DC60,AtLeast,1)})
→ P2의 index:0x10인 변수를 호출하는 P1트리거 생성 (RecoverNext 사용)
ex) [예제 6-1] 참고

29

------------------------------------------------------------------------------------------

『 6장 : 변수/배열 선언 및 호출 함수 』

-----------------------------------------------------------------------------------------CallLabel1X(Variable)
: CallLabel1의 호출할 변수 정보를 변수 데이터로 입력받는 버전 / Variable에 V()를 입력

CallLabel2X(Variable)
: CallLabel2의 호출할 변수 정보를 변수 데이터로 입력받는 버전 / Variable에 V()를 입력
ex) [예제 6-1] 참고

CallLabelAlwaysX(Variable)
: CallLabelAlways의 호출할 변수 정보를 변수 데이터로 입력받는 버전 / Variable에 V()를 입력

CallVariableX(PlayerID,Variable,Conditions,Actions)
: CallVariable의 호출할 변수 정보를 변수 데이터로 입력받는 버전 / Variable에 V()를 입력

CallLabelAlways2(Player,Index,Next,Player2,Index2,Next2)
: 2개의 변수를 한번에 호출할 때 사용 (액션3개) (RecoverNext 사용안함)
실행 순서 : CallLabel → Index → Index2 → CallLabel 다음트리거
Player(2), Index(2), Next(2)는 모두 CallLabelAlways와 동일

CallLabelAlways3(Player,Index,Next,Player2,Index2,Next2,Player3,Index3,Next3)
: 3개의 변수를 한번에 호출할 때 사용 (액션4개) (RecoverNext 사용안함)
실행 순서 : CallLabel → Index → Index2 → Index3 → CallLabel 다음트리거
Player(2,3), Index(2,3), Next(2,3)는 모두 CallLabelAlways와 동일

CallLabelAlways4(Player,Index,Next,Player2,Index2,Next2,Player3,Index3,Next3,Player4,Index4,Next4)
: 4개의 변수를 한번에 호출할 때 사용 (액션5개) (RecoverNext 사용안함)
실행 순서 : CallLabel → Index → Index2 → Index3 → Index4 → CallLabel 다음트리거
Player(2,3,4), Index(2,3,4), Next(2,3,4)는 모두 CallLabelAlways와 동일

CallLabelAlways2X(Variable,Variable2)
: CallLabelAlways2의 호출할 변수 정보를 변수 데이터로 입력받는 버전 / Variable(2)에 V()를 입력

CallLabelAlways3X(Variable,Variable2,Variable3)
: CallLabelAlways3의 호출할 변수 정보를 변수 데이터로 입력받는 버전 / Variable(2,3)에 V()를 입력

CallLabelAlways4X(Variable,Variable2,Variable3,Variable4)
: CallLabelAlways2의 호출할 변수 정보를 변수 데이터로 입력받는 버전 / Variable(2,3,4)에 V()를 입력

CallLabelAlwaysN(...)
: 여러개의 변수를 한번에 호출할 때 사용 (액션n+1개) (RecoverNext 사용안함) / Variable(2,3,4,…)에 V()를 입력

Ex) [예제 6-2] 참고
※ CallLabelAlways류 함수를 사용하는 트리거는 반드시 조건이 Label(0); 하나뿐이여야 합니다.

30

------------------------------------------------------------------------------------------

『 7장 : DoActions류 트리거 생성 함수 』

-----------------------------------------------------------------------------------------DoActions(PlayerID,Actions,flag)
: 조건 없이 액션만을 실행하는 트리거를 생성하는 함수
PlayerID : 트리거의 체크 플레이어

Actions : 실행할 액션 - {액션1,액션2,...} 형태로 입력해야함
flag : Preserve 옵션 선택 (비우면 Preserved, 값 입력시 한번만 실행)
ex) DoActions(P1,{Wait(0),SetDeaths(P1,SetTo,0,0)})
DoActions2(PlayerID,Actions,flag)
: DoActions() 에서 액션 갯수의 제한이 없는 함수
사용법은 DoActions와 동일함
Trigger2(Player, Conditions, Actions, Flags)
: Trigger에서 액션 갯수의 제한이 없는 함수
PlayerID : 트리거의 체크 플레이어
Conditions : 검사할 조건 - {조건1,조건2,…} 형태로 입력해야함 (최대 16개)
Actions : 실행할 액션 - {액션1,액션2,…} 형태로 입력해야함 (제한 없음)
Flags : 트리거의 Flag ({Flag1,Flag2,…} 형태로 입력)
Ex) Trigger2({P1,P2},{Always()},{SetDeaths(P1,SetTo,0,0)},{Preserved})
DoActionsX(PlayerID,Actions,flag,Index)
: DoActions()에서 조건에 Label(Index)를 추가해 Ctrig액션을 사용할 수 있는 함수
Index에 숫자를 넣어 Label에 Index 삽입가능 (기본값 0)
나머지는 DoActions와 동일함
Ex) [예제 7-1] 참고, [예제 7-2] 참고
DoActions2X(PlayerID,Actions,flag)

: DoActions2()에서 조건에 Label(0)을 추가해 Ctrig액션을 사용할 수 있는 함수
사용법은 DoActions2와 동일함
※ DoActions2(X)의 액션 무제한 삽입 가능 함수는 액션 64개 초과시 트리거를 붙여서 추가생성함

31

------------------------------------------------------------------------------------------

『 7장 : DoActions류 트리거 생성 함수 』

-----------------------------------------------------------------------------------------TriggerX(Player, Conditions, Actions, Flags, Index)
: Trigger에서 조건에 Label(Index)를 추가해 Ctrig조건/액션을 사용할 수 있는 함수
Index에 숫자를 넣어 Label에 Index 삽입가능 (기본값 0)

나머지는 Trigger와 동일함
Ex) [예제 7-1] 참고, [예제 7-2] 참고
Trigger2X(Player, Conditions, Actions, Flags)
: Trigger2에서 조건에 Label(0)을 추가해 Ctrig조건/액션을 사용할 수 있는 함수
사용법은 Trigger2와 동일함
※ Trigger2(X)의 액션 무제한 삽입 가능 함수는 액션 64개 초과시 트리거를 붙여서 추가생성함

｡˙+ﾟ Cstruct 함수 (Ctrig 구조체) ｡+.ﾟ
CDoActions(PlayerID,Actions,flag,Index)
: DoActionsX와 동일하나, T/TT 액션 사용가능 (Cstruct)
Index에 숫자를 넣어 Label에 Index 삽입가능 (기본값 0)
Ex) [예제 16-1] 참고

CTrigger(PlayerID, Conditions, Actions, Flags, Index)
: TriggerX와 동일하나, T/TT 조건/액션 사용가능 (Cstruct)

Flags에 1 입력시 {Preserved}로 입력됨
Index에 숫자를 넣어 Label에 Index 삽입가능 (기본값 0)
Ex) [예제 16-2] 참고

32

------------------------------------------------------------------------------------------

『 8장 : Ctrig 파생 조건/액션 함수 』

-----------------------------------------------------------------------------------------SetNext(Index1,Index2,Next) ※ 고급
: 트리거의 Next를 변경하는 함수(단일 액션) - 타겟 플레이어는 CurrentPlayer로 설정
Index1 : Next를 변경할 트리거의 Index
Index2 : 변경된 Next의 목표 트리거의 Index
Next : 목표 트리거의 Next (기본값 0) - Index1 → (Index2_Next)
ex) SetNext(0x10,0x11) → index:0x10 트리거의 Next를 index:0x11인 트리거로 변경함 / [예제 8-1] 참고
SetNext(0x10,0x11,1) → index:0x10 트리거의 Next를 index:0x11인 트리거의 바로 뒤 트리거로 변경함

MemX(Mem,Type,Value,Mask)
: Mem 타입 전용 CtrigX 조건
Mem : Mem 데이터 입력
Type : 조건 연산자 - AtMost, Exactly, AtLeast
Value : 조건 연산값 / Mask : eudx 비트마스크 (기본값 0xFFFFFFFF)
ex) [예제 8-4] 참고
SetMemX(Mem1,Type,Mem2,Mask)
: Mem 타입 전용 CtrigX 액션
Mem1 : Mem 데이터 입력 (Offset) - 상수 입력 가능 (Offset 입력)
Mem2 : Mem 데이터 입력 (Value) - EPDflag 1이면 EPD값을 입력함, 상수 입력 가능
Type : 액션 연산자 - Add, SetTo, Subtract
Value : 액션 연산값 / Mask : eudx 비트마스크 (기본값 0xFFFFFFFF)
ex) [예제 8-4] 참고

33

------------------------------------------------------------------------------------------

『 8장 : Ctrig 파생 조건/액션 함수 』

-----------------------------------------------------------------------------------------VariableX(Player,Index,Section,Type,Value,Mask)
: 변수 전용 CtrigX 조건
Player : 변수의 플레이어
Index : 변수의 Index
Section : 선택할 변수의 영역 - "EPD"(0x158), "Value"(0x15C), "Next"(0x4), "Mask"(0x148),
"Type"(0x160) - (Mask 비우면 0xFF000000), "Flag"(0x164) - (Mask 비우면 0xFF)
Type : 조건 연산자 - AtMost, Exactly, AtLeast
Value : 조건 연산값 / Mask : eudx 비트마스크 (기본값 0xFFFFFFFF)
ex) VariableX(P1,0x10,"Value",Exactly,10) → MemoryX(P1의 0x10변수의 Value부분,Exactly,10,0xFFFFFFFF);

SetVariableX(Player,Index,Section,Type,Value,Mask)
: 변수 전용 SetCtrig1X 액션
Player : 변수의 플레이어
Index : 변수의 Index
Section : 선택할 변수의 영역 - "EPD"(0x158), "Value"(0x15C), "Next"(0x4), "Mask"(0x148),
"Type"(0x160) - (Mask 비우면 0xFF000000), "Flag"(0x164) - (Mask 비우면 0xFF)
Type : 액션 연산자 - Add, SetTo, Subtract
Value : 액션 연산값 / Mask : eudx 비트마스크 (기본값 0xFFFFFFFF)
ex) SetVariableX(P1,0x10,"Type",SetTo,0x10)
→ SetMemoryX(P1의 0x10변수의 Type부분,SetTo,0x10,0xFF000000);
ex) [예제 8-2] 참고
Variable(Variable,Section,Type,Value,Mask)
: VariableX에서 변수 정보를 변수 데이터로 입력받는 버전
Variable : 입력할 변수의 데이터 (V()로 입력)
나머지는 VariableX와 동일함
ex) Variable(V(0x10,P1),"Value",Exactly,10) → MemoryX(P1의 0x10변수의 Value부분,Exactly,10,0xFFFFFFFF);

SetVariable(Variable,Section,Type,Value,Mask)

: SetVariableX에서 변수 정보를 변수 데이터로 입력받는 버전
Variable : 입력할 변수의 데이터 (V()로 입력)
나머지는 VariableX와 동일함
ex) SetVariable(V(0x10,P1),Type",SetTo,0x10)
→ SetMemoryX(P1의 0x10변수의 Type부분,SetTo,0x10,0xFF000000);

34

------------------------------------------------------------------------------------------

『 8장 : Ctrig 파생 조건/액션 함수 』

-----------------------------------------------------------------------------------------VArrayX(VArray,Section,Type,Value,Mask)
: 변수배열 상수인덱스 전용 CtrigX 조건
VArray : 변수배열 헤더 (CVArray, GetVArray 리턴값)
Section : 선택할 변수의 영역 - "EPD"(0x158), "Value"(0x15C), "Next"(0x4), "Mask"(0x148),
"Type"(0x160) - (Mask 비우면 0xFF000000), "Flag"(0x164) - (Mask 비우면 0xFF)
Type : 조건 연산자 - AtMost, Exactly, AtLeast
Value : 조건 연산값 / Mask : eudx 비트마스크 (기본값 0xFFFFFFFF)
ex) VArrayX(VArr(VArr1,0x10),"Value",Exactly,10)
→ MemoryX(VArr1[0x10]의 Value부분,Exactly,10,0xFFFFFFFF);

SetVArrayX(VArray,Section,Type,Value,Mask)
: 변수배열 상수인덱스 전용 SetCtrig1X 조건
Player : 변수의 플레이어
Index : 변수의 Index
Section : 선택할 변수의 영역 - "EPD"(0x158), "Value"(0x15C), "Next"(0x4), "Mask"(0x148),
"Type"(0x160) - (Mask 비우면 0xFF000000), "Flag"(0x164) - (Mask 비우면 0xFF)
Type : 액션 연산자 - Add, SetTo, Subtract
Value : 액션 연산값 / Mask : eudx 비트마스크 (기본값 0xFFFFFFFF)
ex) SetVArrayX(VArr(VArr1,0x10),"Type",SetTo,10)
→ SetMemoryX(VArr1[0x10]의 Value부분,SetTo,10,0xFF000000);

ex) [예제 8-2] 참고
CVar(Player,Index,Type,Value,Mask)
: VariableX에서 Section이 "Value"(0x15C)로 설정된 버전, 나머지는 VariableX와 사용법 동일함

SetCVar(Player,Index,Type,Value,Mask)
: SetVariableX에서 Section이 "Value"(0x15C)로 설정된 버젼, 나머지는 SetVariableX와 사용법 동일함

NVar(Variable,Type,Value,Mask)
: Variable에서 Section이 "Value"(0x15C)로 설정된 버전, 나머지는 Variable와 사용법 동일함

SetNVar(Variable,Type,Value,Mask)
: SetVariable에서 Section이 "Value"(0x15C)로 설정된 버젼, 나머지는 SetVariable와 사용법 동일함

CVAar(VArray,Type,Value,Mask)
: VArrayX에서 Section이 "Value"(0x15C)로 설정된 버젼, 나머지는 VArrayX와 사용법 동일함

SetCVAar(VArray,Type,Value,Mask)
: SetVArrayX에서 Section이 "Value"(0x15C)로 설정된 버젼, 나머지는 SetVArrayX와 사용법 동일함

35

------------------------------------------------------------------------------------------

『 8장 : Ctrig 파생 조건/액션 함수 』

-----------------------------------------------------------------------------------------CDeaths(Player,Type,Value,Code)
: 확장 데스값 조건
Player : 기준 변수의 Player
Type : 조건 연산자 - Exactly / AtMost / AtLeast
Value : 조건 연산값

Code : CDeaths 용 Code - Ccode() 리턴값 입력
ex) [예제 8-3] 참고

CDeathsX(Player,Type,Value,Code,Mask)
: CDeaths의 eudx 버전, Mask : 비트마스크 (나머지는 CDeaths와 동일함)

SetCDeaths(Player,Type,Value,Code)
: 확장 데스값 액션
Player : 기준 변수의 Player
Type : 액션 연산자 - SetTo / Add / Subtract / Value : 액션 연산값
Code : CDeaths 용 Code - Ccode() 리턴값 입력

SetCDeathsX(Player,Type,Value,Code,Mask)
: SetCDeaths의 eudx 버전, Mask : 비트마스크 (나머지는 SetCDeaths와 동일함)

NDeaths(Player,Type,Value,Code)
: 플레이어 고정형 확장 데스값 조건
Player : 기준 변수의 Player ("X" 입력 불가, 반드시 P1 ~ P8중 하나여야함)
Type : 조건 연산자 - Exactly / AtMost / AtLeast
Value : 조건 연산값
Code : NDeaths 용 Code - Ncode() 리턴값 입력
ex) [예제 8-3] 참고

NDeathsX(Player,Type,Value,Code,Mask)
: NDeaths의 eudx 버전, Mask : 비트마스크 (나머지는 NDeaths와 동일함)

SetNDeaths(Player,Type,Value,Code)
: 플레이어 고정형 확장 데스값 액션
Player : 기준 변수의 Player ("X" 입력 불가, 반드시 P1 ~ P8중 하나여야함)
Type : 액션 연산자 - SetTo / Add / Subtract / Value : 액션 연산값
Code : NDeaths 용 Code - Ncode() 리턴값 입력

SetNDeathsX(Player,Type,Value,Code,Mask)
: SetNDeaths의 eudx 버전, Mask : 비트마스크 (나머지는 SetNDeaths와 동일함)

36

------------------------------------------------------------------------------------------

『 9장 : Cp트릭 관련 및 CunitCtrig 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 주의 : Cp트릭 사용법을 모르면 이 함수들의 사용을 권장하지 않습니다. ｡+.ﾟ

RecoverCp(PlayerID)
: Cp(0x6509B0)값을 복구하는 트리거 생성 함수 (기본 RecoverCp값 : "X" (CurrentPlayer))

PlayerID : 생성 트리거의 체크 플레이어

SetRecoverCp(Cp)
: RecoverCp의 복구값을 지정하는 함수 (순수 lua함수)
Cp : 지정할 복구값 ("X",상수,V(i) 입력 가능)
(기본값 : CurrentPlayer로 복구, 상수 : 입력된 상수로 복구, 변수(V(i)) : 입력된 변수로 복구)
ex) [예제 9-1] 참고

MoveCp(Type,Value)
: Cp트릭에서 Cp값을 편리하게 조작하는 함수 (Value는 Offset 단위로 입력)
Type : Cp값 조작 연산자
(비우면 현재 Cp변화량을 리턴함, "X" 또는 "Clear" 입력시 Cp변화량을 Value로 설정함)
Add 입력시 Value만큼 Cp값을 더함, Subtract 입력시 Value만큼 Cp값을 뺌(iSub연산),
SetTo 입력시 Value로 Cp값을 옮김
ex) [예제 9-2] 참고
※ 주의 : Cp트릭 도중에 조건이 있는 트리거에 의해서 Cp값의 변동이 있는경우
반드시 해당 트리거의 마지막 액션에 해당 트리거 실행 이전의 Cp값으로 돌려놔야함

SaveCp(PlayerID,Output,OffsetOutput)
: 현재 Cp값을 변수에 백업하는 함수 (Cp트릭 사용시 필수)
PlayerID : 생성 트리거의 체크 플레이어
Output : Cp(0x6509B0)의 값(epd)를 저장할 변수 (V입력)
OffsetOutput : Cp값(Offset)을 저장할 변수 (비우면 사용X, V입력)
ex) [예제 9-2] 참고

LoadCp(PlayerID,Cp)
: Cp값을 백업한 변수로 Cp값을 복구하는 함수 (Cp트릭 사용시 필수)

PlayerID : 생성 트리거의 체크 플레이어
Cp : 복구할 Cp값이 들어있는 변수
(비우면 CurrentPlayer로, 상수 입력시 상수값으로, V(i) 입력시 변수값으로 복구함)
ex) [예제 9-2] 참고
※ LoadpCp 사용후 RecoverCp의 지정된 복구값이 Cp에 입력한 값으로 자동 변경됨

LoadCpX(PlayerID,Cp)
: LoadCp와 동일하나, 현재 저장된 RecoverCp의 복구값을 Cp복구 후에도 유지하는 함수
사용법은 LoadCp와 동일함

37

------------------------------------------------------------------------------------------

『 9장 : Cp트릭 관련 및 CunitCtrig 함수 』

-----------------------------------------------------------------------------------------CunitCtrig_Part1(PlayerID,Actions)
- NJump Trig 삽입 부분 (조건만족시 Jump) -

｡˙+ﾟ CunitCtrig 함수. ｡+.ﾟ

CunitCtrig_Part2()
- Cunit 연산 트리거 삽입 부분 (Break/Clear로 Return) -

CunitCtrig_Part3(Conditions,Actions)
: EUDLoopUnit 최적화 버전
Part1 : CunitCtrig 헤더+Calc Selector - PlayerID : 체크 플레이어(P1~P8)
,Actions : Calc Selector에 추가할 Actions
Part2 : Cunit Calc Last
Part3 : Cunit Calc Main(i=0~1699) - Conditions : Calc에 추가할 조건
,Actions : Calc에 추가할 액션 / MoveCp가 초기화됨
ex) [예제 9-3] 참고

CunitCtrig_Part3X()
for i = 0, 1699 do

CunitCtrig_Part4X(LoopIndex,Conditions,Actions)
end

CunitCtrig_End()
: Cunit Ctrig 수동 루프 버젼
Part1 : CunitCtrig 헤더+Calc Selector - PlayerID : 체크 플레이어(P1~P8)
,Actions : Calc Selector에 추가할 Actions
Part2 : Cunit Calc Last
Part3 : Cunit Calc Start
Part4 : Cunit Calc Main(루프 필요) - Conditions : Calc에 추가할 조건
,Actions : Calc에 추가할 액션 / MoveCp가 초기화됨
End : Cunit Ctrig 선언 종료
ex) [예제 9-4] 참고
※ CunitCtrig 함수는 0x628298부터 0x150씩 감소하는 형태로 Loop를 도는 형태임

ClearCalc()
: Cunit Ctrig 연산 단락을 종료하는 함수 : 실행시 Cunit Calc Last 로 점프함
ex) [예제 9-3] 참고

BreakCalc(Conditions,Actions)
: Cunit Ctrig 연산을 도중에 종료하는 함수 : 조건 만족시 Cunit Calc Last 로 점프함 (RecoverNext 사용)
ex) [예제 9-3] 참고

38

------------------------------------------------------------------------------------------

『 10장 : 제어문 관련 함수 (CStruct) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ CStruct에만 T/TT 조건/액션을 사용할 수 있습니다. ｡+.ﾟ
SLoopN(PlayerID,Repeat,Conditions,Actions,InitActions,Single)
또는

SLoopN(PlayerID,Repeat,Conditions,Actions,InitActions)
~ 적용할 트리거 ~

SLoopNEnd(Actions)
: 조건 만족시 트리거(단락)을 횟수만큼 반복하는 함수 (초소형 루프문) - 단락 내부에서 Jump로 탈출 가능

PlayerID : 체크 플레이어
Repeat : 반복할 횟수 (변수 삽입가능) - 변수 삽입시 (V의 값/4) 만큼 반복함
상수입력 : 상수, 변수 입력 : {V(),최대 반복 횟수(상수)} 형식으로 입력
Conditions : 루프문을 실행할 조건
Actions : 루프문 내부에서 실행할 액션

InitActions : 루프문을 시작하기전 실행할 액션 (T액션 사용가능)
Single : 비워둘 경우 SLoopN ~ SLoopNEnd 내부의 트리거를 반복문 단락으로 포함시킴
1 입력시 단일 트리거 루프문으로 설정함 (액션 입력시 단일 트리거문 종료 후 실행시킬 액션으로 입력됨)

Actions(SLoopNEnd) : 트리거 단락 반복문 종료 후 실행시킬 액션
Ex) [예제 10-E] 참고

CJump(PlayerID,sIndex)
~ 적용할 트리거 ~

CJumpEnd(PlayerID,sIndex)
: 조건없이 트리거를 점프하는 함수 (Jump문) - 전방/후방 점프 가능
PlayerID : 점프 트리거의 체크 플레이어
sIndex : 0x0 ~ 0xFFF (Jump 인덱스) 입력
CJump → CJumpEnd로 점프하며, 반드시 한쌍을 이뤄야함 (PlayerID와 sIndex 동일)
ex) [예제 10-A] 참고

SetCJump(sIndex,Status,NewDest) ※ 고급
: CJump의 상태를 조작하는 액션 (CurrentPlayer 고정)
sIndex : 조작할 CJump의 Jump 인덱스
Status : 1 또는 "On" 입력시 CJump를 실행상태로 변경함 / 아닐시 CJump를 비활성화시킴
NewDest : 새로운 목적지의 Jump 인덱스 - CJump의 목적지를 NewDest로 변경함
ex) [예제 10-A] 참고
39

------------------------------------------------------------------------------------------

『 10장 : 제어문 관련 함수 (CStruct) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ CStruct에만 T/TT 조건/액션을 사용할 수 있습니다. ｡+.ﾟ
NJump(PlayerID,sIndex,Conditions,Actions)
~ 적용할 트리거 ~

NJumpEnd(PlayerID,sIndex,Actions_Always)
: 조건 만족시 트리거를 점프하는 함수 (Jump문) - 전방/후방 점프 가능
PlayerID : 점프 트리거의 체크 플레이어
sIndex : 0x0 ~ 0xFFF (Jump 인덱스) 입력
Conditions : 점프를 실행할 조건
Actions : 조건만족시 실행할 액션 (T액션 사용가능)
NJump → NJumpEnd로 점프하며, 반드시 한쌍을 이뤄야함 (PlayerID와 sIndex 동일)
ex) [예제 10-A] 참고

CJumpX(PlayerID,sIndex)
~ 적용할 트리거 ~

CJumpXEnd(PlayerID,sIndex)
: 조건없이 트리거를 점프하는 함수 (Jump문) - 전방/후방 점프 가능 (CJumpX는 다수입력 가능)
PlayerID : 점프 트리거의 체크 플레이어
sIndex : 0x0 ~ 0xFFF (Jump 인덱스) 입력
CJumpX → CJumpXEnd로 점프하며, 반드시 최소 한쌍을 이뤄야함 (PlayerID와 sIndex 동일)
ex) [예제 10-F] 참고

NJumpX(PlayerID,sIndex,Conditions,Actions)
~ 적용할 트리거 ~

NJumpXEnd(PlayerID,sIndex,Actions)
: 조건 만족시 트리거를 점프하는 함수 (Jump문) - 전방/후방 점프 가능 (NJumpX는 다수입력 가능)
PlayerID : 점프 트리거의 체크 플레이어
sIndex : 0x0 ~ 0xFFF (Jump 인덱스) 입력
Conditions : 점프를 실행할 조건
Actions : 조건만족시 실행할 액션 (T액션 사용가능)
NJumpX → NJumpEnd로 점프하며, 반드시 최소 한쌍을 이뤄야함 (PlayerID와 sIndex 동일)
ex) [예제 10-F] 참고

40

------------------------------------------------------------------------------------------

『 10장 : 제어문 관련 함수 (CStruct) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ CStruct에만 T/TT 조건/액션을 사용할 수 있습니다. ｡+.ﾟ
CIf(PlayerID, Conditions, Actions)
~ 적용할 트리거 ~
CIfEnd(Actions_Always)
: 조건 만족시 트리거단락을 연결하는 함수 (If문) - 단락 내부에서 Jump로 탈출 불가능
PlayerID : If문 트리거의 체크 플레이어
Conditions : If문의 조건
Actions : If문 만족시 실행할 액션 (T액션 사용가능)
ex) [예제 10-B] 참고
CIfOnce(PlayerID, Conditions, Actions)
~ 적용할 트리거 ~
CIfEnd(Actions_Always)
: CIf를 조건 만족시 1회만 실행하는 함수 (이후 조건을 만족해도 실행 안됨)
사용법은 CIf와 동일함
ex) [예제 10-C] 참고
NIf(PlayerID, Conditions, Actions)
~ 적용할 트리거 ~
NIfEnd()
: 조건 만족시 트리거단락을 연결하는 함수 (If문) - 단락 내부에서 Jump로 탈출 가능
PlayerID : If문 트리거의 체크 플레이어
Conditions : If문의 조건
Actions : If문 만족시 실행할 액션 (T액션 사용가능)

ex) [예제 10-B] 참고

41

------------------------------------------------------------------------------------------

『 10장 : 제어문 관련 함수 (CStruct) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ CStruct에만 T/TT 조건/액션을 사용할 수 있습니다. ｡+.ﾟ
CIfX(PlayerID, Conditions, Actions)
~ 적용할 트리거 ~
CElseIfX(Conditions, Actions)
~ 적용할 트리거 ~
CElseX(Actions)
~ 적용할 트리거 ~
CIfXEnd()
: 조건 만족시 트리거단락을 연결하는 함수 (If~Elseif~Else문) - 단락 내부에서 Jump로 탈출 불가능

PlayerID : If문 트리거의 체크 플레이어
Conditions : If문의 조건
Actions : If문 만족시 실행할 액션 (T액션 사용가능)
ex) [예제 10-D] 참고
※ CElseIfX와 CElseX는 선택 / CElseIfX는 갯수에 제한 없음
NIfX(PlayerID, Conditions, Actions)
~ 적용할 트리거 ~
NElseIfX(Conditions, Actions)
~ 적용할 트리거 ~
NElseX(Actions)
~ 적용할 트리거 ~
NIfXEnd()
: 조건 만족시 트리거단락을 연결하는 함수 (If~Elseif~Else문) - 단락 내부에서 Jump로 탈출 가능

PlayerID : If문 트리거의 체크 플레이어

Conditions : If문의 조건
Actions : If문 만족시 실행할 액션 (T액션 사용가능)
NElseIfX와 NElseX는 선택 / NElseIfX는 갯수에 제한 없음
ex) [예제 10-D] 참고

42

------------------------------------------------------------------------------------------

『 10장 : 제어문 관련 함수 (CStruct) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ CStruct에만 T/TT 조건/액션을 사용할 수 있습니다. ｡+.ﾟ
CWhile(PlayerID, Conditions, Actions)
~ 적용할 트리거 ~

CWhileEnd(Actions)
: 조건 만족시 트리거단락을 반복하는 함수 (While문) - 단락 내부에서 Jump로 탈출 불가능

PlayerID : While문 트리거의 체크 플레이어
Conditions : While문의 반복조건
Actions : While문 만족시 실행할 액션 (T액션 사용가능)

ex) [예제 10-B] 참고

CLoop(PlayerID,Repeat,Conditions,Actions)
~ 적용할 트리거 ~

CWhileEnd(Actions)
: CWhile과 동일하나, 조건만족시 Repeat 횟수만큼 반복하는 함수 (Loop문)
Repeat : 반복할 횟수 (상수만 입력가능)

ex) [예제 10-C] 참고

NWhile(PlayerID, Conditions, Actions)
~ 적용할 트리거 ~

NWhileEnd(Actions)
: 조건 만족시 트리거단락을 반복하는 함수 (While문) - 단락 내부에서 Jump로 탈출 가능

PlayerID : While문 트리거의 체크 플레이어
Conditions : While문의 반복조건
Actions : While문 만족시 실행할 액션 (T액션 사용가능)

ex) [예제 10-B] 참고

NLoop(PlayerID,Repeat,Conditions,Actions)
~ 적용할 트리거 ~

NWhileEnd(Actions)
: NWhile과 동일하나, 조건만족시 Repeat 횟수만큼 반복하는 함수 (Loop문)

Repeat : 반복할 횟수 (상수만 입력가능)

ex) [예제 10-C] 참고
※ Bring, Command 반복조건 사용시 KillUnit, RemoveUnit 액션으로 루프 탈출 불가능,
반드시 GiveUnit을 사용하여 루프문을 탈출해야함 (루프 탈출 실패시 무한 루프 버그 발생함)
※ While, Loop문은 T/TT 조건에 변수를 넣으면 갱신되지 않는 반복문임 (사용시 추가처리 필요)
추가 처리 방법은 [예제 10-H] 참고

43

------------------------------------------------------------------------------------------

『 10장 : 제어문 관련 함수 (CStruct) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ CStruct에만 T/TT 조건/액션을 사용할 수 있습니다. ｡+.ﾟ
CWhileX(PlayerID, Conditions, Actions)
~ 적용할 트리거 ~

CWhileXEnd(Actions)
: 조건 만족시 트리거단락을 반복하는 함수 (While문) - 단락 내부에서 Jump로 탈출 불가능

PlayerID : While문 트리거의 체크 플레이어
Conditions : While문의 반복조건
Actions : While문 만족시 실행할 액션 (T액션 사용가능)
ex) [예제 10-G] 참고

CLoopX(PlayerID,Repeat,Conditions,Actions)
~ 적용할 트리거 ~

CWhileXEnd(Actions)
: CWhileX과 동일하나, 조건만족시 Repeat 횟수만큼 반복하는 함수 (Loop문)
Repeat : 반복할 횟수 (상수만 입력가능)

NWhileX(PlayerID, Conditions, Actions)
~ 적용할 트리거 ~

NWhileXEnd(Actions)
: 조건 만족시 트리거단락을 반복하는 함수 (While문) - 단락 내부에서 Jump로 탈출 가능
PlayerID : While문 트리거의 체크 플레이어
Conditions : While문의 반복조건
Actions : While문 만족시 실행할 액션 (T액션 사용가능)
ex) [예제 10-G] 참고

NLoopX(PlayerID,Repeat,Conditions,Actions)
~ 적용할 트리거 ~

NWhileXEnd(Actions)
: NWhileX와 동일하나, 조건만족시 Repeat 횟수만큼 반복하는 함수 (Loop문)
Repeat : 반복할 횟수 (상수만 입력가능)
※ Bring, Command 반복조건 사용시 KillUnit, RemoveUnit 액션으로 루프 탈출 불가능,
반드시 GiveUnit을 사용하여 루프문을 탈출해야함 (루프 탈출 실패시 무한 루프 버그 발생함)
※ WhileX, LoopX문은 T/TT 조건에 변수를 넣어도 자동갱신되는 반복문임 (추가처리 불필요)

44

------------------------------------------------------------------------------------------

『 10장 : 제어문 관련 함수 (CStruct) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ CStruct에만 T/TT 조건/액션을 사용할 수 있습니다. ｡+.ﾟ
DoWhile(PlayerID, Actions_Always)
~ 적용할 트리거 ~
DoWhileEnd(Loop_Conditions, Actions)
: 트리거단락 실행 후 조건 만족시 트리거단락을 반복하는 함수 (DoWhile문)
- 단락 내부에서 Jump로 탈출 가능
PlayerID : DoWhile문 트리거의 체크 플레이어
Loop_Conditions : DoWhile문의 반복조건
Actions : DoWhile문 만족시 실행할 액션 (T액션 사용가능)

ex) [예제 10-C] 참고
CFor(PlayerID,Init,End,Step,Actions)
~ 적용할 트리거 ~
CForEnd(Actions)
: for Init, End ,Step do ~ end 만큼 트리거단락을 반복하는 함수 (for문)
- 단락 내부에서 Jump로 탈출 가능
PlayerID : For문 트리거의 체크 플레이어
Init : 시작값 / End : 조건값 / Step : 변화량값 (Init부터 시작해서 End에 반드시 도달해야합니다.)

Actions : For문 만족시 실행할 액션 (T액션 사용가능)
ex) [예제 10-D] 참고
CForVariable(NestingLevel) ※ 고급
: CFor문 내부 루프 변수(Init→End값 저장)의 변수 데이터를 반환하는 함수
NestingLevel : CFor의 중첩된 수 (비우면 현재 CFor 내부변수 반환)

ex) [예제 10-D] 참고
※ CStruct 함수명 맨 뒤에 2를 붙이면 Condtions와 Actions를 CTriggerX 형태로 가능함
적용 가능 함수 목록 : SLoopN2(), NJump2(), NJumpX2(), CIfOnce2(), DoWhileEnd2(),
CIf2(), CIf2X(), CElseIfX2(), CElseX2(), NIf2(), NIfX2(), NElseIfX2(), NElseX2(),
CWhile2(), CLoop2(), CWhileEnd2(), CWhileX2(), CLoopX2(), CWhileXEnd2(),
NWhile2(), NLoop2(), NWhileEnd2(), NWhileX2(), NLoopX2(), NWhileXEnd2(),
CFor2(), CForEnd2(), CDoActionX(), CTriggerX(), CDoAction2X(), CTrigger2X()
※ CTriggerX 형태 입력방법은 21장 CunPack류 함수 설명 참고 : CunPack() 설명

45

------------------------------------------------------------------------------------------

『 11장 : SafeRead류 데이터 읽기 관련 함수 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ 변수 입력 인자에 중간 연산자 함수를 사용할 수 있습니다. ｡+.ﾟ
SafeReadX(PlayerID,Input,Output,Mask,EPDRead)
: Input → Output으로 값을 복사하는 함수
PlayerID : 생성 트리거의 체크 플레이어
Input : 값을 읽어올 대상 (상수/"Cp"/변수/Mem) 입력
Output : 읽어온 값을 담을 대상 배열 (상수/"Cp"/변수/Mem) 입력 - {대상1,대상2,...} 형식으로 입력

Mask : 읽어올 범위 (비트마스크)
EPDRead : Input값의 EPD형식으로 읽어옴 (=EPD(Input)) / 비우면 적용X

ex) [예제 11-A] 참고
UnitReadX(PlayerID,Player,UnitId,Loc,Output)
: 2진탐색 방식으로 유닛 갯수를 읽어오는 함수
PlayerID : 생성 트리거의 체크 플레이어
Loc을 비우면 : Command(Player,AtLeast,2^i,UnitId)
Loc을 채우면 : Bring(Player,AtLeast,2^i,UnitId,Loc) 조건으로 읽어옴
Output : 읽어온 유닛 갯수를 담을 변수

ex) [예제 11-B] 참고
ConvertReadX(PlayerID,Input,Output,Multiplier,Mask,UseCycle)
: Input*Multiplier → Output으로 값을 복사하는 함수
Multiplier : Input 값에 곱할 상수 (Input값 * Multiplier을 Output에 복사함)
UseCycle : 결과값이 4바이트 주기를 넘어갈수있게 설정 (음수곱 전용) / 비우면 적용X
나머지 사용방법은 SafeReadX와 동일함
ex) [예제 11-C] 참고

46

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ 데이터 이동 (읽기/대입) ｡+.ﾟ
CRead(PlayerID,Dest,Source,Deviation,Mask,EPDRead,Clear)
: f_maskread 방식으로 값을 읽어들임, Dest << f_maskread(EPD(Source),Mask)
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (상수(오프셋)/"Cp"/변수/Mem/A/VA)
Source : 값을 읽어올 대상 (상수(오프셋)/"Cp"/변수/Mem/A/VA) - 변수값를 epd로 간주해 읽어옴

Deviation : 결과값의 편차 - Dest에 상수를 더함
Mask : 읽어올 범위 (비트마스크)
EPDRead : 1이면 읽어온 값의 EPD값을 반환 / 비우면 적용X
Clear : 자동 초기화 flag - 중간 연산자에서 사용 / Dest 전체 초기화가 필요할때 1을 입력
ex) [예제 12-A] 참고

CReadX(PlayerID,Dest,Source,Deviation,Mask,Multiplier,Clear)
: CRead에서 ConvertX 기능을 추가한 함수
Multiplier : Source값에 곱할 상수 (읽어온값 * Multiplier을 Dest에 복사함)
Mask : {BitMask (Source에서 읽을 부분), DestMask (Dest에 값을 복사할 부분)}으로 입력
나머지 사용법은 CRead와 동일함
ex) [예제 12-B] 참고

CMov(PlayerID,Dest,Source,Deviation,Mask,Clear)
: 변수에서 값을 출력해서 대입함, Dest << Source + Deviation
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (상수(오프셋)/"Cp"/변수/Mem/A/VA)
Source : 값을 읽어올 대상 (상수(값)/변수/VA)
Deviation : 결과값의 편차 - Dest에 상수를 더함
Mask : 읽어올 범위 (비트마스크)
Clear : 자동 초기화 flag - 중간 연산자에서 사용 / Dest 전체 초기화가 필요할때 1을 입력
ex) [예제 12-C] 참고

CMovX(PlayerID,Dest,Source,Mode,Mask)
PlayerID : 생성 트리거의 체크 플레이어
: Dest에 상수/V, Source에 VA(변수 인덱스) 대입시 Dest << Source 연산을 수행함 (CPRead방식)

Mode : 액션 연산자 / Add / SetTo / Subtract / Mask : 액션 비트마스크
: Dest에 VA 또는 A(변수 인덱스), Source에 상수/V 대입시 Dest << Source 연산을 수행함
Mode : 액션 연산자 / Add / SetTo / Subtract / Mask : 액션 비트마스크
ex) [예제 12-D] 참고

47

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ 데이터 이동 (읽기/대입) ｡+.ﾟ
TMem(PlayerID,Dest,Source,Address,Next,OffsetFlag)
: Dest(V)에 Source(Mem/V/VA/A/W/WA/LA)의 주소값(epd/Offset)값을 저장함
PlayerID : 생성 트리거의 체크 플레이어
Dest : 주소값을 담을 변수 (V)
Source : 주소값을 읽어올 대상(Mem/V/VA/A/W/WA/LA)
Address : (W/WA/V/VA만 해당) 변수의 주소값(+0x0) + Address값
Next : (W/WA/V/VA만 해당) 변수의 Next
OffsetFlag : 비우면 EPD값을 반환 / 1 입력시 Offset값을 반환
ex) [예제 12-E] 참고
f_Diff(PlayerID,Dest,Source,Mask,Time,Delay,Init)
: Dest에 Source의 Time 동안의 변화량 값을 구함, Dest << V - Vprev → Vprev << V
PlayerID : 생성 트리거의 체크 플레이어
Dest : 변화량을 담을 변수 (V/VA)
Source : 변화량을 측정할 대상 (V/VA)
Mask : 읽어올 범위 (비트마스크)
Time : 변화량을 측정할 주기 (Time ≤ 1일 경우 매 틱마다 측정)
Delay : 첫 실행시까지 대기할 시간
Init : 첫 실행 후 Vprev << V 이전까지 변화량 측정값을 0으로 고정함
ex) [예제 12-F] 참고

CWrite(PlayerID,Dest,Source,Deviation,Mask)
: SetMemoryX(V(Dest),SetTo,V(Source),Mask) 방식으로 값을 씀
PlayerID : 생성 트리거의 체크 플레이어
Dest : 값을 쓸 대상 (V/VA) - 변수값을 epd로 간주해 읽어옴
Source : 대상에 쓸 값 (상수/V/VA)
Deviation : 결과값의 편차 - Dest에 상수를 더함
Mask : 값을 쓸 범위 (기본값 0xFFFFFFFF)

ex) [예제 12-G] 참고

48

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ 덧셈과 뺄셈 (+부호 연산) ｡+.ﾟ
CAdd(PlayerID,Dest,Source,Operand,Mask)
: 변수에 덧셈 연산을 수행함
(Operand를 비우면) Dest << Dest + Source
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (상수(오프셋)/"Cp"/변수/Mem/A/VA)
Source : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
(Operand를 채우면) Dest << Source + Operand
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
ex) [예제 12-H] 참고
CSub(PlayerID,Dest,Source,Operand,Mask)
: 변수에 뺄셈 연산을 수행함 (순환을 사용하지 않음)
(Operand를 비우면) Dest << Dest - Source
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (상수(오프셋)/"Cp"/변수/Mem/A/VA)
Source : 값을 읽어올 대상 (상수(값)/변수/VA)

Mask : 읽어올 범위 (비트마스크)
(Operand를 채우면) Dest << Source - Operand
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
ex) [예제 12-I] 참고 / 2 - 1 = 0

49

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ 덧셈과 뺄셈 (+부호 연산) ｡+.ﾟ
CiSub(PlayerID,Dest,Source,Operand,Mask)
: 변수에 뺄셈 연산을 수행함 (순환을 사용함)
(Operand를 비우면) Dest << Dest - Source
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (상수(오프셋)/"Cp"/변수/Mem/A/VA)
Source : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
(Operand를 채우면) Dest << Source - Operand
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
ex) [예제 12-J] 참고 / 2 - 1 = -1
CNeg(PlayerID,Dest,Source,Mask)
: 변수에 부호 전환 연산을 수행함
(Source를 비우면) Dest << -Dest
PlayerID : 생성 트리거의 체크 플레이어
Dest : 연산을 수행할 대상 (변수/VA)
Mask : 읽어올 범위 (비트마스크)

(Source를 채우면) Dest << -Source
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)
Mask : 읽어올 범위 (비트마스크)
ex) [예제 12-K] 참고

50

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ 곱셈과 나눗셈 (+Shift 연산) ｡+.ﾟ
ClShift(PlayerID,Dest,Source,Operand,Mask)
: 변수에 << 연산을 수행함
(Operand를 비우면) Dest <<= Source
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
(Operand를 채우면) Dest = Source << Operand
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
ex) [예제 12-L] 참고
CMul(PlayerID,Dest,Source,Multiplier,Mask,BitLimit)

: 변수에 곱셈 연산을 수행함
(Multiplier를 비우면) Dest << Dest * Source
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (상수(오프셋)/"Cp"/변수/Mem/A/VA)
Source : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
BitLimit : 연산 범위 지정 (Y 최대 크기)
(Multiplier를 채우면) Dest << Source * Operand
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)
Multiplier : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
BitLimit : 연산 범위 지정 (Y 최대 크기)
ex) [예제 12-M] 참고
51

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ 곱셈과 나눗셈 (+Shift 연산) ｡+.ﾟ
CDiv(PlayerID,Dest,Source,Divisor,Mask,BitLimit)
: 변수에 나눗셈 연산을 수행함 (Unsigned)
(Divisor를 비우면) Dest << Dest / Source
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
BitLimit : 연산 범위 지정 (X,Y 최대 크기)
(Divisor를 채우면) Dest << Source / Operand
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)
Divisor : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
BitLimit : 연산 범위 지정 (X,Y 최대 크기)
ex) [예제 12-N] 참고 / 10/3 = 3, ÷0 = 0xFFFFFFFF 로 처리

CiDiv(PlayerID,Dest,Source,Divisor,Mask,BitLimit)
: 변수에 나눗셈 연산을 수행함 (Signed)
(Divisor를 비우면) Dest << Dest / Source
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
BitLimit : 연산 범위 지정 (X,Y 최대 크기)
(Divisor를 채우면) Dest << Source / Operand
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)
Divisor : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
BitLimit : 연산 범위 지정 (X,Y 최대 크기)
ex) [예제 12-O] 참고 / 10/-3 = -3, -10/3 = -3, -10/-3 = 3,
(양수,0)÷0 = 0x7FFFFFFF, (음수)÷0 = 0x80000000로 처리

52

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ 곱셈과 나눗셈 (+Shift 연산) ｡+.ﾟ
CMod(PlayerID,Dest,Source,Divisor,Mask,BitLimit)
: 변수에 나머지 연산을 수행함 (Unsigned)
(Divisor를 비우면) Dest << Dest % Source
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
BitLimit : 연산 범위 지정 (X,Y 최대 크기)
(Divisor를 채우면) Dest << Source % Operand
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)
Divisor : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
BitLimit : 연산 범위 지정 (X,Y 최대 크기)
ex) [예제 12-P] 참고 / 10%3 = 1, N%0 = N으로 처리

CiMod(PlayerID,Dest,Source,Divisor,Mask,BitLimit)
: 변수에 나머지 연산을 수행함 (Signed)
(Divisor를 비우면) Dest << Dest % Source
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
BitLimit : 연산 범위 지정 (X,Y 최대 크기)
(Divisor를 채우면) Dest << Source % Operand
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)
Divisor : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
BitLimit : 연산 범위 지정 (X,Y 최대 크기)
ex) [예제 12-Q] 참고 / 10%-3 = -1, -10%3 = 1, -10%-3 = -1, N%0 = N으로 처리

53

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ 비트 연산 ｡+.ﾟ
CNot(PlayerID,Dest,Source,Mask)
: 변수에 논리 연산 Not을 수행함
(Source를 비우면) Dest << ~Dest
PlayerID : 생성 트리거의 체크 플레이어
Dest : 연산을 수행할 대상 (변수/VA)
Mask : 읽어올 범위 (비트마스크)
(Source를 채우면) Dest << ~Source
PlayerID : 생성 트리거의 체크 플레이어

Dest : 결과값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)
Mask : 읽어올 범위 (비트마스크)
ex) [예제 12-R] 참고
CAnd(PlayerID,Dest,Source,Operand,Mask)
: 변수에 논리 연산 And를 수행함
(Operand를 비우면) Dest << Dest & Source
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
(Operand를 채우면) Dest << Source & Operand
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
ex) [예제 12-S] 참고

54

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ 비트 연산 ｡+.ﾟ
COr(PlayerID,Dest,Source,Operand,Mask)
: 변수에 논리 연산 Or를 수행함
(Operand를 비우면) Dest << Dest | Source
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
(Operand를 채우면) Dest << Source | Operand

PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
ex) [예제 12-T] 참고
CXor(PlayerID,Dest,Source,Operand,Mask)
: 변수에 논리 연산 Xor를 수행함
(Operand를 비우면) Dest << Dest ^ Source
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
(Operand를 채우면) Dest << Source ^ Operand
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 읽어올 범위 (비트마스크)
ex) [예제 12-U] 참고

55

------------------------------------------------------------------------------------------

『 13장 : 함수 호출형 함수 정의 선언 함수 (Include) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ 반드시 Tep 맨 위의 CJump(0) 사이에 넣어야 합니다 ｡+.ﾟ
Include_CtrigPlib(Cycle,SeedSwitch)
: 어셈블러가 지원하는 모든 호출형 함수를 Include 합니다.
구성 함수 : Include_DataTransfer()
Include_ArithMetic()
Include_MatheMatics(Cycle)
Include_MiscFunctions(SeedSwitch)
ex) [예제 13-1] 참고
※ 따로따로 Include 함수를 사용할 수 있지만, 반드시 위 순서대로 포함시켜야 합니다.
Include_DataTransfer()
: 데이터 이동/대입 관련 호출형 함수를 Include 합니다.
구성 함수 :

f_Read
f_ReadX
f_EPD
f_MovcpyEPD
f_Movcpy
f_MemcpyEPD
f_Memcpy
f_MemcpyX
f_ReadcpyEPD
f_Readcpy
f_ReadcpyX
f_byteConvert(PlayerID,DestVA,Source,Size,Distance)
f_byteConvertX(PlayerID,DestVA,Source,SourceX,Size,Distance)
f_bytecpy(PlayerID,Dest,SourceVA,Size,Distance)
f_bytecpyX(PlayerID,Dest,DestX,SourceVA,Size,Distance)
f_bytecmp(PlayerID,Flag,Dest,SourceVA,Size,Distance)
f_bytecmpX(PlayerID,Flag,Dest,DestX,SourceVA,Size,Distance)
ex) [예제 13-2] 참고

56

------------------------------------------------------------------------------------------

『 13장 : 함수 호출형 함수 정의 선언 함수 (Include) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ 반드시 Tep 맨 위의 CJump(0) 사이에 넣어야 합니다 ｡+.ﾟ
Include_ArithMetic()
: 사칙연산 관련 호출형 함수를 Include 합니다.
구성 함수 :

f_Abs
f_Mul
f_iMul
f_Div
f_iDiv
f_Mod

f_iMod
Include_MatheMatics(Cycle)
: 수학 함수 관련 호출형 함수를 Include 합니다.
Cycle : 2π = Cycle로 계산하여 각도 주기를 결정함 (비우면 Cycle = 360)
구성 함수 :

f_Sqrt
f_Lengthdir (Cycle 필요)
f_Atan2 (Cycle 필요)
f_Log2

Include_MiscFunctions(SeedSwitch)
: 기타 함수 관련 호출형 함수를 Include 합니다.
SeedSwitch : 32비트 난수값을 만들때 사용할 스위치를 설정함
구성 함수 :

f_Rand (SeedSwitch 필요)
f_GetStrptr
f_GetStrXptr
f_GetTblptr

ex) [예제 13-2] 참고

57

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ 반드시 함수 호출전 해당 함수의 원형을 Include 해야합니다 ｡+.ﾟ
｡˙+ﾟ Include_DataTransfer ｡+.ﾟ
f_Read(PlayerID,Input,Output,EPDOutput,Mask,Clear)
: CRead와 동일한 방식으로 값을 읽어들임, Output << f_maskread(EPD(Source),Mask)
PlayerID : 생성 트리거의 체크 플레이어
Input : 값을 읽어올 대상 (상수(오프셋)/변수/Mem/A/VA) - 변수값를 epd로 간주해 읽어옴

Output : 읽어온 값을 담을 대상 (변수/VA)
EPDOutput : EPD(읽어온 값)을 담을 대상 (변수/VA)
Mask : 읽어올 범위 (비트마스크)
Clear : 자동 초기화 flag - 중간 연산자에서 사용 / Dest 전체 초기화가 필요할때 1을 입력
ex) [예제 14-A] 참고

f_ReadX(PlayerID,Input,Output,Multiplier,Mask,Clear)
: CReadX와 동일한 방식으로 값을 읽어들임, Output << f_maskread(EPD(Source),Mask)*Multiplier
PlayerID : 생성 트리거의 체크 플레이어
Input : 값을 읽어올 대상 (상수(오프셋)/변수/Mem/A/VA) - 변수값를 epd로 간주해 읽어옴
Output : 읽어온 값을 담을 대상 (상수/V/Mem/A/VA)
Multiplier : 읽어온 값에 곱할 상수값 ("-3","-2","-1","0","+1","+2","+3", 각각 *256^n)
Mask : 읽어올 범위 (비트마스크) (1바이트 단위로 입력해야함, 0xFF FF FF FF)
Clear : 자동 초기화 flag - 중간 연산자에서 사용 / Dest 전체 초기화가 필요할때 1을 입력
※ f_Read 바이트 단위 변환 Read용 함수로, Multiplier는 1/16777216, 1/65536, 1/256, 1, 256, 65536, 16777216만 입력가능

ex) [예제 14-B] 참고

f_EPD(PlayerID,Dest,Source)
: Offset 값을 EPD형식으로 변환함 ,Dest << EPD(Source)
PlayerID : 생성 트리거의 체크 플레이어
Dest : 읽어온 값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)
ex) [예제 14-C] 참고

f_EPDX(PlayerID,DestX,Source)
: Offset 값을 DestX형식으로 변환함 ,DestX << Source%4
PlayerID : 생성 트리거의 체크 플레이어
DestX : 읽어온 값을 담을 대상 (상수/변수/Mem)
Source : 값을 읽어올 대상 (변수/VA)
ex) [예제 25-2] 참고

58

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ 반드시 함수 호출전 해당 함수의 원형을 Include 해야합니다 ｡+.ﾟ
｡˙+ﾟ Include_DataTransfer ｡+.ﾟ
f_MemcpyEPD(PlayerID,Dest,Source,Size)
: Dest에 Source의 데이터를 Size만큼 복사하는 함수 (Dest, Source에 epd 입력)
Offset → Offset 전용 (변수 입력시 변수값을 epd로 받음)
PlayerID : 생성 트리거의 체크 플레이어
Dest : 읽어온 값을 담을 시작점 (상수(epd)/변수/VA/A/Mem)
Source : 값을 읽어올 시작점 (상수(epd)/변수/VA/A/Mem)

Size : 데이터를 복사할 크기
ex) [예제 14-D] 참고

f_Memcpy(PlayerID,Dest,Source,Size)
: Dest에 Source의 데이터를 Size만큼 복사하는 함수 (Dest, Source에 Offset 입력)
Offset → Offset 전용 (변수 입력시 변수값을 Offset으로 받음)
PlayerID : 생성 트리거의 체크 플레이어
Dest : 읽어온 값을 담을 시작점 (상수(Offset)/변수/VA/A/Mem)

Source : 값을 읽어올 시작점 (상수(Offset)/변수/VA/A/Mem)
Size : 데이터를 복사할 크기
※ flag에 1을 넣어야 사용가능
ex) [예제 14-E] 참고

f_MemcpyX(PlayerID,Dest,DestX,Source,SourceX,Size)
: Dest에 Source의 데이터를 Size만큼 복사하는 함수
(Dest, Source에 epd 입력, DestX, SourceX에 편차 입력(0~3))

Offset → Offset 전용 (변수 입력시 변수값을 epd+편차로 받음)
PlayerID : 생성 트리거의 체크 플레이어
Dest : 읽어온 값을 담을 시작점 (상수(epd)/변수/VA/A/Mem)
DestX : 읽어온 값을 담을 시작점 주소의 편차 (상수/변수/VA)
Source : 값을 읽어올 시작점 (상수(epd)/변수/VA/A/Mem)
SourceX : 값을 읽어올 시작점의 주소값 편차 (상수/변수/VA)
Size : 데이터를 복사할 크기
※ flag에 1을 넣어야 사용가능

ex) [예제 14-F] 참고
59

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ 반드시 함수 호출전 해당 함수의 원형을 Include 해야합니다 ｡+.ﾟ
｡˙+ﾟ Include_DataTransfer ｡+.ﾟ
f_ReadcpyEPD(PlayerID,DestVA,Source,Size)
: DestVA에 Source의 데이터를 Size만큼 복사하는 함수 (Source에 epd 입력)

Offset → VArray 전용 (변수 입력시 변수값을 epd로 받음)
PlayerID : 생성 트리거의 체크 플레이어
DestVA : 읽어온 값을 담을 시작점 (VA)
Source : 값을 읽어올 시작점 (상수(epd)/변수/VA/A/Mem)
Size : 데이터를 복사할 크기
ex) [예제 14-G] 참고

f_Readcpy(PlayerID,DestVA,Source,Size,InitBytes)
: DestVA에 Source의 데이터를 Size만큼 복사하는 함수 (Source에 Offset 입력)
Offset → VArray 전용 (변수 입력시 변수값을 Offset으로 받음)
PlayerID : 생성 트리거의 체크 플레이어
DestVA : 읽어온 값을 담을 시작점 (VA)
Source : 값을 읽어올 시작점 (상수(Offset)/변수/VA/A/Mem)
Size : 데이터를 복사할 크기
InitBytes : VA에 담을 데이터의 시작지점 편차값(+0x0~+0x3) - 0~3을 입력
※ flag에 1을 넣어야 사용가능

ex) [예제 14-H] 참고

f_ReadcpyX(PlayerID,DestVA,Source,SourceX,Size,InitBytes)
: DestVA에 Source의 데이터를 Size만큼 복사하는 함수
(Source에 epd 입력, SourceX에 편차 입력(0~3))
Offset → VArray 전용 (변수 입력시 변수값을 epd+편차로 받음)
PlayerID : 생성 트리거의 체크 플레이어
DestVA : 읽어온 값을 담을 시작점 (VA)

Source : 값을 읽어올 시작점 (상수(epd)/변수/VA/A/Mem)
SourceX : 값을 읽어올 시작점의 주소값 편차 (상수/변수/VA)
Size : 데이터를 복사할 크기
InitBytes : VA에 담을 데이터의 시작지점 편차값(+0x0~+0x3) - 0~3을 입력
※ flag에 1을 넣어야 사용가능
ex) [예제 14-I] 참고

60

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ 반드시 함수 호출전 해당 함수의 원형을 Include 해야합니다 ｡+.ﾟ
｡˙+ﾟ Include_DataTransfer ｡+.ﾟ
f_MovcpyEPD(PlayerID,Dest,SourceVA,Size,InitBytes)
: Dest에 SourceVA의 데이터를 Size만큼 복사하는 함수 (Dest에 epd 입력)
VArray → Offset 전용 (변수 입력시 변수값을 epd로 받음)
PlayerID : 생성 트리거의 체크 플레이어
Dest : 읽어온 값을 담을 시작점 (상수(epd)/변수/VA/A/Mem)
SourceVA : 값을 읽어올 시작점 (VA)

Size : 데이터를 복사할 크기
InitBytes : Dest에 담을 데이터의 시작지점 편차값(+0x0~+0x3)
-> 0~3을 입력 (밀린 시작지점은 복사되지않음)
ex) [예제 14-J] 참고

f_Movcpy(PlayerID,Dest,SourceVA,Size)
: Dest에 SourceVA의 데이터를 Size만큼 복사하는 함수 (Dest에 Offset 입력)
VArray → Offset 전용 (변수 입력시 변수값을 Offset로 받음)

PlayerID : 생성 트리거의 체크 플레이어
Dest : 읽어온 값을 담을 시작점 (상수(Offset)/변수/VA/A/Mem)
SourceVA : 값을 읽어올 시작점 (VA)
Size : 데이터를 복사할 크기
※ 작동방식은 MovcpyEPD와 동일하나, Offset의 편차값(0~3)에 따라서 자동으로 InitBytes가 결정됨

ex) [예제 14-K] 참고

61

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ 반드시 함수 호출전 해당 함수의 원형을 Include 해야합니다 ｡+.ﾟ
｡˙+ﾟ Include_ArithMetic ｡+.ﾟ
f_Abs(PlayerID,Dest,Source,Mask)
: Dest에 Source의 절댓값을 대입함, Dest <<| Source |
PlayerID : 생성 트리거의 체크 플레이어
Dest : 읽어온 값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)
Mask : 대입 비트마스크

ex) [예제 14-L] 참고

f_Mul(PlayerID,Dest,Source,Multiplier,Mask)
: Dest에 Source*Multiplier을 대입함, Dest << Source * Multiplier
PlayerID : 생성 트리거의 체크 플레이어
Dest : 읽어온 값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)
Multiplier : 값을 읽어올 대상 (변수/VA)

Mask : 대입 비트마스크
ex) [예제 14-M] 참고

f_iMul(PlayerID,Dest,Source,Multiplier,Mask)
: Dest에 Source*Multiplier을 대입함, Dest << Source * Multiplier
PlayerID : 생성 트리거의 체크 플레이어
Dest : 읽어온 값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)

Multiplier : 값을 읽어올 대상 (변수/VA)
Mask : 대입 비트마스크
ex) [예제 14-N] 참고
※ f_Mul과 동일하나, Source의 절댓값이 작을수록 연산속도가 빨라짐 (절댓값 작은 Signed 변수용)

62

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ 반드시 함수 호출전 해당 함수의 원형을 Include 해야합니다 ｡+.ﾟ
｡˙+ﾟ Include_ArithMetic ｡+.ﾟ
f_Div(PlayerID,Dest,Source,Divisor,Mask)
: Dest에 Source/Divisor을 대입함, Dest << Source / Divisor (Unsigned 연산)
PlayerID : 생성 트리거의 체크 플레이어
Dest : 읽어온 값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)
Divisor : 값을 읽어올 대상 (변수/VA)
Mask : 대입 비트마스크
ex) [예제 14-O] 참고

f_iDiv(PlayerID,Dest,Source,Divisor,Mask)
: Dest에 Source/Divisor을 대입함, Dest << Source / Divisor (Signed 연산)
PlayerID : 생성 트리거의 체크 플레이어
Dest : 읽어온 값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)
Divisor : 값을 읽어올 대상 (변수/VA)
Mask : 대입 비트마스크
ex) [예제 14-O] 참고

f_Mod(PlayerID,Dest,Source,Divisor,Mask)
: Dest에 Source%Divisor을 대입함, Dest << Source % Divisor (Unsigned 연산)
PlayerID : 생성 트리거의 체크 플레이어
Dest : 읽어온 값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)
Divisor : 값을 읽어올 대상 (변수/VA)

Mask : 대입 비트마스크
ex) [예제 14-P] 참고

f_iMod(PlayerID,Dest,Source,Divisor,Mask)
: Dest에 Source%Divisor을 대입함, Dest << Source % Divisor (Signed 연산)
PlayerID : 생성 트리거의 체크 플레이어
Dest : 읽어온 값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)
Divisor : 값을 읽어올 대상 (변수/VA)

Mask : 대입 비트마스크
ex) [예제 14-P] 참고
63

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ 반드시 함수 호출전 해당 함수의 원형을 Include 해야합니다 ｡+.ﾟ
｡˙+ﾟ Include_MatheMatics ｡+.ﾟ
f_Sqrt(PlayerID,Dest,Source)
: Dest에 Source의 제곱근을 대입함, Dest << √(Source)
PlayerID : 생성 트리거의 체크 플레이어
Dest : 읽어온 값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)
ex) [예제 14-Q] 참고

f_Lengthdir(PlayerID,Radius,Angle,CosOutput,SinOutput)
: Radius, Angle → RCosΘ, RSinΘ의 값을 구하는 함수
(-32768≤R≤32767, 0≤Θ＜Cycle) - 각도값은 Cycle 초과시 iMod 연산 실행함
PlayerID : 생성 트리거의 체크 플레이어
Radius : 반지름 값(상수(값)/변수/VA)
Angle : 각도 값(상수(값)/변수/VA)
CosOutput : RCosΘ 값을 담을 대상 (변수/VA)

SinOutput : RSinΘ 값을 담을 대상 (변수/VA)
ex) [예제 14-R] 참고

f_Atan2(PlayerID,DeltaY,DeltaX,AngleOutput)
: ΔY/ΔX → Θ의 값을 구하는 함수 (-32768≤ΔX,ΔY≤32767)
PlayerID : 생성 트리거의 체크 플레이어
DeltaY : Y좌표 변화량 값(상수(값)/변수/VA)
DeltaX : X좌표 변화량 값(상수(값)/변수/VA)

AngleOutput : Θ 값을 담을 대상 (변수/VA)
ex) [예제 14-S] 참고

f_Log2(PlayerID,Dest,Source)
: Dest에 Source의 log2값을 대입함, Dest << log2(Source) (밑 = 2)
PlayerID : 생성 트리거의 체크 플레이어
Dest : 읽어온 값을 담을 대상 (변수/VA)
Source : 값을 읽어올 대상 (변수/VA)

ex) [예제 14-T] 참고
64

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ 반드시 함수 호출전 해당 함수의 원형을 Include 해야합니다 ｡+.ﾟ
｡˙+ﾟ Include_MiscFunctions ｡+.ﾟ
f_Rand(PlayerID,Dest,Mask)
: Dest에 32비트 랜덤 난수를 저장하는 함수
PlayerID : 생성 트리거의 체크 플레이어
Dest : 랜덤 난수를 담을 대상 (변수/VA) / Mask : 랜덤 난수값에 적용할 비트마스크
※ 랜덤 난수를 만들때 SeedSwitch를 사용합니다.
ex) [예제 14-U] 참고

f_GetStrptr(PlayerID,Output,StringId)
: StringId에 해당하는 스트링의 Offset을 Output에 저장하는 함수
(STR단락 전용 - euddraft 0.8.9.0 이전버전 사용시 선택)
PlayerID : 생성 트리거의 체크 플레이어
StringId : 선택한 스트링의 Id (상수/변수/VA) - 스트링의 내용을 직접 작성해서 입력할수도 있음 ("스트링1")

Output : 스트링의 Offset을 담을 대상 (변수/VA/Offset/A/Mem)
리턴값 : 입력한 문자열의 String Id (StringId가 상수일때)

Ex) [예제 14-V] 참고

f_GetStrXptr(PlayerID,Output,StringId)
: StringId에 해당하는 스트링의 Offset을 Output에 저장하는 함수
(STRX단락 전용 - euddraft 0.8.9.0 이후버전 사용시 선택)
PlayerID : 생성 트리거의 체크 플레이어
StringId : 선택한 스트링의 Id (상수/변수/VA) - 스트링의 내용을 직접 작성해서 입력할수도 있음 ("스트링1")

Output : 스트링의 Offset을 담을 대상 (변수/VA/Offset/A/Mem)

리턴값 : 입력한 문자열의 String Id (StringId가 상수일때)
Ex) [예제 14-W] 참고

f_GetTblptr(PlayerID,Output,TBLIndex)
: TBLIndex에 해당하는 tbl스트링의 Offset을 Output에 저장하는 함수
PlayerID : 생성 트리거의 체크 플레이어
TBLIndex : 선택한 tbl스트링의 index (상수/변수/VA)
Output : 스트링의 Offset을 담을 대상 (변수/VA/Offset/A/Mem)

Ex) [예제 14-V] 참고
65

------------------------------------------------------------------------------------------

『 15장 : 중간 연산자 관련 함수 (_) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ※ 중간 연산자 함수는 무제한으로 중첩해서 사용할 수 있습니다｡+.ﾟ
_Mov(Source,Mask)
: CMov의 중간 연산자 함수, V << Source
Source : 값을 읽어올 대상 (상수(값)/변수/VA)
Mask : 대입 연산 비트마스크

_MovX(Source,Mode,Mask)
: CMovX의 중간 연산자 함수, VA → V(변수 출력) 타입 변환시 사용
Source : 값을 읽어올 대상 (VA)
Mode : 액션 연산자 / Add / SetTo / Subtract / Mask : 액션 비트마스크

_Read(Source,Mask)
: CRead의 중간 연산자 함수, V << f_maskread(Source,Mask)
Source : 값을 읽어올 대상 (상수(값)/"Cp"/변수/Mem/A/VA)
Mask : 대입 연산 비트마스크

_ReadX(Source,Mask,Multiplier)
: CReadX의 중간 연산자 함수, V << f_maskread(Source,Mask) * Multiplier
Source : 값을 읽어올 대상 (상수(값)/"Cp"/변수/Mem/A/VA)
Mask : 대입 연산 비트마스크
Multiplier : 읽은 값에 곱할 상수 (상수)

_EPDRead(Source)
: CRead의 중간 연산자 함수(EPD 읽기모드), V << EPD(f_maskread(Source,Mask))
Source : 값을 읽어올 대상 (상수(값)/"Cp"/변수/Mem/A/VA)
Mask : 대입 연산 비트마스크
ex) [예제 15-1] 참고

66

------------------------------------------------------------------------------------------

『 15장 : 중간 연산자 관련 함수 (_) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ※ 중간 연산자 함수는 무제한으로 중첩해서 사용할 수 있습니다｡+.ﾟ
_ReadF(Source,Mask)
: f_Read의 중간 연산자 함수, V << f_maskread(Source,Mask)
Source : 값을 읽어올 대상 (상수(값)/"Cp"/변수/Mem/A/VA)
Mask : 대입 연산 비트마스크

_ReadFX(Source,Mask,Multiplier)
: f_ReadX의 중간 연산자 함수, V << f_maskread(Source,Mask) * Multiplier
Source : 값을 읽어올 대상 (상수(값)/"Cp"/변수/Mem/A/VA)
Mask : 대입 연산 비트마스크
Multiplier : 읽은 값에 곱할 상수 (상수)

_EPDReadF(Source)
: f_Read의 중간 연산자 함수(EPD 읽기모드), V << EPD(f_maskread(Source,Mask))
Source : 값을 읽어올 대상 (상수(값)/"Cp"/변수/Mem/A/VA)
Mask : 대입 연산 비트마스크

_EPD(Source)
: f_EPD의 중간 연산자 함수, V << EPD(Source)
Source : 값을 읽어올 대상 (변수/VA)
ex) [예제 15-2] 참고

_EPDX(Source)
: f_EPDX의 중간 연산자 함수, V << Source%4
Source : 값을 읽어올 대상 (변수/VA)

_TMem(Source,Address,Next,OffsetFlag)
: TMem의 중간 연산자 함수, VA,A → V(변수 입력) 타입 변환시 사용
Source : 주소값을 읽어올 대상(Mem/V/VA/A)
Address : (V/VA만 해당) 변수의 주소값(+0x0) + Address값
Next : (V/VA만 해당) 변수의 Next
OffsetFlag : 비우면 EPD값을 반환 / 1 입력시 Offset값을 반환
ex) [예제 12-E] 참고
67

------------------------------------------------------------------------------------------

『 15장 : 중간 연산자 관련 함수 (_) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ※ 중간 연산자 함수는 무제한으로 중첩해서 사용할 수 있습니다｡+.ﾟ
_Add(Source,Operand)
: CAdd의 중간 연산자 함수, V << Source + Operand
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA)

_Sub(Source,Operand)
: CSub의 중간 연산자 함수, V << Source - Operand (순환X)
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA)

_iSub(Source,Operand)
: CiSub의 중간 연산자 함수, V << Source - Operand (순환O)
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA)

_Neg(Source)
: CNeg의 중간 연산자 함수, V << -Source
Source : 값을 읽어올 대상 (변수/VA)
ex) [예제 15-3] 참고

68

------------------------------------------------------------------------------------------

『 15장 : 중간 연산자 관련 함수 (_) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ※ 중간 연산자 함수는 무제한으로 중첩해서 사용할 수 있습니다｡+.ﾟ
_Mul(Source,Operand)
: CMul/f_Mul의 중간 연산자 함수, V << Source * Operand
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA) - 상수 : CMul / 변수,VA : f_Mul로 연산

_MulX(Source,Operand)
: CMul/f_Mul의 중간 연산자 함수, V << Source * Operand
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA) - 상수 : f_Mul / 변수,VA : CMul로 연산

_iMul(Source,Operand)
: f_iMul의 중간 연산자 함수, V << Source * Operand
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA)
ex) [예제 15-4] 참고

69

------------------------------------------------------------------------------------------

『 15장 : 중간 연산자 관련 함수 (_) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ※ 중간 연산자 함수는 무제한으로 중첩해서 사용할 수 있습니다｡+.ﾟ
_Div(Source,Operand)
: CDiv/f_Div의 중간 연산자 함수, V << Source / Operand (Unsigned)
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA) - 상수 : CDiv / 변수,VA : f_Div로 연산

_iDiv(Source,Operand)
: CiDiv/f_iDiv의 중간 연산자 함수, V << Source / Operand (Signed)
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA) - 상수 : CiDiv / 변수,VA : f_iDiv로 연산

_DivX(Source,Operand)
: CDiv/f_Div의 중간 연산자 함수, V << Source / Operand (Unsigned)
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA) - 상수 : f_Div / 변수,VA : CDiv로 연산

_iDivX(Source,Operand)
: CiDiv/f_iDiv의 중간 연산자 함수, V << Source / Operand (Signed)
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA) - 상수 : f_iDiv / 변수,VA : CiDiv로 연산
ex) [예제 15-4] 참고

70

------------------------------------------------------------------------------------------

『 15장 : 중간 연산자 관련 함수 (_) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ※ 중간 연산자 함수는 무제한으로 중첩해서 사용할 수 있습니다｡+.ﾟ
_Mod(Source,Operand)
: CMod/f_Mod의 중간 연산자 함수, V << Source % Operand (Unsigned)
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA) - 상수 : CMod / 변수,VA : f_Mod로 연산

_iMod(Source,Operand)
: CiMod/f_iMod의 중간 연산자 함수, V << Source % Operand (Signed)
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA) - 상수 : CiMod / 변수,VA : f_iMod로 연산

_ModX(Source,Operand)
: CMod/f_Mod의 중간 연산자 함수, V << Source % Operand (Unsigned)
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA) - 상수 : f_Mod / 변수,VA : CMod로 연산

_iModX(Source,Operand)
: CiMod/f_iMod의 중간 연산자 함수, V << Source % Operand (Signed)
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA) - 상수 : f_iMod / 변수,VA : CiMod로 연산
ex) [예제 15-5] 참고

71

------------------------------------------------------------------------------------------

『 15장 : 중간 연산자 관련 함수 (_) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ※ 중간 연산자 함수는 무제한으로 중첩해서 사용할 수 있습니다｡+.ﾟ
_Not(Source)
: CNot의 중간 연산자 함수, V << ~Source
Source : 값을 읽어올 대상 (변수/VA)

_Or(Source,Operand)
: COr의 중간 연산자 함수, V << Source | Operand
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA)

_And(Source,Operand)
: CAnd의 중간 연산자 함수, V << Source & Operand
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA)

_Xor(Source,Operand)
: CXor의 중간 연산자 함수, V << Source ^ Operand
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA)
ex) [예제 15-6] 참고

_lShift(Source,Operand)
: ClShift의 중간 연산자 함수, V = Source << Operand
Source : 값을 읽어올 대상 (변수/VA)
Operand : 값을 읽어올 대상 (상수(값)/변수/VA)

72

------------------------------------------------------------------------------------------

『 15장 : 중간 연산자 관련 함수 (_) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ※ 중간 연산자 함수는 무제한으로 중첩해서 사용할 수 있습니다｡+.ﾟ
_Abs(Source)
: f_Abs의 중간 연산자 함수, V << |Source|
Source : 값을 읽어올 대상 (변수/VA)
ex) [예제 15-4] 참고

_Sqrt(Source)
: f_Sqrt의 중간 연산자 함수, V << √(Source)
Source : 값을 읽어올 대상 (변수/VA)
ex) [예제 15-5] 참고

_Lengthdir(Radius,Angle)
: f_Lengthdir의 중간 연산자 함수, W << R*CosA, R*SinA
Radius : 값을 읽어올 대상 (변수/VA)
Angle : 값을 읽어올 대상 (변수/VA)
※ Cos, Sin값이 4바이트씩 나눠 담김, _Cast를 사용해 V로 변환가능

_Atan2(DeltaY,DeltaX)
: f_Atan2의 중간 연산자 함수, V << Atan2(ΔY/ΔX)
DeltaY : 값을 읽어올 대상 (변수/VA)
DeltaX : 값을 읽어올 대상 (변수/VA)

_Log2(Source)
: f_Log2의 중간 연산자 함수, V << log2(Source) (밑 = 2)
Source : 값을 읽어올 대상 (변수/VA)

_Rand()
: f_Rand의 중간 연산자 함수, V << 32비트 랜덤난수
ex) [예제 15-5] 참고

73

------------------------------------------------------------------------------------------

『 16장 : 변수 삽입형 조건/액션 함수 (T) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ (T) 조건/액션 함수는 변수(V)를 삽입할 수 있습니다 ｡+.ﾟ
TCDeathsX(Player,Type,Value,Code,Mask)
TCDeaths(Player,Type,Value,Code)
TSetCDeathsX(Player,Type,Value,Code,Mask)
TSetCDeaths(Player,Type,Value,Code)
: C(Set)Deaths(X) 조건/액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Value, Mask

TNDeathsX(Player,Type,Value,Code,Mask)
TNDeaths(Player,Type,Value,Code)
TSetNDeathsX(Player,Type,Value,Code,Mask)
TSetNDeaths(Player,Type,Value,Code)
: N(Set)Deaths(X) 조건/액션의 변수 삽입형 함수

변수 삽입 가능 항목 : Value, Mask

TVariableX(Player,Index,Section,Type,Value,Mask)
TSetVariableX(Player,Index,Section,Type,Value,Mask)
TVariable(Variable,Section,Type,Value,Mask)
TSetVariable(Variable,Section,Type,Value,Mask)
TVArrayX(VArray,Section,Type,Value,Mask)
TSetVArrayX(VArray,Section,Type,Value,Mask)
: (Set)[Variable/VArray](X) 조건/액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Value, Mask

TCVar(Player,Index,Type,Value,Mask)
TSetCVar(Player,Index,Type,Value,Mask)
TNVar(Variable,Type,Value,Mask)
TSetNVar(Variable,Type,Value,Mask)
TCVAar(VArray,Type,Value,Mask)
TSetCVAar(VArray,Type,Value,Mask)
: (Set)[C/N][Var/VAar] 조건/액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Value, Mask
74

------------------------------------------------------------------------------------------

『 16장 : 변수 삽입형 조건/액션 함수 (T) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ (T) 조건/액션 함수는 변수(V)를 삽입할 수 있습니다 ｡+.ﾟ
TSetCtrig2X(Offset,Type,Player2,Index2,Address2,EPD2,Next2,Mask)
TSetCtrig1X(Player1,Index1,Address1,Next1,Type,Value,Mask)
TCtrigX(Player,Index,Address,Next,Type,Value,Mask)
: (Set)Ctrig(1/2)X 조건/액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Value, Mask

TDeathsX(Player,Type,Value,UnitId,Mask)
TDeaths(Player,Type,Value,UnitId)
TSetDeathsX(Player,Type,Value,UnitId,Mask)
TSetDeaths(Player,Type,Value,UnitId)
: (Set)Deaths(X) 조건/액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Player(epd), Value, Mask, UnitId
ex) [예제 16-3] 참고

TMemory(Offset,Type,Value)
TSetMemory(Offset,Type,Value)
TMemoryX(Offset,Type,Value,Mask)
TSetMemoryX(Offset,Type,Value,Mask)
: (Set)Deaths(X) 조건/액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Player(epd), Value, Mask

※ Offset이나 Value 자리에 Mem 데이터를 넣으면 해당 주소로 바뀜
ex) Offset << Mem → CtrigX / SetCtrig1X
Value << Mem → SetCtrig2X
Offset,Value << Mem → SetCtrigX
※ TMemory(X) <- Offset, TSetMemory(X) <- Offset, Value에 Vi()로 Mem데이터 삽입가능
ex) [예제 16-1] 참고
ex) [예제 16-2] 참고

75

------------------------------------------------------------------------------------------

『 16장 : 변수 삽입형 조건/액션 함수 (T) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ (T) 조건/액션 함수는 변수(V)를 삽입할 수 있습니다 ｡+.ﾟ
TCommand(Player,Type,Value,UnitID)
TBring(Player,Type,Value,UnitID,Location)
: Command/Bring 조건의 변수 삽입형 함수
변수 삽입 가능 항목 : Player(epd), Value, UnitID, Location

TAccumulate(Player,Type,Value,ResourceType)
: Accumulate 조건의 변수 삽입형 함수
변수 삽입 가능 항목 : Player, Value

TCountdownTimer(Type,Value)
: CountdownTimer 조건의 변수 삽입형 함수
변수 삽입 가능 항목 : Value

TElapsedTime(Type,Value)
: ElapsedTime 조건의 변수 삽입형 함수
변수 삽입 가능 항목 : Value

TKills(Player,Type,Value,UnitId)
: Kills 조건의 변수 삽입형 함수
변수 삽입 가능 항목 : Player, Value, UnitId

TScore(Player,ScoreType,Type,Value)
: Score 조건의 변수 삽입형 함수
변수 삽입 가능 항목 : Player, Value

TOpponents(Player,Type,Value)
: Opponents 조건의 변수 삽입형 함수
변수 삽입 가능 항목 : Player, Value

76

------------------------------------------------------------------------------------------

『 16장 : 변수 삽입형 조건/액션 함수 (T) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ (T) 조건/액션 함수는 변수(V)를 삽입할 수 있습니다 ｡+.ﾟ
TCreateUnit(Amount,UnitId,Location,Player)
TCreateUnitWithProperties(Amount,UnitId,Location,Player,Property)
: CreateUnit(WithProperties) 액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Player(epd), Amount(*16777216필요), UnitID, Location
ex) [예제 16-3] 참고

TKillUnit(UnitId,Player)
TKillUnitAt(Amount,UnitId,Location,Player)
: KillUnit(At) 액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Player(epd), Amount(*16777216필요), UnitID, Location

TRemoveUnit(UnitId,Player)
TRemoveUnitAt(Amount,UnitId,Location,Player)
: RemoveUnit(At) 액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Player(epd), Amount(*16777216필요), UnitID, Location

TGiveUnits(Amount,UnitId,Player,Location,NewPlayer)
: GiveUnits 액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Player(epd), Amount(*16777216필요), UnitID, Location

TOrder(UnitId,Player,StartLocation,OrderType,DestLocation)
: Order 액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Player(epd), UnitID, StartLocation, DestLocation

TMoveLocation(Location,UnitId,Player,DestLocation)
: MoveLocation 액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Player(epd), UnitID, Location, DestLocation

TMoveUnit(Amount,UnitId,Player,StartLocation,DestLocation)
: MoveUnit 액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Player(epd), Amount(*16777216필요), UnitID, StartLocation, DestLocation
77

------------------------------------------------------------------------------------------

『 16장 : 변수 삽입형 조건/액션 함수 (T) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ (T) 조건/액션 함수는 변수(V)를 삽입할 수 있습니다 ｡+.ﾟ
TModifyUnitEnergy(Amount,UnitId,Player,Location,Value)
: ModifyUnitEnergy 액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Player(epd), Value, Amount(*16777216필요), UnitID, Location

TModifyUnitHangarCount(Value,Amount,UnitId,Player,Location)
: ModifyUnitHangarCount 액션의 변수 삽입형 함수
변수 삽입 가능 항목 :Player(epd), Value, Amount(*16777216필요), UnitID, Location

TModifyUnitHitPoints(Amount,UnitId,Player,Location,Value)
: ModifyUnitHitPoints 액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Player(epd), Value, Amount(*16777216필요), UnitID, Location

TModifyUnitResourceAmount(Amount,Player,Location,Value)
: ModifyUnitResourceAmount 액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Player(epd), Value, Amount(*16777216필요), Location

TModifyUnitShields(Amount,UnitId,Player,Location,Value)
: ModifyUnitShields 액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Player(epd), Value, Amount(*16777216필요), UnitID, Location

TSetCountdownTimer(Type,Time)
: SetCountdownTimer 액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Time

78

------------------------------------------------------------------------------------------

『 16장 : 변수 삽입형 조건/액션 함수 (T) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ (T) 조건/액션 함수는 변수(V)를 삽입할 수 있습니다 ｡+.ﾟ
TSetResources(Player,Type,Value,ResourceType)
: SetResources 액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Player(epd), Value

TSetScore(Player,Type,Value,ScoreType)
: SetScore 액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Player(epd), Value

TWait(Time)
: Wait 액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Time

TSetDoodadState(State,UnitId,Player,Location)
: SetDoodadState 액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Player(epd), UnitID, Location

TSetInvincibility(State,UnitId,Player,Location)
: SetInvincibility 액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Player(epd), UnitID, Location

TSetAllianceStatus(Player,Status)
: SetAllianceStatus 액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Player(epd)

TDisplayText(Text,AlwaysDisplay)
: DisplayText 액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Text

TPlayWAV(WAVName)
: PlayWav 액션의 변수 삽입형 함수

변수 삽입 가능 항목 : WAVName

TSetMissionObjectives(Text)
: SetMissionObjectives 액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Text

79

------------------------------------------------------------------------------------------

『 17장 : 특수 조건 관련 함수 (TT) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 특수 조건 입력방법 : "!=", NotSame : 같지않다 / ">", Above : 초과 / "<", Below : 미만 ｡+.ﾟ

TTOR(OR_Conditions) ※ 구 함수
: EUDOr 조건삽입 함수 / OR_Conditions에 {조건1,조건2,...} 형태로 입력
※ 일반조건은 그대로, T/TT 조건은 앞에 _를 붙여서 입력 (TMemoryX → _TMemoryX)
ex) [예제 17-1] 참고

TTAND(AND_Conditions) ※ 구 함수
: TTOR 내부에 AND 조건을 삽입할때 사용 / AND_Conditions에 {조건1,조건2,...} 형태로 입력
※ 일반조건은 그대로, T/TT 조건은 앞에 _를 붙여서 입력 (TMemoryX → _TMemoryX)
ex) [예제 17-2] 참고
※ TTOR, TTAND 대신 24장(_T)의 함수를 사용하는 것을 권장합니다.

TTCDeathsX(Player,Type,Value,Code,Mask)
TTCDeaths(Player,Type,Value,Code)
: CDeaths(X) 조건의 특수조건/변수 삽입형 함수
변수 삽입 가능 항목 : Value, Mask
※ 부호 있는 특수 조건 사용가능 : "i>=", iAtLeast / "i<=", iAtMost / "i>", iAbove / "i<", iBelow

TTNDeathsX(Player,Type,Value,Code,Mask)
TTNDeaths(Player,Type,Value,Code)
: NDeaths(X) 조건의 특수조건/변수 삽입형 함수
변수 삽입 가능 항목 : Value, Mask
※ 부호 있는 특수 조건 사용가능 : "i>=", iAtLeast / "i<=", iAtMost / "i>", iAbove / "i<", iBelow

80

------------------------------------------------------------------------------------------

『 17장 : 특수 조건 관련 함수 (TT) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 특수 조건 입력방법 : "!=", NotSame : 같지않다 / ">", Above : 초과 / "<", Below : 미만 ｡+.ﾟ

TTVariableX(Player,Index,Section,Type,Value,Mask)
TTVariable(Variable,Section,Type,Value,Mask)
TTVArrayX(VArray,Section,Type,Value,Mask)
: [Variable/VArray](X) 조건의 특수조건/변수 삽입형 함수
변수 삽입 가능 항목 : Value, Mask
※ 부호 있는 특수 조건 사용가능 : "i>=", iAtLeast / "i<=", iAtMost / "i>", iAbove / "i<", iBelow

TTCVar(Player,Index,Type,Value,Mask)
TTNVar(Variable,Type,Value,Mask)
TTCVAar(VArray,Type,Value,Mask)
: [C/N][Var/VAar] 조건의 특수조건/변수 삽입형 함수
변수 삽입 가능 항목 : Value, Mask
※ 부호 있는 특수 조건 사용가능 : "i>=", iAtLeast / "i<=", iAtMost / "i>", iAbove / "i<", iBelow

TTCtrigX(Player,Index,Address,Next,Type,Value,Mask)
: CtrigX조건의 특수조건/변수 삽입형 함수
변수 삽입 가능 항목 : Value, Mask
※ 부호 있는 특수 조건 사용가능 : "i>=", iAtLeast / "i<=", iAtMost / "i>", iAbove / "i<", iBelow

TTDeathsX(Player,Type,Value,UnitId,Mask)
TTDeaths(Player,Type,Value,UnitId)
: Deaths(X)조건의 특수조건/변수 삽입형 함수
변수 삽입 가능 항목 : Player(epd), Value, Mask, UnitId
※ 부호 있는 특수 조건 사용가능 : "i>=", iAtLeast / "i<=", iAtMost / "i>", iAbove / "i<", iBelow

TTMemory(Offset,Type,Value)
TTMemoryX(Offset,Type,Value,Mask)
: Memory(X)조건의 특수조건/변수 삽입형 함수
변수 삽입 가능 항목 : Player(epd), Value, Mask
ex) [예제 17-1] 참고
ex) [예제 17-3] 참고
ex) [예제 17-5] 참고
81
※ 부호 있는 특수 조건 사용가능 : "i>=", iAtLeast / "i<=", iAtMost / "i>", iAbove / "i<", iBelow

------------------------------------------------------------------------------------------

『 17장 : 특수 조건 관련 함수 (TT) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 특수 조건 입력방법 : "!=", NotSame : 같지않다 / ">", Above : 초과 / "<", Below : 미만 ｡+.ﾟ

TTCommand(Player,Type,Value,UnitID)
TTBring(Player,Type,Value,UnitID,Location)
: Command/Bring 조건의 특수조건/변수 삽입형 함수
변수 삽입 가능 항목 : Player(epd), Value, UnitID, Location
ex) [예제 17-4] 참고

TTAccumulate(Player,Type,Value,ResourceType)
: Accumulate 조건의 특수조건/변수 삽입형 함수
변수 삽입 가능 항목 : Player, Value

TTCountdownTimer(Type,Value)
: CountdownTimer 조건의 특수조건/변수 삽입형 함수
변수 삽입 가능 항목 : Value

TTElapsedTime(Type,Value)
: ElapsedTime 조건의 특수조건/변수 삽입형 함수
변수 삽입 가능 항목 : Value

TTKills(Player,Type,Value,UnitId)
: Kills 조건의 특수조건/변수 삽입형 함수
변수 삽입 가능 항목 : Player, Value, UnitId

TTScore(Player,ScoreType,Type,Value)
: Score 조건의 특수조건/변수 삽입형 함수
변수 삽입 가능 항목 : Player, Value

TTOpponents(Player,Type,Value)
: Opponents 조건의 특수조건/변수 삽입형 함수
변수 삽입 가능 항목 : Player, Value

82

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------EUDTurbo(PlayerID)
: EUD터보를 실행하는 함수. / PlayerID : 생성 트리거의 체크 플레이어
※ EndCtrig()뒤나 StartCtrig() 앞에 설치하는 것을 권장함

Loc(LocationId,Direction,Type,Value)
: 로케이션 좌표 조건 생성 함수
LocationId : 로케이션 id (로케이션 이름 삽입가능)
Direction : 선택할 방향
("L",0 : 왼쪽 / "U",1,4 : 위쪽 / "R",2,8 : 오른쪽 / "D",3,12 : 아래쪽 / 16 : 로케이션 Flag)
Type : 조건 연산자 - Exactly / AtLeast / AtMost
Value : 조건 연산값

LocX(LocationId,Direction,Type,Value)
: Loc의 eudx 버전 / Mask : 조건 비트마스크

SetLoc(LocationId,Direction,Type,Value)
: 로케이션 좌표 액션 생성 함수
LocationId : 로케이션 id (로케이션 이름 삽입가능)
Direction : 선택할 방향
("L",0 : 왼쪽 / "U",1,4 : 위쪽 / "R",2,8 : 오른쪽 / "D",3,12 : 아래쪽 / 16 : 로케이션 Flag)
nil 입력시 로케이션 좌표 갱신 액션을 실행함 ({A,B} 입력시 KillUnitAt(1,A,LocationId,B) 실행)
Type : 액션 연산자 - SetTo / Add / Subtract
Value : 액션 연산값
Direction 미 입력시(nil) : 로케이션 좌표 갱신 액션(KillUnitAt(1,185,LocationId,P12))을 실행함
Direction = {A,B} : 로케이션 좌표 갱신 액션(KillUnitAt(1,A,LocationId,B))을 실행함
ex) [예제 18-1] 참고

SetLocX(LocationId,Direction,Type,Value)
: SetLoc의 eudx 버전 / Mask : 조건 비트마스크
※ (Set)Loc(X)의 T/TT 버전인 TLoc, TLocX, TSetLoc, TSetLocX,
TTLoc, TTLocX, _TLoc, _TLocX, _TTLoc, _TTLocX도 사용가능

83

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------MemoryW(Offset,Type,Value)
: 2바이트 단위 메모리 조건 생성 함수 (Value와 Mask가 Offset 값에 맞게 채워짐)
Offset : 2의 배수여야함 / 나머지는 Memory와 동일

SetMemoryW(Offset,Type,Value)
: 2바이트 단위 메모리 조건 생성 함수 (Value와 Mask가 Offset 값에 맞게 채워짐)

Offset : 2의 배수여야함 / 나머지는 SetMemory와 동일

MemoryB(Offset,Type,Value)
: 1바이트 단위 메모리 조건 생성 함수 (Value와 Mask가 Offset 값에 맞게 채워짐)
Offset : 1의 배수여야함 / 나머지는 Memory와 동일

SetMemoryB(Offset,Type,Value)
: 1바이트 단위 메모리 조건 생성 함수 (Value와 Mask가 Offset 값에 맞게 채워짐)
Offset : 1의 배수여야함 / 나머지는 SetMemory와 동일
ex) [예제 18-1] 참고
※ (Set)Memory[B/W]의 TT 버전인 TTMemoryB, TTMemoryW,
_TTMemoryB, _TTMemoryW도 사용가능 (단, 변수삽입은 불가)

NoAirCollision(PlayerID)
: 공중유닛 밀림 방지를 적용합니다. / PlayerID : 생성 트리거의 체크 플레이어 - Ctrig 미사용 버전

NoAirCollisionX(PlayerID)
: 공중유닛 밀림 방지를 적용합니다. / PlayerID : 생성 트리거의 체크 플레이어 - Ctrig 사용 버전
※ Cif같은 제어문으로 실시간 적용 및 해제도 가능함
ex) [예제 18-1] 참고

EPDX(Offset)
: Offset을 4로 나눈 나머지를 구합니다. / Offset : 나머지 값을 구할 오프셋
ex) [예제 25-4] 참고

84

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------Enable_PlayerCheck(Offset) ※ 삭제됨 (구버전 호환용 함수)
: PlayerCheck 함수를 활성화시키는 함수
Offset에 조건값을 담아둘 공메모리를 설정 (비우면 0x58F44C 사용)

PlayerCheck(Player,Status)
: f_PlayerExist 최적화버전 (0x51A284 + 12*Player 부분을 읽어서 감지함)
Player에 감지할 플레이어(P1 ~ P8), Status에 없을경우 = 0, 있을경우 = 1 입력
ex) [예제 18-2] 참고

_Void(Number)
: 공메모리 영역 (0x58F500+4*Number)의 Offset을 반환합니다.

Void(Number,Type,Value)
: 공메모리 영역의 Memory 조건 (=Memory(0x58F500+4*Number,Type,Value))

SetVoid(Number,Type,Value)
: 공메모리 영역의 SetMemory 액션 (=SetMemory(0x58F500+4*Number,Type,Value))

VoidX(Number,Type,Value,Mask)
: 공메모리 영역의 MemoryX 조건 (=MemoryX(0x58F500+4*Number,Type,Value,Mask))

SetVoidX(Number,Type,Value,Mask)
: 공메모리 영역의 SetMemoryX 액션 (=SetMemoryX(0x58F500+4*Number,Type,Value,Mask))

SetCp(Number)
: Cp값을 조정하는 액션 (=SetMemory(0x6509B0,SetTo,Number))

I64Zero(Number,Digit)
: 스트링 형식으로 숫자를 입력할때 설정한 자릿수만큼 0을 채워주는 함수
Number : 스트링 형식으로 입력할 숫자
Digit : 설정할 자릿수 (앞에서 부터 0을 채움)
※ 64비트 상수 입력시 편리하게 사용할 수 있습니다.

85

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------EPDF(Offset)
: EPD(Offset)의 값을 정수화 시킵니다. / Offset : 입력할 오프셋
ex) [예제 25-4] 참고
※ 4의 배수가 아닌 Offset을 EPD()로 입력하는 대신 EPDF()로 입력하는 것을 권장함
(EPD(Offset)의 경우 소수점이 남아있어 그대로 입력시 반올림으로 오류 발생 가능성 존재함)

FMemory(offset, comparison, number)
: EPD형식으로 Memory조건을 입력합니다. (Death(EPDF(Offset)) 사용)
사용방법은 Memory와 동일
FMemoryX(offset, comparison, number, mask)
: EPD형식으로 MemoryX조건을 입력합니다. (DeathX(EPDF(Offset)) 사용)
사용방법은 MemoryX와 동일
FSetMemoryX(offset, modtype, number, mask)
: EPD형식으로 SetMemory액션을 입력합니다. (SetDeath(EPDF(Offset)) 사용)
사용방법은 SetMemory와 동일
FSetMemory(offset, modtype, number)
: EPD형식으로 SetMemoryX액션을 입력합니다. (SetDeathX(EPDF(Offset)) 사용)
사용방법은 SetMemoryX와 동일
※ Ctrig류 함수로 (Set)Memory(X) 조건/액션을 수정하는 경우 F(Set)Memory(X)를 사용하는 것을 권장함
((Set)Memory(X) 조건/액션은 0x58A364~0x88A360 까지를 EUD형식으로 입력함)

86

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------PlayerColor(Player,Type,Value)
: 플레이어 컬러 조건 생성 함수
Player : 적용할 플레이어 (0~11) / Type : 조건 연산자 / Value : 조건 입력값 (0~255)
SetPlayerColor(Player,Type,Value)
: 플레이어 컬러 액션 생성 함수

Player : 적용할 플레이어 (0~11) / Type : 액션 연산자 / Value : 액션 입력값 (0~255)
MinimapColor(Player,Type,Value)
: 플레이어 미니맵 컬러 조건 생성 함수
Player : 적용할 플레이어 (0~11) / Type : 조건 연산자 / Value : 조건 입력값 (0~255)
SetMinimapColor(Player,Type,Value)
: 플레이어 미니맵 컬러 액션 생성 함수
Player : 적용할 플레이어 (0~11) / Type : 액션 연산자 / Value : 액션 입력값 (0~255)
Speed(Type,Value)
: 배속 조건 생성 함수
Type : 조건 연산자 / Value : 조건 입력값
SetSpeed(Type,Value)
: 배속 액션 생성 함수
Type : 액션 연산자 / Value : 액션 입력값

※ 배속 조건/액션의 Value에 "#X_" 형식으로 입력시 해당 배속값으로 입력됨
입력 가능 속도 목록 : "#X0" (노배속), "#X1", "#X2", "#X3", "#X4", "#X5"
LocalPlayerID(Player,Type,Value)
: 해당 플레이어에게만 만족하는 조건 생성 함수 (비공유 조건용)
Player : 적용할 플레이어 (0~7, "Ob1"~"Ob4" : 관전 1~4)
Type : 조건 연산자 (미입력시 Exactly) / Value : 조건 입력값
UnixTime(Type,Date)
: 맵 실행 시작시간 조건 생성 함수 (맵 유통기한 조건용)
Type : 조건 연산자 / Date : 조건 입력 날짜
({year = 2021, month = 7, day = 24, hour = 22, min = 36, sec = 12} 형식으로 입력)
ex) [예제 18-3] 참고

87

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------SetKills(Player, Modifier, Number, Unit)
TSetKills(Player, Modifier, Number, Unit) ※ 변수 삽입형 액션
: 각 플레이어의 킬 수 변경 액션 생성 함수
Player : 대상 플레이어
Modifier : 액션 연산자 (Add/Subtract/SetTo)
Number : 변경할 수
Unit : 대상 유닛Id (0~227 : 해당 유닛, 229 : Any Unit, 231 : Buildings, 232 : Factories)
※ TSetKills 변수 삽입가능 항목 : Player, Number, Unit(변수 입력 값 범위 : 0~227)
KtoA(Player,UnitId)
: 플레이어의 킬 수 부분의 오프셋을 구하는 함수
Player : 대상 플레이어
Unit : 대상 유닛Id (0~227 : 해당 유닛, 229 : Any Unit, 231 : Buildings, 232 : Factories)

ex) [예제 18-4] 참고
f_SHRead(PlayerID,Input,Output,Mask,Clear) -- (CPRead) 방식으로 읽음
: Input을 Signed Short형식으로 읽어서 Output에 값을 복사하는 함수
Player : 생성 트리거의 체크 플레이어
Input : 값을 읽을 대상 (상수/V/Mem/VA/A)
Output : 값을 복사할 곳 (상수/V/Mem/VA/A)
Mask : 읽어올 범위 (비트마스크)
Clear : 자동 초기화 flag - 중간 연산자에서 사용 / Dest 전체 초기화가 필요할때 1을 입력
※ Input에서 Signed Short의 범위를 넘는 값은 무시됨
_SHRead(Source,Mask)
: f_SHRead의 중간 연산자 함수
Source : Input과 동일, 나머지는 모두 f_SHRead와 동일함
ex) [예제 18-4] 참고

88

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------TBread(Offset,Type,Value)
TBwrite(Offset,Type,Value)
TTBread(Offset,Type,Value) - 특수 조건 삽입 가능
: Byte단위 연산 조건/액션 생성 함수 (변수 삽입 가능 항목 : Offset, Value)
Offset : 연산 대상 오프셋 (오프셋으로 입력, 상수/V)
Type : 조건/액션 연산자 (TBread : Exactly/AtLeast/AtMost, TBwrite : Add/Subtract/SetTo)
Value : 연산할 수 (0~255 범위내의 값 입력, 상수/V)
※ TTBread의 Type에 특수 조건(iAtLeast/iAtMost/(i)Above/(i)Below/NotSame) 입력가능함
Ex) [예제 18-5] 참고
TWread(Offset,Type,Value)
TWwrite(Offset,Type,Value)
TTWread(Offset,Type,Value) - 특수 조건 삽입 가능

: Word단위 연산 조건/액션 생성 함수 (변수 삽입 가능 항목 : Offset, Value)
Offset : 연산 대상 오프셋 (오프셋으로 입력, 상수/V)
Type : 조건/액션 연산자 (Twread : Exactly/AtLeast/AtMost, Twwrite : Add/Subtract/SetTo)
Value : 연산할 수 (0~65535 범위내의 값 입력, 상수/V)
※ TTWread의 Type에 특수 조건(iAtLeast/iAtMost/(i)Above/(i)Below/NotSame) 입력가능함
Ex) [예제 18-5] 참고
TMemoryB(Base,Index,Type,Value)
TSetMemoryB(Base,Index,Type,Value)
TTMemoryBX(Base,Index,Type,Value) - 특수 조건 삽입 가능
: Byte단위 연산 조건/액션 생성 함수 (DatEdit 오프셋 전용, 변수 삽입 가능 항목 : Index, Value)

Base : 연산 대상 베이스 오프셋 (오프셋으로 입력, 상수)
Index : 연산 대상의 인덱스 오프셋 (오프셋으로 입력, 상수/V)
Type : 조건/액션 연산자 (TMemoryB : Exactly/AtLeast/AtMost, TSetMemoryB : Add/Subtract/SetTo)

Value : 연산할 수 (0~255 범위내의 값 입력, 상수/V)

Ex) [예제 18-5] 참고
※ TTMemoryB의 Type에 특수 조건(iAtLeast/iAtMost/(i)Above/(i)Below/NotSame) 입력가능함
※ [T/TT](Set)MemoryB는 최종 오프셋 = Base + Index * 1로 계산된다. (Index의 간격이 1바이트)
※ DatEdit에서 대상 항목 오프셋의 시작지점이 Base, UnitId 등 목표지점까지의 거리가 Index다
Ex) 유닛의 높이 항목 = 0x663150 + 1*UnitId → Base = 0x663150, Index = UnitId

89

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------TMemoryW(Base,Index,Type,Value)
TSetMemoryW(Base,Index,Type,Value)
TTMemoryWX(Base,Index,Type,Value) - 특수 조건 삽입 가능
: Word단위 연산 조건/액션 생성 함수 (DatEdit 오프셋 전용, 변수 삽입 가능 항목 : Index, Value)

Base : 연산 대상 베이스 오프셋 (오프셋으로 입력, 상수)
Index : 연산 대상의 인덱스 오프셋 (오프셋으로 입력, 상수/V)
Type : 조건/액션 연산자 (TMemoryW : Exactly/AtLeast/AtMost, TSetMemoryW : Add/Subtract/SetTo)

Value : 연산할 수 (0~65535 범위내의 값 입력, 상수/V)
Ex) [예제 18-5] 참고
※ TTMemoryW의 Type에 특수 조건(iAtLeast/iAtMost/(i)Above/(i)Below/NotSame) 입력가능함
※ [T/TT](Set)MemoryW는 최종 오프셋 = Base + Index * 2로 계산된다. (Index의 간격이 2바이트)
※ DatEdit에서 대상 항목 오프셋의 시작지점이 Base, UnitId 등 목표지점까지의 거리가 Index다
Ex) 비행정보의 가속도 항목 = 0x6C9C78 + 2*FlingyId → Base = 0x6C9C78, Index = FlingyId

TMemoryDw(Base,Index,Type,Value,Mask)
TSetMemoryDw(Base,Index,Type,Value,Mask)
TTMemoryDw(Base,Index,Type,Value,Mask) - 특수 조건 삽입 가능
: Dword단위 연산 조건/액션 생성 함수 (DatEdit 오프셋 전용, 변수 삽입 가능 항목 : Index, Value)

Base : 연산 대상 베이스 오프셋 (오프셋으로 입력, 상수)
Index : 연산 대상의 인덱스 오프셋 (오프셋으로 입력, 상수/V)
Type : 조건/액션 연산자 (TMemoryDw : Exactly/AtLeast/AtMost, TSetMemoryDw : Add/Subtract/SetTo)

Value : 연산할 수 (4바이트 전체 입력가능, 상수/V)
Mask : 조건/액션의 비트마스크 (미입력시 0xFFFFFFFF로 입력됨)
Ex) [예제 18-5] 참고
※ TTMemoryDw의 Type에 특수 조건(iAtLeast/iAtMost/(i)Above/(i)Below/NotSame) 입력가능함
※ [T/TT](Set)MemoryDw는 최종 오프셋 = Base + Index * 4로 계산된다. (Index의 간격이 4바이트)
※ DatEdit에서 대상 항목 오프셋의 시작지점이 Base, UnitId 등 목표지점까지의 거리가 Index다
Ex) 무기의 최대사거리 항목 = 0x657470 + 2*WeaponId → Base = 0x657470, Index = WeaponId
※ [T/TT](Set)MemoryDw는 추가연산 없이 [T/TT](Set)Memory를 사용함

90

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------f_Bread(PlayerID,Offset,Output,Multiplier)
f_BreadX(PlayerID,Base,Index,Output,Multiplier) - DatEdit 오프셋 전용
: Byte단위 Read함수 (Output << byte(0~0xFF) * Multiplier)
(일반함수) Offset : 값을 읽어올 오프셋 (오프셋으로 입력, 상수/V)
(X함수) Base : 값을 읽어올 베이스 오프셋 (오프셋으로 입력, 상수)
(X함수) Index : 값을 읽어올 인덱스 오프셋 (오프셋으로 입력, 상수/V)
Output : 읽어온 값을 담을 대상 (상수/V/Mem)
Multiplier : 읽어온 값에 곱할 상수값 ("0","+1","+2","+3", 각각 *256^n, 비우면 사용X)
※ f_BreadX는 최종 오프셋 = Base + Index * 1로 계산된다. (Index의 간격이 1바이트)
f_Wread(PlayerID,Offset,Output,Multiplier)
f_WreadX(PlayerID,Base,Index,Output,Multiplier) - DatEdit 오프셋 전용
: Word단위 Read함수 (Output << word(0~0xFFFF) * Multiplier)
(일반함수) Offset : 값을 읽어올 오프셋 (오프셋으로 입력 (2의 배수로 입력해야함), 상수/V)

(X함수) Base : 값을 읽어올 베이스 오프셋 (오프셋으로 입력, 상수)
(X함수) Index : 값을 읽어올 인덱스 오프셋 (오프셋으로 입력, 상수/V)
Output : 읽어온 값을 담을 대상 (상수/V/Mem)
Multiplier : 읽어온 값에 곱할 상수값 ("0","+1", 각각 *65536^n, 비우면 사용X)
※ f_WreadX는 최종 오프셋 = Base + Index * 2로 계산된다. (Index의 간격이 2바이트)
Ex) [예제 18-11] 참고

f_Bwrite(PlayerID,Offset,Type,Value)
: CDoActions(PlayerID,{TBwrite(Offset,Type,Value)}) 방식으로 byte 단위로 값을 씀
f_BwriteX(PlayerID,Base,Index,Type,Value)
: CDoActions(PlayerID,{TSetMemoryB(Base,Index,Type,Value)}) 방식으로 byte 단위로 값을 씀
f_Wwrite(PlayerID,Offset,Type,Value)
: CDoActions(PlayerID,{TWwrite(Offset,Type,Value)}) 방식으로 word 단위로 값을 씀
f_WwriteX(PlayerID,Base,Index,Type,Value)
: CDoActions(PlayerID,{TSetMemoryW(Base,Index,Type,Value)}) 방식으로 word 단위로 값을 씀
f_Dwwrite(PlayerID,Offset,Type,Value,Mask)
: CDoActions(PlayerID,{TSetMemoryX(_EPD(Offset),Type,Value,Mask)}) 방식으로 dword 단위로 값을 씀

f_DwwriteX(PlayerID,Base,Index,Type,Value,Mask)
: CDoActions(PlayerID,{TSetMemoryDw(Base,Index,Type,Value,Mask)}) 방식으로 dword 단위로 값을
씀
91

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------_ParseDw(Number)
: Number(dword)를 바이트 단위로 자르는 함수
Number : 연산할 수
리턴값 : 바이트 단위로 잘린 수 4개 (각각 +0x0, +0x1, +0x2, +0x3)
Ex) Number = 0xAABBCCDD → 0xDD, 0xCC, 0xBB, 0xAA 리턴됨

_ParseW(Number)
: Number(word)를 바이트 단위로 자르는 함수
Number : 연산할 수
리턴값 : 바이트 단위로 잘린 수 2개 (각각 +0x0, +0x1)
Ex) Number = 0xAABB → 0xBB, 0xAA 리턴됨

Timer(PlayerID,Index,Init,Start,End,Step,Order
,InitAction,StepCondition,StepAction,ResetCondtion,ResetAction)
: 타이머 트리거를 자동으로 생성하는 함수 (정수 시간 간격)
PlayerID : 생성 트리거의 체크 플레이어
Index : 타이머 시간값을 저장할 위치 (상수/V/Mem, 비우면 Ccode를 할당 후 사용함)
Init : 타이머 초기값 (미 입력시 Start 값으로 입력됨)
Start : 타이머 시작값 (상수)
End : 타이머 종료값 (상수) - 시작값과 종료값의 부호가 다를경우 Signed 연산을 적용함
Step : 타이머 시간 변화량값 (상수) - 시간값이 시작~종료 범위를 넘어가도 리셋됨
Order : "RS"입력시 리셋 → 증가 순으로 트리거 생성, "SR"입력시 증가 → 리셋순으로 트리거 생성
(Start=0~End=N의 범위에서, "RS" : 1~N / "SR" : 0~N-1로 루프 작동함)
InitAction : 타이머 초기값 설정시 실행할 액션 (최초 1회만 실행함)
StepCondition : 증가 트리거를 실행할 조건
StepAction : 증가 트리거에 추가할 액션
ResetCondition : 리셋 트리거를 실행할 조건
ResetAction : 리셋 트리거에 추가할 액션
리턴값 : (Index를 비웠을 경우만) 타이머 시간값 저장용으로 할당된 Ccode
Ex) [예제 18-6] 참고
※ Timer는 초기화(1회실행) - (리셋 ↔ 증가) 트리거로 구성되어 있으며 데스값 타이머 트리거와 구조가 같음

※ Timer 트리거의 조건이나 액션에 T/TT 조건및 액션삽입이 가능함 (CTriggerX 형태로 삽입)
※ 조건이나 액션은 반드시 {조건1/액션1,조건2/액션2,…} 형태로 삽입해야함
※ Timer 트리거를 2개 이상 조합해서 복잡한 시간 트리거를 제작 가능함
92

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------TimerX(PlayerID,Index,Repeat,Init,Start,End,Step,Ratio,Order,
InitAction,ResetCondtion,ResetAction,StepCondition,StepAction)
: 타이머 트리거를 자동으로 생성하는 함수 (유리수 시간 간격)
PlayerID : 생성 트리거의 체크 플레이어
Index : 타이머 시간값을 저장할 위치 (상수/V/Mem, 비우면 Ccode를 할당 후 사용함)
Repeat : 반복횟수 카운트값을 저장할 위치 (상수/V/Mem, 비우면 Ccode를 할당 후 사용함)
Init : 타이머 초기값 (미 입력시 Start 값으로 입력됨)
Start : 타이머 시작값 (상수)
End : 타이머 종료값 (상수) - 시작값과 종료값의 부호가 다를경우 Signed 연산을 적용함
Step : 타이머 시간 변화량값 (상수) - 시간값이 시작~종료 범위를 넘어가도 리셋됨
Ratio : {반복 횟수 카운트(A), 루프의 주기(B)} 형식으로 입력, A/B비율로 반복 횟수를 카운트함
Order : "RS"입력시 리셋 → 증가 순으로 트리거 생성, "SR"입력시 증가 → 리셋순으로 트리거 생성
(Start=0~End=N의 범위에서, "RS" : 1~N / "SR" : 0~N-1로 루프 작동함)
InitAction : 타이머 초기값 설정시 실행할 액션 (최초 1회만 실행함)
StepCondition : 증가 트리거를 실행할 조건
StepAction : 증가 트리거에 추가할 액션
ResetCondition : 리셋 트리거를 실행할 조건
ResetAction : 리셋 트리거에 추가할 액션
리턴값 : {타이머 시간값 저장용으로 할당된 Ccode, 반복횟수 카운트용으로 할당된 Ccode}
Ex) [예제 18-6] 참고
※ TimerX는 초기화(1회실행) - (리셋 ↔ 증가) 트리거로 구성되어 있으며 데스값 타이머 트리거와 구조가 같음

※ TimerX 트리거를 2개 이상 조합해서 복잡한 시간 트리거를 제작 가능함

※ TimerX에서 반복 횟수 카운트를 채우는 순서는 컴파일 할때마다 랜덤으로 설정됨
※ While문 등을 통해 반복 횟수 카운트 값 만큼 한 트리거 주기내에 반복 실행시키면 된다.
※ TimerX 및 Stage 트리거의 조건이나 액션에 T/TT 조건및 액션삽입이 가능함 (CTriggerX 형태로 삽입)

※ 조건이나 액션은 반드시 {조건1/액션1,조건2/액션2,…} 형태로 삽입해야함
Stage(PlayerID,Step,StageData)
: 단계별 실행 트리거를 자동으로 생성하는 함수
PlayerID : 생성 트리거의 체크 플레이어

Step : 현재 단계 값을 저장할 위치(상수/V/Mem, Ccode 입력시 {Ccode} 형식으로 입력)
StageData : 단계별 실행할 액션을 추가할 데이터
({{Step(N 또는 {A,B}),{액션},{조건},{Flag},Index},…} 형식으로 입력,
Step에서 N입력시 Step == N의 조건을 추가함, {A,B}입력시 Step>=A, Step<=B의 조건을 추가함)
Ex) [예제 18-6] 참고

93

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------SetMapSize(Value,Mask)
TSetMapSize(Value,Mask) -- 변수 삽입형 액션
: 맵의 크기를 변경하는 액션 (0xFFFF : X크기/0xFFFF0000 : Y크기)
Value : 변경할 값
Mask : 액션의 비트마스크
※ 맵의 사이즈 변경은 오류가 발생할 수도 있습니다. (어떤 경우에는 나간 뒤에도 버그가 지속됨)
PlayerState(Player,State) -- 조건
SetPlayerState(Player,State) -- 액션
: 플레이어의 현재 상태를 변경하는 조건/액션
Player : 대상 플레이어 (P1~P12)
State : 변경할 상태값 (0 = inactive, 1 = 컴퓨터, 2 = 사람, 3 = 구조가능, 7 = 중립)
※ 플레이어의 상태값을 사람이 아니게 바꾸면 동맹창에서 사라짐

PauseCount(Player,Type,Value) -- 조건
SetPauseCount(Player,Type,Value) -- 액션
: 플레이어의 남은 퍼즈 개수를 변경하는 조건/액션
Player : 대상 플레이어 (P1~P8)
State : 변경할 갯수 (0~255)
DropTimer(Type,Value) -- 조건
SetDropTimer(Type,Value) -- 액션

: 드랍창의 남은 시간을 변경하는 조건/액션
Type : 조건/액션 연산자 (조건 : Exactly/AtLeast/AtMost, 액션 : Add/Subtract/SetTo)
Value : 변경할 남은 시간 (4바이트)
DropWindow(Type,Value) -- 조건
SetDropWindow(Type,Value) -- 액션
: 드랍창의 남은 표시 시간을 변경하는 조건/액션
Type : 조건/액션 연산자 (조건 : Exactly/AtLeast/AtMost, 액션 : Add/Subtract/SetTo)

Value : 변경할 남은 시간 (4바이트)
VisionTurbo(PlayerID)
: 터보시야 (0x51CE98)의 값을 1로 고정 시키는 트리거 (0으로 고정시 시야가 꺼지지 않음)
PlayerID : 생성 트리거의 체크 플레이어

94

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------SaveValueMsg(String,FileName)
: String의 내용을 AbsolutePath에 파일로 저장하는 함수
String : 저장할 스트링
FileName : 저장할 파일의 이름 (AbsolutePath에 해당 파일명으로 저장됨)
FindSD(PlayerID,TargetPlayer,Location,Output,Preserve)

: 대상 플레이어의 화면크기가 와이드 스크린인지 체크하는 함수
PlayerID : 생성 트리거의 체크 플레이어
TargetPlayer : 화면크기를 체크할 대상 플레이어
Location : 화면크기를 체크하는데 사용할 로케이션 (좌표값 모두 변함)
({로케이션, 유닛ID} 형식으로 입력시 해당 플레이어의 UnitID를 센터뷰함, 기본값 192(테란 마커))
Output : 와이드 스크린이 아닐시 1, 와이드 스크린이면 0을 출력함 (상수/V/Mem 입력)
Preserve : 0 입력시 1회만 실행함

ExitDrop(PlayerID,DropPlayer) ＃STRCtrig 필수
: 대상 플레이어를 맵에 감금시킵니다. (어떠한 방법으로도 나갈시 무한루프 형식으로 스타 크래쉬)
PlayerID : 생성 트리거의 체크 플레이어
Player : 대상 플레이어 (P1~P8, "Ob1"~"Ob4")
※ If등 조건문들로 ExitDrop 트리거의 실행을 멈추면 다음틱에 감금이 해제됨
※ 승리나 패배등으로 나갈시에도 감금 미 해제시 스타 꺼짐
CMotion(PlayerID,Displacement,Velocity,Acceleration,Time)

: 가속도 운동의 좌표 연산을 실행하는 함수 (실행시 v = v0+aΔt, d = (v+v0)*Δt/2를 계산함)
PlayerID : 생성 트리거의 체크 플레이어
Displacement : 변위(d) (V)
Velocity : 속도(v) (V)
Acceleration : 가속도(a) (V)
Time : 시간 변화량(Δt) (상수/V, 비우면 1로 입력됨)
※ 힘을 가속도에 대한 식으로 바꿔서 2D 물리엔진을 만들 수 있음
※ CMotion의 인자에 중간연산자 사용금지

Ex) [예제 18-7] 참고

95

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------IBGM_EPD(PlayerID,TargetPlayer,Input,WAVData,AlertWav)
: 끊김 없는 BGM 재생을 실행하는 함수
PlayerID : 생성 트리거의 체크 플레이어
TargetPlayer : BGM을 재생할 플레이어 (플레이어 배열 입력 가능)
Input : 재생할 BGM의 인덱스 값을 저장한 곳 (상수/V/Mem)
WAVData : 재생할 BGM 리스트 ({{Index,사운드 이름,사운드 길이},…} 형식으로 입력, Index는 1이상을 입력)

AlertWav : 다른 BGM이 재생중에 사운드 재생값이 들어왔을 때 대신 출력할 사운드 이름 (미입력시 재생X)

※ Input에 WavData에 등록한 Index의 값을 넣으면 해당 사운드의 길이동안 그 사운드를 재생함
※ 사운드 길이는 ms단위로 입력해야함 (1000분의 1초)
IBGM_EPDX(PlayerID,TargetPlayer,Input,WAVData,AlertWav)
: 끊김 없는 BGM 재생을 실행하는 함수 (연속 재생 탑재)
PlayerID : 생성 트리거의 체크 플레이어
TargetPlayer : BGM을 재생할 플레이어 (플레이어 배열 입력 가능)

Input : 재생할 BGM의 인덱스 값을 저장한 곳 (V)
WAVData : 재생할 BGM 리스트 ({{Index,사운드 이름,사운드 길이},…} 형식으로 입력, Index는 1이상을 입력)
AlertWav : 다른 BGM이 재생중에 사운드 재생값이 들어왔을 때 대신 출력할 사운드 이름 (미입력시 재생X)

※ Input에 WavData에 등록한 Index의 값을 넣으면 해당 사운드의 길이동안 그 사운드를 재생함
※ IBGM_EPDX는 재생중에 다른 사운드 재생값이 들어왔을 때 1개까지는 저장했다가,
지금 재생중인 사운드가 종료되었을 때 저장한 사운드를 연속해서 재생시킴
NPA5(PlayerID,Pointer,Fileptr,Size,DestDistance,SourceDistance)

: Pointer에 Fileptr의 내용을 Size만큼 복사시키는 함수 (NPA5와 원리 동일, f_MemcpyEPD사용)
PlayerID : 생성 트리거의 체크 플레이어
Pointer : 파일 내용을 복사시킬 위치를 가리키는 포인터 (상수)
Fileptr : 복사할 내용을 담고있는 곳의 위치 (상수/V/Mem)
DestDistance : Dest 붙임 간격 (기본값 1)
SourceDistance : Source 복사 간격 (기본값 1, Fileptr에 V입력시 604로 입력됨)
※ f_GetFileptr, f_GetVArrptr등의 리턴값을 Fileptr에 넣어서 Stat_txt.tbl, Aiscript.bin등을 복사할수있음
Ex) [예제 18-8] 참고

96

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------f_CGive(PlayerID,UnitEPD,UnitPtr,NewOwner,PrevOwner)
: 구조오프셋으로 유닛을 NewOwner에게 Give하는 함수 (서브유닛 존재시 2회 실행됨)
PlayerID : 생성 트리거의 체크 플레이어
UnitEPD : 복사할 유닛의 구조오프셋 EPD값 (상수/V/VA)
UnitPtr : 복사할 유닛의 구조오프셋값 (상수/V/VA, EPD와 Ptr중 둘중 하나만 입력해도 됨)
NewOwner : 유닛을 소유하게될 플레이어 (상수/V/VA, P1~P12중 입력)

PrevOwner : 유닛을 소유했던 전 플레이어 (상수/V/VA, 비워도 됨)
※ 드랍쉽에 탄 유닛, 캐리어의 인터셉터, 리버의 스캐럽 등은 본체를 CGive해도 같이 적용되지 않음
IsTyping()
: 채팅을 치고 있을 경우 참인 조건 (비공유 조건)
NotTyping()
: 채팅을 치고 있지 않을 경우 참인 조건 (비공유 조건)
KeyPress(KeyName,Status)
: 키보드 키를 누를 때를 인식하는 조건 (비공유 조건)
KeyName : 인식할 키보드 키 이름
Status : "Up" 입력시 안 누르고 있을때, "Down" 입력시 누르고 있을때 만족함
TTKeyPress(KeyName,Status)
: 키보드 키를 누를 때를 인식하는 조건 (비공유 조건, 특수 조건형 함수)
KeyName : 인식할 키보드 키 이름

Status : "Up" 입력시 눌렀다가 땔 때, "Down" 입력시 땠다가 눌렀을 때 1회 만족함
※ KeyName 목록은 27장의 키 인식 목록 참고
MousePress(KeyName,Status)
: 마우스 버튼을 누를 때를 인식하는 조건 (비공유 조건)
KeyName : 인식할 마우스 버튼 이름
Status : "Up" 입력시 안 누르고 있을때, "Down" 입력시 누르고 있을때 만족함
TTMousePress(KeyName,Status)

: 마우스 버튼을 누를 때를 인식하는 조건 (비공유 조건, 특수 조건형 함수)
KeyName : 인식할 마우스 버튼 이름
Status : "Up" 입력시 눌렀다가 땔 때, "Down" 입력시 땠다가 눌렀을 때 1회 만족함
※ KeyName 목록은 27장의 마우스 키 목록 참고
Ex) [예제 18-9] 참고

97

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------f_OffsetToAlphaID(PlayerID,Input,Output)
: 구조오프셋의 알파ID를 구하는 함수 (Offset 값 입력)
PlayerID : 생성 트리거의 체크 플레이어
Input : 알파ID를 구할 구조오프셋 (상수/V)
Output : 구조오프셋의 AlphaID (상수/V/Mem)
※ 빈 슬롯의 알파ID는 0으로 채워짐

f_EPDToAlphaID(PlayerID,Input,Output)
: 구조오프셋의 알파ID를 구하는 함수 (EPD 값 입력)
PlayerID : 생성 트리거의 체크 플레이어
Input : 알파ID를 구할 구조오프셋의 EPD (상수/V)
Output : 구조오프셋의 AlphaID (상수/V/Mem)
※ f_[Offset/EPD]ToAlphaID로 구한 알파ID를 (Set)HotKeyUnit 조건/액션의 Value에 넣어 사용가능
f_AlphaIDToCunit(PlayerID,Input,Output,EPDOutput)

: 알파ID로 구조오프셋을 구하는 함수
PlayerID : 생성 트리거의 체크 플레이어
Input : 구조오프셋을 구할 AlphaID (상수/V)
Output : 알파ID의 구조오프셋 값 (상수/V/Mem, 비우면 사용X, 알파ID가 0이면 0을 출력함)
EPDOutput : 알파ID의 구조오프셋의 EPD 값 (상수/V/Mem, 비우면 사용X , 알파ID가 0이면 0을 출력함)

_HotKeyUnit(Player,Group,Index)
: 부대지정 오프셋의 주소를 구하는 함수 (오프셋 값을 리턴함)
Player : 대상 플레이어
Group : 부대지정 그룹 (0~9 각각 0~9번키의 지정된 부대)
Index : 부대지정내의 인덱스 (0~11)
HotkeyUnit(Player,Group,Index,Type,Value) - 조건
SetHotkeyUnit(Player,Group,Index,Type,Value) - 액션
: 대상 플레이어의 부대지정된 유닛을 변경하는 조건 및 액션
Player : 대상 플레이어
Group : 부대지정 그룹 (0~9 각각 0~9번키의 지정된 부대)

Index : 부대지정내의 인덱스 (0~11)
Type : 조건/액션 연산자 (조건 : Exactly/AtLeast/AtMost, 액션 : Add/Subtract/SetTo)
Value : 변경할 값 (알파ID를 입력)
Ex) [예제 18-10] 참고
98

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------THotkeyUnit(Player,Group,Index,Type,Value) - 조건
TSetHotkeyUnit(Player,Group,Index,Type,Value) - 액션
TTHotKeyUnit(Player,Group,Index,Type,Value) - 특수 조건
: 대상 플레이어의 부대지정된 유닛을 변경하는 조건 및 액션 (변수 삽입형 조건 및 액션)
Player : 대상 플레이어
Group : 부대지정 그룹 (0~9 각각 0~9번키의 지정된 부대)

Index : 부대지정내의 인덱스 (0~11)
Type : 조건/액션 연산자 (조건 : Exactly/AtLeast/AtMost, 액션 : Add/Subtract/SetTo)
Value : 변경할 값 (알파ID를 입력)
※ 변수 삽입 가능 항목 : Group, Index, Value (Player는 상수만 가능)
Ex) [예제 18-10] 참고
SetUnitName(UnitId,StringId)
: 유닛의 이름에 연결된 스트링을 바꾸는 액션

UnitId : 대상 유닛의 Id
StringId : 유닛의 이름에 연결할 스트링 Id (상수)
※ StringId값은 f_GetStr(X)ptr, GetiStrptr등의 함수의 리턴값을 입력하면 됨
Ex) [예제 26-19] 참고

99

------------------------------------------------------------------------------------------

『 19장 : 기타 스트링 관련 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ InitBytes(편차값)은 0~3의 값을 가지며, 각각 +0x0 (0xFFFFFFFF),
+0x1 (0xFFFFFF00), +0x2 (0xFFFF0000), +0x3 (0xFF000000) 부터 시작함｡+.ﾟ

｡˙+ﾟ Print_utf8X.lua 함수 ｡+.ﾟ
print_utf8(line, offset, string)
: line번째 줄의 Offset(시작위치)에 String내용을 출력함
line : 출력할 채팅줄 (0~10 / 13번째줄 : 12)
offset : 출력 시작 위치 (0~218)

string : 출력할 스트링 내용 ("내용" 으로 직접입력)

check_utf8(line, offset, string)
: line번째 줄의 Offset(시작위치)에 String내용을 체크함
line : 체크할 채팅줄 (0~10 / 13번째줄 : 12)
offset : 체크 시작 위치 (0~218)
string : 체크할 스트링 내용 ("내용" 으로 직접입력)

100

------------------------------------------------------------------------------------------

『 19장 : 기타 스트링 관련 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ InitBytes(편차값)은 0~3의 값을 가지며, 각각 +0x0 (0xFFFFFFFF),
+0x1 (0xFFFFFF00), +0x2 (0xFFFF0000), +0x3 (0xFF000000) 부터 시작함｡+.ﾟ

Print_String(PlayerID, Dest, String, InitBytes)
: Dest에 String내용을 출력함 (InitBytes만큼 밀어서 출력)
PlayerID : 생성할 트리거의 체크 플레이어
Dest : 출력을 시작할 위치(epd로 입력) - 상수(epd)/변수/VA

String : 출력할 스트링 내용 ("내용" 으로 직접입력)
InitBytes : 시작 위치의 편차값 (0~3 입력)
ex) [예제 19-1] 참고
Print_StringX(PlayerID, DestVA, String, InitBytes)
: DestVA에 String내용을 출력함 (InitBytes만큼 밀어서 출력)
PlayerID : 생성할 트리거의 체크 플레이어
DestVA : 출력을 시작할 변수의 위치(V 또는 VA타입으로 입력)
String : 출력할 스트링 내용 ("내용" 으로 직접입력)
InitBytes : 시작 위치의 편차값 (0~3 입력)
ex) [예제 19-5] 참고

Print_13(PlayerID,DisplayPlayer,String)
: 원하는 플레이어에게 13번째 줄에 String을 출력하는 함수
PlayerID : 생성 트리거의 체크 플레이어
DisplayPlayer : 출력할 대상 플레이어 ({P1,P2,...}로 입력)
String : 출력할 스트링 내용 ("내용" 으로 직접입력)
ex) [예제 19-1] 참고

101

------------------------------------------------------------------------------------------

『 19장 : 기타 스트링 관련 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ InitBytes(편차값)은 0~3의 값을 가지며, 각각 +0x0 (0xFFFFFFFF),
+0x1 (0xFFFFFF00), +0x2 (0xFFFF0000), +0x3 (0xFF000000) 부터 시작함｡+.ﾟ

GetStrSize(cp949flag,String,Null)
: 입력한 문자열의 길이(Size)를 반환하는 함수
cp949flag : 0입력시 utf-8로, 1입력시 cp949 문자열로 간주하여 길이를 계산함
String : 길이를 계산할 문자열을 입력 (String Id를 입력해도됨)

Null : 스트링의 끝(0x00)을 포함할지 여부 (1 입력시 포함)
리턴값 : 문자열의 길이
ex) [예제 19-5] 참고
GetStrArr(cp949flag,String,Null)
: 입력한 문자열을 char형 배열로 변환하는 함수 (1바이트씩 분할)
cp949flag : 0입력시 utf-8로, 1입력시 cp949 문자열로 간주하여 길이를 계산함
String : 배열로 변환할 문자열을 입력 (String Id를 입력해도됨)
Null : 스트링의 끝(0x00)을 포함할지 여부 (1 입력시 포함)
리턴값 : 변환된 배열
Ex) [예제 25-1] 참고
※ utf-8 : 영어및 기본문자 1바이트, 한글및 특수문자 3바이트 (Print_String류 함수)
cp949 : 영어및 기본문자 1바이트, 한글및 특수문자 2바이트 (Str 단락 입력 스트링)
GetStrId(String)

: 입력한 문자열의 String Id를 반환하는 함수
String : String Id를 구할 문자열을 입력
※ String에 입력된 문자열은 맵의 Str단락에 그대로 저장됨
SaveStrArr(Dest,StrArr,Distance)
: 입력한 문자열 배열(GetStrArr의 반환값)을 메모리에 저장하는 함수
Dest : 문자열을 저장할 위치 (상수/V/Mem)
StrArr : 저장할 문자열 배열 (GetStrArr의 반환값)을 입력
Distance : 저장할 데이터 단락 간격의 크기 (기본값 4byte per 1epd)
※ 리턴값이 액션이므로 DoActions2(X)나 Trigger2(X)에 삽입해서 사용해야함
Ex) [예제 25-4] 참고
102

------------------------------------------------------------------------------------------

『 19장 : 기타 스트링 관련 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ InitBytes(편차값)은 0~3의 값을 가지며, 각각 +0x0 (0xFFFFFFFF),
+0x1 (0xFFFFFF00), +0x2 (0xFFFF0000), +0x3 (0xFF000000) 부터 시작함｡+.ﾟ

GetPlayerName(PlayerID,TargetPlayer,OutputVA,InitBytes)
: 원하는 플레이어의 ID를 스트링 형식으로 가져옴
(솔플시 제대로 작동 안될수도있음)
PlayerID : 생성 트리거의 체크 플레이어

TargetPlayer : ID를 저장할 플레이어
OutputVA : 값을 저장할 VA (상수 인덱스) (크기 5 필요)
InitBytes : 저장할 위치의 편차값 (0~3 입력)
ex) [예제 19-2] 참고
GetPlayerLength(PlayerID,TargetPlayer,Output,Multiplier)
: 원하는 플레이어의 ID의 길이를 저장함 (3~15글자)
PlayerID : 생성 트리거의 체크 플레이어

TargetPlayer : ID의 길이를 저장할 플레이어
Output : 값을 저장할 변수 / Multiplier : 길이 값에 곱할 숫자 / ex) [예제 25-3] 참고
ItoName(PlayerID,TargetPlayer,OutputVA,Color)
: 원하는 플레이어의 ID를 스트링 형식으로 저장함 (완충영역O)
(솔플시 제대로 작동 안될수도있음)
PlayerID : 생성 트리거의 체크 플레이어
TargetPlayer : ID를 저장할 플레이어

OutputVA : 값을 저장할 VA (상수 인덱스) (크기 5 필요)
Color : 글자에 입힐 컬러코드 (비우면 0xD)
ex) [예제 19-2] 참고
ItoX(PlayerID,Input,OutputVA,Color)
: 변수의 값을 전각문자로 변환함 (완충영역X) - 1234 → １２３４
PlayerID : 생성 트리거의 체크 플레이어
Input : 값을 변환할 변수
OutputVA : 값을 저장할 VA (상수 인덱스)
(크기 4 필요) : VA[상수]로 입력시 VA[상수+0],VA[상수+1],VA[상수+2],VA[상수+3]에 입력됨
{V1,V2,V3,V4}로 입력시 V1, V2, V3, V4에 각각 입력됨 (안쓸경우 "X" 입력)
Color : 글자에 입힐 컬러코드 (비우면 0xD) : 1234 → {1,2,3,4} 순으로 인식
ex) [예제 19-5] 참고

103

------------------------------------------------------------------------------------------

『 19장 : 기타 스트링 관련 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ InitBytes(편차값)은 0~3의 값을 가지며, 각각 +0x0 (0xFFFFFFFF),
+0x1 (0xFFFFFF00), +0x2 (0xFFFF0000), +0x3 (0xFF000000) 부터 시작함｡+.ﾟ

ItoDec(PlayerID,Input,OutputVA,ZeroMode,Color,Sign,DigitMax,DigitMin)
: 변수의 값을 10진법 스트링 형식으로 저장함 (완충영역O)
PlayerID : 생성 트리거의 체크 플레이어
Input : 값을 변환할 변수

OutputVA : 값을 저장할 VA (상수 인덱스) (크기 4 필요)
ZeroMode : 앞글자 0을 표시할 방식 선택 (0 : 00001000 / 1 :

1000 / 2 : 1000)

Color : 글자에 입힐 컬러코드 (비우면 0xD)
Sign : 부호 표시여부 선택 (-1000 → 0 : 4294966296 / 1 : -1000 / 2 : - 1000)
DigitMax : 표시 최대 자릿수 선택 (1~10 입력, 기본값 10)
DigitMin : 표시 최소 자릿수 선택 (1~10 입력, 기본값 1)
ex) [예제 19-3] 참고

ItoHex(PlayerID,Input,OutputVA,ZeroMode,Color,Case,DigitMax,DigitMin)
: 변수의 값을 16진법 스트링 형식으로 저장함 (완충영역O)
PlayerID : 생성 트리거의 체크 플레이어
Input : 값을 변환할 변수
OutputVA : 값을 저장할 VA (상수 인덱스) (크기 3 필요)
ZeroMode : 앞글자 0을 표시할 방식 선택 (0 : 00001000 / 1 :

1000 / 2 : 1000)

Color : 글자에 입힐 컬러코드 (비우면 0xD)
Case : 알파벳 대소문자 표시 여부 선택 (0 : 0xABCD1234 / 1 : 0xabcd1234)

DigitMax : 표시 최대 자릿수 선택 (1~8 입력, 기본값 8)
DigitMin : 표시 최소 자릿수 선택 (1~8 입력, 기본값 1)
ex) [예제 19-4] 참고

104

------------------------------------------------------------------------------------------

『 19장 : 기타 스트링 관련 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ InitBytes(편차값)은 0~3의 값을 가지며, 각각 +0x0 (0xFFFFFFFF),
+0x1 (0xFFFFFF00), +0x2 (0xFFFF0000), +0x3 (0xFF000000) 부터 시작함｡+.ﾟ

ItoDecX(PlayerID,Input,OutputVA,ZeroMode,Color,Sign,DigitMax,DigitMin)
: 변수의 값을 10진법 특수 스트링(１２３４）형식으로 저장함 (완충영역O)
PlayerID : 생성 트리거의 체크 플레이어
Input : 값을 변환할 변수

OutputVA : 값을 저장할 VA (상수 인덱스) (크기 12 필요)
ZeroMode : 앞글자 0을 표시할 방식 선택 (0 : 00001000 / 1 :

1000 / 2 : 1000)

Color : 글자에 입힐 컬러코드 (비우면 0xD) : +1234567890 → {0,9,8,7,6,5,4,3,2,1,+} 순으로 인식
Sign : 부호 표시여부 선택 (-1000 → 0 : 4294966296 / 1 : -1000 / 2 : - 1000)
DigitMax : 표시 최대 자릿수 선택 (1~10 입력, 기본값 10)
DigitMin : 표시 최소 자릿수 선택 (1~10 입력, 기본값 1)
ex) [예제 19-3] 참고

ItoHexX(PlayerID,Input,OutputVA,ZeroMode,Color,Case,DigitMax,DigitMin)
: 변수의 값을 16진법 특수 스트링(１２３４）형식으로 저장함 (완충영역O)
PlayerID : 생성 트리거의 체크 플레이어
Input : 값을 변환할 변수
OutputVA : 값을 저장할 VA (상수 인덱스) (크기 3 필요)
ZeroMode : 앞글자 0을 표시할 방식 선택 (0 : 00001000 / 1 :

1000 / 2 : 1000)

Color : 글자에 입힐 컬러코드 (비우면 0xD) : 12345678 → {8,7,6,5,4,3,2,1} 순으로 인식
Case : 알파벳 대소문자 표시 여부 선택 (0 : 0xABCD1234 / 1 : 0xabcd1234)

DigitMax : 표시 최대 자릿수 선택 (1~8 입력, 기본값 8)
DigitMin : 표시 최소 자릿수 선택 (1~8 입력, 기본값 1)
ex) [예제 19-4] 참고

105

------------------------------------------------------------------------------------------

『 19장 : 기타 스트링 관련 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ InitBytes(편차값)은 0~3의 값을 가지며, 각각 +0x0 (0xFFFFFFFF),
+0x1 (0xFFFFFF00), +0x2 (0xFFFF0000), +0x3 (0xFF000000) 부터 시작함｡+.ﾟ

GetHostPlayerID(PlayerID,Output))
: 방장 플레이어의 플레이어ID를 구함
PlayerID : 생성 트리거의 체크 플레이어
Output : 값을 저장할 변수(V)
GetHostName(PlayerID,OutputVA,InitBytes)
: 방장 플레이어의ID를 스트링 형식으로 가져옴
PlayerID : 생성 트리거의 체크 플레이어
OutputVA : 값을 저장할 VA (상수 인덱스) (크기 5 필요)
InitBytes : 저장할 위치의 편차값 (0~3 입력)
GetHostLength(PlayerID,Output,Multiplier)
: 방장 플레이어의 ID의 길이를 저장함 (3~15글자)
PlayerID : 생성 트리거의 체크 플레이어
Output : 값을 저장할 변수 / Multiplier : 길이 값에 곱할 숫자
ItoHost(PlayerID,OutputVA,Color)
: 방장 플레이어의 ID를 스트링 형식으로 저장함 (완충영역O)
PlayerID : 생성 트리거의 체크 플레이어
OutputVA : 값을 저장할 VA (상수 인덱스) (크기 5 필요)
Color : 글자에 입힐 컬러코드 (비우면 0xD)
HostName(Name,Length)
: 방장의 ID를 Name과 비교하는 조건을 생성함
Name : ID와 비교할 스트링
Length : 비교할 길이 (앞에서부터 비교함, 비우면 16으로 입력됨)

PlayerName(TargetPlayer,Name,Length)
: 원하는 플레이어의 ID를 Name과 비교하는 조건을 생성함
TargetPlayer : ID를 비교할 플레이어
Name : ID와 비교할 스트링
Length : 비교할 길이 (앞에서부터 비교함, 비우면 16으로 입력됨)
ex) [예제 19-6] 참고
106

------------------------------------------------------------------------------------------

『 20장 : CreateUnitShape.lua 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CreateUnitShape.lua는 여러 모양으로 유닛을 생성하는 함수입니다.
CtrigAsm이 없어도 사용가능합니다.｡+.ﾟ
CreateUnitPolygon(PlayerID,Condition,Number,UnitId,LocId,ForPlayer,LocX,LocY,PerUnit
,SizeofLoc,Radius,Angle,Points,Preserve)
: 정다각형 모양으로 유닛을 생성하는 함수
PlayerID : 생성 트리거의 체크 플레이어

Condition : 유닛 생성 트리거를 실행할 조건
Number : 생성할 유닛 갯수
UnitId : 생성할 유닛 Id (유닛 이름 입력가능)
LocId : 생성할때 사용할 로케이션 (로케이션 이름 입력가능)
ForPlayer : 생성할 유닛의 플레이어
LocX : 유닛 생성 중심 X 좌표
LocY : 유닛 생성 중심 Y 좌표
PerUnit : 한 점당 생성할 유닛수

SizeofLoc : 유닛 생성시 로케이션 크기
Radius : 정다각형 도형 껍질간의 간격
Angle : 정다각형 도형의 회전각도
Points : 정다각형 도형의 각 수
Preserve : PreserveTrigger 액션 삽입여부 (비우면 삽입, 0 입력시 삽입X)
CreateUnitPolygonWithProperties(PlayerID,Condition,Number,UnitId,LocId,ForPlayer,LocX,LocY
,PerUnit,SizeofLoc,Radius,Angle,Points,Preserve,Properties)

: CreateUnitPolygon의 Properties 삽입 가능 버전
Properties : 생성할 유닛의 특성 설정 (CreateUnitWithProperties와 동일)
CreateUnitPolygonSafe(PlayerID,Condition,Number,UnitId,LocId,ForPlayer,PerUnit
,SizeofLoc,Radius,Angle,Points,Preserve)
: CreateUnitPolygon에서 고정 좌표 대신 로케이션을 중심으로 생성함
CreateUnitPolygonSafeWithProperties(PlayerID,Condition,Number,UnitId,LocId,ForPlayer,PerUnit
,SizeofLoc,Radius,Angle,Points,Preserve,Properties)
: CreateUnitPolygonSafe의 Properties 삽입 가능 버전
Properties : 생성할 유닛의 특성 설정 (CreateUnitWithProperties와 동일)
Ex) [예제 20-1] 참고
107

------------------------------------------------------------------------------------------

『 20장 : CreateUnitShape.lua 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CreateUnitShape.lua는 여러 모양으로 유닛을 생성하는 함수입니다.
CtrigAsm이 없어도 사용가능합니다.｡+.ﾟ
CreateUnitLine(PlayerID,Condition,Number,UnitId,LocId,ForPlayer,LocX,LocY,PerUnit,
SizeofLoc,Radius,Angle,Points,Preserve)
: 직선 모양으로 유닛을 생성하는 함수 (Points에 1입력시 반직선으로 생성함)
CreateUnitLineWithProperties(PlayerID,Condition,Number,UnitId,LocId,ForPlayer,LocX,LocY

,PerUnit,SizeofLoc,Radius,Angle,Points,Preserve,Properties)
: CreateUnitLine의 Properties 삽입 가능 버전
Properties : 생성할 유닛의 특성 설정 (CreateUnitWithProperties와 동일)
CreateUnitLineSafe(PlayerID,Condition,Number,UnitId,LocId,ForPlayer,PerUnit,
SizeofLoc,Radius,Angle,Points,Preserve)
: CreateUnitLine에서 고정 좌표 대신 로케이션을 중심으로 생성함
CreateUnitLineSafeWithProperties(PlayerID,Condition,Number,UnitId,LocId,ForPlayer,PerUnit,
SizeofLoc,Radius,Angle,Points,Preserve,Properties)
: CreateUnitLineSafe의 Properties 삽입 가능 버전
Properties : 생성할 유닛의 특성 설정 (CreateUnitWithProperties와 동일)
CreateUnitStar(PlayerID,Condition,Number,UnitId,LocId,ForPlayer,LocX,LocY,PerUnit,
SizeofLoc,Radius,Angle,Points,StarAngle,Preserve)
: 별 모양으로 유닛을 생성하는 함수
StarAngle에 변의 중점 사이 각도를 입력
Number에 짝수(2n)를 입력해야 정n각 별이 만들어짐
CreateUnitStarWithProperties(PlayerID,Condition,Number,UnitId,LocId,ForPlayer,LocX,LocY,
PerUnit,SizeofLoc,Radius,Angle,Points,StarAngle,Preserve,Properties)
: CreateUnitStar의 Properties 삽입 가능 버젼
Properties : 생성할 유닛의 특성 설정 (CreateUnitWithProperties와 동일)
CreateUnitStarSafe(PlayerID,Condition,Number,UnitId,LocId,ForPlayer,PerUnit,
SizeofLoc,Radius,Angle,Points,StarAngle,Preserve)
: CreateUnitStar에서 고정 좌표 대신 로케이션을 중심으로 생성함

CreateUnitStarSafeWithProperties(PlayerID,Condition,Number,UnitId,LocId,ForPlayer,PerUnit,
SizeofLoc,Radius,Angle,Points,StarAngle,Preserve,Properties)
: CreateUnitStarSafe의 Properties 삽입 가능 버전
Properties : 생성할 유닛의 특성 설정 (CreateUnitWithProperties와 동일)
Ex) [예제 20-1] 참고

108

------------------------------------------------------------------------------------------

『 20장 : CreateUnitShape.lua 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CreateUnitShape.lua는 여러 모양으로 유닛을 생성하는 함수입니다.
CtrigAsm이 없어도 사용가능합니다.｡+.ﾟ
CreateUnitFlower(PlayerID,Condition,Number,UnitId,LocId,ForPlayer,LocX,LocY,PerUnit,
SizeofLoc,Radius,Angle,PolarPointsNumerator,PolarPointsDenominator,Partition,RadiusConstant,
CenterPoint,Halfdomain,Preserve)
: 꽃 모양(극좌표 그래프 개형)으로 유닛을 생성하는 함수

(r = kSin((α/β)Θ+a)+b 궤적으로 유닛을 생성함)
PolarPointsNumerator : α의 값을 결정
PolarPointsDenominator : β의 값을 결정
Halfdomain : Θ의 정의역을 0≤Θ≤2πβ 에서 0≤Θ≤πβ 로 변경
Partition : 한 단계당 몇점을 찍을시 설정 (찍히는 점 수는 단계 * Partition 값)
RadiusConstant : b의 값을 결정 / Angle : a의 값을 결정
CenterPoint : 첫 가운데 점을 찍을지 설정 (1 = 찍음)

CreateUnitFlowerWithProperties(PlayerID,Condition,Number,UnitId,LocId,ForPlayer,LocX,LocY,
PerUnit,SizeofLoc,Radius,Angle,PolarPointsNumerator,PolarPointsDenominator,Partition
,RadiusConstant,CenterPoint,Halfdomain,Preserve,Properties)
: CreateUnitFlower의 Properties 삽입 가능 버전
Properties : 생성할 유닛의 특성 설정 (CreateUnitWithProperties와 동일)
CreateUnitFlowerSafe(PlayerID,Condition,Number,UnitId,LocId,ForPlayer,PerUnit,SizeofLoc,
Radius,Angle,PolarPointsNumerator,PolarPointsDenominator,Partition,RadiusConstant,

CenterPoint,Halfdomain,Preserve)
: CreateUnitFlower에서 고정 좌표 대신 로케이션을 중심으로 생성함
CreateUnitFlowerSafeWithProperties(PlayerID,Condition,Number,UnitId,LocId,ForPlayer,PerUnit,
SizeofLoc,Radius,Angle,PolarPointsNumerator,PolarPointsDenominator,Partition,RadiusConstant,
CenterPoint,Halfdomain,Preserve,Properties)
: CreateUnitFlowerSafe의 Properties 삽입 가능 버전
Properties : 생성할 유닛의 특성 설정 (CreateUnitWithProperties와 동일)
Ex) [예제 20-1] 참고

109

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CopyCpAction 전용 함수 (사용법은 일반 액션과 동일) ｡+.ﾟ
DisplayTextX(Text,AlwaysDisplay)
PlayWAVX(WAVName)
SetMissionObjectivesX(Text)

TransmissionX(Unit,Where,WAVName,TimeModifier,Time,Text,AlwaysDisplay)
LeaderBoardKillsX(Unit,Label)
LeaderBoardScoreX(ScoreType,Label)
LeaderBoardResourcesX(ResourceType,Label)
LeaderBoardControlX(Unit,Label)
LeaderBoardControlAtX(Unit,Location,Label)
LeaderBoardGoalScoreX(Goal,ScoreType,Label)
LeaderBoardGoalKillsX(Goal,Unit,Label)

LeaderBoardGoalResourcesX(Goal,ReesourceType,Label)
LeaderBoardGoalControlX(Goal,Unit,Label)
LeaderBoardGoalControlAtX(Goal,Unit,Location,Label)
: CopyCpAction 전용 함수 (각 액션의 인자는 원본 액션과 동일, 원본 액션에 X를 붙이면 사용가능)
CopyCpAction(X)에 CpActions칸에 {액션1,액션2,…} 형식으로 삽입
액션X가 없는 CurrentPlayer액션의 경우 해당 액션 자체를 CpActions칸에 삽입
CopyCpAction(CpActions,Player,CurrentCp)
CopyCpActionX(CpActions,Player,CurrentCp)
: 한 트리거 내에서 Cp변경을 사용해 여러 플레이어에게 String인자가 포함된 액션을 사용할 때
이용하는 함수 (Scmdraft2 스트링 깨짐 방지용으로 사용)
Ex) SetCp(0), PlayWav("1.wav"), SetCp(2), PlayWav("1.wav"), … 등을 사용할 때 대신 사용
CpActions : 각 플레이어에게 사용할 액션, {액션1, 액션2,…} 형식으로 삽입,
일반 액션을 그대로 삽입가능하나, String인자가 있는 액션은 CopyCpAction 전용함수를 사용해야함
각 플레이어에게 인자를 다르게 적용하는 경우, 일반 액션 : {"액션명",인자1,인자2,…} 형식으로 입력
CopyCpAction 전용함수의 경우 액션 인자에 그대로 {인자1,인자2,…} 입력가능
Player : CpActions를 실행할 플레이어 - {P1,P2,Force1,…} 같은 형식으로 입력
(P9~P12 = 각 관전자1~4, Force5 = 관전자 전체, EveryPlayers = 관전자 포함 모든 플레이어)
CurrentCp : 복구할 Cp값 - 트리거의 체크 플레이어 입력 (비우면 복구 안함)
일반함수 : 각 플레이어에 개별인자 적용시 {P1,P2,P3,…,P12}로 인식함
X함수 : 각 플레이어에게 개별인자 적용시 Player 배열순으로 인식함
Ex) [예제 21-1] 참고
110

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 자동할당 Index영역 변경 함수 (StartCtrig 위에 사용해야함) ｡+.ﾟ
__SetFuncAlloc(Start,End) ※ 고급
: FuncAlloc의 Index 자동 할당영역을 설정하는 함수 (부족한 경우 사용)
Start : 자동 할당영역의 시작 Index (기본값 0x1D000)
End : 자동 할당영역의 끝 Index (기본값 0x20000)
※ 자동 할당되는 Index영역은 Start ≤ Index ＜ End로 설정됨
__SetIndexAlloc(Start,End) ※ 고급
: IndexAlloc의 Index 자동 할당영역을 설정하는 함수 (부족한 경우 사용)
Start : 자동 할당영역의 시작 Index (기본값 0xC000)
End : 자동 할당영역의 끝 Index (기본값 0xF000)
__SetJumpAlloc(Start,End) ※ 고급
: [C/N]Jump(X)의 sIndex 할당영역을 설정하는 함수 (부족한 경우 사용)

Start : Jump의 sIndex 할당영역의 시작 Index (기본값 0xA000)
End : JumpEnd의 sIndex 할당영역의 시작 Index (기본값 0xB000)
※ 할당되는 sindex영역은 Start≤ sIndex(0~(End-Start)까지 사용가능) ＜End+(End-Start)로 설정됨

__SetVoidArea(Start,End) ※ 고급
: VoidAreaAlloc의 공메모리 오프셋 자동 할당영역을 설정하는 함수 (부족한 경우 사용)
Start : 자동 할당영역의 시작 Offset (기본값 0x58F500)
End : 자동 할당영역의 끝 Offset (기본값 0x5967F0)
__SetFlagAlloc(Start,End) ※ 고급
: FlagAlloc의 Index 자동 할당영역을 설정하는 함수 (부족한 경우 사용)
Start : 자동 할당영역의 시작 Index (기본값 0xF300)
End : 자동 할당영역의 끝 Index (기본값 0xF400)
※ 생성되는 트리거는 무조건 AllPlayers로 생성되며, 개당 480개의 Flag가 할당됨

111

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 자동할당 Index영역 변경 함수 (StartCtrig 위에 사용해야함) ｡+.ﾟ
__SetCAPlotJumpAlloc(Start,End) ※ 고급
: CAPlotJumpAlloc의 sIndex 자동 할당영역을 설정하는 함수 (부족한 경우 사용)
Start : 자동 할당영역의 시작 sIndex (기본값 0xA00)
End : 자동 할당영역의 끝 sIndex (기본값 0x1000)
__SetCAPlotVarAlloc(Start,End) ※ 고급
: CAPlotVarAlloc의 Index 자동 할당영역을 설정하는 함수 (부족한 경우 사용)
Start : 자동 할당영역의 시작 Index (기본값 0x1A000)
End : 자동 할당영역의 끝 Index (기본값 0x1D000)
__SetCAPrintVarAlloc(Start,End) ※ 고급
: CAPrintVarAlloc의 Index 자동 할당영역을 설정하는 함수 (부족한 경우 사용)
Start : 자동 할당영역의 시작 Index (기본값 0xF002)

End : 자동 할당영역의 끝 Index (기본값 0xF300)
__SetCreateVarIndex(Init,Max,Ccode,NCode) ※ 고급
: CreateVarXAlloc의 Index 자동 할당영역을 설정하는 함수 (부족한 경우 사용)
Init : 자동 할당영역의 시작 Index (기본값 0x18000)
Max : 자동 할당영역의 끝 Index (기본값 0x19FFF)
Ccode : Ccode 자동 할당영역의 크기 (기본값 0x100)
Ncode : Ncode 자동 할당영역의 크기 (기본값 0x500)

112

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CreateVar류 함수 (자동 변수 생성 함수) ｡+.ﾟ
CreateVar(PlayerID)
: CVariable() 자동할당 함수, (A = CreateVar() 형식으로 사용, Index = A[2])
PlayerID : 생성할 트리거의 체크 플레이어

리턴값 : V(자동할당된 Index)
CreateVar2(PlayerID,Offset,Type,Value,Mask)
: CVariable2() 자동할당 함수, (A = CreateVar() 형식으로 사용, Index = A[2])
PlayerID : 생성할 트리거의 체크 플레이어
리턴값 : V(자동할당된 Index)
CreateVars(Number,PlayerID)
: CVariable() 다중 자동할당 함수, (A, B = CreateVars(2) 형식으로 사용)
PlayerID : 생성할 트리거의 체크 플레이어
Number : 생성할 변수의 개수
리턴값 : 각각 V(자동할당된 Index)
CreateVarArr(Number,PlayerID)
: CVariable() 다중 자동할당 함수, (Arr = CreateVarArr(2) 형식으로 사용)

PlayerID : 생성할 트리거의 체크 플레이어
Number : 생성할 변수의 개수
리턴값 : {V(자동할당된 Index1), V(자동할당된 Index2),…}
Ex) [예제 21-2] 참고

※ CreateVar류 함수에서 PlayerID를 비우면 AllPlayers로 입력됨
(PlayerID에 숫자(P1~P8) 입력시 생성된 변수의 Player를 "X"대신 입력된 PlayerID로 설정함)

113

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CreateVar류 함수 (자동 변수 생성 함수) ｡+.ﾟ
CreateVArr(Size,PlayerID)
: CVArray() 자동할당 함수, (A = CreateVArr() 형식으로 사용, Index = A[2])
PlayerID : 생성할 트리거의 체크 플레이어

Size : 생성할 배열의 크기
리턴값 : V(자동할당된 Index) → VArr(X)()를 사용해 VA타입으로 사용
CreateVArrs(Number,Size,PlayerID)
: CVArray() 다중 자동할당 함수, (A, B = CreateVArrs(2) 형식으로 사용)
PlayerID : 생성할 트리거의 체크 플레이어
Number : 생성할 배열의 개수
Size : 생성할 배열의 크기
리턴값 : 각각 V(자동할당된 Index) → VArr(X)()를 사용해 VA타입으로 사용
CreateVArrArr(Number,Size,PlayerID)
: CVArray() 다중 자동할당 함수, (Arr = CreateVArrArr(2) 형식으로 사용)
PlayerID : 생성할 트리거의 체크 플레이어
Number : 생성할 배열의 개수
Size : 생성할 배열의 크기
리턴값 : {V(자동할당된 Index1),V(자동할당된 Index2),…} → VArr(X)()를 사용해 VA타입으로 사용
Ex) [예제 21-3] 참고

114

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CreateVar류 함수 (자동 변수 생성 함수) ｡+.ﾟ
CreateArr(Size,PlayerID)
: CArray() 자동할당 함수, (A = CreateArr() 형식으로 사용, Index = A[2])
PlayerID : 생성할 트리거의 체크 플레이어

Size : 생성할 배열의 크기
리턴값 : Mem(자동할당된 Index) → Arr(X)()를 사용해 A타입으로 사용
CreateArrs(Number,Size,PlayerID)
: CArray() 다중 자동할당 함수, (A, B = CreateArrs(2) 형식으로 사용)
PlayerID : 생성할 트리거의 체크 플레이어
Number : 생성할 배열의 개수
Size : 생성할 배열의 크기
리턴값 : 각각 Mem(자동할당된 Index) → Arr(X)()를 사용해 A타입으로 사용
CreateArrArr(Number,Size,PlayerID)
: CArray() 다중 자동할당 함수, (Arr = CreateArrArr(2) 형식으로 사용)
PlayerID : 생성할 트리거의 체크 플레이어
Number : 생성할 배열의 개수
Size : 생성할 배열의 크기
리턴값 : {Mem(자동할당된 Index1),Mem(자동할당된 Index2),…} → Arr(X)()를 사용해 A타입으로 사용

Ex) [예제 21-4] 참고
CreateDb(ByteSize,PlayerID)
: CreateArr()의 Db버전 함수
ByteSize : 생성할 배열의 크기 (Byte 단위) - 나머지는 CreateArr()와 동일
CreateDbs(Number,ByteSize,PlayerID)
: CreateArrs()의 Db버전 함수
ByteSize : 생성할 배열의 크기 (Byte 단위) - 나머지는 CreateArrs()와 동일
CreateDbArr(Number,ByteSize,PlayerID)
: CreateArrArr()의 Db버전 함수
ByteSize : 생성할 배열의 크기 (Byte 단위) - 나머지는 CreateArrArr()와 동일

115

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CreateVar류 함수 (자동 변수 생성 함수) ｡+.ﾟ
CreateCcode()
: Ccode() 자동할당 함수, (A = CreateCcode() 형식으로 사용)
리턴값 : 자동할당된 Ccode
CreateCcodes(Number)
: Ccode() 다중 자동할당 함수, (A, B = CreateCcodes(2) 형식으로 사용)
Number : 생성할 변수의 개수
리턴값 : 각각 자동할당된 Ccode
CreateCcodeArr(Number)
: Ccode() 다중 자동할당 함수, (Arr = CreateCcodeArr(2) 형식으로 사용)
Number : 생성할 변수의 개수
리턴값 : {자동할당된 Ccode1, 자동할당된 Ccode2,…}
CreateNcode()
: Ncode() 자동할당 함수, (A = CreateNcode() 형식으로 사용)
리턴값 : 자동할당된 Ncode

CreateNcodes(Number)
: Ncode() 다중 자동할당 함수, (A, B = CreateNcodes(2) 형식으로 사용)
Number : 생성할 변수의 개수
리턴값 : 각각 자동할당된 Ncode
CreateNcodeArr(Number)
: Ncode() 다중 자동할당 함수, (Arr = CreateNcodeArr(2) 형식으로 사용)
Number : 생성할 변수의 개수
리턴값 : {자동할당된 NCcode1, 자동할당된 Ncode2,…}
Ex) [예제 21-5] 참고

116

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CreateVar류 함수 (자동 변수 생성 함수) ｡+.ﾟ
CreateWar(PlayerID)
: CWariable() 자동할당 함수, (A = CreateWar() 형식으로 사용, Index = A[2])
PlayerID : 생성할 트리거의 체크 플레이어

리턴값 : W(자동할당된 Index)
CreateWar2(PlayerID,Offset,Type,Value,Mask)
: CWariable2() 자동할당 함수, (A = CreateWar() 형식으로 사용, Index = A[2])
PlayerID : 생성할 트리거의 체크 플레이어
리턴값 : W(자동할당된 Index)
CreateWars(Number,PlayerID)
: CWariable() 다중 자동할당 함수, (A, B = CreateWars(2) 형식으로 사용)
PlayerID : 생성할 트리거의 체크 플레이어
Number : 생성할 변수의 개수
리턴값 : 각각 W(자동할당된 Index)
CreateWarArr(Number,PlayerID)
: CWariable() 다중 자동할당 함수, (Arr = CreateWarArr(2) 형식으로 사용)

PlayerID : 생성할 트리거의 체크 플레이어
Number : 생성할 변수의 개수
리턴값 : {W(자동할당된 Index1), W(자동할당된 Index2),…}
Ex) [예제 21-2] 참고

117

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CreateVar류 함수 (자동 변수 생성 함수) ｡+.ﾟ
CreateWArr(Size,PlayerID)
: CWArray() 자동할당 함수, (A = CreateWArr() 형식으로 사용, Index = A[2])
PlayerID : 생성할 트리거의 체크 플레이어

Size : 생성할 배열의 크기
리턴값 : W(자동할당된 Index) → WArr(X)()를 사용해 WA타입으로 사용
CreateWArrs(Number,Size,PlayerID)
: CWArray() 다중 자동할당 함수, (A, B = CreateWArrs(2) 형식으로 사용)
PlayerID : 생성할 트리거의 체크 플레이어
Number : 생성할 배열의 개수
Size : 생성할 배열의 크기
리턴값 : 각각 W(자동할당된 Index) → WArr(X)()를 사용해 WA타입으로 사용
CreateWArrArr(Number,Size,PlayerID)
: CWArray() 다중 자동할당 함수, (Arr = CreateWArrArr(2) 형식으로 사용)
PlayerID : 생성할 트리거의 체크 플레이어
Number : 생성할 배열의 개수
Size : 생성할 배열의 크기
리턴값 : {W(자동할당된 Index1),W(자동할당된 Index2),…} → WArr(X)()를 사용해 WA타입으로 사용
Ex) [예제 21-3] 참고

118

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CreateVar류 함수 (자동 변수 생성 함수) ｡+.ﾟ
CreateLArr(Size,PlayerID)
: LArray() 자동할당 함수, (A = CreateLArr() 형식으로 사용, Index = A[2])
PlayerID : 생성할 트리거의 체크 플레이어

Size : 생성할 배열의 크기
리턴값 : Mem(자동할당된 Index) → LArr(X)()를 사용해 LA타입으로 사용
CreateLArrs(Number,Size,PlayerID)
: LArray() 다중 자동할당 함수, (A, B = CreateLArrs(2) 형식으로 사용)
PlayerID : 생성할 트리거의 체크 플레이어
Number : 생성할 배열의 개수
Size : 생성할 배열의 크기
리턴값 : 각각 Mem(자동할당된 Index) → LArr(X)()를 사용해 LA타입으로 사용
CreateLArrArr(Number,Size,PlayerID)
: LArray() 다중 자동할당 함수, (Arr = CreateLArrArr(2) 형식으로 사용)
PlayerID : 생성할 트리거의 체크 플레이어
Number : 생성할 배열의 개수
Size : 생성할 배열의 크기
리턴값 : {Mem(자동할당된 Index1),Mem(자동할당된 Index2),…} → LArr(X)()를 사용해 LA타입으로 사용

Ex) [예제 21-4] 참고
CreateLDb(ByteSize,PlayerID)
: CreateLArr()의 Db버전 함수
ByteSize : 생성할 배열의 크기 (Byte 단위) - 나머지는 CreateLArr()와 동일
CreateLDbs(Number,ByteSize,PlayerID)
: CreateLArrs()의 Db버전 함수
ByteSize : 생성할 배열의 크기 (Byte 단위) - 나머지는 CreateLArrs()와 동일
CreateLDbArr(Number,ByteSize,PlayerID)
: CreateLArrArr()의 Db버전 함수
ByteSize : 생성할 배열의 크기 (Byte 단위) - 나머지는 CreateLArrArr()와 동일

119

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CreateVar류 함수 (자동 변수 생성 함수) ｡+.ﾟ
CreateSVar(Size,PlayerID)
: CSVariable() 자동할당 함수, (A = CreateSVar() 형식으로 사용, Index = A[2])
PlayerID : 생성할 트리거의 체크 플레이어

Size : SVariable의 Number (변수 개수)
리턴값 : {SV(자동할당된 Index), S(자동할당된 Index)} - SVData에 Ret[1], Svariable에 Ret[2] 입력

CreateSVar2(Size,PlayerID,Offset,Type,Value,Mask)
: CSVariable2() 자동할당 함수, (A = CreateSVar() 형식으로 사용, Index = A[2])
PlayerID : 생성할 트리거의 체크 플레이어
Size : SVariable의 Number (변수 개수)
리턴값 : {SV(자동할당된 Index), S(자동할당된 Index)} - SVData에 Ret[1], Svariable에 Ret[2] 입력

CreateSVars(Size,Number,PlayerID)
: CSVariable() 다중 자동할당 함수, (A, B = CreateSVars(Size,2) 형식으로 사용)
PlayerID : 생성할 트리거의 체크 플레이어
Number : 생성할 변수의 개수
Size : SVariable의 Number (변수 개수)
리턴값 : 각각 {SV(자동할당된 Index), S(자동할당된 Index)}
CreateSVarArr(Size,Number,PlayerID)
: CSVariable() 다중 자동할당 함수, (Arr = CreateSVarArr(Size,2) 형식으로 사용)
PlayerID : 생성할 트리거의 체크 플레이어
Number : 생성할 변수의 개수
Size : SVariable의 Number (변수 개수)
리턴값 : {{SV(자동할당된 Index1), S(자동할당된 Index1)}, {SV(자동할당된 Index2), S(자동할당된 Index2)},…}

Ex) [예제 21-6] 참고

120

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CreateVar류 함수 (자동 변수 생성 함수) ｡+.ﾟ
CreateSVArr(Number,Size,PlayerID)
: SVArray() 자동할당 함수, (A = CreateSVArr() 형식으로 사용, Index = A[2])
PlayerID : 생성할 트리거의 체크 플레이어

Number : SVariable의 Number (변수 개수)
Size : 생성할 배열의 크기
리턴값 : SA(자동할당된 Index) → SVArr(X)()를 사용해 SVA타입으로 사용
CreateSVArrs(Numbers,Number,Size,PlayerID)
: SVArray() 다중 자동할당 함수, (A, B = CreateSVArrs(2) 형식으로 사용)
PlayerID : 생성할 트리거의 체크 플레이어
Number : SVariable의 Number (변수 개수)
Numbers : 생성할 배열의 개수
Size : 생성할 배열의 크기
리턴값 : 각각 SA(자동할당된 Index) → SVArr(X)()를 사용해 SVA타입으로 사용
CreateSVArrArr(Numbers,Number,Size,PlayerID)
: SVArray() 다중 자동할당 함수, (Arr = CreateSVArrArr(2) 형식으로 사용)
PlayerID : 생성할 트리거의 체크 플레이어

Number : SVariable의 Number (변수 개수)
Numbers : 생성할 배열의 개수
Size : 생성할 배열의 크기
리턴값 : {SA(자동할당된 Index1),SA(자동할당된 Index2),…} → SVArr(X)()를 사용해 SVA타입으로 사용
Ex) [예제 21-7] 참고

121

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CreateVar류 함수 (자동 변수 생성 함수) ｡+.ﾟ
CreateVoid()
: 공메모리 영역 자동할당 편의 함수, (A = CreateVoid() 형식으로 사용, EPD = EPD(A))
리턴값 : 할당된 공메모리의 Offset
CreateVoids(Number)
: 공메모리 영역 다중 자동할당 편의 함수, (A, B = CreateVoids(2) 형식으로 사용)
리턴값 : 각각 할당된 공메모리의 Offset
CreateVoidArr(Number)
: 공메모리 영역 다중 자동할당 편의 함수, (Arr = CreateVoidArr(2) 형식으로 사용)
리턴값 : {할당된 공메모리의 Offset1, 할당된 공메모리의 Offset2,…}
Ex) [예제 21-5] 참고

122

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CreateVar류 함수 (자동 변수 생성 함수) ｡+.ﾟ
CreateVar2s(Number,Value,PlayerID)
: CreateVar2() 다중 자동할당 함수
Value : {초기값1, 초기값2, …} 형식으로 입력

CreateVarArr2(Number,Value,PlayerID)
: CreateVarArr() 초기값 설정 가능 함수
Value : {초기값1, 초기값2, …} 형식으로 입력
CreateWar2s(Number,Value,PlayerID)
: CreateWar2() 다중 자동할당 함수
Value : {초기값1, 초기값2, …} 형식으로 입력
CreateWarArr2(Number,Value,PlayerID)
: CreateWarArr() 초기값 설정 가능 함수
Value : {초기값1, 초기값2, …} 형식으로 입력
CreateVArr2(Size,Value,PlayerID)
: CreateVarArr() 초기값 설정 가능 함수
Value : {초기값1, 초기값2, …} 형식으로 입력
CreateVArr2s(Number,Size,Value,PlayerID)
: CreateVarArr2() 다중 자동할당 함수
Value : {{초기값 배열1}, {초기값 배열2}, …} 형식으로 입력
CreateVArrArr2(Number,Size,Value,PlayerID)
: CreateVArrArr() 초기값 설정 가능 함수
Value : {{초기값 배열1}, {초기값 배열2}, …} 형식으로 입력
CreateWArr2(Size,Value,PlayerID)
: CreateWarArr() 초기값 설정 가능 함수
Value : {초기값1, 초기값2, …} 형식으로 입력
CreateWArrArr2(Number,Size,Value,PlayerID)

: CreateWArrArr() 초기값 설정 가능 함수
Value : {{초기값 배열1}, {초기값 배열2}, …} 형식으로 입력

CreateWArr2s(Number,Size,Value,PlayerID)
: CreateWarArr2() 다중 자동할당 함수
Value : {{초기값 배열1}, {초기값 배열2}, …} 형식으로 입력

Ex) [예제 21-8] 참고

123

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ CunPack류 함수 (Cond/Act/Parameter 다중 입력 전용 함수) ｡+.ﾟ
CunPack(CPack) # 내부함수 (함수 만들 때 참고용)
: CTrigger, CDoActions를 함수 내부에 2개 이상 입력받을때 사용하는 함수
CPack : {{함수명,함수 인자들,…},…} 형태로 입력 (조건 및 액션)

※ CDoActions의 액션, CTrigger의 조건 및 액션 입력 인자가 함수에 2개 이상일때 사용,
배열의 형태로 조건 및 액션 인자를 전달하고 해당 CDoActions, CTrigger에서 전달된
인자들을 풀어서 입력된 함수들을 실행시킴 (전역변수 배열 꼬임방지용 함수)
※ CunPack은 조건 또는 액션 1개 단위로 작동하는 함수임
CDoActionsX(PlayerID,Actions,Flags,Index)
: CDoActions와 동일하나, CunPack 적용됨 (CStruct)
PlayerID : 생성 트리거의 체크 플레이어
Actions : 실행시킬 액션 ({{함수명,함수 인자들,…},…} 형태로 입력)
Flags : 트리거의 flags (미입력시 Preserved로 입력됨)
Index : 트리거의 Label Index (미입력시 0으로 입력됨)
※ CDoActionsX, CTriggerX류 함수의 Condtions나 Actions는 반드시 {조건1,조건2,…} 또는
{액션1,액션2,…} 형태로 넣어야함 (조건/액션 칸에 조건/액션배열 또는 빈칸 삽입시 오류 발생함)

CTriggerX(PlayerID, Conditions, Actions, Flags, Index)
: TriggerX와 동일하나, CunPack 적용됨 (CStruct)
PlayerID : 생성 트리거의 체크 플레이어
Conditions : 실행하기위한 조건 ({{함수명,함수 인자들,…},…} 형태로 입력)
Actions : 실행시킬 액션 ({{함수명,함수 인자들,…},…} 형태로 입력)
Flags : 트리거의 flags (1입력시 Preserved로 입력됨)
Index : 트리거의 Label Index (미입력시 0으로 입력됨)

CDoActions2X(PlayerID,Actions,Flags)
: CDoActionsX() 에서 액션 갯수의 제한이 없는 함수
사용법은 CDoActionsX와 동일함

CTrigger2X(PlayerID, Conditions, Actions, Flags)
: CTriggerX() 에서 액션 갯수의 제한이 없는 함수
사용법은 CTriggerX와 동일함 / Flags에 1입력시 {Preserved}, 나머지는 1회만 실행함

Ex) [예제 21-9] 참고

124

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ Stack류 함수 (변수 임시 저장 및 출력 함수) ｡+.ﾟ
CPush(PlayerID,Parameter)
: V를 CStack에 Push하는 함수 (Stack의 최댓값은 StartCtrig의 CStack인자로 조절가능)
PlayerID : 생성 트리거의 체크 플레이어

Parameter : Stack에 입력할 V ({V1,V2,…} 형식으로 입력, 왼쪽부터 순서대로 입력됨)
CPop(PlayerID,Return)
: CStack에서 V를 Pop하는 함수 (Push된 V의 수 보다 많이 Pop하면 오류 발생함)
PlayerID : 생성 트리거의 체크 플레이어
Return : V의 값을 복사할 곳 ({상수/V/Mem,…} 형식으로 입력, 왼쪽부터 순서대로 입력됨)
※ CStack에서 스택 오버플로우가 발생할 경우 오류 발생함
LPush(PlayerID,Parameter)
: W를 LStack에 Push하는 함수 (Stack의 최댓값은 StartCtrig의 LStack인자로 조절가능)
PlayerID : 생성 트리거의 체크 플레이어
Parameter : Stack에 입력할 W ({W1,W2,…} 형식으로 입력, 왼쪽부터 순서대로 입력됨)
LPop(PlayerID,Return)
: LStack에서 W를 Pop하는 함수 (Push된 W의 수 보다 많이 Pop하면 오류 발생함)

PlayerID : 생성 트리거의 체크 플레이어
Return : W의 값을 복사할 곳
({W/{상수/V/Mem, 상수/V/Mem},…} 형식으로 입력, 왼쪽부터 순서대로 입력됨)
※ LStack에서 스택 오버플로우가 발생할 경우 오류 발생함
Ex) [예제 21-10] 참고

125

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CFunc류 함수 (사용자 정의 함수 생성) ｡+.ﾟ
InitCFunc(PlayerID)
: CFunc을 생성하는 함수 (CFunc의 헤더 Index 할당)
PlayerID : 생성 트리거의 체크 플레이어

리턴값 : CFunction 데이터

CFunc(CFunction)
: CFunc을 현재 위치에서 시작하는 함수
CFunction : 시작할 CFunc의 데이터 (InitCFunc의 리턴값을 입력)
리턴값 : CFunction 전달인자 배열 (CFunc 단락 내부에서 사용가능)
※ CFunc 함수에서 전달인자의 개수는 StartCtrig의 CFunc인자로 변경가능함

CFuncEnd()
: CFunc을 현재 위치에서 끝내는 함수
CFunction은 CFunc ~ CFuncEnd 사이가 해당 함수의 단락이 된다.
CFuncReturn(Return)
: CFunc에서 결과값을 리턴하는 함수 (리턴시 해당 함수를 탈출함)
Return : Cfunction 리턴값 배열 ({상수/V,…} 형식으로 입력)
※ 리턴값 배열에 같은 변수를 2개 이상 입력하면 오류 발생함
CallCFunc(CFunction,Parameter,Return,PlayerID,Conditions,Actions,Once)
: Cfunction을 호출하는 함수 (Parameter를 인자로 받고, Return을 리턴함)
Cfunction : 호출할 Cfunc의 데이터 (InitCFunc의 리턴값을 입력)
Parameter : Cfunc의 전달인자에 입력할 값 ({상수/V,…}형식으로 입력, 1번째 전달인자부터 채워짐)
Return : Cfunc의 리턴값을 저장할 곳 ({상수/V/Mem,…}형식으로 입력, 1번째 리턴값부터 설정됨)
PlayerID : 생성 트리거의 체크 플레이어
Condtions : 트리거를 실행시킬 조건

Actions : 트리거에서 실행시킬 액션
Once : 1 입력시 1회만 실행함
Ex) [예제 21-11] 참고

126

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CFunc류 함수 (사용자 정의 함수 생성) ｡+.ﾟ
CallCFuncX(PlayerID,CFunction,Parameter,Return)
: Cfunction을 호출하는 함수 (If문 미사용, 항상 호출함)
PlayerID : 생성 트리거의 체크 플레이어

Cfunction : 호출할 Cfunc의 데이터 (InitCFunc의 리턴값을 입력)
Parameter : Cfunc의 전달인자에 입력할 값 ({상수/V,…}형식으로 입력, 1번째 전달인자부터 채워짐)
Return : Cfunc의 리턴값을 저장할 곳 ({상수/V/Mem,…}형식으로 입력, 1번째 리턴값부터 설정됨)
_Func(CFunction,Parameter)
: Cfunction을 중간연산자 형태로 호출하는 함수
Cfunction : 호출할 Cfunc의 데이터 (InitCFunc의 리턴값을 입력)
Parameter : Cfunc의 전달인자에 입력할 값 ({상수/V,…}형식으로 입력, 1번째 전달인자부터 채워짐)

※ 호출할 Cfunc은 반드시 CFuncReturn으로 결과값을 하나만 리턴해야함 (중간 연산자 전달값)
TTFunc(CFunction,Parameter,flag)
: Cfunction을 조건 연산자 형태로 호출하는 함수
Cfunction : 호출할 Cfunc의 데이터 (InitCFunc의 리턴값을 입력)
Parameter : Cfunc의 전달인자에 입력할 값 ({상수/V,…}형식으로 입력, 1번째 전달인자부터 채워짐)
Flag : 0입력시 리턴값이 0일때 참인 조건을 생성, 아닐시 리턴값이 1이상일때 참인 조건을 생성함
※ 호출할 Cfunc은 반드시 CFuncReturn으로 결과값을 하나만 리턴해야함 (리턴값이 1이상이면 참)
Ex) [예제 21-11] 참고

127

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CMathFunc류 함수 (사용자 정의 수학 함수 생성) ｡+.ﾟ
CMathFunc(PlayerID,Func,Start,End,Exception,T,TException,Magnificent) # StrCtrig 필수
: Cfunction으로 사용자 정의 수학 함수를 생성함 (매개변수 1개인 함수)
PlayerID : 생성 트리거의 체크 플레이어

Func : 수학 함수 수식 (매개변수 1개(y=f(x)), 함수명을 스트링으로 입력)
Start : 수학 함수 정의역의 시작지점
End : 수학 함수 정의역의 종료지점 (Start ~ End까지 1 간격으로 함수값을 저장함)
Exception : (미입력시 적용X) 정의역 예외설정 ({{조건("==",">=","<="), 조건 값, 액션값} 또는
{"><",조건1값(iAtLeast),조건2값(iAtMost),액션값},…} 형식으로 입력
→ TriggerX(Nvar(x,조건,조건값),SetNVar(x,SetTo,액션값)) 또는
TriggerX({Nvar(x,iAtLeast,조건1값), Nvar(x,iAtMost,조건2값)},SetNVar(x,SetTo,액션값))의 트리거를 생성함

T : (주기함수전용, 미입력시 적용X) 정의역의 주기를 설정함 (설정시 정의역은 0~T-1로 설정됨)
Texception : (미입력시 적용X, T를 입력해야 사용가능) 정의역 주기 예외설정, 사용방법은 Exception과 동일함

Magnificent : 결과값에 곱할 수 (f(x) = math.sin(x)과 같이 결과값이 작고 정수가 아닌 함수에 적용)
(f(x)*Magnificent 값으로 결과값이 저장되며, {x(입력 값),k(곱할 수)}로 인자를 받아
(f(x)*M*곱할 수)/M 형식으로 값을 리턴함 - f_Lengthdir과 방식이 같음, 미입력시 적용X)
리턴값 : 생성된 수학 함수 연산 Cfunc 헤더
※ CMathFunc 사용시 CFunction Parameter 개수를 최소 2개이상으로 설정해야함 (StartCtrig)
※ CMathFunc은 하나의 Cfunc이며 호출시 첫번째 인자로 x(입력값)을 받고 결과값으로
F(x)(함수값)을 리턴함 (Magnificient 입력시 두번째 인자로 결과값에 곱할 크기값을 입력받음)
Ex) [예제 21-12] 참고

128

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CMathFunc류 함수 (사용자 정의 수학 함수 생성) ｡+.ﾟ
CMathFunc2(PlayerID,Func,Start,End,Exception,T,TException,Magnificent) # StrCtrig 필수
: Cfunction으로 사용자 정의 수학 함수를 생성함 (매개변수 2개인 함수)
PlayerID : 생성 트리거의 체크 플레이어

Func : 수학 함수 수식 (매개변수 2개(y=f(x,y)), 함수명을 스트링으로 입력)
Start : 수학 함수 정의역의 시작지점 ({X 정의역 시작지점, Y 정의역 시작지점} 형식으로 입력)
End : 수학 함수 정의역의 종료지점 (({X 정의역 종료지점, Y 정의역 종료지점} 형식으로 입력,
Start ~ End까지 X, Y 각각1 간격으로 함수값을 저장함)
Exception : (미입력시 적용X) 정의역 예외설정
({{조건("Y==","Y>=","Y<=","X==",X>=","X<="), 조건 값, 액션값/호출할 CFunc} 또는
{조건("Y><","X><"),조건1값(iAtLeast),조건2값(iAtMost),액션값/호출할 CFunc},…} 또는
{조건1("X==","X>=","X<="),조건1 값,액션값,조건2("Y==","Y>=",Y<="),조건2값,액션값} 또는

{조건1("X==","X>=","X<="),조건1 값,액션값,조건2("Y><"),조건2a값,조건2b값,액션값} 또는
{조건1("X><"),조건1 값,액션값,조건1a값,조건1b값,("Y==","Y>=",Y<=","Y><"),조건2값,액션값} 또는
{조건1("X><"),조건1 값,액션값,조건1a값,조건1b값,("Y><"),조건2a값,조건2b값,액션값} 형식으로 입력
(액션값 대신 호출할 Cfunc 입력시 조건 만족시 입력한 Cfunc을 호출함)

T : (주기함수전용, 미입력시 적용X) 정의역의 주기를 설정함
({X주기,Y주기} 형식으로 입력, X또는 Y 주기 입력칸을 비우면 해당 변수는 주기 설정 안함,
설정시 정의역은 각각 0~X주기-1, 0~Y-1로 설정됨)
Texception : (미입력시 적용X, T를 입력해야 사용가능) 정의역 주기 예외설정, 사용방법은 Exception과 동일함

Magnificent : 결과값에 곱할 수
(f(x,y)*Magnificent 값으로 결과값이 저장되며, {x(입력 값),y(입력값),k(곱할 수)}로 인자를 받아
(f(x,y)*M*곱할 수)/M 형식으로 값을 리턴함 - f_Lengthdir과 방식이 같음, 미입력시 적용X)
리턴값 : 생성된 수학 함수 연산 Cfunc 헤더
※ CMathFunc2 사용시 CFunction Parameter 개수를 최소 3개이상으로 설정해야함 (StartCtrig)
※ CMathFunc2은 하나의 Cfunc이며 호출시 첫번째 인자로 x(입력값)을, 두번째 인자로 y(입력값)을
입력받고 결과값으로 F(x,y)(함수값)을 리턴함
(Magnificient 입력시 세번째 인자로 결과값에 곱할 크기값을 입력받음)
Ex) [예제 21-12] 참고

129

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ VFunc류 함수 (사용자 정의 함수 포인터 생성) ｡+.ﾟ
InitVFunc(PlayerID,CFunction,Wariable,Conditions,Actions,Once)
: VFunc을 생성하는 함수 (Wariable에 CFunc의 주소값 저장)
PlayerID : 생성 트리거의 체크 플레이어

Cfunction : 변수에 주소값을 담을 CFunc 함수
Wariable : CFunc의 주소를 저장할 변수 (W/WA 입력)
Condtions : 트리거를 실행시킬 조건
Actions : 트리거에서 실행시킬 액션
Once : 1 입력시 1회만 실행함

※ Wariable과 CFunction의 플레이어가 동일해야함
VFunc(CFunction,Wariable)
: VFunc을 생성하는 액션 (Wariable에 CFunc의 주소값 저장, 액션2개짜리 배열)
Cfunction : 변수에 주소값을 담을 CFunc 함수
Wariable : CFunc의 주소를 저장할 변수 (W 입력)
※ Cfunction의 주소를 저장한 W타입 변수는 CallVFunc에 입력해 해당 함수를 호출할 수 있음
CallVFunc(Wariable,Parameter,Return,PlayerID,Conditions,Actions,Once)
: Vfunc을 호출하는 함수 (W를 함수포인터로 사용해 저장된 주소로 Cfunc을 호출함)
Wariable : 호출할 Cfunction의 주소가 저장된 W타입 변수

Parameter : Cfunc의 전달인자에 입력할 값 ({상수/V,…}형식으로 입력, 1번째 전달인자부터 채워짐)
Return : Cfunc의 리턴값을 저장할 곳 ({상수/V/Mem,…}형식으로 입력, 1번째 리턴값부터 설정됨)
PlayerID : 생성 트리거의 체크 플레이어
Condtions : 트리거를 실행시킬 조건
Actions : 트리거에서 실행시킬 액션
Once : 1 입력시 1회만 실행함
Ex) [예제 21-13] 참고

130

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ VFunc류 함수 (사용자 정의 함수 포인터 생성) ｡+.ﾟ
CallVFuncX(PlayerID,Wariable,Parameter,Return)
: Vfunc을 호출하는 함수 (W를 함수포인터로 사용해 저장된 주소로 Cfunc을 호출함, 항상 호출함)
PlayerID : 생성 트리거의 체크 플레이어

Wariable : 호출할 Cfunction의 주소가 저장된 W타입 변수
Parameter : Cfunc의 전달인자에 입력할 값 ({상수/V,…}형식으로 입력, 1번째 전달인자부터 채워짐)
Return : Cfunc의 리턴값을 저장할 곳 ({상수/V/Mem,…}형식으로 입력, 1번째 리턴값부터 설정됨)
_VFunc(Wariable,Parameter)
: Vfunc을 중간연산자 형태로 호출하는 함수
Wariable : 호출할 Cfunction의 주소가 저장된 W타입 변수
Parameter : Cfunc의 전달인자에 입력할 값 ({상수/V,…}형식으로 입력, 1번째 전달인자부터 채워짐)

※ 호출할 Cfunc은 반드시 CFuncReturn으로 결과값을 하나만 리턴해야함 (중간 연산자 전달값)
TTVFunc(Wariable,Parameter,flag)
: VFunc을 조건 연산자 형태로 호출하는 함수
Wariable : 호출할 Cfunction의 주소가 저장된 W타입 변수
Parameter : Cfunc의 전달인자에 입력할 값 ({상수/V,…}형식으로 입력, 1번째 전달인자부터 채워짐)
Flag : 0입력시 리턴값이 0일때 참인 조건을 생성, 아닐시 리턴값이 1이상일때 참인 조건을 생성함
※ 호출할 Cfunc은 반드시 CFuncReturn으로 결과값을 하나만 리턴해야함 (리턴값이 1이상이면 참)
Ex) [예제 21-13] 참고

131

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 64비트 표준 입출력 및 변환 함수 ｡+.ﾟ
｡˙+ﾟ ※ 64비트 상수는 스트링("0x1234567890ABCDEF","-1234567890" 등) 또는
배열({0x90ABCDEF,0x12345678})로 입력할 수 있습니다. (단순 숫자는 입력불가)｡+.ﾟ
W(Index,Player,Next)
: 64비트 변수 정보를 입력하는 함수
Index : 변수의 Index / Player : 변수의 Player ("X"→CurrentPlayer) / Next : 변수의 Next
ex) W(0x10) → CurrentPlayer의 Index:0x10인 변수를 입력

W(0x10,P1) → P1의 Index:0x10인 변수를 입력
W(0x10,P1,1) → P1의 Index:0x10인 변수의 다음 변수를 입력
Wi(Index,Deviation,Player,Next)
: 64비트 변수 정보 + 편차값(64비트)을 입력하는 함수
Deviation : 64비트 편차값 (상수)
ex) W(0x10,"-1") → CurrentPlayer의 Index:0x10인 변수값 - 1 을 입력
[예제 22-2] 참고
LMem(Player,Index,Address,Next,EPDflag)
: Ctrig메모리의 주소를 입력하는 함수 (64비트 메모리)
Player, Index, Address, Next의 항목을 {앞,뒤}로 입력 가능, 상수 입력시 {상수,상수}로 변환됨
나머지는 Mem과 동일함

_LMem(Wariable,Address,Next,EPDflag)
: 64비트 변수 데이터를 Ctrig메모리 데이터(배열)로 변환하는 함수
Wariable : 변수 데이터 (W, WArr(상수인덱스)) 입력

Next : 변수 트리거의 Next (기본값 0)
EPDflag : SetMemX, T액션의 Value부분에 Ctrig주소를 입력할 방식을 선택 (0 = Value, 1 = EPD), (기본값 0)

Address : 변수 트리거의 선택할 영역의 주소 (기본값 {0x15C,0x19C})
Address = X → 해당 주소(X)의 Mem 데이터를 반환 (Mem(X))
Address = {X1,X2} → {Mem(X1),Mem(X2)}를 반환
Address = {X1,{ΔX}} → {Mem(X1),Mem(X1+ΔX)}를 반환
Ex) _LMem(W(0x10)) → {Mem(P1,0x10,0x15C,0,0),Mem(P1,0x10,0x19C,0,0)}
_LMem(W(0x10),0x4,2,1) → Mem(P1,0x10,0x4,2,1)
_LMem(W(0x10),{0x158,0x198},1) → {Mem(P1,0x10,0x158,1,0),Mem(P1,0x10,0x198,1,0)}
_LMem(W(0x10),{0x24,{0x14}}) → {Mem(P1,0x10,0x24,0,0),Mem(P1,0x10,0x24+0x14,0,0)}
[예제 22-1] 참고

132

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 64비트 표준 입출력 및 변환 함수 ｡+.ﾟ
WArr(WArray,Index,Player)
: 64비트 변수 배열을 입력하는 함수
WArray : 64비트 변수배열 헤더 (CWArray 또는 GetWArray 리턴값 입력)
Index : 64비트 변수배열의 인덱스 : 상수 or 변수(W) 입력 - Wi 입력 가능
(Index에 V(i) 입력시 W(i)로 자동변환됨)
Player : 64비트 변수배열의 Player 입력 (기본값 "X")
ex) WArr(WArr1,0) → WArr1[0]를 반환함
WArr(WArr1,W(0x10),P1) → P1의 WArr1[W(0x10)]를 반환함
WArr(WArr1,Wi(0x10,12)) → WArr1[W(0x10)+12]를 반환함
WArrX(WArray,Index,Index4,Player)

: WArr()의 최적화용 함수
Index가 상수 → Index4는 입력 필요X
Index가 변수 → Index, Index4에 각각 ConvertWArr의 Dest, Dest4에 넣었던 변수를 입력
(Index에 Wi 입력 가능, 입력시 Index4 자동적용)
ex) WArrX(WArr1,0) : WArr(WArr,0)과 동일
(ConvertWArr() → W(0x10) = Dext, W(0x11) = Dext4)
WArrX(WArr1,W(0x10),W(0x11),P1) → P1의 WArr1[W(0x10)]를 반환함
WArrX(WArr1,Wi(0x10,12),W(0x11)) → WArr1[W(0x10)+12]를 반환함

※ WA타입의 인덱스는 상수 또는 W타입만 사용할 수 있습니다. (V타입 불가)
ConvertWArr(PlayerID,Dest,Dest4,Source,Size)
: WArr, WArrX용 인덱스값 변환 함수
PlayerID : 트리거 체크 플레이어
Dest : (Source+Vi)*604 (epd), Dest4 : (Source+Vi)*2416 (offset) (인덱스값을 WArr에 맞게 변환)

Source : 배열의 변수 Index (V(i), W(i) 입력 가능)
Size : 배열의 크기 (최적화용, 기본값 4095)
ex) [예제 22-3] 참고
※ WArray의 간격은 0x970으로, Dest에는 *604(epd), Dest4에는 *2416(Offset)을 대입함 (각각 Index, Index4)

※ WArr류 함수에 사용하는 Index 변수(W)는 항상 값이 {index,index}로 되어있어야 합니다.

133

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 64비트 표준 입출력 및 변환 함수 ｡+.ﾟ
LArr(LArray,Index,Player)
: 64비트 배열을 입력하는 함수
Index : 64비트 배열의 인덱스 : 상수 or 변수(V, W) 입력 - Vi, Wi 입력 가능
Player : 64비트 배열의 Player 입력 (기본값 "X")
LArray : 64비트 배열 헤더 (LArray 리턴값 입력)
LArray = X(헤더) → 32비트 모드 (앞) - Mem / A타입
LArray = {X(헤더),0} → 32비트 모드 (앞) - Mem / A타입
LArray = {X(헤더),1} → 32비트 모드 (뒤) (=앞+0x4 부분) - Mem / A타입
LArray = {X(헤더),8} 또는 {X(헤더)} → 64비트 모드 - {Mem,Mem} / LA타입
ex) LArr(LArr1,0) → LArr1[0]의 주소를 반환함 (32비트, Mem 타입)
LArr({LArr1,0},V(0x10),P1) → P1의 LArr1[V(0x10)]의 주소를 반환함 (32비트, A타입)
LArr({LArr1,1},Vi(0x10,12)) → LArr1[V(0x10)+12]의 주소를 반환함 (32비트, A타입)
LArr({LArr1,8},2) → LArr1[2]의 주소를 반환함 (64비트, {Mem,Mem})
LArr({LArr1,8},V(0x10)) → LArr1[V(0x10)]의 주소를 반환함 (64비트, LA타입)

LArr({LArr1,8},W(0x10)) → LArr1[W(0x10)]의 주소를 반환함 (64비트, LA타입)
※ LArr의 인덱스는 0부터 시작함
※ 상수 인덱스 : Mem타입 / {Mem,Mem} 반환, 변수 인덱스 : A / LA 타입 반환

LArrX(LArray,Index,Player)
: LArr()의 최적화용 함수
Index가 상수 → LArr()과 동일함
Index가 변수 → Index에 ConvertLArr의 Dest에 넣었던 변수를 입력 (Index에 Vi, Wi 입력 가능)

※ LA타입의 인덱스는 상수 또는 V, W타입 모두 사용할 수 있습니다.
ConvertLArr(PlayerID,Dest,Source,Mode)
: LArr, LArrX용 인덱스값 변환 함수
PlayerID : 트리거 체크 플레이어
Dest : (Source+Vi)*4(+1) (epd) (인덱스값을 LArr에 맞게 변환)
Source : 배열의 변수 Index (V(i), W(i) 입력 가능)
Mode : 비트 수에 맞는 변환 모드를 설정 (0 = 32비트 앞, 1 = 32비트 뒤, 8 = 64비트)

ex) [예제 22-2] 참고
※ LArray의 간격은 0x16으로, Dest에 *4(epd)을 대입함(Index), 구조에 대한 자세한 설명은 부록 참고

※ LArr류 함수에 사용하는 Index 변수(W)는 항상 값이 {index,index}로 되어있어야 합니다.
134

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 64비트 변수(배열) 선언 및 호출 함수 ｡+.ﾟ
CWariable(Player,Index)
: 64비트 변수 선언 함수
Player : 64비트 변수 트리거의 체크 플레이어

Index : 64비트 변수 트리거에 할당할 Index
ex) CWariable(P1,0x10) → P1의 Index:0x10인 변수 선언
CWariable2(Player,Index,Offset,Type,Value,Mask)
: CWariable()에서 초기값을 설정할 수 있는 함수
Player : 64비트 변수 트리거의 체크 플레이어
Index : 64비트 변수 트리거에 할당할 Index
Offset : 64비트 변수 트리거의 초기 Offset값 (기본값 0x58A364)
Type : 64비트 변수 트리거의 초기 Type값 (기본값 SetTo)
Value : 64비트 변수 트리거의 초기 Value값 (기본값 0)
Mask : 64비트 변수 트리거의 초기 Mask값 (기본값 0xFFFFFFFF)
ex) CVariable2(P1,0x10) → P1의 Index:0x10인 변수 선언 - SetMemoryX(0x58A364,SetTo,0,0xFFFFFFFF); 적용

CVariable2(P1,0x10,0x58F500,Add,1234,0xFFFF)
→ P1의 Index:0x10인 변수 선언 - SetMemoryX(0x58F500,Add,1234,0xFFFF); 적용
[예제 22-4] 참고
CWArray(PlayerID,Size)
: Size 만큼의 크기를 갖는 CWArray를 선언하는 함수
PlayerID : 64비트 변수 배열 트리거의 체크 플레이어
Size : 선언할 64비트 변수 배열의 크기 (Size가 4096이상이면 선언 불가)
ex) WArr1 = CWArray(P1,100) → WArr1[0] ~ WArr1[99] 까지 사용가능한 P1 CWArray를 선언

GetWArray(Header,Size)

: 연속된 CWariable을 WArray로 묶어주는 함수 (index 범위는 연속된 변수가 끝날 때까지)
Header : 64비트 변수 배열의 시작점 (W타입 변수를 입력, 인덱스 0번 변수가 됨)
Size : 배열의 크기 (최적화용, 기본값 4095)
ex) WArr1 = GetWArray(W(0x10)) → W(0x10)을 시작위치로 갖는 WArray를 선언
WArr1 = GetWArray(W(0x10,"X",4)) → W(0x10)의 4칸 뒤의 변수를 시작위치로 갖는 WArray를 선언

[예제 22-4] 참고

135

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 64비트 변수(배열) 선언 및 호출 함수 ｡+.ﾟ
LArray(PlayerID,Size)
: Size 만큼의 크기를 갖는 LArray를 선언하는 함수
PlayerID : 64비트 배열 트리거의 체크 플레이어

Size : 선언할 64비트 배열의 크기 (Size가 618496이상이면 선언 불가)
ex) LArr1 = LArray(P1,100) → LArr1[0] ~ LArr1[99] 까지 사용가능한 P1 LArray를 선언
LDb(PlayerID,ByteSize)
: ByteSize 만큼의 LArray를 할당해주는 함수
PlayerID : 64비트 배열 트리거의 체크 플레이어
ByteSize : 선언할 64비트 배열의 용량 ByteSize가 0x400000이상이면 할당 불가)
ex) LArr1 = LDb(P1,0x4000) → 0x4000을 담을 수 있는 P1 LArray를 선언
※ LArray의 값은 맵 실행시 초기화를 따로 시켜줘야합니다. (기본값이 0이 아닐수 있음)
LCallLabel1(Player,Index,Next)
: 특정 플레이어의 Label이 Index인 64비트 변수를 호출할 때 사용 (액션5개, RecoverNext 사용)
Player : 호출트리거의 체크 플레이어 (P1 ~ P8, "X"=CurrentPlayer)
Index : 호출트리거의 Index
Next : 호출트리거의 Next
LCallLabel2(Player,Index,Next)
: LCallLabel1과 함께 사용하는 함수 (바로 다음 트리거에 삽입) (액션1개)
Player, Index, Next는 LCallLabel1과 동일하게 입력
ex) DoActionsX(P1,LCallLabel1(P2,0x10)) → P2의 index:0x10인 64비트 변수 호출 (RecoverNext 사용)
DoActionsX(P1,LCallLabel2(P2,0x10)) → P2의 index:0x10인 64비트 변수의 RecoverNext Flag 복구

[예제 22-4] 참고
※ LCallLabel1과 LCallLabel2는 반드시 함께 사용해야 합니다.
LCallLabel1X(Wariable)
: LCallLabel1의 호출할 변수 정보를 변수 데이터로 입력받는 버전 / Wariable에 W()를 입력
LCallLabel2X(Wariable)
: LCallLabel2의 호출할 변수 정보를 변수 데이터로 입력받는 버전 / Wariable에 W()를 136
입력

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 64비트 변수(배열) 선언 및 호출 함수 ｡+.ﾟ
CallWariable(PlayerID,Player,Index,Next,Conditions,Actions)
: 64비트 변수를 호출하는 트리거 생성 함수
PlayerID : 트리거의 체크 플레이어

Player : 호출트리거의 체크 플레이어 (P1 ~ P8, "X"=CurrentPlayer)
Index : 호출트리거의 Index
Next : 호출트리거의 Next
Conditions : 트리거의 조건 (비우면 RecoverNext 사용안함)
Actions : 트리거의 액션
ex) CallVariable(P1,P2,0x10,0,"X")
→ P2의 index:0x10인 변수를 호출하는 P1트리거 생성 (RecoverNext 사용안함)
CallVariable(P1,P2,0x10,0,{Memory(0x58DC60,AtLeast,1)})
→ P2의 index:0x10인 변수를 호출하는 P1트리거 생성 (RecoverNext 사용)
CallWariableX(PlayerID,Wariable,Conditions,Actions)
: CallWariable의 호출할 변수 정보를 변수 데이터로 입력받는 버전 / Wariable에 W()를 입력

※ RecoverNext : 호출 트리거의 Next를 복구하는 기능
(미사용시 트리거의 조건이 불만족되더라도 CallLabel 액션이 실행됨)
[예제 22-4] 참고

137

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 64비트 Ctrig 파생 조건 및 액션 함수 ｡+.ﾟ
WariableX(Player,Index,Section,Type,Value,Mask)
: 64비트 변수 전용 CtrigX 조건
Player : 64비트 변수의 플레이어 / Index : 64비트 변수의 Index
Section : 선택할 64비트 변수의 영역 :
64비트 모드 : "EPD"(0x158,0x198), "Value"(0x15C,0x19C), "Type"(0x160,0x1A0), "Mask"(0x148,0x188),
"Flag"(0x164,0x1A4) → Value, Mask 64비트로 입력 (조건 2개)
32비트 모드 : "Next"(0x4), "EPD1"(0x158), "EPD2"(0x198), "Value1"(0x15C), "Value2"(0x19C),
"Type1"(0x160), "Type2"(0x1A0), "Mask1"(0x148), "Mask2"(0x188),
"Flag1"(0x164), "Flag2"(0x1A4) → Value, Mask 32비트로 입력 (조건 1개)

Type : 조건 연산자 - AtMost, Exactly, AtLeast (64비트 모드에서 두 조건이 Type을 공유함)
Value : 조건 연산값 - "EPD" : X → {X,X+0x4}, {X,{Y}} → {X,X+Y} / "Mask" X → {X,X} /
"Type" : X → {X,X} (Mask 자동세팅) / "Flag" : X → {X,X} (Mask 자동세팅)
이외의 경우 Value와 Mask에 64비트 스트링 또는 배열을 입력함
Mask : eudx 비트마스크 (기본값 0xFFFFFFFF / "0xFFFFFFFFFFFFFFFF")
ex) WariableX(P1,0x10,"Value",Exactly,"10") → {MemoryX(P1의 0x10변수의 0x15C부분
,Exactly,10,0xFFFFFFFF), MemoryX(P1의 0x10변수의 0x19C부분,Exactly,0,0xFFFFFFFF)}
※ 64비트 조건 연산(AtLeast,AtMost)을 사용하려면 TTWariableX()를 권장함
[예제 22-5] 참고
SetWariableX(Player,Index,Section,Type,Value,Mask)
: 64비트 변수 전용 SetCtrigX 액션
Player : 64비트 변수의 플레이어 / Index : 64비트 변수의 Index
Section : 선택할 64비트 변수의 영역 :
64비트 모드 : "EPD"(0x158,0x198), "Value"(0x15C,0x19C), "Type"(0x160,0x1A0), "Mask"(0x148,0x188),

"Flag"(0x164,0x1A4) → Value, Mask 64비트로 입력 (액션 2개)
32비트 모드 : "Next"(0x4), "EPD1"(0x158), "EPD2"(0x198), "Value1"(0x15C), "Value2"(0x19C),
"Type1"(0x160), "Type2"(0x1A0), "Mask1"(0x148), "Mask2"(0x188),
"Flag1"(0x164), "Flag2"(0x1A4) → Value, Mask 32비트로 입력 (액션 1개)

Type : 액션 연산자 - Add, SetTo, Subtract (64비트 모드에서 두 액션이 Type을 공유함)
Value : 액션 연산값 - "EPD" : X → {X,X+0x4}, {X,{Y}} → {X,X+Y} / "Mask" X → {X,X} /
"Type" : X → {X,X} (Mask 자동세팅) / "Flag" : X → {X,X} (Mask 자동세팅)
이외의 경우 Value와 Mask에 64비트 스트링 또는 배열을 입력함

Mask : eudx 비트마스크 (기본값 0xFFFFFFFF / "0xFFFFFFFFFFFFFFFF")
ex) SetWariableX(P1,0x10,"Value",SetTo,{1,2}) → {SetMemoryX(P1의 0x10변수의 0x15C부분
,SetTo,1,0xFFFFFFFF), SetMemoryX(P1의 0x10변수의 0x19C부분,SetTo,2,0xFFFFFFFF)}
※ 64비트 액션 연산(Add,Subtract)을 사용하려면 f_LAdd, f_LSub()를 권장함

138

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 64비트 Ctrig 파생 조건 및 액션 함수 ｡+.ﾟ
Wariable(Wariable,Section,Type,Value,Mask)
: WariableX의 입력할 변수 정보를 변수 데이터로 입력받는 버전 / Wariable에 W()를 입력
SetWariable(Wariable,Section,Type,Value,Mask)
: SetWariableX의 입력할 변수 정보를 변수 데이터로 입력받는 버전 / Wariable에 W()를 입력

WArrayX(WArray,Section,Type,Value,Mask)
: 64비트 변수배열 상수인덱스 전용 CtrigX 조건
WArray : 변수배열 헤더 (CWArray, GetWArray 리턴값)
나머지는 WariableX와 동일함
※ 64비트 조건 연산(AtLeast,AtMost)을 사용하려면 TTWArrayX()를 권장함
SetWArrayX(WArray,Section,Type,Value,Mask)
: 64비트 변수배열 상수인덱스 전용 CtrigX 액션
WArray : 변수배열 헤더 (CWArray, GetWArray 리턴값)
나머지는 SetWariableX와 동일함
※ 64비트 액션 연산(Add,Subtract)을 사용하려면 f_LAdd, f_LSub()를 권장함
CWar(Player,Index,Type,Value,Mask)
: WariableX에서 Section이 "Value(1,2)"(0x15C/0x19C)로 설정된 버전
Value = X → "Value1"로 입력됨

Value = {X} → "Value2"로 입력됨
Value = {X,Y} or 스트링 → "Value"로 입력됨
나머지는 WariableX와 동일함
SetCWar(Player,Index,Type,Value,Mask)
: SetWariableX에서 Section이 "Value(1,2)"(0x15C/0x19C)로 설정된 버전
Value = X → "Value1"로 입력됨
Value = {X} → "Value2"로 입력됨
Value = {X,Y} or 스트링 → "Value"로 입력됨
나머지는 SetWariableX와 동일함
[예제 22-5] 참고

139

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 64비트 Ctrig 파생 조건 및 액션 함수 ｡+.ﾟ
NWar(Wariable,Type,Value,Mask)
: CWar의 입력할 변수 정보를 변수 데이터로 입력받는 버전 / Wariable에 W()를 입력
SetNWar(Wariable,Type,Value,Mask)
: SetCWar의 입력할 변수 정보를 변수 데이터로 입력받는 버전 / Wariable에 W()를 입력
CWAar(WArray,Type,Value,Mask)
: WArrayX에서 Section이 "Value(1,2)"(0x15C/0x19C)로 설정된 버전
Value = X → "Value1"로 입력됨
Value = {X} → "Value2"로 입력됨
Value = {X,Y} or 스트링 → "Value"로 입력됨
나머지는 WArrayX와 동일함
SetCWAar(WArray,Type,Value,Mask)
: SetWArrayX에서 Section이 "Value(1,2)"(0x15C/0x19C)로 설정된 버전
Value = X → "Value1"로 입력됨
Value = {X} → "Value2"로 입력됨
Value = {X,Y} or 스트링 → "Value"로 입력됨
나머지는 SetWArrayX와 동일함
LMemX(LMem,Type,Value,Mask)
: LMem 타입 전용 CtrigX 조건

LMem : LMem 데이터 입력 (Memx2)
Type : 조건 연산자 - AtMost, Exactly, AtLeast
Value : 조건 연산값 / Mask : eudx 비트마스크 (기본값 "0xFFFFFFFFFFFFFFFF")
SetLMemX(LMem1,Type,LMem2,Mask)
: LMem 타입 전용 CtrigX 액션
LMem1 : LMem 데이터 입력 (Offset) - 상수 입력 가능 (Offset 입력)
LMem2 : LMem 데이터 입력 (Value) - EPDflag 1이면 EPD값을 입력함, 상수 입력 가능

Type : 액션 연산자 - Add, SetTo, Subtract
Value : 액션 연산값 / Mask : eudx 비트마스크 (기본값 "0xFFFFFFFFFFFFFFFF")
[예제 22-5] 참고
140

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 64비트 변수 삽입형 조건 및 액션 함수 ｡+.ﾟ
TWariableX(Player,Index,Section,Type,Value,Mask)
TSetWariableX(Player,Index,Section,Type,Value,Mask)
TWariable(Wariable,Section,Type,Value,Mask)

TSetWariable(Wariable,Section,Type,Value,Mask)
TWArrayX(WArray,Section,Type,Value,Mask)
TSetWArrayX(WArray,Section,Type,Value,Mask)
: (Set)[Wariable/WArray](X) 조건/액션의 변수 삽입형 함수 (32비트 모드만 사용가능)
변수 삽입 가능 항목 : Value, Mask (V(i) 입력)
※ Section에 "EPD", "Value", "Type", "Mask", "Flag"는 사용불가 (64비트 모드 전용)
TCWar(Player,Index,Type,Value,Mask)
TSetCWar(Player,Index,Type,Value,Mask)
TNWar(Wariable,Type,Value,Mask)
TSetNWar(Wariable,Type,Value,Mask)
TCWAar(WArray,Type,Value,Mask)
TSetCWAar(WArray,Type,Value,Mask)
: (Set)[C/N][War/WAar] 조건/액션의 변수 삽입형 함수 (32비트 모드만 사용가능)
변수 삽입 가능 항목 : Value, Mask (V(i) 입력)

※ Value에 X 또는 {X}만 사용가능 (64비트 모드 사용불가)
Ex)[예제 22-6] 참고

141

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 64비트 비교 연산 및 특수 조건 관련 함수｡+.ﾟ
TTLMemory(Offset,Type,Value)
TTLMemoryX(Offset,Type,Value,Mask)
: 64비트 Memory(X)조건의 특수조건/변수 삽입형 함수

변수 삽입 가능 항목 : Player(epd), Value, Mask (W(i) 입력)
Offset : X → {X,X+4} / 스트링 → {X,Y} / {X/Mem,{Y}} → {X/Mem,X/Mem+Y}
{X1/Mem1,X2/Mem2} 삽입 가능 (변수는 W만 입력가능)
Value : {X,Y} 또는 스트링 / Mask : {X,Y} 또는 스트링 (기본값 {0xFFFFFFFF,0xFFFFFFFF})
Ex) [예제 22-7] 참고
Ex) [예제 22-8] 참고
※ Type에 Exactly, NotSame, AtLeast, Above, AtMost, Below 모두 사용가능 (64비트 조건연산)
※ Type에 iAtLeast, iAtMost, iAbove, iBelow 모두 사용가능 (64비트 부호있는 조건연산)

TTWariableX(Player,Index,Section,Type,Value,Mask)
TTWariable(Wariable,Section,Type,Value,Mask)
TTWArrayX(WArray,Section,Type,Value,Mask)
: [Wariable/WArray](X) 조건/액션의 특수조건/변수 삽입형 함수 (64비트 모드)
변수 삽입 가능 항목 : Value, Mask (W(i) 입력)
※ Type에 Exactly, NotSame, AtLeast, Above, AtMost, Below 모두 사용가능 (64비트 조건연산)
※ Type에 iAtLeast, iAtMost, iAbove, iBelow 모두 사용가능 (64비트 부호있는 조건연산)

TTCWar(Player,Index,Type,Value,Mask)
TTNWar(Wariable,Type,Value,Mask)
TTCWAar(WArray,Type,Value,Mask)
: (Set)[C/N][War/WAar] 조건/액션의 특수조건/변수 삽입형 함수 (64비트 모드)
변수 삽입 가능 항목 : Value, Mask (W(i) 입력)
※ Type에 Exactly, NotSame, AtLeast, Above, AtMost, Below 모두 사용가능 (64비트 조건연산)

※ Type에 iAtLeast, iAtMost, iAbove, iBelow 모두 사용가능 (64비트 부호있는 조건연산)

142

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 64비트 함수 호출형 최종 연산 함수｡+.ﾟ
Include_64BitLibrary(SeedSwitch)
: 어셈블러가 지원하는 모든 64비트 호출형 함수를 Include 합니다.
SeedSwitch : 64비트 난수값을 만들때 사용할 스위치를 설정함

※ 반드시 Tep 맨 위의 CJump(0) 사이에 넣어야 합니다
f_LRead(PlayerID,Input,Output,Mask,Clear)
: f_maskread 방식으로 값을 읽어들임
PlayerID : 생성 트리거의 체크 플레이어
Input : 값을 읽어올 대상 - 변수값을 epd로 간주해 읽어옴
X→{X,X+4} / 스트링 / W(WA), LA / {X/V(VA)/Mem(A), X/V(VA)/Mem(A)}, {X/Mem,{Y}}→{X/Mem,X/Mem+Y}

Output : 결과값을 담을 대상
X→{X,X+4} / 스트링 / W(WA), LA / {X/V(VA)/Mem(A), X/V(VA)/Mem(A)}, {X/Mem,{Y}}→{X/Mem,X/Mem+Y}

Mask : 읽어올 범위 (기본값 "0xFFFFFFFFFFFFFFFF")
Clear : 자동 초기화 flag - 중간 연산자에서 사용 / Output 전체 초기화가 필요할 때 1을 입력

ex) [예제 22-A] 참고
f_LReadX(PlayerID,Input,Output,Multiplier,Mask,Clear)
: f_LRead에서 ConvertX 기능을 추가한 함수
Multiplier : 읽어온 값에 증감시킬 바이트 수를 입력 (-7 ~ 7까지 입력 가능)
나머지는 f_LRead와 동일함
Clear : 자동 초기화 flag - 중간 연산자에서 사용 / Output 전체 초기화가 필요할 때 1을 입력

ex) [예제 22-B] 참고
f_LWrite(PlayerID,Dest,Source,Deviation,Mask) ※ 매크로형
: SetMemoryX(W(Dest),SetTo,W(Source),Mask) 방식으로 값을 씀
PlayerID : 생성 트리거의 체크 플레이어

Dest : 값을 쓸 대상 - 변수값을 epd로 간주해 읽어옴
W(WA) / {V(VA), V(VA)}

Source : 대상에 쓸 값
X→{X,0} / 스트링 / W(WA) / {X/V(VA), X/V(VA)}

Deviation : 결과값의 편차 - Dest에 상수를 더함
Mask : 값을 쓸 범위 (기본값 "0xFFFFFFFFFFFFFFFF")

ex) [예제 22-C] 참고

143

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 64비트 함수 호출형 최종 연산 함수｡+.ﾟ
f_LMov(PlayerID,Dest,Source,Deviation,Mask,Clear) ※ 매크로형
: 변수에서 값을 출력해서 대입함, Dest << Source + Deviation
PlayerID : 생성 트리거의 체크 플레이어

Dest : 결과값을 담을 대상
X→{X,X+4} / 스트링 / W(WA), LA / {X/V(VA)/Mem(A), X/V(VA)/Mem(A)}, {X/Mem,{Y}}→{X/Mem,X/Mem+Y}

Source : 값을 읽어올 대상
X→{X,0} / 스트링 / W(WA) / {X/V(VA), X/V(VA)}

Deviation : 결과값의 편차 - Dest에 상수를 더함
Mask : 값을 읽어올 범위 (기본값 "0xFFFFFFFFFFFFFFFF")
Clear : 자동 초기화 flag - 중간 연산자에서 사용 / Dest 전체 초기화가 필요할 때 1을 입력

ex) [예제 22-D] 참고
f_LMovX(PlayerID,Dest,Source,Mode,Mask,Deviation,Clear) ※ 매크로형
: 변수배열에 값을 대입하거나 변수배열의 값을 출력함, Dest << Source + Deviation
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상
Source : 값을 읽어올 대상
WA, LA << X(→{X,0}), 스트링, {X/V,X/V}, W
X(→{X,X+4}, 스트링, W(WA), LA, {X/V/Mem, X/V/Mem}, {X/Mem,{Y}}→{X/Mem,X/Mem+Y} << WA

Mode : 액션 연산자 - Add / SetTo / Subtract
Deviation : 결과값의 편차 - Dest에 상수를 더함
Mask : 값을 읽어올 범위 (기본값 "0xFFFFFFFFFFFFFFFF")
Clear : 자동 초기화 flag - 중간 연산자에서 사용 / Dest 전체 초기화가 필요할 때 1을 입력

ex) [예제 22-E] 참고

144

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 64비트 함수 호출형 최종 연산 함수｡+.ﾟ
TLMem(PlayerID,Dest,Source,Address,Next,OffsetFlag) ※ 매크로형
: Dest(W)에 Source의 주소값(epd/Offset)값을 저장함
PlayerID : 생성 트리거의 체크 플레이어

Dest : 주소값을 담을 변수 (W타입만 가능)
Source : 주소값을 읽어올 대상
V→{V주소,V주소} (기본값 0x15C,0x15C), W→{W주소,W주소} (기본값 0x15C,0x19C),
VA→{VA주소,VA주소} (기본값 0x15C,0x15C), WA→{WA주소,WA주소} (기본값 0x15C,0x19C),
Mem→{Mem주소,Mem주소}, A→{A주소,A주소}, LA→{LA주소(앞),LA주소+1(뒤)}

Address : (V(A)/W(A)만 해당) 변수의 주소값(+0x0) + Address값 - 배열로 입력 {X,Y}
Next : (V(A)/W(A)만 해당) 변수의 Next
OffsetFlag : 비우면 EPD값을 반환 / 1 입력시 Offset값을 반환
ex) [예제 22-F] 참고
f_LDiff(PlayerID,Dest,Source,Mask,Time,Delay,Init) ※ 매크로형
: Dest에 Source의 Time 동안의 변화량 값을 구함, Dest << W - prevW → prevW << W
PlayerID : 생성 트리거의 체크 플레이어
Dest : 변화량을 담을 변수 (W/WA)
Source : 변화량을 측정할 대상 (W/WA)
Mask : 변화량을 읽어올 범위 (기본값 "0xFFFFFFFFFFFFFFFF")
Time : 변화량을 측정할 주기 (Time ≤ 1일 경우 매 틱마다 측정)
Delay : 첫 실행시까지 대기할 시간
Init : 첫 실행 후 prevW << W 이전까지 변화량 측정값을 0으로 고정함
ex) [예제 22-G] 참고
f_LRand(PlayerID,Dest,Mask)
: Dest에 64비트 랜덤 난수를 저장하는 함수

PlayerID : 생성 트리거의 체크 플레이어
Dest : 랜덤 난수를 담을 대상
X→{X,X+4} / 스트링 / W(WA), LA / {X/V(VA)/Mem(A), X/V(VA)/Mem(A)}, {X/Mem,{Y}}→{X/Mem,X/Mem+Y}

Mask : 난수값을 담을 범위 (기본값 "0xFFFFFFFFFFFFFFFF")
ex) [예제 22-H] 참고
※ 랜덤 난수를 만들때 SeedSwitch를 사용합니다.

145

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 64비트 함수 호출형 최종 연산 함수｡+.ﾟ
f_Cast(PlayerID,Dest,Source,Deviation,Mask,Clear) ※ 매크로형
: 변수 타입을 변환함 (64비트 변수 W(A) ↔ 32비트 변수 V(A))
PlayerID : 생성 트리거의 체크 플레이어

Dest : 타입변환 후의 변수
Source : 타입변환 전의 변수
V(A) → W(A) : Dest = W(A) → WA(A) << V(A) (앞, 뒤 모두 V(A)를 복사)
W(A) → V(A) : Dest = {V(A),0} → V(A) << 앞 4바이트, {V(A),1} → V(A) << 뒤 4바이트
Deviation : 결과값의 편차 - Dest에 상수를 더함
Mask : 값을 읽어올 범위 (기본값 "0xFFFFFFFFFFFFFFFF" / 0xFFFFFFFF)
Clear : 자동 초기화 flag - 중간 연산자에서 사용 / Dest 전체 초기화가 필요할 때 1을 입력

ex) [예제 22-I] 참고
f_iCast(PlayerID,Dest,Source) ※ 매크로형
: 변수 타입을 부호를 고려하여 변환함 (64비트 변수 W(A) ↔ 32비트 변수 V(A))
PlayerID : 생성 트리거의 체크 플레이어
Dest : 타입변환 후의 변수
Source : 타입변환 전의 변수
V(A) → W(A) / W(A) → V(A)

※ 변환 규칙은 C++의 signed long long ↔ signed int 와 같습니다.
ex) [예제 22-J] 참고

146

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 64비트 함수 호출형 최종 연산 함수｡+.ﾟ
f_LAdd(PlayerID,Dest,Source,Operand,Mask)
: 변수에 덧셈 연산을 수행함, Dest << Source + Operand
PlayerID : 생성 트리거의 체크 플레이어

Dest : 결과값을 담을 대상
X→{X,X+4} / 스트링 / W(WA), LA / {X/V(VA)/Mem(A), X/V(VA)/Mem(A)}, {X/Mem,{Y}}→{X/Mem,X/Mem+Y}

Source : 연산할 값을 읽어올 대상
X→{X,0} / 스트링 / W(WA) / {X/V(VA), X/V(VA)}

Operand : 연산할 값을 읽어올 대상
X→{X,0} / 스트링 / W(WA) / {X/V(VA), X/V(VA)}

Mask : 결과값을 대입할 범위 (기본값 "0xFFFFFFFFFFFFFFFF")
ex) [예제 22-K] 참고
f_LSub(PlayerID,Dest,Source,Operand,Mask)
: 변수에 뺄셈 연산을 수행함, Dest << Source - Operand
모두 f_LAdd와 동일하게 입력
Ex) [예제 22-L] 참고
f_LiSub(PlayerID,Dest,Source,Operand,Mask)
: 변수에 부호 있는 뺄셈 연산을 수행함, Dest << Source - Operand (signed 연산)
모두 f_LAdd와 동일하게 입력
Ex) [예제 22-M] 참고
f_LNeg(PlayerID,Dest,Source,Mask)
: 변수의 부호를 바꾸는 연산을 수행함, Dest << -Source
모두 f_LAdd와 동일하게 입력
Ex) [예제 22-N] 참고
f_LAbs(PlayerID,Dest,Source,Mask)
: 변수에 절댓값 연산을 수행함, Dest << |Source|
모두 f_LAdd와 동일하게 입력
Ex) [예제 22-O] 참고
147

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 64비트 함수 호출형 최종 연산 함수｡+.ﾟ
f_LMul(PlayerID,Dest,Source,Operand,Mask)
: 변수에 곱셈 연산을 수행함, Dest << Source * Operand
모두 f_LAdd와 동일하게 입력

Ex) [예제 22-P] 참고
f_LiMul(PlayerID,Dest,Source,Operand,Mask)
: 변수에 곱셈 연산을 수행함, Dest << Source * Operand
모두 f_LAdd와 동일하게 입력
Ex) [예제 22-Q] 참고
※ f_LMul과 동일하나, Operand의 절댓값이 작을수록 연산속도가 빨라짐 (절댓값 작은 Signed 변수용)

f_LDiv(PlayerID,Dest,Source,Operand,Mask)
: 변수에 나눗셈 연산을 수행함, Dest << Source / Operand
모두 f_LAdd와 동일하게 입력
Ex) [예제 22-R] 참고
f_LiDiv(PlayerID,Dest,Source,Operand,Mask)
: 변수에 부호 있는 뺄셈 연산을 수행함, Dest << Source / Operand (signed 연산)

모두 f_LAdd와 동일하게 입력
Ex) [예제 22-S] 참고
f_LMod(PlayerID,Dest,Source,Operand,Mask)
: 변수에 나머지 연산을 수행함, Dest << Source % Operand
모두 f_Ladd와 동일하게 입력
Ex) [예제 22-T] 참고
f_LiMod(PlayerID,Dest,Source,Operand,Mask)
: 변수에 부호 있는 나머지 연산을 수행함, Dest << Source % Operand (signed 연산)
모두 f_LAdd와 동일하게 입력
Ex) [예제 22-U] 참고

148

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 64비트 함수 호출형 최종 연산 함수｡+.ﾟ
f_LlShift(PlayerID,Dest,Source,Operand,Mask)
: 변수에 lShift 연산을 수행함, Dest << Source << Operand
모두 f_LAdd와 동일하게 입력, Operand에는 상수(32비트)/V(A)/W(A) 입력가능

Ex) [예제 22-V] 참고
f_LAnd(PlayerID,Dest,Source,Operand,Mask)
: 변수에 And 연산을 수행함, Dest << Source & Operand
모두 f_LAdd와 동일하게 입력
Ex) [예제 22-W] 참고
f_LOr(PlayerID,Dest,Source,Operand,Mask)
: 변수에 Or 연산을 수행함, Dest << Source | Operand
모두 f_LAdd와 동일하게 입력
Ex) [예제 22-X] 참고
f_LXor(PlayerID,Dest,Source,Operand,Mask)
: 변수에 Xor 연산을 수행함, Dest << Source ^ Operand
모두 f_LAdd와 동일하게 입력

Ex) [예제 22-Y] 참고
f_LNot(PlayerID,Dest,Source,Mask)
: 변수에 Not 연산을 수행함, Dest << ~ Source
모두 f_LAdd와 동일하게 입력
Ex) [예제 22-Z] 참고

149

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 64비트 중간 연산자 관련 함수｡+.ﾟ
_LRead(Source,Mask)
: f_LRead의 중간 연산자 함수, W << f_maskread(Source)
Source : 연산할 값을 읽어올 대상
X→{X,X+4} / 스트링 / W(WA), LA / {X/V(VA)/Mem(A), X/V(VA)/Mem(A)}, {X/Mem,{Y}}→{X/Mem,X/Mem+Y}

Mask : 읽어올 범위 (기본값 "0xFFFFFFFFFFFFFFFF")
_LReadX(Source,Multiplier,Mask)
: f_LReadX의 중간 연산자 함수, W << f_maskread(Source) * Multiplier
Multiplier : 읽어온 값에 증감시킬 바이트 수를 입력 (-7 ~ 7까지 입력 가능)
나머지는 _LRead와 동일함
_LMov(Source,Mask,Deviation)
: f_LMov의 중간 연산자 함수, W << Source + Deviation
Source : 연산할 값을 읽어올 대상
X→{X,0} / 스트링 / W(WA) / {X/V(VA), X/V(VA)}
Mask : 대입 연산 비트마스크 (기본값 "0xFFFFFFFFFFFFFFFF")
Deviation : 결과값의 편차 - Dest에 상수를 더함

_LMovX(Source,Mode,Mask,Deviation)
: f_LMovX의 중간 연산자 함수, W << Source + Deviation
Source : 연산할 값을 읽어올 대상
X→{X,0} / 스트링 / W(WA) / {X/V(VA), X/V(VA)}
Mode : 액션 연산자 - Add / SetTo / Subtract
Mask : 대입 연산 비트마스크 (기본값 "0xFFFFFFFFFFFFFFFF")
Deviation : 결과값의 편차 - Dest에 상수를 더함

150

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 64비트 중간 연산자 관련 함수｡+.ﾟ
_TLMem(Source,Address,Next,OffsetFlag)
: TLMem의 중간 연산자 함수, W << 주소값(epd/Offset)
Source : 주소값을 읽어올 대상
V→{V주소,V주소} (기본값 0x15C,0x15C), W→{W주소,W주소} (기본값 0x15C,0x19C),
VA→{VA주소,VA주소} (기본값 0x15C,0x15C), WA→{WA주소,WA주소} (기본값 0x15C,0x19C),
Mem→{Mem주소,Mem주소}, A→{A주소,A주소}, LA→{LA주소(앞),LA주소+1(뒤)}

Address : (V(A)/W(A)만 해당) 변수의 주소값(+0x0) + Address값 - 배열로 입력 {X,Y}
Next : (V(A)/W(A)만 해당) 변수의 Next
OffsetFlag : 비우면 EPD값을 반환 / 1 입력시 Offset값을 반환
_LRand()

: f_LRand의 중간 연산자 함수, W << 64비트 난수
※ 랜덤 난수를 만들때 SeedSwitch를 사용합니다.
_Cast(Dest,Source,Deviation,Mask)
: f_Cast의 중간 연산자 함수, W(A) → V 전용
Dest : 변환 후 저장할 위치 (0 : 앞 4바이트, 1 : 뒤 4바이트)
Source : 타입변환 전의 변수 (W/WA)
Deviation : 결과값의 편차 - Dest에 상수를 더함

Mask : 값을 읽어올 범위 (기본값 "0xFFFFFFFFFFFFFFFF")
_CastW(Source,Deviation,Mask)
: f_Cast의 중간 연산자 함수, V(A) → W 전용
Source : 타입변환 전의 변수 (V/VA)
Deviation : 결과값의 편차 - Dest에 상수를 더함
Mask : 값을 읽어올 범위 (기본값 0xFFFFFFFF)

_iCast(Source)
: f_iCast의 중간 연산자 함수, W(A) → V 전용
Source : 타입변환 전의 변수 (W/WA)
_iCastW(Source)
: f_iCast의 중간 연산자 함수, V(A) → W 전용
Source : 타입변환 전의 변수 (V/VA)

151

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 64비트 중간 연산자 관련 함수｡+.ﾟ
_LAdd(Source,Operand)
: f_LAdd의 중간 연산자 함수, W << Source + Operand
Source : 연산할 값을 읽어올 대상

X→{X,0} / 스트링 / W(WA) / {X/V(VA), X/V(VA)}
Operand : 연산할 값을 읽어올 대상
X→{X,0} / 스트링 / W(WA) / {X/V(VA), X/V(VA)}
_LSub(Source,Operand)
: f_LSub의 중간 연산자 함수, W << Source - Operand
모두 _LAdd와 동일하게 입력
_LiSub(Source,Operand)
: f_LiSub의 중간 연산자 함수, W << Source - Operand (signed 연산)
모두 _LAdd와 동일하게 입력
_LNeg(Source)
: f_LNeg의 중간 연산자 함수, W << -Source
모두 _LAdd와 동일하게 입력
_LAbs(Source)
: f_LAbs의 중간 연산자 함수, W << |Source|
모두 _LAdd와 동일하게 입력
_LMul(Source,Operand)
: f_LMul의 중간 연산자 함수, W << Source * Operand
모두 _LAdd와 동일하게 입력
_LiMul(Source,Operand)
: f_LiMul의 중간 연산자 함수, W << Source * Operand
모두 _LAdd와 동일하게 입력
※ _LMul과 동일하나, Operand의 절댓값이 작을수록 연산속도가 빨라짐 (절댓값 작은 Signed 변수용)
152

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 64비트 중간 연산자 관련 함수｡+.ﾟ
_LDiv(Source,Operand)
: f_LDiv의 중간 연산자 함수, W << Source / Operand
모두 _LAdd와 동일하게 입력
_LiDiv(Source,Operand)
: f_LiDiv의 중간 연산자 함수, W << Source / Operand (signed 연산)
모두 _LAdd와 동일하게 입력
_LMod(Source,Operand)
: f_LMod의 중간 연산자 함수, W << Source % Operand
모두 _LAdd와 동일하게 입력
_LiMod(Source,Operand)
: f_LiMod의 중간 연산자 함수, W << Source % Operand (signed 연산)
모두 _LAdd와 동일하게 입력
_LlShift(Source,Operand)
: f_LlShift의 중간 연산자 함수, W << Source << Operand
모두 _LAdd와 동일하게 입력

_LAnd(Source,Operand)
: f_LAnd의 중간 연산자 함수, W << Source & Operand
모두 _LAdd와 동일하게 입력
_LOr(Source,Operand)
: f_LOr의 중간 연산자 함수, W << Source | Operand
모두 _LAdd와 동일하게 입력

_LXor(Source,Operand)
: f_LXor의 중간 연산자 함수, W << Source ^ Operand
모두 _LAdd와 동일하게 입력
_LNot(Source)
: f_LNot의 중간 연산자 함수, W << ~ Source
모두 _LAdd와 동일하게 입력

153

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 구조체 변수 표준 입출력 및 변환 함수 ｡+.ﾟ
SV(SVariable,Line,Player,Next)
: 구조체 변수 정보를 입력하는 함수 (SV타입 리턴 → SVData)
SVariable : 선언한 구조체 변수의 리턴값

Line : 구조체 변수 내부의 연산할 변수 줄 수 (1~32 까지 입력 가능)
_SMem / SCast / SCopy / ([T/TT])(Set)[C/N][Var/VAar](X) 에 사용
Player : 변수의 Player ("X"→CurrentPlayer) / Next : 변수의 Next
Ex) [예제 23-1] 참고
※ 위 목록에 없는 함수에서 SV() 사용시 Line 항목은 무시됨
_SMem(SVData,Address,Next,EPDflag)
: 구조체 변수 데이터를 Ctrig메모리 데이터(배열)로 변환하는 함수
SVData : 변수 데이터 (SV, SVArr(상수인덱스)) 입력
Next : 변수 트리거의 Next (기본값 0)
EPDflag : SetMemX, T액션의 Value부분에 Ctrig주소를 입력할 방식을 선택 (0 = Value, 1 = EPD), (기본값 0)

Address : 변수 트리거의 선택할 영역의 주소
Address = nil → Line = nil : SVariable 전체 내부 변수 Value 영역 (0x15C+0x40*i)
Line = X : 0x15C+0x40*(X-1)
Line = {X,Y,…} : {0x15C+0x40*(X-1), 0x15C+0x40*(Y-1),…}

Address = X → Line = nil : X
Line = Y : X+0x40*(Y-1)
Address = {X1,{ΔX}} → Line = nil : SVariable 전체 내부 변수 Value 영역 (0x15C+ ΔX*i)
Line = X : 0x15C+ ΔX*(X-1)
Line = {X,Y,…} : {0x15C+ ΔX*(X-1), 0x15C+ ΔX*(Y-1),…}
Ex) [예제 23-1] 참고

154

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 구조체 변수 표준 입출력 및 변환 함수 ｡+.ﾟ
SVArr(SVArray,Index,Line,Player)
: 구조체 변수 배열을 입력하는 함수 (SV타입 리턴 → SVData / SVA타입 리턴)
SVArray : 구조체 변수배열 헤더 (SVArray 또는 GetSVArray 리턴값 입력)

Index : 구조체 변수배열의 인덱스 : 상수 or 변수(V) 입력 - Vi 입력 가능
Line : 구조체 변수 내부의 연산할 변수 줄 수 (1~32 까지 입력 가능)
_SMem / SCast / SCopy / ([T/TT])(Set)[C/N][Var/VAar](X) 에 사용
Player : 구조체 변수배열의 Player 입력 (기본값 "X")
Ex) [예제 23-2] 참고
SVArrX(SVArray,Index,Index4,Line,Player)
: SVArr()의 최적화용 함수 (SV타입 리턴 → SVData / SVA타입 리턴)
Index가 상수 → Index4는 입력 필요X
Index가 변수 → Index, Index4에 각각 ConvertSVArr의 Dest, Dest4에 넣었던 변수를 입력
(Index에 Vi 입력 가능, 입력시 Index4 자동적용)
ConvertSVArr(PlayerID,Dest,Dest4,Source,Size)
: SVArr, SVArrX용 인덱스값 변환 함수
PlayerID : 트리거 체크 플레이어
Dest : (Source+Vi)*604 (epd), Dest4 : (Source+Vi)*2416 (offset) (인덱스값을 SVArr에 맞게 변환)

Source : 배열의 변수 Index (V(i) 입력 가능)
Size : 배열의 크기 (최적화용, 기본값 4095)
Ex) [예제 23-2] 참고
※ SVArray의 간격은 0x970으로, Dest에는 *604(epd), Dest4에는 *2416(Offset)을 대입함 (각각 Index, Index4)

155

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 구조체 변수(배열) 선언 및 호출 함수 ｡+.ﾟ
CSVariable(Player,Index,Number)
: 구조체 변수 선언 함수 (S타입 리턴 → SVariable)
Player : 구조체 변수 트리거의 체크 플레이어

Index : 구조체 변수 트리거에 할당할 Index
Number : 구조체 변수 내부의 변수 개수 (1~32 까지 입력 가능)
Ex) CSVariable(P1,0x10,4) → P1의 Index:0x10, 변수 4개인 구조체 변수 선언
※ 같은 SV(A) 타입이더라도 Number 개수가 다르면 서로 다른 타입으로 간주됩니다.
CSVariable2(Player,Index,Number,Offset,Type,Value,Mask)
: CWariable()에서 초기값을 설정할 수 있는 함수 (S타입 리턴 → SVariable)
Player : 구조체 변수 트리거의 체크 플레이어
Index : 구조체 변수 트리거에 할당할 Index
Offset : 구조체 변수 트리거의 초기 Offset값 (기본값 0x58A364)
Type : 구조체 변수 트리거의 초기 Type값 (기본값 SetTo)
Value : 구조체 변수 트리거의 초기 Value값 (기본값 0)
Mask : 구조체 변수 트리거의 초기 Mask값 (기본값 0xFFFFFFFF)
Offset, Type, Value, Mask = nil → 모두 기본값으로 입력됨
= X → X를 기본값으로 간주하여 모두 X로 입력됨
= {X,Y,…} → 1번째 변수부터 순서대로 X, Y, … 입력됨

SVArray(PlayerID,Size,Number)
: Size 만큼의 크기를 갖는 SVArray를 선언하는 함수 (SA타입 리턴 → SVArray)
PlayerID : 구조체 배열 트리거의 체크 플레이어
Size : 선언할 구조체 배열의 크기 (Size가 4096이상이면 선언 불가)
Number : 구조체 변수 내부의 변수 개수 (1~32 까지 입력 가능)
ex) SVArr1 = SVArray(P1,100,4) → SVArr1[0] ~ SVArr1[99] 까지 사용가능한 P1,변수 4개 SVArray를 선언

GetSVArray(Header,Size)
: 연속된 CSVariable을 SVArray로 묶어주는 함수

(SA타입 리턴 → SVArray, index 범위는 연속된 변수가 끝날 때까지)
Header : 구조체 배열의 시작점 (SV타입 변수를 입력, 인덱스 0번 변수가 됨)
Size : 배열의 크기 (최적화용, 기본값 4095)
ex) SVArr1 = GetSVArray(SV(0x10)) → SV(0x10)을 시작위치로 갖는 SVArray를 선언
※ SVArray의 Number 개수는 묶은 CSVariable과 동일합니다.
ex) [예제 23-3] 참고

156

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 구조체 변수(배열) 선언 및 호출 함수 ｡+.ﾟ
SCallLabel1(Player,SVariable,Next)
: 특정 플레이어의 Label이 Index인 구조체 변수를 호출할 때 사용 (액션5개, RecoverNext 사용)
Player : 호출트리거의 체크 플레이어 (P1 ~ P8, "X"=CurrentPlayer)

SVariable : 호출하는 CSVariable의 리턴값 입력
Next : 호출트리거의 Next
SCallLabel2(Player,SVariable,Next)
: SCallLabel1과 함께 사용하는 함수 (바로 다음 트리거에 삽입) (액션1개)
Player, SVariable, Next는 SCallLabel1과 동일하게 입력
ex) DoActionsX(P1,SCallLabel1(P2,0x10)) → P2의 index:0x10인 구조체 변수 호출 (RecoverNext 사용)
DoActionsX(P1,SCallLabel2(P2,0x10)) → P2의 index:0x10인 구조체 변수의 RecoverNext Flag 복구

ex) [예제 23-3] 참고
※ SCallLabel1과 SCallLabel2는 반드시 함께 사용해야 합니다.
SCallLabel1X(SVData)
: SCallLabel1의 호출할 변수 정보를 변수 데이터로 입력받는 버전 / SVData에 SV()를 입력
SCallLabel2X(SVData)
: SCallLabel2의 호출할 변수 정보를 변수 데이터로 입력받는 버전 / SVData에 SV()를 입력
CallSVariable(PlayerID,Player,SVariable,Next,Conditions,Actions)
: 구조체 변수를 호출하는 트리거 생성 함수
PlayerID : 트리거의 체크 플레이어
Player : 호출트리거의 체크 플레이어 (P1 ~ P8, "X"=CurrentPlayer)
SVariable : 호출하는 CSVariable의 리턴값 입력
Next : 호출트리거의 Next
Conditions : 트리거의 조건 (비우면 RecoverNext 사용안함)
Actions : 트리거의 액션
CallSVariableX(PlayerID,SVData,Conditions,Actions)
: CallSVariable의 호출할 변수 정보를 변수 데이터로 입력받는 버전 / SVData에 SV()를 입력

※ RecoverNext : 호출 트리거의 Next를 복구하는 기능
(미사용시 트리거의 조건이 불만족되더라도 CallLabel 액션이 실행됨)

157

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 구조체 변수 조작용 조건 및 액션 함수 ｡+.ﾟ
SVariableX(Player,SVariable,Line,Section,Type,Value,Mask)
: 구조체 변수 전용 CtrigX 조건
Player : 구조체 변수의 플레이어 / SVariable : 조작할 CSVariable의 리턴값 입력

Section : 선택할 구조체 변수의 영역 : "EPD"(=0x158+0x40*i), "Value"(=0x15C+0x40*i),
"Type"(=0x160+0x40*i), "Mask"(=0x148+0x40*i), "Flag"(=0x164+0x40*i), "Next"(=0x4)
Line : 구조체 변수 내부의 조작할 변수 줄 수 (1~32 까지 입력 가능)
Type : 조건 연산자 - AtMost, Exactly, AtLeast
Value : 조건 연산값
Mask : eudx 비트마스크 (기본값 0xFFFFFFFF)
SetSVariableX(Player,SVariable,Line,Section,Type,Value,Mask)
: 구조체 변수 전용 CtrigX 액션
Player : 구조체 변수의 플레이어 / SVariable : 조작할 CSVariable의 리턴값 입력
Section : 선택할 구조체 변수의 영역 : "EPD"(=0x158+0x40*i), "Value"(=0x15C+0x40*i),
"Type"(=0x160+0x40*i), "Mask"(=0x148+0x40*i), "Flag"(=0x164+0x40*i), "Next"(=0x4)
Line : 구조체 변수 내부의 조작할 변수 줄 수 (1~32 까지 입력 가능)
Type : 액션 연산자 - Add, SetTo, Subtract
Value : 액션 연산값

Mask : eudx 비트마스크 (기본값 0xFFFFFFFF)
ex) [예제 23-4] 참고
SVariable(SVData,Section,Type,Value,Mask)
: SVariableX의 입력할 변수 정보를 변수 데이터로 입력받는 버전 / SVData에 SV()를 입력
SetSVariable(SVData,Section,Type,Value,Mask)
: SetSVariableX의 입력할 변수 정보를 변수 데이터로 입력받는 버전 / SVData에 SV()를 입력

158

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 구조체 변수 조작용 조건 및 액션 함수 ｡+.ﾟ
SVArrayX(SVArray,Section,Type,Value,Mask)
: 구조체 변수배열 상수인덱스 전용 CtrigX 조건
SVArray : 변수배열 헤더 (SVArray, GetSVArray 리턴값)

나머지는 SVariableX와 동일함
SetSVArrayX(SVArray,Section,Type,Value,Mask)
: 구조체 변수배열 상수인덱스 전용 CtrigX 액션
SVArray : 변수배열 헤더 (SVArray, GetSVArray 리턴값)
나머지는 SetSVariableX와 동일함
CSVar(Player,SVariable,Line,Type,Value,Mask)
: SVariableX에서 Section이 "Value"로 설정된 버전
모두 SVariableX와 동일함
SetCSVar(Player,SVariable,Line,Type,Value,Mask)
: SetSVariableX에서 Section이 "Value"로 설정된 버전
모두 SetSVariableX와 동일함

NSVar(SVData,Type,Value,Mask)
: CSVar의 입력할 변수 정보를 변수 데이터로 입력받는 버전 / SVData에 SV()를 입력
SetNSVar(SVData,Type,Value,Mask)
: SetCSVar의 입력할 변수 정보를 변수 데이터로 입력받는 버전 / SVData에 SV()를 입력
CSVAar(SVArray,Type,Value,Mask)
: SVArrayX에서 Section이 "Value"로 설정된 버전
모두 SVArrayX와 동일함
SetCSVAar(SVArray,Type,Value,Mask)
: SetSVArrayX에서 Section이 "Value"로 설정된 버전
모두 SetSVArrayX와 동일함
ex) [예제 23-4] 참고

159

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 구조체 변수 삽입형 조건 및 액션 함수 ｡+.ﾟ
TSVariableX(Player,SVariable,Line,Section,Type,Value,Mask)
TSetSVariableX(Player,SVariable,Line,Section,Type,Value,Mask)
TSVariable(SVData,Section,Type,Value,Mask)

TSetSVariable(SVData,Section,Type,Value,Mask)
TSVArrayX(SVArray,Section,Type,Value,Mask)
TSetSVArrayX(SVArray,Section,Type,Value,Mask)
: (Set)[SVariable/SVArray](X) 조건/액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Value, Mask (V(i) 입력)
TCSVar(Player,SVariable,Line,Type,Value,Mask)
TSetCSVar(Player,SVariable,Line,Type,Value,Mask)
TNSVar(SVData,Type,Value,Mask)
TSetNSVar(SVData,Type,Value,Mask)
TCSVAar(SVArray,Type,Value,Mask)
TSetCSVAar(SVArray,Type,Value,Mask)
: (Set)[C/N]S[Var/VAar] 조건/액션의 변수 삽입형 함수
변수 삽입 가능 항목 : Value, Mask (V(i) 입력)
Ex)[예제 23-5] 참고

160

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 구조체 변수 조작용 특수 조건 관련 함수｡+.ﾟ
TTSVariableX(Player,SVariable,Line,Section,Type,Value,Mask)
TTSVariable(SVData,Section,Type,Value,Mask)
TTSVArrayX(SVArray,Section,Type,Value,Mask)

: [SVariable/SVArray](X) 조건/액션의 특수조건/변수 삽입형 함수
변수 삽입 가능 항목 : Value, Mask (V(i) 입력)
TTCSVar(Player,SVariable,Line,Type,Value,Mask)
TTNSVar(SVData,Type,Value,Mask)
TTCSVAar(SVArray,Type,Value,Mask)
: (Set)[C/N]S[Var/VAar] 조건/액션의 특수조건/변수 삽입형 함수
변수 삽입 가능 항목 : Value, Mask (V(i) 입력)
Ex)[예제 23-6] 참고

161

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 구조체 함수 매크로형 최종 연산 함수｡+.ﾟ
SMov(PlayerID,Dest,Source,Mode,Deviation,Mask,Clear)
: 변수에서 값을 출력해서 대입함, Dest << Source + Deviation
PlayerID : 생성 트리거의 체크 플레이어

Dest : 결과값을 담을 대상
SV(SVA) / {X1/V1(VA1)/Mem1(A1), X2/V2(VA2)/Mem2(A2),…}, Line 미입력시 1~Number 까지로 입력됨

Source : 값을 읽어올 대상 (V(A)는 중복 입력 불가능)
SV(SVA) / {X1/V1(VA1), X2/V2(VA2),…}, Line 미입력시 1~Number 까지로 입력됨
Mode : 액션 연산자 - Add / SetTo / Subtract (기본값 SetTo, 숫자 입력시 기본값으로 설정, 배열입력 가능)
Deviation : 결과값의 편차 - Dest에 상수를 더함 (기본값 0, 숫자 입력시 기본값으로 설정, 배열입력 가능)

Mask : 값을 읽어올 범위 (기본값 0xFFFFFFFF, 숫자 입력시 기본값으로 설정, 배열입력 가능)
Clear : 자동 초기화 flag - 중간 연산자에서 사용 / Dest 전체 초기화가 필요할 때 1을 입력

ex) [예제 23-A] 참고
MovS(PlayerID,Dest,Source,Mode,Mask,Clear) ※ 내부함수
: 변수배열에 값을 대입하거나 변수배열의 값을 출력함, Dest << Source + Deviation
PlayerID : 생성 트리거의 체크 플레이어
Dest : 결과값을 담을 대상
Source : 값을 읽어올 대상
SV << SVA / SVA << SV

Mode : 액션 연산자 - Add / SetTo / Subtract
Mask : 값을 읽어올 범위 (기본값 0xFFFFFFFF)
Clear : 자동 초기화 flag - 중간 연산자에서 사용 / Dest 전체 초기화가 필요할 때 1을 입력

ex) [예제 23-B] 참고
TSMem(PlayerID,Dest,Source,Address,Next,OffsetFlag)
: Dest(V)에 Source(SV/SVA)의 주소값(epd/Offset)값을 저장함
PlayerID : 생성 트리거의 체크 플레이어

Dest : 주소값을 담을 변수 (V타입만 가능)
Source : 주소값을 읽어올 대상 (SV/SVA)
Address : 변수의 주소값(+0x0) + Address값 (기본값 0x15C)
Next : 변수의 Next
OffsetFlag : 비우면 EPD값을 반환 / 1 입력시 Offset값을 반환
ex) [예제 23-C] 참고

162

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 구조체 함수 매크로형 최종 연산 함수｡+.ﾟ
f_SDiff(PlayerID,Dest,Source,Mask,Time,Delay,Init)
: Dest에 Source의 Time 동안의 변화량 값을 구함, Dest << SV - prevSV → prevSV << SV
PlayerID : 생성 트리거의 체크 플레이어

Dest : 변화량을 담을 변수 (SV/SVA)
Source : 변화량을 측정할 대상 (SV/SVA)
Mask : 변화량을 읽어올 범위 (기본값 0xFFFFFFFF)
Time : 변화량을 측정할 주기 (Time ≤ 1일 경우 매 틱마다 측정)
Delay : 첫 실행시까지 대기할 시간
Init : 첫 실행 후 prevSV << SV 이전까지 변화량 측정값을 0으로 고정함
ex) [예제 23-D] 참고
SCast(PlayerID,Dest,Source,Deviation,Mask,Clear)
: 변수 타입을 변환함 (구조체 변수 SV(A) ↔ 32비트 변수 V(A))
PlayerID : 생성 트리거의 체크 플레이어
Dest : 타입변환 후의 변수
Source : 타입변환 전의 변수
V(A) → SV(A) / SV(A) → V(A) (Line에 복사할 값이 들어있는 줄 수를 입력)
Deviation : 결과값의 편차 - Dest에 상수를 더함

Mask : 값을 읽어올 범위 (기본값 0xFFFFFFFF)
Clear : 자동 초기화 flag - 중간 연산자에서 사용 / Dest 전체 초기화가 필요할 때 1을 입력

ex) [예제 23-E] 참고
SCopy(PlayerID,SVData,DestLine,SourceLine)
: 구조체 변수 내부의 변수 값을 다른 내부 변수에 복사시킴
PlayerID : 생성 트리거의 체크 플레이어
SVData : 값 증식을 실행할 구조체 변수 (SV/SVA)
DestLine : 값을 복사할 내부 변수의 줄 수
SourceLine : 복사할 값이 들어있는 내부 변수의 줄 수
DestLine = X → SourceLine = {A,B,C,…} / DestLine = {X,Y} → SourceLine = {{A,B,…},{a,b,…} 형식으로 입력

ex) [예제 23-F] 참고

163

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 구조체 함수 중간 연산자 관련 함수｡+.ﾟ
_SMov(Number,Source,Mode,Deviation,Mask)
: SMov의 중간 연산자 함수, SV << Source + Deviation
Number : 구조체 변수의 내부 변수의 개수 (1~16 까지 입력 가능) - Source의 갯수와 동일

Source : 값을 읽어올 대상
SV(SVA) / {X1/V1(VA1), X2/V2(VA2),…}
Mode : 액션 연산자 - Add / SetTo / Subtract (기본값 SetTo, 숫자 입력시 기본값으로 설정, 배열입력 가능)
Deviation : 결과값의 편차 - Dest에 상수를 더함 (기본값 0, 숫자 입력시 기본값으로 설정, 배열입력 가능)

Mask : 값을 읽어올 범위 (기본값 0xFFFFFFFF, 숫자 입력시 기본값으로 설정, 배열입력 가능)

_MovS(Number,Source,Mode,Mask) ※ 내부함수
: MovS의 중간 연산자 함수, SV << Source
Number : 구조체 변수의 내부 변수의 개수 (1~16 까지 입력 가능) - Source와 동일

Source : 연산할 값을 읽어올 대상 (SVA)
Mode : 액션 연산자 - Add / SetTo / Subtract
Mask : 대입 연산 비트마스크 (기본값 0xFFFFFFFF)
_TSMem(Source,Address,Next,OffsetFlag)
: TSMem의 중간 연산자 함수, V << 주소값(epd/Offset)
Source : 주소값을 읽어올 대상 (SV/SVA)
Address : 변수의 주소값(+0x0) + Address값 (기본값 0x15C)

Next : 변수의 Next
OffsetFlag : 비우면 EPD값을 반환 / 1 입력시 Offset값을 반환
_SCast(Source,Deviation,Mask)
: SCast의 중간 연산자 함수, SV(A) → V 전용
Source : 타입변환 전의 변수 (SV/SVA) - (Line에 복사할 값이 들어있는 줄 수를 입력)
Deviation : 결과값의 편차 - Dest에 상수를 더함
Mask : 값을 읽어올 범위 (기본값 0xFFFFFFFF)

_CastS(Number,Source,Deviation,Mask)
: SCast의 중간 연산자 함수, V(A) → SV 전용
Number : 구조체 변수의 내부 변수의 개수 (1~32 까지 입력 가능)
Source : 타입변환 전의 변수 (V/VA)
Deviation : 결과값의 편차 - Dest에 상수를 더함
Mask : 값을 읽어올 범위 (기본값 0xFFFFFFFF)
164

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 구조체 함수 중간 연산자 관련 함수｡+.ﾟ
_SCopy(SVData,DestLine,SourceLine)
: SCopy의 중간 연산자 함수
SVData : 값 증식을 실행할 구조체 변수 (SV/SVA)

DestLine : 값을 복사할 내부 변수의 줄 수
SourceLine : 복사할 값이 들어있는 내부 변수의 줄 수
DestLine = X → SourceLine = {A,B,C,…} / DestLine = {X,Y} → SourceLine = {{A,B,…},{a,b,…} 형식으로 입력

※ _SCopy는 임시변수 할당을 하지않고 입력값(SVData)을 직접 연산한 후 리턴함(SV)

165

------------------------------------------------------------------------------------------

『 24장 : 논리 조건 연산 함수 (_T) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ TTOR과 함께 사용할 수 없으며, TP()를 조건 입력칸 맨 바깥에 감싸야함 ｡+.ﾟ
_TP(...)
: 논리 조건 연산 함수를 사용하기 위한 조건 단락 입력 함수 (TTOR과 함께 사용 불가)
아래 논리 조건 연산 함수들을 트리거(CStruct조건)에 삽입 시 _TP()로 묶어서 입력
_TC(...)
: 일반 조건을 논리 조건 연산 함수로 변환함
입력칸에 입력할 일반 조건을 그대로 입력 (최대 1개 제한)
_TB(...)
: 여러 조건들을 한 Ctrigger로 묶어서 처리할 때 사용함 (최적화용)
입력칸에 묶을 조건들을 그대로 입력 (최대 16개 제한, _TB()는 입력 불가)
_TNOT(...)
: 조건에 Not 논리 연산을 수행함, Condition = ~조건
입력칸에 Not 논리 연산을 적용할 조건을 그대로 입력 (최대 1개 제한)
_TOR(...)
: 조건에 Or 논리 연산을 수행함, Condition = 조건1||조건2||…

입력칸에 Or 논리 연산을 적용할 조건을 그대로 입력 (개수 제한 없음)
_TAND(...)
: 조건에 And 논리 연산을 수행함, Condition = 조건1&&조건2&&…
입력칸에 And 논리 연산을 적용할 조건을 그대로 입력 (개수 제한 없음)
Ex) [예제 24-1] 참고
※ T/TT 조건의 경우 함수명 맨 앞에 _를 붙이면 논리 조건 연산 함수로 입력됨
※ 논리 조건 연산 함수의 중첩은 무제한이며, CStruct 함수의 조건에만 사용가능 함

166

------------------------------------------------------------------------------------------

『 25장 : 바이트 단위 R/W 함수 (byte) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 일반 스트링 단락(채팅인식, 칭호 등)에 사용을 권장함｡+.ﾟ
CbyteConvert(PlayerID,DestVA,Source)
: 상수 배열을 f_byte[cpy/cmp](X) 전용 데이터 배열로 변환 후 저장함
PlayerID : 생성 트리거의 체크 플레이어

DestVA : 변환된 데이터 배열을 저장할 변수배열(V(변수배열 헤더)/VA)
Source : 변환할 상수 배열 - {X,Y,Z,…} 형태로 저장
Ex) [예제 25-1] 참고
※ DestVA의 크기는 (Source의 크기+1)*4 이상이여야 합니다.
※ 상수 스트링을 Source에 입력시 GetStrSize, GetStrArr를 사용하여 편리하게 입력가능함
f_byteConvert(PlayerID,DestVA,Source,Size,Distance)
: 데이터 배열을 f_byte[cpy/cmp](X) 전용 데이터 배열로 변환 후 저장함
PlayerID : 생성 트리거의 체크 플레이어
DestVA : 변환된 데이터 배열을 저장할 변수배열(V(변수배열 헤더)/VA)
Source : 변환할 데이터 배열의 주소 (Offset) - (상수/V/VA/Mem)
Size : 변환할 데이터의 크기 - (상수/V/VA)
Distance : 읽어올 데이터 단락 간격의 크기 (기본값 4byte per 1epd)
※ DestVA의 크기는 (Size+1)*4 이상이여야 합니다.
Ex) [예제 25-2] 참고
f_byteConvertX(PlayerID,DestVA,Source,SourceX,Size,Distance)
: f_byteConvert에서 Source의 주소를 epd로 입력받는 버전 (최적화용)
PlayerID : 생성 트리거의 체크 플레이어
DestVA : 변환된 데이터 배열을 저장할 변수배열(V(변수배열 헤더)/VA)
Source : 변환할 데이터 배열의 주소 (epd) - (상수/V/VA/Mem)
SourceX : 변환할 데이터 배열의 주소의 편차값 (0~3) - (상수/V/VA)
Size : 변환할 데이터의 크기 - (상수/V/VA)
Distance : 읽어올 데이터 단락 간격의 크기 (기본값 4byte per 1epd)
Ex) [예제 25-4] 참고

167

------------------------------------------------------------------------------------------

『 25장 : 바이트 단위 R/W 함수 (byte) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 일반 스트링 단락(채팅인식, 칭호 등)에 사용을 권장함｡+.ﾟ
f_bytecpy(PlayerID,Dest,SourceVA,Size,Distance)
: f_byte 형식의 데이터 배열을 바이트 단위로 Dest에 Size만큼 복사함
PlayerID : 생성 트리거의 체크 플레이어

Dest : 데이터 배열을 복사할 곳의 주소 (Offset) - (상수/V/VA/Mem)
SourceVA : 복사할 f_byte 형식의 데이터를 저장한 변수배열(V(변수배열 헤더)/VA)
Size : 복사할 데이터의 크기 - (상수/V/VA)
Distance : 복사할 데이터 단락 간격의 크기 (기본값 4byte per 1epd)
Ex) [예제 25-1] 참고
f_bytecpyX(PlayerID,Dest,DestX,SourceVA,Size,Distance)
: f_bytecpy에서 Dest의 주소를 epd로 입력받는 버전 (최적화용)
Dest : 데이터 배열을 복사할 곳의 주소 (epd) - (상수/V/VA/Mem)
DestX : 데이터 배열을 복사할 곳의 주소의 편차값 (0~3) - (상수/V/VA)
나머지는 f_bytecpy와 동일함
f_bytecmp(PlayerID,CFlag,Dest,SourceVA,Size,Distance)
: f_byte 형식의 데이터 배열을 바이트 단위로 Dest에 Size만큼 비교함
PlayerID : 생성 트리거의 체크 플레이어

CFlag : 조건 연산의 결과값을 저장할 CFlag (Exactly 연산, CDeaths Ccode 입력 가능)
모두 일치할 경우 1, 하나라도 다를 경우 0을 CFlag에 반환함
Dest : 데이터 배열을 비교할 곳의 주소 (Offset) - (상수/V/VA/Mem)
SourceVA : 비교할 f_byte 형식의 데이터를 저장한 변수배열(V(변수배열 헤더)/VA)
Size : 비교할 데이터의 크기 - (상수/V/VA)
Distance : 비교할 데이터 단락 간격의 크기 (기본값 4byte per 1epd)
Ex) [예제 25-3] 참고
f_bytecmpX(PlayerID,CFlag,Dest,DestX,SourceVA,Size,Distance)
: f_bytecmp에서 Dest의 주소를 epd로 입력받는 버전 (최적화용)
Dest : 데이터 배열을 비교할 곳의 주소 (epd) - (상수/V/VA/Mem)
DestX : 데이터 배열을 비교할 곳의 주소의 편차값 (0~3) - (상수/V/VA)
나머지는 f_bytecmp와 동일함
※ CFlag에 {상수} 형식으로 값 입력시 조건 불만족시 CFlag의 값을 0으로 초기화 하지않음
168

------------------------------------------------------------------------------------------

『 25장 : 바이트 단위 R/W 함수 (byte) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 일반 스트링 단락(채팅인식, 칭호 등)에 사용을 권장함｡+.ﾟ
TTbytecmp(Dest,SourceVA,Size,Distance)
: f_bytecmp를 TT조건 형태로 만든 함수 (CFlag 자동 할당됨, CStruct 조건에서 사용가능)
f_bytecmp와 모두 동일하게 입력 / Ex) [예제 25-4] 참고
TTbytecmpX(Dest,DestX,SourceVA,Size,Distance)
: f_bytecmpX를 TT조건 형태로 만든 함수 (CFlag 자동 할당됨 , CStruct 조건에서 사용가능)
f_bytecmpX와 모두 동일하게 입력
Ex) [예제 25-3] 참고
_byteConvert(Source)
: CbyteConvert의 중간 연산자 함수 (임시 VA를 할당함)
Source : 변환할 상수 배열 - {X,Y,Z,…} 형태로 저장
※ Source의 크기가 너무 클 경우 임시 변수 할당제한에 걸릴 수도 있습니다.
Ex) [예제 25-1] 참고
_byteConvertF(Source,Size,Distance)
: f_byteConvert의 중간 연산자 함수 (임시 VA를 할당함)
Source : 변환할 데이터 배열의 주소 (Offset) - (상수/V/VA/Mem)

Size : 변환할 데이터의 크기 - (상수)
Distance : 읽어올 데이터 단락 간격의 크기 (기본값 4byte per 1epd)
※ Size의 크기가 너무 클 경우 임시 변수 할당제한에 걸릴 수도 있습니다.
Ex) [예제 25-4] 참고
_byteConvertFX(Source,SourceX,Size,Distance)
: f_byteConvertX의 중간 연산자 함수 (임시 VA를 할당함)
Source : 변환할 데이터 배열의 주소 (epd) - (상수/V/VA/Mem)
SourceX : 변환할 데이터 배열의 주소의 편차값 (0~3) - (상수/V/VA)
Size : 변환할 데이터의 크기 - (상수)
Distance : 읽어올 데이터 단락 간격의 크기 (기본값 4byte per 1epd)
※ Size의 크기가 너무 클 경우 임시 변수 할당제한에 걸릴 수도 있습니다.
※ X함수를 사용할 때 Source에 상수를 입력하는 경우 EPDF(Offset) 사용을 권장함
Ex) [예제 25-4] 참고

169

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ ISTR(이상 스트링)은 글자당 4바이트를 사용함 (컬러코드1+글자3) ｡+.ﾟ

GetiStrArr(cp949flag,String)
: 입력받은 스트링을 iStr로 변환하는 함수
Cp949flag : 0 입력시 utf8형식으로 변환, 1 입력시 cp949형식으로 변환
String : iStr로 변환할 스트링
리턴값 : 변환된 iStr 배열, 변환된 iStr의 길이
Ex) [예제 26-2] 참고

GetiStrSize(cp949flag,String)
: 입력받은 스트링을 iStr로 변환 후의 길이를 반환하는 함수
Cp949flag : 0 입력시 utf8형식으로 변환, 1 입력시 cp949형식으로 변환
String : iStr로 변환 후의 길이를 구할 스트링
리턴값 : 변환된 iStr의 길이
GetiStrId(PlayerId,String)
: 입력받은 스트링을 iStr로 변환 후 등록하는 함수 (STR단락 공간 할당용)
PlayerID : 생성되는 변수의 체크 플레이어
String : iStr로 변환 후 등록할 스트링

리턴값 : 해당 StrId에 할당된 IString 데이터 → IStrId 인자에 입력가능
Ex) [예제 26-1] 참고
※ iStrId 데이터 형식 = {iStr의 주소를 담은 변수(V), 할당받은 문자열의 StringId, iStr의 길이, 입력된 스트링}

SaveiStrArr(PlayerID,String,SVA32)
: 입력받은 스트링을 iStr로 변환 후 변수에 저장하는 함수
PlayerID : 생성되는 변수의 체크 플레이어
String : iStr로 변환 후 저장할 스트링
SVA32 : 비우면 SVA1타입으로 저장 (CAPrint), 1입력시 SVA32타입으로 저장 (CSPrint)

리턴값 : iStr이 저장된 변수, 변환된 iStr 배열, 변환된 iStr의 길이
Ex) [예제 26-1] 참고

SaveiStrptr(PlayerID,String,SVA32) - ＃STRCtrig 필수 & 반드시 CJump 사이에서만 사용해야함
: 입력받은 스트링을 iStr로 변환 후 변수에 저장하는 함수 (파일로 저장함)
나머지는 SaveiStrArr와 모두 동일함
Ex) [예제 26-2] 참고
※ GetiStrId는 Str(X)단락에 iStr 공간을 할당 및 초기화 할때 사용함 (IStrId 인자에 입력)
※ SaveiStr[Arr/ptr]은 iStr데이터를 변수에 저장할때 사용함 (CSPrint/CAPrint등에서 사용)

※ SaveiStrptr은 반드시 Tep 맨 위의 CJump(0) 사이에 넣어야 합니다. (변수 선언 함수와 동일함)

170

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ SVA32타입은 CSPrint전용 상수 스트링 저장 변수 (트리거당 32글자)｡+.ﾟ

CreateSVA32(iStrArr,Size,PlayerID)
: 입력받은 iStr을 SVA32 변수에 저장하는 함수
iStrArr : 변수에 저장할 iStr 배열 (GetiStrArr등의 함수로 변환된 iStr배열을 입력)
Size : 변수에 저장할 iStr의 길이 (GetiStr[Arr/Size]등의 함수로 구한 iStr길이를 입력)
PlayerID : 생성되는 변수의 체크 플레이어
리턴값 : iStr이 저장된 변수
Ex) [예제 26-2] 참고

MakeiStrVoid(Size,flag)
: 공백문자(0xD)로 채워진 스트링을 만드는 함수 (리턴값은 배열이 아닌 string타입)
Size : 만들 문자열의 길이
Flag : 비우면 Str타입으로, 1입력시 iStr타입으로 스트링을 만듦
Ex) [예제 26-1] 참고

MakeiStrLetter(Letter,Size,flag)
: 특정 글자로 채워진 스트링을 만드는 함수 (리턴값은 배열이 아닌 string타입)
Letter : 문자열을 채울 글자 (컬러코드+1글자)
Size : 만들 문자열의 길이
Flag : 비우면 Str타입으로, 1입력시 iStr타입으로 스트링을 만듦
Ex) [예제 26-1] 참고

MakeiStrWord(String,Size)
: 특정 문자열로 채워진 스트링을 만드는 함수 (리턴값은 배열이 아닌 string타입)
String : 문자열을 채울 문자 (입력한 문자열을 Size만큼 반복해서 채움, Str타입으로 리턴)
Size : 만들 문자열의 길이
Ex) [예제 26-2] 참고

FixText(PlayerID,Preset)
: 출력된 텍스트의 위치를 고정시키는 함수 (맨 위에서부터 순서대로 고정됨)
PlayerID : 생성 트리거의 체크 플레이어
Preset : 1입력시 현재 텍스트의 위치를 고정함, 2입력시 저장했던 텍스트의 위치를 불러옴
(FixText(PlayerID,1) ~ 텍스트 입력 ~ FixText(PlayerID,2) 형식으로 사용함)
Ex) [예제 26-2] 참고
※ FixText는 Aret(공용변수)에 위치값을 저장하며, CSPrint등의 FixText에서도 Aret을 사용함
171

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CSPrint는 단순 추가스트링 출력용으로 사용하는 함수 (Ctext, DisplayExtText)｡+.ﾟ

CSPrint(iStrid,SVA32,DisplayPlayer,FixText,PlayerID,Condition,CpAction,Action,Preserve)
: SVA32에 저장된 iStr을 출력하는 함수 (iStrId에 SVA32의 iStr을 덮어씀)
iStrid : 텍스트를 출력하는데 사용할 iStrId (GetiStrId의 리턴값 입력)
SVA32 : 출력할 텍스트가 저장된 변수 (SaveiStr[Arr/ptr]의 리턴값 입력, SVA32타입 변수전용)
DisplayPlayer : 텍스트를 출력할 플레이어 (CopyCpActionX의 Player와 동일)
FixText : 1입력시 현재 텍스트의 위치를 고정함, 2입력시 저장했던 텍스트의 위치를 불러옴
3입력시 CSPrint의 텍스트의 위치를 고정함(1+2입력과 동일), 0 입력시 사용안함
PlayerID : 생성 트리거의 체크 플레이어
Condition : 트리거의 조건
CpAction : 각 플레이어에게 사용할 액션 (CopyCpActionX의 CpAction과 동일)
Action : 생성할때마다 실행할 액션
Preserve : 트리거에 Preserve 옵션을 넣을지의 여부 (1입력시 적용, 비우면 적용안함)
Ex) [예제 26-1] 참고
※ DisplayPlayer를 비우면 CpActions를 실행하지않음 (iStrId에 순수 덮어쓰기용으로 사용)

f_GetiStrptr(PlayerID,Output,StringId)
: StringId에 해당하는 스트링의 Offset을 Output에 저장하는 함수
(StartCtrig의 STRX옵션에 따라 STR단락 또는 STRX단락 전용 함수를 선택함)
PlayerID : 생성 트리거의 체크 플레이어
StringId : 선택한 스트링의 Id (상수/변수/VA) - 스트링의 내용을 직접 작성해서 입력할수도 있음 ("스트링1")

Output : 스트링의 Offset을 담을 대상 (변수/VA/Offset/A/Mem)
리턴값 : 입력한 문자열의 String Id (StringId가 상수일때)
f_GetiStrXepd(PlayerID,Output,StringId)
: StringId에 해당하는 스트링의 EPD를 Output에 저장하는 함수
(STRX단락 전용 - euddraft 0.8.9.0 이후버전 사용시 사용가능, StartCtrig에서 STRX옵션 선택필수)

PlayerID : 생성 트리거의 체크 플레이어
StringId : 선택한 스트링의 Id (상수/변수/VA) - 스트링의 내용을 직접 작성해서 입력할수도 있음 ("스트링1")

Output : 스트링의 EPD를 담을 대상 (변수/VA/Offset/A/Mem)
리턴값 : 입력한 문자열의 String Id (StringId가 상수일때)
172

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ SVA1타입은 CAPrint전용 변수 스트링 저장 변수 (트리거당 1글자) ｡+.ﾟ

CreateSVA1(iStrArr,Size,PlayerID)
: 입력받은 iStr을 SVA1 변수에 저장하는 함수
iStrArr : 변수에 저장할 iStr 배열 (GetiStrArr등의 함수로 변환된 iStr배열을 입력)
Size : 변수에 저장할 iStr의 길이 (GetiStr[Arr/Size]등의 함수로 구한 iStr길이를 입력)
PlayerID : 생성되는 변수의 체크 플레이어
리턴값 : iStr이 저장된 변수
Ex) [예제 26-3] 참고
SVA1(SVA1,Index)
: SVA1타입 변수 정보를 입력하는 함수 (주로 CA__함수 등에서 사용)
SVA1 : 정보를 입력할 SVA1타입 변수

Index : SVA1배열의 인덱스 : 상수 or V 입력가능 (각각 V, VA타입으로 변환됨)
Ex) [예제 26-3] 참고
※ SVA1변수(배열)은 V(A)와 구조가 다르므로 SVA1함수 사용시 반드시 값 입력 용도로만 사용해야함 (출력X)
※ SVA1의 Index에 V를 넣어 VA타입으로 변환시 반드시 Index는 604의 배수여야함

TSVA1Mem(PlayerID,Dest,SVA1,Address,OffsetFlag)
: Dest(V)에 Source(SVA1)의 주소값(epd/Offset)값을 저장함
PlayerID : 생성 트리거의 체크 플레이어
Dest : 주소값을 담을 변수 (V)
SVA1 : 주소값을 읽어올 대상(SVA1) ← SVA1함수 사용으로 입력
Address : 변수의 주소값(+0x0) + Address값 (비우면 0x15C)
OffsetFlag : 비우면 EPD값을 반환 / 1 입력시 Offset값을 반환

MakeiStrData(Letter,Fill)
: 입력한 문자의 헥스값을 구하는 함수
Letter : 헥스값을 구할 문자 (한 글자만 입력해야함, 컬러코드 포함 가능)
Fill : 1입력시 빈칸을 0xD로 채움 (1바이트 단위로 0x00 → 0x0D로 변경, 비우면 적용X)
Ex) [예제 26-14] 참고

MakeiStrDiff(Start,End)
: 입력한 문자들의 헥스값의 차를 구하는 함수
Start : 헥스값을 구할 문자 (한 글자만 입력해야함, 시작문자)
End : 헥스값을 구할 문자 (한 글자만 입력해야함, 도착문자) → End - Start의 값을 리턴함
Ex) [예제 26-16] 참고
※ MakeiStrData, MakeiStrDiff는 주로 CA__ConvertLetter에서 사용됨 (ConvertData 입력시 사용)

173

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ (Set)(T/TT)CSVA1 조건/액션은 모두 SVA1의 값(0x15C)부분을 대상으로 함｡+.ﾟ
CSVA1(SVA1,Type,Value,Mask)
: SVA1타입 변수 전용 CtrigX 조건
SVA1 : SVA1타입 변수 (SVA1 함수 사용만 가능, Index 상수 입력)
Type : 조건 연산자 - AtMost, Exactly, AtLeast
Value : 조건 연산값 / Mask : eudx 비트마스크 (기본값 0xFFFFFFFF)
SetCSVA1(SVA1,Type,Value,Mask)
: SVA1타입 변수 전용 SetCtrig1X 액션
SVA1 : SVA1타입 변수 (SVA1 함수 사용만 가능, Index 상수 입력)
Type : 액션 연산자 - Add, SetTo, Subtract
Value : 액션 연산값 / Mask : eudx 비트마스크 (기본값 0xFFFFFFFF)

ex) [예제 26-32] 참고
TCSVA1(SVA1,Type,Value,Mask)
TSetCSVA1(SVA1,Type,Value,Mask)
: (Set)CSVA1 조건/액션의 변수 삽입형 함수

변수 삽입 가능 항목 : SVA1의 Index, Value, Mask
TTCSVA1(SVA1,Type,Value,Mask)
: CSVA1 조건의 특수조건/변수 삽입형 함수
변수 삽입 가능 항목 : SVA1의 Index, Value, Mask
※ TTCSVA1에서 Type에 입력 가능한 값 : NotSame("!="), Above(">"), Below("<")

174

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CAPrint는 변수 스트링 출력 함수로, 부가효과 함수(CA__)를 CAfunc 내부에서 사용가능함 ｡+.ﾟ

CAPrint(iStrid,DisplayPlayer,Preset,CAfunc,PlayerID,Condition,PerAction,CpAction,Action)
: iStr 데이터를 실시간 변수 스트링 출력 트리거로 변환하는 함수 (변수 삽입 가능)
iStrid : 텍스트를 출력하는데 사용할 iStrId (GetiStrId의 리턴값 입력)
DisplayPlayer : 텍스트를 출력할 플레이어 (CopyCpActionX의 Player와 동일)
Preset : = {CA[1],CA[2],CA[3],CA[4],CA[5],CA[6],CA[7],CA[8]}
각각의 자리에 nil, 숫자, V(변수) 삽입 가능 (변수 삽입시 CAPrint 트리거 앞에서 CA[_] << V 연산이 실행됨)

CAfunc : CAPrint 함수 내부에 삽입할 사용자 정의 코드를 입력함 (nil 입력시 사용X)
(함수 이름 (String) 입력시 함수 내부 코드를 CAPlot 내부에서 실행시킴)
PlayerID : 생성 트리거의 체크 플레이어
Condition : 트리거의 조건
PerAction : 생성할때마다 실행할 액션 (CDoActionsX 형식으로 입력)
CpAction : 각 플레이어에게 사용할 액션 (CopyCpActionX의 CpAction과 동일)
Action : 생성할때마다 실행할 액션
CA : (= CAPrintDataArr) : 1st CAPrint 전용 내부 변수 총 8개
CB : (= CAPrintCreateArr) : 2nd CAPrint 전용 내부변수 총 4개
PlayerID : (=CAPrintPlayerID) : CAPrint 전용 트리거 플레이어
CA[1] = 출력할 String Id 선택 (k 입력시 k번 iStrid 데이터로 초기화 후 0으로 변경됨)
CA[2] = 남은 대기 시간 (Tick 단위 / 0일때 CAFunc 실행)
CA[3] = CAFunc 대기시간 증가량 (Tick 단위/ k입력시 1회 루프후 대기시간 k추가)
CA[4] = 루프 카운터 (트리거 순환당 루프 수를 카운트함)
CA[5] = 루프 리미트 (트리거 순환당 CAFunc 실행할 횟수/ k입력시 CA[4] : 0~k-1까지 루프함)
CA[6] = FixText (0 : 사용안함, 1 : 현재 텍스트 위치고정, 2 : 텍스트 위치 불러오기, 3 : 1+2)
CA[7] = 텍스트 출력 딜레이 (Tick 단위 / 0일때 텍스트 출력)
CA[8] = 텍스트 출력 대기시간 증가량 (Tick 단위/ k입력시 1회 루프후 대기시간 k추가)
CB[1] = 선택된 iStrid의 시작 주소의 EPD (CA[1] 변경시 갱신됨)
CB[2] = 선택된 iStrid의 iStr Size (스트링 단락에 할당받은 공간의 크기, CA[1] 변경시 갱신됨)
CB[3] = 선택된 iStrid의 String Id (CA[1] 변경시 갱신됨)
CB[4] = 텍스트 출력 스위치 (0이 아닐경우 텍스트의 출력을 차단함)

Ex) [예제 26-10] 참고
※ CAfunc 내부 코드를 작성할때 CAPrint 내부 변수를 가져오려면
local PlayerID = CAPrintPlayerID
local CA = CAPrintDataArr
local CB = CAPrintCreateArr
를 함수 맨 위에 붙여넣으면 된다.

175

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ ※ CA__ 함수는 CAPrint 내부에서 스트링 데이터를 실시간으로 연산 할 수 있습니다 ｡+.ﾟ
CA__InputVA(Index,SVA1,Size,Mask,Start,End,SourceDistance)

: SVA1에 저장된 iStr을 iStrid에 복사하는 함수
Index : iStr에 복사할 시작점 (글자단위, 상수/V)
SVA1 : 복사할 iStr이 담긴 SVA1타입 변수 (SVA1함수 사용, 미사용 모두 가능)
Size : 복사할 글자의 개수 (상수/V)
Mask : 복사할 범위 (비트마스크, 비우면 SVA1이 가진 Mask대로 복사함)
Start : iStr에 복사할 범위의 최솟값 (상수/V) → Start미만 범위는 복사 안됨
End : iStr에 복사할 범위의 최댓값 (상수/V) → End초과 범위는 복사 안됨
SourceDistance : SVA1 복사 간격 (n입력시 1→n+1→2n+1순으로 간격을 두면서 복사함)
Ex) [예제 26-3] 참고
CA__InputSVA1(Dest,Source,Size,Mask,Start,End,Next,DestDistance,SourceDistance)
: SVA1에 저장된 iStr을 SVA1에 복사하는 함수
Dest : 복사된 iStr을 담을 SVA1타입 변수 (SVA1함수 사용, 미사용 모두 가능)
Source : 복사할 iStr이 담긴 SVA1타입 변수 (SVA1함수 사용, 미사용 모두 가능)
Size : 복사할 글자의 개수 (상수/V)
Mask : 복사할 범위 (비트마스크, 비우면 Source가 가진 Mask대로 복사함)
Start : SVA1에 복사할 범위의 최솟값 (상수/V) → Start미만 범위는 복사 안됨, V삽입시 604의 배수로 입력
End : SVA1에 복사할 범위의 최댓값 (상수/V) → End초과 범위는 복사 안됨, V삽입시 604의 배수로 입력

Next : SVA1의 Next값이 604의 배수일때 1을 입력 (CA__SetNext,CA__MoveXY로 Next값 604의 배수로 변경시 1입력 필수)
DestDistance : Dest 붙임 간격 (n입력시 1→n+1→2n+1순으로 간격을 두면서 Dest에 붙여넣음)
SourceDistance : Source 복사 간격 (n입력시 1→n+1→2n+1순으로 간격을 두면서 Source에서 복사함)
Ex) [예제 26-4] 참고
CA__InputSVA1X(Dest,Source,Size,Mask,DestMask,Start,End,Next,DestDistance,SourceDistance)
: SVA1에 저장된 iStr을 SVA1에 복사하는 함수 (DestMask를 Dest의 Mask에 함께 복사함)
DestMask : Dest의 Mask에 복사할 비트마스크 (Dest에서 실제로 값이 복사된 부분만 Mask도 함께 복사됨)
나머지는 CA__InputSVA1과 모두 동일함 (Path데이터용 SVA1에 텍스트를 복사할때 사용함)
Ex) [예제 26-9] 참고
※ CA__InputSVA1(X)는 무한 중첩이 가능하며, 최종적으로 CA__InputVA를 통해 IStrid에 SVA1의 값을 복사하게됨
※ Mask가 nil일 경우 Source의 Mask가 1이상일때만 Dest에 값을 복사함

CA__OverWrite(SVA32,Index,Null,Preserve)
: SVA32에 저장된 iStr을 iStrid에 복사하는 함수
SVA32 : 복사할 iStr이 담긴 SVA32타입 변수
Index : iStr에 복사할 시작점 (글자단위, 상수/V)
Null : SVA32 스트링 삽입후 0x0(Null) 삽입여부 (1 입력시 삽입함, 비우면 삽입X)
Preserve : 0입력시 1번만 실행함, 비우면 Preserved 상태로 생성
Ex) [예제 26-5] 참고

176

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

CA__Input(Input,SVA1,Mask)

: SVA1의 값을 변경하는 함수
Input : SVA1에 복사할 값 (상수/V)
SVA1 : 값을 변경할 SVA1타입 변수 (SVA1함수 사용, 미사용 모두 가능) → Index를 SVA1함수로 입력
Mask : 복사할 범위 (비트마스크, 비우면 0xFFFF00FF로 입력됨)
Ex) [예제 26-6] 참고
CA__SetMask(SVA1,Mask,Start,End,Preserve)
: SVA1의 Mask를 변경하는 함수
SVA1 : Mask 값을 변경할 SVA1타입 변수 (SVA1함수 미사용만 가능)
Mask : SVA1의 Mask에 복사할 값 (상수, 비우면 0xFFFF00FF로 입력됨)
Start : SVA1 복사 시작지점 (상수/V) → V삽입시 604의 배수로 입력
End : SVA1 복사 종결지점 (상수/V) → V삽입시 604의 배수로 입력, SVA1의 Start~End범위의 Mask를 변경함
Preserve : (Start, End가 모두 상수일때만 적용됨) 0입력시 1번만 실행함, 비우면 Preserved 상태로 생성
Ex) [예제 26-7] 참고
CA__SetNext(SVA1,DestDistance,Mode,Start,End,Preserve)
: SVA1의 Next(다음 글자를 복사할 위치, 기본값 1)를 변경하는 함수
SVA1 : Next 값을 변경할 SVA1타입 변수 (SVA1함수 미사용만 가능)
DestDistance : SVA1의 Next에 복사할 값 (상수/V)

Mode : Next 연산자 (Add, Subtract, SetTo 중 선택, 비우면 SetTo로 입력)
Start : SVA1 복사 시작지점 (상수/V) → V삽입시 604의 배수로 입력
End : SVA1 복사 종결지점 (상수/V) → V삽입시 604의 배수로 입력, SVA1의 Start~End범위의 Mask를 변경함
Preserve : (Start, End가 모두 상수일때만 적용됨) 0입력시 1번만 실행함, 비우면 Preserved 상태로 생성
Ex) [예제 26-8] 참고
※ DestDistance : SVA1→iStrid : Next = (복사간격) (InputVA), SVA1→SVA1 : Next = (복사간격)*604 (InputSVA1(X))

CA__MoveXY(SVA1,Line,Mul,Mode,Fix,PathData,Preserve)
: SVA1의 Next를 변경하여 다음글자 복사위치를 상하좌우로 움직이는 함수
SVA1 : 값을 변경할 SVA1타입 변수 (SVA1함수 미사용만 가능)
Line : 텍스트 한 줄의 길이 (상수, \n을 포함)
Mul : 1입력시 PathData의 상수값에 604를 곱함 (비우면 적용X, SVA1→SVA1 사용시 적용 필수)
Mode : Next 연산자 (Add, Subtract, SetTo 중 선택, 비우면 Add로 입력)
Fix : 1입력시 X,Y,XY에 상수만 입력가능하며, Next에 절대 위치값을 복사함 (입력한 순서대로 누적해서 연산함)
PathData : Next를 변경할 위치데이터 입력 → {변경할 Index(상수/V),X(상수),Y(상수)}
또는 {변경할 Index(상수/V),XY(상수/V)} 형태로 입력 (변경할 Index에 V삽입시 604의 배수로 입력)
Preserve : 0입력시 1번만 실행함, 비우면 Preserved 상태로 생성
리턴값 : (Fix에 1입력시 해당) Next 실제 변경값 배열 (PushValueMsg로 값 확인가능) / Ex) [예제 26-9] 참고

※ CA__MoveXY는 가로 길이가 일정한 1줄 이상의 텍스트를 대상으로 함 (Line = 한 줄의 글자 개수)
※ SVA1의 Next값은 1이 기본값(바로 오른쪽칸)이며, Y*Line+X꼴로 변경가능 (0 또는 음수도 가능)
177입력)
※ SVA1→SVA1 사용시 PathData의 X,Y,XY에 V를 입력할 경우 604의 배수로 입력 (SVA1→iStrid의 경우 1의 배수로

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CA__ 함수는 CAPrint 내부에서 스트링 데이터를 실시간으로 연산 할 수 있습니다 ｡+.ﾟ
CA__SetValue(SVA1,String,Mask,Index,Preserve,utf8flag)
: SVA1에 스트링을 복사하는 함수 (String입력으로 iStr으로 저장)
SVA1 : 값을 변경할 SVA1타입 변수 (SVA1함수 미사용만 가능)
String : SVA1에 복사할 스트링 (String타입으로 입력)
Mask : 복사할 범위 (비트마스크, 비우면 0xFFFF00FF로 입력됨)
Index : SVA1 복사 시작지점 (상수/V) → V삽입시 604의 배수로 입력
Preserve : 0입력시 1번만 실행함, 비우면 Preserved 상태로 생성
Ex) [예제 26-11] 참고
※ CA__SetValue에서 String의 길이는 SVA1의 Index~끝까지의 크기보다 작아야함
CA__Mov(SVA1,Output,Mask,RecoverMask)
: SVA1의 값을 Output에 복사하는 함수 (Output << SVA1)
SVA1 : 값을 복사할 SVA1타입 변수 (SVA1함수 사용, 미사용 모두 가능) → Index를 SVA1함수로 입력
Output : SVA1의 값을 담을 곳 (상수/V/Mem)
Mask : 복사할 범위 (비트마스크, 비우면 0xFFFFFFFF로 입력됨)
RecoverMask : 복사 후 SVA1의 Mask에 복구할 값 (비트마스크, 비우면 0xFFFF00FF로 입력됨)
Ex) [예제 26-12] 참고
CA__Movcpy(SVA1,Output,Size,Mask,RecoverMask,DestDistance)
: SVA1의 값을 Output에 Size개 만큼 복사하는 함수 (Output << SVA1)
SVA1 : 값을 복사할 SVA1타입 변수 (SVA1함수 사용, 미사용 모두 가능) → Index를 SVA1함수로 입력
Output : SVA1의 값을 담을 곳 (상수/V/Mem)
Size : 복사할 글자의 개수 (상수/V, 글자 1개당 4바이트씩 복사함)
Mask : 복사할 범위 (비트마스크, 비우면 0xFFFFFFFF로 입력됨)
RecoverMask : 복사 후 SVA1의 Mask에 복구할 값 (비트마스크, 비우면 0xFFFF00FF로 입력됨)
DestDistance : Output 붙임 간격 (n입력시 1→n+1→2n+1순으로 간격을 두면서 Output에 붙여넣음)

Ex) [예제 26-12] 참고
※ CA_Mov(cpy)함수에서 Index가 해당 SVA1의 범위를 벗어날 경우 오류발생 (0~SVA1의 크기-1까지만 입력)
CA__Read(Index,Output,Mask)
: iStrid의 Index번째 글자를 Output에 읽어오는 함수
Index : iStr에서 읽어올 글자의 위치 (글자단위, 상수/V)
Output : 읽어온 글자의 값을 담을 곳 (상수/V/Mem/A/VA)
Mask : 복사할 범위 (비트마스크, 비우면 0xFFFFFFFF로 입력됨)
Ex) [예제 26-13] 참고
178

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CA__ 함수는 CAPrint 내부에서 스트링 데이터를 실시간으로 연산 할 수 있습니다 ｡+.ﾟ
CA__ReadX(Index,Output,Multiplier,Mask)
: iStrid의 Index번째 글자를 Output에 읽어오는 함수 (*Multiplier)
Index : iStr에서 읽어올 글자의 위치 (글자단위, 상수/V)
Output : 읽어온 글자의 값을 담을 곳 (상수/V/Mem/A/VA)
Multiplier : 읽어온 값에 곱할 상수값 ("-3","-2","-1","0","+1","+2","+3", 각각 *256^n)
Mask : 복사할 범위 (비트마스크, 비우면 0xFFFFFFFF로 입력됨)
Ex) [예제 26-13] 참고
CA__SetMemoryX(index,Value,Mask,utf8flag)
: iStrid의 Index번째 글자에 Value값을 복사하는 함수

Index : iStr에 값을 복사할 글자의 위치 (글자단위, 상수/V)
Value : 복사할 값 (상수/V/스트링)
Mask : 복사할 범위 (비트마스크, 비우면 0xFFFF00FF로 입력됨)
Ex) [예제 26-14] 참고
※ MakeiStrData로 값 입력시 Fill에 1을 입력해야함 (값에 0x00 존재시 텍스트 잘림)
CA__SetColor(index,ColorCode)
: iStrid의 Index번째 글자에 컬러코드 값을 변경하는 함수
Index : iStr에 값을 복사할 글자의 위치 (글자단위, 상수/V)
ColorCode : 글자에 넣을 컬러코드 (상수/V)
Ex) [예제 26-14] 참고
※ iStr에서 컬러코드는 일반적으로 +0x0부분에 위치하며, CA__SetColor는 Mask가 0xFF로 설정됨
CA__SetLetter(index,Letter,utf8flag)
: iStrid의 Index번째 글자를 변경하는 함수 (컬러코드 제외)
Index : iStr에 값을 복사할 글자의 위치 (글자단위, 상수/V)
Letter : 해당 위치에 넣을 글자값 (상수/V/스트링)
Ex) [예제 26-14] 참고
※ iStr에서 글자값은 일반적으로 +0x2~+0x3부분에 위치하며, CA__SetLetter은 Mask가 0xFFFF0000로 설정됨

CA__Encode(Dest,Source,Size,cp949flag) - ＃STRCtrig 필수
: SVA1의 글자를 인코딩하는 함수 (cp949 ↔ utf8, iStr형식)
Dest : 인코딩 한 글자를 저장할 SVA1타입 변수 (SVA1함수 미사용, 사용 모두 가능)
Source : 인코딩 할 글자가 저장된 SVA1타입 변수 (SVA1함수 미사용, 사용 모두 가능)
Size : 인코딩할 글자의 수 (상수/V)
Cp949flag : 1입력시 iutf8 → icp949로 (CD,C13→CA,CB), 0입력시 icp949 → iutf8로 인코딩함 (CA,CB→CD,C13)

Ex) [예제 26-41] 참고
※ iStr cp949 : +0x0 = 컬러코드, +0x1 = 빈칸(0xD), +0x2~+0x3 = 문자 (Mask 기본값 0xFFFF00FF)
iStr utf8 : +0x0 = 컬러코드, +0x1~+0x3 = 문자 (Mask 기본값 0xFFFFFFFF)
※ CA__Encode의 결과는 0xFFFFFFFF 범위 전체를 인코딩 후 Dest에 복사함

179

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CA__ 함수는 CAPrint 내부에서 스트링 데이터를 실시간으로 연산 할 수 있습니다 ｡+.ﾟ
CA__ConvertColor(SVA1,ConvertData,MaskData,Start,End)
: SVA1의 컬러코드를 변환하는 함수
SVA1 : 컬러코드를 변환할 SVA1타입 변수 (SVA1함수 미사용만 가능)
ConvertData : 컬러코드를 변경할 변환데이터 입력 → {A(상수/V),B(상수/V)} (컬러코드 A를 B로 변환함)
{A,B,{C(상수/V/스트링),Mask(상수)}) 형태로 입력시 (해당글자의 헥스값,Exactly,C,Mask)의 조건을 추가함
MaskData : {조건 Mask, 액션 Mask, 연산자} 형태로 입력 (변환 조건과 변환 액션에 Mask를 적용함,
비우면 0xFF으로 적용/액션의 연산자는 Add, SetTo, Subtract중 선택, 비우면 SetTo로 입력)
Start : SVA1 변환 시작지점 (상수/V) → V삽입시 604의 배수로 입력
End : SVA1 변환 종결지점 (상수/V) → V삽입시 604의 배수로 입력, SVA1의 Start~End범위의 컬러코드를 변환함

Ex) [예제 26-15] 참고
CA__ConvertLetter(SVA1,ConvertData,MaskData,Start,End,utf8flag)
: SVA1의 글자를 변환하는 함수
SVA1 : 글자를 변환할 SVA1타입 변수 (SVA1함수 미사용만 가능)
ConvertData : 글자를 변경할 변환데이터 입력 → {A(상수/V/스트링),B(상수/V/스트링)} (문자 A를 B로 변환함)
{A,B,{C(상수/V/스트링),Mask(상수)} 형태로 입력시 (해당글자의 헥스값,Exactly,C,Mask)의 조건을 추가함
{{A(상수/V/스트링),B(상수/V/스트링)},상수/V/{C(스트링),D(스트링)}}
(문자 A~B에 +상수/+V/+D-C값을 더해서 변환시킴)
{{A,B},상수/V/{C,D},{E,Mask}} 형태로 입력시 (해당글자의 헥스값,Exactly,E,Mask)의 조건을 추가함
{{A,B},{C,D},Mask} 형태로 입력시 (해당글자의 헥스값,Exactly,A,Mask)의 조건을 추가함
MaskData : {조건 Mask, 액션 Mask, 연산자} 형태로 입력 (변환 조건과 변환 액션에 Mask를 적용함,
비우면 0xFFFF0000으로 적용/액션의 연산자는 Add, SetTo, Subtract중 선택, 비우면 Add(A→B변환시 SetTo)로 입력)

Start : SVA1 변환 시작지점 (상수/V) → V삽입시 604의 배수로 입력
End : SVA1 변환 종결지점 (상수/V) → V삽입시 604의 배수로 입력, SVA1의 Start~End범위의 글자를 변경함
Ex) [예제 26-16] 참고
※ ConvertData는 글자당 한번만 변환을 실행함 (해당 글자에서 변환이 이루어지면 바로 다음글자로 넘어감)

※ ConvertLetter에서 ConvertData입력시 A와 B의 헥스값은 항상 A≤B여야함
CA__ItoName(SVA1,TargetPlayer,Output,Init,ColorArr,FullWidth,utf8flag)
: SVA1에 플레이어의 아이디를 iStr타입으로 출력하는 함수
SVA1 : iStr타입으로 변환된 변수 스트링을 저장할 SVA1타입 변수(SVA1함수 사용(상수Index만), 미사용 모두 가능)
TargetPlayer : 변환할 플레이어 (0~7중 선택 또는 "Host"입력, "Host" 입력시 방장의 아이디를 출력함)
Output : 변환된 iStr의 자릿수를 저장할 변수 (V)
Init : 초기화 문자 표시 방법 선택 (문자 입력시 해당 문자로 표시함, 비우면 0xD로 입력)
ColorArr : 컬러코드 추가 (비우면 적용X, 숫자 맨 앞부터 적용, 0x0입력시 적용X)
FullWidth : 전각 문자 표시 옵션 (비우면 적용X, 1입력시 전각문자로 출력함) / Ex) [예제 26-17] 참고

180

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CA__ 함수는 CAPrint 내부에서 스트링 데이터를 실시간으로 연산 할 수 있습니다 ｡+.ﾟ
CA__ItoCustom(SVA1,Input,Output,Mask,Base,Length,Init,Sign,ColorArr,IndexArr,DataArr,ClearArr,utf8flag)
: SVA1에 4바이트 변수를 iStr타입으로 출력하는 함수
SVA1 : iStr타입으로 변환된 변수 스트링을 저장할 SVA1타입 변수 (SVA1함수 사용(상수Index만), 미사용 모두 가능)
Input : 변환할 4바이트 변수 (V)
Output : 변환된 iStr의 자릿수를 저장할 변수 (V) → 변환된 최대 자릿수의 위치를 반환함
Mask : 복사할 범위 (비트마스크, 비우면 0xFFFF00FF로 입력됨)
Base : 변수를 출력할 진법 (2~2^32중 선택, 배열로 입력시 {진법, 최대 자릿수} 형태로 입력됨)
Length : 자릿수당 문자의 길이 (비우면 1로 입력, Init과 ColorArr,DataArr,IndexArr가 모두 같은 길이여야함)
Init : 초기화 문자 표시 방법 선택 (비우면 0xD로 입력, 문자(2글자이상 가능) 입력시 해당 문자로 표시함)

{문자열A,문자열B,….} 형식으로 입력시 1번째 문자 자리부터 초기화 문자열이 앞쪽 순서대로 적용됨
Sign : 부호 표시 여부 (비우면 표시X, 스트링 입력시 0일때 표시문자로 입력됨 (2글자이상 입력가능)
→ {+기호 표시 문자 -기호 표시 문자, 0일때 표시 문자} 형식으로 입력 (2글자이상 입력가능)
비우거나 스트링입력시 Unsigned로, 배열로 입력시 Signed로 출력함
ColorArr : 컬러코드 추가 (비우면 적용X, 숫자 맨 앞부터 적용, 0입력시 적용X, DataArr가 있다면 덮어씌워짐)
{0(미적용)/상수/{A(0/상수),B(0/상수)} 꼴로 입력함 (Init자리 위에 변수 문자가 덮어씌워지는 위치부터 컬러코드가 적용됨)
IndexArr : 숫자 삽입 위치 결정 (비우면 맨 앞부터 삽입, {1번째 문자 삽입위치, … , 마지막 문자 삽입위치} 형식으로 입력)
DataArr : 변환 문자 설정 ({A(조건),B(액션)} 형태로 입력, 미입력시 2~10진법 → 0~9로 표시, 11진법 이상 → 0~F로 표시)
A = n (해당 자리수의 숫자) → (문자 Exactly n), A = {a,b} → (a≤문자≤b),
B = " "(2글자이상 입력가능) → (문자 SetTo " "),
B = {" "(기본문자, 2글자이상 입력가능), 곱할 수(상수/배열(2글자이상))}} → (문자 SetTo " "+ 해당 자리수의 숫자*곱할수)
ClearArr : 변수 사이 공간의 초기화 여부 (비우면 적용X, {1번째 문자 뒷공간 초기화여부, …. , } 형식으로 입력)
→ 0입력시 공간 앞의 자리수가 모두 0일때 초기화함, n입력시 n번째 자릿수가 0일경우 초기화함 (배열로 입력)

Ex) [예제 26-18] 참고
※ 배열 원소에 빈칸입력시 nil 대신 0을 입력해야함 (Init, Sign, ColorArr, DataArr, ClearArr)
CA__lItoCustom(SVA1,Input,Output,Mask,Base,Length,Init,Sign,ColorArr,IndexArr,DataArr,ClearArr,utf8flag)
: SVA1에 8바이트 변수를 iStr타입으로 출력하는 함수
Input : 변환할 8바이트 변수 (W)
나머지는 CA__ItoCustom과 모두 동일함

Ex) [예제 26-18] 참고

181

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CA__ 함수는 CAPrint 내부에서 스트링 데이터를 실시간으로 연산 할 수 있습니다 ｡+.ﾟ
CA__GetName(SVA1,TargetPlayer,Output)
: SVA1에 TargetPlayer의 아이디를 복사하는 함수 (iString으로 자동 인코딩)
SVA1 : 인코딩된 스트링을 저장할 SVA1 변수 (SVA1 함수 미사용, 사용 모두 가능)
TargetPlayer : 아이디를 복사할 플레이어 (P1~P8중 선택, "Host" 입력시 방장의 아이디를 복사함)
Output : 실제로 인코딩 된 글자의 수 (상수/V/Mem 입력, 비우면 사용안함)
※ 복사된 아이디의 글자 수는 최대 16자까지 복사됨 (SVA1의 길이는 반드시 16이상 이여야함)
Ex) [예제 26-36] 참고
CA__epdcpy(SVA1,Value,Mask,Start,End,Preserve)

: SVA1에 Value값을 Start부터 End까지 복사하는 함수
SVA1 : 값을 변경할 SVA1타입 변수 (SVA1함수 미사용만 가능)
Value : SVA1에 복사할 값 (상수/V)
Mask : SVA1 복사값의 비트마스크 (상수, 비우면 0xFFFFFFFF로 입력됨)
Start : SVA1 복사 시작지점 (상수/V) → V삽입시 604의 배수로 입력
End : SVA1 복사 종결지점 (상수/V) → V삽입시 604의 배수로 입력, SVA1의 Start~End범위의 Value를 변경함
Preserve : (Start, End가 모두 상수일때만 적용됨) 0입력시 1번만 실행함, 비우면 Preserved 상태로 생성
Ex) [예제 26-37] 참고
CA__epdcmp(Dest,Source,Size,Mask,CFlag)
: SVA1 배열의 값을 EPD 단위로 Dest와 Size만큼 비교함 (Dest == Source 검사)
Dest : 값을 비교할 SVA1타입 변수 (SVA1 함수 미사용, 사용 모두 가능)
Source : 값을 비교할 SVA1타입 변수 (SVA1 함수 미사용, 사용 모두 가능 / 연산 후 Mask값 바뀜)
Size : 비교할 데이터의 크기 - (상수/V/VA)
Mask : 비교할 데이터 값의 비트마스크 (상수, 비우면 0xFFFFFFFF로 입력됨, 연산 후 Source의 Mask가 이 값으로 바뀜)

CFlag : 조건 연산의 결과값을 저장할 CFlag (Exactly 연산, CDeaths Ccode 입력 가능)
모두 일치할 경우 1, 하나라도 다를 경우 0을 CFlag에 반환함

Ex) [예제 26-38] 참고
TTepdcmp(Dest,Source,Size,Mask)
: CS__epdcmp를 TT조건 형태로 만든 함수 (CFlag 자동 할당됨, CStruct 조건에서 사용가능)
CA__epdcmp와 모두 동일하게 입력 / Ex) [예제 26-38] 참고

182

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ iTbl은 iString을 TBL에 삽입하기 위한 스트링 형식 (버튼타입 및 단축키 + iString)｡+.ﾟ
MakeiTblString(TBLIndex,Type,Hotkey,String,Name,Hexflag)
: 입력받은 String를 iTBL로 변환후 저장하는 함수 (TBL단락 공간 할당용 텍스트 출력 함수)
TBLIndex : iTBL로 변환 후 등록할 TBL 문자열
Type : 버튼의 타입
HotKey : 버튼의 단축키
String : iTBL로 변환 후 저장할 스트링
Name : 저장할 스트링의 이름 (TBLString.txt에서 확인)
Hexflag : 1입력시 스트링을 헥스값의 나열로 저장함 (비우면 문자열로 저장함)
리턴값 : 변환된 iTBL의 길이 (GetiTblId의 Size에 입력)

Ex) [예제 26-19] 참고
※ EUDEditor2 → Hexflag 비우기, EUDEditor3 → Hexflag 1입력 후 저장을 권장함
GetiTblId(PlayerId,TBLIndex,Size)
: 입력받은 TBLIndex를 iTBL로 패치하는 함수 (TBL단락 공간 할당 및 패치용)
PlayerID : 생성되는 변수의 체크 플레이어
TBLIndex : iTBL로 변환 후 등록할 TBL 문자열
Size : iTBL의 길이 (MakeiTblString의 리턴값 삽입)
리턴값 : 해당 TBLId에 할당된 iTBL 데이터 → iTblId 인자에 입력가능
Ex) [예제 26-19] 참고
※ iTblId 데이터 형식 = {iTbl의 주소를 담은 변수(V), 할당받은 문자열의 TBLIndex, iTbl의 길이}

MakeButtonTypeValue(String)
: 입력한 버튼의 타입의 헥스값을 구하는 함수 (CB__SetButtonType에 사용됨)
String : 버튼의 타입
Ex) [예제 26-21] 참고
※ 버튼의 타입 입력방법 : 일반명령, 유닛생산, N업그레이드, 스킬사용, 테크업그레이드, 유닛변태, None 중 입력

MakeHotkeyValue(String)
: 입력한 버튼의 단축키의 헥스값을 구하는 함수 (CB__SetHotkey에 사용됨)
String : 버튼의 단축키
Ex) [예제 26-21] 참고
※ 버튼의 단축키 입력방법 (아래 문자 중 입력) : (키없음) → None
(영어) → A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q ,R, S, T, U, V, W, X, Y, Z,
a, b, c, d, e, f, g, h, I, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z
(Ctrl+영어) → CA, CB, CD, CE, CF, CG, CI, CJ, CK, CL, CN, CO, CP, CT, CU, CV, CW, CY, CZ
(Ctrl+Shift+영어) → CSC, CSM, CSQ, CSR, CSS, CSX
(특수키) → Tab, Enter, ESC, Space, \", \', +, ,, ., /, :, ;, <, >, ?, [, \\, ], _, `, {, |, }, ~,
(Ctrl+특수키) → Center, C[, C\\, C], C^, C_, CBS (BS = Backspace)
183 NA(넘버패드) → N*, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9 / (Shift+넘버패드) → NS+, NS- / (Alt+넘버패드) → NA+,

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟCBPrint는 Tbl전용 변수 스트링 출력 함수로, 부가효과 함수(CA__&CB__)를 Cbfunc 내부에서 사용가능함｡+.ﾟ

CBPrint(iTblId,Preset,CBfunc,PlayerID,Condition,PerAction,Action)
: iTbl 데이터를 실시간 변수 스트링 출력 트리거로 변환하는 함수 (변수 삽입 가능)
iTblId : 텍스트를 출력하는데 사용할 iTblId (GetiTblId의 리턴값 입력)
Preset : = {CA[1],CA[2],CA[3],CA[4],CA[5]}
각각의 자리에 nil, 숫자, V(변수) 삽입 가능 (변수 삽입시 CBPrint 트리거 앞에서 CA[_] << V 연산이 실행됨)

CBfunc : CBPrint 함수 내부에 삽입할 사용자 정의 코드를 입력함 (nil 입력시 사용X)
(함수 이름 (String) 입력시 함수 내부 코드를 CBPlot 내부에서 실행시킴)
PlayerID : 생성 트리거의 체크 플레이어
Condition : 트리거의 조건

PerAction : 생성할때마다 실행할 액션 (CDoActionsX 형식으로 입력)
Action : 생성할때마다 실행할 액션
CA : (= CAPrintDataArr) : 1st CBPrint 전용 내부 변수 총 5개
CB : (= CAPrintCreateArr) : 2nd CBPrint 전용 내부변수 총 3개
PlayerID : (=CAPrintPlayerID) : CBPrint 전용 트리거 플레이어
CA[1] = 출력할 String Id 선택 (k 입력시 k번 iTblid 데이터로 초기화 후 0으로 변경됨)
CA[2] = 남은 대기 시간 (Tick 단위 / 0일때 CBFunc 실행)
CA[3] = CBFunc 대기시간 증가량 (Tick 단위/ k입력시 1회 루프후 대기시간 k추가)
CA[4] = 루프 카운터 (트리거 순환당 루프 수를 카운트함)
CA[5] = 루프 리미트 (트리거 순환당 CBFunc 실행할 횟수/ k입력시 CA[4] : 0~k-1까지 루프함)
CB[1] = 선택된 iTblid의 시작 주소의 EPD (CA[1] 변경시 갱신됨)
CB[2] = 선택된 iTblid의 iStr Size (스트링 단락에 할당받은 공간의 크기, CA[1] 변경시 갱신됨)
CB[3] = 선택된 iTblid의 String Id (CA[1] 변경시 갱신됨)

Ex) [예제 26-19] 참고
※ CBfunc 내부 코드를 작성할때 CBPrint 내부 변수를 가져오려면
local PlayerID = CAPrintPlayerID
local CA = CAPrintDataArr

local CB = CAPrintCreateArr
를 함수 맨 위에 붙여넣으면 된다.
※ iTblid 공간 할당 방법 :
EUDEditor2,3 등의 TBL편집 프로그램을 사용해 MakeiTblString으로 출력된 스트링(절대경로의 TBLString.txt에 저장됨)을
GetiTblId에 입력한 TBLIndex에 해당 텍스트를 그대로 붙여넣은 후 저장된 stat_txt.tbl파일을 맵에 그대로 삽입한다.
이후 GetiTblId의 리턴값을 CBPrint의 iTblId에 삽입하면 CBFunc내에서 iStrid처럼 사용가능함 (CA__&CB__ 사용가능)
※ 주의 : 버튼셋 TBL의 갱신 주기는 기본적으로 마우스 커서를 버튼에 올렸다가 내리고 다시 올릴때까지 갱신이 안됨
이 갱신주기를 트리거 실행주기와 동일하게 맞추려면 유닛 생성 삭제를 무한반복 해주면 된다. (유닛종류, 수량, 위치 무관)
(예제의 TBL Refresh 트리거 참고)

184

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CB__ 함수는 CBPrint 내부에서 스트링 데이터를 실시간으로 연산 할 수 있습니다 ｡+.ﾟ
CB__SetButtonType(Value)
: iTbl의 버튼의 타입을 바꾸는 함수
Value : 버튼의 타입의 헥스값(상수/V/스트링) → MakeButtonTypeValue의 리턴값을 입력
Ex) [예제 26-20] 참고
※ 버튼의 타입 입력방법(스트링 입력시) :
일반명령, 유닛생산, N업그레이드, 스킬사용, 테크업그레이드, 유닛변태, None 중 입력

CB__SetHotkey(Value)
: iTbl의 버튼의 단축키를 바꾸는 함수

Value : 버튼의 단축키의 헥스값(상수/V/스트링) → MakeHotkeyValue의 리턴값을 입력
Ex) [예제 26-20] 참고
※ 버튼의 단축키 입력방법 (아래 문자 중 입력) : (키없음) → None
(영어) → A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q ,R, S, T, U, V, W, X, Y, Z,
a, b, c, d, e, f, g, h, I, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z
(Ctrl+영어) → CA, CB, CD, CE, CF, CG, CI, CJ, CK, CL, CN, CO, CP, CT, CU, CV, CW, CY, CZ
(Ctrl+Shift+영어) → CSC, CSM, CSQ, CSR, CSS, CSX
(특수키) → Tab, Enter, ESC, Space, \", \', +, ,, ., /, :, ;, <, >, ?, [, \\, ], _, `, {, |, }, ~,
(Ctrl+특수키) → Center, C[, C\\, C], C^, C_, CBS (BS = Backspace)

(넘버패드) → N*, N0, N1, N2, N3, N4, N5, N6, N7, N8, N9
(Shift+넘버패드) → NS+, NS(Alt+넘버패드) → NA+, NA-

185

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ iUTF8은 utf8인코딩 iStr형식으로, 글자당 4바이트로 구성됨 (디스플레이 전용, 함수명 뒤에 X를 붙임) ｡+.ﾟ

CreateSVA32X(iStrArr,Size,PlayerID)
: 입력받은 iStr을 SVA32 변수에 저장하는 함수 (utf8 전용)
iStrArr : 변수에 저장할 iStr 배열 (GetiStrArr등의 함수로 변환된 iStr배열을 입력)
Size : 변수에 저장할 iStr의 길이 (GetiStr[Arr/Size]등의 함수로 구한 iStr길이를 입력)
PlayerID : 생성되는 변수의 체크 플레이어
리턴값 : iStr이 저장된 변수
SaveiStrArrX(PlayerID,String,SVA32)
: 입력받은 스트링을 iStr로 변환 후 변수에 저장하는 함수 (utf8 전용)

PlayerID : 생성되는 변수의 체크 플레이어
String : iStr로 변환 후 저장할 스트링
SVA32 : 비우면 SVA1타입으로 저장 (CDPrint, C13Print), 1입력시 SVA32타입으로 저장 (CA__Overwrite)
리턴값 : iStr이 저장된 변수, 변환된 iStr 배열, 변환된 iStr의 길이
Ex) [예제 26-22] 참고
SaveiStrptrX(PlayerID,String,SVA32) - ＃STRCtrig 필수 & 반드시 CJump 사이에서만 사용해야함
: 입력받은 스트링을 iStr로 변환 후 변수에 저장하는 함수 (파일로 저장함, utf8 전용)
나머지는 SaveiStrArrX와 모두 동일함
Ex) [예제 26-22] 참고
※ SaveiStrX[Arr/ptr]은 iStr데이터를 변수에 저장할때 사용함 (CDPrint/C13Print등에서 사용, utf8타입으로 저장함)
※ SaveiStrptrX은 반드시 Tep 맨 위의 Cjump(0) 사이에 넣어야 합니다. (변수 선언 함수와 동일함)

MakeiStrDataX(Letter,Fill)
: 입력한 문자의 헥스값을 구하는 함수 (utf8 전용)
Letter : 헥스값을 구할 문자 (한 글자만 입력해야함, 컬러코드 포함 가능)
Fill : 1입력시 빈칸을 0xD로 채움 (1바이트 단위로 0x00 → 0x0D로 변경, 비우면 적용X)

Ex) [예제 26-27] 참고
MakeiStrDiffX(Start,End)
: 입력한 문자들의 헥스값의 차를 구하는 함수 (utf8 전용)
Start : 헥스값을 구할 문자 (한 글자만 입력해야함, 시작문자)
End : 헥스값을 구할 문자 (한 글자만 입력해야함, 도착문자) → End - Start의 값을 리턴함
Ex) [예제 26-27] 참고
※ MakeiStrDataX, MakeiStrDiffX는 주로 CA__ConvertLetter에서 사용됨 (ConvertData 입력시 사용)

186

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ iUTF8은 utf8인코딩 iStr형식으로, 글자당 4바이트로 구성됨 (디스플레이 전용, 함수명 뒤에 X를 붙임) ｡+.ﾟ

Display(Line,Status)
: 디스플레이 텍스트의 표시여부를 감지하는 조건
Line : 표시여부를 감지할 디스플레이 텍스트의 줄 (0~10, 12입력, 각각 0x640B60+218*Line부분을 검사함)
Status : "On" 입력시 텍스트가 표시중일때 조건 만족, 비우면 표시X일때 조건 만족함
Ex) [예제 26-28] 참고
TTDisplay(Line,Status)
: 디스플레이 텍스트의 표시여부를 감지하는 조건 (변수 삽입형 조건)
Line : 표시여부를 감지할 디스플레이 텍스트의 줄 (V입력, 각각 0x640B60+218*Line부분을 검사함)

Status : "On" 입력시 텍스트가 표시중일때 조건 만족, 비우면 표시X일때 조건 만족함
Ex) [예제 26-28] 참고
※ 사용자가 디스플레이 텍스트의 첫부분(0x640B60+218*Line)에 Null문자 삽입시에도 표시 X으로 인식됨
DisplayX(Line,Index,Value,Mask)
: 디스플레이 텍스트의 Line번째 줄의 Index가 Value와 일치하는지 검사하는 조건
Line : 표시여부를 감지할 디스플레이 텍스트의 줄 (상수/V, 0~10 또는 12입력)
Index : 표시여부를 감지할 디스플레이 텍스트의 Index (상수/V, 0~53 입력, iStr 기준 1글자(epd)씩 움직임)
Value : 비교할 값 (상수/V, MakeiStrDataX 등으로 값을 직접 입력)
Mask : 조건의 Mask (상수/V)
Ex) [예제 26-29] 참고
TTDisplayX(Line,Index,Type,Value,Mask)
: 디스플레이 텍스트의 Line번째 줄의 Index가 Value와 일치하는지 검사하는 조건
Line : 표시여부를 감지할 디스플레이 텍스트의 줄 (상수/V, 0~10 또는 12입력)
Index : 표시여부를 감지할 디스플레이 텍스트의 Index (상수/V, 0~53 입력, iStr 기준 1글자(epd)씩 움직임)
Type : Exactly 입력시 일치시 조건만족, NotSame또는 "!="입력시 불일치시 조건만족

Value : 비교할 값 (상수/V, MakeiStrDataX 등으로 값을 직접 입력)
Mask : 조건의 Mask (상수/V)
Ex) [예제 26-29] 참고
※ (TT)DisplayX는 Memory(0x640B60(2)+Line*218+Index*4,Exactly,Value,Mask) 의 조건을 생성함

187

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ iUTF8은 utf8인코딩 iStr형식으로, 글자당 4바이트로 구성됨 (디스플레이 전용, 함수명 뒤에 X를 붙임) ｡+.ﾟ

f_Strlen(PlayerID,Line,Output,EPDXOutput)
: 디스플레이 텍스트의 길이를 구하는 함수 (CDPrint기준 Line번째 줄의 Index 0~53영역을 검사함)
PlayerID : 생성 트리거의 체크 플레이어
Line : 길이를 구할 디스플레이 텍스트의 줄 (0~10, 12입력, 각각 0x640B60+218*Line부분을 검사함)
Output : 해당 줄의 스트링 길이 (상수/V/Mem 입력, Index 0~53 각각 0~53반환, Null이 없을 경우 54반환)
EPDXOutput : 해당 줄의 Null문자의 위치 편차 (상수/V/Mem 입력, +0x0 ~+0x3 각각 0~3으로 반환)
Ex) [예제 26-30] 참고
※ Output과 EPDXOutput 비우면 반환 값 사용 안함으로 처리됨

MakeChatOffset(Line,Offset)
: 디스플레이 텍스트의 오프셋을 구하는 함수 (상수전용)
Line : 오프셋을 구할 디스플레이 텍스트의 줄 (0~10 또는 12 중 선택)
Offset : 오프셋에 더할 편차값 (0~218중 입력)
리턴값 : 0x640B60+218*Line + Offset (상수)
Ex) [예제 26-31] 참고
f_ChatOffset(PlayerID,Line,Offset,Output)
: 디스플레이 텍스트의 오프셋을 구하는 함수 (변수전용)
PlayerID : 생성 트리거의 체크 플레이어
Line : 오프셋을 구할 디스플레이 텍스트의 줄 (0~10 또는 12 중 선택, 상수/V/VA 입력)
Offset : 오프셋에 더할 편차값 (0~218중 선택, 상수/V/VA 입력)
Output : 구한 오프셋을 담을 변수 (상수/V/Mem 입력)
Ex) [예제 26-31] 참고
_Chat(Line,Offset)
: f_ChatOffset의 중간 연산자 함수

Line, Offset : f_ChatOffset과 동일, 모두 상수 입력시 트리거 생성 안함 (단순 상수 변환)
Ex) [예제 26-31] 참고
※ f_ChatOffset과 _Chat은 주로 CD__ScanChat의 Offset값을 구하기위해 사용됨

188

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ CDPrint는 디스플레이 출력 함수로, 부가효과 함수(CD__)를 CDfunc 내부에서 사용가능함 ｡+.ﾟ

CDPrint(Line,Size,Init,DisplayPlayer,Preset,CDfunc,PlayerID,Condition,PerAction,Action)
: 변수 스트링 데이터를 실시간 디스플레이 출력 트리거로 변환하는 함수 (변수 삽입 가능, utf8 전용)

Line : 텍스트를 출력하는데 사용할 디스플레이의 줄 수 (0~10 중 선택, 숫자/V 입력가능
→ 0x640B60+218*Line에 출력함 / {숫자/V} 입력시 텍스트의 절대 위치(위에서부터 0~10)에 출력함)
Size : 텍스트의 세로 줄 수 (1~11 중 선택, 숫자/V 입력)
Init : 출력시 해당 디스플레이 줄을 초기화 할 문자와 마스크값 입력 (54번째 글자는 Null,0xFFFFFFFF로 초기화)
→ {문자,마스크,홀수줄 시작부분 초기화 마스크(미입력 가능)} 형태로 입력 (문자는 1글자 또는 4바이트 값으로 입력)

DisplayPlayer : 텍스트를 출력할 플레이어 (CopyCpActionX의 Player와 동일)
Preset : = {X,CA[2],CA[3],CA[4],CA[5],X,CA[7],CA[8]} - X는 빈칸 (아무 숫자나 입력)
각각의 자리에 nil, 숫자, V(변수) 삽입 가능 (변수 삽입시 CDPrint 트리거 앞에서 CA[_] << V 연산이 실행됨)

CDfunc : CDPrint 함수 내부에 삽입할 사용자 정의 코드를 입력함 (nil 입력시 사용X)
(함수 이름 (String) 입력시 함수 내부 코드를 CDPlot 내부에서 실행시킴)
PlayerID : 생성 트리거의 체크 플레이어
Condition : 트리거의 조건
PerAction : 생성할때마다 실행할 액션 (CDoActionsX 형식으로 입력)
Action : 생성할때마다 실행할 액션
CA : (= CAPrintDataArr) : 1st CDPrint 전용 내부 변수 총 8개
CB : (= CAPrintCreateArr) : 2nd CDPrint 전용 내부변수 총 4개
PlayerID : (=CAPrintPlayerID) : CDPrint 전용 트리거 플레이어

CA[1] = 출력할 Line 선택 (k 입력시 k번 Line으로 출력함, 사용자가 값 변경 금지 - Line의 값에 의해 결정됨)
CA[2] = 남은 대기 시간 (Tick 단위 / 0일때 CDFunc 실행)
CA[3] = CDFunc 대기시간 증가량 (Tick 단위/ k입력시 1회 루프후 대기시간 k추가)
CA[4] = 루프 카운터 (트리거 순환당 루프 수를 카운트함)
CA[5] = 루프 리미트 (트리거 순환당 CDFunc 실행할 횟수/ k입력시 CA[4] : 0~k-1까지 루프함)
CA[6] = Size의 값 저장 (k 입력시 Line에 k줄을 출력함, 사용자가 값 변경 금지 - Size의 값에 의해 결정됨)
CA[7] = 텍스트 출력 딜레이 (Tick 단위 / 0일때 텍스트 출력)
CA[8] = 텍스트 출력 대기시간 증가량 (Tick 단위/ k입력시 1회 루프후 대기시간 k추가)
CB[1] = 출력할 디스플레이 시작 주소의 EPD (사용자가 값 변경 금지)

CB[2] = 디스플레이 텍스트의 길이 (항상 604*11로 고정, 사용자가 값 변경 금지)
CB[3] = 현재 0x640B58의 값
CB[4] = 텍스트 출력 스위치 (0이 아닐경우 텍스트의 출력을 차단함)

Ex) [예제 26-22] 참고
※ CDfunc 내부 코드를 작성할때 CDPrint 내부 변수를 가져오려면
local PlayerID = CAPrintPlayerID
local CA = CAPrintDataArr
local CB = CAPrintCreateArr
를 함수 맨 위에 붙여넣으면 된다.

189

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ CDPrint는 디스플레이 출력 함수로, 부가효과 함수(CD__)를 CDfunc 내부에서 사용가능함 ｡+.ﾟ

CDPrint(Line,Size,ClearLetter,DisplayPlayer,Preset,CDfunc,PlayerID,Condition,PerAction,Action)
: 변수 스트링 데이터를 실시간 디스플레이 출력 트리거로 변환하는 함수 (변수 삽입 가능, utf8 전용)
※ CA__ 함수를 CDfunc 또는 C13func 에서 사용시 뒤에 utf8flag가 있는 경우 반드시 1을 입력해야함.
(utf8flag에 1입력시 iutf8모드로 작동, 비우면 icp949로 작동함)
※ CDPrint의 구조 :
CDPrint → SVA54[21] → 실제 디스플레이 텍스트 부분 (0x640B60+Line*218)
SVA54[21] : 각각 0x640B60+0*218+0~+216, 0x640B62+1*218+0~+216,

0x640B60+2*218+0~+216, 0x640B62+3*218+0~+216, 0x640B60+4*218+0~+216
0x640B62+5*218+0~+216, 0x640B60+6*218+0~+216, 0x640B62+7*218+0~+216,
0x640B60+8*218+0~+216, 0x640B62+9*218+0~+216, 0x640B60+10*218+0~+216,
0x640B60+0*218+0~+216, 0x640B62+1*218+0~+216, 0x640B60+2*218+0~+216,
0x640B62+3*218+0~+216, 0x640B60+4*218+0~+216, 0x640B62+5*218+0~+216,
0x640B60+6*218+0~+216, 0x640B62+7*218+0~+216, 0x640B60+8*218+0~+216,
0x640B62+9*218+0~+216 를 변경하는 액션 54개짜리 트리거 배열 (Line번째 부터 Size개 만큼 호출함)
(트리거 하나당 텍스트 한줄씩 출력함)
CDPrint 실행시 CB[1]은 SVA54[Line]의 첫번째 액션 부분의 주소(EPD)를 저장함
CDPrint에서의 Index는 글자당 간격이 8(epd)이 되며, 한 줄당 최대 54자의 글자를 iStr타입으로 출력할수있음
1~53번째 글자는 Init에 입력한 문자로 CDPrint 실행시마다 초기화되며, 54번째 글자는 Null(0)이 입력됨
(CDFunc 등으로 Null 제거시 다음줄의 텍스트까지 같이 출력됨)
SVA54[21]의 각 액션의 Mask는 글자 데이터가 저장된 Value에서 -5(epd)에 저장되어 있으며,
_Mindex등의 함수를 사용하여 CA__SetMemoryX, CA__ReadX의 Index에 값을 넣어 Mask에 접근할수 있다.

두 줄 이상의 텍스트를 출력하는 경우 줄 사이의 간격은 604(epd)이며, Line에 상관없이 최대 11줄 까지 출력가능
_GIndex등의 함수를 사용하지 않을 경우, 시작위치 + k번째줄의 n번째 글자 = k*604+n*8 (n=0~53, k=0~10)
= Index로 입력해야 하며, 이것을 지키지 않을 경우 CDPrint 트리거 자체에 오류가 발생 할 수도 있음
CDPrint 및 C13Print, 디스플레이 텍스트는 무조건 utf8로 인코딩 되어야 하며, 반드시 X함수 또는 iutf8flag를 사용해야함
CDPrint의 Init인자 홀수줄 시작부분 초기화 마스크는 디스플레이 텍스트 홀수줄의 첫 2바이트 부분을 공백문자(0xD)로
채워 넣을지의 여부를 결정하는 부분이며, 값 미입력시 홀수줄의 첫 2바이트를 0x0D0D로 채워넣고,
0입력시 홀수줄의 첫 2바이트를 건드리지 않는다. (홀수줄 첫 2바이트,SetTo,0x0D0D의 비트 마스크로 작동함)
190

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CD__ 함수는 CDPrint 내부에서 스트링 데이터를 실시간으로 연산 할 수 있습니다 (utf8 전용) ｡+.ﾟ
CD__GetDisplayLine(Line,Output)
: Line(주소위치)을 DisplayLine(절대위치)로 변환하는 함수
Line : 변환할 주소위치(0x640B60+218*Line, 0~10 중 선택, 상수/V/VA 입력)

Output : 변환된 DisplayLine을 저장할 곳 (상수/V/VA/A/Mem 입력)
CD__GetLine(DisplayLine,Output)
: DisplayLine(절대위치)을 Line(주소위치)로 변환하는 함수
Line : 변환할 절대위치(맨 위부터 0, 0~10 중 선택, 상수/V/VA 입력)
Output : 변환된 Line을 저장할 곳 (상수/V/VA/A/Mem 입력)
CD__GetIndex(Index,Output)
: Index를 CDPrint의 인덱스로 변환하는 함수
Index : 변환할 index (0~53+54*10 중 선택, 상수/V/VA 입력) → (Index/54)*604+(Index%54)*8로 변환됨
Output : 변환된 Index를 저장할 곳 (상수/V/VA/A/Mem 입력)
CD__GetIndex2(Line,Index,Output)
: Line과 Index를 CDPrint의 인덱스로 변환하는 함수
Line : 변환할 Line (0~10 중 선택, 상수/V/VA 입력)
Index : 변환할 index (0~53 중 선택, 상수/V/VA 입력) → Line*604 + Index*8로 변환됨
Output : 변환된 Index를 저장할 곳 (상수/V/VA/A/Mem 입력)
_GIndex(Index)
: CD__GetIndex의 중간 연산자 함수
Index : CD__GetIndex와 동일, 상수 입력시 트리거 생성 안함 (단순 상수 변환)
Ex) [예제 26-34] 참고
_GIndex2(Line,Index)
: CD__GetIndex2의 중간 연산자 함수
Index, Line : CD__GetIndex2와 동일, 모두 상수 입력시 트리거 생성 안함 (단순 상수 변환)

Ex) [예제 26-35] 참고

191

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CD__ 함수는 CDPrint 내부에서 스트링 데이터를 실시간으로 연산 할 수 있습니다 (utf8 전용) ｡+.ﾟ
CD__GetMask(Index,Output)
: Index를 CDPrint의 Mask 인덱스로 변환하는 함수
CD__GetIndex와 동일 → (Index/54)*604+(Index%54)*8 - 5로 변환됨
CD__GetMask2(Line,Index,Output)
: Line과 Index를 CDPrint의 Mask 인덱스로 변환하는 함수
CD__GetIndex2와 동일 → Line*604 + Index*8 - 5로 변환됨
_MIndex(Index)
: CD__GetMask의 중간 연산자 함수
_GIndex와 동일, 모두 상수 입력시 트리거 생성 안함 (단순 상수 변환)
Ex) [예제 26-34] 참고
_MIndex2(Line,Index)
: CD__GetMask2의 중간 연산자 함수
_GIndex2와 동일, 모두 상수 입력시 트리거 생성 안함 (단순 상수 변환)
Ex) [예제 26-35] 참고
CD__SetMaskX(index,Mask)
: index의 Mask를 변경하는 함수
Line : Mask값을 변경할 텍스트의 index (_Gindex 함수 등으로 Index 변환값을 입력, 상수/V)
Mask : Mask에 복사할 값 (상수/V)
Ex) [예제 26-39] 참고

192

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CD__ 함수는 CDPrint 내부에서 스트링 데이터를 실시간으로 연산 할 수 있습니다 (utf8 전용) ｡+.ﾟ
CD__InputVAX(Index,SVA1,Size,Mask,DestMask,Start,End,SourceDistance)
: SVA1에 저장된 iStr을 디스플레이 출력 트리거에 복사하는 함수 (DestMask를 Dest의 Mask에 함께 복사함)
Index : iStr에 복사할 시작점 (글자단위, 상수/V)
SVA1 : 복사할 iStr이 담긴 SVA1타입 변수 (SVA1함수 사용, 미사용 모두 가능)
Size : 복사할 글자의 개수 (상수/V)
Mask : 복사할 범위 (비트마스크, 비우면 SVA1이 가진 Mask대로 복사함)
DestMask : Dest의 Mask에 복사할 비트마스크 (Dest에서 실제로 값이 복사된 부분만 Mask도 함께 복사됨)
Start : iStr에 복사할 범위의 최솟값 (상수/V) → Start미만 범위는 복사 안됨
End : iStr에 복사할 범위의 최댓값 (상수/V) → End초과 범위는 복사 안됨

SourceDistance : SVA1 복사 간격 (n입력시 1→n+1→2n+1순으로 간격을 두면서 복사함)
Ex) [예제 26-23] 참고
※ CD__InputVAX는 CA__InputVA와 완전히 동일하게 사용하면 됨 (DestMask 옵션만 추가된 함수)
※ Mask가 nil일 경우 SVA1의 Mask가 1이상일때만 Dest에 값을 복사함
CD__InputMask(Line,Mask,Start,End)
: Line번째 줄의 Mask를 변경하는 함수
Line : Mask값을 변경할 텍스트 줄 수 (0~10 중 선택, CDFunc의 Line번째 줄 부터 0, 상수/V 입력)
Mask : Mask에 복사할 값 (상수/V)
Start : Mask 복사 시작지점 (0~53 중 선택, 상수/V 입력)
End : Mask 복사 종결지점 (0~53 중 선택, 상수/V 입력)
Ex) [예제 26-39] 참고
※ CD__InputMask에서 입력가능 범위를 초과한 경우 오류가 발생할 수도 있음 (Line 0~10, Start~End 0~53)
CD__Resize(Line,Status)
: Line번째 줄에 입력된 텍스트의 폰트 크기를 변경하는 함수 (맨 앞글자(Index=0)에 0x0D0D0D0A 삽입 방식)
Line : 폰트의 크기를 변경할 텍스트 줄 수 (0~10 중 선택, CDFunc의 Line번째 줄 부터 0, 상수/V 입력)

Status : 크기 조절상태 (1또는 "On" → 크기 줄일때 사용, 0또는 "Off" 입력 → 크기 복구시 사용)
Ex) [예제 26-39] 참고
※ CD__Resize는 무조건 해당 줄의 맨 앞 글자(Index=0)에 0x0D0D0D0A를 삽입함 (복구시 0x0D0D0D0D를 삽입함)

193

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CD__ 함수는 CDPrint 내부에서 스트링 데이터를 실시간으로 연산 할 수 있습니다 (utf8 전용) ｡+.ﾟ
CD__ScanV(SVA1,Size,Variable,Output,Base,Sign)
: SVA1에 저장된 스트링을 4바이트 값(V)으로 변환하는 함수
SVA1 : 변환할 스트링이 저장된 SVA1타입 변수 (SVA1 함수 미사용, 사용 모두 가능)
(SVA1함수로 변환할 숫자 스트링의 맨 끝 Index를 입력)
Size : 스트링을 읽어들일 최대 크기 (상수/V)
Variable : 변환된 변수값을 저장할 V
Output : 변환된 스트링의 맨 앞글자의 Index를 반환함 (V입력)
Base : 변환할 스트링의 진법 수 (10 → 10진법, 16 → 16진법, 상수/V)
Sign : 변환할 스트링의 부호 여부 (0입력시 unsigned로 변환, 1입력시 signed로 변환, 상수/V)

Ex) [예제 26-40] 참고
CD__ScanW(SVA1,Size,Wariable,Output,Base,Sign)
: SVA1에 저장된 스트링을 8바이트 값(W)으로 변환하는 함수
Wariable : 변환된 변수값을 저장할 W
나머지는 모두 CD__ScanV와 동일함
Ex) [예제 26-40] 참고
※ CD__Scan[V/W]는 사용자 채팅입력을 CD__ScanChat으로 변환 후 해당 스트링을 함수에 입력해 사용함
※ CD__Scan[V/W]는 Sign이 1일때 -가 있으면 부호를 바꾸고 중단함, 다른 문자가 있을 경우 중단함
※ CD__Scan[V/W]는 Base가 10일때 숫자 사이의 ,를 무시함, 16일때 숫자 사이의 스페이스바를 무시함
※ CD__Scan[V/W]는 SVA1로 입력된 Index부터 ←방향으로 읽으며, 첫번째 숫자 스트링이 나오기 전까지의
모든 문자를 무시하고 진행함 (읽는 도중 Size를 초과하거나 SVA1의 Index가 0이 되어도 중단함)
CD__ScanChat(SVA1,Offset,Size,Output,Null,SkipInit)
: Offset에서 SVA1에 글자를 복사 및 인코딩하는 함수 (utf8 → iutf8)
SVA1 : 인코딩된 스트링을 저장할 SVA1 변수 (SVA1 함수 미사용, 사용 모두 가능)
Offset : 인코딩할 스트링이 저장된 오프셋 (Offset으로 입력, 상수/V 입력) - _Chat 함수 사용을 권장함

Size : 인코딩할 글자의 수 (상수/V 입력)
Output : 실제로 인코딩 된 글자의 수 (상수/V/Mem 입력, 비우면 사용안함)
Null : 1 입력시 Null문자(0x00)을 변환함 (0x00 존재시 마지막 변환값이 0x00000000이 됨, 비우면 적용X)
SkipInit : 1 입력시 오프셋의 EPDX가 +0x2고 첫번째 글자가 0x0D0D면 Offset을 2만큼 스킵함
(Offset에 디스플레이 텍스트의 홀수 줄의 Offset값을 입력할때 사용함 (_Chat(홀수,0), 비우면 적용X)
Ex) [예제 26-23] 참고
※ CD__ScanChat은 CAPrint 텍스트, 채팅 텍스트, 일반 DisplayText 텍스트를 모두 iutf8로 변환할수 있으나,
Offset 입력시 해당 디스플레이 텍스트의 시작지점을 입력하는 것을 권장함 (0xD로 CAPrint텍스트 여부를 결정함)
※ 일반 DisplayText 스트링에는 0xD를 사용하면 안되며, CAPrint 출력시 0xFF00부분에는 항상 0x0D로 채워져야함

※ 인코딩할 스트링의 Null문자 바로 앞의 \n(0xA)는 변환시 무시됨 (Null이 없어도 \n이 마지막 문자면 무시함)

194

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ C13Print는 오류줄 출력 함수로, 부가효과 함수를 C13func 내부에서 사용가능함 ｡+.ﾟ

CreateSV54(PlayerID,String)
: 입력받은 String을 SV54 변수에 저장하는 함수 (C13Print 전용)
String : SV54 타입 변수에 저장할 스트링 (54자 이내, 빈칸은 0xD로 채워짐)
PlayerID : 생성되는 변수의 체크 플레이어 / 리턴값 : iStr이 저장된 SV54타입 변수
※ SV54 타입 변수는 C13Print전용 스트링 저장용 변수 타입임 (CDPrint의 SVA32[21]을 대신함)
C13Print(SV54,DisplayPlayer,Preset,C13func,PlayerID,Condition,PerAction,CpAction,Action)
: 변수 스트링 데이터를 실시간 오류줄 출력 트리거로 변환하는 함수 (변수 삽입 가능, utf8 전용)
SV54 : 오류줄에 출력할 스트링이 저장된 SV54 타입 변수 ({A,B,…}형식으로도 입력가능)
DisplayPlayer : 텍스트를 출력할 플레이어 (CopyCpActionX의 Player와 동일)

Preset : = {CA[1],CA[2],CA[3],CA[4],CA[5],X,CA[7],CA[8]} - X는 빈칸 (아무 숫자나 입력)
각각의 자리에 nil, 숫자, V(변수) 삽입 가능 (변수 삽입시 C13Print 트리거 앞에서 CA[_] << V 연산이 실행됨)

C13func : C13Print 함수 내부에 삽입할 사용자 정의 코드를 입력함 (nil 입력시 사용X)
(함수 이름 (String) 입력시 함수 내부 코드를 C13Plot 내부에서 실행시킴)
PlayerID : 생성 트리거의 체크 플레이어 / Condition : 트리거의 조건
PerAction : 생성할때마다 실행할 액션 (CDoActionsX 형식으로 입력) / Action : 생성할때마다 실행할 액션
CA : (= CAPrintDataArr) : 1st C13Print 전용 내부 변수 총 8개
CB : (= CAPrintCreateArr) : 2nd C13Print 전용 내부변수 총 4개
PlayerID : (=CAPrintPlayerID) : C13Print 전용 트리거 플레이어
CA[1] = 출력할 SV54 변수 선택 (k 입력시 k번 SV54 데이터로 초기화 후 0으로 변경됨)
CA[2] = 남은 대기 시간 (Tick 단위 / 0일때 C13Func 실행)
CA[3] = C13Func 대기시간 증가량 (Tick 단위/ k입력시 1회 루프후 대기시간 k추가)
CA[4] = 루프 카운터 (트리거 순환당 루프 수를 카운트함)
CA[5] = 루프 리미트 (트리거 순환당 C13Func 실행할 횟수/ k입력시 CA[4] : 0~k-1까지 루프함)
CA[6] = Nextptr의 값 저장 (오류줄 출력후 복구할 Nextptr값 저장, 사용자가 값 변경 금지)
CA[7] = 텍스트 출력 딜레이 (Tick 단위 / 0일때 텍스트 출력)
CA[8] = 텍스트 출력 대기시간 증가량 (Tick 단위/ k입력시 1회 루프후 대기시간 k추가)

CB[1] = 출력할 디스플레이 시작 주소의 EPD (사용자가 값 변경 금지)
CB[2] = 디스플레이 텍스트의 길이 (항상 54*8로 고정, 사용자가 값 변경 금지)
CB[3] = 현재 선택된 SV54의 Offset값 (CA[1]변경시 초기화, 사용자가 값 변경 금지)
CB[4] = 텍스트 출력 스위치 (0이 아닐경우 텍스트의 출력을 차단함)

Ex) [예제 26-27] 참고
※ C13func 내부 코드를 작성할때 C13Print 내부 변수를 가져오려면
local PlayerID = CAPrintPlayerID
local CA = CAPrintDataArr
local CB = CAPrintCreateArr
를 함수 맨 위에 붙여넣으면 된다.

195

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CS__ 함수는 CA,CB,CD,C13Print 외부에서 스트링 편집을 사용할 수 있는 함수입니다｡+.ﾟ
CS__InputVA(PlayerID,iStrid,Index,SVA1,Size,Mask,Start,End,SourceDistance)
: CA__InputVA의 외부 함수 (CA/CB/C13Print 전용)
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
iStrid : CAPrint → iStrid를 입력, CBPrint → iTblid를 입력, C13Print → SV54타입 변수를 입력 (CB[1]을 대신함)
나머지는 모두 CA__InputVA와 동일함
※ iStrid가 있는 CS__ 외부 함수에서 CDPrint의 경우 CDPrint 실행시 SVA54[21]이 초기화 되므로 사용불가
CS__InputSVA1(PlayerID,Dest,Source,Size,Mask,Start,End,Next,DestDistance,SourceDistance)
: CA__InputSVA1의 외부 함수

PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CA__InputSVA1과 동일함
CS__InputSVA1X(PlayerID,Dest,Source,Size,Mask,DestMask,Start,End,Next,DestDistance,SourceDistance)
: CA__InputSVA1X의 외부 함수
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CA__InputSVA1X과 동일함
CS__OverWrite(PlayerID,iStrid,SVA32,Index,Null,Preserve)
: CA__OverWrite의 외부 함수 (CA/CB/C13Print 전용)
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
iStrid : CAPrint → iStrid를 입력, CBPrint → iTblid를 입력, C13Print → SV54타입 변수를 입력 (CB[1],CB[2]를 대신함)

나머지는 모두 CA__OverWrite와 동일함
CS__Input(PlayerID,Input,SVA1,Mask)
: CA__Input의 외부 함수
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)

나머지는 모두 CA__Input과 동일함
CS__SetMask(PlayerID,SVA1,Mask,Start,End,Preserve)
: CA__SetMask의 외부 함수
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CA__SetMask와 동일함

196

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CS__ 함수는 CA,CB,CD,C13Print 외부에서 스트링 편집을 사용할 수 있는 함수입니다｡+.ﾟ
CS__SetNext(PlayerID,SVA1,DestDistance,Mode,Start,End,Preserve)
: CA__SetNext의 외부 함수
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CA__SetNext와 동일함
CS__MoveXY(PlayerID,SVA1,Line,Mul,Mode,Fix,PathData,Preserve)
: CA__MoveXY의 외부 함수
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CA__MoveXY와 동일함
CS__SetValue(PlayerID,SVA1,String,Mask,Index,Preserve,utf8flag)
: CA__SetValue의 외부 함수
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CA__SetValue와 동일함
CS__Mov(PlayerID,SVA1,Output,Mask,RecoverMask)
: CA__Mov의 외부 함수
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CA__Mov와 동일함
CS__Movcpy(PlayerID,SVA1,Output,Size,Mask,RecoverMask,DestDistance)
: CA__Movcpy의 외부 함수
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CA__Movcpy와 동일함
CS__Read(PlayerID,iStrid,Index,Output,Mask)

: CA__Read의 외부 함수 (CA/CB/C13Print 전용)
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
iStrid : CAPrint → iStrid를 입력, CBPrint → iTblid를 입력, C13Print → SV54타입 변수를 입력 (CB[1],CB[2]를 대신함)

나머지는 모두 CA__Read와 동일함
CS__ReadX(PlayerID,iStrid,Index,Output,Multiplier,Mask)
: CA__ReadX의 외부 함수 (CA/CB/C13Print 전용)
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
iStrid : CAPrint → iStrid를 입력, CBPrint → iTblid를 입력, C13Print → SV54타입 변수를 입력 (CB[1],CB[2]를 대신함)

나머지는 모두 CA__ReadX와 동일함

197

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CS__ 함수는 CA,CB,CD,C13Print 외부에서 스트링 편집을 사용할 수 있는 함수입니다｡+.ﾟ
CS__SetMemoryX(PlayerID,iStrid,index,Value,Mask,utf8flag)
: CA__SetMemoryX의 외부 함수 (CA/CB/C13Print 전용)
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
iStrid : CAPrint → iStrid를 입력, CBPrint → iTblid를 입력, C13Print → SV54타입 변수를 입력 (CB[1],CB[2]를 대신함)

나머지는 모두 CA__SetMemoryX와 동일함
CS__SetColor(PlayerID,iStrid,index,ColorCode)
: CA__SetColor의 외부 함수 (CA/CB/C13Print 전용)
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
iStrid : CAPrint → iStrid를 입력, CBPrint → iTblid를 입력, C13Print → SV54타입 변수를 입력 (CB[1],CB[2]를 대신함)

나머지는 모두 CA__SetColor와 동일함
CS__SetLetter(PlayerID,iStrid,index,Letter,utf8flag)
: CA__SetLetter의 외부 함수 (CA/CB/C13Print 전용)
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
iStrid : CAPrint → iStrid를 입력, CBPrint → iTblid를 입력, C13Print → SV54타입 변수를 입력 (CB[1],CB[2]를 대신함)

나머지는 모두 CA__SetLetter와 동일함
CS__Encode(PlayerID,Dest,Source,Size,cp949flag) - ＃STRCtrig 필수
: CA__Encode의 외부 함수
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CA__Encode와 동일함
CS__ConvertColor(PlayerID,SVA1,ConvertData,MaskData,Start,End)
: CA__ConvertColor의 외부 함수
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)

나머지는 모두 CA__ConvertColor와 동일함
CS__ConvertLetter(PlayerID,SVA1,ConvertData,MaskData,Start,End,utf8flag)
: CA__ConvertLetter의 외부 함수
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CA__ConvertLetter과 동일함

198

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CS__ 함수는 CA,CB,CD,C13Print 외부에서 스트링 편집을 사용할 수 있는 함수입니다｡+.ﾟ
CS__ItoName(PlayerID,SVA1,TargetPlayer,Output,Init,ColorArr,FullWidth,utf8flag)
: CA__ItoName의 외부 함수
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CA__ItoName과 동일함
CS__ItoCustom(PlayerID,SVA1,Input,Output,Mask,Base,Length,Init,Sign,ColorArr,IndexArr,DataArr,ClearArr,utf8flag)

: CA__ItoCustom의 외부 함수
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CA__ItoCustom과 동일함

Ex) [예제 26-25] 참고
CS__lItoCustom(PlayerID,SVA1,Input,Output,Mask,Base,Length,Init,Sign,ColorArr,IndexArr,DataArr,ClearArr,utf8flag)

: CA__lItoCustom의 외부 함수
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CA__lItoCustom과 동일함
CS__SetHotkey(PlayerID,iTBLid,Value)
: CB__SetHotkey의 외부 함수 (CBPrint 전용)
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
iTblid : CBPrint의 iTblid를 입력 (CB[1]을 대신함)
나머지는 모두 CA__SetHotkey와 동일함
CS__SetButtonType(PlayerID,iTBLid,Value)
: CB__SetButtonType의 외부 함수 (CBPrint 전용)
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
iTblid : CBPrint의 iTblid를 입력 (CB[1]을 대신함)

나머지는 모두 CA__SetButtonType과 동일함

199

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CS__ 함수는 CA,CB,CD,C13Print 외부에서 스트링 편집을 사용할 수 있는 함수입니다｡+.ﾟ
CS__GetDisplayLine(PlayerID,Line,Output)
: CD__GetDisplayLine의 외부 함수 (CD/C13Print 전용)
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CD__GetDisplayLine과 동일함
CS__GetLine(PlayerID,DisplayLine,Output)
: CD__GetLine의 외부 함수 (CD/C13Print 전용)
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CD__GetLine과 동일함
CS__GetIndex(PlayerID,Index,Output)
: CD__GetIndex의 외부 함수 (CD/C13Print 전용)
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CD__GetIndex와 동일함
CS__GetIndex2(PlayerID,Line,Index,Output)
: CD__GetIndex2의 외부 함수 (CD/C13Print 전용)
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CD__GetIndex2와 동일함
CS__GetMask(PlayerID,Index,Output)
: CD__GetMask의 외부 함수 (CD/C13Print 전용)
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CD__GetMask와 동일함
CS__GetMask2(PlayerID,Line,Index,Output)

: CD__GetMask2의 외부 함수 (CD/C13Print 전용)
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CD__GetMask2와 동일함

200

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CS__ 함수는 CA,CB,CD,C13Print 외부에서 스트링 편집을 사용할 수 있는 함수입니다｡+.ﾟ
CS__InputVAX(PlayerID,SV54,Index,SVA1,Size,Mask,DestMask,Start,End,SourceDistance)
: CD__InputVAX의 외부 함수 (C13Print 전용)
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
SV54 : C13Print의 SV54타입 변수를 입력 (CB[1]을 대신함)
나머지는 모두 CD__InputVAX와 동일함
CS__InputMask(PlayerID,SV54,Line,Mask,Start,End)
: CD__InputMask의 외부 함수 (C13Print 전용)
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)

SV54 : C13Print의 SV54타입 변수를 입력 (CB[1]을 대신함)
나머지는 모두 CD__InputMask와 동일함
CS__Resize(PlayerID,SV54,Line,Status)
: CD__Resize의 외부 함수 (C13Print 전용)
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
SV54 : C13Print의 SV54타입 변수를 입력 (CB[1]을 대신함)
나머지는 모두 CD__Resize와 동일함
CS__ScanChat(PlayerID,SVA1,Offset,Size,Output,SkipInit)
: CD__ScanChat의 외부 함수 (CD/C13Print 전용)
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CD__ScanChat과 동일함
CS__ScanV(PlayerID,SVA1,Size,Variable,Output,Base,Sign)
: CD__ScanV의 외부 함수 (CD/C13Print 전용)
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)

나머지는 모두 CD__ScanV와 동일함
CS__ScanW(PlayerID,SVA1,Size,Variable,Output,Base,Sign)
: CD__ScanW의 외부 함수 (CD/C13Print 전용)
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CD__ScanW와 동일함

201

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CS__ 함수는 CA,CB,CD,C13Print 외부에서 스트링 편집을 사용할 수 있는 함수입니다｡+.ﾟ
CS__epdcpy(PlayerID,SVA1,Value,Mask,Start,End,Preserve)
: CA__epdcpy의 외부 함수
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CA__epdcpy와 동일함
CS__epdcmp(PlayerID,Dest,Source,Size,Mask,CFlag)
: CA__epdcmp의 외부 함수
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CA__epdcmp와 동일함
CS__GetName(PlayerID,SVA1,TargetPlayer,Output)
: CA__GetName의 외부 함수
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
나머지는 모두 CA__GetName과 동일함
CS__SetMaskX(PlayerID,SV54,index,Mask)
: CD__SetMaskX의 외부 함수 (C13Print 전용)
PlayerID : 생성 트리거의 체크 플레이어 (CAPrintPlayerID를 대신함)
SV54 : C13Print의 SV54타입 변수를 입력 (CB[1], CB[2]를 대신함)
나머지는 모두 CD__SetMaskX와 동일함

202

------------------------------------------------------------------------------------------

『 27장 : 비공유 데이터 전송 함수 (NSQC.py) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 27장의 함수를 사용하기 위해서는 반드시 NSQC.py를 플러그인에 추가해야함 ｡+.ﾟ
※ NSQC.py 플러그인 추가 방법
어셈블러 폴더의 py폴더 안의 NSQC.py을 eudplib의 plugins 폴더에 복사 후
플러그인 입력칸 (또는 .eds 파일)에
[NSQC]
<입력할 NSQC 명령어들>
입력 후 저장 한 뒤 EUDEditor2,3 등으로 컴파일 하면 된다.
※ 주의사항 : 반드시 Ctrig Assembler가 NSQC보다 위에 오게 컴파일 해야함
플러그인 입력창 입력예시
다른 플러그인들
[Ctrig Assembler v5.4]
[NSQC]
<NSQC명령어 등>
다른 플러그인들
순서로 입력해야함

※ NSQC 플러그인 사용방법 (NSQC 명령어 단락에 적어서 사용가능)
일반 비공유 오프셋 [개당 1/24마리 추가]

MemoryX(주소,연산자,값1,마스크) : [UnitID/유닛이름], 값2
→ MemoryX(주소,연산자,값1,마스크)이면 SetDeaths(해당 조건이 만족된 사람,Add,값2,UnitID); 실행
ex) MemoryX(0x512684,Exactly,2,0xFFFFFFFF) : 0, 1
→ P3의 스타에서 0x512684의 값이 2일경우 SetDeaths(P3,Add,1,0);
※ Memory(주소,연산자,값)이나 다른 일반조건도 사용가능함, UnitID입력시 0~65535 입력가능
Ex) [예제 27-1] 참고

키인식 [개당 1/24마리 추가]
[키/KeyDown(키)/KeyUp(키)/KeyPress(키)] : [UnitID/유닛이름], 값
→ 키 입력시 SetDeaths(누른사람,Add,값,UnitID); 실행
ex) X : 0, 1 → P3이 X를 누른경우 SetDeaths(P3,Add,1,0);
키 또는 KeyDown(키) : 키를 누른 순간 1회 인식
KeyUp(키) : 키를 떼는 순간 1회 인식
KeyPress(키) : 키를 누르는 동안 계속 인식
Ex) [예제 27-1] 참고

203

------------------------------------------------------------------------------------------

『 27장 : 비공유 데이터 전송 함수 (NSQC.py) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 27장의 함수를 사용하기 위해서는 반드시 NSQC.py를 플러그인에 추가해야함 ｡+.ﾟ
※ NSQC 플러그인 사용방법 (NSQC 명령어 단락에 적어서 사용가능)
마우스 인식 [개당 1/24마리 추가]
[MouseDown(키)/MouseUp(키)/MousePress(키)] : [UnitID/유닛이름], 값
→ 마우스 키 입력시 SetDeaths(누른사람,Add,값,UnitID); 실행
ex) MouseDown(L) : 0, 1 → P3이 마우스 왼쪽버튼을 누른경우 SetDeaths(P3,Add,1,0);
MouseDown(키) : 마우스 키를 누른 순간 1회 인식
MouseUp(키) : 마우스 키를 떼는 순간 1회 인식
MousePress(키) : 마우스 키를 누르는 동안 계속 인식
※ 마우스 키 목록 : L (왼쪽버튼), R (오른쪽버튼), M (휠버튼)
Ex) [예제 27-1] 참고
키인식 목록 (대소문자 상관 없음, \를 인식하고 싶으면 \\를 적어야함)

LBUTTON RBUTTON CANCEL MBUTTON XBUTTON1 XBUTTON2 BACK TAB
CLEAR ENTER NX5 SHIFT LCTRL LALT PAUSE CAPSLOCK
RALT JUNJA FINAL RCTRL ESC CONVERT NONCONVERT ACCEPT MODECHANGE
SPACE PGUP PGDN END HOME LEFT UP RIGHT DOWN ← 방향키
SELECT PRINTSCREEN EXECUTE SNAPSHOT INSERT DELETE HELP
0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ
LWIN RWIN 속성 SLEEP ; = , - . / ` ABNT_C1 ABNT_C2 [ \\ ] ' OEM_8
NUMPAD0 NUMPAD1 NUMPAD2 NUMPAD3 NUMPAD4 NUMPAD5 NUMPAD6 NUMPAD7
NUMPAD8 NUMPAD9 NUMPAD* NUMPAD+ SEPARATOR NUMPAD- NUMPAD. NUMPAD/

F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 F14 F15 F16 F17 F18 F19 F20 F21 F22 F23 F24
NUMLOCK SCROLL OEM_FJ_JISHO OEM_FJ_MASSHOU OEM_FJ_TOUROKU OEM_FJ_LOYA
OEM_FJ_ROYA
LSHIFT RSHIFT LCONTROL RCONTROL LMENU RMENU
BROWSER_BACK BROWSER_FORWARD BROWSER_REFRESH BROWSER_STOP
BROWSER_SEARCH BROWSER_FAVORITES BROWSER_HOME
VOLUME_MUTE VOLUME_DOWN VOLUME_UP
MEDIA_NEXT_TRACK MEDIA_PLAY_PAUSE MEDIA_PREV_TRACK MEDIA_STOP

LAUNCH_MAIL LAUNCH_MEDIA_SELECT LAUNCH_APP1 LAUNCH_APP2
OEM_AX OEM_102 ICO_HELP ICO_00 PROCESSKEY ICO_CLEAR PACKET OEM_RESET
OEM_JUMP OEM_PA1 OEM_PA2 OEM_PA3 OEM_WSCTRL OEM_CUSEL
OEM_ATTN OEM_FINISH OEM_COPY OEM_AUTO OEM_ENLW OEM_BACKTAB ATTN CRSEL
EXSEL EREOF PLAY ZOOM NONAME PA1 OEM_CLEAR _NONE_

204

------------------------------------------------------------------------------------------

『 27장 : 비공유 데이터 전송 함수 (NSQC.py) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 27장의 함수를 사용하기 위해서는 반드시 NSQC.py를 플러그인에 추가해야함 ｡+.ﾟ
※ NSQC 플러그인 사용방법 (NSQC 명령어 단락에 적어서 사용가능)
기타 비공유 조건 [개당 1/24마리 추가]
NotTyping : [UnitID/유닛이름], 값
→ 채팅 입력중(엔터키를 눌러서 아래에 채팅 치는 메세지 칸이 뜨는 상태)가 아닐때
SetDeaths(해당하는 사람,Add,값,UnitID); 실행

MouseMoved : [UnitID/유닛이름], 값
→ 마우스를 움직일때 SetDeaths(해당하는 사람,Add,값,UnitID); 실행

ScreenMoved : [UnitID/유닛이름], 값
→ 스크린을 움직일때 SetDeaths(해당하는 사람,Add,값,UnitID); 실행

WideScreen : [UnitID/유닛이름], 값
→ 와이드 스크린일때 SetDeaths(해당하는 사람,Add,값,UnitID); 실행

ex) NotTyping : 0, 1 → P3이 채팅 입력중이 아닐경우 SetDeaths(P3,Add,1,0);
Ex) [예제 27-1] 참고

마우스 로케이션 [개당 1마리 추가]
[마우스/Mouse] : 첫 사람 플레이어가 쓸 로케이션
→ 입력된 로케이션ID부터 사람수 만큼의 로케이션이 각각 순서대로 해당 플레이어의 마우스 좌표에 부착됨

ex) 마우스 : 0 → P1, P2, P3이 사람일경우 0번 → P1, 1번 → P2, 2번 → P3 로케이션이
해당 플레이어의 마우스 좌표에 부착됨
※ 마우스의 좌표가 맵 가장자리에 위치할 경우 약간의 오차가 발생할 수도 있음 (약 2px)
Ex) [예제 27-2] 참고

화면 로케이션 [개당 1마리 추가]
[화면/Screen] : 첫 사람 플레이어가 쓸 로케이션
→ 입력된 로케이션ID부터 사람수 만큼의 로케이션이 각각 순서대로 해당 플레이어의 화면 중앙 좌표에 부착됨

ex) 화면 : 0 → P1, P2, P3이 사람일경우 0번 → P1, 1번 → P2, 2번 → P3 로케이션이
해당 플레이어의 화면 중앙 좌표에 부착됨
※ 마우스의 좌표가 맵 가장자리에 위치할 경우 약간의 오차가 발생할 수도 있음 (약 2px)
※ 리마스터 와이드 스크린 및 오리지날 일반 스크린에 자동으로 맞춰서 화면 중심에 로케이션을 부착함
Ex) [예제 27-2] 참고

205

------------------------------------------------------------------------------------------

『 27장 : 비공유 데이터 전송 함수 (NSQC.py) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 27장의 함수를 사용하기 위해서는 반드시 NSQC.py를 플러그인에 추가해야함 ｡+.ﾟ
※ NSQC 플러그인 사용방법 (NSQC 명령어 단락에 적어서 사용가능)
xy [개당 1마리 추가]
조건(최소 1개이상); xy, 주소1 (, 주소2) : 유닛1 (, 유닛2)
→ 조건 만족시 주소의 값을 데스값으로 옮김
ex) Always(); xy, 0x58F500 : 0
→ (Always() 조건 만족시) P1의 0x58F500값→P1의 마린데스값, P2의 0x58F500값→P2의 마린데스값 ...
(전송 범위 = 0~X좌표 최대크기-1 + (0~Y좌표 최대크기-1)*65536 → 256x256맵 기준 0x1FFF1FFF)
ex) Always(); xy, 0x58F500, 0x58F504 : 0, 1 → (Always() 조건 만족시)
P1의 0x58F500(4)값→P1의 마린(고스트)데스값, P2의 0x58F500(4)값→P2의 마린(고스트)데스값 ...
(주소1 전송 범위 = 0~X좌표 최대크기-1, 주소2 전송 범위 = 0~Y좌표 최대크기-1
→ 256x256맵 기준 0x00001FFF, 0x00001FFF)

※ xy는 마우스 또는 화면좌표와 같은 맵 전체 범위의 좌표를 전송할때 사용하며,
값이 맵 경계에 붙었을 경우 오차가 발생할 수 있음 (상,좌,우 2px, 하 34px)
※ 유닛1(유닛2)에 i.0 입력시 NSQCVArray[i]에 값을 담음 (1.0 입력시 NSQCVArray[1])
Ex) [예제 27-3] 참고
Ex) [예제 27-4] 참고

val [개당 1마리 추가]
조건(최소 1개이상); val, 주소 : 유닛
→ 조건 만족시 주소의 값을 데스값으로 옮김

ex) Always(); val, 0x58F500 : 0 → (Always() 조건 만족시)
P1의 0x58F500값→P1의 마린데스값, P2의 0x58F500값→P2의 마린데스값 ...
(전송 범위 = 0 ~ 맵 X좌표 최대크기/2 * 맵 Y좌표 최대 크기/2 -1 → 256x256맵 기준 0x3FFFFF)
※ val은 일반 비공유 오프셋의 값을 정확한 크기로 전송할때 사용하며,
전송 범위 이내의 값은 오차 없이 전송됨
※ 유닛에 i.0 입력시 NSQCVArray[i]에 값을 담음 (1.0 입력시 NSQCVArray[1])
Ex) [예제 27-3] 참고

206

------------------------------------------------------------------------------------------

『 27장 : 비공유 데이터 전송 함수 (NSQC.py) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 27장의 함수를 사용하기 위해서는 반드시 NSQC.py를 플러그인에 추가해야함 ｡+.ﾟ
※ NSQC 플러그인 사용방법 (NSQC 명령어 단락에 적어서 사용가능)
dword [개당 2마리 추가]
조건(최소 1개이상); dword, 주소 (, 에러코드) : 유닛
→ 조건 만족시 주소의 값을 데스값으로 옮김, 조건 불만족시 데스값을 에러코드로 설정함
ex) Always(); dword, 0x58F500 : 0 → (Always() 조건 만족시)
P1의 0x58F500값→P1의 마린데스값, P2의 0x58F500값→P2의 마린데스값 …
(전송 범위 = 4바이트 전체, 최소 맵 크기 16x16, 오차 없이 전송됨,
에러코드 미입력시 0xFFFFFFFF로 입력됨)
※ 에러코드는 16진수(0x1234ABCD 등)로 입력해야함,
맵 시작시 SetMemory(주소,SetTo,에러코드)를 실행함
※ 유닛에 i.0 입력시 NSQCVArray[i]에 값을 담음 (1.0 입력시 NSQCVArray[1])
Ex) [예제 27-3] 참고

QC유닛 드래그 후 값 조작 버그 방지 [개당 1마리 추가, 기본 적용]
→ 기본적용됨 (QCDummy에 쓰레기값 항상 복사함)
-------------------------------------------------------------------------------------------------------------

조건 2개 이상 입력방법
조건1; 조건2; ... 조건n;
→ 명령어에 해당 조건을 추가함
ex) 0x58F450,Exactly,0; X : 0, 1 →
Memory(0x58F450,Exactly,0)이고 X키를 누를경우 SetDeaths(두 조건을 만족한 사람,Add,1,0);을 실행함

QCDebug (기본값: True)
디버그 옵션 + 안전장치를 킴
ex) QCDebug : false → QC디버그를 적용하지 않음

207

------------------------------------------------------------------------------------------

『 27장 : 비공유 데이터 전송 함수 (NSQC.py) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 27장의 함수를 사용하기 위해서는 반드시 NSQC.py를 플러그인에 추가해야함 ｡+.ﾟ
※ NSQC 플러그인 사용방법 (NSQC 명령어 단락에 적어서 사용가능)
NSQC 유닛 설정 (기본값)
QCUnit: Terran Valkyrie

QCLoc: 0
QCPlayer: 10
QC_XY: 128, 128
QCDummy : 227
QCUnit : NSQC용으로 사용할 유닛
QCLoc : NSQC유닛을 생성하는데 사용할 로케이션ID
QCPlayer NSQC유닛을 소유할 PlayerID
QC_XY : NSQC유닛을 생성할 XY좌표 (X좌표, Y좌표)

QCDummy : 버그방지용 QC유닛의 좌표값을 담을 데스값의 UnitID (안쓰는 데스값을 입력)

최종 유닛수 계산 방법
추가되는 QC유닛의 총합 = math.ceil(추가된 유닛수+1)*플레이어 수
ex) 사람 5명 × 키인식4개 + 마우스 로케이션 + val 1개 + dword 2개
= math.ceil(4/24+1+1*1+2*2 +1)*5 = 총 40마리 추가

208

------------------------------------------------------------------------------------------

『 27장 : 비공유 데이터 전송 함수 (NSQC.py) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 27장의 함수를 사용하기 위해서는 반드시 NSQC.py를 플러그인에 추가해야함 ｡+.ﾟ
※ NSQC.py 어셈블러 연계방법
StartCtrig의 NSQC 인자에 NSQCVArray 사용할 만큼의 수를 입력
(n입력시 NSQCVArray[n]까지 사용가능 → [NSQC]에 n.0까지 입력가능)
NSQC의 리턴값을 어셈블러 NSQCVArray에 담기 위해 설정하는 옵션
※ VA단위 전송은 NSQCSend, NSQCReceive를 사용해 4N바이트를 N+1틱내로 전송가능함

NSQCSend(PlayerID,SourceVA,Size,Mask,Offset,ErrorCode,ResetCond,ResetAct)
: 비공유 데이터를 VA단위로 전송하는 함수 (Size+1틱동안 전송함)
PlayerID : 생성 트리거의 체크 플레이어
SourceVA : 전송할 비공유 데이터 (VA입력, 상수/V 인덱스 가능)
Size : 전송할 크기 (상수/V 입력)
Mask : 전송할 값의 비트마스크 (미입력시 0xFFFFFFFF로 입력됨)
Offset : dword 명령어에서 입력한 주소값
ErrorCode : dword 명령어에서 입력한 에러코드값 (NSQC에서 미입력시 0xFFFFFFFF를 입력)
ResetCond : 전송을 시작할때 필요한 조건 (비공유 조건 삽입 가능)
ResetAct : 전송이 시작될때 실행할 액션
리턴값(Time) : 전송 완료까지 남은 시간 (틱단위, V)
※ 전송이 완료(Time이 0일때)되고 ResetCond를 만족시킬때 재전송 시작됨
NSQCReceive(PlayerID,DestVA,Size,TargetPlayer,NSQCIndex,ErrorCode,ErrorCheck,ResetCond,ResetAct)

: NSQCVArray로 전송된 데이터를 VA단위로 저장하는 함수 (Size틱동안 복사함)
PlayerID : 생성 트리거의 체크 플레이어
DestVA : 전송된 데이터를 받을 배열 (VA입력, 상수/V 인덱스 가능)
Size : 전송된 데이터를 저장할 크기 (상수/V 입력)
TargetPlayer : 전송된 데이터를 받을 플레이어ID (0~7중 선택, 해당 플레이어의 전송된 값을 복사함)
NSQCIndex : dword 명령어에서 입력한 NSQCVArray의 인덱스값 (NSQC에서 n.0입력시 n을 입력)
ErrorCode : dword 명령어에서 입력한 에러코드값 (NSQC에서 미입력시 0xFFFFFFFF를 입력)
{A,B} 형식으로 입력시 수신 도중 A값이 전송되면 B값으로 배열에 저장함
ErrorCheck : 복사 진행중 : 0, 복사 완료(오류X) : 1, 복사 완료(오류 O) : -1 리턴함 (V입력)

ResetCond : 전송을 시작할때 필요한 조건 (비공유 조건 삽입 불가)
ResetAct : 전송이 시작될때 실행할 액션
리턴값(Time) : 복사 완료까지 남은 시간 (틱단위, V)
※ 전송이 완료(Time이 0일때)되고 ResetCond를 만족시키며, 전송된 값이 ErrorCode가 아닐때 재전송 시작됨

Ex) [예제 27-5] 참고

209

------------------------------------------------------------------------------------------

『 28장 : 순수 총알생성 함수 (언리미터 필요) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 28장의 함수를 사용하기 위해서 언리미터의 사용을 권장합니다 ｡+.ﾟ
ScanInitSetting(PlayerID,Preserve)
: ScanSprite 사용전 필요한 스캔 초기화 함수
PlayerID : 생성 트리거의 체크 플레이어
Preserve : 0 입력시 1회만 실행함
Ex) [예제 28-1] 참고
※ 스캔 유닛의 크기를 0x0, 스캔 유닛의 에디터 어빌리티를 0x01CF로 변경함
ScanSprite(PlayerID,Number,Owner,RemoveScan,Location,Conditions,Actions,Preserve)
: 스캔(33번 유닛)으로 스프라이트 이미지를 생성하는 함수 (생성된 스프라이트의 높이는 4로 고정됨)
PlayerID : 생성 트리거의 체크 플레이어
Number : 생성할 이미지의 개수 (상수/V)
Owner : 생성된 스캔 유닛의 소유 플레이어
RemoveScan : 1입력시 RemoveUnit(33,Owner) 액션을 추가함 (스캔 제거 액션)
Location : 스캔 유닛의 생성에 사용될 로케이션 ("로케이션 이름"으로 입력시 해당 로케이션에서 생성됨,

{"로케이션 이름", X(상수/V), Y(상수/V)} 로 입력시 해당 로케이션의 좌표를 X, Y로 설정 후 생성함
Condtions : 트리거 실행에 필요한 조건
Actions : 트리거 실행에 추가할 액션 (로케이션 X,Y좌표 설정 후 Actions 단락 실행함)
Preserve : 0 입력시 1회만 실행함
Ex) [예제 28-1] 참고 / ※ 각 인자에 중간연산자 사용 불가능함
※ Conditions와 Actions 모두 CTriggerX 형식으로 입력
UnitSprite(PlayerID,Owner,UnitId,Height,Time,Location,Conditions,Actions,Preserve)
: 스프라이트 표시용 유닛을 생성하는 함수 (해당유닛의 구조오프셋+0xE4를 0으로 고정하면 드래그방지 적용됨)

PlayerID : 생성 트리거의 체크 플레이어
Owner : 생성된 유닛의 소유 플레이어
UnitId : 생성할 유닛의 유닛Id (상수/V)
Height : 생성할 유닛의 높이 (상수/V)
Time : 생성할 유닛의 지속시간 (상수/V, 미입력시 지속 시간제한 없음, "X"입력시 Nextptr 연산 제외함)
Location : 유닛의 생성에 사용될 로케이션 ("로케이션 이름"으로 입력시 해당 로케이션에서 생성됨,
{"로케이션 이름", X(상수/V), Y(상수/V)} 로 입력시 해당 로케이션의 좌표를 X, Y로 설정 후 생성함
Condtions : 트리거 실행에 필요한 조건
Actions : 트리거 실행에 추가할 액션 (로케이션 X,Y좌표 설정 후 Actions 단락 실행함)
Preserve : 0 입력시 1회만 실행함
Ex) [예제 28-1] 참고 / ※ 각 인자에 중간연산자 사용 불가능함, 유닛의 구조오프셋은 NRet[1]에 저장됨
※ Conditions와 Actions 모두 CTriggerX 형식으로 입력
210

------------------------------------------------------------------------------------------

『 28장 : 순수 총알생성 함수 (언리미터 필요) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 28장의 함수를 사용하기 위해서 언리미터의 사용을 권장합니다 ｡+.ﾟ
RecallSprite(PlayerID,Owner,UnitId,Location,X,Y,Conditions,Actions,Preserve)
: 리콜로 스프라이트 이미지를 생성하는 함수 (아비터로 리콜을 시전하는 방식, 0틱연산 불가)
PlayerID : 생성 트리거의 체크 플레이어
Owner : 생성된 아비터 유닛의 소유 플레이어
UnitId : 아비터 유닛의 유닛Id
Location : 아비터 유닛의 생성에 사용될 로케이션 ("로케이션 이름"으로 입력시 해당 로케이션에서 생성됨,
{"로케이션 이름", X(상수/V), Y(상수/V)} 로 입력시 해당 로케이션의 좌표를 X, Y로 설정 후 생성함
X : 리콜을 생성할 X좌표 (상수/V)
Y : 리콜을 생성할 Y좌표 (상수/V)
Condtions : 트리거 실행에 필요한 조건
Actions : 트리거 실행에 추가할 액션 (로케이션 X,Y좌표 설정 후 Actions 단락 실행함)
Preserve : 0 입력시 1회만 실행함
Ex) [예제 28-1] 참고 / ※ 각 인자에 중간연산자 사용 불가능함, 리콜 마나를 0으로 설정하는 것을 권장
※ Conditions와 Actions 모두 CTriggerX 형식으로 입력
BulletInitSetting(PlayerID,UnitId,Weapon,Flingy,Sprite,Image,Script,Color,Damage,DamageUp,UpgradeID
,BulletNumber,DamageType,Special,Splash,Preserve)
: 스프라이트 표시용 유닛을 생성하는 함수 (해당유닛의 구조오프셋+0xE4를 0으로 고정하면 드래그방지 적용됨)
PlayerID : 생성 트리거의 체크 플레이어
UnitId : 총알 생성용 유닛의 유닛Id ({유닛Id, 유닛의 비행정보Id, 유닛의 스프라이트Id}로 입력, 고정 항목)
{트랩류 유닛Id(203~213), 유닛의 비행정보Id, 유닛의 스프라이트Id, 1} 입력시 반 공중 유닛으로 생성됨
(CreateSprite 등에서 생성위치에 유닛의 존재여부, 높이와 무관하게 정확하게 생성할때 필요함)
Weapon : 총알 생성에 사용할 무기Id (유닛의 무기로 설정됨, 고정 항목)
Flingy : 총알 생성용 유닛의 비행정보 (고정 항목)
Sprite : 총알 생성용 유닛의 비행정보의 스프라이트 (고정 항목)
Image : Sprite에 연결된 이미지
Script : Image에 적용할 스크립트 (395 : 지속데미지(럴커), 235/242 등의 총알스크립트 : 단발 데미지)
Color : Image에 적용할 화면출력 정보 기능
Damage : 총알의 데미지 (Script 395(럴커)는 지속 데미지, 나머지 총알류는 총알 폭발시 단일 데미지)
DamageUp : 총알의 추가 데미지
UpgrageID : 무기의 업그레이드Id
BulletNumber : 총알 수 (2 입력시 한번에 2발씩 생성됨, 나머진 1발)

DamageType : 데미지형식 (0 : 알수없음, 1 : 폭발형, 2 : 진동형, 3 : 노멀, 4 : 방어력 무시)
Special : 폭발형 타입 (0 : 없음, 1 : 기본, 2 : 원방형, 3 : 일방형, … 등)
Splash : 스플레쉬 범위 ({안쪽,중간,외각}으로 입력)
Preserve : 0 입력시 1회만 실행함
Ex) [예제 28-1] 참고 / ※ 모든 항목들은 상수로 입력해야함, 고정 항목은 따로 변경할 수 없는 항목임211

------------------------------------------------------------------------------------------

『 28장 : 순수 총알생성 함수 (언리미터 필요) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 28장의 함수를 사용하기 위해서 언리미터의 사용을 권장합니다 ｡+.ﾟ
CreateBullet(PlayerID,Owner,UnitId,Height,Angle,Speed,Time,Location,Conditions,Actions,Preserve)
: 유닛 생성으로 순수 총알을 생성하는 함수 (생성된 총알은 언리미터의 적용을 받음)
PlayerID : 생성 트리거의 체크 플레이어
Owner : 생성된 총알 생성용 유닛의 소유 플레이어
UnitId : 생성된 유닛의 유닛Id
Height : 생성된 유닛의 높이 (상수/V)
Angle : 총알을 발사 시킬 각도 (0~255 중 입력, V입력시 256의 배수로 입력해야함)
Speed : 총알의 속도 (상수/V, 입력값의 음수로 입력됨)
Time : 총알의 지속시간 (상수/V, 0~255중 입력)
Location : 유닛의 생성에 사용될 로케이션 ("로케이션 이름"으로 입력시 해당 로케이션에서 생성됨,
{"로케이션 이름", X(상수/V), Y(상수/V)} 로 입력시 해당 로케이션의 좌표를 X, Y로 설정 후 생성함
Condtions : 트리거 실행에 필요한 조건
Actions : 트리거 실행에 추가할 액션 (로케이션 X,Y좌표 설정 후 Actions 단락 실행함)
Preserve : 0 입력시 1회만 실행함

Ex) [예제 28-1] 참고 / ※ 각 인자에 중간연산자 사용 불가능함, 투사방식 9번을 사용함,
벌쳐에 자폭명령(135)을 내리는 방식으로 총알을 생성함, 실행시 벌쳐 이미지의 스크립트가 86으로 바뀜
※ Conditions와 Actions 모두 CTriggerX 형식으로 입력
CreateBulletTarget(PlayerID,Owner,UnitId,Height,Angle,Speed,Time,Location,X,Y,Conditions,Actions1,Actions2,Preserve)

: 유닛 생성으로 순수 총알을 생성하는 함수 (X,Y 좌표로 발사 방향이 정해짐)

PlayerID : 생성 트리거의 체크 플레이어
Owner : 생성된 총알 생성용 유닛의 소유 플레이어
UnitId : 생성된 유닛의 유닛Id
Height : 생성된 유닛의 높이 (상수/V)

Angle : 총알 발사 회전값 (상수/V, 정방향 128, 역방향 0, 나머지는 2갈래로 발사됨)
Speed : 총알의 속도 (상수/V, 입력값의 음수로 입력됨)
Time : 총알의 지속시간 (상수/V, 0~255중 입력)
Location : 유닛의 생성에 사용될 로케이션 ("로케이션 이름"으로 입력시 해당 로케이션에서 생성됨,
{"로케이션 이름", X(상수/V), Y(상수/V)} 로 입력시 해당 로케이션의 좌표를 X, Y로 설정 후 생성함
X : 목표 지점의 X좌표 (상수/V)
Y : 목표 지점의 Y좌표 (상수/V)
Condtions : 트리거 실행에 필요한 조건
Actions1 : 트리거 실행에 추가할 액션 (유닛생성 직전) / Actions2 : 트리거 실행에 추가할 액션 (발사직전)
Preserve : 0 입력시 1회만 실행함
Ex) [예제 28-1] 참고 / ※ 각 인자에 중간연산자 사용 불가능함, 투사방식 9번을 사용함,
벌쳐에 자폭명령(135)을 내리는 방식으로 총알을 생성함, 실행시 벌쳐 이미지의 스크립트가 86으로 바뀜
총알 생성용 유닛 생성 1틱후 총알이 발사됨 / ※ Conditions와 Actions1,2 모두 CTriggerX 형식으로 입력
212

------------------------------------------------------------------------------------------

『 28장 : 순수 총알생성 함수 (언리미터 필요) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 28장의 함수를 사용하기 위해서 언리미터의 사용을 권장합니다 ｡+.ﾟ
CreateStorm(PlayerID,Owner,UnitId,Height,Angle,ImageID,Time,Location,Conditions,Actions,Preserve)
: 유닛 생성으로 순수 스톰을 생성하는 함수 (생성된 총알은 언리미터의 적용을 받음)
PlayerID : 생성 트리거의 체크 플레이어
Owner : 생성된 스톰 생성용 유닛의 소유 플레이어
UnitId : 생성된 유닛의 유닛Id
Height : 생성된 유닛의 높이 (상수/V)
Angle : 스톰을 생성 시킬 각도 (0~255 중 입력, V입력시 256의 배수로 입력해야함)
ImageID : 총알의 이미지Id (함수 실행 후 해당 이미지의 스크립트가 236으로 바뀜)
Time : 스톰의 지속시간 (상수/V, 0~255중 입력)
Location : 유닛의 생성에 사용될 로케이션 ("로케이션 이름"으로 입력시 해당 로케이션에서 생성됨,
{"로케이션 이름", X(상수/V), Y(상수/V)} 로 입력시 해당 로케이션의 좌표를 X, Y로 설정 후 생성함
Condtions : 트리거 실행에 필요한 조건
Actions : 트리거 실행에 추가할 액션 (로케이션 X,Y좌표 설정 후 Actions 단락 실행함)
Preserve : 0 입력시 1회만 실행함

Ex) [예제 28-1] 참고 / ※ 각 인자에 중간연산자 사용 불가능함, 투사방식 3번을 사용함,
벌쳐에 자폭명령(135)을 내리는 방식으로 스톰을 생성함, 실행시 벌쳐 이미지의 스크립트가 86으로 바뀜
※ Conditions와 Actions 모두 CTriggerX 형식으로 입력
CreateSprite(PlayerID,Owner,UnitId,Height,Angle,Speed,Location,Conditions,Actions,Preserve)
: 유닛 생성으로 순수 총알(영구 스프라이트)을 생성하는 함수 (생성된 총알은 언리미터의 적용을 받음)
PlayerID : 생성 트리거의 체크 플레이어
Owner : 생성된 총알 생성용 유닛의 소유 플레이어
UnitId : 생성된 유닛의 유닛Id
Height : 생성된 유닛의 높이 (상수/V)

Angle : 총알을 발사 시킬 각도 (0~255 중 입력, V입력시 256의 배수로 입력해야함)
Speed : 총알의 속도 (상수/V, 입력값의 음수로 입력됨)
Time : 총알의 지속시간 (상수/V, 0~255중 입력)
Location : 유닛의 생성에 사용될 로케이션 ("로케이션 이름"으로 입력시 해당 로케이션에서 생성됨,
{"로케이션 이름", X(상수/V), Y(상수/V)} 로 입력시 해당 로케이션의 좌표를 X, Y로 설정 후 생성함
Condtions : 트리거 실행에 필요한 조건
Actions : 트리거 실행에 추가할 액션 (로케이션 X,Y좌표 설정 후 Actions 단락 실행함)
Preserve : 0 입력시 1회만 실행함
Ex) [예제 28-1] 참고 / ※ 각 인자에 중간연산자 사용 불가능함, 투사방식 7번을 사용함,
벌쳐에 자폭명령(135)을 내리는 방식으로 총알을 생성함, 실행시 벌쳐 이미지의 스크립트가 86으로 바뀜
생성된 총알은 영구 스프라이트로 작동하며, 395(럴커) 스크립트를 제외하면 데미지를 입히지 않음
※ Conditions와 Actions 모두 CTriggerX 형식으로 입력
※ 주의 : 총알 생성은 0틱연산을 사용할 수 없음 (총알 생성용 유닛이 트리거 단락 순환 후 총알을 생성함)
213

------------------------------------------------------------------------------------------

『 28장 : 순수 총알생성 함수 (언리미터 필요) 』

-----------------------------------------------------------------------------------------SetImageColor(ImageID,Code)
TSetImageColor(ImageID,Code) - 변수 삽입 가능
: 화면출력 정보 기능 설정 함수
ImageID : 적용할 이미지Id

Code : 화면 출력정보 기능Id
SetImageScript(ImageID,ScriptID)
TSetImageScript(ImageID,ScriptID) - 변수 삽입 가능
: 이미지 스크립트ID 설정 함수
ImageID : 적용할 이미지Id
ScriptID : 스크립트Id
SetImageAllScript(ImageID,Value)
TSetImageAllScript(ImageID,Value) - 변수 삽입 가능
: 이미지 일반정보 - 모든 스크립트 설정 함수
ImageID : 적용할 이미지Id
Value : 1 입력시 모든 스크립트에 체크함, 0 입력시 체크 안함
SetRecallImage(ImageID)
TSetRecallImage(ImageID) - 변수 삽입 가능
: 리콜 스프라이트(379)의 이미지 설정 함수

ImageID : 설정할 이미지Id
SetScanImage(ImageID)
TSetScanImage(ImageID) - 변수 삽입 가능
: 스캔 스프라이트(380)의 이미지 설정 함수
ImageID : 설정할 이미지Id
SetSpriteImage(SpriteID,ImageID)
TSetSpriteImage(SpriteID,ImageID) - 변수 삽입 가능

: 스프라이트의 이미지 설정 함수
SpriteID : 적용할 스프라이트Id
ImageID : 설정할 이미지Id

214

------------------------------------------------------------------------------------------

『 28장 : 순수 총알생성 함수 (언리미터 필요) 』

-----------------------------------------------------------------------------------------SetBulletDamage(WeaponID,Type,Damage)
TSetBulletDamage(WeaponID,Type,Damage) - 변수 삽입 가능
: 총알의 공격력 설정 함수
WeaponId : 적용할 무기Id
Type : 액션 연산자 Add/Subtract/SetTo
Damage : 적용할 공격력 값

SetBulletDamageUp(WeaponID,Type,Damage)
TSetBulletDamageUp(WeaponID,Type,Damage) - 변수 삽입 가능
: 총알의 추가공격력 설정 함수
WeaponId : 적용할 무기Id
Type : 액션 연산자 Add/Subtract/SetTo
Damage : 적용할 추가공격력 값
SetBulletNumber(WeaponID,Number)
TSetBulletNumber(WeaponID,Number) - 변수 삽입 가능
: 총알의 투사체 수 설정 함수
WeaponId : 적용할 무기Id
Number : 2 입력시 2발씩, 나머지 1발씩 적용
SetBulletUpgrade(WeaponID,UpgradeID)
TSetBulletUpgrade(WeaponID,UpgradeID) - 변수 삽입 가능
: 총알의 무기 업그레이드 설정 함수
WeaponId : 적용할 무기Id

UpgradeID : 설정할 업그레이드Id
SetBulletDamageType(WeaponID,DamageType)
TSetBulletDamageType(WeaponID,DamageType) - 변수 삽입 가능
: 총알의 데미지 형식 설정 함수
WeaponId : 적용할 무기Id
DamageType : 설정할 데미지 형식Id
SetBulletDamageSpecial(WeaponID,DamageSpecial)
TSetBulletDamageSpecial(WeaponID,DamageSpecial) - 변수 삽입 가능
: 총알의 폭발형 타입 설정 함수
WeaponId : 적용할 무기Id
DamageSpecial : 설정할 폭발형 타입Id
215

------------------------------------------------------------------------------------------

『 28장 : 순수 총알생성 함수 (언리미터 필요) 』

-----------------------------------------------------------------------------------------SetBulletSpin(WeaponID,Type,Angle)
TSetBulletSpin(WeaponID,Type,Angle) - 변수 삽입 가능
: 총알의 발사회전값 설정 함수
WeaponId : 적용할 무기Id
Type : 액션 연산자 Add/Subtract/SetTo
Angle : 설정할 발사회전값

SetBulletSplash100(WeaponID,Type,Radius)
TSetBulletSplash100(WeaponID,Type,Radius) - 변수 삽입 가능
: 총알의 스플레쉬 범위(안쪽) 설정 함수
WeaponId : 적용할 무기Id
Type : 액션 연산자 Add/Subtract/SetTo
Radius : 설정할 스플레쉬 범위 (32당 1칸)
SetBulletSplash50(WeaponID,Type,Radius)
TSetBulletSplash50(WeaponID,Type,Radius) - 변수 삽입 가능
: 총알의 스플레쉬 범위(중간) 설정 함수
WeaponId : 적용할 무기Id
Type : 액션 연산자 Add/Subtract/SetTo
Radius : 설정할 스플레쉬 범위 (32당 1칸)
SetBulletSplash25(WeaponID,Type,Radius)
TSetBulletSplash25(WeaponID,Type,Radius) - 변수 삽입 가능
: 총알의 스플레쉬 범위(외각) 설정 함수

WeaponId : 적용할 무기Id
Type : 액션 연산자 Add/Subtract/SetTo
Radius : 설정할 스플레쉬 범위 (32당 1칸)
SetDimension(UnitId,Value)
TSetDimension(UnitId,Value) - 변수 삽입 가능
: 유닛의 생산크기 설정 함수
UnitId : 적용할 유닛Id
Value : 설정할 생산크기 (32당 1칸, Y좌표(2)*65536+X좌표(2) 꼴로 삽입)

216

------------------------------------------------------------------------------------------

『 29장 : 파일 I/O 및 CGRP 삽입 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 29장의 함수 사용시 반드시 STRCtrig를 적용해야 합니다. ｡+.ﾟ
f_GetVArrptr(PlayerID,Size) - ＃STRCtrig 필수
: VArray를 파일 삽입식으로 생성하는 함수
PlayerID : 생성 트리거의 체크 플레이어
Size : 생성할 VArray의 크기 (N입력시 0~N-1까지 index 사용가능)
Ex) [예제 29-1] 참고
※ 생성된 VArray의 Value 값은 모두 0으로 채워짐
f_GetWArrptr(PlayerID,Size) - ＃STRCtrig 필수
: WArray를 파일 삽입식으로 생성하는 함수
PlayerID : 생성 트리거의 체크 플레이어
Size : 생성할 WArray의 크기 (N입력시 0~N-1까지 index 사용가능)
Ex) [예제 29-1] 참고
※ 생성된 WArray의 Value 값은 모두 0으로 채워짐
f_GetSVArrptr(PlayerID,Size,Number) - ＃STRCtrig 필수
: SVArray를 파일 삽입식으로 생성하는 함수
PlayerID : 생성 트리거의 체크 플레이어
Number : 구조체 변수 내부의 연산할 변수 줄 수 (1~32 까지 입력 가능)
Size : 생성할 SVArray의 크기 (N입력시 0~N-1까지 index 사용가능)
Ex) [예제 29-1] 참고
※ 생성된 SVArray의 Value 값은 모두 0으로 채워짐
f_GetFileVArrptrN(PlayerID,FileArray,ElementSize,Repeat,LoadCheck) - ＃STRCtrig 필수
: VArray를 파일생성 후 파일 삽입식으로 생성하는 함수 (FileArray의 값을 Value에 저장함)
PlayerID : 생성 트리거의 체크 플레이어
FileArray : VArray에 저장할 값의 배열 ({값1,값2, … } 식으로 입력)
ElementSize : FileArray의 개별 원소의 크기 (1, 2, 4 중 선택, 각각 byte/word/dword로 입력됨)
Repeat : 반복 생성할 횟수 (N입력시 N번 반복 생성함)
LoadCheck : 1입력시 파일이 성공적으로 로드되었는지 체크함
Ex) [예제 29-1] 참고
※ 생성된 VArray는 FileArray로 값이 채워지는 길이만큼 생성됨

217

------------------------------------------------------------------------------------------

『 29장 : 파일 I/O 및 CGRP 삽입 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 29장의 함수 사용시 반드시 STRCtrig를 적용해야 합니다. ｡+.ﾟ
f_GetFileWArrptrN(PlayerID,FileArray,ElementSize,Repeat,LoadCheck) - ＃STRCtrig 필수
: WArray를 파일생성 후 파일 삽입식으로 생성하는 함수 (FileArray의 값을 Value에 저장함)
PlayerID : 생성 트리거의 체크 플레이어
FileArray : WArray에 저장할 값의 배열 ({값1,값2, … } 식으로 입력)
ElementSize : FileArray의 개별 원소의 크기 (1, 2, 4 중 선택, 각각 byte/word/dword로 입력됨)
Repeat : 반복 생성할 횟수 (N입력시 N번 반복 생성함)
LoadCheck : 1입력시 파일이 성공적으로 로드되었는지 체크함
Ex) [예제 29-1] 참고
※ 생성된 WArray는 FileArray로 값이 채워지는 길이만큼 생성됨
f_GetFileSVArrptrN(PlayerID,FileArray,ElementSize,Number,Repeat,LoadCheck) - ＃STRCtrig 필수
: SVArray를 파일생성 후 파일 삽입식으로 생성하는 함수 (FileArray의 값을 Value에 저장함)
PlayerID : 생성 트리거의 체크 플레이어
FileArray : SVArray에 저장할 값의 배열 ({값1,값2, … } 식으로 입력)
ElementSize : FileArray의 개별 원소의 크기 (1, 2, 4 중 선택, 각각 byte/word/dword로 입력됨)
Repeat : 반복 생성할 횟수 (N입력시 N번 반복 생성함)
LoadCheck : 1입력시 파일이 성공적으로 로드되었는지 체크함
Ex) [예제 29-1] 참고
※ 생성된 SVArray는 FileArray로 값이 채워지는 길이만큼 생성됨
FArr(Fileptr,Index,Player)
: File타입(Void 포함) 메모리 배열의 주소를 입력하는 함수
Fileptr : 배열 헤더 (f_GetFileptr, f_GetVoidptr등의 리턴값 입력)
Index : 배열의 인덱스 : 상수 or 변수 입력
Player : 배열의 Player 입력 (기본값 "X")
ex) FArr(Arr1,0) → FArr1[0]의 주소를 반환함 / Ex) [예제 29-2] 참고
FArr(Arr1,V(0x10),P1) → P1의 FArr1[V(0x10)]의 주소를 반환함
※ FArr의 인덱스는 0부터 시작함 / 상수 인덱스 : Mem 타입 반환 / 변수 인덱스 : Arr 타입 반환

218

------------------------------------------------------------------------------------------

『 29장 : 파일 I/O 및 CGRP 삽입 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 29장의 함수 사용시 반드시 STRCtrig를 적용해야 합니다. ｡+.ﾟ
f_GetVoidptr(PlayerID,Size) - ＃STRCtrig 필수
: Array를 파일 삽입식으로 생성하는 함수 (빈칸 없는 순수 공메모리를 생성함)
PlayerID : 생성 트리거의 체크 플레이어
Size : 생성할 공메모리의 크기 (bytes 단위, 0x970의 배수로 생성됨)
Ex) [예제 29-2] 참고
※ 생성된 공메모리 배열은 FArr로 Array처럼 사용가능 (ConvertArr 필요 없음)
f_GetFileptr(PlayerID,FileName,LoadCheck) - ＃STRCtrig 필수
: AbsolutePath에 이름이 FileName인 파일을 맵에 삽입하는 함수 (파일내용이 그대로 복사됨)
PlayerID : 생성 트리거의 체크 플레이어
FileName : 로드할 파일의 이름 (절대 경로 내부에 해당 파일이 존재해야함)
LoadCheck : 1입력시 파일이 성공적으로 로드되었는지 체크함
Ex) [예제 29-2] 참고
f_GetFileptrN(PlayerID,FileName,Repeat,LoadCheck) - ＃STRCtrig 필수
: AbsolutePath에 이름이 FileName인 파일을 맵에 삽입하는 함수 (반복 복사 가능)
PlayerID : 생성 트리거의 체크 플레이어
FileName : 로드할 파일의 이름 (절대 경로 내부에 해당 파일이 존재해야함)
Repeat : 반복 생성할 횟수 (N입력시 N번 반복 생성함)
LoadCheck : 1입력시 파일이 성공적으로 로드되었는지 체크함
Ex) [예제 29-2] 참고

219

------------------------------------------------------------------------------------------

『 29장 : 파일 I/O 및 CGRP 삽입 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 29장의 함수 사용시 반드시 STRCtrig를 적용해야 합니다. ｡+.ﾟ
SaveFileArr(FileArray,ElementSize,FileName)
: FileArray의 값으로 AbsolutePath에 파일을 생성하는 함수
FileArray : 파일에 저장할 값의 배열 ({값1,값2, … } 식으로 입력)
ElementSize : FileArray의 개별 원소의 크기 (1, 2, 4 중 선택, 각각 byte/word/dword로 입력됨)
FileName : 생성할 파일의 이름 (절대 경로 내부에 입력한 파일명으로 생성함)
Ex) [예제 29-3] 참고
f_GetFileArrptr(PlayerID,FileArray,ElementSize,LoadCheck) - ＃STRCtrig 필수
: FileArray의 값으로 파일생성 후 파일을 맵에 삽입하는 함수
PlayerID : 생성 트리거의 체크 플레이어
FileArray : 파일에 저장할 값의 배열 ({값1,값2, … } 식으로 입력)
ElementSize : FileArray의 개별 원소의 크기 (1, 2, 4 중 선택, 각각 byte/word/dword로 입력됨)
LoadCheck : 1입력시 파일이 성공적으로 로드되었는지 체크함
Ex) [예제 29-2] 참고
※ 생성되는 파일의 이름은 SCTRIGASMFILE0000 ~ FFFF로 자동 할당됨
f_GetFileArrptrN(PlayerID,FileArray,ElementSize,Repeat,LoadCheck) - ＃STRCtrig 필수
: FileArray의 값으로 파일생성 후 파일을 맵에 삽입하는 함수 (반복 복사 가능)
PlayerID : 생성 트리거의 체크 플레이어
FileArray : 파일에 저장할 값의 배열 ({값1,값2, … } 식으로 입력)
ElementSize : FileArray의 개별 원소의 크기 (1, 2, 4 중 선택, 각각 byte/word/dword로 입력됨)
Repeat : 반복 생성할 횟수 (N입력시 N번 반복 생성함)
LoadCheck : 1입력시 파일이 성공적으로 로드되었는지 체크함
Ex) [예제 29-2] 참고
※ 생성되는 파일의 이름은 SCTRIGASMFILE0000 ~ FFFF로 자동 할당됨

220

------------------------------------------------------------------------------------------

『 29장 : 파일 I/O 및 CGRP 삽입 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 29장의 함수 사용시 반드시 STRCtrig를 적용해야 합니다. ｡+.ﾟ
f_GetFileSize(FileName)
: AbsolutePath에 이름이 FileName인 파일의 크기를 구하는 함수
FileName : 로드할 파일의 이름 (절대 경로 내부에 해당 파일이 존재해야함)
리턴값 : 로드된 파일의 크기
Ex) [예제 29-3] 참고
f_GetTRIGptrN(PlayerID,FileName,Repeat,LoadCheck) - ＃STRCtrig 필수
: AbsolutePath에 이름이 FileName인 파일을 맵에 삽입하는 함수 (파일 내용을 Ctrig로 받음)
PlayerID : 생성 트리거의 체크 플레이어
FileName : 로드할 파일의 이름 (절대 경로 내부에 해당 파일이 존재해야함)
Repeat : 반복 생성할 횟수 (N입력시 N번 반복 생성함)
LoadCheck : 1입력시 파일이 성공적으로 로드되었는지 체크함
Ex) [예제 29-3] 참고
※ 로드한 파일의 내용을 Ctrig로 인식하여 파일 내용을 맵 실행시 패치해서 로드함
※ 파일 내용은 트리거 배열의 형태로 구성되야 하며, 파일 크기는 0x970의 배수여야함
※ Label은 Disabled 처리해야하며, Ctrig문법에서 index는 CurrentIndex("X")만 사용가능함

221

------------------------------------------------------------------------------------------

『 29장 : 파일 I/O 및 CGRP 삽입 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CGRP 사용시 반드시 UnlimiterX.py를 맵에 적용해야 합니다. ｡+.ﾟ
※ 사진변환기(CS_Photo.exe) 사용법 - 2. 이미지를 그래픽 데이터로 변환 (CGRP)

← 시작화면에서 2를 입력후 엔터

CS_Photo는 8비트 .bmp파일을 .CGRP파일로 변환함
(출력된 파일을 f_GetFileptr등으로 삽입 후 CreateBullet류 함수로 해당 좌표에 점을 찍는다)
.CGRP 파일의 구조 :
-------------- 헤더 (16bytes) -------------4bytes 전체 점의 개수
4bytes 밑변의 길이(X) (점 단위, 실제 가로 크기 = 밑변의 길이 * 점의 가로 크기px)

4bytes 높이의 길이(Y) (점 단위, 실제 세로 크기 = 높이의 길이 * 점의 세로 크기px)
2bytes 점의 가로 크기 / 2bytes 점의 세로 크기 (px단위, 기본값 각각 3)
-------------- 내용 (4*X*Y bytes) --------(한 점당 총 4bytes, 색상은 233번 이미지(뉴크닷)을 기준으로함)
Red flag (화면출력 0번) : 1
Green flag (화면출력 13번) : 2
Blue flag (화면출력 16번) : 4
White flag (화면출력 17번) : 8 → 지속적으로 갱신해야함

EMP effect flag (화면출력 8번) : 16, 잔상만 보임
Indigo flag (화면출력 12번) : 32, 리마스터에서는 안보임
Box flag (화면출력 15번) : 64, 한 점당 크기 가로세로 각각 5px
Fill flag : 128, 해당 좌표에 점을 찍으면 true, 아니면 false
Black Stack (화면출력 10번) : (0~7)*256, 흑색 명암조절 0~7단계 (음영표현)
Red Stack (화면출력 6번) : (0~7)*2048, 적색 명암조절 0~7단계 (색조합, 실제로는 3단계까지 사용)
ImageID : ImageID*16384 (10bit), 해당 점에 출력할 이미지의 Id

Height : Height*16777216 (1byte), 해당 점에 출력할 이미지의 높이
---------------------------------------------

※ 색 조합시 Black Stack > Red Stack > 베이스 색상 순으로 높이를 설정해야함
리마스터 사용시 쉐도우 스택킹 On + 실시간 조명 Off로 옵션을 설정해야함
222

------------------------------------------------------------------------------------------

『 29장 : 파일 I/O 및 CGRP 삽입 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CGRP 사용시 반드시 UnlimiterX.py를 맵에 적용해야 합니다. ｡+.ﾟ
※ 사진변환기(CS_Photo.exe) 사용법 - 2-1. 단일색상 & 단일높이 (Mask01.ACT)
이미지를 단일 색상 및 단일 높이로 출력할 때 쓰는 모드입니다.

1. 포토샵으로 변환할 이미지를 불러온 뒤 편집 후 CGRP_ACT폴더 안의 Mask01.ACT로
인덱스 색상 팔레트를 적용한다. (흰색이 칠하는 부분, 검정이 투명색)
2. 확장자를 .Bmp, BMP 옵션에서 8비트로 설정 후 CS_Photo.exe가 있는 폴더에 저장한다.
3. CS_Photo.exe를 더블클릭해서 실행한다.

Ex) [예제 29-4] 참고
해당 예제의 입력과정
(29-4.bmp → 29-4_out.cgrp)
29-4.bmp는 TestMap 폴더에 있음
Mask01.Act : 2번 이상의 색상은 투명색 처리함

이미지 변환모드 : 2 입력 후 엔터
삽입할 이미지 파일이름 : 포토샵으로 편집 후 저장한 이미지 파일의 이름을 입력 후 엔터
점 사이의 X축 간격 : 점의 가로 크기 입력 후 엔터
점 사이의 Y축 간격 : 점의 세로 크기 입력 후 엔터
이미지 색상 모드 : 1 입력 후 엔터
이미지의 색상코드 : 해당 이미지를 칠할 색상의 코드를 입력 후 엔터
이미지의 흑색 음영 단계 : 0~7중 입력 후 엔터
이미지의 적색 음영 단계 : 0~7중 입력 후 엔터
도트의 높이 : 0 ~ 255중 입력후 엔터
도트로 찍을 이미지ID : 해당 이미지를 그릴 이미지ID를 입력 후 엔터 (233 = 뉴크닷)

223

------------------------------------------------------------------------------------------

『 29장 : 파일 I/O 및 CGRP 삽입 함수 』

-----------------------------------------------------------------------------------------※ 사진변환기(CS_Photo.exe) 사용법 - 2-2. 단일색상 & 음영사용 (Mask02~08.ACT)
이미지를 단일 색상 베이스에 흑색 음영을 점마다 개별적으로 적용하여 출력할 때 쓰는 모드입니다.

1. 포토샵으로 변환할 이미지를 불러온 뒤 편집 후 CGRP_ACT폴더 안의 Mask02~08.ACT로
인덱스 색상 팔레트를 적용한다. (흰색이 흑색 음영 0단계 → 검정색 음영 7단계, 자주색은 투명색)

2. 확장자를 .Bmp, BMP 옵션에서 8비트로 설정 후 CS_Photo.exe가 있는 폴더에 저장한다.
3. CS_Photo.exe를 더블클릭해서 실행한다.

Ex) [예제 29-5] 참고
해당 예제의 입력과정
(29-5.bmp → 29-5_out.cgrp)

29-5.bmp는 TestMap 폴더에 있음
Mask0N.Act : N단계까지 흑색 음영이 존재함
왼쪽부터 순서대로 흑색음영 0단계 ~ N단계로 받음
인덱스 9번 이상의 색상은 투명색 처리함

이미지 변환모드 : 2 입력 후 엔터
삽입할 이미지 파일이름 : 포토샵으로 편집 후 저장한 이미지 파일의 이름을 입력 후 엔터

점 사이의 X축 간격 : 점의 가로 크기 입력 후 엔터
점 사이의 Y축 간격 : 점의 세로 크기 입력 후 엔터
이미지 색상 모드 : 2 입력 후 엔터
이미지의 색상코드 : 해당 이미지를 칠할 베이스 색상의 코드를 입력 후 엔터 (해당 색을 기준으로 흑색 음영을 씌움)
이미지의 적색 음영 단계 : 0~7중 입력 후 엔터
도트의 높이 : N개 입력 → 흑색 음영 0단계 ~ N단계 까지의 점의 높이를 차례대로 0~255중 선택해 입력 후 엔터
도트로 찍을 이미지ID : 해당 이미지를 그릴 이미지ID를 입력 후 엔터 (233 = 뉴크닷)

※ 흑색 음영 데이터는 흑색 음영단계(2^8~2^10)와 점의 높이(2^24~2^31)에 모두 저장되며 각각
A. 저장된 흑색 음영 단계대로 각 점을 찍는 방법과 (한 점당 베이스컬러 + 흑색음영 단계 수 만큼의 총알 소모)
B. 흑색 음영 뒷 배경(이미지 210번 등)을 두고 높이차를 둬서 각 점을 찍는 방법이 있다.
(한 점당 베이스 컬러만큼의 총알 소모) ← 예제 29-5에서 사용한 방법

224

------------------------------------------------------------------------------------------

『 29장 : 파일 I/O 및 CGRP 삽입 함수 』

-----------------------------------------------------------------------------------------※ 사진변환기(CS_Photo.exe) 사용법 - 2-3. 팔레트사용 & 단일높이 (Palette01~38.ACT)
이미지를 다색상 베이스에 각 점의 높이를 모두 동일하게 설정하여 출력할 때 쓰는 모드입니다.

1. 포토샵으로 변환할 이미지를 불러온 뒤 편집 후 CGRP_ACT폴더 안의 Palette01~38.ACT로
인덱스 색상 팔레트를 적용한다. (각 색상마다 왼쪽부터 흑색 음영 0단계 → 검정색 음영 7단계)

2. 확장자를 .Bmp, BMP 옵션에서 8비트로 설정 후 CS_Photo.exe가 있는 폴더에 저장한다.
3. CS_Photo.exe를 더블클릭해서 실행한다.

Ex) [예제 29-6] 참고
해당 예제의 입력과정
(29-6.bmp → 29-6_out.cgrp)

29-6.bmp는 TestMap 폴더에 있음
PaletteABTW.Act : (T는 적색 음영)
순서대로 R/T1/G/G+T1/G+T2/G+T3/
B/B+T1/B+T2/B+T3/W/W+T1/W+T2/W+T3
색상으로 구성되어 있으며, 각 색상마다 0~7단계의
흑색 음영 적용 색상으로 구성되어있다.
상황에 맞는 팔레트를 골라서 적용
A : 0~3 (적색 음영 단계)
B : 0~7 (흑색 음영 단계)

T : 없을경우 T1색상이 제거됨
W : 없을경우 W계열 색상이 제거됨
이미지 변환모드 : 2 입력 후 엔터

인덱스 113번째 이상의 색상은 투명색으로 처리함

삽입할 이미지 파일이름 : 포토샵으로 편집 후 저장한 이미지 파일의 이름을 입력 후 엔터
점 사이의 X축 간격 : 점의 가로 크기 입력 후 엔터
점 사이의 Y축 간격 : 점의 세로 크기 입력 후 엔터
이미지 색상 모드 : 3 입력 후 엔터
도트의 높이 : 0 ~ 255중 입력후 엔터

도트로 찍을 이미지ID : 해당 이미지를 그릴 이미지ID를 입력 후 엔터 (233 = 뉴크닷)

※ 흑색 음영과 적색 음영, 베이스 컬러 데이터는 모두 사용자가 선택한 팔레트의 컬러인덱스로 결정되며,
자동으로 각 점의 R/G/B/W flag 및 Red/Black Stack을 채운다.
※ 음영의 색상은 팔레트 상의 색상보다 더 진하게 표시됨
※ T1의 팔레트상 색상은 구분을 위해 하늘색으료 표시함 (실제 색상은 반투명 빨강색임)
※ 팔레트의 색상은 마음대로 변경이 가능하나, 인덱스에 맞게 색을 칠해야 의도한대로 값이 입력됨
※ 흰색의 경우, 색상 스크립트 특성상 반드시 42틱(잔여시간 기준)내로 재 갱신해줘야 하며, 그 시간 동안 점점 색이
100% 불투명 → 0% 완전 투명으로 변한다. (잔여시간이 42틱 초과인경우 스타 팅김 발생함) 따라서 흰색의 경우
A. 흰색이 포함된 각 점을 매 틱마다 각각 갱신하여 찍는 방법과 (실시간 갱신에 사용되는 유닛수 +흰색점 수 만큼)
B. 흰색 뒷 배경(이미지 210번 등)을 두고 흰색 점은 비워두는 방법이 있다. (실시간 갱신에 사용되는 유닛수 +배경수)
↑ 예제 29-6에서 사용한 방법

225

------------------------------------------------------------------------------------------

『 29장 : 파일 I/O 및 CGRP 삽입 함수 』

------------------------------------------------------------------------------------------

※ 사진변환기(CS_Photo.exe) 사용법 - 2-4. 팔레트사용 & 음영사용 (Palette.ACT & 음영을 높이로 처리)
이미지를 다색상 베이스에 각 점의 높이를 흑색 음영에 따라 다르게 설정하여 출력할 때 쓰는 모드입니다.

1. 포토샵으로 변환할 이미지를 불러온 뒤 편집 후 CGRP_ACT폴더 안의 Palette01~38.ACT로
인덱스 색상 팔레트를 적용한다. (각 색상마다 왼쪽부터 흑색 음영 0단계 → 검정색 음영 7단계)

2. 확장자를 .Bmp, BMP 옵션에서 8비트로 설정 후 CS_Photo.exe가 있는 폴더에 저장한다.
3. CS_Photo.exe를 더블클릭해서 실행한다.

Ex) [예제 29-7] 참고
해당 예제의 입력과정
(29-7.bmp → 29-7_out.cgrp)

29-7.bmp는 TestMap 폴더에 있음
PaletteABTW.Act : (T는 적색 음영)
순서대로 R/T1/G/G+T1/G+T2/G+T3/
B/B+T1/B+T2/B+T3/W/W+T1/W+T2/W+T3
색상으로 구성되어 있으며, 각 색상마다 0~7단계의
흑색 음영 적용 색상으로 구성되어있다.
상황에 맞는 팔레트를 골라서 적용
A : 0~3 (적색 음영 단계)
B : 0~7 (흑색 음영 단계)

T : 없을경우 T1색상이 제거됨
W : 없을경우 W계열 색상이 제거됨
인덱스 113번째 이상의 색상은 투명색으로 처리함
이미지 변환모드 : 2 입력 후 엔터
삽입할 이미지 파일이름 : 포토샵으로 편집 후 저장한 이미지 파일의 이름을 입력 후 엔터
점 사이의 X축 간격 : 점의 가로 크기 입력 후 엔터
점 사이의 Y축 간격 : 점의 세로 크기 입력 후 엔터
이미지 색상 모드 : 4 입력 후 엔터

도트의 높이 : N개 입력 → 흑색 음영 0단계 ~ N단계 까지의 점의 높이를 차례대로 0~255중 선택해 입력 후 엔터
도트로 찍을 이미지ID : 해당 이미지를 그릴 이미지ID를 입력 후 엔터 (233 = 뉴크닷)

※ 흑색 음영과 적색 음영, 베이스 컬러 데이터는 모두 사용자가 선택한 팔레트의 컬러인덱스로 결정되며,
자동으로 각 점의 R/G/B/W flag 및 Red/Black Stack을 채운다.
※ 음영의 색상은 팔레트 상의 색상보다 더 진하게 표시됨
※ T1의 팔레트상 색상은 구분을 위해 하늘색으료 표시함 (실제 색상은 반투명 빨강색임)
※ 팔레트의 색상은 마음대로 변경이 가능하나, 인덱스에 맞게 색을 칠해야 의도한대로 값이 입력됨
※ 2번 모드와 마찬가지로, 흑색 음영 뒷 배경(이미지 210번 등)을 두고 높이차를 둬서 각 점을 찍는다.
↑ 예제 29-7에서 사용한 방법
※ 각 점의 색상 조합의 순서는 흑색 음영 > 적색 음영 > 베이스 컬러 순으로 와야함
(예제에서 0~7단계 음영 * 흑/적/베이스 높이차로 총 24개의 높이를 사용함)

226

------------------------------------------------------------------------------------------

『 29장 : 파일 I/O 및 CGRP 삽입 함수 』

-----------------------------------------------------------------------------------------※ 사진변환기(CS_Photo.exe) 사용법 - CGRP 헤더의 활용
Ex) [예제 29-8] 참고
해당 예제의 입력과정
(29-8.bmp → 29-8_out.cgrp)
29-8.bmp는 TestMap 폴더에 있음

※ f_GetFileptr로 .CGRP파일을 로드하면 FArr(CGRP,0~3)까지는 헤더, 4부터는 데이터 단락이다.
해당 부분의 데이터를 읽으면 출력할 이미지의 정보를 맵 내부에서 알 수 있다. (코드에 반영 가능)

227

------------------------------------------------------------------------------------------

『 29장 : 파일 I/O 및 CGRP 삽입 함수 』

-----------------------------------------------------------------------------------------※ 사진변환기(CS_Photo.exe) 사용법 - 가변 스프라이트 출력방법
Ex) [예제 29-9] 참고
해당 예제의 입력과정
(29-9A~F.bmp → 29-9A~F_out.cgrp)
29-9A~F.bmp는 TestMap 폴더에 있음
해당 이미지와 같은 방법으로
29-9B~29-9F.bmp를 변환한다.

※ 0도부터 15도씩 돌린 이미지 6장을 연속적으로 출력해 회전하는 이미지를 출력함
※ 가변 스프라이트의 경우, CreateSprite(영구 스프라이트 전용) 함수로는 만들 수 없고,
A. CreateBullet에서 Time(지속시간 0~255, 최대 약 8초)를 설정해서 총알 생성 방식으로 만들거나
(장점 : UnlimiterX의 총알 최대치의 영향을 받음, 이미지 높이 설정가능
단점 : 빠른 갱신이 불가능함 (최소간격 2틱 이상), 갱신시 소리가 들리거나(233) 잔상이 남음(259),
지속시간의 최대 한계가 약 8초로 다소 짧음)
B. ScanSprite에서 이미지의 스크립트 250으로 설정하고 매 틱마다 스캔 생성 방식으로 만들거나
(장점 : 매 틱마다 갱신가능, 갱신시 아무런 소리나 흔적이 없음, 0틱 연산 가능,
단점 : 스프라이트 생성 한계치가 500~600으로 작음, 이미지의 높이가 4로 고정됨, 항상 갱신해야함)
C. UnitSprite에서 이미지 표시용 유닛 생성 방식으로 만드는 방법이 있다.
(장점 : 매 틱마다 갱신가능, 지속시간 한계 없음, 0틱 연산 가능, 높이 조절 가능

단점 : 드래그 방지 적용시 클로킹 소리 발생함, 미적용시 드래그 가능,
생성유닛 850 초과시 최소 갱신 시간 3틱으로 늘어남, 이미지 밑 유닛은 조치 없으면 강제 껌밟음)
29-9 예제에서는 ScanSprite 방식을 사용함 (꼭 필요한 이미지만을 가변이미지로 사용하는 것을 권장함)
※ 가변이미지 제작시 ScanSprite + RecallSprite를 사용하면 높이차로 색 조합을 할 수 있다.
228

------------------------------------------------------------------------------------------

『 29장 : 파일 I/O 및 CGRP 삽입 함수 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CGRP 사용시 반드시 UnlimiterX.py를 맵에 적용해야 합니다. ｡+.ﾟ
※ UnlimiterX.py 플러그인 추가 방법
어셈블러 폴더의 py폴더 안의 UnlimiterX.py을 eudplib의 plugins 폴더에 복사 후
플러그인 입력칸 (또는 .eds 파일)에
[UnlimiterX]
<입력할 UnlmiterX.py 명령어들>
입력 후 저장 한 뒤 EUDEditor2,3 등으로 컴파일 하면 된다.

※ UnlimiterX는 기존 Unlimiter에서 총알 최대 개수를 사용자가 조절할 수 있게 한 플러그인임

플러그인 입력창 입력예시
다른 플러그인들
[UnlimiterX]
<UnlimiterX 명령어 등>
다른 플러그인들
순서로 입력해야함

※ UnlimiterX 플러그인 사용방법 (UnlimiterX 명령어 단락에 적어서 사용가능)
Count (총알 최대 개수 설정, 기본값 8192)
Count : 설정할 총알 최대 개수 (10진법 숫자로 입력)
→ 맵의 최대 총알 생성 가능 개수를 입력한 값으로 설정함
ex) Count : 65536 → 최대 총알 생성 개수를 65536개로 설정함
※ Count 미입력시 총알 개수 제한을 8192개로 설정함

SpCount (스프라이트/이미지/오더 최대 개수 설정, 기본값 65536)
SpCount : 설정할 총알 최대 개수 (10진법 숫자로 입력)
→ 맵의 최대 스프라이트/이미지/오더 생성 가능 개수를 입력한 값으로 설정함
ex) SpCount : 65536 → 최대 스프라이트/이미지/오더 생성 개수를 65536개로 설정함
※ SpCount 미입력시 스프라이트/이미지/오더 개수 제한을 max(65536,Count)개로 설정함
※ Unlimiter(X)로 늘어나는 스프라이트/이미지/오더는 오직 총알의 스프라이트/이미지/오더만 해당됨.
※ 맵상의 자신의 모든 시야 내에 "표시 되는" 총알의 수의 합이 일정 개수(컴퓨터 성능에 따라 다름)를 넘을 경우
일부 총알이 투명해짐(일정 개수 아래로 내려가면 다시 표시됨) → 방 갈림이 일어남 → 스타가 팅김
순으로 진행되며, 따라서 평균 표시 한계값 (약 4096개)를 넘는 숫자의 총알을 생성할 경우,

플레이어의 모든 시야 내에 총알의 수가 한계값 아래로 유지되게끔 해야함 (관전은 비공유 랜더링 미적용시 드랍)
※ 비공유 랜더링 : 기타 비공유 오프셋/스크립트/이미지/스프라이트/총알 ← 플레이어마다 값이 달라져도 무관
유닛/자원/기타 공유 오프셋 ← 값이 플레이어마다 다르면 방이 갈림
따라서 출력은 같이 하되, 총알의 지속시간 (CreateBullet함수 등에서의 Time 인자)를 다르게 하여 플레이어마다
서로 다른 총알을 생성하게 할 수 있다. (단, 해당 총알이 "유닛에게" 데미지를 입히는 즉시 방갈림 발생함)

229

------------------------------------------------------------------------------------------

『 29장 : 파일 I/O 및 CGRP 삽입 함수 』

-----------------------------------------------------------------------------------------※ 사진변환기(CS_Photo.exe) 사용법 - 다중 이미지 출력 방법 (UnlimiterX.py 연동)
Ex) [예제 29-10] 참고
해당 예제의 입력과정
(29-10.bmp → 29-10_out.cgrp)
29-10.bmp는 TestMap 폴더에 있음
해당 이미지가 맵 내 16곳에 출력된다.
총 도트수 43000+ (미네랄 양)

※ UnlimiterX.py에서의 설정 한계값은 없지만, 큰 수를 입력할수록 컴파일 시간이 느려진다.
※ 맵 내의 총알수가 총알 한계값에 도달하면 새로운 총알은 만들어지지 않는다. (물총현상)
※ 맵 내의 총알 수가 만 단위를 넘어가면 출력 당시에는 렉이 걸리지만 출력 이후에는 해소됨
※ 맵 내의 모든 시야라는 것은 자신의 유닛 시야 + 타 플레이어(컴퓨터 포함) 비전 공유 시야를 의미함

(화면 바깥의 시야도 모두 포함함, 이 시야 내에 표시 한계값 초과량의 총알이 있을경우 드랍)
※ CreateBullet류 함수의 Owner는 총알 생성시 시야를 갖게되므로 만 단위 이상의 총알생성시
Owner는 반드시 컴퓨터 플레이어를 설정해야한다.
(관전은 투사방식 변경+지속시간 설정을 통한 비공유 랜더링으로 누적이 안되게 막아야함)
※ 실제 맵에서는 시야 끄고 생성 (로딩시간 필요) → 제한된 시야(동맹비젼 불가능)로
진행시켜야 안전함 (미궁맵/공포맵/퍼즐맵에 적합함)

230

------------------------------------------------------------------------------------------

『 # : 부록 설명 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 트리거의 구조 (Ctrig) ｡+.ﾟ
분류

크기 (byte)

이름

설명

트리거 헤더
(이중 연결리스트)
4*2 = 8byte

4

Prev

이전 트리거를 가리킴 (chk에는 존재X)

4

Next

다음 트리거를 가리킴 (chk에는 존재X)

4

Locid

로케이션

4

Player

플레이어ID

4

Amount

2

Unitid

1

Comparison

1

Condtype

1

Restype

1

Flag

조건의 flag, 0x2 체크시 disabled

2

Internal

스타 내부에서 사용함, EUDX Flag

4

Locid1

1번째 로케이션

4

Strid

4

Wavid

4

Time

4

Player1

1번째 플레이어ID

4

Player2

2번째 플레이어ID, 2번째 로케이션

2

Unitid

유닛ID, 스코어/리소스 종류, 동맹상태

1

Acttype

액션ID, 0일시 다음 액션들을 무시함

1

Amount

유닛 개수, 스위치 종류 등

1

Flags

액션의 flag, 0x2 체크시 disabled

3

Internal

스타 내부에서 사용함, EUDX Flag

잡

4

Internal

스타 내부에서 사용함

체크 플레이어

1*28

effplayer[28]

트리거를 실행시킬 플레이어,
P1~P8에게만 유효함

SCR 전용 추가단락

8

SCR:Internal

TRIG단락에 삽입된 트리거에 추가됨,
접근시 EUDERROR 발생시킴

트리거 조건
(총 16개)
20*16 = 320byte

트리거 액션
(총 64개)

32*64 = 2048byte

양
유닛ID
조건연산자 (AtLeast, AtMost, Exactly)
조건ID, 0일시 다음 조건들을 무시함
리소스 종류, 스코어 종류, 스위치 번호

스트링ID
PlayWav에서 사용하는 스트링ID
시간, (ms 단위)

231

------------------------------------------------------------------------------------------

『 # : 부록 설명 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 어셈블러 표준 입출력 타입 ｡+.ﾟ
"X" → nil
숫자 → 상수 (위치마다 Offset(EPD) 또는 Value로 자동 선택되어 입력됨)
"Cp" → CurrentPlayer (epd=13으로 대신 입력가능)
Mem → {Player,Index,Address,Next} - Mem타입
V → {Player,Index,Next,"V",Deviation(Vi)} - V타입
Array[상수(k)] → Mem:{Arr_Player,Arr_Index,(k+(k/602)*2)*4,0} - Mem타입
Array[변수(i)] → {i_Player,i_Index,i_Next,"A",Array_Header} - A타입
VArray[상수(k)] → V:{VArr_Player,VArr_Index,k,"V"} - V타입
VArray[변수(i,i4)] → {i_Player,i_Index,i_Next,"VA",i_Deviation*604,i4_Player,i4_index,i4_Next}
- VA타입
----------------------------------------------------------------------------------------------------64비트 추가 타입 (22단원 참고)
W → {Player,Index,Next,"W",Deviation(Wi)} - W타입
LArray[상수(k)] → Mem:{LArr_Player,LArr_Index,0,k/151} - Mem타입 (앞4바이트)
LArray[{상수(k),0}] → Mem:{LArr_Player,LArr_Index,0,k/151} - Mem타입 (앞4바이트)
LArray[{상수(k),1}] → Mem:{LArr_Player,LArr_Index,1,k/151} - Mem타입 (뒤4바이트)
LArray[{상수(k)}] → LMem:{{LArr_Player,LArr_Index,0,k/151},{LArr_Player,LArr_Index,1,k/151}}
- LMem타입
LArray[변수(i)] → {i_Player,i_Index,i_Next,"A",Array_Header} - A타입 (앞4바이트)
LArray[{변수(i),0}] → {i_Player,i_Index,i_Next,"A",Array_Header} - A타입 (앞4바이트)
LArray[{변수(i),1}] → {i_Player,i_Index,i_Next,"A",Array_Header} - A타입 (뒤4바이트)
LArray[{변수(i)}] → {i_Player,i_Index,i_Next,"LA",LArray_Header} - LA타입
WArray[상수(k)] → W:{WArr_Player,WArr_Index,k,"W"} - W타입
WArray[변수(i,i4)] → {i_Player,i_Index,i_Next,"WA",i_Deviation*604,i4_Player,i4_index,i4_Next}
- WA타입
※ LA타입의 경우 Index 변수(V/W)에 따라 내부에서 서로 다른 타입으로 분류함 (LA_V,LA_W)
-----------------------------------------------------------------------------------------------------구조체 변수 추가 타입 (23단원 참고)
S → {"S",Index,Number} : SV()와 결합하기 전 SV의 임시 타입
SV → {Player,Index,Next,"SV",Number,Line}
SA → {"X",Index,0,"SA",Number,Size} : SVArr(X)()와 결합하기 전 SVA의 임시 타입
SVA → {i_Player,i_Index,i_Next,"SVA",SVArray_Header,i_Deviation*604,i4_Player,i4_Index,i4_Next}
232

------------------------------------------------------------------------------------------

『 # : 부록 설명 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 확장 데스값 작동 방식 ｡+.ﾟ
CDeaths : 기준 CVariable의 빈 공간(액션 5~64번째 줄(총 60줄) x 0x20 bytes를
공메모리로 사용함 (Line = 0 ~ 479))
NDeaths : 기준 플레이어의 기준 CVariable의 빈공간의 액션 1줄(0x20 bytes)당
P1 ~ P8의 4bytes씩의 공메모리로 할당함 (Line = 0 ~ 59 x Player1~8)

｡˙+ﾟ ※ Cunit Ctrig 구조 ｡+.ﾟ
Header / Selector - NJump~ - Last / Start - Main 순서로 구성됨
CunitCtrig 작동 원리 : Header → Start → Main(0) → Main(1) → ...
→ Main(1699) → Last → Exit(CunitCtrig 다음 트리거)
Main(i) 조건 만족시 : Main(0) → ... → Main(i) → Selector → NJump_1 → ...
→ Last → Main(i+1) → ... → Main(1699) → Last → Exit
NJump_j 조건 만족시 : Selector → NJump_1 → ...
→ NJump_i → NJumpEnd_i → Calc_i Start → ... → Calc_i End → Clear Calc → Last
BreakCalc 조건 만족시 : Calc_i Start → ... → BreakCalc → Last

｡˙+ﾟ ※ 중간 연산자 생성 원리 ｡+.ﾟ
중간 연산자 함수는 대상 트리거 바로 앞쪽에 연산 트리거를 생성하고 할당받은 임시 변수에 연산 결과를 저장한다.

데이터(VArr()/V()/상수등) → 중간 연산자 → 임시변수 할당후 연산 트리거 생성 데이터를 STPushTrigArr에 전달
→ 최종 연산 함수 도달 → STPopTrigArr 실행 →
저장된 STPushTrigArr에 있는 연산 트리거 생성 데이터를 쌓인 순서대로 처리
(최종 연산 트리거 바로 앞쪽에 생성됨) → 최종 연산 트리거 생성 (STPopTrigArr 이후 영역의 코드)
중간 연산자 함수는 (C) 또는 (f_) 함수를 재사용해서 만들수있다. (임시 변수는 VarXAlloc에서 할당받는다.)
해당 연산에 해당하는 중간 연산 함수 (_)를 만들고 STPushTrigArr에 연산 트리거 생성 데이터를 전달한뒤
STPopTrigArr() 함수에 전달받은 해당 데이터를 처리하는 단락을 추가하면 된다. (다른 중간 연산자 함수 참고)

｡˙+ﾟ ※ T/TT 조건/액션 생성 원리 ｡+.ﾟ
기타 조건/액션의 (T) 조건/액션 추가시 변수를 넣고싶은 항목의 오프셋에 변수 처리 정보를 추가해서
PushTrigArr에 저장하면 된다.
(T) 조건/액션은 변수 삽입 트리거 정보를 PushTrigArr에 저장한뒤 PopTrigArr를 갖는 함수(Cstruct류)에서
PopCondArr, PopActArr 함수로 삽입한 (T)조건/액션의 위치를 결정한다음,
PopTrigArr() 함수에서 저장된 변수 삽입 트리거 생성 정보를 처리한다.
기타 조건/액션의 (TT) 조건 추가시 변수를 넣고싶은 항목의 오프셋에 변수 처리 정보를 추가해서
TTPushTrigArr에 저장하면 된다.
(TT) 조건은 특수 조건 만족여부를 체크하는 CFlag를 자동할당 받고 해당 조건 자리에 해당 CFlag 판단 조건을 삽입한 뒤

변수 정보를 TTPushTrigArr에, 조건의 실제 정보를 TTPushCondArr에,
할당받은 CFlag를 TTFCodeArr에, 입력한 특수 조건을 TTModeArr에 저장한다.
TTPopTrigArr를 갖는 함수(CStruct류)에서 저장된 특수 조건 및 변수 삽입 등의 트리거 생성 정보를 처리한다.

233

------------------------------------------------------------------------------------------

『 # : 부록 설명 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CtrigAsm 데이터 변환 및 입력처리 구조 ｡+.ﾟ
상수 오프셋의 입력(조건/액션의 Offset,Value 부분에 상수 오프셋의 Offset/epd를 입력)
상수(Offset/epd) → MemoryX / SetMemoryX / MemX / SetMemX
Ctrig메모리 → Mem() → MemX, SetMemX
N/CDeaths → _N/Ccode() → MemX, SetMemX
배열[상수] → Arr() → MemX, SetMemX
변수 → _Mem() → MemX, SetMemX
변수배열[상수] → VArr() → _Mem() → MemX, SetMemX
T 조건/액션 사용시 MemX,MemoryX → TMemoryX / SetMemX,SetMemoryX → TSetMemoryX를 사용

----------------------------------------------------------------------------------------------------------T 조건/액션 필요) 상수 오프셋의 출력(조건/액션의 Offset,Value 부분에 상수 오프셋의 Value를 입력)

변수 → V() → TMemoryX, TSetMemoryX
변수배열[상수] → VArr() → TMemoryX, TSetMemoryX
----------------------------------------------------------------------------------------------------------T 조건/액션 필요) 변수 오프셋의 입력(조건/액션의 Offset,Value 부분에 변수 오프셋의 Offset/epd를 입력)

배열[변수] → Arr() → _TMem() → TMemoryX, TSetMemoryX
변수배열[변수] → VArr() → _TMem() → TMemoryx, TSetMemoryX
----------------------------------------------------------------------------------------------------------T 조건/액션 필요) 변수 오프셋의 출력(조건/액션의 Offset,Value 부분에 변수 오프셋의 Value를 입력)

변수배열[변수] → VArr() → _MovX() (T조건/액션에는 내장) → TMemoryX, TSetMemoryX
----------------------------------------------------------------------------------------------------------(C/f_) 함수 내부 A, VA타입 처리 방식
Source << A (CRead류) : 배열[변수] → Arr() → A →|함수내부: _MovZ(V에 epd저장)
→ V(임시변수) → 연산시작
Source << VA : 변수배열[변수] → VArr() → VA →|함수내부: _MovX(V에 Value저장)
→ V(임시변수) → 연산시작
Dest << A : 배열[변수] → Arr() → A →|함수내부: (→ 연산종료)→ _MovX(V의 Value를 A에 저장)
Dest << VA : 변수배열[변수] → VArr() → VA →|함수내부: (→ 연산종료)
→ _MovX(V의 Value를 VA에 저장)

234

------------------------------------------------------------------------------------------

『 # : 부록 설명 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CtrigAsm 데이터 변환 및 입력처리 구조 ｡+.ﾟ
A, VA타입 삽입가능 영역 및 강제 입력 방법
(C/f_) 함수, (_)중간연산자, print_String() : VArr(), Arr() 사용시 자동으로 입력/출력 선택하여 연산함
(T/TT) 조건/액션 : VArr() 단일 사용시 출력으로, VArr(), Arr() → _TMem() 사용시 입력으로 연산함
ConvertArr(), ConvertVArr(), SafeRead류(Input만), ItoDec(X), ItoHex(X)(Input만), Print_String(X)(Input만) : 강제 변환 입력 가능 (지원X)
일반 조건/액션, Arr(X), VArr(X), RecoverCp(), SetRecoverCp(), SaveCp(), LoadCp(), 기타 스트링 관련 함수 : 사용불가 (지원X)

강제 입/출력 형식 변환 및 입력방법 :
(VA/A 타입 지원X일 경우 Source에 타입 변환 함수를 중간에 넣어 강제 입력 가능)
상수 / Mem / N/CDeaths / Arr(상수) → 상수 입력만 가능 (변환X)
V / VArr(상수) → 그대로 사용시 상수 출력 / _Mem() 사용시 상수 입력(V → Mem)
Arr(변수) → (지원O) : 그대로 사용시 변수 입력 / (지원X) : _TMem() 사용시 변수 입력 (A → V)
VArr(변수) → (지원O) : 그대로 사용시 변수 출력 / (지원X) : _MovX() 사용시 변수 출력 (VA → V)
/ _TMem() 사용시 변수 입력 (VA → V)
※ Dest에 VA나 A타입을 넣는경우 함수 자체에서 지원하지 않는경우 입력이 불가능함
(A나 VA가 아닌 임시 변수에 값이 저장됨)
MovX(PlayerID,[VArr()/Arr()],_연산함수())를 사용하거나, 연산함수 바로 뒤에
MovX(PlayerID,[VArr()/Arr()],임시변수)를 사용

235

------------------------------------------------------------------------------------------

『 # : 부록 설명 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ 드래그 방지 유닛 생성방법｡+.ﾟ
A : Cunit + 0xDC의 0x100 flag (Require Detection)을 true로 설정
-A : Cunit + 0xDC의 0x100 flag (Require Detection)을 false로 설정
A` : Cunit + 0xDC의 0x200 flag (Cloaked)를 true로 설정
-A` : Cunit + 0xDC의 0x200 flag (Cloaked)를 false로 설정
B : 해당 UnitID의 Special Ability의 영구 클로킹 항목을 true로 설정
C : Cunit + 0xE4 (Visibility flag)를 0으로 설정
-C : Cunit + 0xE4 (Visibility flag)를 0xFF로 설정
디텍터X : 디텍터가 없는 상태로 유닛을 봤을때

디텍터O : 디텍터 유닛으로 유닛을 봤을때
디텍후 : 1회이상 디텍터 유닛으로 유닛을 본 후 디텍터가 없는 상태로 유닛을 봤을때
100% : 불투명 (유닛 이미지가 일반 상태처럼 불투명하게 보임)
50% : 반투명 (유닛 이미지가 자기유닛 클로킹 상태처럼 반투명하게 보임)
0% : 투명 (유닛 이미지가 적 클로킹 유닛처럼 완전투명하게 보임)
O : 드래그 가능 / O` : 드래그 가능, 자동으로 선택해제됨 /X : 드래그 불가능

A

A+C
(드래그 방지)

A → -A

A+C → -A

A+C → -C

디텍터 X : 100%, X

디텍터 X : 100%, X

디텍터 X : 100%, O

디텍터 X : 100%, O

디텍터 X : 100%, O`

디텍터 O : 50%, O

디텍터 O : 50%, X

디텍터 O : 50%, O

디텍터 O : 50%, O

디텍터 O : 50%, O`

디텍후 : 0%, X

디텍후 : 50%, X

디텍후 : 0%, O

디텍후 : 50%, O

디텍후 : 0%, O`

B

B+C
(드래그 방지)

B → -A`
B+C → -C

B+C → -A`

B+C → -A+-C

디텍터 X : 0%, X

디텍터 X : 0%, X

디텍터 X : 0%, O

디텍터 X : 0%, O`

디텍터 X : 0%, O`

디텍터 O : 50%, O

디텍터 O : 50%, X

디텍터 O : 0%, O

디텍터 O : 50%, O`

디텍터 O : 50%, O

디텍후 : 0%, X

디텍후 : 50%, X

디텍후 : 0%, O

디텍후 : 50%, O`

디텍후 : 0%, O`

※ Visibility Flag를 0으로 만들때(C) 드래그 방지를 적용할 플레이어의 flag를 0으로 만들수 있다.
(2^(PlayerID)를 0으로 만들경우 해당 Player에게만 드래그 방지가 적용됨)
※ 드래그 방지 유닛의 경우 미니맵 표시 X, 공격타겟 X의 효과를 받음
※ 생산크기 0,0 의 경우 해당 UnitId전체가 실시간으로 적용되며,
유닛은 디텍터 여부와 관계없이 이미지 자체가 사라지고

건물은 생산크기 0,0이 된 그 자리의 이미지만 남고 이미지 갱신이 안됨
(생산크기를 1,1이상으로 올릴 경우 다시 원래대로 돌아옴)

236

------------------------------------------------------------------------------------------

『 E. CtrigAsm 예제 』

------------------------------------------------------------------------------------------

｡˙+ﾟ 0. 목차 ｡+.ﾟ
1장 : 맵 정보 입력 관련
2장 : CtrigAsm 설치 관련 함수

3장 : 기본 내장 조건/액션 함수 (.Py 직접 연동 함수)
4장 : 기본 오류 체크 함수 (선택)
5장 : 표준 입출력 및 변환 함수
6장 : 변수/배열 선언 및 호출 함수
7장 : DoActions류 트리거 생성 함수
8장 : Ctrig 파생 조건/액션 함수
9장 : Cp트릭 관련 및 CunitCtrig 함수
10장 : 제어문 관련 함수 (CStruct)
11장 : SafeRead류 데이터 읽기 관련 함수
12장 : 매크로 함수형 최종 연산 함수 (C)
13장 : 함수 호출형 함수 정의 선언 함수 (Include)
14장 : 함수 호출형 최종 연산 함수 (f_)
15장 : 중간 연산자 관련 함수 (_)
16장 : 변수 삽입형 조건/액션 함수 (T)
17장 : 특수 조건 관련 함수 (TT)

18장 : 기타 편의기능 관련 함수
19장 : 기타 스트링 관련 함수
20장 : CreateUnitShape.lua 함수
21장 : 사용자 정의 추가 함수
22장 : 64비트 변수 연산 함수 (W)
23장 : 구조체 변수 연산 함수 (SV)
24장 : 논리 조건 연산 함수 (_T)
25장 : 바이트 단위 R/W 함수 (byte)
26장 : 이상 스트링 편집 및 출력 함수 (CAPrint)
27장 : 비공유 데이터 전송 함수 (NSQC.py)
28장 : 순수 총알생성 함수 (언리미터 필요)
29장 : 파일 I/O 및 CGRP 삽입 함수
# : 부록 예제
237

------------------------------------------------------------------------------------------

『 1장 : 맵 정보 입력 관련 』

-----------------------------------------------------------------------------------------[예제 1-1] SetForces()
-- Force1 : P1,P2,P3,P4,P5 / Force2 : P6 / Force3 : P7,P8 인 맵
SetForces({P1,P2,P3,P4,P5},{P6},{P7,P8},{},{P1,P2,P3,P4,P5,P6,P7,P8})
-----------------------------------------------------------------------------------------[예제 1-2] SetFixedPlayer()
-- 맵에서 P7이 컴퓨터 플레이어이며, 게임이 끝날때까지 Defeat()이나 Victory() 처리가 안될경우

SetFixedPlayer(P7)
------------------------------------------------------------------------------------------

238

------------------------------------------------------------------------------------------

『 2장 : CtrigAsm 설치 관련 함수 』

-----------------------------------------------------------------------------------------※ TestMap.scx의 기본 트리거를 참고한다. (StartCtrig(), EndCtrig())
------------------------------------------------------------------------------------------

239

------------------------------------------------------------------------------------------

『 3장 : 기본 내장 조건/액션 함수 (.Py 직접 연동 함수)』

------------------------------------------------------------------------------------------

[예제 3-1] Label(), CtrigX(), SetCtrig1X()
-- A액션 : SetResources(P1,SetTo,0 → 10 → 20 → ... → 100 → 100 → 100,Ore);
-- B액션 : SetCtrig1X(P2,0x10,0x15C,0,Add,10 → 10 → 10 → ... → 10 → 0);
Trigger {
players = {P2},
conditions = {

Label(0x10); -- P2 index:0x10 트리거
},
actions = {
SetResources(P1,SetTo,0,Ore); -- P1 미네랄 Set 0 (A액션)
SetCtrig1X(P2,0x10,0x15C,0,Add,10); -- A액션의 Value부분을 10씩 더함 (B액션)
},
flag = {Preserved}
}
Trigger {
players = {P1},
conditions = {
Label(0);
CtrigX(P2,0x10,0x15C,0,Exactly,100); -- A액션의 Value 부분이 100일경우
},
actions = {
SetCtrig1X(P2,0x10,0x17C,0,SetTo,0); -- B액션의 Value 부분을 0으로 세팅
},
flag = {Preserved}
}

------------------------------------------------------------------------------------------

240

------------------------------------------------------------------------------------------

『 3장 : 기본 내장 조건/액션 함수 (.Py 직접 연동 함수)』

------------------------------------------------------------------------------------------

[예제 3-2] SetCtrigX()
-- 트리거 실행 순서 : A → B → C ---> A → C로 변경
-- A → C로 실행 순서가 변경되어 트리거 B는 실행되지 않음
Trigger { -- 트리거 A
players = {P1},
conditions = {
Label(0);
},
actions = {
SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2); -- 트리거 A의 Next를 트리거 C로 설정
},
flag = {Preserved}
}

Trigger { -- 트리거 B
players = {P1},
conditions = {
Label(0);
},
actions = {
SetResources(P1,SetTo,1000,Ore); -- P1 미네랄 Set 1000
},
flag = {Preserved}
}

Trigger { -- 트리거 C
players = {P1},
conditions = {
Label(0);
},
actions = {
SetResources(P1,SetTo,1000,Gas); -- P1 가스 Set 1000
},
flag = {Preserved}
}

------------------------------------------------------------------------------------------

241

------------------------------------------------------------------------------------------

『 4장 : 기본 오류 체크 함수 (선택) 』

------------------------------------------------------------------------------------------

[예제 4-1] PushErrorMsg()
function Example(Input)
if Input == nil then -- 사용자 정의 함수 생성시 예외처리
PushErrorMsg("입력안함")
end
end
Example()
-----------------------------------------------------------------------------------------[예제 4-2] PushRecoverCpMsg()
CJump(AllPlayers,0)
CVariable2(P1,0x10,"X","X",1)
for i = 0, 10 do
CVariable2(P1,0x20+i,"X","X",i)

end
VA1 = GetVArray(V(0x20),10)
CJumpEnd(AllPlayers,0)
PushRecoverCpMsg()
CAdd(P1,0x58F450,VArr(VA1,V(0x10))) -- MovX 액션(<<VA)때문에 Cp트릭 사용됨
PushRecoverCpMsg(1)
-----------------------------------------------------------------------------------------[예제 4-3] PushValueMsg()
local X = 12345 local Y = 67.89 local Z = "ZXCVB"
local W = 0xABCD local V = nil
local Arr = {nil,1,2,3,"가"}
local Arr2 = {0.1,0.2,0.3,0.4}
local Arr3 = {0xA, 0xB, 0xC, 0xD}

PushValueMsg(V,{W,"x"},X,{Y,"F"},Z,{Arr},{Arr2,"f"},{Arr3,"X"}) -- 변수 값을 직접 확인
-----------------------------------------------------------------------------------------242

------------------------------------------------------------------------------------------

『 5장 : 표준 입출력 및 변환 함수 』

------------------------------------------------------------------------------------------

[예제 5-1] CAddr()
-- 2번째 액션의 Value부분이 1234가 되어 P1가스가 1234로 설정됨
DoActionsX(P1,{SetCtrig1X("X","X",CAddr("Value",2,0),0,SetTo,1234),SetResources(P1,SetTo,0,Gas)})

-----------------------------------------------------------------------------------------[예제 5-2] DtoA()
Trigger {
players = {P1},
conditions = {
},
actions = {
SetDeaths(P2,SetTo,1234,"Terran SCV");
},
flag = {Preserved}
}
Trigger {
players = {P1},
conditions = {
Memory(DtoA(P2,"Terran SCV"),Exactly,1234);
},
actions = {
SetResources(P1,SetTo,1234,Ore);
},
flag = {Preserved}
}
-----------------------------------------------------------------------------------------[예제 5-3] Forward()
X1 = Forward() -- 바로 뒤쪽의 CWhile Index 저장
DoActionsX(P1,{SetCtrig1X("X",X1,0x24,0,SetTo,16)}) -- CWhile의 2번째 조건 Memory(0x57f0f0,AtLeast,1→16)

CWhile(P1,Memory(0x57f0f0,AtLeast,1))
DoActions(P1,{SetMemory(0x57f0f0,Subtract,1),SetMemory(0x57f120,Add,1)})

CWhileEnd()
------------------------------------------------------------------------------------------

243

------------------------------------------------------------------------------------------

『 5장 : 표준 입출력 및 변환 함수 』

------------------------------------------------------------------------------------------

[예제 5-4] Forward(), Struct()
X1 = Forward(Struct("CIfX",5)) -- CIfX문 뒤쪽의 CWhile Index 저장
DoActionsX(P1,{SetCtrig1X("X",X1,0x24,0,SetTo,16)}) -- CWhile의 2번째 조건 Memory(0x57f0f0,AtLeast,1→16)

CIfX(P1,Never())
CElseIfX(Never())
CElseIfX(Never())
CElseX()
CIfXEnd()
CWhile(P1,Memory(0x57f0f0,AtLeast,1))
DoActions(P1,{SetMemory(0x57f0f0,Subtract,1),SetMemory(0x57f120,Add,1)})
CWhileEnd()
-----------------------------------------------------------------------------------------[예제 5-5] X(), V(), Mem(), _Mem()
CJump(AllPlayers,0)
CVariable2(P1,0x10,"X","X",0x1000) Var1 = {P1,0x10,0}
CJumpEnd(AllPlayers,0)
CMov(P1,0x58F450,V(0x10)) -- 빨강 숫자 0x1000
CMov(P1,0x58F454,X(Var1)) -- 파랑 숫자 0x1000

CRead(P1,0x58F458,Mem(P1,0x10,0x15C,0)) -- 연두 숫자 0x1000
CRead(P1,0x58F45C,_Mem(V(0x10),0x15C,0)) -- 보라 숫자 0x1000
------------------------------------------------------------------------------------------

244

------------------------------------------------------------------------------------------

『 5장 : 표준 입출력 및 변환 함수 』

------------------------------------------------------------------------------------------

[예제 5-6] Vi(), Arr(), ArrX(), ConvertArr()
CJump(AllPlayers,0)
Arr1 = CArray(P1,1000) -- 배열 선언
CVariable2(P1,0x10,"X","X",5) -- V(0x10) : 초기값 5
CVariable(P1,0x11)
CJumpEnd(AllPlayers,0)
CMov(P1,Arr(Arr1,0),0x1234) -- Arr1[0] << 0x1234
CRead(P1,0x58F450,Arr(Arr1,0)) -- 빨강 숫자 << Arr1[0]

CMov(P1,Arr(Arr1,Vi(0x10,1)),0x5678) -- Arr[V(0x10)+1] << 0x5678
CRead(P1,0x58F454,Arr(Arr1,6)) -- 파랑 숫자 << Arr1[6]
CRead(P1,0x58F458,Arr(Arr1,Vi(0x10,1))) -- 연두 숫자 << Arr[V(0x10)+1]
ConvertArr(P1,V(0x11),V(0x10)) -- V(0x11) << Arr 인덱스 변환(V(0x10))
CMov(P1,ArrX(Arr1,V(0x11)),0xABCD) -- Arr1[V(0x11)] << 0xABCD
CRead(P1,0x58F45C,ArrX(Arr1,V(0x11))) -- 보라 숫자 << Arr1[V(0x11)]
CMov(P1,ArrX(Arr1,604),0x90EF) -- Arr1[604] << 0x90EF
ConvertArr(P1,V(0x11),Vi(0x10,604-5)) -- V(0x11) << Arr 인덱스 변환(V(0x10)+599)
CRead(P1,0x58F460,ArrX(Arr1,V(0x11))) -- 주황 숫자 << Arr1[V(0x11)]
------------------------------------------------------------------------------------------

[예제 5-7] Vi(), VArr(), VArrX(), ConvertVArr()
CJump(AllPlayers,0)
VArr1 = CVArray(P1,10) -- 변수 배열 선언
CVariable2(P1,0x10,"X","X",5) -- V(0x10) : 초기값 5
CVariable(P1,0x11)
CVAriable(P1,0x12)
CJumpEnd(AllPlayers,0)
CMov(P1,VArr(VArr1,0),0x1234) -- VArr1[0] << 0x1234
CMov(P1,0x58F450,VArr(VArr1,0)) -- 빨강 숫자 << VArr1[0]
CMov(P1,VArr(VArr1,Vi(0x10,1)),0x5678) -- VArr[V(0x10)+1] << 0x5678
CMov(P1,0x58F454,VArr(VArr1,6)) -- 파랑 숫자 << VArr1[6]
CMov(P1,0x58F458,VArr(VArr1,Vi(0x10,1))) -- 연두 숫자 << VArr[V(0x10)+1]
ConvertVArr(P1,V(0x11),V(0x12),V(0x10)) -- V(0x11), V(0x12) << VArr 인덱스 변환(V(0x10))
CMov(P1,VArrX(VArr1,V(0x11),V(0x12)),0xABCD) -- VArr1[V(0x11)] << 0xABCD
CMov(P1,0x58F45C,VArrX(VArr1,V(0x11),V(0x12))) -- 보라 숫자 << VArr1[V(0x11)]
CMov(P1,VArrX(VArr1,Vi(0x11,-1),V(0x12)),0x90EF) -- VArr1[V(0x11)-1] << 0x90EF
CMov(P1,0x58F460,VArrX(VArr1,Vi(0x11,-1),V(0x12))) -- 주황 숫자 << Arr1[V(0x11)-1]
-----------------------------------------------------------------------------------------245

------------------------------------------------------------------------------------------

『

6장 : 변수/배열 선언 및 호출 함수 』

-----------------------------------------------------------------------------------------[예제 6-1] GetVArray(), CallLabel1(), CallLabel2(), CallLabel1X(), CallLabel2X(),
CallLabelAlways(), CallLabelAlwaysX(), CallVariable(), CallVariableX()
CJump(AllPlayers,0)
for i=0, 11 do
CVariable2(P1,0x10+i,0x58F450+0x4*i,SetTo,(i+1)*0x1111) -- 0x10 ~ 0x1B 변수 선언
end
VA1 = GetVArray(V(0x10)) -- V(0x10)이 시작점인 VArray 선언
CJumpEnd(AllPlayers,0)
DoActionsX(P1,{SetMemory(0x58F450,SetTo,0), -- 빨강/연두/주황/노랑 숫자 0으로 초기화
SetMemory(0x58F458,SetTo,0),
SetMemory(0x58F460,SetTo,0),
SetMemory(0x58F46C,SetTo,0)})
Trigger { -- 미네랄 -1이면 V(0x10) 호출 (빨강숫자 0x1111)
players = {P1},
conditions = {
Label(0);
Accumulate(P1,Exactly,-1,Ore);
},
actions = {
CallLabel1(P1,0x10);
PreserveTrigger();
}
}
DoActionsX(P1,CallLabel2(P1,0x10)) -- RecoverNext
DoActionsX(P1,CallLabelAlways(P1,0x11)) -- V(0x11) 호출 (파랑숫자 0x2222)
CallVariable(P1,P1,0x12,"X",Accumulate(P1,Exactly,1,Ore)) -- 미네랄 1이면 V(0x12) 호출 (연두숫자 0x3333)
CallVariableX(P1,V(0x13),"X") -- V(0x14) 호출 (보라숫자 0x4444)
Trigger { -- 가스 1이면 V(0x14) 호출 (주황숫자 0x5555)
players = {P1},
conditions = {
Label(0);
Accumulate(P1,Exactly,1,Gas);
},
actions = {
CallLabel1X(V(0x14));
PreserveTrigger();
}
}
DoActionsX(P1,CallLabel2X(V(0x14))) -- RecoverNext
DoActionsX(P1,CallLabelAlwaysX(V(0x15))) -- V(0x15) 호출 (갈색숫자 0x6666)
CallVariableX(P1,VArr(VA1,6),"X") -- VA1[6] 호출 (흰색숫자 0x7777)
Trigger { -- 가스 -1이면 VA1[7] 호출 (노랑숫자 0x8888)
players = {P1},
conditions = {
Label(0);
Accumulate(P1,Exactly,-1,Gas);
},
actions = {
CallLabel1X(VArr(VA1,7));
PreserveTrigger();
}
}
DoActionsX(P1,CallLabel2X(VArr(VA1,7))) -- RecoverNext
DoActionsX(P1,CallLabelAlwaysX(VArr(VA1,8))) -- VA1[8] 호출 (초록숫자 0x9999)

------------------------------------------------------------------------------------------

246

------------------------------------------------------------------------------------------

『

6장 : 변수/배열 선언 및 호출 함수 』

-----------------------------------------------------------------------------------------[예제 6-2] CallLabelAlways2(), CallLabelAlways3(), CallLabelAlways4(),
CallLabelAlways2X(), CallLabelAlways3X(), CallLabelAlways4X(), CallLabelAlwaysN()
CJump(AllPlayers,0)
for i=0, 11 do
for j = 0, 7 do
CVariable2(P1,0x10+j+8*i,0x58F450+0x4*i,SetTo,0x87654321,15*16^j) -- 0x10 ~ 0x6F 변수 선언
end
end
CJumpEnd(AllPlayers,0)
DoActionsX(P1,{-- 빨강/파랑/연두/보라/주황/갈색/하양/노랑 숫자 0으로 초기화
SetMemory(0x58F450,SetTo,0),
SetMemory(0x58F454,SetTo,0),
SetMemory(0x58F458,SetTo,0),
SetMemory(0x58F45C,SetTo,0),
SetMemory(0x58F460,SetTo,0),
SetMemory(0x58F464,SetTo,0),
SetMemory(0x58F468,SetTo,0),
SetMemory(0x58F46C,SetTo,0)})
DoActionsX(P1,CallLabelAlways2(P1,0x10+0,"X",P1,0x10+1,"X"))
-- V(0x10), V(0x11) 호출 (빨강숫자 0x21)
DoActionsX(P1,CallLabelAlways3(P1,0x18+0,"X",P1,0x18+1,"X",P1,0x18+2,"X"))
-- V(0x18), V(0x19), V(0x1A) 호출 (파랑숫자 0x321)
DoActionsX(P1,CallLabelAlways4(P1,0x20+0,"X",P1,0x20+1,"X",P1,0x20+2,"X",P1,0x20+3,"X"))
-- V(0x20), V(0x21), V(0x22), V(0x23) 호출 (연두숫자 0x4321)
DoActionsX(P1,CallLabelAlways2X(V(0x28+0),V(0x28+1)))
-- V(0x28), V(0x29) 호출 (보라숫자 0x21)
DoActionsX(P1,CallLabelAlways3X(V(0x30+0),V(0x30+1),V(0x30+2)))
-- V(0x30), V(0x31), V(0x32) 호출 (주황숫자 0x321)
DoActionsX(P1,CallLabelAlways4X(V(0x38+0),V(0x38+1),V(0x38+2),V(0x38+3)))
-- V(0x38), V(0x39), V(0x3A), V(0x3B) 호출 (갈색숫자 0x4321)
DoActionsX(P1,CallLabelAlwaysN(V(0x40+0)))
-- V(0x40) 호출 (하양숫자 0x1)

DoActionsX(P1,CallLabelAlwaysN(V(0x48+0),V(0x48+1),V(0x48+2),V(0x48+3),V(0x48+4),V(0x48+5),V(0x48+6),V(0x48+7)))

-- V(0x48), V(0x49), V(0x4A), V(0x4B), V(0x4C), V(0x4D), V(0x4E), V(0x4F) 호출 (노랑숫자 0x87654321)

------------------------------------------------------------------------------------------

247

------------------------------------------------------------------------------------------

『 7장 : DoActions류 트리거 생성 함수 』

-----------------------------------------------------------------------------------------[예제 7-1] TriggerX(), DoActionsX()
DoActionsX(P1,{ -- 이런식으로 엔터를 누르거나
SetMemory(0x58F458,SetTo,0xFFFFFFFF),
SetMemory(0x58F45C,SetTo,0xFFFFFFFF),
SetMemory(0x58F460,SetTo,0xFFFFFFFF),
SetMemory(0x58F464,SetTo,0xFFFFFFFF)})
TriggerX({P1}, -- 실제 트리거처럼 구획을 나눠서 작성할 수 있다.
{Always()},
{SetMemory(0x58F450,SetTo,0x12345678),
SetMemory(0x58F454,SetTo,0x90ABCDEF)},
{Preserved})
-----------------------------------------------------------------------------------------[예제 7-2] TriggerX(), DoActionsX()
DoActionsX(P1,{ -- Index : 0x1000 (1회 실행)
SetCtrig1X("X",0x1000,0x178,0,SetTo,EPD(0x58F468)),
SetMemory(0,SetTo,0x12341234)},1,0x1000)
-- SetMemory(0x58F468,SetTo,0x12341234)
TriggerX({P1}, -- Index : 0x1001 (1회 실행)
{Always()},
{SetCtrig1X("X",0x1001,0x178,0,SetTo,EPD(0x58F46C)),
SetMemory(0,SetTo,0x56785678)},
-- SetMemory(0x58F46C,SetTo,0x56785678)
nil,0x1001)
------------------------------------------------------------------------------------------

248

------------------------------------------------------------------------------------------

『 8장 : Ctrig 파생 조건/액션 함수 』

-----------------------------------------------------------------------------------------[예제 8-1] SetNext()
트리거 실행 순서 : A → B → C ---> A → C로 변경
Trigger { -- 트리거 A
players = {P1},
conditions = {
},
actions = {

}

SetNext(0x10,0x12); -- 트리거 A의 Next를 트리거 C로 설정
},
flag = {Preserved}

Trigger { -- 트리거 B
players = {P1},
conditions = {
},
actions = {

}

Label(0x11);

SetResources(P1,SetTo,1000,Ore); -- P1 미네랄 Set 0
},
flag = {Preserved}

Trigger { -- 트리거 C
players = {P1},
conditions = {
},
actions = {

}

Label(0x10);

Label(0x12);

SetResources(P1,SetTo,1000,Gas); -- P1 가스 Set 0
},
flag = {Preserved}

------------------------------------------------------------------------------------------

249

------------------------------------------------------------------------------------------

『 8장 : Ctrig 파생 조건/액션 함수 』

-----------------------------------------------------------------------------------------[예제 8-2] CVar(), SetCVar(), CVAar(), SetCVAar(), VariableX(), SetVariableX(),
VArrayX(), SetVArrayX()
CJump(AllPlayers,0)
VA1 = CVArray(P1,20)
CVariable(P1,0x10)
CVariable(P1,0x11)
CVariable(P1,0x12)
CJumpEnd(AllPlayers,0)

DoActionsX(P1,{SetCVar("X",0x10,Add,1),SetCVar("X",0x11,Add,1)}) -- V(0x10) ,V(0x11) 값 1씩 증가
Trigger {

players = {P1},
conditions = {
},
actions = {

Label(0);
CVar("X",0x10,Exactly,100); -- V(0x10)이 100이 되면

SetVariableX("X",0x10,"EPD",SetTo,EPD(0x58F450)); -- V(0x10)의 EPD를 0x58F450으로 설정 (빨강 숫자)

}
Trigger {

},
flag = {preserved}
players = {P1},
conditions = {
},
actions = {

Label(0);
VariableX("X",0x11,"Value",Exactly,200); -- V(0x11)이 200이 되면

SetVariableX("X",0x11,"EPD",SetTo,EPD(0x58F454)); -- V(0x10)의 EPD를 0x58F454으로 설정 (파랑 숫자)

}

},
flag = {preserved}

DoActionsX(P1,{SetCVAar(VArr(VA1,0),Add,1),SetCVAar(VArr(VA1,1),Add,1)}) -- VA1[0] ,VA1[1] 값 1씩 증가
Trigger {

players = {P1},
conditions = {
},
actions = {

Label(0);
CVAar(VArr(VA1,0),Exactly,50); -- VA1[0]이 100이 되면

SetVArrayX(VArr(VA1,0),"EPD",SetTo,EPD(0x58F458)); -- VA1[0]의 EPD를 0x58F458으로 설정 (연두 숫자)

}
Trigger {

},
flag = {preserved}
players = {P1},
conditions = {
},
actions = {

Label(0);
VArrayX(VArr(VA1,1),"Value",Exactly,100,0xFF); -- VA[1]이 100이 되면

SetVArrayX(VArr(VA1,1),"EPD",SetTo,EPD(0x58F45C)); -- VA[1]의 EPD를 0x58F45C으로 설정 (보라 숫자)

}

},
flag = {preserved}

DoActionsX(P1,{CallLabelAlwaysX(V(0x10))}) -- V(0x10) 호출
DoActionsX(P1,{CallLabelAlwaysX(V(0x11))}) -- V(0x11) 호출
DoActionsX(P1,{CallLabelAlwaysX(VArr(VA1,0))}) -- VA[0] 호출
DoActionsX(P1,{CallLabelAlwaysX(VArr(VA1,1))}) -- VA[1] 호출

------------------------------------------------------------------------------------------

250

------------------------------------------------------------------------------------------

『 8장 : Ctrig 파생 조건/액션 함수 』

-----------------------------------------------------------------------------------------[예제 8-3] Ccode(), _Ccode(), _Ncode(), CDeaths(), SetCDeaths, NDeaths(), SetNDeaths()
CJump(AllPlayers,0)
CVariable(P1,0x10) -- CDeaths용 기준변수
CD1 = Ccode(0x10,0)
CVariable(P1,0x11) -- NDeaths용 기준변수
ND1 = Ccode(0x11,0)
CJumpEnd(AllPlayers,0)
DoActionsX(P1,{SetCDeaths("X",Add,1,CD1),SetNDeaths(P2,Add,1,ND1)}) -- P1의 CD1과 P2의 ND1을 1씩 증가

Trigger {

players = {P1},
conditions = {
},
actions = {

}
Trigger {

SetResources(P1,SetTo,100,Ore); -- 미네랄을 100으로 설정
},
flag = {preserved}
players = {P1},
conditions = {

},
actions = {

}

Label(0);
CDeaths("X",Exactly,100,CD1); -- P1의 CD1이 100일때

Label(0);
NDeaths(P2,Exactly,100,ND1); -- P2의 ND1이 100일때

SetResources(P1,SetTo,100,Gas); -- 가스을 100으로 설정
},
flag = {preserved}

CRead(P1,0x58F450,_Ccode("X",CD1)) -- CurrentPlayer의 CD1을 Mem타입으로 변환 → 0x58F450 << Read("X",CD1)
CRead(P1,0x58F454,_Ncode(P2,ND1)) -- P2의 ND1을 Mem타입으로 변환 → 0x58F454 << Read(P2,ND1)

------------------------------------------------------------------------------------------

251

------------------------------------------------------------------------------------------

『 8장 : Ctrig 파생 조건/액션 함수 』

-----------------------------------------------------------------------------------------[예제 8-4] Mem(), MemX(), SetMemX(), _Ccode(), _Ncode()
CJump(AllPlayers,0)
CVariable(P1,0x10) CVariable(P1,0x11)
CD1 = Ccode(0x10,0) ND1 = Ccode(0x11,0) A1 = CArray(P1,100)
CJumpEnd(AllPlayers,0)
DoActionsX(P1,{SetMemX(_Ccode("X",CD1),Add,1),SetMemX(_Ncode(P2,ND1),Add,1)})
-- CurrentPlayer의 CD1과 P2의 ND1의 값을 1씩 증가
Trigger {
players = {P1},
conditions = {
Label(0);
MemX(_Ccode("X",CD1),Exactly,100); -- CurrentPlayer의 CD1이 100일때
},
actions = {
SetResources(P1,SetTo,100,Ore); -- 미네랄을 100으로 설정
},
flag = {preserved}
}
Trigger {
players = {P1},
conditions = {
Label(0);
MemX(_Ncode(P2,ND1),Exactly,100); -- P2의 ND1이 100일때
},
actions = {
SetResources(P1,SetTo,100,Gas); -- 가스을 100으로 설정
},
flag = {preserved}
}
DoActionsX(P1,{SetMemX(Arr(A1,0),SetTo,0)},0) -- A1[0] 초기화
DoActionsX(P1,{SetMemX(Arr(A1,0),Add,1),SetMemory(0x58F454,SetTo,0)}) -- A1[0]을 1씩 증가, 0x58F454 0으로 초기화
Trigger { -- A트리거
players = {P1},
conditions = {

},
actions = {

}

Label(0);
MemX(Arr(A1,0),Exactly,100); -- A1[0]이 100일경우

SetMemory(0x58F450,SetTo,0x100); -- 0x58F450 (빨강숫자) 0x100으로 설정
SetMemX(Mem("X","X",0x4,0),SetTo,Mem("X","X",0x0,2)); -- A트리거의 Next를 C트리거로 설정 (A → C)
},
flag = {preserved}

Trigger { -- B트리거
players = {P1},
conditions = {
},
actions = {

Label(0);

SetMemory(0x58F454,SetTo,0x1234); -- 0x58F454 (파란숫자) 0x1234로 설정
},
flag = {preserved}

}
Trigger { -- C트리거
players = {P1},
conditions = {
},
actions = {

}

Label(0);

SetMemory(0x58F458,SetTo,0x1234);
},
flag = {preserved}

------------------------------------------------------------------------------------------

252

------------------------------------------------------------------------------------------

『 9장 : Cp트릭 관련 및 CunitCtrig 함수 』

-----------------------------------------------------------------------------------------[예제 9-1] RecoverCp(), SetRecoverCp()
CJump(AllPlayers,0)
CVariable(P1,0x10) -- Cp값 저장용 변수
CJumpEnd(AllPlayers,0)
DoActions(P1,{SetMemory(0x6509B0,SetTo,EPD(0x58F450)), -- Cp << EPD(0x58F450)
SetDeaths(CurrentPlayer,SetTo,0x12345678,0)}) -- 0x58F450 << 0x12345678 (빨강숫자)
RecoverCp(P1) -- CurrentPlayer값으로 Cp 복구

SetRecoverCp(EPD(0x58F454)) -- RecoverCp << EPD(0x58F454)
RecoverCp(P1) -- EPD(0x58F454)로 Cp 복구
DoActions(P1,{SetDeaths(CurrentPlayer,SetTo,0x567890AB,0)}) -- 0x58F454 << 0x567890AB (파랑숫자)
CMov(P1,V(0x10),EPD(0x58F458)) -- V(0x10) << EPD(0x58F458)
SetRecoverCp(V(0x10)) -- RecoverCp << V(0x10)
RecoverCp(P1) -- V(0x10)값으로 Cp 복구
DoActions(P1,{SetDeaths(CurrentPlayer,SetTo,0x90ABCDEF,0)}) -- 0x58F458 << 0x90ABCDEF (연두숫자)
SetRecoverCp() -- RecoverCp << CurrnetPlayer
RecoverCp(P1) -- CurrentPlayer값으로 Cp 복구

-----------------------------------------------------------------------------------------[예제 9-2] SaveCp(), LoadCp(), MoveCp()
CJump(AllPlayers,0)
CVariable(P1,0x10) -- Cp값 저장용 변수
CJumpEnd(AllPlayers,0)
DoActions(P1,{SetMemory(0x58F458,SetTo,0), -- (연두숫자) 0으로 초기화
SetMemory(0x6509B0,SetTo,EPD(0x58F450)), -- Cp << EPD(0x58F450)
SetDeaths(CurrentPlayer,SetTo,0x12345678,0)}) -- 0x58F450 << 0x12345678 (빨강숫자)
SaveCp(P1,V(0x10)) -- V(0x10) << 현재 Cp값
RecoverCp(P1) -- Cp << CurrentPlayer
DoActions(P1,DisplayText("1234",4)) -- "1234" 출력
LoadCp(P1,V(0x10)) -- Cp << V(0x10)
DoActions(P1,{MoveCp(Add,0x4), -- Cp += 1 (타겟 Offset +=0x4)
SetDeaths(CurrentPlayer,SetTo,0x567890AB,0)}) -- 0x58F454 << 0x567890AB (파랑숫자)
Trigger {
players = {P1},
conditions = {
Accumulate(P1,Exactly,1,Ore); -- 미네랄이 1일때
},
actions = {
MoveCp(Add,0x4); -- Cp += 1
SetDeaths(CurrentPlayer,SetTo,0x90ABCDEF,0); -- 0x58F458 << 0x90ABCDEF (연두숫자)
MoveCp(Subtract,0x4); -- Cp -= 1
-- (Cp트릭 도중에 조건문으로 Cp값의 변화가 있을경우 반드시 분기점 이전의 값으로 되돌려야함)

},
flag = {Preserved}

}
LoadCp(P1) -- Cp << CurrentPlayer로 복구

------------------------------------------------------------------------------------------

253

------------------------------------------------------------------------------------------

『 9장 : Cp트릭 관련 및 CunitCtrig 함수 』

-----------------------------------------------------------------------------------------[예제 9-3] CunitCtrig_Part1(), CunitCtrig_Part2(), CunitCtrig_Part3(),
BreakCalc(), ClearCalc(), MoveCp()
실행 순서 : A → B → C → D → E → F (유닛 체력 300 미만일경우)
A → B → C → D → E → E2 → E3 → F (BreakCalc)
A → B → C → D → E → E2 → E3 → E4 → F (ClearCalc)
CunitCtrig_Part1(P1) -- Cunit Ctrig 시작 (A)
MoveCp("X",0x8) -- MoveCp값 0x8로 세팅 (Part3 설정값) (D)
NJump(P1,0x1,Deaths(CurrentPlayer,AtLeast,300*256,0)) -- 유닛 체력이 300 이상일때 점프 (E)
CunitCtrig_Part2() -- (F)
NJumpEnd(P1,0x1) -- 유닛 체력이 300 이상일때 점프 도착지점 (E2)
DoActions(P1,MoveCp(SetTo,0x64)) -- Cp Set Cp+0x64
Trigger {
players = {P1},
conditions = {
Deaths(CurrentPlayer,Exactly,0,0); -- 유닛 Id(0x64) 가 0일경우 (마린)
},
actions = {
MoveCp(SetTo,0x8); -- Cp Set Cp+0x8
SetDeaths(CurrentPlayer,SetTo,150*256,0); -- 유닛 체력(0x8) 150으로 설정
MoveCp(SetTo,0x64); -- Cp Set Cp+0x64 (조건문 이전값으로 복구)
},
flag = {Preserved}
}
BreakCalc(Deaths(CurrentPlayer,Exactly,0,0)) -- 유닛 Id(0x64)가 0일경우 (마린) 계산 단락 종료 (E3)
DoActions(P1,MoveCp(SetTo,0x8)) -- Cp Set Cp + 0x8
DoActions(P1,SetDeaths(CurrentPlayer,SetTo,50*256,0)) -- 유닛 체력(0x8)을 50으로 설정
ClearCalc() -- 계산 단락 종료 (E4)
MoveCp("X",0x0) -- MoveCp값 초기화 (B)
CunitCtrig_Part3({},
{MoveCp(SetTo,0x8), -- Cp Set Cp+0x8
SetDeaths(CurrentPlayer,Add,1*256,0)}) -- 유닛 체력(0x8) +1씩 증가 (C)

------------------------------------------------------------------------------------------

254

------------------------------------------------------------------------------------------

『 9장 : Cp트릭 관련 및 CunitCtrig 함수 』

-----------------------------------------------------------------------------------------[예제 9-4] CunitCtrig_Part1(), CunitCtrig_Part2(), CunitCtrig_Part3X(), CunitCtrig_Part4X(),
CunitCtrig_End(), LoadCp(), MoveCp(), Vi()
CJump(AllPlayers,0)
CVariable(P1,0x10) -- Cp 저장용 변수
CVariable(P1,0x11) -- 인덱스(i) 저장용 변수
Include_ArithMetic() -- _Mul 함수 원형 선언
CJumpEnd(AllPlayers,0)
CunitCtrig_Part1(P1)
MoveCp("X",0x8) -- MoveCp값 0x8로 세팅 (Part4X 설정값)
NJump(P1,0x1,Deaths(CurrentPlayer,AtLeast,300*256,0)) -- Hp가 300이상일 경우 점프
CunitCtrig_Part2()
NJumpEnd(P1,0x1) -- 유닛 체력이 300 이상일때 점프 도착지점

DoActions(P1,SetDeaths(CurrentPlayer,SetTo,50*256,0)) -- Hp를 50으로 설정
LoadCp(P1,Vi(0x10,0x60/4)) -- Cp << V(0x10) + 0x60/4 및 RecoverCp값 << V(0x10) + 0x60/4
CMov(P1,"Cp",_Mul(V(0x11),_Read(0x57f0f0))) -- 유닛 쉴드 << P1 미네랄값 * V(0x11) 로 설정
ClearCalc()
CunitCtrig_Part3X()
for i = 0, 1699 do -- Part4X 용 Cunit Loop (x1700)
CunitCtrig_Part4X(i,MemoryX(0x628298-0x150*i+0x4C,Exactly,0,0xFF), -- P1의 유닛일경우
{SetCVar("X",0x10,SetTo,EPD(0x628298-0x150*i)), -- V(0x10) << Cp값 저장
SetCVar("X",0x11,SetTo,i), -- V(0x11) << i
MoveCp(SetTo,0x8), -- Cp Set Cp+0x8
SetDeaths(CurrentPlayer,Add,i,0)}) -- Hp i/256씩 증가
end
CunitCtrig_End()

------------------------------------------------------------------------------------------

255

------------------------------------------------------------------------------------------

『 10장 : 제어문 관련 함수 (CStruct) 』

-----------------------------------------------------------------------------------------[예제 10-A] CJump(), CJumpEnd(), NJump(), NJumpEnd(), SetCJump()
CJump(P1,0x10) -- (A) CJump 작동시 B로 점프
DoActions(P1,DisplayText("CJump Off",4)); -- CJump 작동 안할시 출력되는 메세지
CJumpEnd(P1,0x10) -- (B)
Trigger {
players = {P1},
conditions = {
Label(0);
Accumulate(P1,Exactly,1,Ore); -- 미네랄이 1일경우
},
actions = {
SetCJump(0x10,"Off"); -- sIndex : 0x10 인 CJump를 작동 중지합니다.
},
flag = {Preserved}
}
Trigger {
players = {P1},
conditions = {
Label(0);
Accumulate(P1,Exactly,-1,Ore); -- 미네랄이 -1일경우
},
actions = {
SetCJump(0x10,"On"); -- sIndex : 0x10 인 CJump를 작동시킵니다.
},
flag = {Preserved}
}
NJump(P1,0x11,Accumulate(P1,Exactly,1,Gas)) -- (C) NJump 작동시 D로 점프
DoActions(P1,DisplayText("NJump Off",4)); -- NJump 작동 안할시 출력되는 메세지
NJumpEnd(P1,0x11) -- (D)

-----------------------------------------------------------------------------------------[예제 10-B] CIf(), CIfEnd(), NIf(), NIfEnd(), CWhile(), CWhileEnd(), NWhile(), NWhileEnd()
CIf(P1,Accumulate(P1,Exactly,1,Ore)) -- 미네랄이 1일경우
DoActions(P1,DisplayText("CIf 조건 만족",4)); -- 조건만족시 출력
CIfEnd()
NIf(P1,Accumulate(P1,Exactly,-1,Ore)) -- 미네랄이 -1일경우
DoActions(P1,DisplayText("NIf 조건 만족",4)); -- 조건만족시 출력
NIfEnd()
CWhile(P1,{Accumulate(P1,AtLeast,1,Gas)
,Accumulate(P1,AtMost,0x80000000,Gas),Accumulate(P1,Exactly,2,Ore)})
DoActions(P1,{SetResources(P1,Subtract,1,Gas),DisplayText("CWhile 실행",4)});
CWhileEnd() -- 미네랄이 2일경우 가스양만큼 출력
NWhile(P1,{Accumulate(P1,AtLeast,1,Gas)
,Accumulate(P1,AtMost,0x80000000,Gas),Accumulate(P1,Exactly,-2,Ore)})
DoActions(P1,{SetResources(P1,Subtract,1,Gas),DisplayText("NWhile 실행",4)});
NWhileEnd() -- 미네랄이 -2일경우 가스양만큼 출력

------------------------------------------------------------------------------------------

256

------------------------------------------------------------------------------------------

『 10장 : 제어문 관련 함수 (CStruct) 』

-----------------------------------------------------------------------------------------[예제 10-C] CIfOnce(), CLoop(), NLoop(), DoWhile(), DoWhileEnd()
CIfOnce(P1)
CIfEnd()

DoActions(P1,DisplayText("CIfOnce 조건 만족",4)); -- 조건만족시 출력 (1회)

CLoop(P1,16,Accumulate(P1,Exactly,1,Ore)) -- 미네랄이 1일경우
DoActions(P1,SetMemory(0x58F450,Add,1)); -- (빨강숫자 +1) x 16회 반복
CWhileEnd()
NLoop(P1,256,Accumulate(P1,Exactly,-1,Ore)) -- 미네랄이 -1일경우
DoActions(P1,SetMemory(0x58F454,Add,1)); -- (파랑숫자 +1) x 256회 반복
NWhileEnd()
DoWhile(P1)
DoActions(P1,SetMemory(0x58F458,Add,1)); -- (연두숫자 +1) - 조건 만족 안하면 1회 실행 / 가스 수 만큼 반복
DoWhileEnd({Accumulate(P1,AtLeast,1,Gas)
,Accumulate(P1,AtMost,0x80000000,Gas)},SetResources(P1,Subtract,1,Gas))

-----------------------------------------------------------------------------------------[예제 10-D] CFor(), CForEnd(), CForVariable(), CIfX(), CElseIfX(), CElseX(), CIfXEnd()
, NIfX(), NElseIfX(), NElseX(), NIfXEnd()
CFor(P1,0,10,2) -- for i = 0, 10, 2 do (10일때는 실행X)
Var1 = CForVariable() -- CFor 내부 인덱스 변수 데이터 반환
CIfX(P1,MemX(_Mem(Var1),Exactly,0))
DoActions(P1,DisplayText("i = 0"));
CElseIfX(MemX(_Mem(Var1),Exactly,2))
DoActions(P1,DisplayText("i = 2"));
CElseIfX(MemX(_Mem(Var1),Exactly,4))
DoActions(P1,DisplayText("i = 4"));
CElseIfX(MemX(_Mem(Var1),Exactly,6))
DoActions(P1,DisplayText("i = 6"));
CElseX()
DoActions(P1,DisplayText("i = 8"));
CIfXEnd()
CForEnd()
NIfX(P1,Accumulate(P1,AtMost,0x7FFFFFFF,Ore))
NIfX(P1,Accumulate(P1,AtMost,0x7FFFFFFF,Gas))
DoActions(P1,DisplayText("미네랄 양수, 가스
NElseX()
DoActions(P1,DisplayText("미네랄 양수, 가스
NIfXEnd()
NElseX()
NIfX(P1,Accumulate(P1,AtMost,0x7FFFFFFF,Gas))
DoActions(P1,DisplayText("미네랄 음수, 가스
NElseX()
DoActions(P1,DisplayText("미네랄 음수, 가스
NIfXEnd()
NIfXEnd()

양수"));
음수"));

양수"));
음수"));

------------------------------------------------------------------------------------------

257

------------------------------------------------------------------------------------------

『 10장 : 제어문 관련 함수 (CStruct) 』

-----------------------------------------------------------------------------------------[예제 10-E] SLoopN()
SLoopN(P1,500,{TTAccumulate(P1,Above,1,Ore)},{SetMemory(0x58F450,Add,1)},
{SetResources(P1,Subtract,1,Ore)},1)
-- 미네랄 1 초과시 미네랄 1 감소후 (0x58F450(빨강)+1)x500회 반복
SLoopN(P1,{_Read(0x58F454),5000},{TTAccumulate(P1,Above,1,Gas)},{SetMemory(0x58F458,Add,1)},nil,
{SetResources(P1,Subtract,1,Gas)})
-- 가스 1 초과시 (0x58F458(연두)+1)x(0x58F454(파랑)의 값/4,최대 5000)회 반복후 가스 1 감소
SLoopN(P1,500,{TTMemory(0x58F45C,Above,1)}) -- 0x58F45C(보라) 1 초과시 500회 반복
CIf(P1,Command(P1,AtLeast,10,"Protoss Dragoon"))
DoActions(P1,SetMemory(0x58F460,Add,1)) -- (주황)
CIfEnd()
SLoopNEnd({SetMemory(0x58F45C,Subtract,1)}) -- 0x58F45C(보라) -1
SLoopN(P1,{_Read(0x58F464),5000},{TTMemory(0x58F468,Above,1)})
-- 0x58F468(하양) 1 초과시 (0x58F464(갈색)의 값/4, 최대 5000)회 반복
CIf(P1,Command(P1,AtLeast,10,"Protoss Zealot"))
DoActions(P1,SetMemory(0x58F46C,Add,1)) -- (노랑)
CIfEnd()
SLoopNEnd({SetMemory(0x58F468,Subtract,1)}) -- 0x58F468(하양) -1

-----------------------------------------------------------------------------------------[예제 10-F] CJumpX(), CJumpXEnd(), NJumpX(), NJumpXEnd()
NIf(P1,Accumulate(P1,Exactly,1,Ore))
CJumpX(P1,0x10)
NIfEnd()
DoActions(P1,DisplayText("CJump1"))
NIf(P1,Accumulate(P1,Exactly,2,Ore))
CJumpX(P1,0x10)
NIfEnd()
DoActions(P1,DisplayText("CJump2"))
NIf(P1,Accumulate(P1,Exactly,3,Ore))
CJumpX(P1,0x10)
NIfEnd()
DoActions(P1,DisplayText("CJump3"))
CJumpXEnd(P1,0x10)
NJumpX(P1,0x11,Accumulate(P1,Exactly,1,Gas))
DoActions(P1,DisplayText("NJump1"))
NJumpX(P1,0x11,Accumulate(P1,Exactly,2,Gas))
DoActions(P1,DisplayText("NJump2"))
NJumpX(P1,0x11,Accumulate(P1,Exactly,3,Gas))
DoActions(P1,DisplayText("NJump3"))
NJumpXEnd(P1,0x11)

------------------------------------------------------------------------------------------

258

------------------------------------------------------------------------------------------

『 10장 : 제어문 관련 함수 (CStruct) 』

-----------------------------------------------------------------------------------------[예제 10-G] CWhileX, CWhileXEnd, NWhileX, NWhileXEnd()
CIf(P1,Accumulate(P1,Exactly,1,Ore))
CWhileX(P1,{TTCommand(P1,">",1,"Protoss Dragoon")})
CDoActions(P1,{TGiveUnits(1,"Protoss Dragoon",P1,"Anywhere",P2)
,TKillUnitAt(1,"Protoss Dragoon","Anywhere",P2),DisplayText("CWhileX 실행",4)})
CWhileXEnd()
CIfEnd()
CIf(P1,Accumulate(P1,Exactly,1,Gas))
NWhileX(P1,{TTCommand(P1,">",1,"Protoss Zealot")})
CDoActions(P1,{TGiveUnits(1,"Protoss Zealot",P1,"Anywhere",P2)
,TKillUnitAt(1,"Protoss Zealot","Anywhere",P2),DisplayText("NWhileX 실행",4)})
NWhileXEnd()
CIfEnd()

-----------------------------------------------------------------------------------------[예제 10-H] CWhile(), NWhile() : T/TT 조건 변수 삽입시 추가처리 방법
CJump(AllPlayers,0)
CVariable(P1,0x10)
CJumpEnd(AllPlayers,0)
CIf(P1,Accumulate(P1,Exactly,1,Ore))
CMov(P1,V(0x10),5) -- 무한 루프 방지용 조건추가
CWhile(P1,{TTCommand(P1,">",1,"Protoss Dragoon"),CVar(P1,0x10,AtLeast,1)},SetCVar(P1,0x10,Subtract,1))
CDoActions(P1,{TGiveUnits(1,"Protoss Dragoon",P1,"Anywhere",P2),
TKillUnitAt(1,"Protoss Dragoon","Anywhere",P2),DisplayText("CWhile 실행",4)})
CWhileEnd()
CIfEnd()
-- TT 특수 조건 삽입시 TT 조건 만족여부 체크 트리거가 While문 만족시 따로 초기화 하지 않아 무한루프에 빠진다.

CIf(P1,Accumulate(P1,Exactly,1,Gas))
CJumpEnd(P1,0x10)
NWhile(P1,{TTCommand(P1,">",1,"Protoss Dragoon")})
CDoActions(P1,{TGiveUnits(1,"Protoss Dragoon",P1,"Anywhere",P2)
,TKillUnitAt(1,"Protoss Dragoon","Anywhere",P2),DisplayText("NWhile 실행",4)})
CJump(P1,0x10)
NWhileEnd()
CIfEnd()
해결방법 : 반복문 도중에 Jump가 가능한 NWhile을 사용하고,
NWhileEnd 바로 위에 CJump를 추가하고 NWhile 바로 앞에 CJumpEnd를 추가해
반복문 실행시 변수 삽입 및 특수 조건 체크 트리거를 실행시키게 만든다.
(CJumpEnd(도착지) → 초기화 트리거들 → NWhile → 내용물 → CJump → NWhileEnd 순서로 배치됨)

------------------------------------------------------------------------------------------

259

------------------------------------------------------------------------------------------

『 11장 : SafeRead류 데이터 읽기 관련 함수 』

-----------------------------------------------------------------------------------------[예제 11-A] SafeReadX()
CJump(AllPlayers,0)
CVariable2(P1,0x10,"X","X",0x58DC60) -- Input 용 변수
CVariable(P1,0x11) -- 값 저장용 변수
CJumpEnd(AllPlayers,0)
CMov(P1,0x58F47C,0x57f0f0) -- 0x58F47C << 0x57f0f0
SafeReadX(P1,V(0x10),{V(0x11),0x58F450},0xFFFFFFFF) -- V(0x11), 0x58F450 << V(0x10)
CMov(P1,0x58F454,V(0x11))
SafeReadX(P1,V(0x10),{V(0x11),0x58F458},0xFFFFFFFF,1) -- V(0x11), 0x58F450 << EPD(V(0x10))
CMov(P1,0x58F45C,V(0x11))
SafeReadX(P1,0x58F47C,{V(0x11),0x58F460},0xFFFFFFFF) -- V(0x11), 0x58F450 << 0x58F47C
CMov(P1,0x58F464,V(0x11))
SafeReadX(P1,0x58F47C,{V(0x11),0x58F468},0xFFFFFFFF,1) -- V(0x11), 0x58F450 << EPD(0x58F47C)
CMov(P1,0x58F46C,V(0x11))

-----------------------------------------------------------------------------------------[예제 11-B] UnitReadX()
CJump(AllPlayers,0)
CVariable(P1,0x10)
CJumpEnd(AllPlayers,0)
UnitReadX(P1,P1,"Protoss Dragoon","Anywhere",V(0x10))
-- V(0x10) << Anywhere에 있는 P1 드라군의 갯수 (Bring)
CMov(P1,0x58F450,V(0x10))
UnitReadX(P1,P1,"Protoss Zealot","X",V(0x10))
-- V(0x10) << P1 질럿의 갯수 (Command)
CMov(P1,0x58F454,V(0x10))

-----------------------------------------------------------------------------------------[예제 11-C] ConvertReadX()
CJump(AllPlayers,0)
CVariable2(P1,0x10,"X","X",0x58DC60) -- Input 용 변수
CVariable(P1,0x11) -- 값 저장용 변수
CJumpEnd(AllPlayers,0)
CMov(P1,0x58F47C,0x57f0f0) -- 0x58F47C << 0x57f0f0
ConvertReadX(P1,V(0x10),{V(0x11),0x58F450},1,0xFFFFFFFF)
-- V(0x11), 0x58F450 << V(0x10)
CMov(P1,0x58F454,V(0x11))
ConvertReadX(P1,V(0x10),{V(0x11),0x58F458},0x100,0xFFFFFFFF)
-- V(0x11), 0x58F450 << V(0x10)*0x100
CMov(P1,0x58F45C,V(0x11))
ConvertReadX(P1,0x58F47C,{V(0x11),0x58F460},0x10000,0xFFFFFFFF)
-- V(0x11), 0x58F450 << V(0x10)*0x10000 (Cycle미사용)
CMov(P1,0x58F464,V(0x11))
ConvertReadX(P1,0x58F47C,{V(0x11),0x58F468},0xFFFFFFFF,0xFFFFFFFF,1)
-- V(0x11), 0x58F450 << V(0x10)*-1 (Cycle사용)
CMov(P1,0x58F46C,V(0x11))

------------------------------------------------------------------------------------------

260

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

-----------------------------------------------------------------------------------------[예제 12-A] CRead()
CJump(AllPlayers,0)
CVariable(P1,0x10) -- 변수
A1 = CArray(P1,1000) -- 배열
VA1 = CVArray(P1,10) -- 변수배열
CVariable2(P1,0x20,"X","X",1) -- 인덱스 변수
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)
CRead(P1,0x58F450,0x57F0F0) -- 0x58F450 << Read(0x57F0F0) (빨강)
CRead(P1,V(0x10),0x57F0F0) -- V(0x10) << Read(0x57F0F0)
CRead(P1,Arr(A1,0),0x57F0F0) -- A1[0] << Read(0x57F0F0)
CRead(P1,VArr(VA1,0),0x57F0F0) -- VA1[0] << Read(0x57F0F0)
CRead(P1,Arr(A1,V(0x20)),0x57F0F0) -- A1[V(0x20)] << Read(0x57F0F0)
CRead(P1,VArr(VA1,V(0x20)),0x57F0F0) -- VA1[V(0x20)] << Read(0x57F0F0)

CRead(P1,LArr(LA1,0),0x57F0F0) -- LA1[0]L << Read(0x57F0F0)
CRead(P1,LArr({LA1,1},0),0x57F0F0) -- LA1[0]H << Read(0x57F0F0)
CRead(P1,LArr(LA1,V(0x20)),0x57F0F0) -- LA1[V(0x20)]L << Read(0x57F0F0)
CRead(P1,LArr({LA1,1},V(0x20)),0x57F0F0) -- LA1[V(0x20)]H << Read(0x57F0F0)
CRead(P1,0x58F454,_Mem(V(0x10))) -- 0x58F454 << Read(V(0x10)의 주소) (파랑)
CRead(P1,0x58F458,Arr(A1,0)) -- 0x58F458 << Read(A1[0]) (연두)
CRead(P1,0x58F45C,_Mem(VArr(VA1,0))) -- 0x58F45C << Read(VA1[0]의 주소) (보라)
CRead(P1,0x58F460,Arr(A1,V(0x20))) -- 0x58F460 << Read(A1[V(0x20)]) (주황)
CRead(P1,0x58F464,_TMem(VArr(VA1,V(0x20)))) -- 0x58F464 << Read(VA1[V(0x20)]의 주소) (갈색)
CRead(P1,0x58F4E0,LArr(LA1,0)) -- 0x58F4E0 << Read(LA1[0])L
CRead(P1,0x58F4E4,LArr({LA1,1},0)) -- 0x58F4E4 << Read(LA1[0])H
CRead(P1,0x58F4E8,LArr(LA1,V(0x20))) -- 0x58F4E8 << Read(LA1[V(0x20)])L
CRead(P1,0x58F4EC,LArr({LA1,1},V(0x20))) -- 0x58F4EC << Read(LA1[V(0x20)])H
CMov(P1,V(0x10),EPD(0x57F120)) -- V(0x10) << EPD(0x57F120)
CMov(P1,VArr(VA1,0),EPD(0x57F120)) -- VA1[0] << EPD(0x57F120)
CMovX(P1,VArr(VA1,V(0x20)),EPD(0x57f120)) -- VA1[V(0x20)] << EPD(0x57F120)
CRead(P1,0x58F468,V(0x10)) -- 0x58F468 << Read(V(0x10)) (흰색)
CRead(P1,0x58F46C,VArr(VA1,0)) -- 0x58F46C << Read(VA1[0]) (노랑)
CRead(P1,0x58F470,VArr(VA1,V(0x20))) -- 0x58F470 << Read(VA1[V(0x20)]) (초록)

------------------------------------------------------------------------------------------

261

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

-----------------------------------------------------------------------------------------[예제 12-B] CReadX()
CJump(AllPlayers,0)
CVariable(P1,0x10) -- 변수
A1 = CArray(P1,1000) -- 배열
VA1 = CVArray(P1,10) -- 변수배열
CVariable2(P1,0x20,"X","X",1) -- 인덱스 변수
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)
CReadX(P1,0x58F450,0x57F0F0,"X","X",0x100) -- *256
CReadX(P1,V(0x10),0x57F0F0,"X","X",0x100) -- *256
CReadX(P1,Arr(A1,0),0x57F0F0,"X","X",0x100) -- *256
CReadX(P1,VArr(VA1,0),0x57F0F0,"X","X",0x100) -- *256
CReadX(P1,Arr(A1,V(0x20)),0x57F0F0,"X","X",0x100) -- *256
CReadX(P1,VArr(VA1,V(0x20)),0x57F0F0,"X","X",0x100) -- *256

CReadX(P1,LArr(LA1,0),0x57F0F0,"X","X",0x100) -- *256
CReadX(P1,LArr({LA1,1},0),0x57F0F0,"X","X",0x100) -- *256
CReadX(P1,LArr(LA1,V(0x20)),0x57F0F0,"X","X",0x100) -- *256
CReadX(P1,LArr({LA1,1},V(0x20)),0x57F0F0,"X","X",0x100) -- *256
CReadX(P1,0x58F454,_Mem(V(0x10)))
CReadX(P1,0x58F458,Arr(A1,0))
CReadX(P1,0x58F45C,_Mem(VArr(VA1,0)))
CReadX(P1,0x58F460,Arr(A1,V(0x20)))
CReadX(P1,0x58F464,_TMem(VArr(VA1,V(0x20))))
CReadX(P1,0x58F4E0,LArr(LA1,0))
CReadX(P1,0x58F4E4,LArr({LA1,1},0))
CReadX(P1,0x58F4E8,LArr(LA1,V(0x20)))
CReadX(P1,0x58F4EC,LArr({LA1,1},V(0x20)))
CMov(P1,V(0x10),EPD(0x57F120))
CMov(P1,VArr(VA1,0),EPD(0x57F120))
CMovX(P1,VArr(VA1,V(0x20)),EPD(0x57f120))
CReadX(P1,0x58F468,V(0x10),"X","X",0x100) -- *256
CReadX(P1,0x58F46C,VArr(VA1,0),"X","X",0x100) -- *256
CReadX(P1,0x58F470,VArr(VA1,V(0x20)),"X","X",0x100) -- *256

------------------------------------------------------------------------------------------

262

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

-----------------------------------------------------------------------------------------[예제 12-C] CMov()
CJump(AllPlayers,0)
CVariable(P1,0x10)
A1 = CArray(P1,1000)
VA1 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20 -- V(0x20) = V(i)
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)
CMov(P1,0x58F450,0x12345678) -- 0x58F450 << 0x12345678
CMov(P1,V(0x10),0x23456789) -- V(0x10) << 0x23456789
CMov(P1,Arr(A1,0),0x34567890) -- A1[0] << 0x34567890
CMov(P1,VArr(VA1,0),0x4567890A) -- VA1[0] << 0x4567890A
CMov(P1,Arr(A1,V(i)),0x567890AB) -- A1[i] << 0x56789AB
CMov(P1,VArr(VA1,V(i)),0x67890ABC) -- VA1[i] << 0x67890ABC

CMov(P1,LArr(LA1,0),0x7890ABCD) -- LA1[0]L << 0x7890ABCD
CMov(P1,LArr({LA1,1},0),0x890ABCDE) -- LA1[0]H << 0x890ABCDE
CMov(P1,LArr(LA1,V(0x20)),0X90ABCDEF) -- LA1[V(0x20)]L << 0X90ABCDEF
CMov(P1,LArr({LA1,1},V(0x20)),0xABCDEF12) -- LA1[v(0X20)]H << 0xABCDEF12
CMov(P1,0x58F454,V(0x10)) -- 0x58F454 << V(0x10)
CMov(P1,0x58F458,_Read(Arr(A1,0))) -- 0x58F458 << A1[0]
CMov(P1,0x58F45C,VArr(VA1,0)) -- 0x58F45C << VA1[0]
CMov(P1,0x58F460,_Read(Arr(A1,V(i)))) -- 0x58F460 << A1[i]
CMov(P1,0x58F464,VArr(VA1,V(i))) -- 0x58F464 << VA1[i]
CMov(P1,0x58F4E0,_Read(LArr(LA1,0))) -- 0x58F4E0 << LA1[0]L
CMov(P1,0x58F4E4,_Read(LArr({LA1,1},0))) -- 0x58F4E4 << LA1[0]H
CMov(P1,0x58F4E8,_Read(LArr(LA1,V(0x20)))) -- 0x58F4E8 << LA1[V(0x20)]L
CMov(P1,0x58F4EC,_Read(LArr({LA1,1},V(0x20)))) -- 0x58F4EC << LA1[V(0x20)]H

------------------------------------------------------------------------------------------

263

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

-----------------------------------------------------------------------------------------[예제 12-D] CMovX()
CJump(AllPlayers,0)
CVariable(P1,0x10) CVariable(P1,0x11)
A1 = CArray(P1,1000)
VA1 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)
CMovX(P1,VArr(VA1,V(i)),0x12345678) -- VA1[i] << 0x12345678 : VArr << 상수
CMovX(P1,0x58F450,VArr(VA1,V(i))) -- 0x58F450 << VA1[i] : 상수 << VArr
CMov(P1,V(0x10),0x12345678)
CMovX(P1,VArr(VA1,V(i)),V(0x10)) -- VA1[i] << V(0x10) : VArr << V
CMovX(P1,V(0x11),VArr(VA1,V(i))) -- V(0x11) << VA1[i] : V << VArr
CMov(P1,0x58F454,V(0x11))
CMovX(P1,Arr(A1,V(i)),0x12345678) -- A1[i] << 0x12345678 : Arr << 상수
CRead(P1,0x58F458,Arr(A1,V(i)))
CMovX(P1,Arr(A1,V(i)),V(0x10)) -- A1[i] << 0x12345678 : Arr << V
CRead(P1,0x58F45C,Arr(A1,V(i)))
CMovX(P1,LArr(LA1,V(i)),0x12345678) -- LA1[i]L << 0x12345678 : LArr << 상수
CRead(P1,0x58F4E0,LArr(LA1,V(i)))
CMovX(P1,LArr({LA1,1},V(i)),0x90ABCDEF) -- LA1[i]H << 0x90ABCDEF : LArr << 상수
CRead(P1,0x58F4E4,LArr({LA1,1},V(i)))
CMov(P1,V(0x10),0x12345678)
CMovX(P1,LArr(LA1,V(i)),V(0x10)) -- LA1[i]L << 0x12345678 : LArr << V
CRead(P1,0x58F4E8,LArr(LA1,V(i)))
CMov(P1,V(0x10),0x90ABCDEF)
CMovX(P1,LArr({LA1,1},V(i)),V(0x10)) -- LA1[i]H << 0x90ABCDEF : LArr << V
CRead(P1,0x58F4EC,LArr({LA1,1},V(i)))

------------------------------------------------------------------------------------------

264

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

-----------------------------------------------------------------------------------------[예제 12-E] TMem(), _TMem(), _Mem()
CJump(AllPlayers,0)
CVariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12)
CVariable(P1,0x13) CVariable(P1,0x14) CVariable(P1,0x15)
CVariable(P1,0x16) CVariable(P1,0x17) CVariable(P1,0x18)
CVariable(P1,0x19) CVariable(P1,0x1A) CWariable(P1,0x1B)
A1 = CArray(P1,1000) VA1 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20 CWariable2(P1,0x21,"X","X",1) j = 0x21
LA1 = LArray(P1,1000) WA1 = CWArray(P1,10)
CJumpEnd(AllPlayers,0)
CMov(P1,V(0x10),0x12345678)
CRead(P1,0x58F450,_Mem(V(0x10)))
-- V(0x10)의 주소를 입력 (Read는 입력으로 값을 가져오는 방식이다.)
CMovX(P1,VArr(VA1,V(i)),0x12345678)
CRead(P1,0x58F454,_TMem(VArr(VA1,V(i))))
-- VA1[i]의 주소를 입력 (Mov는 출력으로 값을 가져오는 방식이다.)
CDoActions(P1,{TSetMemory(_Mem(V(0x10)),SetTo,0x90ABCDEF)})
-- V(0x10)의 주소를 입력 (상수입력)
CMov(P1,0x58F458,V(0x10))
CDoActions(P1,{TSetMemory(_TMem(VArr(VA1,V(i))),SetTo,0x90ABCDEF)})
-- VA1[i]의 주소를 입력 (변수입력)
CMovX(P1,0x58F45C,VArr(VA1,V(i)))
CDoActions(P1,{TSetMemory(_TMem(Arr(A1,V(i))),SetTo,0x90ABCDEF)})
-- A1[i]의 주소를 입력 (변수입력)
CRead(P1,0x58F460,Arr(A1,V(i)))

TMem(P1,V(0x11),Arr(A1,0)) -- V << A1[0]의 epd (디버깅용)
TMem(P1,V(0x12),V(0x10)) -- V << V(0x10)의 epd (디버깅용)
TMem(P1,V(0x13),Arr(A1,0),0,0,1) -- V << A1[0]의 Offset (디버깅용)
TMem(P1,V(0x14),V(0x10),0x15C,0,1) -- V << V(0x10)의 Offset (디버깅용)
TMem(P1,V(0x15),Arr(A1,V(i)),0,0,1) -- V << A1[V(0x10)]의 Offset (디버깅용)
TMem(P1,V(0x16),VArr(VA1,V(i)),0x15C,0,1) -- V << VA1[V(0x10)]의 Offset (디버깅용)
CMov(P1,0x58F464,V(0x11))
CMov(P1,0x58F468,V(0x12))
CMov(P1,0x58F46C,V(0x13))
CMov(P1,0x58F470,V(0x14))
CMov(P1,0x58F474,V(0x15))
CMov(P1,0x58F478,V(0x16))
TMem(P1,V(0x17),LArr(LA1,V(i)),0,0,1) -- V << LA1[V(0x10)]L의 Offset (디버깅용)
TMem(P1,V(0x18),LArr({LA1,1},V(i)),0,0,1) -- V << LA1[V(0x10)]H의 Offset (디버깅용)
TMem(P1,V(0x19),WArr(WA1,V(i)),0x15C,0,1) -- V << WA1[V(0x10)]의 Offset (디버깅용)
TMem(P1,V(0x1A),W(0x1B),0x15C,0,1) -- V << W(0x1B)의 Offset (디버깅용)
CMov(P1,0x58F4E0,V(0x17))
CMov(P1,0x58F4E4,V(0x18))
CMov(P1,0x58F4E8,V(0x19))
CMov(P1,0x58F4EC,V(0x1A))

------------------------------------------------------------------------------------------

265

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

-----------------------------------------------------------------------------------------[예제 12-F] f_Diff()
CJump(AllPlayers,0)
CVariable(P1,0x10)
CVariable(P1,0x11)
CVariable(P1,0x12)
CVariable(P1,0x13)
CVariable(P1,0x14)
VA1 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20
CJumpEnd(AllPlayers,0)
DoActionsX(P1,SetCVar("X",0x10,SetTo,0xFFFFFFFF),1)
CAdd(P1,V(0x10),_Read(0x57F0F0))
CMov(P1,0x58F450,V(0x10))
f_Diff(P1,V(0x11),V(0x10),0xFFFFFFFF,0)
CMov(P1,0x58F454,V(0x11))
f_Diff(P1,V(0x11),V(0x10),0xFFFFFFFF,0,nil,1)
CMov(P1,0x58F458,V(0x11))
CMovX(P1,VArr(VA1,V(i)),V(0x10))
f_Diff(P1,V(0x11),VArr(VA1,V(i)),0xFFFFFFFF,0)
CMov(P1,0x58F45C,V(0x11))
Trigger {
players = {P1},
conditions = {
Label();
Memory(0x58F454,Exactly,0xFFFFFFFF);
},
actions = {
DisplayText("\x0E0x58F454 : 0xFFFFFFFF 감지됨");
}
}
DoActionsX(P1,SetCVar("X",0x14,SetTo,0xFFFFFFFF),1)
CAdd(P1,V(0x14),_Read(0x57F120))
CMov(P1,0x58F460,V(0x14))
f_Diff(P1,V(0x11),V(0x14),0xFFFFFFFF,24*5,0,0)
CMov(P1,0x58F464,V(0x11))
f_Diff(P1,V(0x11),V(0x14),0xFFFFFFFF,24*5,0,1)
CMov(P1,0x58F468,V(0x11))
f_Diff(P1,VArr(VA1,V(i)),V(0x14),0xFFFFFFFF,24*5,0,0)
CMov(P1,0x58F46C,VArr(VA1,V(i)))
CAdd(P1,V(0x13),1)
CMov(P1,0x58F470,V(0x13))
CAdd(P1,V(0x12),V(0x13))
CMov(P1,0x58F474,V(0x12))
f_Diff(P1,V(0x11),V(0x12),0xFFFFFFFF,24,0)
CMov(P1,0x58F478,V(0x11))
f_Diff(P1,V(0x11),V(0x12),0xFFFFFFFF,24,12)
CMov(P1,0x58F47C,V(0x11))

------------------------------------------------------------------------------------------

266

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

-----------------------------------------------------------------------------------------[예제 12-G] CWrite()
CJump(AllPlayers,0)
CVariable(P1,0x10)
VA1 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20
CJumpEnd(AllPlayers,0)
CMov(P1,V(0x10),EPD(0x58F450))
CWrite(P1,V(0x10),_Read(0x57F0F0))
CMovX(P1,VArr(VA1,V(i)),EPD(0x58F454))
CWrite(P1,VArr(VA1,V(i)),0x12345678)
CMov(P1,V(0x10),EPD(0x58F458))
CMovX(P1,VArr(VA1,V(i)),_Read(0x57F120))
CWrite(P1,V(0x10),VArr(VA1,V(i)))

------------------------------------------------------------------------------------------

267

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

-----------------------------------------------------------------------------------------[예제 12-H] CAdd()
CJump(AllPlayers,0)
CVariable(P1,0x10) CVariable2(P1,0x30,"X","X",0x300) CVariable2(P1,0x20,"X","X",1) i = 0x20
A1 = CArray(P1,1000) VA1 = CVArray(P1,10) CVariable2(P1,0x21,"X","X",9) j = 0x21
CJumpEnd(AllPlayers,0)
CMov(P1,VArr(VA1,9),0x4000)
CMov(P1,0x58F450,0x1)
CAdd(P1,0x58F450,0x20)
CAdd(P1,0x58F450,V(0x30))
CAdd(P1,0x58F450,VArr(VA1,V(j)))
CMov(P1,V(0x10),0x1)
CAdd(P1,V(0x10),0x20)
CAdd(P1,V(0x10),V(0x30))
CAdd(P1,V(0x10),VArr(VA1,V(j)))
CMov(P1,0x58F454,V(0x10))
CMov(P1,Arr(A1,0),0x1)
CAdd(P1,Arr(A1,0),0x20)
CAdd(P1,Arr(A1,0),V(0x30))
CAdd(P1,Arr(A1,0),VArr(VA1,V(j)))
CMov(P1,0x58F458,_Read(Arr(A1,0)))
CMov(P1,Arr(A1,V(i)),0x1)
CAdd(P1,Arr(A1,V(i)),0x20)
CAdd(P1,Arr(A1,V(i)),V(0x30))
CAdd(P1,Arr(A1,V(i)),VArr(VA1,V(j)))
CMov(P1,0x58F45C,_Read(Arr(A1,V(i))))
CMov(P1,VArr(VA1,V(i)),0x1)
CAdd(P1,VArr(VA1,V(i)),0x20)
CAdd(P1,VArr(VA1,V(i)),V(0x30))
CAdd(P1,VArr(VA1,V(i)),VArr(VA1,V(j)))
CMov(P1,0x58F460,VArr(VA1,V(i)))
CAdd(P1,V(0x10),V(0x30),0x4000)
CMov(P1,0x58F464,V(0x10))
CAdd(P1,V(0x10),V(0x30),VArr(VA1,9))
CMov(P1,0x58F468,V(0x10))
CAdd(P1,V(0x10),V(0x30),VArr(VA1,V(j)))
CMov(P1,0x58F46C,V(0x10))
CAdd(P1,VArr(VA1,V(i)),VArr(VA1,V(j)),0x4000)
CMov(P1,0x58F470,VArr(VA1,V(i)))
CMov(P1,0x58F4E0,_Add(_Read(0x57F0F0),_Read(0x57F120)))
-----------------------------------------------------------------------------------------268

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

-----------------------------------------------------------------------------------------[예제 12-I] CSub()
CJump(AllPlayers,0)
CVariable(P1,0x10) CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x21,"X","X",9) j = 0x21
A1 = CArray(P1,1000) VA1 = CVArray(P1,10) CVariable2(P1,0x30,"X","X",0x200)
CJumpEnd(AllPlayers,0)
CMov(P1,VArr(VA1,9),0x3000)
CMov(P1,0x58F450,0x4444)
CSub(P1,0x58F450,0x10)
CSub(P1,0x58F450,V(0x30))
CSub(P1,0x58F450,VArr(VA1,V(j)))
CMov(P1,V(0x10),0x4444)
CSub(P1,V(0x10),0x10)
CSub(P1,V(0x10),V(0x30))
CSub(P1,V(0x10),VArr(VA1,V(j)))
CMov(P1,0x58F454,V(0x10))
CMov(P1,Arr(A1,0),0x4444)
CSub(P1,Arr(A1,0),0x10)
CSub(P1,Arr(A1,0),V(0x30))
CSub(P1,Arr(A1,0),VArr(VA1,V(j)))
CMov(P1,0x58F458,_Read(Arr(A1,0)))
CMov(P1,Arr(A1,V(i)),0x4444)
CSub(P1,Arr(A1,V(i)),0x10)
CSub(P1,Arr(A1,V(i)),V(0x30))
CSub(P1,Arr(A1,V(i)),VArr(VA1,V(j)))
CMov(P1,0x58F45C,_Read(Arr(A1,V(i))))
CMov(P1,VArr(VA1,V(i)),0x4444)
CSub(P1,VArr(VA1,V(i)),0x10)
CSub(P1,VArr(VA1,V(i)),V(0x30))
CSub(P1,VArr(VA1,V(i)),VArr(VA1,V(j)))
CMov(P1,0x58F460,VArr(VA1,V(i)))
CSub(P1,V(0x10),V(0x30),0x30)
CMov(P1,0x58F464,V(0x10))
CSub(P1,V(0x10),V(0x30),VArr(VA1,9))
CMov(P1,0x58F468,V(0x10))
CSub(P1,V(0x10),V(0x30),VArr(VA1,V(j)))
CMov(P1,0x58F46C,V(0x10))
CSub(P1,VArr(VA1,V(i)),VArr(VA1,V(j)),0x30)
CMov(P1,0x58F470,VArr(VA1,V(i)))
CMov(P1,0x58F4E0,_Sub(_Read(0x57F0F0),_Read(0x57F120)))
-----------------------------------------------------------------------------------------269

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

-----------------------------------------------------------------------------------------[예제 12-J] CiSub()
CJump(AllPlayers,0)
CVariable(P1,0x10) CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x21,"X","X",9) j = 0x21
A1 = CArray(P1,1000) VA1 = CVArray(P1,10) CVariable2(P1,0x30,"X","X",0x200)
CJumpEnd(AllPlayers,0)
CMov(P1,VArr(VA1,9),0x3000)
CMov(P1,0x58F450,0x1)
CiSub(P1,0x58F450,0x10)
CiSub(P1,0x58F450,V(0x30))
CiSub(P1,0x58F450,VArr(VA1,V(j)))
CMov(P1,V(0x10),0x1)
CiSub(P1,V(0x10),0x10)
CiSub(P1,V(0x10),V(0x30))
CiSub(P1,V(0x10),VArr(VA1,V(j)))
CMov(P1,0x58F454,V(0x10))
CMov(P1,Arr(A1,0),0x1)
CiSub(P1,Arr(A1,0),0x10)
CiSub(P1,Arr(A1,0),V(0x30))
CiSub(P1,Arr(A1,0),VArr(VA1,V(j)))
CMov(P1,0x58F458,_Read(Arr(A1,0)))
CMov(P1,Arr(A1,V(i)),0x1)
CiSub(P1,Arr(A1,V(i)),0x10)
CiSub(P1,Arr(A1,V(i)),V(0x30))
CiSub(P1,Arr(A1,V(i)),VArr(VA1,V(j)))
CMov(P1,0x58F45C,_Read(Arr(A1,V(i))))
CMov(P1,VArr(VA1,V(i)),0x1)
CiSub(P1,VArr(VA1,V(i)),0x10)
CiSub(P1,VArr(VA1,V(i)),V(0x30))
CiSub(P1,VArr(VA1,V(i)),VArr(VA1,V(j)))
CMov(P1,0x58F460,VArr(VA1,V(i)))
CiSub(P1,V(0x10),V(0x30),0x3000)
CMov(P1,0x58F464,V(0x10))
CiSub(P1,V(0x10),V(0x30),VArr(VA1,9))
CMov(P1,0x58F468,V(0x10))
CiSub(P1,V(0x10),V(0x30),VArr(VA1,V(j)))
CMov(P1,0x58F46C,V(0x10))
CiSub(P1,VArr(VA1,V(i)),VArr(VA1,V(j)),0x30)
CMov(P1,0x58F470,VArr(VA1,V(i)))
CMov(P1,0x58F4E0,_iSub(_Read(0x57F0F0),_Read(0x57F120)))
-----------------------------------------------------------------------------------------270

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

-----------------------------------------------------------------------------------------[예제 12-K] CNeg()
CJump(AllPlayers,0)
CVariable(P1,0x10) CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x21,"X","X",9) j = 0x21
A1 = CArray(P1,1000) VA1 = CVArray(P1,10) CVariable2(P1,0x30,"X","X",0x300)
CJumpEnd(AllPlayers,0)
CMov(P1,VArr(VA1,9),0x4000)
CMov(P1,V(0x10),0x1)
CNeg(P1,V(0x10))
CMov(P1,0x58F450,V(0x10))
CMov(P1,VArr(VA1,V(i)),0x1)
CNeg(P1,VArr(VA1,V(i)))
CMov(P1,0x58F454,V(0x10))
CMov(P1,V(0x10),0x1)
CNeg(P1,VArr(VA1,V(i)),V(0x10))
CMov(P1,0x58F458,VArr(VA1,V(i)))
CMov(P1,VArr(VA1,V(i)),0x1)
CNeg(P1,V(0x10),VArr(VA1,V(i)))
CMov(P1,0x58F45C,V(0x10))
CMov(P1,0x58F4E0,_Neg(_Read(0x57F0F0)))
------------------------------------------------------------------------------------------

271

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

-----------------------------------------------------------------------------------------[예제 12-L] ClShift()
CJump(AllPlayers,0)
Include_ArithMetic()
CVariable(P1,0x10)
A1 = CArray(P1,1000)
VA1 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20
CVariable2(P1,0x21,"X","X",9) j = 0x21
CVariable2(P1,0x30,"X","X",2)
CJumpEnd(AllPlayers,0)
CMov(P1,VArr(VA1,9),3)
CMov(P1,V(0x10),0x101)
ClShift(P1,V(0x10),1)
ClShift(P1,V(0x10),V(0x30))
ClShift(P1,V(0x10),VArr(VA1,V(j)))
CMov(P1,0x58F450,V(0x10))
CMov(P1,VArr(VA1,V(i)),0x101)
ClShift(P1,VArr(VA1,V(i)),1)
ClShift(P1,VArr(VA1,V(i)),V(0x30))
ClShift(P1,VArr(VA1,V(i)),VArr(VA1,V(j)))
CMov(P1,0x58F454,VArr(VA1,V(i)))
ClShift(P1,V(0x10),V(0x30),4)
CMov(P1,0x58F458,V(0x10))
ClShift(P1,V(0x10),V(0x30),VArr(VA1,9))
CMov(P1,0x58F45C,V(0x10))
ClShift(P1,V(0x10),V(0x30),VArr(VA1,V(j)))
CMov(P1,0x58F460,V(0x10))
ClShift(P1,VArr(VA1,V(i)),VArr(VA1,V(j)),4)
CMov(P1,0x58F464,VArr(VA1,V(i)))
CMov(P1,0x58F4E0,_lShift(_Read(0x57F0F0),_Read(0x57F120)))

------------------------------------------------------------------------------------------

272

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

-----------------------------------------------------------------------------------------[예제 12-M] CMul()
CJump(AllPlayers,0)
Include_ArithMetic()
CVariable(P1,0x10)
A1 = CArray(P1,1000)
VA1 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20
CVariable2(P1,0x21,"X","X",9) j = 0x21
CVariable2(P1,0x30,"X","X",0x20)
CJumpEnd(AllPlayers,0)
CMov(P1,VArr(VA1,9),0x30)
CMov(P1,0x58F450,0x10)
CMul(P1,0x58F450,0x10)
CMov(P1,V(0x10),0x10)
CMul(P1,V(0x10),0x10)
CMul(P1,V(0x10),V(0x30))
CMul(P1,V(0x10),VArr(VA1,V(j)))
CMov(P1,0x58F454,V(0x10))
CMov(P1,Arr(A1,0),0x10)
CMul(P1,Arr(A1,0),0x10)
CMov(P1,0x58F458,_Read(Arr(A1,0)))

CMov(P1,VArr(VA1,V(i)),0x10)
CMul(P1,VArr(VA1,V(i)),0x10)
CMul(P1,VArr(VA1,V(i)),V(0x30))
CMul(P1,VArr(VA1,V(i)),VArr(VA1,V(j)))
CMov(P1,0x58F45C,VArr(VA1,V(i)))
CMul(P1,V(0x10),V(0x30),0x30)
CMov(P1,0x58F460,V(0x10))
CMul(P1,V(0x10),V(0x30),VArr(VA1,9))
CMov(P1,0x58F464,V(0x10))

CMul(P1,V(0x10),V(0x30),VArr(VA1,V(j)))
CMov(P1,0x58F468,V(0x10))
CMul(P1,VArr(VA1,V(i)),VArr(VA1,V(j)),0x30)
CMov(P1,0x58F46C,VArr(VA1,V(i)))
CMov(P1,0x58F4E0,_Mul(_Read(0x57F0F0),_Read(0x57F120)))
------------------------------------------------------------------------------------------

273

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

-----------------------------------------------------------------------------------------[예제 12-N] CDiv()
CJump(AllPlayers,0)
Include_ArithMetic()
CVariable(P1,0x10)
A1 = CArray(P1,1000)
VA1 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20
CVariable2(P1,0x21,"X","X",9) j = 0x21
CVariable2(P1,0x30,"X","X",0x20)
CJumpEnd(AllPlayers,0)
CMov(P1,VArr(VA1,9),0x30)
CMov(P1,V(0x30),0x20)
CMov(P1,V(0x10),0x60000)
CDiv(P1,V(0x10),0x10)
CDiv(P1,V(0x10),V(0x30))
CDiv(P1,V(0x10),VArr(VA1,V(j)))
CMov(P1,0x58F450,V(0x10))
CMov(P1,VArr(VA1,V(i)),0x60000)
CDiv(P1,VArr(VA1,V(i)),0x10)
CDiv(P1,VArr(VA1,V(i)),V(0x30))
CDiv(P1,VArr(VA1,V(i)),VArr(VA1,V(j)))
CMov(P1,0x58F454,VArr(VA1,V(i)))
CMov(P1,V(0x30),0x600)
CDiv(P1,V(0x10),V(0x30),0x30)
CMov(P1,0x58F458,V(0x10))
CDiv(P1,V(0x10),V(0x30),VArr(VA1,9))
CMov(P1,0x58F45C,V(0x10))
CDiv(P1,V(0x10),V(0x30),VArr(VA1,V(j)))
CMov(P1,0x58F460,V(0x10))
CDiv(P1,VArr(VA1,V(i)),VArr(VA1,V(j)),0x30)
CMov(P1,0x58F464,VArr(VA1,V(i)))
CMov(P1,0x58F4E0,_Div(_Read(0x57F0F0),_Read(0x57F120)))

------------------------------------------------------------------------------------------

274

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

-----------------------------------------------------------------------------------------[예제 12-O] CiDiv()
CJump(AllPlayers,0)
Include_ArithMetic()
CVariable(P1,0x10)
A1 = CArray(P1,1000)
VA1 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20
CVariable2(P1,0x21,"X","X",9) j = 0x21
CVariable2(P1,0x30,"X","X",0x20)
CJumpEnd(AllPlayers,0)
CMov(P1,VArr(VA1,9),0x30)
CMov(P1,V(0x30),0x20)
CMov(P1,V(0x10),0-0x60000)
CiDiv(P1,V(0x10),0x10)
CiDiv(P1,V(0x10),V(0x30))
CiDiv(P1,V(0x10),VArr(VA1,V(j)))
CMov(P1,0x58F450,V(0x10))
CMov(P1,VArr(VA1,V(i)),0-0x60000)
CiDiv(P1,VArr(VA1,V(i)),0x10)
CiDiv(P1,VArr(VA1,V(i)),V(0x30))
CiDiv(P1,VArr(VA1,V(i)),VArr(VA1,V(j)))
CMov(P1,0x58F454,VArr(VA1,V(i)))
CMov(P1,V(0x30),0-0x600)
CiDiv(P1,V(0x10),V(0x30),0x30)
CMov(P1,0x58F458,V(0x10))
CiDiv(P1,V(0x10),V(0x30),VArr(VA1,9))
CMov(P1,0x58F45C,V(0x10))
CiDiv(P1,V(0x10),V(0x30),VArr(VA1,V(j)))
CMov(P1,0x58F460,V(0x10))
CiDiv(P1,VArr(VA1,V(i)),VArr(VA1,V(j)),0x30)
CMov(P1,0x58F464,VArr(VA1,V(i)))
CMov(P1,0x58F4E0,_iDiv(_Read(0x57F0F0),_Read(0x57F120)))

------------------------------------------------------------------------------------------

275

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

-----------------------------------------------------------------------------------------[예제 12-P] CMod()
CJump(AllPlayers,0)
Include_ArithMetic()
CVariable(P1,0x10)
A1 = CArray(P1,1000)
VA1 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20
CVariable2(P1,0x21,"X","X",9) j = 0x21
CVariable2(P1,0x30,"X","X",0x20)
CJumpEnd(AllPlayers,0)
CMov(P1,VArr(VA1,9),0x30)
CMov(P1,V(0x30),0x20)
CMov(P1,V(0x10),0x4321)
CMod(P1,V(0x10),0x10)
CMov(P1,0x58F450,V(0x10))
CMov(P1,V(0x10),0x4321)
CMod(P1,V(0x10),V(0x30))
CMov(P1,0x58F454,V(0x10))
CMov(P1,V(0x10),0x4321)
CMod(P1,V(0x10),VArr(VA1,V(j)))
CMov(P1,0x58F458,V(0x10))

CMov(P1,VArr(VA1,V(i)),0x4321)
CMod(P1,VArr(VA1,V(i)),0x10)
CMov(P1,0x58F45C,VArr(VA1,V(i)))
CMov(P1,VArr(VA1,V(i)),0x4321)
CMod(P1,VArr(VA1,V(i)),V(0x30))
CMov(P1,0x58F460,VArr(VA1,V(i)))
CMov(P1,VArr(VA1,V(i)),0x4321)
CMod(P1,VArr(VA1,V(i)),VArr(VA1,V(j)))
CMov(P1,0x58F464,VArr(VA1,V(i)))

CMov(P1,V(0x30),0x321)
CMod(P1,V(0x10),V(0x30),0x30)
CMov(P1,0x58F468,V(0x10))
CMod(P1,V(0x10),V(0x30),VArr(VA1,9))
CMov(P1,0x58F46C,V(0x10))
CMod(P1,V(0x10),V(0x30),VArr(VA1,V(j)))
CMov(P1,0x58F470,V(0x10))
CMod(P1,VArr(VA1,V(i)),VArr(VA1,V(j)),0x30)
CMov(P1,0x58F474,VArr(VA1,V(i)))
CMov(P1,0x58F4E0,_Mod(_Read(0x57F0F0),_Read(0x57F120)))
------------------------------------------------------------------------------------------

276

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

-----------------------------------------------------------------------------------------[예제 12-Q] CiMod()
CJump(AllPlayers,0)
Include_ArithMetic()
CVariable(P1,0x10)
A1 = CArray(P1,1000)
VA1 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20
CVariable2(P1,0x21,"X","X",9) j = 0x21
CVariable2(P1,0x30,"X","X",0x20)
CJumpEnd(AllPlayers,0)
CMov(P1,VArr(VA1,9),0x30)
CMov(P1,V(0x30),0x20)
CMov(P1,V(0x10),0-0x4321)
CiMod(P1,V(0x10),0x10)
CMov(P1,0x58F450,V(0x10))
CMov(P1,V(0x10),0-0x4321)
CiMod(P1,V(0x10),V(0x30))
CMov(P1,0x58F454,V(0x10))
CMov(P1,V(0x10),0-0x4321)
CiMod(P1,V(0x10),VArr(VA1,V(j)))
CMov(P1,0x58F458,V(0x10))

CMov(P1,VArr(VA1,V(i)),0-0x4321)
CiMod(P1,VArr(VA1,V(i)),0x10)
CMov(P1,0x58F45C,VArr(VA1,V(i)))
CMov(P1,VArr(VA1,V(i)),0-0x4321)
CiMod(P1,VArr(VA1,V(i)),V(0x30))
CMov(P1,0x58F460,VArr(VA1,V(i)))
CMov(P1,VArr(VA1,V(i)),0-0x4321)
CiMod(P1,VArr(VA1,V(i)),VArr(VA1,V(j)))
CMov(P1,0x58F464,VArr(VA1,V(i)))

CMov(P1,V(0x30),0-0x321)
CiMod(P1,V(0x10),V(0x30),0x30)
CMov(P1,0x58F468,V(0x10))
CiMod(P1,V(0x10),V(0x30),VArr(VA1,9))
CMov(P1,0x58F46C,V(0x10))
CiMod(P1,V(0x10),V(0x30),VArr(VA1,V(j)))
CMov(P1,0x58F470,V(0x10))
CiMod(P1,VArr(VA1,V(i)),VArr(VA1,V(j)),0x30)
CMov(P1,0x58F474,VArr(VA1,V(i)))
CMov(P1,0x58F4E0,_iMod(_Read(0x57F0F0),_Read(0x57F120)))
------------------------------------------------------------------------------------------

277

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

-----------------------------------------------------------------------------------------[예제 12-R] CNot()
CJump(AllPlayers,0)
CVariable(P1,0x10)
A1 = CArray(P1,1000)
VA1 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20
CVariable2(P1,0x21,"X","X",9) j = 0x21
CVariable2(P1,0x30,"X","X",0x300)
CJumpEnd(AllPlayers,0)
CMov(P1,VArr(VA1,9),0x4000)
CMov(P1,V(0x10),0xF0F0F0F0)
CNot(P1,V(0x10))
CMov(P1,0x58F450,V(0x10))
CMov(P1,VArr(VA1,V(i)),0xF0F0F0F0)
CNot(P1,VArr(VA1,V(i)))
CMov(P1,0x58F454,V(0x10))
CMov(P1,VArr(VA1,V(i)),0xF0F0F0F0)
CNot(P1,VArr(VA1,V(i)),V(0x10))
CMov(P1,0x58F458,V(0x10))
CMov(P1,VArr(VA1,V(i)),0xF0F0F0F0)
CNot(P1,V(0x10),VArr(VA1,V(i)))
CMov(P1,0x58F45C,V(0x10))
CMov(P1,0x58F4E0,_Not(_Read(0x57F0F0)))

------------------------------------------------------------------------------------------

278

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

-----------------------------------------------------------------------------------------[예제 12-S] CAnd()
CJump(AllPlayers,0)
CVariable(P1,0x10) CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x21,"X","X",9) j = 0x21
A1 = CArray(P1,1000) VA1 = CVArray(P1,10) CVariable2(P1,0x30,"X","X",0x00FF00FF)
CJumpEnd(AllPlayers,0)
CMov(P1,VArr(VA1,9),0x00FF00FF)
CMov(P1,0x58F450,0xF0F0F0F0)
CAnd(P1,0x58F450,0x00FF00FF)
CMov(P1,0x58F454,0xF0F0F0F0)
CAnd(P1,0x58F454,V(0x30))

CMov(P1,0x58F458,0xF0F0F0F0)
CAnd(P1,0x58F458,VArr(VA1,V(j)))
CMov(P1,V(0x10),0xF0F0F0F0)
CAnd(P1,V(0x10),0x00FF00FF)
CMov(P1,0x58F45C,V(0x10))
CMov(P1,V(0x10),0xF0F0F0F0)
CAnd(P1,V(0x10),V(0x30))
CMov(P1,0x58F460,V(0x10))
CMov(P1,V(0x10),0xF0F0F0F0)
CAnd(P1,V(0x10),VArr(VA1,V(j)))
CMov(P1,0x58F464,V(0x10))
CMov(P1,Arr(A1,0),0xF0F0F0F0)
CAnd(P1,Arr(A1,0),0x00FF00FF)
CMov(P1,0x58F468,_Read(Arr(A1,0)))
CMov(P1,Arr(A1,0),0xF0F0F0F0)
CAnd(P1,Arr(A1,0),V(0x30))
CMov(P1,0x58F46C,_Read(Arr(A1,0)))
CMov(P1,Arr(A1,0),0xF0F0F0F0)
CAnd(P1,Arr(A1,0),VArr(VA1,V(j)))
CMov(P1,0x58F470,_Read(Arr(A1,0)))
CMov(P1,VArr(VA1,V(i)),0xF0F0F0F0)
CAnd(P1,VArr(VA1,V(i)),0x00FF00FF)
CMov(P1,0x58F474,VArr(VA1,V(i)))
CMov(P1,VArr(VA1,V(i)),0xF0F0F0F0)
CAnd(P1,VArr(VA1,V(i)),V(0x30))
CMov(P1,0x58F478,VArr(VA1,V(i)))
CMov(P1,VArr(VA1,V(i)),0xF0F0F0F0)
CAnd(P1,VArr(VA1,V(i)),VArr(VA1,V(j)))
CMov(P1,0x58F47C,VArr(VA1,V(i)))
CMov(P1,0x58F4E0,_And(_Read(0x57F0F0),_Read(0x57F120)))

------------------------------------------------------------------------------------------

279

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

-----------------------------------------------------------------------------------------[예제 12-T] COr()
CJump(AllPlayers,0)
CVariable(P1,0x10) CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x21,"X","X",9) j = 0x21
A1 = CArray(P1,1000) VA1 = CVArray(P1,10) CVariable2(P1,0x30,"X","X",0x00FF00FF)
CJumpEnd(AllPlayers,0)
CMov(P1,VArr(VA1,9),0x00FF00FF)
CMov(P1,0x58F450,0xF0F0F0F0)
COr(P1,0x58F450,0x00FF00FF)
CMov(P1,0x58F454,0xF0F0F0F0)
COr(P1,0x58F454,V(0x30))

CMov(P1,0x58F458,0xF0F0F0F0)
COr(P1,0x58F458,VArr(VA1,V(j)))
CMov(P1,V(0x10),0xF0F0F0F0)
COr(P1,V(0x10),0x00FF00FF)
CMov(P1,0x58F45C,V(0x10))
CMov(P1,V(0x10),0xF0F0F0F0)
COr(P1,V(0x10),V(0x30))
CMov(P1,0x58F460,V(0x10))
CMov(P1,V(0x10),0xF0F0F0F0)
COr(P1,V(0x10),VArr(VA1,V(j)))
CMov(P1,0x58F464,V(0x10))
CMov(P1,Arr(A1,0),0xF0F0F0F0)
COr(P1,Arr(A1,0),0x00FF00FF)
CMov(P1,0x58F468,_Read(Arr(A1,0)))
CMov(P1,Arr(A1,0),0xF0F0F0F0)
COr(P1,Arr(A1,0),V(0x30))
CMov(P1,0x58F46C,_Read(Arr(A1,0)))
CMov(P1,Arr(A1,0),0xF0F0F0F0)
COr(P1,Arr(A1,0),VArr(VA1,V(j)))
CMov(P1,0x58F470,_Read(Arr(A1,0)))
CMov(P1,VArr(VA1,V(i)),0xF0F0F0F0)
COr(P1,VArr(VA1,V(i)),0x00FF00FF)
CMov(P1,0x58F474,VArr(VA1,V(i)))
CMov(P1,VArr(VA1,V(i)),0xF0F0F0F0)
COr(P1,VArr(VA1,V(i)),V(0x30))
CMov(P1,0x58F478,VArr(VA1,V(i)))
CMov(P1,VArr(VA1,V(i)),0xF0F0F0F0)
COr(P1,VArr(VA1,V(i)),VArr(VA1,V(j)))
CMov(P1,0x58F47C,VArr(VA1,V(i)))
CMov(P1,0x58F4E0,_Or(_Read(0x57F0F0),_Read(0x57F120)))

------------------------------------------------------------------------------------------

280

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

-----------------------------------------------------------------------------------------[예제 12-U] CXor()
CJump(AllPlayers,0)
CVariable(P1,0x10)
A1 = CArray(P1,1000)
VA1 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20
CVariable2(P1,0x21,"X","X",9) j = 0x21
CVariable2(P1,0x30,"X","X",0x00FF00FF)
CJumpEnd(AllPlayers,0)
CMov(P1,VArr(VA1,9),0x00FF00FF)
CMov(P1,V(0x10),0xF0F0F0F0)
CXor(P1,V(0x10),0x00FF00FF)
CMov(P1,0x58F450,V(0x10))
CMov(P1,V(0x10),0xF0F0F0F0)
CXor(P1,V(0x10),V(0x30))
CMov(P1,0x58F454,V(0x10))
CMov(P1,V(0x10),0xF0F0F0F0)
CXor(P1,V(0x10),VArr(VA1,V(j)))
CMov(P1,0x58F458,V(0x10))
CMov(P1,VArr(VA1,V(i)),0xF0F0F0F0)
CXor(P1,VArr(VA1,V(i)),0x00FF00FF)
CMov(P1,0x58F45C,VArr(VA1,V(i)))
CMov(P1,VArr(VA1,V(i)),0xF0F0F0F0)
CXor(P1,VArr(VA1,V(i)),V(0x30))
CMov(P1,0x58F460,VArr(VA1,V(i)))
CMov(P1,VArr(VA1,V(i)),0xF0F0F0F0)
CXor(P1,VArr(VA1,V(i)),VArr(VA1,V(j)))
CMov(P1,0x58F464,VArr(VA1,V(i)))
CMov(P1,0x58F4E0,_Xor(_Read(0x57F0F0),_Read(0x57F120)))

------------------------------------------------------------------------------------------

281

------------------------------------------------------------------------------------------

『 12장 : 매크로 함수형 최종 연산 함수 (C) 』

-----------------------------------------------------------------------------------------[예제 12-V] CAnd(), COr(), CXor()
CJump(AllPlayers,0)
CVariable(P1,0x10)
A1 = CArray(P1,1000)
VA1 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20
CVariable2(P1,0x21,"X","X",9) j = 0x21
CVariable2(P1,0x30,"X","X",0x00FF00FF)
CJumpEnd(AllPlayers,0)
CMov(P1,VArr(VA1,9),0x00FF00FF)
CMov(P1,VArr(VA1,9),0xF0F0F0F0)
CAnd(P1,V(0x10),V(0x30),0xF0F0F0F0)
CMov(P1,0x58F450,V(0x10))
CAnd(P1,V(0x10),V(0x30),VArr(VA1,9))
CMov(P1,0x58F454,V(0x10))
CAnd(P1,V(0x10),V(0x30),VArr(VA1,V(j)))
CMov(P1,0x58F458,V(0x10))
CAnd(P1,VArr(VA1,V(i)),VArr(VA1,V(j)),0xF0F0F0F0)
CMov(P1,0x58F45C,V(0x10))

CMov(P1,VArr(VA1,9),0xF0F0F0F0)
COr(P1,V(0x10),V(0x30),0xF0F0F0F0)
CMov(P1,0x58F460,V(0x10))
COr(P1,V(0x10),V(0x30),VArr(VA1,9))
CMov(P1,0x58F464,V(0x10))
COr(P1,V(0x10),V(0x30),VArr(VA1,V(j)))
CMov(P1,0x58F468,V(0x10))
COr(P1,VArr(VA1,V(i)),VArr(VA1,V(j)),0xF0F0F0F0)
CMov(P1,0x58F46C,V(0x10))
CMov(P1,VArr(VA1,9),0xF0F0F0F0)
CXor(P1,V(0x10),V(0x30),0xF0F0F0F0)
CMov(P1,0x58F470,V(0x10))
CXor(P1,V(0x10),V(0x30),VArr(VA1,9))
CMov(P1,0x58F474,V(0x10))
CXor(P1,V(0x10),V(0x30),VArr(VA1,V(j)))
CMov(P1,0x58F478,V(0x10))

CXor(P1,VArr(VA1,V(i)),VArr(VA1,V(j)),0xF0F0F0F0)
CMov(P1,0x58F47C,V(0x10))
------------------------------------------------------------------------------------------

282

------------------------------------------------------------------------------------------

『 13장 : 함수 호출형 함수 정의 선언 함수 (Include) 』

-----------------------------------------------------------------------------------------[예제 13-1] Include_CtrigPlib()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
-- 주기 : 360 = 360도 / Switch 1을 랜덤스위치로 사용 / f_Memcpy(Readcpy) 포함
CJumpEnd(AllPlayers,0)
------------------------------------------------------------------------------------------

[예제 13-2] Include_DataTransfer(), Include_ArithMetic(), Include_MatheMatics(),
Include_MiscFunctions()
CJump(AllPlayers,0)
Include_DataTransfer() -- f_Memcpy(Readcpy) 미포함
Include_ArithMetic()
Include_MatheMatics() -- 주기 : 360 = 360도
Include_MiscFunctions("Switch 1") -- Switch 1을 랜덤스위치로 사용(f_Rand)
CJumpEnd(AllPlayers,0)
------------------------------------------------------------------------------------------

283

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-A] f_Read()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CVariable(P1,0x10) -- 변수
A1 = CArray(P1,1000) -- 배열
VA1 = CVArray(P1,10) -- 변수배열
CVariable2(P1,0x20,"X","X",1) i = 0x20 -- 인덱스 변수
for i = 0x100, 0x110 do CVariable(P1,i) end
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)

f_Read(P1,0x57F0F0,V(0x10))
CRead(P1,Arr(A1,0),0x57F0F0)
f_Read(P1,0x57F0F0,VArr(VA1,0))
CRead(P1,Arr(A1,V(0x20)),0x57F0F0)
f_Read(P1,0x57F0F0,VArr(VA1,V(0x20)))
f_Read(P1,0x57F0F0,LArr(LA1,0))
f_Read(P1,0x57F0F0,LArr({LA1,1},0))
f_Read(P1,0x57F0F0,LArr(LA1,V(i)))
f_Read(P1,0x57F0F0,LArr({LA1,1},V(i)))
f_Read(P1,_Mem(V(0x10)),V(0x100))
f_Read(P1,Arr(A1,0),V(0x101))
f_Read(P1,_Mem(VArr(VA1,0)),V(0x102))
f_Read(P1,Arr(A1,V(0x20)),V(0x103))
f_Read(P1,_TMem(VArr(VA1,V(0x20))),V(0x104))
f_Read(P1,LArr(LA1,0),V(0x108))
f_Read(P1,LArr({LA1,1},0),V(0x109))
f_Read(P1,LArr(LA1,V(i)),V(0x10A))
f_Read(P1,LArr({LA1,1},V(i)),V(0x10B))
CMov(P1,V(0x10),EPD(0x57F120))
CMov(P1,VArr(VA1,0),EPD(0x57F120))
CMovX(P1,VArr(VA1,V(0x20)),EPD(0x57f120))
f_Read(P1,V(0x10),V(0x105))
f_Read(P1,VArr(VA1,0),V(0x106))
f_Read(P1,VArr(VA1,V(0x20)),V(0x107))
for i = 0, 7 do CMov(P1,0x58F450+0x4*i,V(0x100+i)) end
CMov(P1,0x58F4E0,V(0x108)) CMov(P1,0x58F4E4,V(0x109))
CMov(P1,0x58F4E8,V(0x10A)) CMov(P1,0x58F4EC,V(0x10B))
------------------------------------------------------------------------------------------

284

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-B] f_ReadX()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CVariable(P1,0x10) -- 변수
A1 = CArray(P1,1000) -- 배열
VA1 = CVArray(P1,10) -- 변수배열
CVariable2(P1,0x20,"X","X",1) i = 0x20 -- 인덱스 변수
for i = 0x100, 0x110 do CVariable(P1,i) end
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)

f_ReadX(P1,0x57F0F0,V(0x10),0x1)
CReadX(P1,Arr(A1,0),0x57F0F0,"X","X",0x1)
f_ReadX(P1,0x57F0F0,VArr(VA1,0),0x1)
CReadX(P1,Arr(A1,V(0x20)),0x57F0F0,"X","X",0x1)
f_ReadX(P1,0x57F0F0,VArr(VA1,V(0x20)),0x1)
f_ReadX(P1,0x57F0F0,LArr(LA1,0),1)
f_ReadX(P1,0x57F0F0,LArr({LA1,1},0),1)
f_ReadX(P1,0x57F0F0,LArr(LA1,V(i)),1)
f_ReadX(P1,0x57F0F0,LArr({LA1,1},V(i)),1)
f_ReadX(P1,_Mem(V(0x10)),V(0x100),0x1000000)
f_ReadX(P1,Arr(A1,0),V(0x101),0x100)
f_ReadX(P1,_Mem(VArr(VA1,0)),V(0x102),0x10000)
f_ReadX(P1,Arr(A1,V(0x20)),V(0x103),0x1)
f_ReadX(P1,_TMem(VArr(VA1,V(0x20))),V(0x104),0x100)
f_ReadX(P1,LArr(LA1,0),V(0x108),0x1)
f_ReadX(P1,LArr({LA1,1},0),V(0x109),0x100)
f_ReadX(P1,LArr(LA1,V(i)),V(0x10A),0x10000)
f_ReadX(P1,LArr({LA1,1},V(i)),V(0x10B),0x1000000)
CMov(P1,V(0x10),EPD(0x57F120))
CMov(P1,VArr(VA1,0),EPD(0x57F120))
CMovX(P1,VArr(VA1,V(0x20)),EPD(0x57f120))
f_ReadX(P1,V(0x10),V(0x105),0x100)
f_ReadX(P1,VArr(VA1,0),V(0x106),0x100)
f_ReadX(P1,VArr(VA1,V(0x20)),V(0x107),0x100)
for i = 0, 7 do CMov(P1,0x58F450+0x4*i,V(0x100+i)) end
CMov(P1,0x58F4E0,V(0x108)) CMov(P1,0x58F4E4,V(0x109))
CMov(P1,0x58F4E8,V(0x10A)) CMov(P1,0x58F4EC,V(0x10B))

------------------------------------------------------------------------------------------

285

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-C] f_EPD()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CVariable(P1,0x10) -- 변수
A1 = CArray(P1,1000) -- 배열
VA1 = CVArray(P1,10) -- 변수배열
CVariable2(P1,0x20,"X","X",1) i = 0x20 -- 인덱스 변수
CVariable2(P1,0x30,"X","X",9) j = 0x30
for i = 0x100, 0x110 do
CVariable(P1,i)
end
CJumpEnd(AllPlayers,0)
CMov(P1,V(0x10),0x57F0F0)
CMovX(P1,VArr(VA1,V( j)),0x57F0F0)
f_EPD(P1,V(0x100),V(0x10))
f_EPD(P1,VArr(VA1,V(i)),VArr(VA1,V( j)))
CMov(P1,0x58F450,V(0x100))
CMovX(P1,0x58F454,VArr(VA1,V(i)))

------------------------------------------------------------------------------------------

286

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-D] f_MemcpyEPD()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CVariable(P1,0x10) -- 변수
CVariable(P1,0x11) -- 변수
CVariable(P1,0x12) -- 변수
A1 = CArray(P1,1000) -- 배열
VA1 = CVArray(P1,10) -- 변수배열
CVariable2(P1,0x20,"X","X",1) i = 0x20 -- 인덱스 변수
CVariable2(P1,0x30,"X","X",2) j = 0x30
CVariable2(P1,0x40,"X","X",3) k = 0x40
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)
CMov(P1,0x58F500,0x11112222)
CMov(P1,0x58F504,0x33334444)
CMov(P1,0x58F508,0x55556666)
CMov(P1,0x58F50C,0x77778888)
CMov(P1,0x58F510,0x9999AAAA)
CMov(P1,0x58F514,0xBBBBCCCC)
CMov(P1,0x58F518,0xDDDDEEEE)
CMov(P1,0x58F51C,0xFFFF0000)
CMov(P1,V(0x10),EPD(0x58F458))
CMov(P1,V(0x11),EPD(0x58F508))
CMov(P1,V(0x12),8)
CMovX(P1,VArr(VA1,V(i)),EPD(0x58F460))
CMovX(P1,VArr(VA1,V( j)),EPD(0x58F510))
CMovX(P1,VArr(VA1,V(k)),16)
f_MemcpyEPD(P1,EPD(0x58F450),EPD(0x58F500),8)
f_MemcpyEPD(P1,V(0x10),V(0x11),V(0x12))
f_MemcpyEPD(P1,VArr(VA1,V(i)),VArr(VA1,V( j)),VArr(VA1,V(k)))
f_MemcpyEPD(P1,LArr(LA1,0),EPD(0x58F500),32,4,1)
f_MemcpyEPD(P1,LArr({LA1,1},V(i)),EPD(0x58F500),32,4,1)
f_MemcpyEPD(P1,EPD(0x58F4C0),LArr(LA1,0),32,1,4)
f_MemcpyEPD(P1,EPD(0x58F4E0),LArr({LA1,1},V(i)),32,1,4)
------------------------------------------------------------------------------------------

287

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-E] f_Memcpy()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CVariable(P1,0x10) -- 변수
CVariable(P1,0x11) -- 변수
CVariable(P1,0x12) -- 변수
A1 = CArray(P1,1000) -- 배열
VA1 = CVArray(P1,10) -- 변수배열
CVariable2(P1,0x20,"X","X",1) i = 0x20 -- 인덱스 변수
CVariable2(P1,0x30,"X","X",2) j = 0x30
CVariable2(P1,0x40,"X","X",3) k = 0x40
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)
CMov(P1,0x58F500,0x22221111)
CMov(P1,0x58F504,0x44443333)
CMov(P1,0x58F508,0x66665555)
CMov(P1,0x58F50C,0x88887777)
CMov(P1,0x58F510,0xAAAA9999)
CMov(P1,0x58F514,0xCCCCBBBB)
CMov(P1,0x58F518,0xEEEEDDDD)
CMov(P1,0x58F51C,0x0000FFFF)
CMov(P1,V(0x10),0x58F452+9)
CMov(P1,V(0x11),0x58F500+9)
CMov(P1,V(0x12),10)
CMovX(P1,VArr(VA1,V(i)),0x58F452+19)
CMovX(P1,VArr(VA1,V( j)),0x58F500+19)
CMovX(P1,VArr(VA1,V(k)),13)
f_Memcpy(P1,0x58F452,0x58F500,9)
f_Memcpy(P1,V(0x10),V(0x11),V(0x12))
f_Memcpy(P1,VArr(VA1,V(i)),VArr(VA1,V( j)),VArr(VA1,V(k)))
f_Memcpy(P1,LArr(LA1,0),0x58F500,32,4,1)
f_Memcpy(P1,LArr({LA1,1},V(i)),0x58F500,32,4,1)
f_Memcpy(P1,0x58F4C0,LArr(LA1,0),32,1,4)
f_Memcpy(P1,0x58F4E2,LArr({LA1,1},V(i)),30,1,4)
------------------------------------------------------------------------------------------

288

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-F] f_MemcpyX()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CVariable(P1,0x10) CVariable(P1,0x11)
CVariable(P1,0x12) CVariable(P1,0x13)
CVariable(P1,0x14) A1 = CArray(P1,1000)
VA1 = CVArray(P1,10) LA1 = LArray(P1,1000)
CVariable2(P1,0x20,"X","X",1) i = 0x20 -- 인덱스 변수
CVariable2(P1,0x30,"X","X",2) j = 0x30
CVariable2(P1,0x40,"X","X",3) k = 0x40
CVariable2(P1,0x50,"X","X",4) l = 0x50
CVariable2(P1,0x60,"X","X",5) m = 0x60
CJumpEnd(AllPlayers,0)
CMov(P1,0x58F500,0x22221111)
CMov(P1,0x58F504,0x44443333)
CMov(P1,0x58F508,0x66665555)
CMov(P1,0x58F50C,0x88887777)
CMov(P1,0x58F510,0xAAAA9999)
CMov(P1,0x58F514,0xCCCCBBBB)
CMov(P1,0x58F518,0xEEEEDDDD)
CMov(P1,0x58F51C,0x0000FFFF)
CMov(P1,V(0x10),EPD(0x58F45B))
CMov(P1,V(0x11),EPD(0x58F509))
CMov(P1,V(0x12),3)
CMov(P1,V(0x13),1)
CMov(P1,V(0x14),10)
CMovX(P1,VArr(VA1,V(i)),EPD(0x58F465))
CMovX(P1,VArr(VA1,V( j)),EPD(0x58F513))
CMovX(P1,VArr(VA1,V(k)),1)
CMovX(P1,VArr(VA1,V(l)),3)
CMovX(P1,VArr(VA1,V(m)),13)
f_MemcpyX(P1,EPD(0x58F450),2,EPD(0x58F500),0,9)
f_MemcpyX(P1,V(0x10),V(0x12),V(0x11),V(0x13),V(0x14))
f_MemcpyX(P1,VArr(VA1,V(i)),VArr(VA1,V(k)),VArr(VA1,V( j)),VArr(VA1,V(l)),VArr(VA1,V(m)))
f_MemcpyX(P1,LArr(LA1,0),0,EPD(0x58F500),0,32,4,1)
f_MemcpyX(P1,LArr({LA1,1},V(i)),0,EPD(0x58F500),2,30,4,1)
f_MemcpyX(P1,EPD(0x58F4C0),0,LArr(LA1,0),0,32,1,4)
f_MemcpyX(P1,EPD(0x58F4E0),0,LArr({LA1,1},V(i)),0,30,1,4)
------------------------------------------------------------------------------------------

289

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-G] f_ReadcpyEPD()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CVariable(P1,0x10) -- 변수
CVariable(P1,0x11) -- 변수
CVariable(P1,0x12) -- 변수
CVariable(P1,0x13) -- 변수
CVariable(P1,0x14) -- 변수
A1 = CArray(P1,1000) -- 배열
VA1 = CVArray(P1,10) -- 변수배열
VA2 = CVArray(P1,10) -- 변수배열
CVariable2(P1,0x20,"X","X",1) i = 0x20 -- 인덱스 변수
CVariable2(P1,0x30,"X","X",2) j = 0x30
CVariable2(P1,0x40,"X","X",3) k = 0x40
CVariable2(P1,0x50,"X","X",4) l = 0x50
CVariable2(P1,0x60,"X","X",5) m = 0x60
CJumpEnd(AllPlayers,0)
CMov(P1,0x58F500,0x22221111)
CMov(P1,0x58F504,0x44443333)
CMov(P1,0x58F508,0x66665555)
CMov(P1,0x58F50C,0x88887777)
CMov(P1,0x58F510,0xAAAA9999)
CMov(P1,0x58F514,0xCCCCBBBB)
CMov(P1,0x58F518,0xEEEEDDDD)
CMov(P1,0x58F51C,0x0000FFFF)
CMov(P1,V(0x10),EPD(0x58F508))
CMov(P1,V(0x11),8)
CMovX(P1,VArr(VA1,V(i)),EPD(0x58F510))
CMovX(P1,VArr(VA1,V( j)),16)
f_ReadcpyEPD(P1,VArr(VA2,0),EPD(0x58F500),8)
f_ReadcpyEPD(P1,VArr(VA2,2),V(0x10),V(0x11))
f_ReadcpyEPD(P1,VArr(VA2,V(l)),VArr(VA1,V(i)),VArr(VA1,V( j)))
f_Movcpy(P1,0x58F450,VArr(VA2,0),32)

------------------------------------------------------------------------------------------

290

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-H] f_Readcpy()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CVariable(P1,0x10) -- 변수
CVariable(P1,0x11) -- 변수
CVariable(P1,0x12) -- 변수
CVariable(P1,0x13) -- 변수
CVariable(P1,0x14) -- 변수
A1 = CArray(P1,1000) -- 배열
VA1 = CVArray(P1,10) -- 변수배열
VA2 = CVArray(P1,10) -- 변수배열
CVariable2(P1,0x20,"X","X",1) i = 0x20 -- 인덱스 변수
CVariable2(P1,0x30,"X","X",2) j = 0x30
CVariable2(P1,0x40,"X","X",3) k = 0x40
CVariable2(P1,0x50,"X","X",4) l = 0x50
CVariable2(P1,0x60,"X","X",5) m = 0x60
CJumpEnd(AllPlayers,0)
CMov(P1,0x58F500,0x22221111)
CMov(P1,0x58F504,0x44443333)
CMov(P1,0x58F508,0x66665555)
CMov(P1,0x58F50C,0x88887777)
CMov(P1,0x58F510,0xAAAA9999)
CMov(P1,0x58F514,0xCCCCBBBB)
CMov(P1,0x58F518,0xEEEEDDDD)
CMov(P1,0x58F51C,0x0000FFFF)
CMov(P1,V(0x10),0x58F502+9)
CMov(P1,V(0x11),10)
CMovX(P1,VArr(VA1,V(i)),0x58F502+19)
CMovX(P1,VArr(VA1,V( j)),13)
f_Readcpy(P1,VArr(VA2,0),0x58F502,9)
f_Readcpy(P1,VArr(VA2,2),V(0x10),V(0x11),1)
f_Readcpy(P1,VArr(VA2,V(l)),VArr(VA1,V(i)),VArr(VA1,V( j)),3)
f_Movcpy(P1,0x58F450,VArr(VA2,0),32)

------------------------------------------------------------------------------------------

291

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-I] f_ReadcpyX()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CVariable(P1,0x10) -- 변수
CVariable(P1,0x11) -- 변수
CVariable(P1,0x12) -- 변수
CVariable(P1,0x13) -- 변수
CVariable(P1,0x14) -- 변수
A1 = CArray(P1,1000) -- 배열
VA1 = CVArray(P1,10) -- 변수배열
VA2 = CVArray(P1,10) -- 변수배열
CVariable2(P1,0x20,"X","X",1) i = 0x20 -- 인덱스 변수
CVariable2(P1,0x30,"X","X",2) j = 0x30
CVariable2(P1,0x40,"X","X",3) k = 0x40
CVariable2(P1,0x50,"X","X",4) l = 0x50
CVariable2(P1,0x60,"X","X",5) m = 0x60
CJumpEnd(AllPlayers,0)
CMov(P1,0x58F500,0x22221111)
CMov(P1,0x58F504,0x44443333)
CMov(P1,0x58F508,0x66665555)
CMov(P1,0x58F50C,0x88887777)
CMov(P1,0x58F510,0xAAAA9999)
CMov(P1,0x58F514,0xCCCCBBBB)
CMov(P1,0x58F518,0xEEEEDDDD)
CMov(P1,0x58F51C,0x0000FFFF)
CMov(P1,V(0x10),EPD(0x58F50B))
CMov(P1,V(0x11),3)
CMov(P1,V(0x12),10)
CMovX(P1,VArr(VA1,V(i)),EPD(0x58F515))
CMovX(P1,VArr(VA1,V( j)),1)
CMovX(P1,VArr(VA1,V(k)),13)
f_ReadcpyX(P1,VArr(VA2,0),EPD(0x58F500),2,9)
f_ReadcpyX(P1,VArr(VA2,2),V(0x10),V(0x11),V(0x12),1)
f_ReadcpyX(P1,VArr(VA2,V(l)),VArr(VA1,V(i)),VArr(VA1,V( j)),VArr(VA1,V(k)),3)
f_Movcpy(P1,0x58F450,VArr(VA2,0),32)

------------------------------------------------------------------------------------------

292

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-J] f_MovcpyEPD()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CVariable(P1,0x10) -- 변수
CVariable(P1,0x11) -- 변수
CVariable(P1,0x12) -- 변수
CVariable(P1,0x13) -- 변수
CVariable(P1,0x14) -- 변수
A1 = CArray(P1,1000) -- 배열
VA1 = CVArray(P1,10) -- 변수배열
CVariable2(P1,0x20,"X","X",1) i = 0x20 -- 인덱스 변수
CVariable2(P1,0x30,"X","X",2) j = 0x30
CVariable2(P1,0x40,"X","X",3) k = 0x40
CVariable2(P1,0x50,"X","X",4) l = 0x50
CVariable2(P1,0x60,"X","X",5) m = 0x60
VA2 = CVArray(P1,10) -- 변수배열
CJumpEnd(AllPlayers,0)
CMov(P1,VArr(VA2,0),0x22221111)
CMov(P1,VArr(VA2,1),0x44443333)
CMov(P1,VArr(VA2,2),0x66665555)
CMov(P1,VArr(VA2,3),0x88887777)
CMov(P1,VArr(VA2,4),0xAAAA9999)
CMov(P1,VArr(VA2,5),0xCCCCBBBB)
CMov(P1,VArr(VA2,6),0xEEEEDDDD)
CMov(P1,VArr(VA2,7),0x0000FFFF)
CMov(P1,V(0x10),EPD(0x58F458))
CMov(P1,V(0x11),8)
CMovX(P1,VArr(VA1,V(i)),EPD(0x58F460))
CMovX(P1,VArr(VA1,V( j)),16)
f_MovcpyEPD(P1,EPD(0x58F450),VArr(VA2,0),8)
f_MovcpyEPD(P1,V(0x10),VArr(VA2,2),V(0x11))
f_MovcpyEPD(P1,VArr(VA1,V(i)),VArr(VA2,V(l)),VArr(VA1,V( j)))

------------------------------------------------------------------------------------------

293

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-K] f_Movcpy()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CVariable(P1,0x10) -- 변수
CVariable(P1,0x11) -- 변수
CVariable(P1,0x12) -- 변수
CVariable(P1,0x13) -- 변수
CVariable(P1,0x14) -- 변수
A1 = CArray(P1,1000) -- 배열
VA1 = CVArray(P1,10) -- 변수배열
CVariable2(P1,0x20,"X","X",1) i = 0x20 -- 인덱스 변수
CVariable2(P1,0x30,"X","X",2) j = 0x30
CVariable2(P1,0x40,"X","X",3) k = 0x40
CVariable2(P1,0x50,"X","X",4) l = 0x50
CVariable2(P1,0x60,"X","X",5) m = 0x60
VA2 = CVArray(P1,10) -- 변수배열
CJumpEnd(AllPlayers,0)
CMov(P1,VArr(VA2,0),0x22221111)
CMov(P1,VArr(VA2,1),0x44443333)
CMov(P1,VArr(VA2,2),0x66665555)
CMov(P1,VArr(VA2,3),0x88887777)
CMov(P1,VArr(VA2,4),0xAAAA9999)
CMov(P1,VArr(VA2,5),0xCCCCBBBB)
CMov(P1,VArr(VA2,6),0xEEEEDDDD)
CMov(P1,VArr(VA2,7),0x0000FFFF)
CMov(P1,V(0x10),0x58F458+2)
CMov(P1,V(0x11),8)
CMovX(P1,VArr(VA1,V(i)),0x58F460+2)
CMovX(P1,VArr(VA1,V( j)),16)
f_Movcpy(P1,0x58F452,VArr(VA2,0),8)
-- 0x58F452부터 작성시작 (0x58F450 +0x0, +0x1의 2바이트는 작성X)
f_Movcpy(P1,V(0x10),VArr(VA2,2),V(0x11))
-- 0x58F45A부터 작성시작 (0x58F45A +0x0, +0x1의 2바이트는 작성X)
f_Movcpy(P1,VArr(VA1,V(i)),VArr(VA2,V(l)),VArr(VA1,V( j)))
-- 0x58F462부터 작성시작 (0x58F460 +0x0, +0x1의 2바이트는 작성X)

------------------------------------------------------------------------------------------

294

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-L] f_Abs()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CVariable(P1,0x10) CVariable(P1,0x11)
A1 = CArray(P1,1000) -- 배열
VA1 = CVArray(P1,10) -- 변수배열
CVariable2(P1,0x20,"X","X",1) i = 0x20 -- 인덱스 변수
CVariable2(P1,0x30,"X","X",2) j = 0x30
CVariable2(P1,0x40,"X","X",3) k = 0x40
CVariable2(P1,0x50,"X","X",4) l = 0x50
CVariable2(P1,0x60,"X","X",5) m = 0x60
VA2 = CVArray(P1,10) -- 변수배열
CJumpEnd(AllPlayers,0)

CMov(P1,V(0x10),0xFFFFFFF0)
CMovX(P1,VArr(VA1,V(i)),0xFFFFFFF0)
f_Abs(P1,V(0x10))
f_Abs(P1,VArr(VA1,V(i)))
CMov(P1,0x58F450,V(0x10))
CMovX(P1,0x58F458,VArr(VA1,V(i)))
CMov(P1,V(0x10),0xFFFFFFF0)
CMovX(P1,VArr(VA1,V(i)),0xFFFFFFF0)
f_Abs(P1,V(0x11),V(0x10))
f_Abs(P1,VArr(VA1,V( j)),VArr(VA1,V(i)))
CMov(P1,0x58F454,V(0x11))
CMovX(P1,0x58F45C,VArr(VA1,V( j)))
CMov(P1,V(0x10),0x10)
CMovX(P1,VArr(VA1,V(i)),0x10)
f_Abs(P1,V(0x10))
f_Abs(P1,VArr(VA1,V(i)))

CMov(P1,0x58F460,V(0x10))
CMovX(P1,0x58F468,VArr(VA1,V(i)))
CMov(P1,V(0x10),0x10)
CMovX(P1,VArr(VA1,V(i)),0x10)
f_Abs(P1,V(0x11),V(0x10))
f_Abs(P1,VArr(VA1,V( j)),VArr(VA1,V(i)))
CMov(P1,0x58F464,V(0x11))
CMovX(P1,0x58F46C,VArr(VA1,V( j)))
------------------------------------------------------------------------------------------

295

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-M] f_Mul()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CVariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12)
CVariable(P1,0x13) CVariable(P1,0x14)
A1 = CArray(P1,1000) VA1 = CVArray(P1,10) VA2 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x30,"X","X",2) j = 0x30
CVariable2(P1,0x40,"X","X",3) k = 0x40 CVariable2(P1,0x50,"X","X",4) l = 0x50
CVariable2(P1,0x60,"X","X",5) m = 0x60
CJumpEnd(AllPlayers,0)

CMov(P1,V(0x10),0xFFFFFFF0)
CMovX(P1,VArr(VA1,V(i)),0xFFFFFFF0)
f_Mul(P1,V(0x10),_Read(0x57f0f0))
f_Mul(P1,VArr(VA1,V(i)),_Read(0x57f0f0))
CMov(P1,0x58F450,V(0x10))
CMovX(P1,0x58F458,VArr(VA1,V(i)))
CMov(P1,V(0x10),0xFFFFFFF0)
CMovX(P1,VArr(VA1,V(i)),0xFFFFFFF0)
f_Mul(P1,V(0x11),V(0x10),_Read(0x57f0f0))
f_Mul(P1,VArr(VA1,V( j)),VArr(VA1,V(i)),_Read(0x57f0f0))
CMov(P1,0x58F454,V(0x11))
CMovX(P1,0x58F45C,VArr(VA1,V( j)))
CMov(P1,0x58F4E0,_Mul(_Read(0x57F0F0),_Read(0x57F120)))
------------------------------------------------------------------------------------------

296

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-N] f_iMul()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CVariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12)
CVariable(P1,0x13) CVariable(P1,0x14)
A1 = CArray(P1,1000) VA1 = CVArray(P1,10) VA2 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x30,"X","X",2) j = 0x30
CVariable2(P1,0x40,"X","X",3) k = 0x40 CVariable2(P1,0x50,"X","X",4) l = 0x50
CVariable2(P1,0x60,"X","X",5) m = 0x60
CJumpEnd(AllPlayers,0)

CMov(P1,V(0x10),0xFFFFFFF0)
CMovX(P1,VArr(VA1,V(i)),0xFFFFFFF0)
f_iMul(P1,V(0x10),_Read(0x57f0f0))
f_iMul(P1,VArr(VA1,V(i)),_Read(0x57f0f0))
CMov(P1,0x58F450,V(0x10))
CMovX(P1,0x58F458,VArr(VA1,V(i)))
CMov(P1,V(0x10),0xFFFFFFF0)
CMovX(P1,VArr(VA1,V(i)),0xFFFFFFF0)
f_iMul(P1,V(0x11),V(0x10),_Read(0x57f0f0))
f_iMul(P1,VArr(VA1,V( j)),VArr(VA1,V(i)),_Read(0x57f0f0))
CMov(P1,0x58F454,V(0x11))
CMovX(P1,0x58F45C,VArr(VA1,V( j)))
CMov(P1,0x58F4E0,_iMul(_Read(0x57F0F0),_Read(0x57F120)))
------------------------------------------------------------------------------------------

297

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-O] f_Div(), f_iDiv()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CVariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12) CVariable(P1,0x13)
CVariable(P1,0x14) A1 = CArray(P1,1000) VA1 = CVArray(P1,10) VA2 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x30,"X","X",2) j = 0x30
CVariable2(P1,0x40,"X","X",3) k = 0x40 CVariable2(P1,0x50,"X","X",4) l = 0x50
CVariable2(P1,0x60,"X","X",5) m = 0x60
CJumpEnd(AllPlayers,0)
CMov(P1,V(0x10),0xFFFFF0000)
CMovX(P1,VArr(VA1,V(i)),0xFFFFF0000)
f_Div(P1,V(0x10),_Read(0x57f0f0))
f_Div(P1,VArr(VA1,V(i)),_Read(0x57f0f0))
CMov(P1,0x58F450,V(0x10))
CMovX(P1,0x58F458,VArr(VA1,V(i)))
CMov(P1,V(0x10),0xFFFFF0000)
CMovX(P1,VArr(VA1,V(i)),0xFFFFF0000)
f_Div(P1,V(0x11),V(0x10),_Read(0x57f0f0))
f_Div(P1,VArr(VA1,V( j)),VArr(VA1,V(i)),_Read(0x57f0f0))
CMov(P1,0x58F454,V(0x11))
CMovX(P1,0x58F45C,VArr(VA1,V( j)))
CMov(P1,V(0x10),0xFFFFF0000)
CMovX(P1,VArr(VA1,V(i)),0xFFFFF0000)
f_iDiv(P1,V(0x10),_Read(0x57f0f0))
f_iDiv(P1,VArr(VA1,V(i)),_Read(0x57f0f0))
CMov(P1,0x58F460,V(0x10))
CMovX(P1,0x58F468,VArr(VA1,V(i)))
CMov(P1,V(0x10),0xFFFFF0000)
CMovX(P1,VArr(VA1,V(i)),0xFFFFF0000)
f_iDiv(P1,V(0x11),V(0x10),_Read(0x57f0f0))
f_iDiv(P1,VArr(VA1,V( j)),VArr(VA1,V(i)),_Read(0x57f0f0))
CMov(P1,0x58F464,V(0x11))
CMovX(P1,0x58F46C,VArr(VA1,V( j)))
CMov(P1,0x58F4E0,_Div(_Read(0x57F0F0),_Read(0x57F120)))
CMov(P1,0x58F4E4,_iDiv(_Read(0x57F0F0),_Read(0x57F120)))
------------------------------------------------------------------------------------------

298

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-P] f_Mod(), f_iMod()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CVariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12) CVariable(P1,0x13)
CVariable(P1,0x14) A1 = CArray(P1,1000) VA1 = CVArray(P1,10) VA2 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x30,"X","X",2) j = 0x30
CVariable2(P1,0x40,"X","X",3) k = 0x40 CVariable2(P1,0x50,"X","X",4) l = 0x50
CVariable2(P1,0x60,"X","X",5) m = 0x60
CJumpEnd(AllPlayers,0)
CMov(P1,V(0x10),0xFFFFF0000)
CMovX(P1,VArr(VA1,V(i)),0xFFFFF0000)
f_Mod(P1,V(0x10),_Read(0x57f0f0))
f_Mod(P1,VArr(VA1,V(i)),_Read(0x57f0f0))
CMov(P1,0x58F450,V(0x10))
CMovX(P1,0x58F458,VArr(VA1,V(i)))
CMov(P1,V(0x10),0xFFFFF0000)
CMovX(P1,VArr(VA1,V(i)),0xFFFFF0000)
f_Mod(P1,V(0x11),V(0x10),_Read(0x57f0f0))
f_Mod(P1,VArr(VA1,V( j)),VArr(VA1,V(i)),_Read(0x57f0f0))
CMov(P1,0x58F454,V(0x11))
CMovX(P1,0x58F45C,VArr(VA1,V( j)))
CMov(P1,V(0x10),0xFFFFF0000)
CMovX(P1,VArr(VA1,V(i)),0xFFFFF0000)
f_iMod(P1,V(0x10),_Read(0x57f0f0))
f_iMod(P1,VArr(VA1,V(i)),_Read(0x57f0f0))
CMov(P1,0x58F460,V(0x10))
CMovX(P1,0x58F468,VArr(VA1,V(i)))
CMov(P1,V(0x10),0xFFFFF0000)
CMovX(P1,VArr(VA1,V(i)),0xFFFFF0000)
f_iMod(P1,V(0x11),V(0x10),_Read(0x57f0f0))
f_iMod(P1,VArr(VA1,V( j)),VArr(VA1,V(i)),_Read(0x57f0f0))
CMov(P1,0x58F464,V(0x11))
CMovX(P1,0x58F46C,VArr(VA1,V( j)))
CMov(P1,0x58F4E0,_Mod(_Read(0x57F0F0),_Read(0x57F120)))
CMov(P1,0x58F4E4,_iMod(_Read(0x57F0F0),_Read(0x57F120)))
------------------------------------------------------------------------------------------

299

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-Q] f_Sqrt()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CVariable(P1,0x10) -- 변수
CVariable(P1,0x11) -- 변수
CVariable(P1,0x12) -- 변수
CVariable(P1,0x13) -- 변수
CVariable(P1,0x14) -- 변수
A1 = CArray(P1,1000) -- 배열
VA1 = CVArray(P1,10) -- 변수배열
CVariable2(P1,0x20,"X","X",1) i = 0x20 -- 인덱스 변수
CVariable2(P1,0x30,"X","X",2) j = 0x30
CVariable2(P1,0x40,"X","X",3) k = 0x40
CVariable2(P1,0x50,"X","X",4) l = 0x50
CVariable2(P1,0x60,"X","X",5) m = 0x60
VA2 = CVArray(P1,10) -- 변수배열
CJumpEnd(AllPlayers,0)
CMov(P1,V(0x10),0xFFFFFFFF)
CMovX(P1,VArr(VA1,V(i)),0xFFFFFFFF)
f_Sqrt(P1,V(0x11),V(0x10))
f_Sqrt(P1,VArr(VA1,V( j)),VArr(VA1,V(i)))
CMov(P1,0x58F450,V(0x11))
CMovX(P1,0x58F454,VArr(VA1,V( j)))
CMov(P1,0x58F4E0,_Sqrt(_Read(0x57F0F0)))
------------------------------------------------------------------------------------------

300

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-R] f_Lengthdir()
CJump(AllPlayers,0)
Include_CtrigPlib(720,"Switch 1",1) -- 720도 각도계
CVariable(P1,0x10) -- 변수
CVariable(P1,0x11) -- 변수
CVariable(P1,0x12) -- 변수
CVariable(P1,0x13) -- 변수
CVariable(P1,0x14) -- 변수
A1 = CArray(P1,1000) -- 배열
VA1 = CVArray(P1,10) -- 변수배열
CVariable2(P1,0x20,"X","X",1) i = 0x20 -- 인덱스 변수
CVariable2(P1,0x30,"X","X",2) j = 0x30
CVariable2(P1,0x40,"X","X",3) k = 0x40
CVariable2(P1,0x50,"X","X",4) l = 0x50
CVariable2(P1,0x60,"X","X",5) m = 0x60
VA2 = CVArray(P1,10) -- 변수배열
for i = 0x100, 0x105 do
CVariable(P1,i)
end
CJumpEnd(AllPlayers,0)
CMov(P1,V(0x10),_ReadX(0x57f0f0,0xFFFFFFFF,0x100))
CMov(P1,V(0x11),_Read(0x57f120))
CMovX(P1,VArr(VA1,V(i)),_ReadX(0x57f0f0,0xFFFFFFFF,0x100))
CMovX(P1,VArr(VA1,V( j)),_Read(0x57f120))
f_Lengthdir(P1,0x10000,60,V(0x100),V(0x101))
f_Lengthdir(P1,V(0x10),V(0x11),V(0x102),V(0x103))
f_Lengthdir(P1,VArr(VA1,V(i)),VArr(VA1,V( j)),VArr(VA1,V(k)),VArr(VA1,V(l)))
CMov(P1,0x58F450,V(0x100))
CMov(P1,0x58F454,V(0x101))
CMov(P1,0x58F458,V(0x102))
CMov(P1,0x58F45C,V(0x103))
CMovX(P1,0x58F460,VArr(VA1,V(k)))
CMovX(P1,0x58F464,VArr(VA1,V(l)))
f_LMov(P1,0x58F4E0,_Lengthdir(_Read(0x57F0F0),_Read(0x57F120)))
------------------------------------------------------------------------------------------

301

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-S] f_Atan2()
CJump(AllPlayers,0)
Include_CtrigPlib(720,"Switch 1",1) -- 720도 각도계
CVariable(P1,0x10) -- 변수
CVariable(P1,0x11) -- 변수
CVariable(P1,0x12) -- 변수
CVariable(P1,0x13) -- 변수
CVariable(P1,0x14) -- 변수
A1 = CArray(P1,1000) -- 배열
VA1 = CVArray(P1,10) -- 변수배열
CVariable2(P1,0x20,"X","X",1) i = 0x20 -- 인덱스 변수
CVariable2(P1,0x30,"X","X",2) j = 0x30
CVariable2(P1,0x40,"X","X",3) k = 0x40
CVariable2(P1,0x50,"X","X",4) l = 0x50
CVariable2(P1,0x60,"X","X",5) m = 0x60
VA2 = CVArray(P1,10) -- 변수배열
for i = 0x100, 0x105 do
CVariable(P1,i)
end
CJumpEnd(AllPlayers,0)
CMov(P1,V(0x10),_Read(0x57f0f0))
CMov(P1,V(0x11),_Read(0x57f120))
CMovX(P1,VArr(VA1,V(i)),_Read(0x57f0f0))
CMovX(P1,VArr(VA1,V( j)),_Read(0x57f120))
f_Atan2(P1,0x10000,0x1000,V(0x100))
f_Atan2(P1,V(0x10),V(0x11),V(0x101))
f_Atan2(P1,VArr(VA1,V(i)),VArr(VA1,V( j)),VArr(VA1,V(k)))
CMov(P1,0x58F450,V(0x100))
CMov(P1,0x58F454,V(0x101))
CMovX(P1,0x58F458,VArr(VA1,V(k)))
CMov(P1,0x58F4E0,_Atan2(_Read(0x57F0F0),_Read(0x57F120)))
------------------------------------------------------------------------------------------

302

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-T] f_Log2()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CVariable(P1,0x10) -- 변수
CVariable(P1,0x11) -- 변수
VA1 = CVArray(P1,10) -- 변수배열
CVariable2(P1,0x20,"X","X",1) i = 0x20 -- 인덱스 변수
CVariable2(P1,0x30,"X","X",2) j = 0x30
CJumpEnd(AllPlayers,0)
CMov(P1,V(0x10),0xFFFFFFFF)
CMovX(P1,VArr(VA1,V(i)),0xFFFFFFFF)
f_Log2(P1,V(0x11),V(0x10))
f_Log2(P1,VArr(VA1,V( j)),VArr(VA1,V(i)))
CMov(P1,0x58F450,V(0x11))
CMovX(P1,0x58F454,VArr(VA1,V( j)))
CMov(P1,V(0x10),0xFFFFFFFF)
CMovX(P1,VArr(VA1,V(i)),0xFFFFFFFF)
CMov(P1,0x58F458,_Log2(VArr(VA1,V(i))))
CMov(P1,0x58F45C,_Log2(V(0x10)))
CMov(P1,0x58F4E0,_Log2(_Read(0x57F0F0)))
------------------------------------------------------------------------------------------

303

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-U] f_Rand()
CJump(AllPlayers,0)
Include_CtrigPlib(720,"Switch 1",1)
CVariable(P1,0x10) -- 변수
CVariable(P1,0x11) -- 변수
CVariable(P1,0x12) -- 변수
CVariable(P1,0x13) -- 변수
CVariable(P1,0x14) -- 변수
A1 = CArray(P1,1000) -- 배열
VA1 = CVArray(P1,10) -- 변수배열
CVariable2(P1,0x20,"X","X",1) i = 0x20 -- 인덱스 변수
CVariable2(P1,0x30,"X","X",2) j = 0x30
CVariable2(P1,0x40,"X","X",3) k = 0x40
CVariable2(P1,0x50,"X","X",4) l = 0x50
CVariable2(P1,0x60,"X","X",5) m = 0x60
VA2 = CVArray(P1,10) -- 변수배열
for i = 0x100, 0x105 do
CVariable(P1,i)
end
CJumpEnd(AllPlayers,0)
f_Rand(P1,V(0x10))
f_Rand(P1,VArr(VA1,V(i)))
CMov(P1,0x58F450,V(0x10))
CMovX(P1,0x58F454,VArr(VA1,V(i)))
CMov(P1,0x58F4E0,_Rand())
------------------------------------------------------------------------------------------

304

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-V] f_GetStrptr(), f_GetTblptr()
CJump(AllPlayers,0)
Include_CtrigPlib(720,"Switch 1",1)
CVariable(P1,0x10) -- 변수
CVariable(P1,0x11) -- 변수
CVariable(P1,0x12) -- 변수
CVariable(P1,0x13) -- 변수
CVariable(P1,0x14) -- 변수
A1 = CArray(P1,1000) -- 배열
VA1 = CVArray(P1,10) -- 변수배열
CVariable2(P1,0x20,"X","X",1) i = 0x20 -- 인덱스 변수
CVariable2(P1,0x30,"X","X",2) j = 0x30
CVariable2(P1,0x40,"X","X",3) k = 0x40
CVariable2(P1,0x50,"X","X",4) l = 0x50
CVariable2(P1,0x60,"X","X",5) m = 0x60
VA2 = CVArray(P1,10) -- 변수배열
CJumpEnd(AllPlayers,0)
f_GetStrptr(P1,V(0x10),"11111111")
f_GetStrptr(P1,VArr(VA1,V(i)),"22222222")
f_GetTblptr(P1,V(0x11),342) -- 이레디 tbl 스트링
f_GetTblptr(P1,VArr(VA1,V( j)),343) -- 야마토 tbl 스트링
DoActions(P1,{DisplayText("11111111",4),DisplayText("22222222",4)})
CMov(P1,0x58F450,V(0x10))
CMov(P1,0x58F458,V(0x11))
CMovX(P1,0x58F454,VArr(VA1,V(i)))
CMovX(P1,0x58F45C,VArr(VA1,V( j)))
CMov(P1,0x58F500,0x411F421F)
CMov(P1,0x58F504,0x431B441B)
CMov(P1,0x58F508,0x45194619)
CMov(P1,0x58F50C,0x471D481D)
f_Memcpy(P1,V(0x10),0x58F500,4)
f_Memcpy(P1,VArr(VA1,V(i)),0x58F504,4)
f_Memcpy(P1,_Add(V(0x11),4),0x58F508,4)
f_Memcpy(P1,_Add(VArr(VA1,V( j)),4),0x58F50C,4)
f_GetStrptr(P1,0x58F4E0,_Read(0x57F0F0))
f_GetTblptr(P1,0x58F4E4,_Read(0x57F120))

-----------------------------------------------------------------------------------------305

------------------------------------------------------------------------------------------

『 14장 : 함수 호출형 최종 연산 함수 (f_) 』

-----------------------------------------------------------------------------------------[예제 14-W] f_GetStrptrX()
CJump(AllPlayers,0)
Include_CtrigPlib(720,"Switch 1",1)
CVariable(P1,0x10) -- 변수
VA1 = CVArray(P1,10) -- 변수배열
CVariable2(P1,0x20,"X","X",1) i = 0x20 -- 인덱스 변수
CJumpEnd(AllPlayers,0)
f_GetStrXptr(P1,V(0x10),"11111111")
f_GetStrXptr(P1,VArr(VA1,V(i)),"22222222")

DoActions(P1,{DisplayText("11111111",4),DisplayText("22222222",4)})
CMov(P1,0x58F450,V(0x10))
CMovX(P1,0x58F454,VArr(VA1,V(i)))
CMov(P1,0x58F500,0x411F421F)
CMov(P1,0x58F504,0x431B441B)
f_Memcpy(P1,V(0x10),0x58F500,4)
f_Memcpy(P1,VArr(VA1,V(i)),0x58F504,4)
f_GetStrXptr(P1,0x58F4E0,_Read(0x57F0F0))
------------------------------------------------------------------------------------------

306

------------------------------------------------------------------------------------------

『 15장 : 중간 연산자 관련 함수 (_) 』

-----------------------------------------------------------------------------------------[예제 15-1] _Mov(), _Read(), _ReadX(), _EPDRead()
CJump(AllPlayers,0)
Include_CtrigPlib(720,"Switch 1",1)

CVariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12) CVariable(P1,0x13) CVariable(P1,0x14)
A1 = CArray(P1,1000) VA1 = CVArray(P1,10) VA2 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x30,"X","X",2) j = 0x30 CVariable2(P1,0x40,"X","X",3)
k = 0x40 CVariable2(P1,0x50,"X","X",4) l = 0x50 CVariable2(P1,0x60,"X","X",5) m = 0x60

for i = 0x100, 0x105 do
CVariable(P1,i)
end
CJumpEnd(AllPlayers,0)

CMov(P1,V(0x10),0x567890AB)
CMovX(P1,VArr(VA1,V(i)),0x90ABCDEF)
CMov(P1,0x58F450,_Mov(0x12345678))
CMov(P1,0x58F454,_Mov(V(0x10)))
CMov(P1,0x58F458,_Mov(VArr(VA1,V(i))))
CMov(P1,V(0x10),EPD(0x57F0F0))
CMovX(P1,VArr(VA1,V(i)),EPD(0x57F0F0))

CMov(P1,0x58F45c,_Read(0x57F0F0))
CMov(P1,0x58F460,_Read(V(0x10)))
CMov(P1,0x58F464,_Read(VArr(VA1,V(i))))
CMov(P1,V(0x10),EPD(0x57F0F0))
CMovX(P1,VArr(VA1,V(i)),EPD(0x57F0F0))
CMov(P1,0x58F468,_ReadX(0x57F0F0,"X",0x10))
CMov(P1,0x58F46c,_ReadX(V(0x10),"X",0x100))
CMov(P1,0x58F470,_ReadX(VArr(VA1,V(i)),"X",0x1000))

CMov(P1,V(0x10),EPD(0x57F0F0))
CMovX(P1,VArr(VA1,V(i)),EPD(0x57F0F0))
CMov(P1,0x58F474,_EPDRead(0x57F0F0))
CMov(P1,0x58F478,_EPDRead(V(0x10)))
CMov(P1,0x58F47C,_EPDRead(VArr(VA1,V(i))))

------------------------------------------------------------------------------------------

307

------------------------------------------------------------------------------------------

『 15장 : 중간 연산자 관련 함수 (_) 』

-----------------------------------------------------------------------------------------[예제 15-2] _EPD(), _ReadF(), _ReadFX(), _EPDReadF()
CJump(AllPlayers,0)
Include_CtrigPlib(720,"Switch 1",1)

CVariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12) CVariable(P1,0x13) CVariable(P1,0x14)
A1 = CArray(P1,1000) VA1 = CVArray(P1,10) VA2 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x30,"X","X",2) j = 0x30 CVariable2(P1,0x40,"X","X",3)
k = 0x40 CVariable2(P1,0x50,"X","X",4) l = 0x50 CVariable2(P1,0x60,"X","X",5) m = 0x60

for i = 0x100, 0x105 do
CVariable(P1,i)
end
CJumpEnd(AllPlayers,0)

CMov(P1,V(0x10),0x57F0F0)
CMovX(P1,VArr(VA1,V(i)),0x57F0F0)
CMov(P1,0x58F454,_EPD(V(0x10)))
CMov(P1,0x58F458,_EPD(VArr(VA1,V(i))))
CMov(P1,V(0x10),EPD(0x57F0F0))
CMovX(P1,VArr(VA1,V(i)),EPD(0x57F0F0))

CMov(P1,0x58F45c,_ReadF(0x57F0F0))
CMov(P1,0x58F460,_ReadF(V(0x10)))
CMov(P1,0x58F464,_ReadF(VArr(VA1,V(i))))
CMov(P1,V(0x10),EPD(0x57F0F0))
CMovX(P1,VArr(VA1,V(i)),EPD(0x57F0F0))
CMov(P1,0x58F468,_ReadFX(0x57F0F0,"X",0x100))
CMov(P1,0x58F46c,_ReadFX(V(0x10),"X",0x10000))
CMov(P1,0x58F470,_ReadFX(VArr(VA1,V(i)),"X",0x1000000))

CMov(P1,V(0x10),EPD(0x57F0F0))
CMovX(P1,VArr(VA1,V(i)),EPD(0x57F0F0))
CMov(P1,0x58F474,_EPDReadF(0x57F0F0))
CMov(P1,0x58F478,_EPDReadF(V(0x10)))
CMov(P1,0x58F47C,_EPDReadF(VArr(VA1,V(i))))

------------------------------------------------------------------------------------------

308

------------------------------------------------------------------------------------------

『 15장 : 중간 연산자 관련 함수 (_) 』

-----------------------------------------------------------------------------------------[예제 15-3] _Add(), _Sub(), _iSub(), _Neg()
CJump(AllPlayers,0)
Include_CtrigPlib(720,"Switch 1",1)

CVariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12) CVariable(P1,0x13) CVariable(P1,0x14)
A1 = CArray(P1,1000) VA1 = CVArray(P1,10) VA2 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x30,"X","X",2) j = 0x30 CVariable2(P1,0x40,"X","X",3)
k = 0x40 CVariable2(P1,0x50,"X","X",4) l = 0x50 CVariable2(P1,0x60,"X","X",5) m = 0x60

for i = 0x100, 0x105 do
CVariable(P1,i)
end
CJumpEnd(AllPlayers,0)

CMov(P1,V(0x10),0x1000)
CMov(P1,V(0x11),0x10)
CMovX(P1,VArr(VA1,V(i)),0x100)
CMov(P1,0x58F450,_Add(VArr(VA1,V(i)),0x10))
CMov(P1,0x58F454,_Add(V(0x11),V(0x10)))
CMov(P1,0x58F458,_Add(V(0x10),VArr(VA1,V(i))))
CMov(P1,V(0x10),0x1000)
CMov(P1,V(0x11),0x10)
CMovX(P1,VArr(VA1,V(i)),0x100)
CMov(P1,0x58F45c,_Sub(VArr(VA1,V(i)),0x10))
CMov(P1,0x58F460,_Sub(V(0x11),V(0x10)))
CMov(P1,0x58F464,_Sub(V(0x10),VArr(VA1,V(i))))
CMov(P1,V(0x10),0x1000)
CMov(P1,V(0x11),0x10)
CMovX(P1,VArr(VA1,V(i)),0x100)
CMov(P1,0x58F468,_iSub(VArr(VA1,V(i)),0x10))
CMov(P1,0x58F46c,_iSub(V(0x11),V(0x10)))
CMov(P1,0x58F470,_iSub(V(0x10),VArr(VA1,V(i))))
CMov(P1,V(0x10),0x1000)
CMovX(P1,VArr(VA1,V(i)),0x1000)
CMov(P1,0x58F474,_Neg(V(0x10)))
CMov(P1,0x58F478,_Neg(VArr(VA1,V(i))))

------------------------------------------------------------------------------------------

309

------------------------------------------------------------------------------------------

『 15장 : 중간 연산자 관련 함수 (_) 』

-----------------------------------------------------------------------------------------[예제 15-4] _Mul(), _Div(), _iDiv(), _Abs()
CJump(AllPlayers,0)
Include_CtrigPlib(720,"Switch 1",1)

CVariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12) CVariable(P1,0x13) CVariable(P1,0x14)
A1 = CArray(P1,1000) VA1 = CVArray(P1,10) VA2 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x30,"X","X",2) j = 0x30 CVariable2(P1,0x40,"X","X",3)
k = 0x40 CVariable2(P1,0x50,"X","X",4) l = 0x50 CVariable2(P1,0x60,"X","X",5) m = 0x60

for i = 0x100, 0x105 do
CVariable(P1,i)
end
CJumpEnd(AllPlayers,0)

CMov(P1,V(0x10),0x50)
CMov(P1,V(0x11),0x20)
CMovX(P1,VArr(VA1,V(i)),0x30)
CMov(P1,0x58F450,_Mul(VArr(VA1,V(i)),0x10))
CMov(P1,0x58F454,_Mul(V(0x11),V(0x10)))
CMov(P1,0x58F458,_Mul(V(0x10),VArr(VA1,V(i))))
CMov(P1,V(0x10),0x6000)
CMov(P1,V(0x11),0x30)
CMovX(P1,VArr(VA1,V(i)),0x200)
CMov(P1,0x58F45c,_Div(VArr(VA1,V(i)),0x11))
CMov(P1,0x58F460,_Div(V(0x10),V(0x11)))
CMov(P1,0x58F464,_Div(V(0x10),VArr(VA1,V(i))))
CMov(P1,V(0x10),-0x6000)
CMov(P1,V(0x11),0x30)
CMovX(P1,VArr(VA1,V(i)),0x200)
CMov(P1,0x58F468,_iDiv(VArr(VA1,V(i)),0x11))
CMov(P1,0x58F46c,_iDiv(V(0x10),V(0x11)))
CMov(P1,0x58F470,_iDiv(V(0x10),VArr(VA1,V(i))))
CMov(P1,V(0x10),0xFFFFFFFF)
CMovX(P1,VArr(VA1,V(i)),0xFFFFFFFF)
CMov(P1,0x58F474,_Abs(V(0x10)))
CMov(P1,0x58F478,_Abs(VArr(VA1,V(i))))

------------------------------------------------------------------------------------------

310

------------------------------------------------------------------------------------------

『 15장 : 중간 연산자 관련 함수 (_) 』

-----------------------------------------------------------------------------------------[예제 15-5] _Sqrt(), _Mod(), _iMod(), _Rand()
CJump(AllPlayers,0)
Include_CtrigPlib(720,"Switch 1",1)

CVariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12) CVariable(P1,0x13) CVariable(P1,0x14)
A1 = CArray(P1,1000) VA1 = CVArray(P1,10) VA2 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x30,"X","X",2) j = 0x30 CVariable2(P1,0x40,"X","X",3)
k = 0x40 CVariable2(P1,0x50,"X","X",4) l = 0x50 CVariable2(P1,0x60,"X","X",5) m = 0x60

for i = 0x100, 0x105 do
CVariable(P1,i)
end
CJumpEnd(AllPlayers,0)

CMov(P1,V(0x10),0x50)
CMov(P1,V(0x11),0x20)
CMovX(P1,VArr(VA1,V(i)),0x30)
CMov(P1,0x58F450,_Sqrt(VArr(VA1,V(i))))
CMov(P1,0x58F454,_Sqrt(V(0x10)))
CMov(P1,V(0x10),0x4321)
CMov(P1,V(0x11),0x30)
CMovX(P1,VArr(VA1,V(i)),0x200)
CMov(P1,0x58F45c,_Mod(VArr(VA1,V(i)),0x11))
CMov(P1,0x58F460,_Mod(V(0x10),V(0x11)))
CMov(P1,0x58F464,_Mod(V(0x10),VArr(VA1,V(i))))
CMov(P1,V(0x10),-0x4321)
CMov(P1,V(0x11),0x30)
CMovX(P1,VArr(VA1,V(i)),0x200)
CMov(P1,0x58F468,_iMod(VArr(VA1,V(i)),0x11))
CMov(P1,0x58F46c,_iMod(V(0x10),V(0x11)))
CMov(P1,0x58F470,_iMod(V(0x10),VArr(VA1,V(i))))
CMov(P1,V(0x10),0xFFFFFFFF)
CMovX(P1,VArr(VA1,V(i)),0xFFFFFFFF)
CMov(P1,0x58F474,_Rand(V(0x10)))
CMov(P1,0x58F478,_Rand(VArr(VA1,V(i))))

------------------------------------------------------------------------------------------

311

------------------------------------------------------------------------------------------

『 15장 : 중간 연산자 관련 함수 (_) 』

-----------------------------------------------------------------------------------------[예제 15-6] _Not(), _And(), _Or(), _Xor()
CJump(AllPlayers,0)
Include_CtrigPlib(720,"Switch 1",1)

CVariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12) CVariable(P1,0x13) CVariable(P1,0x14)
A1 = CArray(P1,1000) VA1 = CVArray(P1,10) VA2 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x30,"X","X",2) j = 0x30 CVariable2(P1,0x40,"X","X",3)
k = 0x40 CVariable2(P1,0x50,"X","X",4) l = 0x50 CVariable2(P1,0x60,"X","X",5) m = 0x60

for i = 0x100, 0x105 do
CVariable(P1,i)
end
CJumpEnd(AllPlayers,0)

CMov(P1,V(0x10),0x00FF00FF)
CMov(P1,V(0x11),0x0F0F0F0F)
CMovX(P1,VArr(VA1,V(i)),0x0F0F0F0F)
CMov(P1,0x58F450,_And(VArr(VA1,V(i)),0xFF00FF00))
CMov(P1,0x58F454,_And(V(0x10),V(0x11)))
CMov(P1,0x58F458,_And(V(0x10),VArr(VA1,V(i))))
CMov(P1,V(0x10),0x00FF00FF)
CMov(P1,V(0x11),0x0F0F0F0F)
CMovX(P1,VArr(VA1,V(i)),0x0F0F0F0F)
CMov(P1,0x58F45c,_Or(VArr(VA1,V(i)),0xFF00FF00))
CMov(P1,0x58F460,_Or(V(0x10),V(0x11)))
CMov(P1,0x58F464,_Or(V(0x10),VArr(VA1,V(i))))
CMov(P1,V(0x10),-0x00FF00FF)
CMov(P1,V(0x11),0x0F0F0F0F)
CMovX(P1,VArr(VA1,V(i)),0x0F0F0F0F)
CMov(P1,0x58F468,_Xor(VArr(VA1,V(i)),0xFF00FF00))
CMov(P1,0x58F46c,_Xor(V(0x10),V(0x11)))
CMov(P1,0x58F470,_Xor(V(0x10),VArr(VA1,V(i))))
CMov(P1,V(0x10),0x0F0F0F0F)
CMovX(P1,VArr(VA1,V(i)),0x0F0F0F0F)
CMov(P1,0x58F474,_Not(V(0x10)))
CMov(P1,0x58F478,_Not(VArr(VA1,V(i))))

------------------------------------------------------------------------------------------

312

------------------------------------------------------------------------------------------

『 16장 : 변수 삽입형 조건/액션 함수 (T) 』

-----------------------------------------------------------------------------------------[예제 16-1] TSetMemoryX(), TSetMemory(), CDoActions()
CJump(AllPlayers,0)
Include_CtrigPlib(720,"Switch 1",1)

CVariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12) CVariable(P1,0x13) CVariable(P1,0x14)
A1 = CArray(P1,1000) VA1 = CVArray(P1,10) VA2 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x30,"X","X",2) j = 0x30 CVariable2(P1,0x40,"X","X",3)
k = 0x40 CVariable2(P1,0x50,"X","X",4) l = 0x50 CVariable2(P1,0x60,"X","X",5) m = 0x60

for i = 0x100, 0x105 do
CVariable(P1,i)
end
CJumpEnd(AllPlayers,0)

CMov(P1,V(0x10),EPD(0x58F454))
CMov(P1,VArr(VA1,V(i)),EPD(0x58F460))
CDoActions(P1,{TSetMemoryX(0x58F450,SetTo,0x12345678,0Xffffffff),
-- 0x58F450 << 0x12345678 (상수입력)
TSetMemoryX(V(0x10),SetTo,0x12345678,0Xffffffff),
-- EPD:V(0x10)인 Offset(=0x58F454) << 0x12345678 (상수출력)
TSetMemoryX(Arr(A1,0),SetTo,0x12345678,0Xffffffff),
-- A1[0] << 0x12345678 (상수입력)
TSetMemoryX(_TMem(Arr(A1,V(i))),SetTo,0x12345678,0Xffffffff),
-- A1[i] << 0x12345678 (변수입력)
TSetMemoryX(VArr(VA1,V(i)),SetTo,0x12345678,0Xffffffff),
-- EPD:VA1[i]인 Offset(=0x58F464) << 0x12345678 (변수출력)
TSetMemoryX(_TMem(VArr(VA1,V(i))),SetTo,0x12345678,0Xffffffff)})
-- VA1[i] << 0x12345678 (변수입력)

CRead(P1,0x58F458,Arr(A1,0))
CRead(P1,0x58F45C,Arr(A1,V(i)))
CRead(P1,0x58F464,_TMem(VArr(VA1,V(i))))
CMov(P1,V(0x10),EPD(0x58F468))
CMov(P1,VArr(VA1,V(i)),EPD(0x58F474))
CDoActions(P1,{TSetMemory(V(0x10),SetTo,V(0x10)), -- 0x58F468 << EPD(0x58F468)
TSetMemory(Arr(A1,0),SetTo,_TMem(Arr(A1,0),0,0,1)), -- A1[0] << A1[0]의 Offset
TSetMemory(_TMem(Arr(A1,V(i))),SetTo,_TMem(Arr(A1,V(i)),0,0,1)),
-- A1[i] << A1[i]의 Offset (변수입력)
TSetMemory(VArr(VA1,V(i)),SetTo,VArr(VA1,V(i))),
-- EPD:VA1[i]인 Offset(=0x58F464) << EPD(0x58F474) (변수출력)
TSetMemory(_TMem(VArr(VA1,V(i))),SetTo,_TMem(VArr(VA1,V(i)),0,0,1))})
-- VA1[i] << VA1[i]의 Offset (변수입력)
CRead(P1,0x58F46C,Arr(A1,0))
CRead(P1,0x58F470,Arr(A1,V(i)))
CRead(P1,0x58F478,_TMem(VArr(VA1,V(i))))
------------------------------------------------------------------------------------------

313

------------------------------------------------------------------------------------------

『 16장 : 변수 삽입형 조건/액션 함수 (T) 』

-----------------------------------------------------------------------------------------[예제 16-2] TMemoryX(), TMemory(), CTrigger()
CJump(AllPlayers,0)
Include_CtrigPlib(720,"Switch 1",1)

CVariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12) CVariable(P1,0x13) CVariable(P1,0x14)
A1 = CArray(P1,1000) VA1 = CVArray(P1,10) VA2 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x30,"X","X",2) j = 0x30 CVariable2(P1,0x40,"X","X",3)
k = 0x40 CVariable2(P1,0x50,"X","X",4) l = 0x50 CVariable2(P1,0x60,"X","X",5) m = 0x60
for i = 0x100, 0x105 do CVariable(P1,i) end

CJumpEnd(AllPlayers,0)

CMov(P1,0x58F500,1234)
CTrigger({P1},
{TMemoryX(0x58F500,Exactly,1234,0xFFFFFFFF)}, -- Memory(0x58F500,Exactly,1234);
{SetMemory(0x58F450,SetTo,1)},1)
CMov(P1,V(0x10),1234)
CTrigger({P1},
{TMemoryX(_Mem(V(0x10)),Exactly,1234,0xFFFFFFFF)}, -- Memory(V(0x10)의 값(=0x58F504),Exactly,1234);
{SetMemory(0x58F454,SetTo,1)},1)
CMov(P1,V(0x10),EPD(0x58F504))
CMov(P1,0x58F504,1234)
CTrigger({P1},
{TMemoryX(V(0x10),Exactly,1234,0xFFFFFFFF)}, -- Memory(V(0x10)의 주소,Exactly,1234);
{SetMemory(0x58F458,SetTo,1)},1)
CMov(P1,Arr(A1,0),1234)
CTrigger({P1},
{TMemoryX(Arr(A1,0),Exactly,1234,0xFFFFFFFF)}, -- Memory(A1[0]의 주소,Exactly,1234);
{SetMemory(0x58F45C,SetTo,1)},1)
CMov(P1,Arr(A1,V(i)),1234)
CTrigger({P1},
{TMemoryX(_TMem(Arr(A1,V(i))),Exactly,1234,0xFFFFFFFF)}, -- Memory(A1[i]의 주소,Exactly,1234);
{SetMemory(0x58F460,SetTo,1)},1)
CMov(P1,VArr(VA1,V(i)),EPD(0x58F508))
CMov(P1,0x58F508,1234)
CTrigger({P1},
{TMemoryX(VArr(VA1,V(i)),Exactly,1234,0xFFFFFFFF)}, -- Memory(VA1[i]의 값(=0x58F508),Exactly,1234);
{SetMemory(0x58F464,SetTo,1)},1)
CMov(P1,VArr(VA1,V(i)),1234)
CTrigger({P1},
{TMemoryX(_TMem(VArr(VA1,V(i))),Exactly,1234,0xFFFFFFFF)}, -- Memory(VA1[i]의 주소,Exactly,1234);
{SetMemory(0x58F468,SetTo,1)},1)
CMov(P1,V(0x10),EPD(0x58F50C))
CMov(P1,0x58F50C,EPD(0x58F50C))
CTrigger({P1},

{TMemoryX(V(0x10),Exactly,V(0x10),0xFFFFFFFF)}, -- Memory(V(0x10)의 값(=0x58F504),Exactly,V(0x10)의 값);

{SetMemory(0x58F46C,SetTo,1)},1)
CMov(P1,VArr(VA1,V(i)),EPD(0x58F510))
CMov(P1,0x58F510,EPD(0x58F510))
CTrigger({P1},
{TMemoryX(VArr(VA1,V(i)),Exactly,VArr(VA1,V(i)),0xFFFFFFFF)},
-- Memory(VA1[i]의 값(=0x58F508),Exactly,VA1[i]의 값);
{SetMemory(0x58F470,SetTo,1)},1)

------------------------------------------------------------------------------------------

314

------------------------------------------------------------------------------------------

『 16장 : 변수 삽입형 조건/액션 함수 (T) 』

-----------------------------------------------------------------------------------------[예제 16-3] TDeaths(), TCreateUnit()
CJump(AllPlayers,0)
Include_CtrigPlib(720,"Switch 1",1)

CVariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12) CVariable(P1,0x13) CVariable(P1,0x14)
A1 = CArray(P1,1000) VA1 = CVArray(P1,10) VA2 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x30,"X","X",2) j = 0x30 CVariable2(P1,0x40,"X","X",3)
k = 0x40 CVariable2(P1,0x50,"X","X",4) l = 0x50 CVariable2(P1,0x60,"X","X",5) m = 0x60

for i = 0x100, 0x105 do
CVariable(P1,i)
end
CJumpEnd(AllPlayers,0)

CTrigger({P1},
{TDeaths(EPD(0x57f0f0),Exactly,_Read(0x57f120),0), -- P1 미네랄 == 가스 (1이상)
TDeaths(EPD(0x57F0F0),AtLeast,1,0)},
{TCreateUnit(_Mul(_Read(0x57f120),2*0x01000000),"Terran Marine","CLoc",P1),
-- 가스양x2 만큼의 P1 마린 생성
SetMemory(0x57F0f0,SetTo,0)},1)
------------------------------------------------------------------------------------------

315

------------------------------------------------------------------------------------------

『 17장 : 특수 조건 관련 함수 (TT) 』

-----------------------------------------------------------------------------------------[예제 17-1] TTOR(), _TMemory(), _TTMemory()
CJump(AllPlayers,0)
Include_CtrigPlib(720,"Switch 1",1)

CVariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12) CVariable(P1,0x13) CVariable(P1,0x14)
A1 = CArray(P1,1000) VA1 = CVArray(P1,10) VA2 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x30,"X","X",2) j = 0x30 CVariable2(P1,0x40,"X","X",3)
k = 0x40 CVariable2(P1,0x50,"X","X",4) l = 0x50 CVariable2(P1,0x60,"X","X",5) m = 0x60

for i = 0x100, 0x105 do
CVariable(P1,i)
end
CJumpEnd(AllPlayers,0)

CMov(P1,V(0x10),17)
CMov(P1,V(0x11),15)
CMov(P1,V(0x14),16)
CMov(P1,V(0x12),EPD(0x57F0F0))
CMov(P1,V(0x13),EPD(0x57F120))
CMovX(P1,VArr(VA1,V(i)),15)
CMovX(P1,VArr(VA1,V( j)),17)
CMovX(P1,VArr(VA1,V(k)),EPD(0x57F0F0))
CMovX(P1,VArr(VA1,V(l)),EPD(0x57F120))
CTrigger({P1},
{TTOR({_TMemory(V(0x12),AtLeast,V(0x10)),_TMemory(VArr(VA1,V(k)),AtMost,VArr(VA1,V(i)))}),
TTOR({_TMemory(VArr(VA1,V(l)),AtLeast,VArr(VA1,V(j))),_TMemory(V(0x13),AtMost,V(0x11))})},
{DisplayText("TTOR조건만족",4)},1)

CTrigger({P1},
{TTOR({_TTMemory(V(0x12),NotSame,V(0x14)),_TTMemory(V(0x13),NotSame,V(0x14))
,Bring(P1,Exactly,0,"Terran SCV","Anywhere")})},
{DisplayText("TTOR조건만족2",4)},1)
------------------------------------------------------------------------------------------

316

------------------------------------------------------------------------------------------

『 17장 : 특수 조건 관련 함수 (TT) 』

-----------------------------------------------------------------------------------------[예제 17-2] TTAND()
CTrigger(P1,{TTOR({TTAND({Accumulate(P1,AtLeast,5,Ore),
_TTAccumulate(P1,Below,10,Ore)}),_TTAccumulate(P1,NotSame,0,Gas)})},
{DisplayText("TTORAND")},{Preserved})
-- 5 ≤ Ore ＜ 10 OR Gas ≠ 0일때 메세지 출력
------------------------------------------------------------------------------------------

317

------------------------------------------------------------------------------------------

『 17장 : 특수 조건 관련 함수 (TT) 』

-----------------------------------------------------------------------------------------[예제 17-3] TTMemoryX(), TTMemory()
CJump(AllPlayers,0)
Include_CtrigPlib(720,"Switch 1",1)

CVariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12) CVariable(P1,0x13) CVariable(P1,0x14)
A1 = CArray(P1,1000) VA1 = CVArray(P1,10) VA2 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x30,"X","X",2) j = 0x30 CVariable2(P1,0x40,"X","X",3)
k = 0x40 CVariable2(P1,0x50,"X","X",4) l = 0x50 CVariable2(P1,0x60,"X","X",5) m = 0x60

for i = 0x100, 0x105 do CVariable(P1,i) end
CJumpEnd(AllPlayers,0)

CMov(P1,0x58F500,1234)
CTrigger({P1},
{TTMemoryX(0x58F500,"!=",1234,0xFFFFFFFF)}, -- Memory(0x58F500,Exactly,1234);
{SetMemory(0x58F450,SetTo,1)},1)
CMov(P1,V(0x10),1234)
CTrigger({P1},
{TTMemoryX(_Mem(V(0x10)),"!=",1234,0xFFFFFFFF)}, -- Memory(V(0x10)의 값(=0x58F504),Exactly,1234);
{SetMemory(0x58F454,SetTo,1)},1)
CMov(P1,V(0x10),EPD(0x58F504))
CMov(P1,0x58F504,1234)
CTrigger({P1},
{TTMemoryX(V(0x10),"!=",1234,0xFFFFFFFF)}, -- Memory(V(0x10)의 주소,Exactly,1234);
{SetMemory(0x58F458,SetTo,1)},1)
CMov(P1,Arr(A1,0),1234)
CTrigger({P1},
{TTMemoryX(Arr(A1,0),"!=",1234,0xFFFFFFFF)}, -- Memory(A1[0]의 주소,Exactly,1234);
{SetMemory(0x58F45C,SetTo,1)},1)
CMov(P1,Arr(A1,V(i)),1234)
CTrigger({P1},
{TTMemoryX(_TMem(Arr(A1,V(i))),"!=",1234,0xFFFFFFFF)}, -- Memory(A1[i]의 주소,Exactly,1234);
{SetMemory(0x58F460,SetTo,1)},1)
CMov(P1,VArr(VA1,V(i)),EPD(0x58F508))
CMov(P1,0x58F508,1234)
CTrigger({P1},
{TTMemoryX(VArr(VA1,V(i)),"!=",1234,0xFFFFFFFF)}, -- Memory(VA1[i]의 값(=0x58F508),Exactly,1234);
{SetMemory(0x58F464,SetTo,1)},1)
CMov(P1,VArr(VA1,V(i)),1234)
CTrigger({P1},
{TTMemoryX(_TMem(VArr(VA1,V(i))),"!=",1234,0xFFFFFFFF)}, -- Memory(VA1[i]의 주소,Exactly,1234);
{SetMemory(0x58F468,SetTo,1)},1)
CMov(P1,V(0x10),EPD(0x58F50C))
CMov(P1,0x58F50C,EPD(0x58F50C))
CTrigger({P1},
{TTMemoryX(V(0x10),"!=",V(0x10),0xFFFFFFFF)}, -- Memory(V(0x10)의 값(=0x58F504),Exactly,V(0x10)의 값);
{SetMemory(0x58F46C,SetTo,1)},1)
CMov(P1,VArr(VA1,V(i)),EPD(0x58F510))
CMov(P1,0x58F510,EPD(0x58F510))
CTrigger({P1},
{TTMemoryX(VArr(VA1,V(i)),"!=",VArr(VA1,V(i)),0xFFFFFFFF)},
-- Memory(VA1[i]의 값(=0x58F508),Exactly,VA1[i]의 값);
{SetMemory(0x58F470,SetTo,1)},1)

------------------------------------------------------------------------------------------

318

------------------------------------------------------------------------------------------

『 17장 : 특수 조건 관련 함수 (TT) 』

-----------------------------------------------------------------------------------------[예제 17-4] TTCommand(), TCreateUnit(), TKillUnitAt()
CJump(AllPlayers,0)
Include_CtrigPlib(720,"Switch 1",1)

CVariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12) CVariable(P1,0x13) CVariable(P1,0x14)
A1 = CArray(P1,1000) VA1 = CVArray(P1,10) VA2 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x30,"X","X",2) j = 0x30 CVariable2(P1,0x40,"X","X",3)
k = 0x40 CVariable2(P1,0x50,"X","X",4) l = 0x50 CVariable2(P1,0x60,"X","X",5) m = 0x60

for i = 0x100, 0x105 do
CVariable(P1,i)
end
CJumpEnd(AllPlayers,0)

CMov(P1,V(0x10),4)
CReadX(P1,V(0x11),0x57f0f0,0,"X",0x01000000)
for i = 0, 15 do
local UnitTable = {0,1,2,3,5,7,8,9,11,12,13,15,30,32,34,16}
CMov(P1,VArr(VA1,i),UnitTable[i+1])
-- VA1 = {0,1,2,3,5,7,8,9,11,12,13,15,30,32,34,16}
end
CMov(P1,V(i),_Mod(_Rand(),16))
CMovX(P1,0x58F450,VArr(VA1,V(i)))
CTrigger({P1},
{TTCommand(P1,">",V(0x10),"Protoss Dragoon")},
-- P1 드라군이 V(0x10)(=4)마리 초과일때
{TCreateUnit(_Add(_Div(V(0x11),2),1*0x01000000),VArr(VA1,V(i)),"CLoc",P2),
-- P2의 UnitId:VA1[0~9(랜덤)] 유닛을 (미네랄양/2)+1 마리 소환
TKillUnitAt(_Mul(V(0x10),0x01000000),"Protoss Dragoon","Anywhere",P1)},1)
-- P1 드라군 V(0x10)(=4)마리 킬
------------------------------------------------------------------------------------------

319

------------------------------------------------------------------------------------------

『 17장 : 특수 조건 관련 함수 (TT) 』

-----------------------------------------------------------------------------------------[예제 17-5] TTMemory()
CTrigger(P1,{TTMemory(0x57F0F0,iAbove,_Read(0x57F120))},{DisplayText("\x1FiAbove 조건 만족")},{Preserved})
CTrigger(P1,{TTMemory(0x57F0F0,iAtLeast,_Read(0x57F120))},{DisplayText("\x07iAtLeast 조건 만족")},{Preserved})
CTrigger(P1,{TTMemory(0x57F0F0,iAtMost,_Read(0x57F120))},{DisplayText("\x11iAtMost 조건 만족")},{Preserved})
CTrigger(P1,{TTMemory(0x57F0F0,iBelow,_Read(0x57F120))},{DisplayText("\x08iBelow 조건 만족")},{Preserved})

------------------------------------------------------------------------------------------

320

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------[예제 18-1] NoAirCollisionX(), MemoryB(), SetMemoryW(), SetLoc()
CJump(AllPlayers,0)
Include_DataTransfer()
CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)
Trigger {

}
Trigger {

}

players = {P1},
conditions = {
MemoryB(0x57f0f1,Exactly,1);
},
actions = {
SetMemoryW(0x57f0f2,SetTo,2);
PreserveTrigger();
}

players = {P1},
conditions = {
MemoryB(0x57f120,Exactly,1);
},
actions = {
SetLoc("CLoc","L",Add,1);
SetLoc("CLoc","R",Add,1);
PreserveTrigger();
}

DoActions(P1,{CreateUnit(1,"Kakaru (Twilight)","CLoc",P1),KillUnit("Kakaru (Twilight)",P1)})
------------------------------------------------------------------------------------------

321

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------[예제 18-2] Enable_PlayerCheck(), PlayerCheck()
Enable_PlayerCheck()
CJump(AllPlayers,0)
CJumpEnd(AllPlayers,0)
CIfX(P1,PlayerCheck(P1,1))
DoActions(P1,{DisplayText("P1 존재",4)})
CElseX()
DoActions(P1,{DisplayText("P1 없음",4)})
CIfXEnd()
CIfX(P1,PlayerCheck(P2,1))
DoActions(P1,{DisplayText("P2 존재",4)})
CElseX()
DoActions(P1,{DisplayText("P2 없음",4)})
CIfXEnd()
CIfX(P1,PlayerCheck(P3,1))
DoActions(P1,{DisplayText("P3 존재",4)})
CElseX()
DoActions(P1,{DisplayText("P3 없음",4)})
CIfXEnd()
CIfX(P1,PlayerCheck(P4,1))
DoActions(P1,{DisplayText("P4 존재",4)})
CElseX()
DoActions(P1,{DisplayText("P4 없음",4)})
CIfXEnd()
Trigger {players = {P1},
conditions = {Accumulate(P1,Exactly,1,Ore);
},
actions = {SetCp(2); Defeat(); SetCp(0);
}
}
Trigger {players = {P1},
conditions = {Accumulate(P1,Exactly,1,Gas);
},
actions = {SetCp(3); Defeat(); SetCp(0);
}
}
-----------------------------------------------------------------------------------------322

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------[예제 18-3] SetPlayerColor(), SetMinimapColor(), PlayerColor(), MinimapColor(),

LocalPlayerID(), Speed(), SetSpeed(), UnixTime()
Trigger {

players = {P1},
conditions = {
},
actions = {

}
Trigger {

}
players = {P1},
conditions = {
},
actions = {

}

DoActions(P1,{

})
Trigger {

}

DisplayText("\x08해당 플레이어는 P1 입니다.");

LocalPlayerID("Ob1",AtLeast);
LocalPlayerID("Ob4",AtMost);
DisplayText("\x05해당 플레이어는 관전자 입니다.");

SetPlayerColor(P1,SetTo,0xD),SetMinimapColor(P1,SetTo,0xD),
SetPlayerColor(P2,SetTo,0xE),SetMinimapColor(P2,SetTo,0xE),
SetPlayerColor(P3,SetTo,0xF),SetMinimapColor(P3,SetTo,0xF),
SetPlayerColor(P4,SetTo,0x0),SetMinimapColor(P4,SetTo,0x0),

players = {P1},
conditions = {
},
actions = {

}

LocalPlayerID(0);

}

PlayerColor(P1,Exactly,0xD);
MinimapColor(P1,Exactly,0xD);
DisplayText("P1 컬러 = 0xD");
PreserveTrigger();

DoActions(P1,SetSpeed(SetTo,"#X0"))
Trigger {

players = {P1},
conditions = {
},
actions = {

}
Trigger {

}
players = {P1},
conditions = {
},
actions = {

}
Trigger {

}
players = {P1},
conditions = {
},
actions = {

}
Trigger {

}

players = {P1},
conditions = {
},
actions = {

}
Trigger {

}
players = {P1},
conditions = {
},
actions = {

}
Trigger {

}
players = {P1},
conditions = {
},
actions = {

}

}

Accumulate(P1,Exactly,1,Ore);

SetSpeed(SetTo,"#X1");
PreserveTrigger();

Accumulate(P1,Exactly,-1,Ore);
SetSpeed(SetTo,"#X2");
PreserveTrigger();

Speed(Exactly,"#X1");
DisplayText("\x02 현재 속도 : 1배속");
PreserveTrigger();

Speed(Exactly,"#X2");
DisplayText("\x03 현재 속도 : 2배속");
PreserveTrigger();

Speed(Exactly,"#X0");
DisplayText("\x04 현재 속도 : 노배속");
PreserveTrigger();

UnixTime(AtLeast,{year = 2021, month = 7, day = 24, hour = 10, min = 36, sec = 12})

DisplayText("\x05 2021/07/24 10:36:12 초과");
PreserveTrigger();

------------------------------------------------------------------------------------------

323

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------[예제 18-4] f_SHRead(), _SHRead(), KtoA(), SetKills(), TSetKills()
f_SHRead(P1,0x57F0F0,0x58F450)
f_SHRead(P1,_Mov(EPD(0x57F120)),0x58F454)
CMov(P1,0x58F458,_SHRead(0x57F0F0))
CMov(P1,0x58F45C,_SHRead(_Mov(EPD(0x57F120))))
TriggerX(P1,Kills(P1,AtLeast,1,"Terran SCV"),{DisplayText("SCV킬 인식됨"),SetKills(P1,Subtract,1,"Terran SCV")},{Preserved})
TriggerX(P1,Kills(P1,AtLeast,1,"Buildings"),{DisplayText("건물킬 인식됨"),SetKills(P1,Subtract,1,"Buildings")},{Preserved})
TriggerX(P1,Kills(P1,AtLeast,1,"Any unit"),{DisplayText("유닛킬 인식됨"),SetKills(P1,Subtract,1,"Any unit")},{Preserved})
TriggerX(P1,Kills(P1,AtLeast,1,"Factories"),{DisplayText("생산 건물킬 인식됨"),SetKills(P1,Subtract,1,"Factories")},{Preserved})

CTrigger(P1,{Memory(0x58F480,Exactly,1)},{TSetKills(_Mov(0),Add,_Mov(2),7)},{Preserved})
CTrigger(P1,{Memory(0x58F480,Exactly,2)},{TSetKills(_Mov(0),Add,_Mov(2),229)},{Preserved})
CRead(P1,0x58F460,KtoA(P1,"Terran SCV"))
CRead(P1,0x58F464,KtoA(P1,229))

-----------------------------------------------------------------------------------------[예제 18-5] TBwrite(), TBread(), TTBread(), TWwrite(), TWread(), TTWread(),
TSetMemoryDw(), TSetMemoryW(), TSetMemoryB()
X, Y = CreateVars(2,P1)
Z = CreateVarArr(4,P1)
CRead(P1,X,0x57F0F0)
CRead(P1,Y,0x57F120)
DoActionsX(P1,{SetNVar(Z[1],SetTo,0x57F0F0),SetNVar(Z[2],SetTo,0x57F0F1),SetNVar(Z[3],SetTo,0x57F0F2),SetNVar(Z[4],SetTo,0x57F0F3)})
CDoActions(P1,{
TBwrite(0x58F450,SetTo,X);
TBwrite(0x58F451,SetTo,X);
TBwrite(0x58F452,SetTo,X);
TBwrite(0x58F453,SetTo,X);
TWwrite(0x58F454,SetTo,X);
TWwrite(0x58F456,SetTo,X);
})
CTrigger(P1,{Memory(0x58F480,Exactly,0),TBread(Z[1],Exactly,Y)},{DisplayText("\x0FOre == Gas 만족 (+0)")},{Preserved})
CTrigger(P1,{Memory(0x58F480,Exactly,0),TTBread(Z[1],NotSame,Y)},{DisplayText("\x11Ore == Gas 불만족 (+0)")},{Preserved})
CTrigger(P1,{Memory(0x58F480,Exactly,0),TBread(Z[2],Exactly,Y)},{DisplayText("\x1FOre == Gas 만족 (+1)")},{Preserved})
CTrigger(P1,{Memory(0x58F480,Exactly,0),TTBread(Z[2],NotSame,Y)},{DisplayText("\x08Ore == Gas 불만족 (+1)")},{Preserved})
CTrigger(P1,{Memory(0x58F480,Exactly,0),TBread(Z[3],Exactly,Y)},{DisplayText("\x1COre == Gas 만족 (+2)")},{Preserved})
CTrigger(P1,{Memory(0x58F480,Exactly,0),TTBread(Z[3],NotSame,Y)},{DisplayText("\x06Ore == Gas 불만족 (+2)")},{Preserved})
CTrigger(P1,{Memory(0x58F480,Exactly,0),TBread(Z[4],Exactly,Y)},{DisplayText("\x0EOre == Gas 만족 (+3)")},{Preserved})
CTrigger(P1,{Memory(0x58F480,Exactly,0),TTBread(Z[4],NotSame,Y)},{DisplayText("\x10Ore == Gas 불만족 (+3)")},{Preserved})
CTrigger(P1,{Memory(0x58F480,Exactly,1),TWread(Z[1],Exactly,Y)},{DisplayText("\x07Ore == Gas 만족 (+0~+1)")},{Preserved})
CTrigger(P1,{Memory(0x58F480,Exactly,1),TTWread(Z[1],NotSame,Y)},{DisplayText("\x17Ore == Gas 불만족 (+0~+1)")},{Preserved})
CTrigger(P1,{Memory(0x58F480,Exactly,1),TWread(Z[3],Exactly,Y)},{DisplayText("\x18Ore == Gas 만족 (+2~+3)")},{Preserved})
CTrigger(P1,{Memory(0x58F480,Exactly,1),TTWread(Z[3],NotSame,Y)},{DisplayText("\x15Ore == Gas 불만족 (+2~+3)")},{Preserved})
CTrigger(P1,{Memory(0x58F480,Exactly,2)},{TSetMemoryDw(0x662350,54,SetTo,Y),TSetMemoryDW(0x662350,X,SetTo,Y)},{Preserved}) -- 최대체력
CTrigger(P1,{Memory(0x58F480,Exactly,3)},{TSetMemoryW(0x656EB0,36,SetTo,Y),TSetMemoryW(0x656EB0,X,SetTo,Y)},{Preserved}) -- 공격력
CTrigger(P1,{Memory(0x58F480,Exactly,4)},{TSetMemoryB(0x6636B8,54,SetTo,Y),TSetMemoryB(0x6636B8,X,SetTo,Y)},{Preserved}) -- 무기

------------------------------------------------------------------------------------------

324

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------[예제 18-6] Timer(), TimerX(), Stage(), VisionTurbo()
X, Y = CreateVars(2,P1)
Timer(P1,0x58F450,nil,0,0x40,1,"SR")
Timer(P1,X,-0x100,-0x10,0x20,2,"RS")
CC = Timer(P1,nil,nil,0x11,-0x10,-1,"RS")
Ca = Timer(P1,nil,0,3,0,-1,"RS",nil,nil,nil,{Never()}) -- 3틱당 1씩 증가
Timer(P1,0x58F45C,nil,0,0x10,1,"SR",nil,{CDeaths("X",Exactly,0,Ca)},{SetCDeaths("X",SetTo,3,Ca)})
Cb1 = CreateCcode()
Cb2 = Timer(P1,nil,0,4,0,-1,"SR",nil,nil,nil,{Never()}) -- 4틱당 1씩 증가

Timer(P1,0x58F460,nil,-0x10,0x10,1,"SR",nil,{CDeaths("X",Exactly,0,Cb2),CDeaths("X",Exactly,0,Cb1)},{SetCDeaths("X",SetTo,4,Cb2)})
Timer(P1,_Ccode("X",Cb1),0,101,0,-1,"RS",nil,nil,nil,{Memory(0x58F460,Exactly,0),CDeaths("X",Exactly,0,Cb1)}) -- 0에서 100틱 멈추고 다시 진행

Cd1, Cd3 = CreateCcodes(2)
Cd2 = Timer(P1,nil,0,5,0,-1,"SR",nil,nil,nil,{Never()}) -- 5틱당 1씩 증가

Timer(P1,_Ccode("X",Cd3),3,0,5,1,"SR",nil,{Never()},nil,{Switch("Switch 2",Set)},{SetSwitch("Switch 2",Clear)}) -- 정지 주기 카운트 (3틱시작, 5틱발동)
Timer(P1,0x58F468,nil,0,50,1,"SR",nil,{CDeaths("X",Exactly,0,Cd2),CDeaths("X",Exactly,0,Cd1)},{SetCDeaths("X",SetTo,5,Cd2),SetCDeaths("X",Add,1,Cd3)})
Timer(P1,_Ccode("X",Cd1),0,25,0,-1,"RS",nil,nil,nil,{CDeaths("X",Exactly,0,Cd3),CDeaths("X",Exactly,0,Cd1)}) -- 주기마다 24틱씩 정지

TriggerX(P1,{CDeaths("X",AtLeast,5,Cd3)},{SetSwitch("Switch 2",Set)},{Preserved})
Ce2 = Timer(P1,nil,0,6,0,-1,"RS",nil,nil,nil,{Never()}) -- 6틱당 1씩 증가

Ce1 = TimerX(P1,0x58F474,nil,nil,0,14,1,{11,7},"SR",nil,nil,nil,{CDeaths("X",Exactly,0,Ce2)},{SetCDeaths("X",SetTo,6,Ce2)})

CWhile(P1,{CDeaths("X",Exactly,6,Ce2),CDeaths("X",AtLeast,1,Ce1[2])},{SetCDeaths("X",Subtract,1,Ce1[2])})
DoActions(P1,{CreateUnit(1,"Mojo (Scout)","CLoc2",P1)})
CWhileEnd()
DoActions(P1,KillUnitAt(All,"Mojo (Scout)","CLoc2",P1))
Cf = Timer(P1,nil,0,0,0,-1,"RS",nil,nil,nil,{Never()})
UnitArr = {0,1,2,3,7,8,9,10,11}
TRIGArr = {}
for i = 0, 8 do
table.insert(TRIGArr,{i,{CreateUnit(i,UnitArr[i+1],"CLoc",P1),SetCDeaths("X",SetTo,6*(i+1),Cf)
,SetNVar(Y,Add,1)},{CDeaths("X",Exactly,0,Cf)},{Preserved}})
end
table.insert(TRIGArr,{9,{KillUnitAt(All,"Men","CLoc",P1),SetNVar(Y,SetTo,0)},nil,{Preserved}})
Stage(P1,Y,TRIGArr)
VisionTurbo(P1)
CMov(P1,0x58F454,X)
CRead(P1,0x58F458,_Ccode(P1,CC))
CRead(P1,0x58F464,_Ccode(P1,Cb1))
CRead(P1,0x58F46C,_Ccode(P1,Cd1))
CRead(P1,0x58F470,_Ccode(P1,Cd3))
CMov(P1,0x58F478,Y)
CRead(P1,0x58F47C,_Ccode(P1,Cf))

------------------------------------------------------------------------------------------

325

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------[예제 18-7] SaveValueMsg(), ExitDrop(), CMotion(), FindSD()
SaveValueMsg("CtrigAsm 예제 18-7 : "..FuncAlloc,"Testest.txt")
X = CreateVar(P1)
FindSD(P1,P1,"CLoc2",0x58F450,0)
FindSD(P1,P1,"CLoc2",X,1)
CMov(P1,0x58F454,X)
CIf(P1,NVar(X,Exactly,0))
ExitDrop(P1,P1)
CIfEnd()
CIf(P1,Memory(0x57F0F0,AtLeast,1))
ExitDrop(P1,"Ob1")
ExitDrop(P1,"Ob2")
ExitDrop(P1,"Ob3")
ExitDrop(P1,"Ob4")
CIfEnd()
Y = CreateVarArr(4,P1)
DoActions(P1,SetMemory(0x58F464,SetTo,1),{})
CIf(P1,Memory(0x57F120,Exactly,1),SetMemory(0x57F120,SetTo,0))
CRead(P1,Y[1],0x58F458)
CRead(P1,Y[2],0x58F45C)
CRead(P1,Y[3],0x58F460)
CRead(P1,Y[4],0x58F464)
CIfEnd()
CMotion(P1,Y[1],Y[2],Y[3],Y[4])
CMov(P1,0x58F468,Y[1])
CMov(P1,0x58F46C,Y[2])
CMov(P1,0x58F470,Y[3])

------------------------------------------------------------------------------------------

326

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------[예제 18-8] IBGM_EPD(), IBGM_EPDX(), NPA5()
CJump(P1,0)
FA1 = f_GetFileptr(P1,"stat_txt_kor_kor.tbl",1) -- 제작했던 아무 TBL이나 AbsolutePath에 넣고 로드
FA1s = f_GetFileSize("stat_txt_kor_kor.tbl") -- 예제에 사용된 tbl은 뎡디터2의 Data폴더에서 가져옴
CJumpEnd(P1,0)
CIfOnce(P1)
NPA5(P1,0x6D5A30,FArr(FA1,0),FA1s) -- 위에서 로드한 TBL파일을 TBL주소에 복사함
CIfEnd()
X = CreateVar(P1)
CIf(P1,Memory(0x57F120,AtLeast,1),SetMemory(0x57F120,SetTo,0))
CRead(P1,X,0x57F0F0)
CIfEnd()
CIfX(P1,Memory(0x58F480,Exactly,0))
IBGM_EPD(P1,{P1,Force5},X,{
{1,"sound\\Terran\\TANK\\TTaPss00.WAV",3200},
{2,"sound\\Terran\\TANK\\TTaPss01.WAV",1700},
{3,"sound\\Terran\\TANK\\TTaPss02.WAV",2700},
{4,"sound\\Terran\\TANK\\TTaPss03.WAV",2100},
},"sound\\glue\\bnetclick.wav")
CElseIfX(Memory(0x58F480,Exactly,1))
IBGM_EPDX(P1,{P1,Force5},X,{
{1,"sound\\Terran\\TANK\\TTaPss00.WAV",3200},
{2,"sound\\Terran\\TANK\\TTaPss01.WAV",1700},
{3,"sound\\Terran\\TANK\\TTaPss02.WAV",2700},
{4,"sound\\Terran\\TANK\\TTaPss03.WAV",2100},
},"sound\\glue\\bnetclick.wav")
CIfXEnd()

-----------------------------------------------------------------------------------------[예제 18-9] f_CGive(), IsTyping(), NotTyping(), KeyPress(), TTKeyPress(), MousePress(), TTMousePress()
Nextptr, NextEPD = CreateVars(2,P1)
f_Read(P1,0x6284B8,Nextptr,NextEPD)
CIf(P1,{TTKeyPress("D","Down"),NVar(Nextptr,AtLeast,1)})
CIfX(P1,{TMemoryX(Vi(NextEPD[2],19),Exactly,0,0xFF)},DisplayText("\x08빨강유닛 CGive"))
f_CGive(P1,nil,Nextptr,_Read(0x57F0F0),P1)
CElseX(DisplayText("\x1C컴퓨터유닛 CGive"))
f_CGive(P1,NextEPD,nil,_Read(0x57F0F0))
CIfXEnd()
CIfEnd()
TriggerX(P1,{Memory(0x57F120,Exactly,1),IsTyping()},{DisplayText("\x0E채팅중임")},{Preserved})
TriggerX(P1,{Memory(0x57F120,Exactly,1),NotTyping()},{DisplayText("\x10채팅중 아님")},{Preserved})
TriggerX(P1,{Memory(0x57F120,Exactly,2),KeyPress("A","Down")},{DisplayText("\x1FA키 누름")},{Preserved})
TriggerX(P1,{Memory(0x57F120,Exactly,2),KeyPress("A","Up")},{DisplayText("\x08A키 땜")},{Preserved})
CTrigger(P1,{Memory(0x57F120,Exactly,3),TTKeyPress("S","Down")},{DisplayText("\x0FS키 누름(1회)")},{Preserved})
CTrigger(P1,{Memory(0x57F120,Exactly,3),TTKeyPress("S","Up")},{DisplayText("\x06S키 땜(1회)")},{Preserved})
TriggerX(P1,{Memory(0x57F120,Exactly,4),MousePress("L","Down")},{DisplayText("\x07마우스 왼쪽버튼 누름")},{Preserved})
TriggerX(P1,{Memory(0x57F120,Exactly,4),MousePress("L","Up")},{DisplayText("\x11마우스 왼쪽버튼 땜")},{Preserved})
CTrigger(P1,{Memory(0x57F120,Exactly,5),TTMousePress("R","Down")},{DisplayText("\x17마우스 오른쪽버튼 누름(1회)")},{Preserved})
CTrigger(P1,{Memory(0x57F120,Exactly,5),TTMousePress("R","Up")},{DisplayText("\x15마우스 오른쪽버튼 땜(1회)")},{Preserved})

------------------------------------------------------------------------------------------

327

------------------------------------------------------------------------------------------

『 18장 : 기타 편의기능 관련 함수 』

-----------------------------------------------------------------------------------------[예제 18-10] f_OffsetToAlphaID(), f_EPDToAlphaID(), f_AlphaIDToCunit(),

_HotKeyUnit(), HotkeyUnit(), TSetHotKeyUnit()
Nextptr, NextEPD, AlphaID = CreateVars(3,P1)
f_Read(P1,0x6284B8,Nextptr,NextEPD)
CIf(P1,{NVar(Nextptr,AtLeast,1),Memory(0x57F0F0,AtLeast,1)})
CMov(P1,0x58F450,Nextptr) CMov(P1,0x58F454,NextEPD)
f_OffsetToAlphaID(P1,Nextptr,AlphaID)
CMov(P1,0x58F458,AlphaID)
f_EPDToAlphaID(P1,NextEPD,AlphaID)
CIfEnd()

CMov(P1,0x58F45C,AlphaID) -- 부대지정 빈칸은 0으로 채워짐
f_AlphaIDToCunit(P1,AlphaID,0x58F460,0x58F464)
CRead(P1,0x58F468,_HotKeyUnit(P1,1,0)) -- 1번키 부대지정 했을경우
CTrigger(P1,{HotkeyUnit(P1,1,0,AtLeast,1)},{TSetHotkeyUnit(P1,_Mov(1),_Mov(1),SetTo,AlphaID)},{Preserved})
CRead(P1,0x58F46C,_HotKeyUnit(P1,1,1)) -- 1번키 부대지정 추가

-----------------------------------------------------------------------------------------[예제 18-11] f_Bread(), f_BreadX(), f_Wread(), f_WreadX()
X = CreateVar(P1)
CRead(P1,X,0x57F0F0)
f_Bread(P1,0x58F450,0x58F480)
f_Bread(P1,0x58F450,0x58F484,"+1")
f_Bread(P1,0x58F450,0x58F488,"+2")
f_Bread(P1,0x58F450,0x58F48C,"+3")
f_Bread(P1,_Add(X,0x58F450),0x58F490)
f_Bread(P1,_Add(X,0x58F450),0x58F494,"+1")
f_Bread(P1,_Add(X,0x58F450),0x58F498,"+2")
f_Bread(P1,_Add(X,0x58F450),0x58F49C,"+3")
f_Wread(P1,0x58F450,0x58F4A0)
f_Wread(P1,0x58F450,0x58F4A4,"+1")
f_Wread(P1,_Add(X,0x58F450),0x58F4A8)
f_Wread(P1,_Add(X,0x58F450),0x58F4AC,"+1")
f_BreadX(P1,0x663150,4,0x58F4B0) -- 유닛의 높이
f_BreadX(P1,0x663150,22,0x58F4B4,"+1") -- 유닛의 높이
f_BreadX(P1,0x663150,6,0x58F4B8,"+2") -- 유닛의 높이
f_BreadX(P1,0x663150,33,0x58F4BC,"+3") -- 유닛의 높이
f_BreadX(P1,0x663150,X,0x58F4C0)
f_BreadX(P1,0x663150,X,0x58F4C4,"+1")
f_BreadX(P1,0x663150,X,0x58F4C8,"+2")
f_BreadX(P1,0x663150,X,0x58F4CC,"+3")
f_WreadX(P1,0x656EB0,0,0x58F4D0) -- 무기의 공격력
f_WreadX(P1,0x656EB0,3,0x58F4D4) -- 무기의 공격력
f_WreadX(P1,0x656EB0,X,0x58F4D8)
f_WreadX(P1,0x656EB0,X,0x58F4DC,"+1")

------------------------------------------------------------------------------------------

328

------------------------------------------------------------------------------------------

『 19장 : 기타 스트링 관련 함수 』

-----------------------------------------------------------------------------------------[예제 19-1] f_GetStrptr(), Print_String(), Print_13()
CJump(AllPlayers,0)
Include_CtrigPlib(720,"Switch 1",1)

CVariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12) CVariable(P1,0x13) CVariable(P1,0x14)
A1 = CArray(P1,1000) VA1 = CVArray(P1,16) VA2 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x30,"X","X",2) j = 0x30 CVariable2(P1,0x40,"X","X",3)
k = 0x40 CVariable2(P1,0x50,"X","X",4) l = 0x50 CVariable2(P1,0x60,"X","X",5) m = 0x60
for i = 0x100, 0x105 do CVariable(P1,i) end

CJumpEnd(AllPlayers,0) -- \x0D = 빈칸(공간차지 X)

f_GetStrptr(P1,V(0x10),"
")
print_String(P1,_EPD(V(0x10)),"\x04Print_String \x05TEXT",3)
print_13(P1,{P1},"\x1FPrint_13 \x07TEXT")
DoActions(P1,DisplayText("
",4))
-----------------------------------------------------------------------------------------[예제 19-2] GetPlayerName(), ItoName(), f_Movcpy()
\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D

\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D

CJump(AllPlayers,0)
Include_CtrigPlib(720,"Switch 1",1)

CVariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12) CVariable(P1,0x13) CVariable(P1,0x14)
A1 = CArray(P1,1000) VA1 = CVArray(P1,16) VA2 = CVArray(P1,16)
CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x30,"X","X",2) j = 0x30 CVariable2(P1,0x40,"X","X",3)
k = 0x40 CVariable2(P1,0x50,"X","X",4) l = 0x50 CVariable2(P1,0x60,"X","X",5) m = 0x60
for i = 0x100, 0x105 do CVariable(P1,i) end

CJumpEnd(AllPlayers,0) -- \x0D = 빈칸(공간차지 X)

f_GetStrptr(P1,V(0x10),"
")
GetPlayerName(P1,P1,VArr(VA1,0),3)
ItoName(P1,P2,VArr(VA2,0),0x1F)
print_13(P1,{P1},"
")
f_Movcpy(P1,V(0x10),VArr(VA1,0),16)
f_Movcpy(P1,0x641598,VArr(VA2,0),16)
DoActions(P1,DisplayText("
",4))
-----------------------------------------------------------------------------------------\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D

\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D

\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D

329

------------------------------------------------------------------------------------------

『 19장 : 기타 스트링 관련 함수 』

-----------------------------------------------------------------------------------------[예제 19-3] ItoDec() ,ItoDecX(), f_Movcpy()
CJump(AllPlayers,0)
Include_CtrigPlib(720,"Switch 1",1)

CVariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12) CVariable(P1,0x13) CVariable(P1,0x14)
A1 = CArray(P1,1000) VA1 = CVArray(P1,16) VA2 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x30,"X","X",2) j = 0x30 CVariable2(P1,0x40,"X","X",3)
k = 0x40 CVariable2(P1,0x50,"X","X",4) l = 0x50 CVariable2(P1,0x60,"X","X",5) m = 0x60
for i = 0x100, 0x105 do CVariable(P1,i) end

CJumpEnd(AllPlayers,0) -- \x0D = 빈칸(공간차지 X)

f_GetStrptr(P1,V(0x10),"
")
ItoDec(P1,_Read(0x57f0f0),VArr(VA1,0),1,0x1F,1)
ItoDecX(P1,_Read(0x57F120),VArr(VA2,0),2,{0x5,0x3,0x17,0x19,0x1D,0x16,0x4,0x2,0x1E,0x1C},0)
print_13(P1,{P1},"
")
f_Movcpy(P1,V(0x10),VArr(VA1,0),16)
f_Movcpy(P1,0x641598,VArr(VA2,0),48)
DoActions(P1,DisplayText("
",4))
-----------------------------------------------------------------------------------------[예제 19-4] ItoHex() ,ItoHexX(), f_Movcpy()
\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D

\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D

\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D

CJump(AllPlayers,0)
Include_CtrigPlib(720,"Switch 1",1)

CVariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12) CVariable(P1,0x13) CVariable(P1,0x14)
A1 = CArray(P1,1000) VA1 = CVArray(P1,16) VA2 = CVArray(P1,16)
CVariable2(P1,0x20,"X","X",1) i = 0x20 CVariable2(P1,0x30,"X","X",2) j = 0x30 CVariable2(P1,0x40,"X","X",3)
k = 0x40 CVariable2(P1,0x50,"X","X",4) l = 0x50 CVariable2(P1,0x60,"X","X",5) m = 0x60
for i = 0x100, 0x105 do CVariable(P1,i) end

CJumpEnd(AllPlayers,0) -- \x0D = 빈칸(공간차지 X)

f_GetStrptr(P1,V(0x10),"
")
ItoHex(P1,_Read(0x57f0f0),VArr(VA1,0),1,0x7,0)
ItoHexX(P1,_Read(0x57F120),VArr(VA2,0),0,{0x5,0x18,0x7,0x1D,0x16,0x4,0x1B,0x11},1)
print_13(P1,{P1},"
")
f_Movcpy(P1,V(0x10),VArr(VA1,0),12)
f_Movcpy(P1,0x641598,VArr(VA2,0),36)
DoActions(P1,DisplayText("
",4))
-----------------------------------------------------------------------------------------\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D

\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D

\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D

330

------------------------------------------------------------------------------------------

『 19장 : 기타 스트링 관련 함수 』

-----------------------------------------------------------------------------------------[예제 19-5] Print_StringX(), GetStrSize(), ItoX(), ItoDecX()
CJump(AllPlayers,0)
for i = 0x10, 0x70 do
CVariable(P1,i)
end
VA1 = GetVArray(V(0x10))
VA2 = GetVArray(V(0x40))
Include_DataTransfer(1)
Include_MiscFunctions("Switch 1")
CVariable2(P1,0x80,"X","X",0) i = 0x80
CJumpEnd(AllPlayers,0)
ItoName(P1,P1,VArr(VA1,0),0x4)
CMov(P1,VArr(VA2,0),0x0D0D0D0D) CMov(P1,VArr(VA2,7),0x0D0D0D0D)
CMov(P1,VArr(VA2,8),0x0D0D0D0D)
ItoX(P1,VArr(VA1,1),VArr(VA2,1),{0x1C,0x1F,0x7,0x17})
ItoX(P1,VArr(VA1,2),{VArr(VA2,5),VArr(VA2,6),"X","X"},{0x11,0x8,0x1B})
ItoX(P1,VArr(VA1,3),VArr(VA2,9))
ItoX(P1,VArr(VA1,4),VArr(VA2,13))
Str1 = f_GetStrptr(P1,V(0x70),

"PlayerNamePlayerNamePlayerNamePlayerNamePlayerName\x0D\x0D\x0D\x0D

Str1L = GetStrSize(1,Str1)
f_Movcpy(P1,V(0x70),VArr(VA2,0),4*13)

")

Print_StringX(P1,VArr(VA1,V(i))," \x04Ｏｒｅ：\x1F",3)
Str2L = GetStrSize(0," \x04Ｏｒｅ：\x1F")
f_Movcpy(P1,_Add(V(0x70),4*13),VArr(VA1,V(i)),Str2L+3) -- Size = Str2L + InitBytes
ItoDecX(P1,_Read(0x57f0f0),VArr(VA2,0),2,{0x5,0x1E,0x2,0x4},2)
f_Movcpy(P1,_Add(V(0x70),4*13+Str2L+3),VArr(VA2,0),4*12)
DoActions(P1,DisplayText(

"PlayerNamePlayerNamePlayerNamePlayerNamePlayerName\x0D\x0D\x0D\x0D

-- String 부분에 Str1 입력시 String 에러창 발생
------------------------------------------------------------------------------------------

",4))

331

------------------------------------------------------------------------------------------

『 19장 : 기타 스트링 관련 함수 』

-----------------------------------------------------------------------------------------[예제 19-6] GetHostPlayerID(), GetHostName(), GetHostLength(), ItoHost(),
PlayerName(), HostName()
X, Z, Strid = CreateVars(3,P1)
Y, W = CreateVArrs(2,5,P1)
GetHostPlayerID(P1,X)
GetHostName(P1,VArr(Y,0),0)
GetHostLength(P1,Z)
CMov(P1,0x58F450,X) CMov(P1,0x58F454,Z)
for i = 0, 4 do
CMov(P1,0x58F458+4*i,VArr(Y,i))
end
TriggerX(P1,{Memory(0x57F0F0,Exactly,1)},{DisplayText(MakeiStrVoid(20))},{Preserved})
f_GetStrXptr(P1,Strid,MakeiStrVoid(20))
ItoHost(P1,VArr(W,0),0x07)
for i = 0, 4 do
CMov(P1,0x58F46C+4*i,VArr(W,i))
end
f_Movcpy(P1,Strid,VArr(W,0),20)
-- 자신의 아이디를 입력
TriggerX(P1,{Memory(0x57F120,Exactly,1),PlayerName(P1,"•••••••••••")}
,{DisplayText("\x04 P1 ID : •••••••••••")},{Preserved})
TriggerX(P1,{Memory(0x57F120,Exactly,1),HostName("•••••••••••")}
,{DisplayText("\x1FHost ID : •••••••••••")},{Preserved})
------------------------------------------------------------------------------------------

332

------------------------------------------------------------------------------------------

『 20장 : CreateUnitShape.lua 함수 』

-----------------------------------------------------------------------------------------[예제 20-1] CreateUnitPolygon(), CreateUnitStar(), CreateUnitLineSafe(),
CreateUnitFlowerSafe()
CJump(AllPlayers,0)
Include_DataTransfer()
CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)
CIfOnce(P1)

DoActions(P1,{SetMemory(0x661940, SetTo, 65537),SetMemory(0x661944, SetTo, 65537)})
-- 스커지 크기 1x1

CreateUnitPolygon(P1,Always(),37,"Terran Ghost","CLoc",P1,1120,1520,1,128,32,30,6)
CreateUnitStar(P1,Always(),31,"Zerg Zergling","CLoc",P1,608,2016,1,64,80,126,5,144,0)
CreateUnitLineSafe(P1,Always(),11,"Protoss Dragoon","CLoc2",P1,1,64,48,45,1)
CreateUnitFlowerSafe(P1,Always(),72,"Zerg Scourge","CLoc3",P1,1,64,64,0,1,1,24,1,0,0,0)
CIfEnd()

------------------------------------------------------------------------------------------

333

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------[예제 21-1] CopyCpActions(), CopyCpActionsX()
Trigger {

}
Trigger {

}
Trigger {

players = {P1},
conditions = {
Accumulate(P1,Exactly,1,Ore);
},
actions = {
CopyCpAction({DisplayTextX("Display"),MinimapPing("HEAL")},EveryPlayers,0);
}, flag = {Preserved}

players = {P1},
conditions = {
Accumulate(P1,Exactly,-1,Ore);
},
actions = {
CopyCpAction({DisplayTextX("Display"),MinimapPing("HEAL")},AllPlayers);
SetCp(0);
}, flag = {Preserved}
players = {P1},
conditions = {
Accumulate(P1,Exactly,1,Gas);
},
actions = {

CopyCpAction({DisplayTextX({"P1","Ob1","Ob2","Ob3","Ob4"})},{P1,P10,P11,P12});
CopyCpAction({{"SetMemory",{0x58F450,0x58F454,0x58F458,0x58F45C,0x58F460}

}
Trigger {

,SetTo,{1,2,3,4,5}}},{P1,P9,P11,P12},0);
}, flag = {Preserved}
players = {P1},
conditions = {
Accumulate(P1,Exactly,-1,Gas);
},
actions = {

CopyCpActionX({DisplayTextX({"P1",nil,nil,nil,nil,nil,nil,nil,nil,"Ob2","Ob3","Ob4"})},{P1,P10,P11,P12});
CopyCpActionX({{"SetMemory",{0x58F450,nil,nil,nil,nil,nil,nil,nil,0x58F454,nil,0x58F45C,0x58F460}
,SetTo,{1,nil,nil,nil,nil,nil,nil,nil,2,nil,4,5}}},{P1,P9,P11,P12});

}

SetCp(0);
}, flag = {Preserved}

-----------------------------------------------------------------------------------------334

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------[예제 21-2] CreateVar(), CreateVar2(), CreateVars, CreateVarArr(),
CreateWar(), CreateWar2(), CreateWars, CreateWarArr(),
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CJumpEnd(AllPlayers,0)
A = CreateVar(P1)
CMov(P1,A,0x11111111)
CMov(P1,0x58F4E0,A)
B = CreateVar2(P1,0x58F4E4,SetTo,0x22222222)
CallVariableX(P1,B)
C, D = CreateVars(2,P1)
DoActionsX(P1,{SetCVar(C[1],C[2],SetTo,0x33333333),SetNVar(D,SetTo,0x44444444)})
f_MovcpyEPD(P1,EPD(0x58F4E8),C,8)
E = CreateVarArr(4,P1)
DoActionsX(P1,{SetCVar(E[1][1],E[1][2],SetTo,0x55555555),SetNVar(E[2],SetTo,0x66666666),
SetCtrig1X(E[3][1],E[3][2],0x15C,E[3][3],SetTo,0x77777777)})
CMov(P1,E[4],0x88888888)
f_MovcpyEPD(P1,EPD(0x58F4F0),E[1],16)
F = CreateWar(P1)
f_LMov(P1,F,"0x9999999999999999")
f_LMov(P1,0x58F480,F)
G = CreateWar2(P1,0x58F488,SetTo,"0xAAAAAAAAAAAAAAAA")
CallWariableX(P1,G)
H, I = CreateWars(2,P1)
DoActionsX(P1,{SetCWar(H[1],H[2],SetTo,"0xBBBBBBBBBBBBBBBB")
,SetNWar(I,SetTo,"0xCCCCCCCCCCCCCCCC")})
f_LMov(P1,0x58F490,H) f_LMov(P1,0x58F498,I)
J = CreateWarArr(4,P1)
DoActionsX(P1,{SetCWar(J[1][1],J[1][2],SetTo,"0xDDDDDDDDDDDDDDDD")
,SetNWar(J[2],SetTo,"0xEEEEEEEEEEEEEEEE"),
SetCtrig1X(J[3][1],J[3][2],0x15C,J[3][3],SetTo,0xFFFFFFFF)
,SetCtrig1X(J[3][1],J[3][2],0x19C,J[3][3],SetTo,0xFFFFFFFF)})
f_LMov(P1,J[4],"0x1234567890ABCDEF")
f_LMov(P1,0x58F4A0,J[1]) f_LMov(P1,0x58F4A8,J[2])
f_LMov(P1,0x58F4B0,J[3]) f_LMov(P1,0x58F4B8,J[4])
------------------------------------------------------------------------------------------

335

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------[예제 21-3] CreateVArr(), CreateVArrs, CreateVArrArr(),
CreateWArr(), CreateWArrs, CreateWArrArr(),
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CJumpEnd(AllPlayers,0)
A = CreateVArr(2,P1)
CMov(P1,VArr(A,0),0x11111111)
CMov(P1,VArr(A,1),0x11111111)
f_MovcpyEPD(P1,EPD(0x58F4D0),VArr(A,0),8)
B, C = CreateVArrs(2,2,P1)
DoActionsX(P1,{SetCVAar(VArr(B,0),SetTo,0x22222222),
SetCVAar(VArr(B,1),SetTo,0x22222222),
SetCVAar(VArr(C,0),SetTo,0x33333333),
SetCVAar(VArr(C,1),SetTo,0x33333333)})
f_MovcpyEPD(P1,EPD(0x58F4D8),VArr(B,0),8)
f_MovcpyEPD(P1,EPD(0x58F4E0),VArr(C,0),8)
D = CreateVArrArr(2,2,P1)
DoActionsX(P1,{SetCVAar(VArr(D[1],0),SetTo,0x44444444),
SetCVAar(VArr(D[1],1),SetTo,0x44444444),
SetCVAar(VArr(D[2],0),SetTo,0x44444444),
SetCVAar(VArr(D[2],1),SetTo,0x44444444)})
f_MovcpyEPD(P1,EPD(0x58F4F0),VArr(D[1],0),16)
E = CreateWArr(2,P1)
f_LMov(P1,WArr(E,0),"0x5555555555555555")
f_LMov(P1,WArr(E,1),"0x5555555555555555")
f_LMov(P1,0x58F480,WArr(E,0))
f_LMov(P1,0x58F488,WArr(E,1))
F, G = CreateWArrs(2,2,P1)
DoActionsX(P1,{SetCWAar(WArr(F,0),SetTo,"0x6666666666666666"),
SetCWAar(WArr(F,1),SetTo,"0x6666666666666666"),
SetCWAar(WArr(G,0),SetTo,"0x7777777777777777"),
SetCWAar(WArr(G,1),SetTo,"0x7777777777777777")})
f_LMov(P1,0x58F490,WArr(F,0)) f_LMov(P1,0x58F498,WArr(F,1))
f_LMov(P1,0x58F4A0,WArr(G,0)) f_LMov(P1,0x58F4A8,WArr(G,1))
H = CreateWArrArr(2,2,P1)
DoActionsX(P1,{SetCWAar(WArr(H[1],0),SetTo,"0x8888888888888888"),
SetCWAar(WArr(H[1],1),SetTo,"0x8888888888888888"),
SetCWAar(WArr(H[2],0),SetTo,"0x8888888888888888"),
SetCWAar(WArr(H[2],1),SetTo,"0x8888888888888888")})
f_LMov(P1,0x58F4B0,WArr(H[1],0)) f_LMov(P1,0x58F4B8,WArr(H[1],1))
f_LMov(P1,0x58F4C0,WArr(H[2],0)) f_LMov(P1,0x58F4C8,WArr(H[2],1))
------------------------------------------------------------------------------------------

336

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------[예제 21-4] CreateArr(), CreateArrs, CreateArrArr(),
CreateLArr(), CreateLArrs, CreateLArrArr(),
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CJumpEnd(AllPlayers,0)
A = CreateArr(1000,P1)
CMov(P1,Arr(A,0),0x11111111) CMov(P1,Arr(A,999),0x11111111)
f_Read(P1,Arr(A,0),0x58F4D0) f_Read(P1,Arr(A,999),0x58F4D4)
B, C = CreateArrs(2,1000,P1)
DoActionsX(P1,{SetMemX(Arr(B,0),SetTo,0x22222222),
SetMemX(Arr(B,999),SetTo,0x22222222),
SetMemX(Arr(C,0),SetTo,0x33333333),
SetMemX(Arr(C,999),SetTo,0x33333333)})
f_Read(P1,Arr(B,0),0x58F4D8) f_Read(P1,Arr(B,999),0x58F4DC)
f_Read(P1,Arr(C,0),0x58F4E0) f_Read(P1,Arr(C,999),0x58F4E4)
D = CreateArrArr(2,1000,P1)
DoActionsX(P1,{SetMemX(Arr(D[1],0),SetTo,0x44444444),
SetMemX(Arr(D[1],999),SetTo,0x44444444),
SetMemX(Arr(D[2],0),SetTo,0x44444444),
SetMemX(Arr(D[2],999),SetTo,0x44444444)})
f_Read(P1,Arr(D[1],0),0x58F4F0) f_Read(P1,Arr(D[1],999),0x58F4F4)
f_Read(P1,Arr(D[2],0),0x58F4F8) f_Read(P1,Arr(D[2],999),0x58F4FC)
E = CreateLArr(1000,P1)
f_LMov(P1,LArr({E},0),"0x5555555555555555")
f_LMov(P1,LArr({E},999),"0x5555555555555555")
f_LRead(P1,LArr({E},0),0x58F480) f_LRead(P1,LArr({E},999),0x58F488)
F, G = CreateLArrs(2,1000,P1)
DoActionsX(P1,{SetLMemX(LArr({F},0),SetTo,"0x6666666666666666"),
SetLMemX(LArr({F},999),SetTo,"0x6666666666666666"),
SetLMemX(LArr({G},0),SetTo,"0x7777777777777777"),
SetLMemX(LArr({G},999),SetTo,"0x7777777777777777")})
f_LRead(P1,LArr({F},0),0x58F490) f_LRead(P1,LArr({F},999),0x58F498)
f_LRead(P1,LArr({G},0),0x58F4A0) f_LRead(P1,LArr({G},999),0x58F4A8)
H = CreateLArrArr(2,1000,P1)
DoActionsX(P1,{SetLMemX(LArr({H[1]},0),SetTo,"0x8888888888888888"),
SetLMemX(LArr({H[1]},999),SetTo,"0x8888888888888888"),
SetLMemX(LArr({H[2]},0),SetTo,"0x8888888888888888"),
SetLMemX(LArr({H[2]},999),SetTo,"0x8888888888888888")})
f_LRead(P1,LArr({H[1]},0),0x58F4B0) f_LRead(P1,LArr({H[1]},999),0x58F4B8)
f_LRead(P1,LArr({H[2]},0),0x58F4C0) f_LRead(P1,LArr({H[2]},999),0x58F4C8)
------------------------------------------------------------------------------------------

337

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------[예제 21-5] CreateCcode(), CreateCcodes, CreateCcodeArr(),
CreateNcode(), CreateNcodes, CreateNcodeArr(),
CreateVoid(), CreateVoids(), CreateVoidArr()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CJumpEnd(AllPlayers,0)
A = CreateCcode()
CMov(P1,_Ccode(P1,A),0x11111111)
f_Read(P1,_Ccode(P1,A),0x58F4C0)
B, C = CreateCCodes(2)
DoActionsX(P1,{SetCDeaths(P1,SetTo,0x22222222,B),
SetCDeaths(P1,SetTo,0x33333333,C)})
f_Read(P1,_Ccode(P1,B),0x58F4C4) f_Read(P1,_Ccode(P1,C),0x58F4C8)
D = CreateCcodeArr(3)
DoActionsX(P1,{SetCDeaths(P1,SetTo,0x44444444,D[1]),
SetCDeaths(P1,SetTo,0x44444444,D[2]),
SetCDeaths(P1,SetTo,0x44444444,D[3])})

f_Read(P1,_Ccode(P1,D[1]),0x58F4CC) f_Read(P1,_Ccode(P1,D[2]),0x58F4D0) f_Read(P1,_Ccode(P1,D[3]),0x58F4D4)

E = CreateNcode()
CMov(P1,_Ncode(P1,E),0x55555555)
f_Read(P1,_Ncode(P1,E),0x58F4E0)
F, G = CreateNCodes(2)
DoActionsX(P1,{SetNDeaths(P1,SetTo,0x66666666,F),
SetNDeaths(P1,SetTo,0x77777777,G)})
f_Read(P1,_Ncode(P1,F),0x58F4E4) f_Read(P1,_Ncode(P1,G),0x58F4E8)
H = CreateNcodeArr(3)
DoActionsX(P1,{SetNDeaths(P1,SetTo,0x88888888,H[1]),
SetNDeaths(P1,SetTo,0x88888888,H[2]),
SetNDeaths(P1,SetTo,0x88888888,H[3])})

f_Read(P1,_Ncode(P1,H[1]),0x58F4EC) f_Read(P1,_Ncode(P1,H[2]),0x58F4F0) f_Read(P1,_Ncode(P1,H[3]),0x58F4F4)

I = CreateVoid()
CMov(P1,I,0x99999999)
f_Read(P1,I,0x58F4A0)

J, K = CreateVoids(2)
DoActionsX(P1,{SetMemory(J,SetTo,0xAAAAAAAA),
SetMemory(K,SetTo,0xBBBBBBBB)})
f_Read(P1,J,0x58F4A4) f_Read(P1,K,0x58F4A8)
L = CreateVoidArr(3)
DoActionsX(P1,{SetMemory(L[1],SetTo,0xCCCCCCCC),
SetMemory(L[2],SetTo,0xCCCCCCCC),
SetMemory(L[3],SetTo,0xCCCCCCCC)})
f_Read(P1,L[1],0x58F4AC) f_Read(P1,L[2],0x58F4B0) f_Read(P1,L[3],0x58F4B4)

------------------------------------------------------------------------------------------

338

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------[예제 21-6] CreateSVar(), CreateSVar2(), CreateSVars, CreateSVarArr(),
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CJumpEnd(AllPlayers,0)
A = CreateSVar(3,P1)
SMov(P1,A[1],{0x11111111,0x11111111,0x11111111})
CMov(P1,0x58F450,_SCast(SV(A[2],1)))
CMov(P1,0x58F454,_SCast(SV(A[2],2)))CMov(P1,0x58F458,_SCast(SV(A[2],3)))
B = CreateSVar2(3,P1,{0x58F45C,0x58F460,0x58F464},SetTo,0x22222222)
CallSVariableX(P1,B[1])

C, D = CreateSVars(3,2,P1)
SMov(P1,C[1],{0x33333333,0x33333333,0x33333333})
SMov(P1,D[1],{0x44444444,0x44444444,0x44444444})
CMov(P1,0x58F468,_SCast(SV(C[2],1)))
CMov(P1,0x58F46C,_SCast(SV(C[2],2)))
CMov(P1,0x58F470,_SCast(SV(C[2],3)))
CMov(P1,0x58F474,_SCast(SV(D[2],1)))
CMov(P1,0x58F478,_SCast(SV(D[2],2)))
CMov(P1,0x58F47C,_SCast(SV(D[2],3)))
E = CreateSVarArr(4,2,P1)
SMov(P1,E[1][1],{0x55555555,0x55555555,0x55555555,0x55555555})
SMov(P1,E[2][1],{0x66666666,0x66666666,0x66666666,0x66666666})
CMov(P1,0x58F480,_SCast(SV(E[1][2],1)))
CMov(P1,0x58F484,_SCast(SV(E[1][2],2)))
CMov(P1,0x58F488,_SCast(SV(E[1][2],3)))
CMov(P1,0x58F48C,_SCast(SV(E[1][2],4)))
CMov(P1,0x58F490,_SCast(SV(E[2][2],1)))
CMov(P1,0x58F494,_SCast(SV(E[2][2],2)))
CMov(P1,0x58F498,_SCast(SV(E[2][2],3)))
CMov(P1,0x58F49C,_SCast(SV(E[2][2],4)))

------------------------------------------------------------------------------------------

339

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------[예제 21-7] CreateSVArr(), CreateSVArrs, CreateSVArrArr()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CJumpEnd(AllPlayers,0)
F = CreateSVArr(4,2,P1)
SMov(P1,SVArr(F,0),{0x77777777,0x77777777,0x77777777,0x77777777})
SMov(P1,SVArr(F,1),{0x88888888,0x88888888,0x88888888,0x88888888})
CMov(P1,0x58F4A0,_SCast(SVArr(F,0,1)))
CMov(P1,0x58F4A4,_SCast(SVArr(F,0,2)))
CMov(P1,0x58F4A8,_SCast(SVArr(F,0,3)))
CMov(P1,0x58F4AC,_SCast(SVArr(F,0,4)))
CMov(P1,0x58F4B0,_SCast(SVArr(F,1,1)))
CMov(P1,0x58F4B4,_SCast(SVArr(F,1,2)))
CMov(P1,0x58F4B8,_SCast(SVArr(F,1,3)))
CMov(P1,0x58F4BC,_SCast(SVArr(F,1,4)))
G, H = CreateSVArrs(2,4,2,P1)
SMov(P1,SVArr(G,0),{0x99999999,0x99999999,0x99999999,0x99999999})
SMov(P1,SVArr(G,1),{0xAAAAAAAA,0xAAAAAAAA,0xAAAAAAAA,0xAAAAAAAA})
SMov(P1,SVArr(H,0),{0xBBBBBBBB,0xBBBBBBBB,0xBBBBBBBB,0xBBBBBBBB})
SMov(P1,SVArr(H,1),{0xCCCCCCCC,0xCCCCCCCC,0xCCCCCCCC,0xCCCCCCCC})
CMov(P1,0x58F4C0,_SCast(SVArr(G,0,1)))
CMov(P1,0x58F4C4,_SCast(SVArr(G,0,2)))
CMov(P1,0x58F4C8,_SCast(SVArr(G,0,3)))
CMov(P1,0x58F4CC,_SCast(SVArr(G,0,4)))
CMov(P1,0x58F4D0,_SCast(SVArr(G,1,1)))
CMov(P1,0x58F4D4,_SCast(SVArr(G,1,2)))
CMov(P1,0x58F4D8,_SCast(SVArr(G,1,3)))
CMov(P1,0x58F4DC,_SCast(SVArr(G,1,4)))
CMov(P1,0x58F4E0,_SCast(SVArr(H,0,1)))
CMov(P1,0x58F4E4,_SCast(SVArr(H,0,2)))
CMov(P1,0x58F4E8,_SCast(SVArr(H,0,3)))
CMov(P1,0x58F4EC,_SCast(SVArr(H,0,4)))
CMov(P1,0x58F4F0,_SCast(SVArr(H,1,1)))
CMov(P1,0x58F4F4,_SCast(SVArr(H,1,2)))
CMov(P1,0x58F4F8,_SCast(SVArr(H,1,3)))
CMov(P1,0x58F4FC,_SCast(SVArr(H,1,4)))

I = CreateSVArrArr(2,4,2,P1)
SMov(P1,SVArr(I[1],0),{0xDDDDDDDD,0xDDDDDDDD,0xDDDDDDDD,0xDDDDDDDD})
SMov(P1,SVArr(I[1],1),{0xEEEEEEEE,0xEEEEEEEE,0xEEEEEEEE,0xEEEEEEEE})
SMov(P1,SVArr(I[2],0),{0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF,0xFFFFFFFF})
SMov(P1,SVArr(I[2],1),{0x12345678,0x90ABCDEF,0x87654321,0xFEDCBA09})
CMov(P1,0x58F450,_SCast(SVArr(I[1],0,1))) CMov(P1,0x58F454,_SCast(SVArr(I[1],0,2)))
CMov(P1,0x58F458,_SCast(SVArr(I[1],0,3))) CMov(P1,0x58F45C,_SCast(SVArr(I[1],0,4)))
CMov(P1,0x58F460,_SCast(SVArr(I[1],1,1))) CMov(P1,0x58F464,_SCast(SVArr(I[1],1,2)))
CMov(P1,0x58F468,_SCast(SVArr(I[1],1,3))) CMov(P1,0x58F46C,_SCast(SVArr(I[1],1,4)))
CMov(P1,0x58F470,_SCast(SVArr(I[2],0,1))) CMov(P1,0x58F474,_SCast(SVArr(I[2],0,2)))
CMov(P1,0x58F478,_SCast(SVArr(I[2],0,3))) CMov(P1,0x58F47C,_SCast(SVArr(I[2],0,4)))
CMov(P1,0x58F480,_SCast(SVArr(I[2],1,1))) CMov(P1,0x58F484,_SCast(SVArr(I[2],1,2)))
CMov(P1,0x58F488,_SCast(SVArr(I[2],1,3))) CMov(P1,0x58F48C,_SCast(SVArr(I[2],1,4)))

-----------------------------------------------------------------------------------------340

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------[예제 21-8] CreateVar2s(), CreateVarArr2(), CreateVArr2(), CreateVArr2s(), CreateVArrArr2(),
CreateWar2s(), CreateWarArr2(), CreateWArr2(), CreateWArr2s(), CreateWArrArr2()
CIfX(P1,Memory(0x57F0F0,Exactly,0))
A1, A2 = CreateVar2s(2,{0xAAAA1111,0xAAAA2222},P1)
CMov(P1,0x58F450,A1) CMov(P1,0x58F454,A2)
B = CreateVarArr2(2,{0xBBBB1111,0xBBBB2222},P1)
CMov(P1,0x58F458,B[1]) CMov(P1,0x58F45C,B[2])
C = CreateVArr2(2,{0xCCCC1111,0xCCCC2222},P1)
CMov(P1,0x58F460,VArr(C,0)) CMov(P1,0x58F464,VArr(C,1))
D, E = CreateVArr2s(2,3,{{0xDDDD1111,0xDDDD2222,0xDDDD3333},{0xEEEE1111,0xEEEE2222,0xEEEE3333}},P1)
CMov(P1,0x58F468,VArr(D,0)) CMov(P1,0x58F46C,VArr(D,1)) CMov(P1,0x58F470,VArr(D,2))
CMov(P1,0x58F474,VArr(E,0)) CMov(P1,0x58F478,VArr(E,1)) CMov(P1,0x58F47C,VArr(E,2))

CElseX()

F = CreateVArrArr2(2,2,{{0xFFFF1111,0xFFFF2222},{0xFFFF3333,0xFFFF4444}},P1)
CMov(P1,0x58F480,VArr(F[1],0)) CMov(P1,0x58F484,VArr(F[1],1))
CMov(P1,0x58F488,VArr(F[2],0)) CMov(P1,0x58F48C,VArr(F[2],1))
WA1, WA2 = CreateWar2s(2,{"0xAAAAAAAA11111111","0xAAAAAAAA22222222"},P1)
f_LMov(P1,0x58F450,WA1) f_LMov(P1,0x58F458,WA2)
WB = CreateWarArr2(2,{"0xBBBBBBBB11111111","0xBBBBBBBB22222222"},P1)
f_LMov(P1,0x58F460,WB[1]) f_LMov(P1,0x58F468,WB[2])
WC = CreateWArr2(2,{"0xCCCCCCCC11111111","0xCCCCCCCC22222222"},P1)
f_LMov(P1,0x58F470,WArr(WC,0)) f_LMov(P1,0x58F478,WArr(WC,1))

WD, WE = CreateWArr2s(2,2,{{"0xDDDDDDDD11111111","0xDDDDDDDD22222222"},{"0xEEEEEEEE11111111","0xEEEEEEEE22222222"}},P1)
f_LMov(P1,0x58F480,WArr(WD,0)) f_LMov(P1,0x58F488,WArr(WD,1)) f_LMov(P1,0x58F490,WArr(WE,0)) f_LMov(P1,0x58F498,WArr(WE,1))
WF = CreateWArrArr2(2,2,{{"0xFFFFFFFF11111111","0xFFFFFFFF22222222"},{"0xFFFFFFFF33333333","0xFFFFFFFF44444444"}},P1)
f_LMov(P1,0x58F4A0,WArr(WF[1],0)) f_LMov(P1,0x58F4A8,WArr(WF[1],1)) f_LMov(P1,0x58F4B0,WArr(WF[2],0)) f_LMov(P1,0x58F4B8,WArr(WF[2],1))

CIfXEnd()

-----------------------------------------------------------------------------------------[예제 21-9] CDoActionsX(), CDoAction2X(), CTriggerX(), CTrigger2X()
X, Y, T = CreateVars(3,P1)
CDoActionsX(P1,{
{TSetMemory,0x58F450,SetTo,{_Mov,{_Read,0x57F0F0},0xFFFF}},
{TSetMemory,0x58F454,SetTo,{_Mov,{_Read,0x57F120},0xFFFF0000}},
SetNVar(T,Subtract,1)
})
Z = CreateVar2(P1,nil,nil,EPD(0x58F480))
CTriggerX(P1,{{TMemory,Z,Exactly,1},NVar(T,Exactly,0)
},{
{TCreateUnit,1,{_Read,0x57F0F0},"CLoc",P1},SetNVar(T,SetTo,24)}
,{Preserved})
local ActArr = {}
for i = 0, 129 do
table.insert(ActArr,{TSetMemoryW,0x656EB0,i,SetTo,{_Mul,{_Read,0x57F0F0},i}})
end
CDoActions2X(P1,ActArr)
local ActArr2 = {}
for i = 0, 227 do
table.insert(ActArr2,{TSetMemoryDw,0x662350,i,Add,{_Mul,{_Read,0x57F0F0},256}})
end
CTrigger2X(P1,{{TMemory,Z,Exactly,2},},ActArr2,1)

------------------------------------------------------------------------------------------

341

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------[예제 21-10] CPush(), CPop(), LPush(), LPop()
Temp, Temp2 = CreateVars(2,P1)
X, Y, Z = CreateVar2s(3,{0x11111111,0x22222222,0x33333333},P1)
CPush(P1,{X,Y,Z})
CPop(P1,{0x58F450,Temp,Mem("X",Temp2[2],0x15C,0)})
CMov(P1,0x58F454,Temp) CMov(P1,0x58F458,Temp2)
TempW, TempW2 = CreateWars(2,P1)
WX, WY, WZ = CreateWar2s(3,{"0xAAAAAAAABBBBBBBB","0xCCCCCCCCDDDDDDDD","0xEEEEEEEEFFFFFFFF"},P1)
LPush(P1,{WX,WY,WZ})
LPop(P1,{{0x58F460,0x58F464},TempW,{Mem("X",TempW2[2],0x15C,0),Mem("X",TempW2[2],0x19C,0)}})
f_LMov(P1,0x58F468,TempW) f_LMov(P1,0x58F470,TempW2)

-----------------------------------------------------------------------------------------[예제 21-11] InitCFunc(), CFunc(), CFuncEnd(), CFuncReturn(), CallCFunc(),
CallCFuncX(), _Func(), TTFunc()
Func1 = InitCFunc(P1)
Para = CFunc(Func1)
X = CreateVar(P1)
CAdd(P1,X,_Add(Para[1],Para[1]),1)
NIfX(P1,NVar(Para[1],Exactly,0,1))
CFuncReturn({0,X})
NElseX()
CFuncReturn({1,X})
NIfXEnd()
CFuncEnd()
Y = CreateVar(P1)
CallCFuncX(P1,Func1,{_Read(0x57F0F0)},{0x58F450,Y})
CMov(P1,0x58F454,Y)
CallCFunc(Func1,{_Read(0x57F0F0)},{0x58F458,0x58F45C},P1,Memory(0x57F120,Exactly,1))
Func2 = InitCFunc(P1)
Para = CFunc(Func2)
CIfX(P1,NVar(Para[2],Exactly,1))
CAdd(P1,X,Para[1],Para[1])
CElseX()
CAdd(P1,X,_Add(Para[1],Para[1]),1)
CIfXEnd()
CFuncReturn({X})
CFuncEnd()
CMov(P1,0x58F460,_Func(Func2,{_Read(0x57F0F0),_Read(0x57F120)}))
Func3 = InitCFunc(P1)
Para = CFunc(Func3)
NIfX(P1,NVar(Para[1],Exactly,0,1))
CFuncReturn({0})
NElseX()
CFuncReturn({1})
NIfXEnd()
CFuncEnd()
CTrigger(P1,{TTFunc(Func3,{_Read(0x57F0F0)})},{DisplayText("\x04홀수")},{Preserved})
CTrigger(P1,{TTFunc(Func3,{_Read(0x57F0F0)},0)},{DisplayText("\x05짝수")},{Preserved})

------------------------------------------------------------------------------------------

342

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------[예제 21-12] CMathFunc(), CMathFunc2()
function func1(X)
return X^2-1
end
CMath1 = CMathFunc(P1,"func1",-0x100,0x100,
{{">=",0x101,0x7FFFFFFF},{"<=",-0x101,0x80000000}})
CMov(P1,0x58F450,_Func(CMath1,{_Read(0x57F0F0)}))
function func2(X)
return math.tan(math.rad(X))
end
CMath2 = CMathFunc(P1,"func2",0,179,nil,180,{
{"==",90,0x80000000}},0x10000)
CMov(P1,0x58F454,_Func(CMath2,{_Read(0x57F0F0),_Read(0x57F120)}))
function func3(X,Y)
return ((X-1)*(2*Y))/((Y-2)*(X-1))
end
function func3e(Y)
return 2*Y/(Y-2)
end
CMath3e = CMathFunc(P1,"func3e",0,0x10,{{"==",2,0x80000000}
,{">=",0x11,0x7FFFFFFF},{"<=",-1,0x7FFFFFFF}},nil,nil,0x1000)
CMath3 = CMathFunc2(P1,"func3",{0,0},{0x10,0x10},{{"X>=",0x11,0x7FFFFFFF},
{"Y>=",0x11,0x7FFFFFFF},{"X<=",-1,0x7FFFFFFF},{"Y<=",-1,0x7FFFFFFF},
{"X==",1,CMath3e},{"Y==",2,0x80000000}},nil,nil,0x1000)
CMov(P1,0x58F458,_Func(CMath3,{_Read(0x57F0F0),_Read(0x57F120),_Read(0x58F480)}))
CMov(P1,0x58F460,_Func(CMath3e,{_Read(0x57F120),_Read(0x58F480)}))
function func4(X,Y)
return math.sin(math.rad(X))*math.cos(math.rad(Y))
end
CMath4 = CMathfunc2(P1,"func4",{0,0},{90,90},nil,{360,360},{
{"X>=",91,0},{"Y>=",91,0}},0x10000)
CMov(P1,0x58F45C,_Func(CMath4,{_Read(0x57F0F0),_Read(0x57F120),_Read(0x58F480)}))
------------------------------------------------------------------------------------------

343

------------------------------------------------------------------------------------------

『 21장 : 사용자 정의 추가 함수 』

-----------------------------------------------------------------------------------------[예제 21-13] InitVFunc(), VFunc(), CallVFunc(), CallVFuncX(), _VFunc(), TTVFunc()
-- 21-11 예제 변형 (VFunc으로 모든 CFunc을 호출함)
Vptr = CreateWar(P1) -- 함수 포인터 (호출할 CFunc과 PlayerID가 같아야함)
VAptr = CreateWArr(2,P1)
Func1 = InitCFunc(P1)
Para = CFunc(Func1)
X = CreateVar(P1)
CAdd(P1,X,_Add(Para[1],Para[1]),1)
NIfX(P1,NVar(Para[1],Exactly,0,1))
CFuncReturn({0,X})
NElseX()
CFuncReturn({1,X})
NIfXEnd()
CFuncEnd()
InitVFunc(P1,Func1,Vptr)
Y = CreateVar(P1)
CallVFuncX(P1,Vptr,{_Read(0x57F0F0)},{0x58F450,Y})
CMov(P1,0x58F454,Y)
CallVFunc(Vptr,{_Read(0x57F0F0)},{0x58F458,0x58F45C},P1,Memory(0x57F120,Exactly,1))
Func2 = InitCFunc(P1)
Para = CFunc(Func2)
CIfX(P1,NVar(Para[2],Exactly,1))
CAdd(P1,X,Para[1],Para[1])
CElseX()
CAdd(P1,X,_Add(Para[1],Para[1]),1)
CIfXEnd()
CFuncReturn({X})
CFuncEnd()
DoActionsX(P1,VFunc(Func2,Vptr))
CMov(P1,0x58F460,_VFunc(Vptr,{_Read(0x57F0F0),_Read(0x57F120)}))
Func3 = InitCFunc(P1)
Para = CFunc(Func3)
NIfX(P1,NVar(Para[1],Exactly,0,1))
CFuncReturn({0})
NElseX()
CFuncReturn({1})
NIfXEnd()
CFuncEnd()
InitVFunc(P1,Func3,WArr(VAptr,_Mov(1)))
CTrigger(P1,{TTVFunc(WArr(VAptr,_Mov(1)),{_Read(0x57F0F0)})},{DisplayText("\x04홀수")},{Preserved})
CTrigger(P1,{TTVFunc(WArr(VAptr,_Mov(1)),{_Read(0x57F0F0)},0)},{DisplayText("\x05짝수")},{Preserved})

------------------------------------------------------------------------------------------

344

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-1] W(), LMem(), _LMem()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable2(P1,0x10,"X","X",{0x2000,0x1000})
CJumpEnd(AllPlayers,0)
f_LMov(P1,0x58F480,W(0x10))
f_LRead(P1,LMem(P1,0x10,{0x15C,0x19C},0),0x58F488)
f_LRead(P1,_LMem(W(0x10),{0x15C,{0x40}},0),0x58F490)
f_LRead(P1,_LMem(W(0x10),{0x15C,0x19C},0),0x58F498)
f_Read(P1,_LMem(W(0x10),0x15C,0),0x58F4A0)
f_Read(P1,_LMem(W(0x10),0x19C,0),0x58F4A4)
-----------------------------------------------------------------------------------------[예제 22-2] Wi(), LArr(), LArrX(), ConvertLArr()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
LA1 = LArray(P1,1000)
CWariable2(P1,0x12,"X","X",{5,5})
CWariable(P1,0x13)
CVariable2(P1,0x10,"X","X",5)
CVariable(P1,0x11)
CJumpEnd(AllPlayers,0)
f_LMov(P1,LArr({LA1},0),"0x1234567890AB")
f_LRead(P1,LArr({LA1},0),0x58F480)
f_LMov(P1,LArr({LA1},Wi(0x12,1)),"0x567890ABCDEF")
f_LRead(P1,LArr({LA1},6),0x58F488)
f_LRead(P1,LArr({LA1},Wi(0x12,1)),0x58F490)
f_LMov(P1,LArr({LA1},V(0x10)),"0x90ABCDEF1234")
f_LRead(P1,LArr({LA1},V(0x10)),0x58F498)
ConvertLArr(P1,W(0x13),W(0x12),8)
f_LMov(P1,LArrX({LA1},W(0x13)),"0xCDEF12345678")
f_LRead(P1,LArrX({LA1},W(0x13)),0x58F4A0)
ConvertLArr(P1,V(0x11),V(0x10),8)
f_LMov(P1,LArrX({LA1},V(0x11)),"0x111222333444")
f_LRead(P1,LArrX({LA1},V(0x11)),0x58F4A8)
f_LMov(P1,LArrX({LA1},Wi(0x13,10)),"0x555666777888")
f_LRead(P1,LArrX({LA1},Wi(0x13,10)),0x58F4B0)
f_LRead(P1,LArrX({LA1},Vi(0x11,10)),0x58F4B8)
------------------------------------------------------------------------------------------

345

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-3] Wi(), WArr(), WArrX(), ConvertWArr()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
WA1 = CWArray(P1,10)
CWariable2(P1,0x12,"X","X",{5,5})
CWariable(P1,0x13) CWariable(P1,0x14)
CVariable2(P1,0x10,"X","X",5)
CWariable(P1,0x11) CWariable(P1,0x15)
CJumpEnd(AllPlayers,0)
f_LMov(P1,WArr(WA1,0),"0x1234567890AB")
f_LMov(P1,0x58F480,WArr(WA1,0))
f_LMov(P1,WArr(WA1,Wi(0x12,1)),"0x567890ABCDEF")
f_LMov(P1,0x58F488,WArr(WA1,6))

f_LMov(P1,0x58F490,WArr(WA1,Wi(0x12,1)))
f_LMov(P1,WArr(WA1,V(0x10)),"0x90ABCDEF1234")
f_LMov(P1,0x58F498,WArr(WA1,V(0x10)))
ConvertWArr(P1,W(0x13),W(0x14),W(0x12),10)
f_LMov(P1,WArrX(WA1,W(0x13),W(0x14)),"0xCDEF12345678")
f_LMov(P1,0x58F4A0,WArrX(WA1,W(0x13),W(0x14)))
ConvertWArr(P1,W(0x11),W(0x15),V(0x10),10)
f_LMov(P1,WArrX(WA1,W(0x11),W(0x15)),"0x111222333444")
f_LMov(P1,0x58F4A8,WArrX(WA1,W(0x11),W(0x15)))
f_LMov(P1,WArrX(WA1,Wi(0x13,3),W(0x14)),"0x555666777888")
f_LMov(P1,0x58F4B0,WArrX(WA1,Wi(0x13,3),W(0x14)))

f_LMov(P1,0x58F4B8,WArrX(WA1,Wi(0x11,3),W(0x15)))
------------------------------------------------------------------------------------------

346

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-4] LCallLabel1(), LCallLabel2(), LCallLabel1X(), LCallLabel2X(),
CallWariable(), CallWariableX(), CWariable2(), GetWArray()
CJump(AllPlayers,0)
for i = 0, 7 do

CWariable2(P1,0x10+i,{0x58F480+0x8*i,0x58F484+0x8*i},SetTo,{0x11111111*(i+1),0x11111111*(i+1)})

end
WA1 = GetWArray(W(0x10))
CJumpEnd(AllPlayers,0)

DoActionsX(P1,{SetMemory(0x58F480,SetTo,0), SetMemory(0x58F484,SetTo,0),
SetMemory(0x58F488,SetTo,0), SetMemory(0x58F48C,SetTo,0),
SetMemory(0x58F490,SetTo,0), SetMemory(0x58F494,SetTo,0),
SetMemory(0x58F498,SetTo,0), SetMemory(0x58F49C,SetTo,0),
SetMemory(0x58F4A0,SetTo,0), SetMemory(0x58F4A4,SetTo,0),
SetMemory(0x58F4A8,SetTo,0), SetMemory(0x58F4AC,SetTo,0),
SetMemory(0x58F4B0,SetTo,0), SetMemory(0x58F4B4,SetTo,0),
SetMemory(0x58F4B8,SetTo,0), SetMemory(0x58F4BC,SetTo,0)
})
Trigger {

players = {P1},
conditions = {
Label(0);
Accumulate(P1,Exactly,1,Ore);
},
actions = {
LCallLabel1(P1,0x10);
PreserveTrigger();
}

}
DoActionsX(P1,LCallLabel2(P1,0x10)) -- RecoverNext
Trigger {

players = {P1},
conditions = {
Label(0);
Accumulate(P1,Exactly,-1,Ore);
},
actions = {
LCallLabel1X(W(0x11));
PreserveTrigger();
}
}DoActionsX(P1,LCallLabel2X(W(0x11))) -- RecoverNext
CallWariable(P1,P1,0x12,"X",Accumulate(P1,Exactly,1,Gas))
CallWariableX(P1,W(0x13),Accumulate(P1,Exactly,-1,Gas))

CallWariable(P1,P1,0x14,"X")
CallWariableX(P1,W(0x15))

------------------------------------------------------------------------------------------

347

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-5] WariableX(), SetWariableX(), Wariable(), SetWariable(), WArrayX(), SetWArrayX(),

CWar(), SetCWar(), NWar(), SetNWar(), CWAar(), SetCWAar(), LMemX(), SetLMemX()

CJump(AllPlayers,0)
CWariable(P1,0x10) CWariable(P1,0x11)
CWariable2(P1,0x12,0x58F4B0)
WA1 = CWArray(P1,10)
CJumpEnd(AllPlayers,0)
A, B = CreateWars(2,P1)
DoActionsX(P1,{SetCWar("X",0x10,SetTo,0x11111111),SetCWar("X",0x10,SetTo,{0x22222222}),
SetCWar("X",0x11,SetTo,"0x3333333333333333")})
TriggerX(P1,CWar("X",0x10,Exactly,0x11111111),
{SetWariableX("X",0x10,"EPD1",SetTo,EPD(0x58F480))},{Preserved})
TriggerX(P1,CWar("X",0x10,Exactly,{0x22222222}),
{SetWariableX("X",0x10,"EPD2",SetTo,EPD(0x58F484))},{Preserved})
TriggerX(P1,CWar("X",0x11,Exactly,{0x33333333,0x33333333}),
{SetWariableX("X",0x11,"EPD",SetTo,{EPD(0x58F488),EPD(0x58F48C)})},{Preserved})
CallWariable(P1,"X",0x10) CallWariable(P1,"X",0x11)
DoActionsX(P1,{SetNWar(A,SetTo,0x44444444),SetNWar(A,SetTo,{0x55555555}),
SetNWar(B,SetTo,"0x6666666666666666")})
TriggerX(P1,NWar(A,Exactly,0x44444444),
{SetWariable(A,"EPD1",SetTo,EPD(0x58F490))},{Preserved})
TriggerX(P1,NWar(A,Exactly,{0x55555555}),
{SetWariable(A,"EPD2",SetTo,EPD(0x58F494))},{Preserved})
TriggerX(P1,NWar(B,Exactly,{0x66666666,0x66666666}),
{SetWariable(B,"EPD",SetTo,{EPD(0x58F498),EPD(0x58F49C)})},{Preserved})
CallWariableX(P1,A) CallWariableX(P1,B)
DoActionsX(P1,{SetCWAar(WArr(WA1,0),SetTo,0x77777777),
SetCWAar(WArr(WA1,0),SetTo,{0x88888888}),SetCWAar(WArr(WA1,1),SetTo,"0x9999999999999999")})
TriggerX(P1,CWAar(WArr(WA1,0),Exactly,0x77777777),
{SetWArrayX(WArr(WA1,0),"EPD1",SetTo,EPD(0x58F4A0))},{Preserved})
TriggerX(P1,CWAar(WArr(WA1,0),Exactly,{0x88888888}),
{SetWArrayX(WArr(WA1,0),"EPD2",SetTo,EPD(0x58F4A4))},{Preserved})
TriggerX(P1,CWAar(WArr(WA1,1),Exactly,{0x99999999,0x99999999}),
{SetWArrayX(WArr(WA1,1),"EPD",SetTo,{EPD(0x58F4A8),EPD(0x58F4AC)})},{Preserved})
CallWariableX(P1,WArr(WA1,0)) CallWariableX(P1,WArr(WA1,1))
DoActionsX(P1,{SetLMemX({{"X",0x12,0x15C,0},{"X",0x12,0x19C,0}},
SetTo,{0xAAAAAAAA,0xBBBBBBBB})})
TriggerX(P1,LMemX({{"X",0x12,0x15C,0},{"X",0x12,0x19C,0}},Exactly,{0xAAAAAAAA,0xBBBBBBBB}),
{CallLabelAlways(P1,0x12)},{Preserved})
TriggerX(P1,WariableX("X",0x10,"EPD1",Exactly,EPD(0x58F480)),
{SetMemoryX(0x58F4B8,SetTo,0xCCCC,0xFFFF)},{Preserved})
TriggerX(P1,Wariable(A,"EPD2",Exactly,EPD(0x58F494)),
{SetMemoryX(0x58F4B8,SetTo,0xDDDD0000,0xFFFF0000)},{Preserved})
TriggerX(P1,WArrayX(WArr(WA1,1),"EPD",Exactly,{EPD(0x58F4A8),EPD(0x58F4AC)}),
{SetMemory(0x58F4BC,SetTo,0xEEEEEEEE)},{Preserved})

------------------------------------------------------------------------------------------

348

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-6] TCWar(), TSetCWar(), TNWar(), TSetNWar(), TCWAar(), TSetCWAar()
CJump(AllPlayers,0)
CWariable(P1,0x10)
WA1 = CWArray(P1,10)
CJumpEnd(AllPlayers,0)
A = CreateWar(P1)
M1 = CreateVar2(P1,nil,nil,0xFFFF0000)
M2 = CreateVar2(P1,nil,nil,0x0000FFFF)
V1 = CreateVar2(P1,nil,nil,0x11111111)
V2 = CreateVar2(P1,nil,nil,0x22222222)
V3 = CreateVar2(P1,nil,nil,0x33333333)
V4 = CreateVar2(P1,nil,nil,0x44444444)
V5 = CreateVar2(P1,nil,nil,0x55555555)
V6 = CreateVar2(P1,nil,nil,0x66666666)
VM1 = CreateVar2(P1,nil,nil,0x11110000)
VM2 = CreateVar2(P1,nil,nil,0x00002222)
VM3 = CreateVar2(P1,nil,nil,0x33330000)
VM4 = CreateVar2(P1,nil,nil,0x00004444)
VM5 = CreateVar2(P1,nil,nil,0x55550000)
VM6 = CreateVar2(P1,nil,nil,0x00006666)
CDoActions(P1,{TSetCWar("X",0x10,SetTo,V1,M1),TSetCWar("X",0x10,SetTo,{V2},M2),
TSetNWar(A,SetTo,V3,M1),TSetNWar(A,SetTo,{V4},M2),
TSetCWAar(WArr(WA1,0),SetTo,V5,M1),TSetCWAar(WArr(WA1,0),SetTo,{V6},M2)})
CTrigger(P1,{TCWar("X",0x10,Exactly,VM1,M1)},{SetWariableX("X",0x10,"EPD1",SetTo,
EPD(0x58F480))},{Preserved})
CTrigger(P1,{TCWar("X",0x10,Exactly,{VM2},M2)},{SetWariableX("X",0x10,"EPD2",SetTo,
EPD(0x58F484))},{Preserved})
CTrigger(P1,{TNWar(A,Exactly,VM3,M1)},{SetWariable(A,"EPD1",SetTo,
EPD(0x58F488))},{Preserved})
CTrigger(P1,{TNWar(A,Exactly,{VM4},M2)},{SetWariable(A,"EPD2",SetTo,
EPD(0x58F48C))},{Preserved})
CTrigger(P1,{TCWAar(WArr(WA1,0),Exactly,VM5,M1)},{SetWArrayX(WArr(WA1,0),"EPD1",SetTo,
EPD(0x58F490))},{Preserved})
CTrigger(P1,{TCWAar(WArr(WA1,0),Exactly,{VM6},M2)},{SetWArrayX(WArr(WA1,0),"EPD2",SetTo,
EPD(0x58F494))},{Preserved})
CallWariable(P1,"X",0x10)
CallWariableX(P1,A)
CallWariableX(P1,WArr(WA1,0))

------------------------------------------------------------------------------------------

349

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-7] TTLMemory(), TTCWar(), TTNWar(), TTCWAar(),
TTWariableX(), TTWariable(), TTWArrayX()
CJump(AllPlayers,0)
CWariable(P1,0x10)
WA1 = CWArray(P1,10)
CJumpEnd(AllPlayers,0)
A = CreateWar(P1)
B = CreateWar2(P1,nil,nil,{EPD(0x58F450),EPD(0x58F454)})
CTrigger(P1,{TTLMemory(B,Exactly,_LRead(0x58F458))},
{DisplayText("\x1DA==B")},{preserved})
CTrigger(P1,{TTLMemory(B,NotSame,_LRead(0x58F458))},
{DisplayText("\x1BA!=B")},{preserved})
CTrigger(P1,{TTLMemory(B,AtLeast,_LRead(0x58F458))},
{DisplayText("\x19A>=B")},{preserved})
CTrigger(P1,{TTLMemory(B,AtMost,_LRead(0x58F458))},
{DisplayText("\x02A<=B")},{preserved})
CTrigger(P1,{TTLMemory(B,Above,_LRead(0x58F458))},
{DisplayText("\x03A>B")},{preserved})
CTrigger(P1,{TTLMemory(B,Below,_LRead(0x58F458))},
{DisplayText("\x1EA<B")},{preserved})
f_LRead(P1,0x58F450,W(0x10))
f_LRead(P1,0x58F450,A)
f_LRead(P1,0x58F450,WArr(WA1,0))
CTrigger(P1,{TTCWar("X",0x10,Exactly,_LRead(0x58F458))},
{DisplayText("\x18A==B:TTCWar")},{preserved})
CTrigger(P1,{TTWariableX("X",0x10,"Value",NotSame,_LRead(0x58F458))},
{DisplayText("\x06A!=B:TTWariableX")},{preserved})
CTrigger(P1,{TTNWar(A,AtLeast,_LRead(0x58F458))},
{DisplayText("\x11A>=B:TTNWar")},{preserved})
CTrigger(P1,{TTWariable(A,"Value",AtMost,_LRead(0x58F458))},
{DisplayText("\x0EA<=B:TTWariable")},{preserved})
CTrigger(P1,{TTCWAar(WArr(WA1,0),Above,_LRead(0x58F458))},
{DisplayText("\x17A>B:TTCWAar")},{preserved})
CTrigger(P1,{TTWArrayX(WArr(WA1,0),"Value",Below,_LRead(0x58F458))},
{DisplayText("\x10A<B:TTWArrayX")},{preserved})

------------------------------------------------------------------------------------------

350

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-8] TTLMemory()
CTrigger(P1,{TTLMemory(0x58F450,iAbove,_LRead(0x58F458))},{DisplayText("\x1FLiAbove 조건 만족")},{Preserved})
CTrigger(P1,{TTLMemory(0x58F450,iAtLeast,_LRead(0x58F458))},{DisplayText("\x07LiAtLeast 조건 만족")},{Preserved})
CTrigger(P1,{TTLMemory(0x58F450,iAtMost,_LRead(0x58F458))},{DisplayText("\x11LiAtMost 조건 만족")},{Preserved})
CTrigger(P1,{TTLMemory(0x58F450,iBelow,_LRead(0x58F458))},{DisplayText("\x08LiBelow 조건 만족")},{Preserved})

------------------------------------------------------------------------------------------

351

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-A] f_LRead()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11)
LA1 = LArray(P1,1000)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
for i = 0x100, 0x110 do CWariable(P1,i) end
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)

f_LRead(P1,0x58F480,0x58F490)
f_LRead(P1,0x58F480,W(0x10))
f_LRead(P1,_LMem(W(0x10)),W(0x100))
f_LRead(P1,0x58F480,LArr({LA1},0))
f_LRead(P1,LArr({LA1},0),W(0x101))
f_LRead(P1,0x58F480,WArr(WA1,0))
f_LRead(P1,_LMem(WArr(WA1,0)),W(0x102))
f_LRead(P1,0x58F480,LArr({LA1},j))
f_LRead(P1,LArr({LA1},j),W(0x103))

f_LRead(P1,0x58F480,LArr({LA1},i))
f_LRead(P1,LArr({LA1},i),W(0x104))
f_LRead(P1,0x58F480,WArr(WA1,i))
f_LRead(P1,_TLMem(WArr(WA1,i)),W(0x105))
f_LRead(P1,0x58F480,{VArr(VA1,j),Arr(A1,j)})
f_LRead(P1,{_TMem(VArr(VA1,j)),Arr(A1,j)},W(0x106))
f_LRead(P1,0x58F480,{0x58F4D0,V(0x11)})
f_LRead(P1,{0x58F4D0,_Mem(V(0x11))},W(0x107))
f_LRead(P1,0x58F480,{Arr(A1,0),VArr(VA1,0)})
f_LRead(P1,{Arr(A1,0),_Mem(VArr(VA1,0))},W(0x108))
f_LMov(P1,W(0x10),{EPD(0x58F488),EPD(0x58F48C)})
f_LRead(P1,W(0x10),W(0x109))
f_LMov(P1,WArr(WA1,0),{EPD(0x58F488),EPD(0x58F48C)})
f_LRead(P1,WArr(WA1,0),W(0x10A))
f_LMov(P1,WArr(WA1,i),{EPD(0x58F488),EPD(0x58F48C)})
f_LRead(P1,WArr(WA1,i),W(0x10B))
f_LMov(P1,{VArr(VA1,j),V(0x11)},{EPD(0x58F488),EPD(0x58F48C)})
f_LRead(P1,{VArr(VA1,j),V(0x11)},W(0x10C))
for i = 0, 12 do f_LMov(P1,0x58F498+0x8*i,W(0x100+i)) end

------------------------------------------------------------------------------------------

352

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-B] f_LReadX()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11)
LA1 = LArray(P1,1000)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
for i = 0x100, 0x110 do CWariable(P1,i) end
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)

f_LReadX(P1,0x58F480,0x58F488,0)
f_LReadX(P1,0x58F480,0x58F490,-7)
f_LReadX(P1,0x58F480,W(0x10),-6)
f_LReadX(P1,_LMem(W(0x10)),W(0x100),0)
f_LReadX(P1,0x58F480,LArr({LA1},0),0)
f_LReadX(P1,LArr({LA1},0),W(0x101),-5)
f_LReadX(P1,0x58F480,WArr(WA1,0),-4)
f_LReadX(P1,_LMem(WArr(WA1,0)),W(0x102),0)
f_LReadX(P1,0x58F480,LArr({LA1},j),0)
f_LReadX(P1,LArr({LA1},j),W(0x103),-3)

f_LReadX(P1,0x58F480,LArr({LA1},i),-2)
f_LReadX(P1,LArr({LA1},i),W(0x104),0)
f_LReadX(P1,0x58F480,WArr(WA1,i),0)
f_LReadX(P1,_TLMem(WArr(WA1,i)),W(0x105),-1)
f_LReadX(P1,0x58F480,{VArr(VA1,j),Arr(A1,j)},1)
f_LReadX(P1,{_TMem(VArr(VA1,j)),Arr(A1,j)},W(0x106),0)
f_LReadX(P1,0x58F480,{0x58F4D0,V(0x11)},0)
f_LReadX(P1,{0x58F4D0,_Mem(V(0x11))},W(0x107),2)
f_LReadX(P1,0x58F480,{Arr(A1,0),VArr(VA1,0)},3)
f_LReadX(P1,{Arr(A1,0),_Mem(VArr(VA1,0))},W(0x108),0)
f_LMov(P1,W(0x10),{EPD(0x58F480),EPD(0x58F484)})
f_LReadX(P1,W(0x10),W(0x109),4)
f_LMov(P1,WArr(WA1,0),{EPD(0x58F480),EPD(0x58F484)})
f_LReadX(P1,WArr(WA1,0),W(0x10A),5)
f_LMov(P1,WArr(WA1,i),{EPD(0x58F480),EPD(0x58F484)})
f_LReadX(P1,WArr(WA1,i),W(0x10B),6)
f_LMov(P1,{VArr(VA1,j),V(0x11)},{EPD(0x58F480),EPD(0x58F484)})
f_LReadX(P1,{VArr(VA1,j),V(0x11)},W(0x10C),7)
for i = 0, 12 do f_LMov(P1,0x58F498+0x8*i,W(0x100+i)) end

------------------------------------------------------------------------------------------

353

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-C] f_LWrite()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)
k = CreateWar2(P1,nil,nil,{2,2})
l = CreateVar2(P1,nil,nil,2)
f_LMov(P1,WArr(WA1,i),{EPD(0x58F488),EPD(0x58F48C)})
f_LRead(P1,0x58F480,WArr(WA1,k))
f_LWrite(P1,WArr(WA1,i),WArr(WA1,k))
f_LMov(P1,WArr(WA1,0),{EPD(0x58F490),EPD(0x58F494)})
f_LRead(P1,0x58F480,W(0x10))
f_LWrite(P1,WArr(WA1,0),W(0x10))
CMov(P1,V(0x11),EPD(0x58F498))
CMov(P1,VArr(VA1,j),EPD(0x58F49C))
f_Read(P1,0x58F480,VArr(VA1,l))
f_LWrite(P1,{V(0x11),VArr(VA1,j)},{VArr(VA1,l),_Read(0x58F484)})
f_LWrite(P1,_LMov({EPD(0x58F4A0),EPD(0x58F4A4)}),"0x1234567890ABCDEF")
CMov(P1,VArr(VA1,0),EPD(0x58F4AC))
f_LWrite(P1,{_Mov(EPD(0x58F4A8)),VArr(VA1,0)},{0x12345678,_Read(0x58F484)})

------------------------------------------------------------------------------------------

354

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-D] f_LMov()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11)
LA1 = LArray(P1,1000)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
CVariable(P1,0x12)
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)

f_LMov(P1,0x58F488,_LRead(0x58F480))
f_LMov(P1,W(0x10),_LRead(0x58F480))
f_LMov(P1,0x58F490,W(0x10))
f_LMov(P1,WArr(WA1,i),_LRead(0x58F480))
f_LMov(P1,0x58F498,WArr(WA1,i))
f_LMov(P1,LArr({LA1},i),_LRead(0x58F480))
f_LMov(P1,0x58F4A0,_LRead(LArr({LA1},i)))
f_LMov(P1,LArr({LA1},j),_LRead(0x58F480))
f_LMov(P1,0x58F4A8,_LRead(LArr({LA1},j)))
f_LMov(P1,LArr({LA1},0),_LRead(0x58F480))
f_LMov(P1,0x58F4B0,_LRead(LArr({LA1},0)))
f_LMov(P1,{VArr(VA1,j),Arr(A1,j)},_LRead(0x58F480))
f_LMov(P1,0x58F4B8,{VArr(VA1,j),_Read(Arr(A1,j))})
f_LMov(P1,{Arr(A1,0),VArr(VA1,0)},_LRead(0x58F480))
f_LMov(P1,0x58F4C0,{_Read(Arr(A1,0)),VArr(VA1,0)})
f_LMov(P1,{0x58F4C8,V(0x11)},_LRead(0x58F480))
f_LMov(P1,{V(0x12),0x58F4CC},_LRead(0x58F480))

f_LMov(P1,0x58F4D0,{V(0x12),V(0x11)})
f_LMov(P1,{0x58F4D8,{4}},"0x1234567890ABCDEF")

------------------------------------------------------------------------------------------

355

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-E] f_LMovX()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11)
LA1 = LArray(P1,1000)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)
k = CreateWar2(P1,nil,nil,{2,2})
l = CreateVar2(P1,nil,nil,2)

f_LMovX(P1,WArr(WA1,i),_LRead(0x58F480))
f_LMovX(P1,0x58F488,WArr(WA1,i))
f_LMovX(P1,W(0x10),WArr(WA1,i))
f_LMov(P1,0x58F490,W(0x10))
f_LMovX(P1,WArr(WA1,k),WArr(WA1,i))
f_LMov(P1,0x58F498,WArr(WA1,k))
f_LMovX(P1,LArr({LA1},i),WArr(WA1,i))
f_LMov(P1,0x58F4A0,_LRead(LArr({LA1},i)))
f_LMovX(P1,LArr({LA1},j),WArr(WA1,i))
f_LMov(P1,0x58F4A8,_LRead(LArr({LA1},j)))
f_LMovX(P1,LArr({LA1},0),WArr(WA1,i))
f_LMov(P1,0x58F4B0,_LRead(LArr({LA1},0)))
f_LMovX(P1,{VArr(VA1,0),Arr(A1,0)},WArr(WA1,i))
f_LMov(P1,0x58F4B8,{VArr(VA1,0),_Read(Arr(A1,0))})
f_LMovX(P1,{Arr(A1,0),VArr(VA1,0)},WArr(WA1,i))
f_LMov(P1,0x58F4C0,{_Read(Arr(A1,0)),VArr(VA1,0)})
f_LMovX(P1,{0x58F4C8,V(0x11)},WArr(WA1,i))
CMov(P1,0x58F4CC,V(0x11))
f_LMovX(P1,WArr(WA1,i),"0x2222222211111111")
f_LMovX(P1,0x58F4D0,WArr(WA1,i))
f_LMovX(P1,WArr(WA1,i),{0x33333333,0x44444444})
f_LMovX(P1,0x58F4D8,WArr(WA1,i))
f_LMovX(P1,WArr(WA1,i),0x55555555)
f_LMovX(P1,0x58F4E0,WArr(WA1,i))
f_LMovX(P1,WArr(WA1,i),_LMov({0x66666666,0x77777777}))
f_LMovX(P1,0x58F4E8,WArr(WA1,i))
f_LMovX(P1,WArr(WA1,i),{_Mov(0x88888888),0x99999999})
f_LMovX(P1,0x58F4F0,WArr(WA1,i))
f_LMovX(P1,WArr(WA1,i),{_Mov(0xBBBBBBBB),_Mov(0xAAAAAAAA)})
f_LMovX(P1,0x58F4F8,WArr(WA1,i))
f_LMovX(P1,WArr(WA1,i),{0x88888888,_Mov(0x99999999)})
f_LMovX(P1,0x58F450,WArr(WA1,i))

------------------------------------------------------------------------------------------

356

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-F] TLMem()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11)
LA1 = LArray(P1,1000)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
for i = 0x100, 0x115 do CWariable(P1,i) end
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)

TLMem(P1,W(0x100),V(0x11),nil,nil,1)
TLMem(P1,W(0x101),W(0x10),nil,nil,1)
TLMem(P1,W(0x102),VArr(VA1,0),nil,nil,1)
TLMem(P1,W(0x103),Arr(A1,0),nil,nil,1)
TLMem(P1,W(0x104),VArr(VA1,j),nil,nil,1)
TLMem(P1,W(0x105),Arr(A1,j),nil,nil,1)
TLMem(P1,W(0x106),LArr({LA1},0),nil,nil,1)
TLMem(P1,W(0x107),LArr({LA1},i),nil,nil,1)
TLMem(P1,W(0x108),LArr({LA1},j),nil,nil,1)
TLMem(P1,W(0x109),WArr(WA1,0),nil,nil,1)
TLMem(P1,W(0x10A),WArr(WA1,i),nil,nil,1)
TLMem(P1,W(0x10B),V(0x11))
TLMem(P1,W(0x10C),W(0x10))
TLMem(P1,W(0x10D),VArr(VA1,0))
TLMem(P1,W(0x10E),Arr(A1,0))
TLMem(P1,W(0x10F),VArr(VA1,j))
TLMem(P1,W(0x110),Arr(A1,j))
TLMem(P1,W(0x111),LArr({LA1},0))
TLMem(P1,W(0x112),LArr({LA1},i))
TLMem(P1,W(0x113),LArr({LA1},j))
TLMem(P1,W(0x114),WArr(WA1,0))
TLMem(P1,W(0x115),WArr(WA1,i))
for i = 0x100, 0x10F do f_LMov(P1,0x58F480+8*(i-0x100),W(i)) end
for i = 0x110, 0x115 do f_LMov(P1,0x58F450+8*(i-0x110),W(i)) end

------------------------------------------------------------------------------------------

357

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-G] f_LDiff()
CJump(AllPlayers,0)
CWariable(P1,0x10)
CWariable(P1,0x11)
CWariable(P1,0x12)
CWariable(P1,0x13)
CWariable(P1,0x14)
WA1 = CWArray(P1,10)
CWariable2(P1,0x20,"X","X",{1,1}) i = 0x20
CJumpEnd(AllPlayers,0)

DoActionsX(P1,{SetMemory(0x58F480,SetTo,0),SetMemory(0x58F484,SetTo,0),
SetCWar("X",0x10,SetTo,{0xFFFFFFFF,0xFFFFFFFF})},1)
f_LAdd(P1,W(0x10),W(0x10),_LRead(0x58F480))
f_LMov(P1,0x58F490,W(0x10))
f_LDiff(P1,W(0x11),W(0x10),"0xFFFFFFFFFFFFFFFF",0)
f_LMov(P1,0x58F498,W(0x11))
f_LDiff(P1,W(0x11),W(0x10),"0xFFFFFFFFFFFFFFFF",0,nil,1)
f_LMov(P1,0x58F4A0,W(0x11))
f_LMovX(P1,WArr(WA1,W(i)),W(0x10))
f_LDiff(P1,W(0x11),WArr(WA1,W(i)),"0xFFFFFFFFFFFFFFFF",0)
f_LMov(P1,0x58F4A8,W(0x11))
CTrigger({P1},{TTLMemory(0x58F490,Exactly,"0xFFFFFFFFFFFFFFFF")},
{DisplayText("\x1F0x58F490 : 0xFFFFFFFFFFFFFFFF 감지됨")})
DoActionsX(P1,SetCWar("X",0x14,SetTo,{0xFFFFFFFF,0xFFFFFFFF}),1)
f_LAdd(P1,W(0x14),W(0x14),_LRead(0x58F488))
f_LMov(P1,0x58F4B0,W(0x14))
f_LDiff(P1,W(0x11),W(0x14),"0xFFFFFFFFFFFFFFFF",24*5,0,0)
f_LMov(P1,0x58F4B8,W(0x11))
f_LDiff(P1,W(0x11),W(0x14),"0xFFFFFFFFFFFFFFFF",24*5,0,1)
f_LMov(P1,0x58F4C0,W(0x11))
f_LDiff(P1,WArr(WA1,W(i)),W(0x14),"0xFFFFFFFFFFFFFFFF",24*5,0,0)
f_LMov(P1,0x58F4C8,WArr(WA1,W(i)))
f_LAdd(P1,W(0x13),W(0x13),1)
f_LMov(P1,0x58F4D0,W(0x13))
f_LAdd(P1,W(0x12),W(0x12),W(0x13))
f_LMov(P1,0x58F4D8,W(0x12))
f_LDiff(P1,W(0x11),W(0x12),"0xFFFFFFFFFFFFFFFF",24,0)
f_LMov(P1,0x58F4E0,W(0x11))
f_LDiff(P1,W(0x11),W(0x12),"0xFFFFFFFFFFFFFFFF",24,12)
f_LMov(P1,0x58F4E8,W(0x11))

------------------------------------------------------------------------------------------

358

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-H] f_LRand()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11)
LA1 = LArray(P1,1000)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
CVariable(P1,0x12)
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)

f_LRand(P1,0x58F488)
f_LRand(P1,W(0x10))
f_LMov(P1,0x58F490,W(0x10))
f_LRand(P1,WArr(WA1,i))
f_LMov(P1,0x58F498,WArr(WA1,i))
f_LRand(P1,LArr({LA1},i))
f_LMov(P1,0x58F4A0,_LRead(LArr({LA1},i)))
f_LRand(P1,LArr({LA1},j))
f_LMov(P1,0x58F4A8,_LRead(LArr({LA1},j)))

f_LRand(P1,LArr({LA1},0))
f_LMov(P1,0x58F4B0,_LRead(LArr({LA1},0)))
f_LRand(P1,{VArr(VA1,j),Arr(A1,j)})
f_LMov(P1,0x58F4B8,{VArr(VA1,j),_Read(Arr(A1,j))})
f_LRand(P1,{Arr(A1,0),VArr(VA1,0)})
f_LMov(P1,0x58F4C0,{_Read(Arr(A1,0)),VArr(VA1,0)})
f_LRand(P1,{0x58F4C8,V(0x11)})
CMov(P1,0x58F4CC,V(0x11))

------------------------------------------------------------------------------------------

359

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-I] f_Cast()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)

f_LMov(P1,W(0x10),"0x1234567890ABCDEF")
f_LMov(P1,0x58F480,W(0x10))
f_Cast(P1,{V(0x11),0},W(0x10))
CMov(P1,0x58F488,V(0x11))
f_Cast(P1,{V(0x11),1},W(0x10))
CMov(P1,0x58F48C,V(0x11))
f_Cast(P1,{VArr(VA1,j),0},W(0x10))
CMov(P1,0x58F490,VArr(VA1,j))
f_Cast(P1,{VArr(VA1,j),1},W(0x10))
CMov(P1,0x58F494,VArr(VA1,j))
f_LMov(P1,WArr(WA1,i),"0x1234567890ABCDEF")
f_LMov(P1,0x58F4A0,WArr(WA1,i))
f_Cast(P1,{V(0x11),0},WArr(WA1,i))
CMov(P1,0x58F4A8,V(0x11))
f_Cast(P1,{V(0x11),1},WArr(WA1,i))
CMov(P1,0x58F4AC,V(0x11))
f_Cast(P1,{VArr(VA1,j),0},WArr(WA1,i))
CMov(P1,0x58F4B0,VArr(VA1,j))
f_Cast(P1,{VArr(VA1,j),1},WArr(WA1,i))
CMov(P1,0x58F4B4,VArr(VA1,j))
CMov(P1,V(0x11),0x87654321)
CMov(P1,VArr(VA1,j),0xFEDCBA09)
f_Cast(P1,W(0x10),V(0x11))
f_LMov(P1,0x58F4C0,W(0x10))
f_Cast(P1,WArr(WA1,i),V(0x11))
f_LMov(P1,0x58F4C8,WArr(WA1,i))
f_Cast(P1,W(0x10),VArr(VA1,j))
f_LMov(P1,0x58F4D0,W(0x10))
f_Cast(P1,WArr(WA1,i),VArr(VA1,j))
f_LMov(P1,0x58F4D8,WArr(WA1,i))

------------------------------------------------------------------------------------------

360

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-J] f_iCast()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)

f_LMov(P1,W(0x10),_LRead(0x58F480))
f_LMov(P1,0x58F480,W(0x10))
f_iCast(P1,V(0x11),W(0x10))
CMov(P1,0x58F488,V(0x11))
f_iCast(P1,VArr(VA1,j),W(0x10))
CMov(P1,0x58F48C,VArr(VA1,j))
f_LMov(P1,WArr(WA1,i),_LRead(0x58F480))
f_LMov(P1,0x58F4A0,WArr(WA1,i))
f_iCast(P1,V(0x11),WArr(WA1,i))
CMov(P1,0x58F4A8,V(0x11))
f_iCast(P1,VArr(VA1,j),WArr(WA1,i))
CMov(P1,0x58F4AC,VArr(VA1,j))
CMov(P1,V(0x11),_Read(0x57F0F0))
CMov(P1,VArr(VA1,j),_Read(0x57F0F0))
f_iCast(P1,W(0x10),V(0x11))
f_LMov(P1,0x58F4C0,W(0x10))
f_iCast(P1,WArr(WA1,i),V(0x11))
f_LMov(P1,0x58F4C8,WArr(WA1,i))
f_iCast(P1,W(0x10),VArr(VA1,j))
f_LMov(P1,0x58F4D0,W(0x10))
f_iCast(P1,WArr(WA1,i),VArr(VA1,j))
f_LMov(P1,0x58F4D8,WArr(WA1,i))

------------------------------------------------------------------------------------------

361

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-K] f_LAdd()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)
k = CreateVar2(P1,nil,nil,2)

f_LMov(P1,W(0x10),_LRead(0x58F480))
f_LMov(P1,WArr(WA1,i),_LRead(0x58F488))
f_Read(P1,0x58F488,VArr(VA1,j))
f_Read(P1,0x58F48C,VArr(VA1,k))
f_LAdd(P1,0x58F490,"0x1111111111111111",{0x22222222,0x33333333})
f_LAdd(P1,0x58F498,0x44444444,0x55555555)
f_LAdd(P1,0x58F4A0,W(0x10),WArr(WA1,i))
f_LAdd(P1,0x58F4A8,{_Read(0x58F480),_Read(0x58F484)},{VArr(VA1,j),VArr(VA1,k)})
f_LAdd(P1,0x58F4B0,_LRead(0x58F480),_LRead(0x58F488))
f_LAdd(P1,{0x58F4B8,0x58F4BC},_LRead(0x58F480),_LRead(0x58F488))
f_LAdd(P1,W(0x10),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C0,W(0x10))
f_LAdd(P1,WArr(WA1,i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C8,WArr(WA1,i))
f_LAdd(P1,LArr({LA1},i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D0,_LRead(LArr({LA1},i)))
f_LAdd(P1,LArr({LA1},j),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D8,_LRead(LArr({LA1},j)))
f_LAdd(P1,LArr({LA1},0),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E0,_LRead(LArr({LA1},0)))
f_LAdd(P1,{V(0x11),V(0x12)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E8,{V(0x11),V(0x12)})
f_LAdd(P1,{VArr(VA1,j),VArr(VA1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F0,{VArr(VA1,j),VArr(VA1,k)})
f_LAdd(P1,{Arr(A1,j),Arr(A1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F8,{_Read(Arr(A1,j)),_Read(Arr(A1,k))})

------------------------------------------------------------------------------------------

362

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-L] f_LSub()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)
k = CreateVar2(P1,nil,nil,2)

f_LMov(P1,W(0x10),_LRead(0x58F480))
f_LMov(P1,WArr(WA1,i),_LRead(0x58F488))
f_Read(P1,0x58F488,VArr(VA1,j))
f_Read(P1,0x58F48C,VArr(VA1,k))
f_LSub(P1,0x58F490,"0x1111111111111111",{0x22222222,0x33333333})
f_LSub(P1,0x58F498,0x44444444,0x55555555)
f_LSub(P1,0x58F4A0,W(0x10),WArr(WA1,i))
f_LSub(P1,0x58F4A8,{_Read(0x58F480),_Read(0x58F484)},{VArr(VA1,j),VArr(VA1,k)})
f_LSub(P1,0x58F4B0,_LRead(0x58F480),_LRead(0x58F488))
f_LSub(P1,{0x58F4B8,0x58F4BC},_LRead(0x58F480),_LRead(0x58F488))
f_LSub(P1,W(0x10),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C0,W(0x10))
f_LSub(P1,WArr(WA1,i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C8,WArr(WA1,i))
f_LSub(P1,LArr({LA1},i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D0,_LRead(LArr({LA1},i)))
f_LSub(P1,LArr({LA1},j),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D8,_LRead(LArr({LA1},j)))
f_LSub(P1,LArr({LA1},0),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E0,_LRead(LArr({LA1},0)))
f_LSub(P1,{V(0x11),V(0x12)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E8,{V(0x11),V(0x12)})
f_LSub(P1,{VArr(VA1,j),VArr(VA1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F0,{VArr(VA1,j),VArr(VA1,k)})
f_LSub(P1,{Arr(A1,j),Arr(A1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F8,{_Read(Arr(A1,j)),_Read(Arr(A1,k))})

------------------------------------------------------------------------------------------

363

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-M] f_LiSub()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)
k = CreateVar2(P1,nil,nil,2)

f_LMov(P1,W(0x10),_LRead(0x58F480))
f_LMov(P1,WArr(WA1,i),_LRead(0x58F488))
f_Read(P1,0x58F488,VArr(VA1,j))
f_Read(P1,0x58F48C,VArr(VA1,k))
f_LiSub(P1,0x58F490,"0x1111111111111111",{0x22222222,0x33333333})
f_LiSub(P1,0x58F498,0x44444444,0x55555555)
f_LiSub(P1,0x58F4A0,W(0x10),WArr(WA1,i))
f_LiSub(P1,0x58F4A8,{_Read(0x58F480),_Read(0x58F484)},{VArr(VA1,j),VArr(VA1,k)})
f_LiSub(P1,0x58F4B0,_LRead(0x58F480),_LRead(0x58F488))
f_LiSub(P1,{0x58F4B8,0x58F4BC},_LRead(0x58F480),_LRead(0x58F488))
f_LiSub(P1,W(0x10),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C0,W(0x10))
f_LiSub(P1,WArr(WA1,i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C8,WArr(WA1,i))
f_LiSub(P1,LArr({LA1},i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D0,_LRead(LArr({LA1},i)))
f_LiSub(P1,LArr({LA1},j),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D8,_LRead(LArr({LA1},j)))
f_LiSub(P1,LArr({LA1},0),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E0,_LRead(LArr({LA1},0)))
f_LiSub(P1,{V(0x11),V(0x12)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E8,{V(0x11),V(0x12)})
f_LiSub(P1,{VArr(VA1,j),VArr(VA1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F0,{VArr(VA1,j),VArr(VA1,k)})
f_LiSub(P1,{Arr(A1,j),Arr(A1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F8,{_Read(Arr(A1,j)),_Read(Arr(A1,k))})

------------------------------------------------------------------------------------------

364

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-N] f_LNeg()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)
k = CreateVar2(P1,nil,nil,2)

f_LMov(P1,W(0x10),_LRead(0x58F480))
f_LMov(P1,WArr(WA1,i),_LRead(0x58F480))
f_Read(P1,0x58F480,VArr(VA1,j))
f_Read(P1,0x58F484,VArr(VA1,k))
f_LNeg(P1,0x58F488,"0x1111111111111111")
f_LNeg(P1,0x58F490,{0x22222222,0x33333333})
f_LNeg(P1,0x58F498,WArr(WA1,i))
f_LNeg(P1,0x58F4A0,{_Read(0x58F480),_Read(0x58F484)})
f_LNeg(P1,0x58F4A8,{VArr(VA1,j),VArr(VA1,k)})
f_LNeg(P1,0x58F4B0,_LRead(0x58F480))
f_LNeg(P1,{0x58F4B8,0x58F4BC},_LRead(0x58F480))
f_LNeg(P1,W(0x10),_LRead(0x58F480))
f_LMov(P1,0x58F4C0,W(0x10))
f_LNeg(P1,WArr(WA1,i),_LRead(0x58F480))
f_LMov(P1,0x58F4C8,WArr(WA1,i))
f_LNeg(P1,LArr({LA1},i),_LRead(0x58F480))
f_LMov(P1,0x58F4D0,_LRead(LArr({LA1},i)))
f_LNeg(P1,LArr({LA1},j),_LRead(0x58F480))
f_LMov(P1,0x58F4D8,_LRead(LArr({LA1},j)))
f_LNeg(P1,LArr({LA1},0),_LRead(0x58F480))
f_LMov(P1,0x58F4E0,_LRead(LArr({LA1},0)))
f_LNeg(P1,{V(0x11),V(0x12)},_LRead(0x58F480))
f_LMov(P1,0x58F4E8,{V(0x11),V(0x12)})
f_LNeg(P1,{VArr(VA1,j),VArr(VA1,k)},_LRead(0x58F480))
f_LMov(P1,0x58F4F0,{VArr(VA1,j),VArr(VA1,k)})
f_LNeg(P1,{Arr(A1,j),Arr(A1,k)},_LRead(0x58F480))
f_LMov(P1,0x58F4F8,{_Read(Arr(A1,j)),_Read(Arr(A1,k))})

------------------------------------------------------------------------------------------

365

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-O] f_LAbs()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)
k = CreateVar2(P1,nil,nil,2)

f_LMov(P1,W(0x10),_LRead(0x58F480))
f_LMov(P1,WArr(WA1,i),_LRead(0x58F480))
f_Read(P1,0x58F480,VArr(VA1,j))
f_Read(P1,0x58F484,VArr(VA1,k))
f_LAbs(P1,0x58F488,"0x11111111FFFFFFFF")
f_LAbs(P1,0x58F490,{0x22222222,0xEEEEEEEE})
f_LAbs(P1,0x58F498,WArr(WA1,i))
f_LAbs(P1,0x58F4A0,{_Read(0x58F480),_Read(0x58F484)})
f_LAbs(P1,0x58F4A8,{VArr(VA1,j),VArr(VA1,k)})
f_LAbs(P1,0x58F4B0,_LRead(0x58F480))
f_LAbs(P1,{0x58F4B8,0x58F4BC},_LRead(0x58F480))
f_LAbs(P1,W(0x10),_LRead(0x58F480))
f_LMov(P1,0x58F4C0,W(0x10))
f_LAbs(P1,WArr(WA1,i),_LRead(0x58F480))
f_LMov(P1,0x58F4C8,WArr(WA1,i))
f_LAbs(P1,LArr({LA1},i),_LRead(0x58F480))
f_LMov(P1,0x58F4D0,_LRead(LArr({LA1},i)))
f_LAbs(P1,LArr({LA1},j),_LRead(0x58F480))
f_LMov(P1,0x58F4D8,_LRead(LArr({LA1},j)))
f_LAbs(P1,LArr({LA1},0),_LRead(0x58F480))
f_LMov(P1,0x58F4E0,_LRead(LArr({LA1},0)))
f_LAbs(P1,{V(0x11),V(0x12)},_LRead(0x58F480))
f_LMov(P1,0x58F4E8,{V(0x11),V(0x12)})
f_LAbs(P1,{VArr(VA1,j),VArr(VA1,k)},_LRead(0x58F480))
f_LMov(P1,0x58F4F0,{VArr(VA1,j),VArr(VA1,k)})
f_LAbs(P1,{Arr(A1,j),Arr(A1,k)},_LRead(0x58F480))
f_LMov(P1,0x58F4F8,{_Read(Arr(A1,j)),_Read(Arr(A1,k))})

------------------------------------------------------------------------------------------

366

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-P] f_LMul()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)
k = CreateVar2(P1,nil,nil,2)

f_LMov(P1,W(0x10),_LRead(0x58F480))
f_LMov(P1,WArr(WA1,i),_LRead(0x58F488))
f_Read(P1,0x58F488,VArr(VA1,j))
f_Read(P1,0x58F48C,VArr(VA1,k))
f_LMul(P1,0x58F490,"0x1111111111111111",{0x22222222,0x33333333})
f_LMul(P1,0x58F498,0x44444444,0x55555555)
f_LMul(P1,0x58F4A0,W(0x10),WArr(WA1,i))
f_LMul(P1,0x58F4A8,{_Read(0x58F480),_Read(0x58F484)},{VArr(VA1,j),VArr(VA1,k)})
f_LMul(P1,0x58F4B0,_LRead(0x58F480),_LRead(0x58F488))
f_LMul(P1,{0x58F4B8,0x58F4BC},_LRead(0x58F480),_LRead(0x58F488))
f_LMul(P1,W(0x10),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C0,W(0x10))
f_LMul(P1,WArr(WA1,i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C8,WArr(WA1,i))
f_LMul(P1,LArr({LA1},i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D0,_LRead(LArr({LA1},i)))
f_LMul(P1,LArr({LA1},j),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D8,_LRead(LArr({LA1},j)))
f_LMul(P1,LArr({LA1},0),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E0,_LRead(LArr({LA1},0)))
f_LMul(P1,{V(0x11),V(0x12)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E8,{V(0x11),V(0x12)})
f_LMul(P1,{VArr(VA1,j),VArr(VA1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F0,{VArr(VA1,j),VArr(VA1,k)})
f_LMul(P1,{Arr(A1,j),Arr(A1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F8,{_Read(Arr(A1,j)),_Read(Arr(A1,k))})

------------------------------------------------------------------------------------------

367

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-Q] f_LiMul()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)
k = CreateVar2(P1,nil,nil,2)

f_LMov(P1,W(0x10),_LRead(0x58F480))
f_LMov(P1,WArr(WA1,i),_LRead(0x58F488))
f_Read(P1,0x58F488,VArr(VA1,j))
f_Read(P1,0x58F48C,VArr(VA1,k))
f_LiMul(P1,0x58F490,"0x1111111111111111",{0x22222222,0x33333333})
f_LiMul(P1,0x58F498,0x44444444,0x55555555)
f_LiMul(P1,0x58F4A0,W(0x10),WArr(WA1,i))
f_LiMul(P1,0x58F4A8,{_Read(0x58F480),_Read(0x58F484)},{VArr(VA1,j),VArr(VA1,k)})
f_LiMul(P1,0x58F4B0,_LRead(0x58F480),_LRead(0x58F488))
f_LiMul(P1,{0x58F4B8,0x58F4BC},_LRead(0x58F480),_LRead(0x58F488))
f_LiMul(P1,W(0x10),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C0,W(0x10))
f_LiMul(P1,WArr(WA1,i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C8,WArr(WA1,i))
f_LiMul(P1,LArr({LA1},i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D0,_LRead(LArr({LA1},i)))
f_LiMul(P1,LArr({LA1},j),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D8,_LRead(LArr({LA1},j)))
f_LiMul(P1,LArr({LA1},0),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E0,_LRead(LArr({LA1},0)))
f_LiMul(P1,{V(0x11),V(0x12)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E8,{V(0x11),V(0x12)})
f_LiMul(P1,{VArr(VA1,j),VArr(VA1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F0,{VArr(VA1,j),VArr(VA1,k)})
f_LiMul(P1,{Arr(A1,j),Arr(A1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F8,{_Read(Arr(A1,j)),_Read(Arr(A1,k))})

------------------------------------------------------------------------------------------

368

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-R] f_LDiv()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)
k = CreateVar2(P1,nil,nil,2)

f_LMov(P1,W(0x10),_LRead(0x58F480))
f_LMov(P1,WArr(WA1,i),_LRead(0x58F488))
f_Read(P1,0x58F488,VArr(VA1,j))
f_Read(P1,0x58F48C,VArr(VA1,k))
f_LDiv(P1,0x58F490,"0x1111111111111111",{0x22222222,0x33333333})
f_LDiv(P1,0x58F498,0x44444444,0x55555555)
f_LDiv(P1,0x58F4A0,W(0x10),WArr(WA1,i))
f_LDiv(P1,0x58F4A8,{_Read(0x58F480),_Read(0x58F484)},{VArr(VA1,j),VArr(VA1,k)})
f_LDiv(P1,0x58F4B0,_LRead(0x58F480),_LRead(0x58F488))
f_LDiv(P1,{0x58F4B8,0x58F4BC},_LRead(0x58F480),_LRead(0x58F488))
f_LDiv(P1,W(0x10),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C0,W(0x10))
f_LDiv(P1,WArr(WA1,i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C8,WArr(WA1,i))
f_LDiv(P1,LArr({LA1},i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D0,_LRead(LArr({LA1},i)))
f_LDiv(P1,LArr({LA1},j),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D8,_LRead(LArr({LA1},j)))
f_LDiv(P1,LArr({LA1},0),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E0,_LRead(LArr({LA1},0)))
f_LDiv(P1,{V(0x11),V(0x12)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E8,{V(0x11),V(0x12)})
f_LDiv(P1,{VArr(VA1,j),VArr(VA1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F0,{VArr(VA1,j),VArr(VA1,k)})
f_LDiv(P1,{Arr(A1,j),Arr(A1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F8,{_Read(Arr(A1,j)),_Read(Arr(A1,k))})

------------------------------------------------------------------------------------------

369

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-S] f_LiDiv()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)
k = CreateVar2(P1,nil,nil,2)

f_LMov(P1,W(0x10),_LRead(0x58F480))
f_LMov(P1,WArr(WA1,i),_LRead(0x58F488))
f_Read(P1,0x58F488,VArr(VA1,j))
f_Read(P1,0x58F48C,VArr(VA1,k))
f_LiDiv(P1,0x58F490,"0x1111111111111111",{0x22222222,0x33333333})
f_LiDiv(P1,0x58F498,0x44444444,0x55555555)
f_LiDiv(P1,0x58F4A0,W(0x10),WArr(WA1,i))
f_LiDiv(P1,0x58F4A8,{_Read(0x58F480),_Read(0x58F484)},{VArr(VA1,j),VArr(VA1,k)})
f_LiDiv(P1,0x58F4B0,_LRead(0x58F480),_LRead(0x58F488))
f_LiDiv(P1,{0x58F4B8,0x58F4BC},_LRead(0x58F480),_LRead(0x58F488))
f_LiDiv(P1,W(0x10),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C0,W(0x10))
f_LiDiv(P1,WArr(WA1,i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C8,WArr(WA1,i))
f_LiDiv(P1,LArr({LA1},i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D0,_LRead(LArr({LA1},i)))
f_LiDiv(P1,LArr({LA1},j),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D8,_LRead(LArr({LA1},j)))
f_LiDiv(P1,LArr({LA1},0),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E0,_LRead(LArr({LA1},0)))
f_LiDiv(P1,{V(0x11),V(0x12)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E8,{V(0x11),V(0x12)})
f_LiDiv(P1,{VArr(VA1,j),VArr(VA1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F0,{VArr(VA1,j),VArr(VA1,k)})
f_LiDiv(P1,{Arr(A1,j),Arr(A1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F8,{_Read(Arr(A1,j)),_Read(Arr(A1,k))})

------------------------------------------------------------------------------------------

370

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-T] f_LMod()
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)
k = CreateVar2(P1,nil,nil,2)

f_LMov(P1,W(0x10),_LRead(0x58F480))
f_LMov(P1,WArr(WA1,i),_LRead(0x58F488))
f_Read(P1,0x58F488,VArr(VA1,j))
f_Read(P1,0x58F48C,VArr(VA1,k))
f_LMod(P1,0x58F490,"0x1111111111111111",{0x22222222,0x33333333})
f_LMod(P1,0x58F498,0x44444444,0x55555555)
f_LMod(P1,0x58F4A0,W(0x10),WArr(WA1,i))
f_LMod(P1,0x58F4A8,{_Read(0x58F480),_Read(0x58F484)},{VArr(VA1,j),VArr(VA1,k)})
f_LMod(P1,0x58F4B0,_LRead(0x58F480),_LRead(0x58F488))
f_LMod(P1,{0x58F4B8,0x58F4BC},_LRead(0x58F480),_LRead(0x58F488))
f_LMod(P1,W(0x10),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C0,W(0x10))
f_LMod(P1,WArr(WA1,i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C8,WArr(WA1,i))
f_LMod(P1,LArr({LA1},i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D0,_LRead(LArr({LA1},i)))
f_LMod(P1,LArr({LA1},j),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D8,_LRead(LArr({LA1},j)))
f_LMod(P1,LArr({LA1},0),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E0,_LRead(LArr({LA1},0)))

f_LMod(P1,{V(0x11),V(0x12)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E8,{V(0x11),V(0x12)})
f_LMod(P1,{VArr(VA1,j),VArr(VA1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F0,{VArr(VA1,j),VArr(VA1,k)})
f_LMod(P1,{Arr(A1,j),Arr(A1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F8,{_Read(Arr(A1,j)),_Read(Arr(A1,k))})

------------------------------------------------------------------------------------------

371

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-U] f_LiMod()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)
k = CreateVar2(P1,nil,nil,2)

f_LMov(P1,W(0x10),_LRead(0x58F480))
f_LMov(P1,WArr(WA1,i),_LRead(0x58F488))
f_Read(P1,0x58F488,VArr(VA1,j))
f_Read(P1,0x58F48C,VArr(VA1,k))
f_LiMod(P1,0x58F490,"0x1111111111111111",{0x22222222,0x33333333})
f_LiMod(P1,0x58F498,0x44444444,0x55555555)
f_LiMod(P1,0x58F4A0,W(0x10),WArr(WA1,i))
f_LiMod(P1,0x58F4A8,{_Read(0x58F480),_Read(0x58F484)},{VArr(VA1,j),VArr(VA1,k)})
f_LiMod(P1,0x58F4B0,_LRead(0x58F480),_LRead(0x58F488))
f_LiMod(P1,{0x58F4B8,0x58F4BC},_LRead(0x58F480),_LRead(0x58F488))
f_LiMod(P1,W(0x10),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C0,W(0x10))
f_LiMod(P1,WArr(WA1,i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C8,WArr(WA1,i))
f_LiMod(P1,LArr({LA1},i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D0,_LRead(LArr({LA1},i)))
f_LiMod(P1,LArr({LA1},j),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D8,_LRead(LArr({LA1},j)))
f_LiMod(P1,LArr({LA1},0),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E0,_LRead(LArr({LA1},0)))
f_LiMod(P1,{V(0x11),V(0x12)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E8,{V(0x11),V(0x12)})
f_LiMod(P1,{VArr(VA1,j),VArr(VA1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F0,{VArr(VA1,j),VArr(VA1,k)})
f_LiMod(P1,{Arr(A1,j),Arr(A1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F8,{_Read(Arr(A1,j)),_Read(Arr(A1,k))})

------------------------------------------------------------------------------------------

372

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-V] f_LlShift()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)
k = CreateVar2(P1,nil,nil,2)

f_LMov(P1,W(0x10),_LRead(0x58F480))
f_LMov(P1,WArr(WA1,i),_LRead(0x58F488))
f_Read(P1,0x58F488,VArr(VA1,j))
f_Read(P1,0x58F48C,VArr(VA1,k))
f_LlShift(P1,0x58F490,"0x1234567890ABCDEF",16)
f_LlShift(P1,0x58F498,0x12345678,_Read(0x58F488))
f_LlShift(P1,0x58F4A0,W(0x10),WArr(WA1,i))
f_LlShift(P1,0x58F4A8,{_Read(0x58F480),_Read(0x58F484)},VArr(VA1,j))
f_LlShift(P1,0x58F4B0,_LRead(0x58F480),_LRead(0x58F488))
f_LlShift(P1,{0x58F4B8,0x58F4BC},_LRead(0x58F480),_LRead(0x58F488))
f_LlShift(P1,W(0x10),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C0,W(0x10))
f_LlShift(P1,WArr(WA1,i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C8,WArr(WA1,i))
f_LlShift(P1,LArr({LA1},i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D0,_LRead(LArr({LA1},i)))
f_LlShift(P1,LArr({LA1},j),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D8,_LRead(LArr({LA1},j)))
f_LlShift(P1,LArr({LA1},0),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E0,_LRead(LArr({LA1},0)))
f_LlShift(P1,{V(0x11),V(0x12)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E8,{V(0x11),V(0x12)})
f_LlShift(P1,{VArr(VA1,j),VArr(VA1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F0,{VArr(VA1,j),VArr(VA1,k)})
f_LlShift(P1,{Arr(A1,j),Arr(A1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F8,{_Read(Arr(A1,j)),_Read(Arr(A1,k))})

------------------------------------------------------------------------------------------

373

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-W] f_LAnd()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)
k = CreateVar2(P1,nil,nil,2)

f_LMov(P1,W(0x10),_LRead(0x58F480))
f_LMov(P1,WArr(WA1,i),_LRead(0x58F488))
f_Read(P1,0x58F488,VArr(VA1,j))
f_Read(P1,0x58F48C,VArr(VA1,k))
f_LAnd(P1,0x58F490,"0xFF00FF00FF00FF00",{0xF0F0F0F0,0xF0F0F0F0})
f_LAnd(P1,0x58F498,0xF0F0F0F0,0xFF00FF00)
f_LAnd(P1,0x58F4A0,W(0x10),WArr(WA1,i))
f_LAnd(P1,0x58F4A8,{_Read(0x58F480),_Read(0x58F484)},{VArr(VA1,j),VArr(VA1,k)})
f_LAnd(P1,0x58F4B0,_LRead(0x58F480),_LRead(0x58F488))
f_LAnd(P1,{0x58F4B8,0x58F4BC},_LRead(0x58F480),_LRead(0x58F488))
f_LAnd(P1,W(0x10),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C0,W(0x10))
f_LAnd(P1,WArr(WA1,i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C8,WArr(WA1,i))
f_LAnd(P1,LArr({LA1},i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D0,_LRead(LArr({LA1},i)))
f_LAnd(P1,LArr({LA1},j),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D8,_LRead(LArr({LA1},j)))
f_LAnd(P1,LArr({LA1},0),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E0,_LRead(LArr({LA1},0)))
f_LAnd(P1,{V(0x11),V(0x12)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E8,{V(0x11),V(0x12)})
f_LAnd(P1,{VArr(VA1,j),VArr(VA1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F0,{VArr(VA1,j),VArr(VA1,k)})
f_LAnd(P1,{Arr(A1,j),Arr(A1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F8,{_Read(Arr(A1,j)),_Read(Arr(A1,k))})

------------------------------------------------------------------------------------------

374

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-X] f_LOr()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)
k = CreateVar2(P1,nil,nil,2)

f_LMov(P1,W(0x10),_LRead(0x58F480))
f_LMov(P1,WArr(WA1,i),_LRead(0x58F488))
f_Read(P1,0x58F488,VArr(VA1,j))
f_Read(P1,0x58F48C,VArr(VA1,k))
f_LOr(P1,0x58F490,"0xFF00FF00FF00FF00",{0xF0F0F0F0,0xF0F0F0F0})
f_LOr(P1,0x58F498,0xF0F0F0F0,0xFF00FF00)
f_LOr(P1,0x58F4A0,W(0x10),WArr(WA1,i))
f_LOr(P1,0x58F4A8,{_Read(0x58F480),_Read(0x58F484)},{VArr(VA1,j),VArr(VA1,k)})
f_LOr(P1,0x58F4B0,_LRead(0x58F480),_LRead(0x58F488))
f_LOr(P1,{0x58F4B8,0x58F4BC},_LRead(0x58F480),_LRead(0x58F488))
f_LOr(P1,W(0x10),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C0,W(0x10))
f_LOr(P1,WArr(WA1,i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C8,WArr(WA1,i))
f_LOr(P1,LArr({LA1},i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D0,_LRead(LArr({LA1},i)))
f_LOr(P1,LArr({LA1},j),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D8,_LRead(LArr({LA1},j)))
f_LOr(P1,LArr({LA1},0),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E0,_LRead(LArr({LA1},0)))
f_LOr(P1,{V(0x11),V(0x12)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E8,{V(0x11),V(0x12)})
f_LOr(P1,{VArr(VA1,j),VArr(VA1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F0,{VArr(VA1,j),VArr(VA1,k)})
f_LOr(P1,{Arr(A1,j),Arr(A1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F8,{_Read(Arr(A1,j)),_Read(Arr(A1,k))})

------------------------------------------------------------------------------------------

375

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-Y] f_LXor()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)
k = CreateVar2(P1,nil,nil,2)

f_LMov(P1,W(0x10),_LRead(0x58F480))
f_LMov(P1,WArr(WA1,i),_LRead(0x58F488))
f_Read(P1,0x58F488,VArr(VA1,j))
f_Read(P1,0x58F48C,VArr(VA1,k))
f_LXor(P1,0x58F490,"0xFF00FF00FF00FF00",{0xF0F0F0F0,0xF0F0F0F0})
f_LXor(P1,0x58F498,0xF0F0F0F0,0xFF00FF00)
f_LXor(P1,0x58F4A0,W(0x10),WArr(WA1,i))
f_LXor(P1,0x58F4A8,{_Read(0x58F480),_Read(0x58F484)},{VArr(VA1,j),VArr(VA1,k)})
f_LXor(P1,0x58F4B0,_LRead(0x58F480),_LRead(0x58F488))
f_LXor(P1,{0x58F4B8,0x58F4BC},_LRead(0x58F480),_LRead(0x58F488))
f_LXor(P1,W(0x10),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C0,W(0x10))
f_LXor(P1,WArr(WA1,i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4C8,WArr(WA1,i))
f_LXor(P1,LArr({LA1},i),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D0,_LRead(LArr({LA1},i)))
f_LXor(P1,LArr({LA1},j),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4D8,_LRead(LArr({LA1},j)))
f_LXor(P1,LArr({LA1},0),_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E0,_LRead(LArr({LA1},0)))
f_LXor(P1,{V(0x11),V(0x12)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4E8,{V(0x11),V(0x12)})
f_LXor(P1,{VArr(VA1,j),VArr(VA1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F0,{VArr(VA1,j),VArr(VA1,k)})
f_LXor(P1,{Arr(A1,j),Arr(A1,k)},_LRead(0x58F480),_LRead(0x58F488))
f_LMov(P1,0x58F4F8,{_Read(Arr(A1,j)),_Read(Arr(A1,k))})

------------------------------------------------------------------------------------------

376

------------------------------------------------------------------------------------------

『 22장 : 64비트 변수 연산 함수 (W) 』

-----------------------------------------------------------------------------------------[예제 22-Z] f_LNot()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CWariable(P1,0x10) CVariable(P1,0x11) CVariable(P1,0x12)
WA1 = CWArray(P1,10)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
LA1 = LArray(P1,1000)
CJumpEnd(AllPlayers,0)
i = CreateWar2(P1,nil,nil,{1,1})
j = CreateVar2(P1,nil,nil,1)
k = CreateVar2(P1,nil,nil,2)

f_LMov(P1,W(0x10),_LRead(0x58F480))
f_LMov(P1,WArr(WA1,i),_LRead(0x58F480))
f_Read(P1,0x58F480,VArr(VA1,j))
f_Read(P1,0x58F484,VArr(VA1,k))
f_LNot(P1,0x58F488,"0xFFFF0000FFFF0000")
f_LNot(P1,0x58F490,{0x0000FFFF,0x0000FFFF})
f_LNot(P1,0x58F498,WArr(WA1,i))
f_LNot(P1,0x58F4A0,{_Read(0x58F480),_Read(0x58F484)})
f_LNot(P1,0x58F4A8,{VArr(VA1,j),VArr(VA1,k)})
f_LNot(P1,0x58F4B0,_LRead(0x58F480))
f_LNot(P1,{0x58F4B8,0x58F4BC},_LRead(0x58F480))
f_LNot(P1,W(0x10),_LRead(0x58F480))
f_LMov(P1,0x58F4C0,W(0x10))
f_LNot(P1,WArr(WA1,i),_LRead(0x58F480))
f_LMov(P1,0x58F4C8,WArr(WA1,i))
f_LNot(P1,LArr({LA1},i),_LRead(0x58F480))
f_LMov(P1,0x58F4D0,_LRead(LArr({LA1},i)))
f_LNot(P1,LArr({LA1},j),_LRead(0x58F480))
f_LMov(P1,0x58F4D8,_LRead(LArr({LA1},j)))
f_LNot(P1,LArr({LA1},0),_LRead(0x58F480))
f_LMov(P1,0x58F4E0,_LRead(LArr({LA1},0)))
f_LNot(P1,{V(0x11),V(0x12)},_LRead(0x58F480))
f_LMov(P1,0x58F4E8,{V(0x11),V(0x12)})
f_LNot(P1,{VArr(VA1,j),VArr(VA1,k)},_LRead(0x58F480))
f_LMov(P1,0x58F4F0,{VArr(VA1,j),VArr(VA1,k)})
f_LNot(P1,{Arr(A1,j),Arr(A1,k)},_LRead(0x58F480))
f_LMov(P1,0x58F4F8,{_Read(Arr(A1,j)),_Read(Arr(A1,k))})

------------------------------------------------------------------------------------------

377

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------[예제 23-1] SV(), _SMem()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
SV4 = CSVariable2(P1,0x10,4,"X","X",{0x1000,0x2000,0x3000,0x4000})
CJumpEnd(AllPlayers,0)
CMov(P1,0x58F480,_SCast(SV(SV4,1))) CMov(P1,0x58F484,_SCast(SV(SV4,2)))
CMov(P1,0x58F488,_SCast(SV(SV4,3))) CMov(P1,0x58F48C,_SCast(SV(SV4,4)))
CRead(P1,0x58F490,_SMem(SV(SV4,1),0x15C))

CRead(P1,0x58F494,_SMem(SV(SV4,2),0x15C))
CRead(P1,0x58F498,_SMem(SV(SV4,3),0x15C))
CRead(P1,0x58F49C,_SMem(SV(SV4,4),0x15C))
CRead(P1,0x58F4A0,_SMem(SV(SV4))[1]) CRead(P1,0x58F4A4,_SMem(SV(SV4))[2])
CRead(P1,0x58F4A8,_SMem(SV(SV4))[3]) CRead(P1,0x58F4AC,_SMem(SV(SV4))[4])
CRead(P1,0x58F4B0,_SMem(SV(SV4,{4,3,2,1}))[1])
CRead(P1,0x58F4B4,_SMem(SV(SV4,{4,3,2,1}))[2])

CRead(P1,0x58F4B8,_SMem(SV(SV4,{4,3,2,1}))[3])
CRead(P1,0x58F4BC,_SMem(SV(SV4,{4,3,2,1}))[4])
CRead(P1,0x58F4C0,_SMem(SV(SV4,1))) CRead(P1,0x58F4C4,_SMem(SV(SV4,2)))
CRead(P1,0x58F4C8,_SMem(SV(SV4,3))) CRead(P1,0x58F4CC,_SMem(SV(SV4,4)))
CRead(P1,0x58F4D0,_SMem(SV(SV4,1),{0x15C,{0x40}}))
CRead(P1,0x58F4D4,_SMem(SV(SV4,2),{0x15C,{0x40}}))
CRead(P1,0x58F4D8,_SMem(SV(SV4,3),{0x15C,{0x40}}))
CRead(P1,0x58F4DC,_SMem(SV(SV4,4),{0x15C,{0x40}}))
CRead(P1,0x58F4E0,_SMem(SV(SV4),{0x15C,{0x40}})[1])
CRead(P1,0x58F4E4,_SMem(SV(SV4),{0x15C,{0x40}})[2])
CRead(P1,0x58F4E8,_SMem(SV(SV4),{0x15C,{0x40}})[3])
CRead(P1,0x58F4EC,_SMem(SV(SV4),{0x15C,{0x40}})[4])
CRead(P1,0x58F4F0,_SMem(SV(SV4,{4,3,2,1}),{0x15C,{0x40}})[1])
CRead(P1,0x58F4F4,_SMem(SV(SV4,{4,3,2,1}),{0x15C,{0x40}})[2])
CRead(P1,0x58F4F8,_SMem(SV(SV4,{4,3,2,1}),{0x15C,{0x40}})[3])

CRead(P1,0x58F4FC,_SMem(SV(SV4,{4,3,2,1}),{0x15C,{0x40}})[4])

------------------------------------------------------------------------------------------

378

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------[예제 23-2] SVArr(), SVArrX(), ConvertSVArr()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
SVA4 = SVArray(P1,10,4)
CJumpEnd(AllPlayers,0)
i = CreateVar2(P1,nil,nil,1)
j,k = CreateVArs(2,P1)
SMov(P1,SVArr(SVA4,0),{0x00000000,0x11111111,0x22222222,0x33333333})
SMov(P1,{0x58F480,0x58F484,0x58F488,0x58F48C},SVArr(SVA4,0))
SMov(P1,SVArr(SVA4,i),{0x44444444,0x55555555,0x66666666,0x77777777})
SMov(P1,{0x58F490,0x58F494,0x58F498,0x58F49C},SVArr(SVA4,i))
SMov(P1,SVArr(SVA4,Vi(i[2],1)),{0x88888888,0x99999999,0xAAAAAAAA,0xBBBBBBBB})

SMov(P1,{0x58F4A0,0x58F4A4,0x58F4A8,0x58F4AC},SVArr(SVA4,Vi(i[2],1)))
ConvertSVArr(P1,j,k,i,10)
SMov(P1,SVArrX(SVA4,0),{0xCCCCCCCC,0xDDDDDDDD,0xEEEEEEEE,0xFFFFFFFF})
SMov(P1,{0x58F4B0,0x58F4B4,0x58F4B8,0x58F4BC},SVArrX(SVA4,0))
SMov(P1,SVArrX(SVA4,j,k),{0x00001111,0x22223333,0x44445555,0x66667777})
SMov(P1,{0x58F4C0,0x58F4C4,0x58F4C8,0x58F4CC},SVArrX(SVA4,j,k))
SMov(P1,SVArrX(SVA4,Vi( j[2],2),k),{0x88889999,0xAAAABBBB,0xCCCCDDDD,0xEEEEFFFF})
SMov(P1,{0x58F4D0,0x58F4D4,0x58F4D8,0x58F4DC},SVArrX(SVA4,Vi( j[2],2),k))
------------------------------------------------------------------------------------------

379

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------[예제 23-3] SCallLabel1(), SCallLabel2(), SCallLabel1X(), SCallLabel2X(),
CallSVariable(), CallSVariableX(), CSVariable2(), GetSVArray()
CJump(AllPlayers,0)
local SVs = {}
for i = 0, 7 do
local SVTemp = CSVariable2(P1,0x10+i,4,{0x58F480+0x10*i,0x58F484+0x10*i,0x58F488+0x10*i,0x58F48C+0x10*i},SetTo,
{0x11111111*(i+1),0x11111111*(i+1),0x11111111*(i+1),0x11111111*(i+1)})
table.insert(SVs,SVTemp)
end
SVA4 = GetSVArray(SVs[1],10)
CJumpEnd(AllPlayers,0)
DoActionsX(P1,{SetMemory(0x58F480,SetTo,0), SetMemory(0x58F484,SetTo,0),
SetMemory(0x58F488,SetTo,0), SetMemory(0x58F48C,SetTo,0),
SetMemory(0x58F490,SetTo,0), SetMemory(0x58F494,SetTo,0),
SetMemory(0x58F498,SetTo,0), SetMemory(0x58F49C,SetTo,0),
SetMemory(0x58F4A0,SetTo,0), SetMemory(0x58F4A4,SetTo,0),
SetMemory(0x58F4A8,SetTo,0), SetMemory(0x58F4AC,SetTo,0),
SetMemory(0x58F4B0,SetTo,0), SetMemory(0x58F4B4,SetTo,0),
SetMemory(0x58F4B8,SetTo,0), SetMemory(0x58F4BC,SetTo,0),
SetMemory(0x58F4C0,SetTo,0), SetMemory(0x58F4C4,SetTo,0),
SetMemory(0x58F4C8,SetTo,0), SetMemory(0x58F4CC,SetTo,0),
SetMemory(0x58F4D0,SetTo,0), SetMemory(0x58F4D4,SetTo,0),
SetMemory(0x58F4D8,SetTo,0), SetMemory(0x58F4DC,SetTo,0),
SetMemory(0x58F4E0,SetTo,0), SetMemory(0x58F4E4,SetTo,0),
SetMemory(0x58F4E8,SetTo,0), SetMemory(0x58F4EC,SetTo,0),
SetMemory(0x58F4F0,SetTo,0), SetMemory(0x58F4F4,SetTo,0),
SetMemory(0x58F4F8,SetTo,0), SetMemory(0x58F4FC,SetTo,0),
})

Trigger {

players = {P1},
conditions = {
},
actions = {

Label(0);
Accumulate(P1,Exactly,1,Ore);
SCallLabel1(P1,SVs[1]);
PreserveTrigger();

}
}
DoActionsX(P1,SCallLabel2(P1,SVs[1])) -- RecoverNext
Trigger {

players = {P1},
conditions = {
},
actions = {

Label(0);
Accumulate(P1,Exactly,-1,Ore);
SCallLabel1X(SV(SVs[2]));
PreserveTrigger();

}
}
DoActionsX(P1,SCallLabel2X(SV(SVs[2]))) -- RecoverNext

CallSVariable(P1,P1,SVs[3],"X",Accumulate(P1,Exactly,1,Gas))
CallSVariableX(P1,SV(SVs[4]),Accumulate(P1,Exactly,-1,Gas))

CallSVariable(P1,P1,SVs[5],"X")
CallSVariableX(P1,SV(SVs[6]))

------------------------------------------------------------------------------------------

380

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------[예제 23-4] SVariableX(), SetSVariableX(), SVariable(), SetSVariable(), SVArrayX(), SetSVArrayX(),
CSVar(), SetCSVar(), NSVar(), SetNSVar(), CSVAar(), SetCSVAar()

CJump(AllPlayers,0)
SV4 = CSVariable(P1,0x10,4)
SVA4 = SVArray(P1,10,4)
CJumpEnd(AllPlayers,0)
DoActionsX(P1,{SetCSVar("X",SV4,1,SetTo,0x11111111),SetCSVar("X",SV4,2,SetTo,0x11112222),
SetCSVar("X",SV4,3,SetTo,0x22221111),SetCSVar("X",SV4,4,SetTo,0x22222222)})
TriggerX(P1,{CSVar("X",SV4,1,Exactly,0x11111111),CSVar("X",SV4,2,Exactly,0x11112222),
CSVar("X",SV4,3,Exactly,0x22221111),CSVar("X",SV4,4,Exactly,0x22222222)},
{SetMemoryX(0x58F480,SetTo,0x1,0xF)},{Preserved})
DoActionsX(P1,{SetNSVar(SV(SV4,1),SetTo,0x33333333),SetNSVar(SV(SV4,2),SetTo,0x33334444),
SetNSVar(SV(SV4,3),SetTo,0x44443333),SetNSVar(SV(SV4,4),SetTo,0x44444444)})
TriggerX(P1,{NSVar(SV(SV4,1),Exactly,0x33333333),NSVar(SV(SV4,2),Exactly,0x33334444),
NSVar(SV(SV4,3),Exactly,0x44443333),NSVar(SV(SV4,4),Exactly,0x44444444)},
{SetMemoryX(0x58F480,SetTo,0x20,0xF0)},{Preserved})
DoActionsX(P1,{SetCSVAar(SVArr(SVA4,0,1),SetTo,0x55555555),SetCSVAar(SVArr(SVA4,0,2),SetTo,0x55556666),
SetCSVAar(SVArr(SVA4,0,3),SetTo,0x66665555),SetCSVAar(SVArr(SVA4,0,4),SetTo,0x66666666)})
TriggerX(P1,{CSVAar(SVArr(SVA4,0,1),Exactly,0x55555555),CSVAar(SVArr(SVA4,0,2),Exactly,0x55556666),
CSVAar(SVArr(SVA4,0,3),Exactly,0x66665555),CSVAar(SVArr(SVA4,0,4),Exactly,0x66666666)},
{SetMemoryX(0x58F480,SetTo,0x300,0xF00)},{Preserved})
DoActionsX(P1,{SetSVariableX("X",SV4,1,"Value",SetTo,0x77777777),SetSVariableX("X",SV4,2,"Value",SetTo,0x77778888),
SetSVariableX("X",SV4,3,"Value",SetTo,0x88887777),SetSVariableX("X",SV4,4,"Value",SetTo,0x88888888)})
TriggerX(P1,{SVariableX("X",SV4,1,"Value",Exactly,0x77777777),SVariableX("X",SV4,2,"Value",Exactly,0x77778888),
SVariableX("X",SV4,3,"Value",Exactly,0x88887777),SVariableX("X",SV4,4,"Value",Exactly,0x88888888)},
{SetMemoryX(0x58F480,SetTo,0x4000,0xF000)},{Preserved})

DoActionsX(P1,{SetSVariable(SV(SV4,1),"Value",SetTo,0x99999999),SetSVariable(SV(SV4,2),"Value",SetTo,0x9999AAAA),
SetSVariable(SV(SV4,3),"Value",SetTo,0xAAAA9999),SetSVariable(SV(SV4,4),"Value",SetTo,0xAAAAAAAA)})
TriggerX(P1,{SVariable(SV(SV4,1),"Value",Exactly,0x99999999),SVariable(SV(SV4,2),"Value",Exactly,0x9999AAAA),
SVariable(SV(SV4,3),"Value",Exactly,0xAAAA9999),SVariable(SV(SV4,4),"Value",Exactly,0xAAAAAAAA)},
{SetMemoryX(0x58F480,SetTo,0x50000,0xF0000)},{Preserved})
DoActionsX(P1,{SetSVArrayX(SVArr(SVA4,0,1),"Value",SetTo,0xBBBBBBBB),SetSVArrayX(SVArr(SVA4,0,2),"Value",SetTo,0xBBBBCCCC),
SetSVArrayX(SVArr(SVA4,0,3),"Value",SetTo,0xCCCCBBBB),SetSVArrayX(SVArr(SVA4,0,4),"Value",SetTo,0xCCCCCCCC)})
TriggerX(P1,{SVArrayX(SVArr(SVA4,0,1),"Value",Exactly,0xBBBBBBBB),SVArrayX(SVArr(SVA4,0,2),"Value",Exactly,0xBBBBCCCC),
SVArrayX(SVArr(SVA4,0,3),"Value",Exactly,0xCCCCBBBB),SVArrayX(SVArr(SVA4,0,4),"Value",Exactly,0xCCCCCCCC)},
{SetMemoryX(0x58F480,SetTo,0x600000,0xF00000)},{Preserved})

------------------------------------------------------------------------------------------

381

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------[예제 23-5] TCSVar(), TSetCSVar(), TNSVar(), TSetNSVar(), TCSVAar(), TSetCSVAar(),
TSVariableX(), TSetSVariableX(), TSVariable(), TSetSVariable(), TSVArrayX(), TSetSVArrayX()
CJump(AllPlayers,0)
SV4 = CSVariable(P1,0x10,4)
SVA2 = SVArray(P1,10,2)
CJumpEnd(AllPlayers,0)
M1 = CreateVar2(P1,nil,nil,0xFFFF0000)
M2 = CreateVar2(P1,nil,nil,0x0000FFFF)
V1 = CreateVar2(P1,nil,nil,0x11111111)
V2 = CreateVar2(P1,nil,nil,0x22222222)
V3 = CreateVar2(P1,nil,nil,0x33333333)
V4 = CreateVar2(P1,nil,nil,0x44444444)
V5 = CreateVar2(P1,nil,nil,0x55555555)
V6 = CreateVar2(P1,nil,nil,0x66666666)
VM1 = CreateVar2(P1,nil,nil,0x11110000)
VM2 = CreateVar2(P1,nil,nil,0x00002222)
VM3 = CreateVar2(P1,nil,nil,0x33330000)
VM4 = CreateVar2(P1,nil,nil,0x00004444)
VM5 = CreateVar2(P1,nil,nil,0x55550000)
VM6 = CreateVar2(P1,nil,nil,0x00006666)
CDoActions(P1,{TSetCSVar("X",SV4,1,SetTo,V1,M1),TSetSVariableX("X",SV4,2,"Value",SetTo,V2,M2),
TSetNSVar(SV(SV4,3),SetTo,V3,M1),TSetSVariable(SV(SV4,4),"Value",SetTo,V4,M2),
TSetCSVAar(SVArrX(SVA2,0,nil,1),SetTo,V5,M1),TSetSVArrayX(SVArrX(SVA2,0,nil,2),"Value",SetTo,V6,M2)})
CTrigger(P1,{TCSVar("X",SV4,1,Exactly,VM1,M1)},{SetSVariableX("X",SV4,1,"EPD",SetTo,
EPD(0x58F480))},{Preserved})
CTrigger(P1,{TSVariableX("X",SV4,2,"Value",Exactly,VM2,M2)},{SetSVariableX("X",SV4,2,"EPD",SetTo,
EPD(0x58F484))},{Preserved})
CTrigger(P1,{TNSVar(SV(SV4,3),Exactly,VM3,M1)},{SetSVariableX("X",SV4,3,"EPD",SetTo,
EPD(0x58F488))},{Preserved})
CTrigger(P1,{TSVariable(SV(SV4,4),"Value",Exactly,VM4,M2)},{SetSVariableX("X",SV4,4,"EPD",SetTo,
EPD(0x58F48C))},{Preserved})
CTrigger(P1,{TCSVAar(SVArrX(SVA2,0,nil,1),Exactly,VM5,M1)},{SetSVArrayX(SVArrX(SVA2,0,nil,1),"EPD",SetTo,
EPD(0x58F490))},{Preserved})
CTrigger(P1,{TSVArrayX(SVArrX(SVA2,0,nil,1),"Value",Exactly,VM6,M2)},{SetSVArrayX(SVArrX(SVA2,0,nil,2),"EPD",SetTo,
EPD(0x58F494))},{Preserved})

CallSVariable(P1,"X",SV4)
CallSVariableX(P1,SVArr(SVA2,0))

------------------------------------------------------------------------------------------

382

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------[예제 23-6] TTCSVar(), TTNSVar(), TTCSVAar()
CJump(AllPlayers,0)
SV4 = CSVariable(P1,0x10,4)
SVA2 = SVArray(P1,10,2)
CJumpEnd(AllPlayers,0)
CDoActions(P1,{
TSetNSVar(SV(SV4,1),SetTo,_Read(0x57F0F0)),
TSetNSVar(SV(SV4,2),SetTo,_Read(0x57F0F0)),
TSetNSVar(SV(SV4,3),SetTo,_Read(0x57F0F0)),
TSetNSVar(SV(SV4,4),SetTo,_Read(0x57F0F0)),
TSetCSVAar(SVArr(SVA2,0,1),SetTo,_Read(0x57F0F0)),
TSetCSVAar(SVArr(SVA2,0,2),SetTo,_Read(0x57F0F0)),
})
CTrigger(P1,{TCSVar("X",SV4,1,Exactly,_Read(0x57F120))},
{DisplayText("\x1DA==B")},{preserved})
CTrigger(P1,{TTCSVar("X",SV4,2,NotSame,_Read(0x57F120))},
{DisplayText("\x1BA!=B")},{preserved})
CTrigger(P1,{TNSVar(SV(SV4,3),AtLeast,_Read(0x57F120))},
{DisplayText("\x19A>=B")},{preserved})
CTrigger(P1,{TTNSVar(SV(SV4,4),Above,_Read(0x57F120))},
{DisplayText("\x03A>B")},{preserved})
CTrigger(P1,{TCSVAar(SVArr(SVA2,0,1),AtMost,_Read(0x57F120))},
{DisplayText("\x02A<=B")},{preserved})
CTrigger(P1,{TTCSVAar(SVArr(SVA2,0,2),Below,_Read(0x57F120))},
{DisplayText("\x1EA<B")},{preserved})

------------------------------------------------------------------------------------------

383

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------[예제 23-A] SMov()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
CVariable(P1,0x12) CVariable(P1,0x13) CVariable(P1,0x14) CVariable(P1,0x15)
SV1 = CSVariable(P1,0x10,2)
SV2 = CSVariable(P1,0x11,2)
SV3 = CSVariable(P1,0x20,4)
SVA1 = SVArray(P1,10,2)
SVA2 = SVArray(P1,10,4)
CJumpEnd(AllPlayers,0)
i = CreateVarArr(5,P1)
l = CreateVarArr(5,P1)
for n = 1, 5 do
CRead(P1,i[n],0x57F0F0)
CRead(P1,l[n],0x57F120)
end
j = CreateVar2(P1,nil,nil,1)
k = CreateVar2(P1,nil,nil,2)

SMov(P1,{0x58F480,V(0x12),
{"X",0x13,0x15C,0},Arr(A1,j),VArr(VA1,j),0x58F484,V(0x14),{"X",0x15,0x15C,0},Arr(A1,k),VArr(VA1,k)},
{i[1],i[2],i[3],i[4],i[5],l[1],l[2],l[3],l[4],l[5]})
SMov(P1,{0x58F488,0x58F48C,0x58F490,0x58F494,0x58F498,0x58F49C},
{V(0x13),V(0x15),_Read(Arr(A1,j)),_Read(Arr(A1,k)),0x11111111,0x22222222})
SMov(P1,SV(SV2),SV(SV1))
SMov(P1,SV(SV1),{V(0x12),VArr(VA1,j)})
SMov(P1,SVArr(SVA1,j),{V(0x14),VArr(VA1,k)})
SMov(P1,SVArr(SVA1,k),SVArr(SVA1,j))
SMov(P1,{0x58F4A0,0x58F4A4},SV(SV1))
SMov(P1,{0x58F4A8,0x58F4AC},SV(SV2))
SMov(P1,{0x58F4B0,0x58F4B4},SVArr(SVA1,j))
SMov(P1,{0x58F4B8,0x58F4BC},SVArr(SVA1,k))

SMov(P1,SV(SV3,{1,2}),SVArr(SVA1,j))
SMov(P1,SV(SV3,{3,4}),SVArr(SVA1,k))
SMov(P1,SVArr(SVA2,j,{1,2}),SV(SV1))
SMov(P1,SVArr(SVA2,j,{3,4}),SV(SV2))
SMov(P1,{{"X",0x13,0x15C,0},Arr(A1,j),{"X",0x15,0x15C,0},Arr(A1,k)},SV(SV3))
SMov(P1,{V(0x12),VArr(VA1,j),V(0x14),VArr(VA1,k)},SVArr(SVA2,j))
SMov(P1,{0x58F4C0,0x58F4C4,0x58F4C8,0x58F4CC,0x58F4D0,0x58F4D4,0x58F4D8,0x58F4DC},
{V(0x13),_Read(Arr(A1,j)),V(0x15),_Read(Arr(A1,k)),V(0x12),VArr(VA1,j),V(0x14),VArr(VA1,k)})
SMov(P1,{0x58F4E0,0x58F4E4},SV(SV3,{1,2}))
SMov(P1,{0x58F4E8,0x58F4EC},SVArr(SVA2,j,{3,4}))

------------------------------------------------------------------------------------------

384

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------[예제 23-B] MovS()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
CVariable(P1,0x12)
CVariable(P1,0x13)
CVariable(P1,0x14)
CVariable(P1,0x15)
SV1 = CSVariable(P1,0x10,8)
SV2 = CSVariable(P1,0x11,8)
SVA1 = SVArray(P1,10,8)
SVA2 = SVArray(P1,10,8)
CJumpEnd(AllPlayers,0)
j = CreateVar2(P1,nil,nil,1)
k = CreateVar2(P1,nil,nil,2)
SMov(P1,SV(SV1),{0x11111111,0x22222222,0x33333333,0x44444444,0x55555555,0x66666666,0x77777777,0x88888888})
SMov(P1,SV(SV2),{0x88888888,0x88888888,0x88888888,0x88888888,0x88888888,0x88888888,0x88888888,0x88888888})

MovS(P1,SVArr(SVA1,j),SV(SV1),SetTo)
MovS(P1,SV(SV2),SVArr(SVA1,j),Add)
SMov(P1,{0x58F480,0x58F484,0x58F488,0x58F48C,0x58F490,0x58F494,0x58F498,0x58F49C},SVArr(SVA1,j))
SMov(P1,{0x58F4A0,0x58F4A4,0x58F4A8,0x58F4AC,0x58F4B0,0x58F4B4,0x58F4B8,0x58F4BC},SV(SV2))

------------------------------------------------------------------------------------------

385

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------[예제 23-C] TSMem()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
VA1 = CVArray(P1,10)
A1 = CArray(P1,1000)
CVariable(P1,0x12)
CVariable(P1,0x13)
CVariable(P1,0x14)
CVariable(P1,0x15)
SV1 = CSVariable(P1,0x10,8)
SVA1 = SVArray(P1,10,8)
CJumpEnd(AllPlayers,0)
j = CreateVar2(P1,nil,nil,1)
TSMem(P1,V(0x12),SV(SV1))
TSMem(P1,V(0x13),SV(SV1),nil,nil,1)
TSMem(P1,V(0x14),SVArr(SVA1,j))
TSMem(P1,V(0x15),SVArr(SVA1,j),nil,nil,1)
CMov(P1,0x58F450,V(0x12))
CMov(P1,0x58F454,V(0x13))
CMov(P1,0x58F458,V(0x14))
CMov(P1,0x58F45C,V(0x15))

------------------------------------------------------------------------------------------

386

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------[예제 23-D] f_SDiff()
CJump(AllPlayers,0)
SV1 = CSVariable(P1,0x10,2)
SV2 = CSVariable(P1,0x11,2)
SV3 = CSVariable(P1,0x12,2)
SV4 = CSVariable(P1,0x13,2)
SV5 = CSVariable(P1,0x14,2)
SVA1 = SVArray(P1,10,2)
CJumpEnd(AllPlayers,0)
i = CreateVar2(P1,nil,nil,1)
DoActionsX(P1,{SetCSVar("X",SV1,1,SetTo,0xFFFFFFFF),SetCSVar("X",SV1,2,SetTo,0xFFFFFFFF)},1)
SMov(P1,SV(SV1),{_Read(0x57F0F0),_Read(0x57F120)},Add)
SMov(P1,{0x58F480,0x58F484},SV(SV1))
f_SDiff(P1,SV(SV2),SV(SV1),0xFFFFFFFF,0)
SMov(P1,{0x58F488,0x58F48C},SV(SV2))
f_SDiff(P1,SV(SV2),SV(SV1),0xFFFFFFFF,0,nil,1)
SMov(P1,{0x58F490,0x58F494},SV(SV2))
MovS(P1,SVArr(SVA1,i),SV(SV1))
f_SDiff(P1,SV(SV2),SVArr(SVA1,i),0xFFFFFFFF,0)
SMov(P1,{0x58F498,0x58F49C},SV(SV2))
Trigger {
players = {P1},
conditions = {
Label();
Memory(0x58F488,Exactly,0xFFFFFFFF);
Memory(0x58F48C,Exactly,0xFFFFFFFF);
},
actions = {
DisplayText("\x1C0x58F488, 0x58F48C : 0xFFFFFFFF 감지됨");
}
}
DoActionsX(P1,{SetCSVar("X",SV5,1,SetTo,0xFFFFFFFF),SetCSVar("X",SV5,2,SetTo,0xFFFFFFFF)},1)
SMov(P1,SV(SV5),{_Read(0x57F0F0),_Read(0x57F120)},Add)
SMov(P1,{0x58F4A0,0x58F4A4},SV(SV5))
f_SDiff(P1,SV(SV2),SV(SV5),0xFFFFFFFF,24*5,0,0)
SMov(P1,{0x58F4A8,0x58F4AC},SV(SV2))
f_SDiff(P1,SV(SV2),SV(SV5),0xFFFFFFFF,24*5,0,1)
SMov(P1,{0x58F4B0,0x58F4B4},SV(SV2))
f_SDiff(P1,SVArr(SVA1,i),SV(SV5),0xFFFFFFFF,24*5,0,0)
SMov(P1,{0x58F4B8,0x58F4BC},SVArr(SVA1,i))
SMov(P1,SV(SV4),{1,1},Add)
SMov(P1,{0x58F4C0,0x58F4C4},SV(SV4))
SMov(P1,SV(SV3),SV(SV4),Add)
SMov(P1,{0x58F4C8,0x58F4CC},SV(SV3))
f_SDiff(P1,SV(SV2),SV(SV3),0xFFFFFFFF,24,0)
SMov(P1,{0x58F4D0,0x58F4D4},SV(SV2))
f_SDiff(P1,SV(SV2),SV(SV3),0xFFFFFFFF,24,12)
SMov(P1,{0x58F4D8,0x58F4DC},SV(SV2))

------------------------------------------------------------------------------------------

387

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------[예제 23-E] SCast()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
SV1 = CSVariable(P1,0x10,2) CVariable(P1,0x11)
SVA1 = SVArray(P1,10,2)
VA1 = CVArray(P1,10)
CJumpEnd(AllPlayers,0)
i = CreateVar2(P1,nil,nil,1)
SMov(P1,SV(SV1),{_Read(0x57F0F0),_Read(0x57F120)})
SMov(P1,{0x58F480,0x58F484},SV(SV1))

SCast(P1,V(0x11),SV(SV1,1))
CMov(P1,0x58F488,V(0x11))
SCast(P1,V(0x11),SV(SV1,2))
CMov(P1,0x58F48C,V(0x11))
SCast(P1,VArr(VA1,i),SV(SV1,1))
CMov(P1,0x58F490,VArr(VA1,i))
SCast(P1,VArr(VA1,i),SV(SV1,2))
CMov(P1,0x58F494,VArr(VA1,i))
SMov(P1,SVArr(SVA1,i),{_Read(0x57F0F0),_Read(0x57F120)})
SMov(P1,{0x58F4A0,0x58F4A4},SVArr(SVA1,i))
SCast(P1,V(0x11),SVArr(SVA1,i,1))
CMov(P1,0x58F4A8,V(0x11))
SCast(P1,V(0x11),SVArr(SVA1,i,2))
CMov(P1,0x58F4AC,V(0x11))
SCast(P1,VArr(VA1,i),SVArr(SVA1,i,1))
CMov(P1,0x58F4B0,VArr(VA1,i))
SCast(P1,VArr(VA1,i),SVArr(SVA1,i,2))
CMov(P1,0x58F4B4,VArr(VA1,i))
CMov(P1,V(0x11),_Read(0x57F0F0))
CMov(P1,VArr(VA1,i),_Read(0x57F120))
SCast(P1,SV(SV1),V(0x11))
SMov(P1,{0x58F4C0,0x58F4C4},SV(SV1))
SCast(P1,SVArr(SVA1,i),V(0x11))
SMov(P1,{0x58F4C8,0x58F4CC},SVArr(SVA1,i))
SCast(P1,SV(SV1),VArr(VA1,i))
SMov(P1,{0x58F4D0,0x58F4D4},SV(SV1))
SCast(P1,SVArr(SVA1,i),VArr(VA1,i))
SMov(P1,{0x58F4D8,0x58F4DC},SVArr(SVA1,i))

------------------------------------------------------------------------------------------

388

------------------------------------------------------------------------------------------

『 23장 : 구조체 변수 연산 함수 (SV) 』

-----------------------------------------------------------------------------------------[예제 23-F] SCopy()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
SV1 = CSVariable(P1,0x10,8)
SVA1 = SVArray(P1,10,8)
SV2 = CSVariable(P1,0x11,6)
SVA2 = SVArray(P1,10,6)
CJumpEnd(AllPlayers,0)
i = CreateVar2(P1,nil,nil,1)
SMov(P1,SV(SV1,1),{0x11111111})
SCopy(P1,SV(SV1),{2,3,4,5,6,7,8},1)
SMov(P1,{0x58F480,0x58F484,0x58F488,0x58F48C,0x58F490,0x58F494,0x58F498,0x58F49C},SV(SV1))
SMov(P1,SV(SV1,{1,2}),{0x22222222,0x33333333})
SCopy(P1,SV(SV1),{{3,4,5},{6,7,8}},{1,2})
SMov(P1,{0x58F4A0,0x58F4A4,0x58F4A8,0x58F4AC,0x58F4B0,0x58F4B4,0x58F4B8,0x58F4BC},SV(SV1))
SMov(P1,SVArr(SVA1,i,1),{0x44444444})
SCopy(P1,SVArr(SVA1,i),{2,3,4,5,6,7,8},1)
SMov(P1,{0x58F4C0,0x58F4C4,0x58F4C8,0x58F4CC,0x58F4D0,0x58F4D4,0x58F4D8,0x58F4DC},SVArr(SVA1,i))
SMov(P1,SVArr(SVA1,i,{1,2}),{0x55555555,0x66666666})
SCopy(P1,SVArr(SVA1,i),{{3,4,5},{6,7,8}},{1,2})
SMov(P1,{0x58F4E0,0x58F4E4,0x58F4E8,0x58F4EC,0x58F4F0,0x58F4F4,0x58F4F8,0x58F4FC},SVArr(SVA1,i))
SMov(P1,SV(SV2,2),{0x77777777})
SCopy(P1,SV(SV2),{6,4,1,3,5},2)
SMov(P1,{0x58F450,0x58F454,0x58F458,0x58F45C,0x58F460,0x58F464},SV(SV2))
SMov(P1,SVArr(SVA2,i,2),{0x88888888})
SCopy(P1,SVArr(SVA2,i),{6,4,1,3,5},2)
SMov(P1,{0x58F468,0x58F46C,0x58F470,0x58F474,0x58F478,0x58F47C},SVArr(SVA2,i))

------------------------------------------------------------------------------------------

389

------------------------------------------------------------------------------------------

『 24장 : 논리 조건 연산 함수 (_T) 』

-----------------------------------------------------------------------------------------[예제 24-1] _TP(), _TC(), _TB(), _TNOT(), _TAND(), _TOR()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CJumpEnd(AllPlayers,0)
N = CreateVar(P1)
CMov(P1,N,0)
CTrigger(P1,{_TP(_TC(Accumulate(P1,AtLeast,1,Ore)),_TC(Accumulate(P1,AtMost,3,Ore)))},
{DisplayText("\x1F1≤Ore≤3"),SetNVar(N,SetTo,1,1)},{Preserved})
CTrigger(P1,{_TP(_TNOT(_TB(_TC(Accumulate(P1,AtMost,3,Ore))
,_TC(Accumulate(P1,AtLeast,1,Ore))) ))},
{DisplayText("\x08~(1≤Ore≤3)")},{Preserved})
CTrigger(P1,{_TP(_TOR( _TC(Accumulate(P1,Exactly,0,Gas)),
_TAND(_TAccumulate(P1,AtLeast,_Read(0x57F0F0),Gas),_TTAccumulate(P1,Below,10,Gas) )
{DisplayText("\x07Gas==0||(Gas<10&&Gas>=Ore)"),SetNVar(N,SetTo,2,2)},{Preserved})
CTrigger(P1,{_TP(_TNOT(_TOR( _TC(Accumulate(P1,Exactly,0,Gas)),
_TAND(_TAccumulate(P1,AtLeast,_Read(0x57F0F0),Gas),_TTAccumulate(P1,Below,10,Gas) )
{DisplayText("\x10~(Gas==0||(Gas<10&&Gas>=Ore))")},{Preserved})

))},
)))},

CTrigger(P1,{_TP( _TB( _TTBring(P1,"!=",1,"Protoss Dragoon","Anywhere"),
_TAND( _TTCommand(P1,Above,0,"Protoss Zealot"),_TC(Command(P1,AtMost,2,"Protoss Zealot")) ) ) )},
{DisplayText("\x17Dragoon!=1,0<Zealot<=2"),SetNVar(N,SetTo,4,4)},{Preserved})
CTrigger(P1,{_TP(_TNOT(_TNOT(_TNOT( _TB( _TTBring(P1,"!=",1,"Protoss Dragoon","Anywhere"),
_TAND( _TTCommand(P1,Above,0,"Protoss Zealot"),_TC(Command(P1,AtMost,2,"Protoss Zealot")) ) ) ))))},
{DisplayText("\x0E~(~(~(Dragoon!=1,0<Zealot<=2)))")},{Preserved})
CTrigger(P1,{_TP(_TC(Accumulate(P1,AtLeast,1,Ore)),_TC(Accumulate(P1,AtMost,3,Ore)))},
{DisplayText("\x1F1≤Ore≤3")},{Preserved})
CTrigger(P1,{_TP(_TOR( _TC(NVar(N,Exactly,1,1)),_TOR(_TC(NVar(N,Exactly,2,2)),
_TC(NVar(N,Exactly,4,4)) ) ))},
{DisplayText("\x0FTRIG1||(TRIG2||TRIG3)")},{Preserved})
CTrigger(P1,{_TP(_TNOT(_TOR( _TC(NVar(N,Exactly,1,1)),_TOR(_TC(NVar(N,Exactly,2,2)),
_TC(NVar(N,Exactly,4,4)) ) )))},
{DisplayText("\x11~TRIG1||(TRIG2||TRIG3)")},{Preserved})

------------------------------------------------------------------------------------------

390

------------------------------------------------------------------------------------------

『 25장 : 바이트 단위 R/W 함수 (byte) 』

-----------------------------------------------------------------------------------------[예제 25-1] CbyteConvert(), _byteConvert(), f_bytecpy(), GetStrArr(), GetStrSize()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CJumpEnd(AllPlayers,0)
TextVA = CreateVArr(100,P1)
CbyteConvert(P1,VArr(TextVA,0),GetStrArr(0,"\x04ABC가나다123日月０",1))

f_bytecpy(P1,0x640B60 + 12 * 218,_byteConvert(GetStrArr(0,"\x04ABC가나다123日月０",1)),
GetStrSize(0,"\x04ABC가나다123日月０",1))

f_bytecpy(P1,0x58F480,VArr(TextVA,0),GetStrSize(0,"\x04ABC가나다123日月０",1))
f_bytecpy(P1,0x58F4A1,VArr(TextVA,0),GetStrSize(0,"\x04ABC가나다123日月０",1))
f_bytecpy(P1,0x58F4C2,VArr(TextVA,0),GetStrSize(0,"\x04ABC가나다123日月０",1))
f_bytecpy(P1,0x58F4E3,VArr(TextVA,0),GetStrSize(0,"\x04ABC가나다123日月０",1))
-----------------------------------------------------------------------------------------[예제 25-2] f_byteConvert(), f_bytecpyX()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",1)
CJumpEnd(AllPlayers,0)
TestVA = CreateVArr(100,P1)
X, Y = CreateVars(2,P1)
f_GetStrXptr(P1,X,"\x06가\x081\x1Ba\x04一")
f_GetStrXptr(P1,Y,"\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D")
f_byteConvert(P1,VArr(TestVA,0),X,GetStrSize(1,"\x06가\x081\x1Ba\x04一"))
f_bytecpyX(P1,EPD(0x58F480),0,VArr(TestVA,0),GetStrSize(1,"\x06가\x081\x1Ba\x04一"))
f_bytecpyX(P1,EPD(0x58F4A0),1,VArr(TestVA,0),GetStrSize(1,"\x06가\x081\x1Ba\x04一"))
f_bytecpyX(P1,EPD(0x58F4C0),2,VArr(TestVA,0),GetStrSize(1,"\x06가\x081\x1Ba\x04一"))
f_bytecpyX(P1,EPD(0x58F4E0),3,VArr(TestVA,0),GetStrSize(1,"\x06가\x081\x1Ba\x04一"))
f_bytecpyX(P1,_EPD(Y),_EPDX(Y),VArr(TestVA,0),GetStrSize(1,"\x06가\x081\x1Ba\x04一",0))

Trigger {

players = {P1},
conditions = {Accumulate(P1,Exactly,1,Ore);},
actions = {
DisplayText("

\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D\x0D

}

PreserveTrigger();
}

");

------------------------------------------------------------------------------------------

391

------------------------------------------------------------------------------------------

『 25장 : 바이트 단위 R/W 함수 (byte) 』

-----------------------------------------------------------------------------------------[예제 25-3] f_bytecmp(), f_bytecmpX(), TTbytecmp(), TTbytecmpX(), GetPlayerLength()
L = CreateVAr()
CIfOnce(P1)
GetPlayerLength(P1,P1,L)
CIfEnd()
N = CreateVar()
F1, F2, F3, F4 = CreateCcodes(4)
SLoopN(P1,11,Always(),{SetNVar(N,Add,218)},{SetNVar(N,SetTo,0x640B63-218),TSetNVar(N,Add,L)})
f_bytecmp(P1,{F1},N,_byteConvert(GetStrArr(0,"마린")),GetStrSize(0,"마린"))
f_bytecmpX(P1,{F2},_EPD(N),_EPDX(N),_byteConvert(GetStrArr(0,"고스트")),GetStrSize(0,"고스트"))
CTrigger(P1,TTbytecmp(N,_byteConvert(GetStrArr(0,"파벳")),GetStrSize(0,"파벳"))
,{SetCDeaths(P1,SetTo,1,F3)},{Preserved})
CTrigger(P1,TTbytecmpX(_EPD(N),_EPDX(N),_byteConvert(GetStrArr(0,"메딕")),GetStrSize(0,"메딕"))
,{SetCDeaths(P1,SetTo,1,F4)},{Preserved})
SLoopNEnd()
TriggerX(P1,{CDeaths(P1,Exactly,1,F1)}, -- 채팅인식 : 마린
{DisplayText("마린생성"),CreateUnit(1,"Terran Marine","CLoc",P1),SetCDeaths(P1,SetTo,0,F1)},{Preserved})
TriggerX(P1,{CDeaths(P1,Exactly,1,F2)}, -- 채팅인식 : 고스트
{DisplayText("고스트생성"),CreateUnit(1,"Terran Ghost","CLoc",P1),SetCDeaths(P1,SetTo,0,F2)},{Preserved})
TriggerX(P1,{CDeaths(P1,Exactly,1,F3)}, -- 채팅인식 : 파벳
{DisplayText("파벳생성"),CreateUnit(1,"Terran Firebat","CLoc",P1),SetCDeaths(P1,SetTo,0,F3)},{Preserved})
TriggerX(P1,{CDeaths(P1,Exactly,1,F4)}, -- 채팅인식 : 메딕
{DisplayText("메딕생성"),CreateUnit(1,"Terran Medic","CLoc",P1),SetCDeaths(P1,SetTo,0,F4)},{Preserved})

------------------------------------------------------------------------------------------

392

------------------------------------------------------------------------------------------

『 25장 : 바이트 단위 R/W 함수 (byte) 』

-----------------------------------------------------------------------------------------[예제 25-4] _byteConvertF(), _byteConvertFX(), f_byteConvertX(), TTbytecmp(),
EPDF(), EPDX(), SaveStrArr()
L = CreateVAr(P1)
Txt = CreateVArr(100,P1)
CIfOnce(P1)
GetPlayerLength(P1,P1,L)
DoActions2(P1,{

CIfEnd()

})

SaveStrArr(0x58F480,GetStrArr(0,"\x04[예제 25-4] ")),
SaveStrArr(0x58F490,GetStrArr(0,"\x08[예제 25-4] ")),
SaveStrArr(0x58F4A0,GetStrArr(0,"\x11[예제 25-4] ")),
SaveStrArr(0x58F4B0,GetStrArr(0,"\x17[예제 25-4] ")),
SaveStrArr(0x58F4C0,GetStrArr(0,"\x07[예제 25-4] ")),
SaveStrArr(0x58F4D0,GetStrArr(0,"\x1F[예제 25-4] ")),
SaveStrArr(0x58F4E0,GetStrArr(0,"\x1C[예제 25-4] ")),
SaveStrArr(0x58F4F0,GetStrArr(0,"\x10[예제 25-4] "))

Ptr = CreateVar(P1)
CMov(P1,Ptr,_Add(_lShift(_Mod(_Rand(),8),4),0x58F480))
N = CreateVar(P1)
F = CreateCcode()
PName = CreateVArr(10,P1)
f_byteConvertX(P1,VArr(PName,0),EPDF(0x57EEEB+0x24*0),EPDX(0x57EEEB+0x24*0),L)
SLoopN(P1,11,Always(),{SetNVar(N,Add,218)},{SetNVar(N,SetTo,0x640B60-218)})
CIf(P1,{TTbytecmp(N,VArr(PName,0),L)})
f_bytecpy(P1,_Add(N,GetStrSize(0,"\x04[예제 25-4] ")),_byteConvertF(N,96),96)
f_bytecpy(P1,N,_byteConvertFX(_EPD(Ptr),_EPDX(Ptr),GetStrSize(0,"\x04[예제 25-4] "))
,GetStrSize(0,"\x04[예제 25-4] ")) -- 칭호 부착

CIfEnd()
SLoopNEnd()
------------------------------------------------------------------------------------------

393

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-1] MakeiStrVoid(), MakeiStrLetter(), GetiStrId(), SaveiStrArr(), CSPrint()

※ StartCtrig()의 STRX인자에 사용중인 플립 버전에 맞게 설정해야함 (0.8.9.0이상이면 1, 이하면 0을 입력)

CJump(AllPlayers,0)
CJumpEnd(AllPlayers,0)
DoActions(P1,{CopyCpAction({DisplayTextX(MakeiStrLetter("\r\n",11),4)},EveryPlayers,0)})
-- Debug.py 텍스트 제거
iStr1 = GetiStrId(P1,MakeiStrVoid(100))
Str1 = SaveiStrArr(P2,"\x13\x08테\x17스\x07트\x1F☆\n\x13\x04CSPrint
CSPrint(iStr1,Str1,{P1,Force5},3,P1,nil,nil,nil,1)

\x1C예제\x0E-1\n\x13\x1BT\x19E\x1DS\x02T",1)

-----------------------------------------------------------------------------------------[예제 26-2] MakeiStrWord(), FixText(), CreateSVA32(), SaveiStrArr(), SaveiStrptr(),
GetiStrArr(), CSPrint()
CJump(AllPlayers,0)
Str3 = SaveiStrptr(P3,"\x13"..MakeiStrWord("\x08T\x17E\x07S\x1FT",2),1)
CJumpEnd(AllPlayers,0)
DoActions(P1,{CopyCpAction({DisplayTextX(MakeiStrLetter("\r\n",11),4)},EveryPlayers,0)})
-- Debug.py 텍스트 제거
iStr1,iStrid1 = GetiStrId(P1,MakeiStrVoid(20))
StrA1, StrS1 = GetiStrArr(1,"\x13\x1B테\x19스\x1D트\x02☆")
Str1 = CreateSVA32(StrA1,StrS1,P1)
Str2 = SaveiStrArr(P2,"\x13\x04CSPrint \x1F예제\x0F-2",1)
FixText(P1,1)
CSPrint(iStr1,Str1,P1,0,P1,{MemoryX(0x57F0F0,Exactly,1,1)},nil,nil,1)
CSPrint(iStr1,Str2,P1,0,P1,{MemoryX(0x57F0F0,Exactly,2,2)},nil,nil,1)
CSPrint(iStr1,Str3,P1,0,P1,{MemoryX(0x57F0F0,Exactly,4,4)},nil,nil,1)
FixText(P1,2)

-----------------------------------------------------------------------------------------[예제 26-3] CAPrint(), CreateSVA1(), SVA1(), CA__InputVA()
CJump(AllPlayers,0)
iStr1 = GetiStrId(P1,MakeiStrVoid(20))
Str1a, Str1s = GetiStrArr(1,"\x13\x04CAPrint \x1B예제\x08-3\x00")
Str1 = CreateSVA1(Str1a,Str1s,P2)
Str2, Str2a, Str2s = SaveiStrArr(P3,"공백→"..MakeiStrLetter(" ",Str1s-1).."\x06테스트☆\x04테스트★"..MakeiStrLetter("
CJumpEnd(AllPlayers,0)
DoActions(P1,DisplayText(MakeiStrWord("\r\n",11),4))
A = CreateVar2(P1,nil,nil,3*604)
B, C, D, E = CreateVars(4,P1)
DoActionsX(P1,{
SetNVar(A,Add,604); SetNvar(B,SetTo,0);
SetNvar(C,SetTo,19); SetNVar(D,SetTo,1);
SetNVar(E,SetTo,Str1s-1);})
TriggerX(P1,Nvar(A,AtLeast,(Str2s-Str1s+1)*604),SetNVar(A,SetTo,3*604),{preserved})
Function TEST()
End
Function TEST2()

",Str1s-1).."\x00")

CA__InputVA(0,Str1,Str1s,nil,0,19)

CA__InputVA(D,SVA1(Str2,A),E,nil,B,C)
End
CAPrint(iStr1,{P1},{1,0,0,0,1,1,0,0},"TEST",P1)
CAPrint(iStr1,{P1},{1,0,0,0,1,2,0,0},"TEST2",P1)

------------------------------------------------------------------------------------------

394

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-4] CAPrint(), CA__InputSVA1()

CJump(AllPlayers,0)
iStr1 = GetiStrId(P1,MakeiStrVoid(20))
Str1, Str1a, Str1s = SaveiStrArr(P2,"\x13\x04CAPrint \x1B예제\x08-4\x00")
Str2, Str2a, Str2s = SaveiStrArr(P3,"\x08 \x11 \x17 \x07 \x1F \x0E \x10 \x15 \x1B \x04 \x19 \x1D \x02 \x1C \x1E \x05 ")
iStr2 = GetiStrId(P2,MakeiStrLetter(" ",20))
Str3, Str3a, Str3s = SaveiStrArr(P4," 테스트☆텍스트★ ")
Str4, Str4a, Str4s = SaveiStrArr(P5,"\x13"..MakeiStrLetter(" ",19))
CJumpEnd(AllPlayers,0)
DoActions(P1,DisplayText(MakeiStrWord("\r\n",11),4))
A, B, C = CreateVars(3,P1) D = CreateVar2(P1,nil,nil,4*604)
E = CreateVar2(P1,nil,nil,0*604) F = CreateVar2(P1,nil,nil,(Str3s-1)*604) G = CreateVar2(P1,nil,nil,2)
function TEST()
local PlayerID = CAPrintPlayerID
DoActionsX(PlayerID,{SetNVar(A,Add,604)})
TriggerX(PlayerID,NVar(A,AtLeast,8*604),SetNVar(A,SetTo,0*604),{preserved})
CA__InputSVA1(SVA1(Str1,9),SVA1(Str2,A),2,0xFF,0,Str1s-1,0,2,8)
-- 9 = "\x1B예", 11 = "\x08-" / Str2 -> 앞8글자 -> 9, 뒤8글자 -> 11
CA__InputVA(0,Str1,Str1s,nil,0,19)
end
function TEST2()
local PlayerID = CAPrintPlayerID
DoActionsX(PlayerID,{SetNVar(B,Add,604),SetNVar(C,Add,604)})
TriggerX(PlayerID,{NVar(B,AtLeast,Str4s*604),NVar(B,AtMost,0x7FFFFFFF)},
SetNVar(B,SetTo,-(Str4s-2)*604),{preserved})
TriggerX(PlayerID,NVar(C,AtLeast,8*604),SetNVar(C,SetTo,0*604),{preserved})
CA__InputSVA1(SVA1(Str3,D),SVA1(Str2,C),G,0xFF,E,F,0,-3,8)
-- 1 = "테", 4 = "☆" / Str2 -> 앞8글자 -> 4, 뒤8글자 -> 1
CA__InputSVA1(SVA1(Str4,B),Str3,Str3s,nil,1,Str4s-1)
CA__InputVA(0,Str4,Str4s,nil,0,19)
end
CAPrint(iStr1,{P1},{1,0,3,0,1,1,0,0},"TEST",P1)
CAPrint(iStr2,{P1},{1,0,2,0,1,2,0,0},"TEST2",P1)

-----------------------------------------------------------------------------------------[예제 26-5] CAPrint(), CA__Overwrite()
CJump(AllPlayers,0)
iStr1 = GetiStrId(P1,MakeiStrVoid(20))
iStr2 = GetiStrId(P2,"\x13"..MakeiStrLetter(" ",19))
Str1 = SaveiStrArr(P2,"\x13\x04CAPrint \x0E예제\x1C-5",1)
Str2 = SaveiStrArr(P3,"\x1F￣\x04테스트☆\x05텍스트★",1)
CJumpEnd(AllPlayers,0)
DoActions(P1,DisplayText(MakeiStrWord("\r\n",11),4))
A = CreateVar2(P1,nil,nil,1)
function TEST() CA__OverWrite(Str1,0,1,1) end
function TEST2() local PlayerID = CAPrintPlayerID
DoActionsX(PlayerID,{SetNVar(A,Add,1)})
TriggerX(PlayerID,NVar(A,AtLeast,20),SetNVar(A,SetTo,1),{preserved})
CA__OverWrite(Str2,A,0,1)
end
CAPrint(iStr1,{P1},{1,0,0,0,1,1,0,0},"TEST",P1)
CAPrint(iStr2,{P1},{1,0,2,0,1,2,0,0},"TEST2",P1)

-----------------------------------------------------------------------------------------395

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-6] CAPrint(), CA__Input()

CJump(AllPlayers,0)
iStr1 = GetiStrId(P1,MakeiStrVoid(20))
Str1, Str1a, Str1s = SaveiStrArr(P2,"CAPrint 예제-6")
CJumpEnd(AllPlayers,0)
DoActions(P1,DisplayText(MakeiStrWord("\r\n",11),4))
A = CreateVar2(P1,nil,nil,0) B = CreateVar2(P1,nil,nil,0x4)
function TEST()

local PlayerID = CAPrintPlayerID
DoActionsX(PlayerID,{SetNVar(A,Add,604)})
TriggerX(PlayerID,NVar(A,AtLeast,Str1s*604),SetNVar(A,SetTo,0*604),{preserved})
CA__Input(MakeiStrData("Ｃ")+0x1300,SVA1(Str1,0),0xFFFFFF00) -- \x13(공백 1바이트에 삽입)
CA__Input(B,SVA1(Str1,Str1s-1),0xFF)
CIf(PlayerID,NVar(A,AtLeast,1*604))
CA__Input(B,SVA1(Str1,Vi(A[2],-1,A[1])),0xFF)
CIfEnd()
CA__Input(0x18,SVA1(Str1,A),0xFF)
CIf(PlayerID,NVar(A,AtMost,(Str1s)*604))
CA__Input(B,SVA1(Str1,Vi(A[2],1,A[1])),0xFF)
CIfEnd()

CA__InputVA(0,Str1,Str1s,nil,0,19)
end
CAPrint(iStr1,{P1},{1,0,2,0,1,3,0,0},"TEST",P1)

-----------------------------------------------------------------------------------------[예제 26-7] CAPrint(), CA__SetMask()
CJump(AllPlayers,0)
iStr1 = GetiStrId(P1,MakeiStrVoid(8).." 예제-7"..MakeiStrVoid(7))
Str1, Str1a, Str1s = SaveiStrArr(P2,"\x13\x03C\x04A\x06P\x07r\x08i\x0En\x0Ft \x10_\x11_\x15_\x16_")
CJumpEnd(AllPlayers,0)
DoActions(P1,DisplayText(MakeiStrWord("\r\n",11),4))
A = CreateVar2(P1,nil,nil,9*604)
B = CreateVar2(P1,nil,nil,12*604)

function TEST()

end

CA__SetMask(Str1,0xFFFF0000,2,8,0) -- 글자만 (CAPrint)
CA__SetMask(Str1,0xFF,A,B,1) -- 색상만 (예제-7)
CA__InputVA(0,Str1,Str1s,nil,0,19)

CAPrint(iStr1,{P1},{1,0,2,0,1,3,0,0},"TEST",P1)

------------------------------------------------------------------------------------------

396

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-8] CAPrint(), CA__SetNext()

CJump(AllPlayers,0)
iStr1 = GetiStrId(P1,MakeiStrVoid(60))
Str1, Str1a, Str1s = SaveiStrArr(P2,"\x04CAPrint \x17예제\x19-8")
Str2, Str2a, Str2s = SaveiStrArr(P3,MakeiStrLetter(" ",60),1)
iStr2 = GetiStrId(P1,MakeiStrVoid(9))
Str3, Str3a, Str3s = SaveiStrArr(P2,"\x1C세\x1F로\x04줄")
Str4, Str4a, Str4s = SaveiStrArr(P5,MakeiStrLetter("\n",9),1)
CJumpEnd(AllPlayers,0)
DoActions(P1,DisplayText(MakeiStrWord("\r\n",11),4))
A = CreateVar2(P1,nil,nil,0*604) B = CreateVar2(P1,nil,nil,(Str3s-1)*604)
function TEST()
CA__OverWrite(Str2,0,0xFFFFFFFF,1)
CA__SetNext(Str1,_Read(0x57F0F0),SetTo,0,Str1s-1)
CA__InputVA(30,Str1,Str1s,nil,0,59)
end
function TEST2()
CA__OverWrite(Str4,0,0xFFFFFFFF)
CA__Input(MakeiStrData("\n")/0x10000,SVA1(Str3,0),0xFF00)
CA__Input(MakeiStrData("\n")/0x10000,SVA1(Str3,1),0xFF00)
CA__Input(MakeiStrData("\n")/0x10000,SVA1(Str3,2),0xFF00)
CA__SetNext(Str3,_Read(0x57F120),SetTo,A,B)
CA__InputVA(_iSub(_Mov(4),_Read(0x57F120)),Str3,Str3s,nil,0,8)
end
CAPrint(iStr1,{P1},{1,0,0,0,1,1,0,0},"TEST",P1)
CAPrint(iStr2,{P1},{1,0,0,0,1,2,0,0},"TEST2",P1)

-----------------------------------------------------------------------------------------[예제 26-9] CAPrint(), CA__InputSVA1X(), CA__MoveXY
CJump(AllPlayers,0)
iStr1 = GetiStrId(P1,MakeiStrLetter(" ",30).."\n"..MakeiStrLetter(" ",30).."\n"..MakeiStrLetter(" ",30))
Str1, Str1a, Str1s = SaveiStrArr(P2," \x04C\x04A\x04P\x04r\x04i\x04n\x04t \x07예\x07제\x18-\x189 ")
Str2, Str2a, Str2s = SaveiStrArr(P3,MakeiStrLetter(" ",30)) -- Path
Str3, Str3a, Str3s = SaveiStrArr(P4," \x0E테\x1C스\x1F트\x0F☆\x1D텍\x04스\x16트\x08★ ")
Str4, Str4a, Str4s = SaveiStrArr(P5,MakeiStrLetter(" ",30)) -- Path
CJumpEnd(AllPlayers,0)
DoActions(P1,DisplayText(MakeiStrWord("\r\n",11),4))
A = CreateVar2(P1,nil,nil,(0-Str2s)*604) B = CreateVar2(P1,nil,nil,(0-Str4s)*604) C = CreateVar(P1)
D = CreateVar2(P1,nil,nil,Str3s) E = CreateVar2(P1,nil,nil,0*604) F = CreateVar2(P1,nil,nil,(Str4s-1)*604)
G = CreateVar2(P1,nil,nil,0*604)
function TEST()
-- Level 2 : Text -> Level 1 : Path -> Level 0 : iStrid
local PlayerID = CAPrintPlayerID
DoActionsX(PlayerID,{SetNVar(C,Add,1)})
TriggerX(PlayerID,{NVar(C,Exactly,2)},{SetNVar(A,Add,1*604),SetNVar(C,SetTo,0)},{Preserved})
CTrigger(PlayerID,{TTNVar(A,iAtLeast,(Str1s+Str2s)*604)},{SetNVar(A,SetTo,(0-Str2s)*604)},{Preserved})

CA__SetMask(Str2,0,0,Str2s-1,1) -- Path Mask Reset
CA__MoveXY(Str2,31,0,nil,1,{{2,0,1},{7,0,2},{10,0,1},{18,0,0},{21,0,1},{26,0,2}},0) -- Path Setting
CA__InputSVA1X(SVA1(Str2,A),Str1,Str1s,nil,0xFFFF00FF,0,Str2s-1,0) -- Text -> Path
CA__InputVA(0*31+0,Str2,Str2s,nil,0,91) -- Path -> iStrid
DoActionsX(PlayerID,{SetNVar(B,Add,1*604)})
CTrigger(PlayerID,{TTNVar(B,iAtLeast,(Str3s+Str4s)*604)},{SetNVar(B,SetTo,(0-Str4s)*604)},{Preserved})
local PathArr = {}
for i = 0, 28 do table.insert(PathArr,{i,0,-math.abs((i-1)%4-2)}) end

end

CA__SetMask(Str4,0,0,Str4s-1,1) -- Path Mask Reset
CA__MoveXY(Str4,31,0,nil,1,PathArr,0) -- Path Setting
CA__InputSVA1X(SVA1(Str4,B),SVA1(Str3,G),D,nil,0xFFFF00FF,E,F,0) -- Text -> Path
CA__InputVA(2*31+0,Str4,Str4s,nil,0,91) -- Path -> iStrid

CAPrint(iStr1,{P1},{1,0,2,0,1,3,0,0},"TEST",P1)

------------------------------------------------------------------------------------------

397

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-10] CAPrint()

CJump(AllPlayers,0)
iStr1 = GetiStrId(P1,"\x04CAPrint \x08예제\x06-A")
iStr2 = GetiStrId(P1,"\x04CAPrint \x11예제\x15-A")
iStr3 = GetiStrId(P1,"\x04CAPrint \x17예제\x03-A")
iStr4 = GetiStrId(P1,"\x04CAPrint \x07예제\x18-A")
iStr5 = GetiStrId(P1,"\x04CAPrint \x1F예제\x0F-A")
iStr6 = GetiStrId(P1,"\x04CAPrint \x1C예제\x0E-A")
iStr7 = GetiStrId(P1,"\x04CAPrint \x10예제\x1E-A")
iStr8 = GetiStrId(P1,"\x04CAPrint \x16예제\x05-A")
iStr9 = GetiStrId(P1,"\x04CAPrint \x1E예제\x02-A")
CJumpEnd(AllPlayers,0)
DoActions(P1,DisplayText(MakeiStrWord("\r\n",11),4))
A, B, C, D, E, F, G = CreateVars(7,P1)
DoActionsX(P1,{
SetNVar(A,Add,1);
SetNVar(D,SetTo,1);
SetNVar(E,Add,1);
SetNVar(F,SetTo,1);
SetNVar(G,SetTo,2);
})
TriggerX(P1,{NVar(A,AtLeast,4)},{SetNVar(A,SetTo,1)},{Preserved})
TriggerX(P1,{NVar(E,AtLeast,25)},{SetNVar(E,SetTo,1)},{Preserved})
CAPrint({iStr1,iStr2,iStr3},{P1},{A,0,0,0,1,F,0,0},nil,P1)
function Test()

local PlayerID = CAPrintPlayerID
CAdd(PlayerID,0x58F450,1)
CMov(PlayerID,B,24)

end
CAPrint(iStr4,{P1},{1,B,0,0,0,0,0,0},"Test",P1)
function Test2()

local PlayerID = CAPrintPlayerID
CAdd(PlayerID,0x58F454,1)
CAdd(PlayerID,C,1)

end
CAPrint(iStr5,{P1},{1,0,C,0,1,0,0,0},"Test2",P1)
function Test3()

local PlayerID = CAPrintPlayerID
CAdd(PlayerID,0x58F458,1)

end
CAPrint(iStr6,{P1},{1,0,0,D,1,0,0,0},"Test3",P1)
function Test4()

local PlayerID = CAPrintPlayerID
CAdd(PlayerID,0x58F45C,1)

end
CAPrint(iStr7,{P1},{1,0,0,0,E,0,0,0},"Test4",P1)
CAPrint(iStr8,{P1},{1,0,0,0,1,0,_Read(0x57F0F0),0},nil,P1)
CAPrint(iStr9,{P1},{1,0,0,0,1,G,_Read(0x57F120),0},nil,P1)
------------------------------------------------------------------------------------------

398

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-11] CAPrint() CA__SetValue(), CA__MoveXY()

CJump(AllPlayers,0)
iStr1 = GetiStrId(P1,MakeiStrLetter(" ",30).."\n"..MakeiStrLetter(" ",30))
Str1, Str1a, Str1s = SaveiStrArr(P1,MakeiStrVoid(12))
Str2 = SaveiStrArr(P1,MakeiStrLetter(" ",30).."\n"..MakeiStrLetter(" ",30),1)
local StrAddr = "" for i = 1, 8 do StrAddr = StrAddr.."\n"..MakeiStrLetter(" ",30) end
iStr2 = GetiStrId(P1,MakeiStrLetter(" ",30)..StrAddr)
Str3, Str3a, Str3s = SaveiStrArr(P1,MakeiStrLetter("\x04 ",29).."\x08 ".."\x11 ".."\x17 ".."\x07 ".."\x1F ".."\x0E ".."\x1C
CJumpEnd(AllPlayers,0)
DoActions(P1,DisplayText(MakeiStrWord("\r\n",11),4))
A = CreateVar2(P1,nil,nil,0*604) B = CreateVar2(P1,nil,nil,0+1*31)
function TEST()
CA__OverWrite(Str2,0,0xFFFFFFFF,0,1)
CA__SetNext(Str1,1,nil,0,Str1s-1,1)
CA__SetValue(Str1,"\x04CAPrint \x10예제\x1E-B",nil,0)
CA__MoveXY(Str1,31,0,SetTo,0,{{_mul(_Mod(_Rand(),Str1s),604),1,1}},1)
CA__InputVA(0,Str1,Str1s,nil,0,60)
end
function TEST2()
local PlayerID = CAPrintPlayerID
DoActionsX(PlayerID,{SetNVar(A,Add,604)})
TriggerX(PlayerID,NVar(A,AtLeast,Str3s*604),SetNVar(A,SetTo,0*604),{Preserved})
CA__SetValue(Str3," 테스트☆텍스트★ ",0xFFFF0000,A)
local Path1 = {}
for i = 29, 37 do
table.insert(Path1,{CreateVar2(PlayerID,nil,nil,i*604),B})
end
CA__MoveXY(Str3,nil,0,SetTo,0,Path1,0)
CA__InputVA(0,Str3,Str3s,nil,0,iStr2[3]-1)
end

".."\x10 ".."\x05

CAPrint(iStr1,{P1},{1,0,12,0,1,1,0,0},"TEST",P1)
CAPrint(iStr2,{P1},{1,0,4,0,1,2,0,0},"TEST2",P1)

------------------------------------------------------------------------------------------

[예제 26-12] CAPrint() CA__Mov(), CA__Movcpy()

CJump(AllPlayers,0)
iStr1 = GetiStrId(P1,MakeiStrLetter(" ",30))
Str1, Str1a, Str1s = SaveiStrArr(P1,"\x04CAPrint \x05예제-C")
CJumpEnd(AllPlayers,0)
DoActions(P1,DisplayText(MakeiStrWord("\r\n",11),4))
A, B = CreateVars(2,P1) C = CreateVar2(P1,nil,nil,3)
function TEST()
local PlayerID = CAPrintPlayerID
CA__Mov(SVA1(Str1,0),0x58F450)
CA__Mov(SVA1(Str1,0),A)
CA__Mov(SVA1(Str1,0),Mem(B[1],B[2],0x15C,B[3]))
CMov(PlayerID,0x58F454,A)
CMov(PlayerID,0x58F458,B)
CA__Mov(SVA1(Str1,_Mul(_Read(0x57F0F0),604)),0x58F45C)
CA__Mov(SVA1(Str1,_Mul(_Read(0x57F0F0),604)),A)
CA__Mov(SVA1(Str1,_Mul(_Read(0x57F0F0),604)),Mem(B[1],B[2],0x15C,B[3]))
CMov(PlayerID,0x58F460,A)
CMov(PlayerID,0x58F464,B)
CA__Movcpy(SVA1(Str1,0),0x58F468,3)
CA__Movcpy(SVA1(Str1,_Mul(_Read(0x57F0F0),604)),0x58F474,C)
CA__InputVA(0,Str1,Str1s,nil,0,60)
end
CAPrint(iStr1,{P1},{1,0,0,0,1,3,0,0},"TEST",P1)

------------------------------------------------------------------------------------------

399

")

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-13] CAPrint() CA__Read(), CA__ReadX()
CJump(AllPlayers,0)
iStr1 = GetiStrId(P1,"\x04CAPrint \x05예제-D")
CJumpEnd(AllPlayers,0)
DoActions(P1,DisplayText(MakeiStrWord("\r\n",11),4))
function TEST()

local PlayerID = CAPrintPlayerID
CA__Read(0,0x58F450)
CA__ReadX(0,0x58F454,"0")
CA__Read(_Read(0x57F0F0),0x58F458)
CA__ReadX(_Read(0x57F0F0),0x58F45C,"-3")
CA__ReadX(_Read(0x57F0F0),0x58F460,"-2")
CA__ReadX(_Read(0x57F0F0),0x58F464,"-1")
CA__ReadX(_Read(0x57F0F0),0x58F468,"0")
CA__ReadX(_Read(0x57F0F0),0x58F46C,"+1")
CA__ReadX(_Read(0x57F0F0),0x58F470,"+2")
CA__ReadX(_Read(0x57F0F0),0x58F474,"+3")

end
CAPrint(iStr1,{P1},{1,0,0,0,1,3,0,0},"TEST",P1)

------------------------------------------------------------------------------------------

[예제 26-14] CAPrint(), CA__SetColor(), CA__SetLetter(), CA__SetMemoryX(), MakeiStrData()
CJump(AllPlayers,0)
iStr1 = GetiStrId(P1,MakeiStrWord("CAPrint 예제-E\n",6))
CJumpEnd(AllPlayers,0)
DoActions(P1,DisplayText(MakeiStrWord("\r\n",11),4))
A = CreateVar2(P1,nil,nil,8) B = CreateVar2(P1,nil,nil,0x02) C = CreateVar(P1)
VA1 = CreateVArr(10,P1) VA2 = CreateVArr(12,P1) VA3 = CreateVArr(8,P1)
local VA1Init = {0x4,0x6,0x11,0x3,0x18,0x1C,0xF,0xE,0x10,0x15}
local VA1Act = {}
local VA2Init = {"Ｃ","Ａ","Ｐ","ｒ","ｉ","ｎ","ｔ"," ","예","제","－","Ｅ"}
local VA2Act = {}
local VA3Init = {"\x04一","\x1B二","\x19三","\x16四","\x02五","\x1D穴","\x1E七","\x05八"} -- 六은 글자깨짐
local VA3Act = {}
for i = 1, #VA1Init do
table.insert(VA1Act,SetCVAar(VArr(VA1,i-1),SetTo,VA1Init[i]))
end
for i = 1, #VA2Init do
table.insert(VA2Act,SetCVAar(VArr(VA2,i-1),SetTo,MakeiStrData(VA2Init[i],1)))
end
for i = 1, #VA3Init do
table.insert(VA3Act,SetCVAar(VArr(VA3,i-1),SetTo,MakeiStrData(VA3Init[i],1)))
end
DoActionsX(P1,{VA1Act,VA2Act,VA3Act,})
function TEST()
local PlayerID = CAPrintPlayerID
DoActionsX(PlayerID,{SetNVar(C,Add,1)})
CA__SetColor(0,0x1B) CA__SetColor(A,0x19) CA__SetColor(10,B)
CA__SetColor(_Add(_Mod(_Rand(),12),13*1),_MovX(VArr(VA1,_Mod(_Rand(),10))))
CA__SetLetter(8+13*2,"例") CA__SetLetter(9+13*2,"題")
CA__SetLetter(_Add(_Mod(_Rand(),12),13*3),_MovX(VArr(VA2,_Mod(_Rand(),12))))
CA__SetMemoryX(10+13*4,"\x1F_") CA__SetMemoryX(11+13*4,MakeiStrData("\x04e",1))
CA__SetMemoryX(_Add(_Mod(_Rand(),12),13*5),_MovX(VArr(VA3,_Mod(_Rand(),8))))

end
CAPrint(iStr1,{P1},{1,0,0,0,1,3,0,0},"TEST",P1)

------------------------------------------------------------------------------------------

400

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-15] CAPrint() CA__ConvertColor()

CJump(AllPlayers,0)
iStr1 = GetiStrId(P1,MakeiStrLetter(" ",30))
Str1, Str1a, Str1s = SaveiStrArr(P1,"\x13\x08C\x0EA\x0FP\x10r\x11i\x15n\x16t\x17 \x18예\x19제\x1B-\x1CF")
iStr2 = GetiStrId(P1,MakeiStrLetter(" ",40))
Str2, Str2a, Str2s = SaveiStrArr(P1,"\x13工으후루꾸十卞丁下丁卞十꾸루후으工工으후루꾸十卞丁下丁卞十꾸루후으工")
CJumpEnd(AllPlayers,0)
DoActions(P1,DisplayText(MakeiStrWord("\r\n",11),4))
A = CreateVar2(P1,nil,nil,0x4) B = CreateVar2(P1,nil,nil,0x1B) C = CreateVar2(P1,nil,nil,0x19)
D = CreateVar2(P1,nil,nil,0x02) E = CreateVar2(P1,nil,nil,1*604) F = CreateVar2(P1,nil,nil,34*604)
function TEST()
local ColorArr = {{0x1C,0x8},{0x1B,0x1C},{0x19,0x1B},{0x18,0x19},{0x17,0x18},{0x16,0x17},{0x15,0x16},{0x11,0x15},{0x10,0x11},{0xF,0x10},{0xE,0xF},{0x8,0xE}}
CA__ConvertColor(Str1,ColorArr,nil,1,12)
CA__InputVA(0,Str1,Str1s,nil,0,39)
end
function TEST2()
CIfOnce(P1)
CA__ConvertColor(Str2,{{0xD,0x4}},nil,1,8)
CA__ConvertColor(Str2,{{0xD,0x1B}},nil,9,17)
CA__ConvertColor(Str2,{{0xD,0x19}},nil,18,25)
CA__ConvertColor(Str2,{{0xD,0x02}},nil,26,34)
CIfEnd()
CA__ConvertColor(Str2,{{A,B},{B,C},{C,D},{D,A}},nil,E,F)
CA__InputVA(0,Str2,Str2s,nil,0,39)
end
CAPrint(iStr1,{P1},{1,0,3,0,1,1,0,0},"TEST",P1)
CAPrint(iStr2,{P1},{1,0,2,0,1,2,0,0},"TEST2",P1)

------------------------------------------------------------------------------------------

[예제 26-16] CAPrint(), CA__ConvertLetter(), CA__ConvertColor(), MakeiStrDiff()
CJump(AllPlayers,0)
iStr1 = GetiStrId(P1,MakeiStrLetter(" ",30))
Str1, Str1a, Str1s = SaveiStrArr(P1,"\x13\x04CAPrint \x1D예제\x1E-G")
iStr2 = GetiStrId(P1,MakeiStrLetter(" ",40))
Str2, Str2a, Str2s = SaveiStrArr(P1,"\x13으후루꾸\x05루\x05후으후루꾸\x05루\x05후으후루꾸\x05루\x05후으")
CJumpEnd(AllPlayers,0)
DoActions(P1,DisplayText(MakeiStrWord("\r\n",11),4))
A = CreateVar2(P1,nil,nil,MakeiStrData("ａ",1)) B = CreateVar2(P1,nil,nil,MakeiStrData(" ",1)) C = CreateVar2(P1,nil,nil,MakeiStrData("☆",1))
D = CreateVar2(P1,nil,nil,0x1E) E = CreateVar2(P1,nil,nil,MakeiStrData("A",1)) F = CreateVar2(P1,nil,nil,MakeiStrData("Z",1))
G = CreateVar2(P1,nil,nil,MakeiStrDiff("A","ａ")) H = CreateVar2(P1,nil,nil,MakeiStrData("A",1))

function TEST()

local LetterArr = {{{E,F},G,{H,0xFF0000}},{{"a","z"},{"a","Ａ"},0xFF0000},{"-","－",{0x1E,0xFF}},{B,C},
{{"Ａ","Ｚ"},{"Ａ","a"},{MakeiStrData("Ａ",1),0xFF0000}},{{"ａ","ｚ"},{"ａ","A"},{A,0xFF0000}},{"－","-",{D,0xFF}},{C,B}}
CA__ConvertLetter(Str1,LetterArr,nil,1,12)
CA__InputVA(0,Str1,Str1s,nil,0,29)
end
function TEST2()
local PlayerID = CAPrintPlayerID
CIfOnce(PlayerID)

CA__ConvertColor(Str2,{{MakeiStrData("으",1),MakeiStrData("\x08으",1)},{MakeiStrData("후",1),MakeiStrData("\x04후",1)},{MakeiStrData("루",1),MakeiStrData("\x02루",1)},
{MakeiStrData("꾸",1),MakeiStrData("\x1F꾸",1)},{MakeiStrData("\x05루",1),MakeiStrData("\x04루",1)},{MakeiStrData("\x05후",1),MakeiStrData("\x1B후",1)}},
{{0xFFFFFFFF,0xFFFFFFFF},{0xFFFFFFFF,0xFFFFFFFF},{0xFFFFFFFF,0xFFFFFFFF},{0xFFFFFFFF,0xFFFFFFFF},{0xFFFFFFFF,0xFFFFFFFF},{0xFFFFFFFF,0xFFFFFFFF}},1,19)

CIfEnd()

local LetterArr = {{"\x08으","\x04후"},{"\x04후","\x02루"},{"\x02루","\x1F꾸"},{"\x1F꾸","\x04루"},{"\x04루","\x1B후"},{"\x1B후","\x08으"}}
local MaskArr = {{0xFFFF00FF,0xFFFF00FF},{0xFFFF00FF,0xFFFF00FF},{0xFFFF00FF,0xFFFF00FF},{0xFFFF00FF,0xFFFF00FF},{0xFFFF00FF,0xFFFF00FF},{0xFFFF00FF,0xFFFF00FF}}
CA__ConvertLetter(Str2,LetterArr,MaskArr,1,19)
CA__InputVA(0,Str2,Str2s,nil,0,39)

end
CAPrint(iStr1,{P1},{1,0,24,0,1,1,0,0},"TEST",P1)
CAPrint(iStr2,{P1},{1,0,12,0,1,2,0,0},"TEST2",P1)

------------------------------------------------------------------------------------------

401

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-17] CAPrint(), CA__ItoName()

CJump(AllPlayers,0)
iStr1 = GetiStrId(P1,MakeiStrLetter(" ",40))
Str1, Str1a, Str1s = SaveiStrArr(P1,"\x04CAPrint \x1B예제\x08-H \x06:\x07 "..MakeiStrVoid(20))
iStr2 = GetiStrId(P1,MakeiStrLetter(" ",30))
Str2, Str2a, Str2s = SaveiStrArr(P1,"\x08P1 : "..MakeiStrVoid(20))
CJumpEnd(AllPlayers,0)
DoActions(P1,DisplayText(MakeiStrWord("\r\n",11),4))
A = CreateVar(P1)
function TEST()
local PlayerID = CAPrintPlayerID
CA__ItoName(SVA1(Str1,15),"Host",A,"■",{0x04,0x08,0x11,0x17,0x7,0xF,0x1F,0x1C,0x10,0x15,0x16,0x1B,0x19,0x1D,0x2,0x1E},1)
CMov(PlayerID,0x58F450,A)
CA__InputVA(0,Str1,Str1s,nil,0,39)
end
function TEST2()
local PlayerID = CAPrintPlayerID
CA__ItoName(SVA1(Str2,5),P1)
CA__InputVA(0,Str2,Str2s,nil,0,29)
end
CAPrint(iStr1,{P1},{1,0,0,0,1,1,0,0},"TEST",P1)
CAPrint(iStr2,{P1},{1,0,0,0,1,2,0,0},"TEST2",P1)
------------------------------------------------------------------------------------------

[예제 26-18] CAPrint(), CA__ItoCustom(), CA__lItoCustom()
CJump(AllPlayers,0)
iStr1 = GetiStrId(P1,"\x13\x04CAPrint \x1B예제\x08-I\r\n"..MakeiStrWord("\x13"..MakeiStrLetter(" ",38).."\r\n",5))
Str1, Str1a, Str1s = SaveiStrArr(P1,MakeiStrVoid(38))
iStr2 = GetiStrId(P1,MakeiStrWord("\x13"..MakeiStrLetter(" ",68).."\r\n",2))
Str2, Str2a, Str2s = SaveiStrArr(P1,MakeiStrVoid(68))
CJumpEnd(AllPlayers,0)
DoActions(P1,DisplayText(MakeiStrWord("\r\n",11),4))
A, B = CreateVars(2,P1) C = CreateWar(P1)
function TEST() local PlayerID = CAPrintPlayerID CRead(PlayerID,A,0x57F0F0)

CA__SetValue(Str1,"_십_억_천_백_십_만_천_백_십_\x04원",nil,2)
local Data = {{1,"일"},{2,"이"},{3,"삼"},{4,"사"},{5,"오"},{6,"육"},{7,"칠"},{8,"팔"},{9,"구"},{0,"\x0D"}}
CA__ItoCustom(SVA1(Str1,0),A,B,nil,10,1,{"\x08·","\x11·","\x17·","\x07·","\x0F·","\x1F·","\x1C·","\x10·","\x15·","\x05·"},{"\x19+ ","\x10- ","\x04영 "},nil
,{0,2,4,6,8,10,12,14,16,18},Data,{{1},{1,2},{3},{4},{5},{3,4,5,6},{7},{8},{9}})
CMov(PlayerID,0x58F450,B)
CA__Input(MakeiStrData("→"),SVA1(Str1,_Sub(_Mul(B,604),604)),0xFFFF0000)
CA__InputVA(41*0+16,Str1,Str1s,nil,41*0+16,41*1+16-3)
CA__SetValue(Str1,MakeiStrVoid(38),0xFFFFFFFF,0)
CA__SetValue(Str1,"_十_億_千_百_十_萬_千_百_十_\x04点",nil,2)
local Data = {{0,"○"},{1,"一"},{2,"二"},{3,"三"},{4,"四"},{5,"五"},{6,"穴"},{7,"七"},{8,"八"},{9,"九"}}
CA__ItoCustom(SVA1(Str1,0),A,B,nil,10,nil,nil,{"\x08▲\x1B ","\x0E▼\x1F ","\x04－"},nil,{0,2,4,6,8,10,12,14,16,18},Data,{{1},{1,2},{3},{4},{5},{3,4,5,6},{7},{8},{9}})
CMov(PlayerID,0x58F454,B)
CA__InputVA(41*1+16,Str1,Str1s,nil,41*1+16,41*2+16-3)
CA__SetValue(Str1,MakeiStrVoid(38),0xFFFFFFFF,0)
CA__Input(MakeiStrData("\x04억",1),SVA1(Str1,3+2))
CA__Input(MakeiStrData("\x04만",1),SVA1(Str1,3+7))
local Data = {{{1,9},{"０",0x1000000}},{0,"\x08０"}}
CA__ItoCustom(SVA1(Str1,0),A,B,nil,10,nil,nil,"\x08헤으응",{0x02,0x1E,0x0E,0x1C,0x1F,0xF,0x1D,0x16,0x1B,0x5},{0,1,3,4,5,6,8,9,10,11},Data,{0,{0},0,0,0,{0},0,0,0})
CMov(PlayerID,0x58F458,B)
CA__InputVA(41*2+16,Str1,Str1s,nil,41*2+16,41*3+16-3)
CA__SetValue(Str1,MakeiStrVoid(38),0xFFFFFFFF,0)
local Data = {{{0,9},{"『0』",{0,0x1000000,0}}},{{10,15},{"『\x37』",{0,0x1000000,0}}}}
CA__ItoCustom(SVA1(Str1,0),A,B,nil,16,3,"\x1F「\x04 \x1F」",nil,{{0x1B,0x4,0x1B},0,{0x19,0x4,0x19},0,{0x1D,0x4,0x1D},0,{0x02,0x4,0x02},0},nil,Data,nil)
CMov(PlayerID,0x58F45C,B)
CA__InputVA(41*3+16,Str1,Str1s,nil,41*3+16,41*4+16-3)
CA__SetValue(Str1,MakeiStrVoid(38),0xFFFFFFFF,0)

end
function TEST2() local PlayerID = CAPrintPlayerID f_LRead(P1,0x58F480,C)

CA__SetValue(Str2,"12\x04,123\x04,123\x04,123\x04,123\x04,123\x04,123￦",nil,1)
CA__lItoCustom(SVA1(Str2,0),C,B,nil,10,1,nil,{"\x1F+","\x08-","\x040"},{0x04,0x04,0x1B,0x1B,0x1B,0x19,0x19,0x19,0x1D,0x1D,0x1D,0x02,0x02,0x2,0x1E,0x1E,0x1E,0x05,0x05,0x05}
,{0,1,3,4,5,7,8,9,11,12,13,15,16,17,19,20,21,23,24,25},nil,{0,{0},0,0,{0},0,0,{0},0,0,{0},0,0,{0},0,0,{0}})
CMov(PlayerID,0x58F460,B)
CA__InputVA(71*0+1,Str2,Str2s,nil,71*0+1,71*1+1-3)
CA__SetValue(Str2,MakeiStrVoid(68),0xFFFFFFFF,0)
CA__lItoCustom(SVA1(Str2,0),C,B,nil,2,1,"\x10_","\x19몰?루\x14 ",nil,nil,{{0,"\x11x"},{1,"\x07o"}})
CMov(PlayerID,0x58F464,B)
CA__InputVA(71*1+1,Str2,Str2s,nil,71*1+1,71*2+1-3)
CA__SetValue(Str2,MakeiStrVoid(68),0xFFFFFFFF,0)

end
CAPrint(iStr1,{P1,Force5},{1,0,0,0,1,1,0,0},"TEST",P1)
CAPrint(iStr2,{P1,Force5},{1,0,0,0,1,2,0,0},"TEST2",P1)

------------------------------------------------------------------------------------------

402

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-19] CAPrint(), CBPrint(), MakeiTblString(), GetiTblId(), CA__ItoCustom()

※ stat_txt.tbl을 EUDEditor2,3으로 편집한 후 EUDEditor2,3으로 빌드(컴파일)해서 맵에 삽입하거나,
EUDEditor2 : 보기→eds파일보기 클릭 후 EUDEditor2폴더\Data\temp → stat_txt.tbl
EUDEditor3 : 빌드 후 EUDEditor3폴더\Data\temp\BuildData_프로젝트이름\temp → custom_txt.tbl
파일 복사 후 CopyTBL.py를 사용해 tbl파일을 맵에 삽입해야함
※ CopyTBL.py 사용방법
어셈블러 폴더의 py폴더 안의 CopyTBL.py을 eudplib의 plugins 폴더에 복사 후
플러그인 입력칸 (또는 .eds 파일)에
플러그인 입력창 입력예시
[CopyTBL]
(custom_txt.tbl을 로드함)
TBL : (tbl파일 이름)
입력 후 저장 한 뒤 EUDEditor2,3 등으로 만든 tbl파일을 eudplib 폴더에 복사 후 컴파일
CJump(AllPlayers,0)
iStr1 = GetiStrId(P1,MakeiStrLetter(" ",20))
S1 = MakeiTblString(372,"일반명령","CU",MakeiStrLetter(" ",20),"Base") -- Cntr+U가 단축키
-- ↑ TBLString.txt에서 == 사이에 들어있는 텍스트를 그대로 복사해서
-- EUDEditor2,3의 372번 TBL스트링에 붙여넣고 해당 tbl파일을 맵에 삽입해야함
iTbl1 = GetiTblId(P1,372,S1)
Str0, Str0a, Str0s = SaveiStrArr(P1,MakeiStrWord("\x1B \x19 \x1D \x16 \x02 \x1E \x04 ",2))
Str1, Str1a, Str1s = SaveiStrArr(P1,MakeiStrWord("\x08 \x11 \x17 \x07 \x1F \x1C \x10 \x15 \x04 ",3))
Str2, Str2a, Str2s = SaveiStrArr(P1," \x04CBPrint \x1B예제\x08-J\x06100.0% ")
CJumpEnd(AllPlayers,0)
DoActions(P1,DisplayText(MakeiStrWord("\r\n",11),4))
DoActions(P1,{CreateUnit(1,"Kakaru (Twilight)","Anywhere",P1),RemoveUnitAt(1,"Kakaru (Twilight)","Anywhere",P1)}) -- TBL Refresh
A, B, C, D, E = CreateVars(5,P1)
function TEST()
local PlayerID = CAPrintPlayerID
DoActionsX(PlayerID,{SetNVar(A,Add,604),SetNVar(C,Add,604),SetNVar(E,Subtract,1)})
TriggerX(PlayerID,NVar(A,AtLeast,9*604),SetNVar(A,SetTo,0*604),{preserved})
TriggerX(PlayerID,NVar(C,AtLeast,7*604),SetNVar(C,SetTo,0*604),{preserved})
TriggerX(PlayerID,NVar(E,Exactly,0),{SetNVar(B,Add,1),SetNVar(E,SetTo,3)},{preserved})
TriggerX(PlayerID,{NVar(B,AtLeast,20+Str2s/2),NVar(B,AtMost,0x7FFFFFFF)},SetNVar(B,SetTo,-Str2s),{preserved})
CMov(PlayerID,D,_Mod(_Read(0x57F0F0),1000))
CA__ItoCustom(SVA1(Str2,14),D,nil,0xFFFF0000,{10,2},1,"0",nil,nil,{0,1,3})
CIfX(PlayerID,Memory(0x57F0F0,Exactly,1000))
CA__Input(MakeiStrData("1",1),SVA1(Str2,13),0xFFFF0000)
CElseX()
CA__Input(MakeiStrData(" ",1),SVA1(Str2,13),0xFFFF0000)
CIfXEnd()

end
function TEST2()
end

CA__InputSVA1(SVA1(Str2,1),SVA1(Str1,A),12,0xFF,1,12)
CA__InputSVA1(SVA1(Str2,13),SVA1(Str0,C),6,0xFF,13,18)
CA__InputVA(B,Str2,Str2s,nil,0,19)

CA__InputVA(B,Str2,Str2s,nil,0,19)

DoActions(P1,{CopyCpAction({LeaderBoardScoreX(Custom,iStr1[4])},{P1},0)},{}) -- 리더보드 액션은 1회만 실행
DoActions(P1,{
CopyCpAction({SetMissionObjectivesX(iStr1[4])},{P1},0); -- String 자체를 넣어야 String 에러가 뜨지않음
SetUnitName(54,iStr1[2]); -- 디버링원 유닛이름 스트링 변경
})
CBPrint(iTbl1,{1,0,0,0,1},"TEST",P1) -- 버로우 버튼
CAPrint(iStr1,P1,{1,0,0,0,1,3,0,0},"TEST2",P1) -- 텍스트, 리더보드, 미션오브젝트, 유닛이름

-----------------------------------------------------------------------------------------403

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-20] CBPrint(), CB__SetHotkey(), CB__SetButtonType()

CJump(AllPlayers,0)
S1 = MakeiTblString(372,"일반명령","CU",MakeiStrWord(MakeiStrLetter("☆",20).."\n",5),"Base")
-- ↑ TBLString.txt에서 == 사이에 들어있는 텍스트를 그대로 복사해서
-- EUDEditor2,3의 372번 TBL스트링에 붙여넣고 해당 tbl파일을 맵에 삽입해야함
iTbl1 = GetiTblId(P1,372,S1)
CJumpEnd(AllPlayers,0)
DoActions(P1,DisplayText(MakeiStrWord("\r\n",11),4))

DoActions(P1,{CreateUnit(1,"Kakaru (Twilight)","Anywhere",P1),RemoveUnitAt(1,"Kakaru (Twilight)","Anywhere",P1)}) -- TBL Refresh

function TEST()

CB__SetHotkey(_ReadFX(0x57F120,0xFF,"+2")) -- 아래 HotkeyCodeDict의 값을 참고
-- 단축키의 값이 0x00일 경우 스트링의 내용이 모두 무시됨 (표시X)
CB__SetButtonType(_ReadFX(0x57F0F0,0xFF,"+3")) -- 아래 ButtonTypeCodeDict의 값을 참고
-- 타입이 N업그레이드일 경우 2번째줄 부분에서 스트링 깨짐 발생함 (단축키 무관)

End
--[[Local HotkeyCodeDict = {
['CA']= 1,['CB']= 2,['CSC']= 3,['CD']= 4,['CE']= 5,['CF']= 6,['CG']= 7,['CI']= 9,['Tab']= 9,
['Center']= 10,['CJ']= 10,['CK']= 11,['CL']= 12,['Enter']= 13,['CSM']= 13,['CN']= 14,['CO']= 15,
['CP']= 16,['CSQ']= 17,['CSR']= 18,['CSS']= 19,['CT']= 20,['CU']= 21,['CV']= 22,['CW']= 23,
['CSX']= 24,['CY']= 25,['CZ']= 26,['ESC']= 27,['C[']= 27,['C\\']= 28,['C]']= 29,['C^']= 30,
['C_']= 31,[' ']= 32,['Space']= 32,['\"']= 34,['\'']= 39,['N*']= 42,['+']= 43,['NS+']= 43,['NA+']= 43,
[',']= 44,['NS-']= 45,['NA-']= 45,['.']= 46,['/']= 47,['N0']= 48,['N1']= 49,['N2']= 50,['N3']= 51,
['N4']= 52,['N5']= 53,['N6']= 54,['N7']= 55,['N8']= 56,['N9']= 57,[':']= 58,[';']= 59,['<']= 60,
['>']= 62,['?']= 63,['[']= 91,['\\']= 92,[']']= 93,['_']= 95,["`"]= 96,['{']= 123,['|']= 124,['}']= 125,
['~']= 126,['CBS']= 127,['None']= 8,['A']= 97,['a']= 97,['B']= 98,['b']= 98,['C']= 99,['c']= 99,
['D']= 100,['d']= 100,['E']= 101,['e']= 101,['F']= 102,['f']= 102,['G']= 103,['g']= 103,['H']= 104,['h']= 104,
['I']= 105,['I']= 105,['J']= 106,['j']= 106,['K']= 107,['k']= 107,['L']= 108,['l']= 108,['M']= 109,['m']= 109,
['N']= 110,['n']= 110,['O']= 111,['o']= 111,['P']= 112,['p']= 112,['Q']= 113,['q']= 113,['R']= 114,['r']= 114,
['S']= 115,['s']= 115,['T']= 116,['t']= 116,['U']= 117,['u']= 117,['V']= 118,['v']= 118,['W']= 119,['w']= 119,
['X']= 120,['x']= 120,['Y']= 121,['y']= 121,['Z']= 122,['z']= 122,}
Local ButtonTypeCodeDict = {

['일반명령']= 0,['유닛생산']= 1,['N업그레이드']= 2,['스킬사용']= 3,['테크업그레이드']= 4,['유닛변태']= 5,['None']= 8,}]]--

CBPrint(iTbl1,{1,0,0,0,1},"TEST",P1) -- 버로우 버튼
------------------------------------------------------------------------------------------

404

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-21] CBPrint(), CB__SetHotkey(), CB__SetButtonType(), CA__MoveXY(),
MakeHotkeyValue(), MakeButtonTypeValue()

CJump(AllPlayers,0)
S1 = MakeiTblString(372,"일반명령","None",MakeiStrWord(MakeiStrLetter(" ",20).."\n",5),"Base")
-- ↑ TBLString.txt에서 == 사이에 들어있는 텍스트를 그대로 복사해서
-- EUDEditor2,3의 372번 TBL스트링에 붙여넣고 해당 tbl파일을 맵에 삽입해야함
iTbl1 = GetiTblId(P1,372,S1)
Str0, Str0a, Str0s = SaveiStrArr(P1,MakeiStrWord("\x1B \x19 \x1D \x16 \x02 \x1E \x04 ",2))
Str1, Str1a, Str1s = SaveiStrArr(P1,MakeiStrWord("\x08 \x11 \x17 \x07 \x1F \x1C \x10 \x15 \x04 ",3))
Str2, Str2a, Str2s = SaveiStrArr(P1," \x04CBPrint \x1B예제\x08-L\x06100.0% ")
Str3, Str3a, Str3s = SaveiStrArr(P1,MakeiStrLetter(" ",32)) -- Path
S2 = MakeiTblString(373,"일반명령","None",MakeiStrWord(MakeiStrLetter(" ",20).."\n",5),"Base")
-- ↑ TBLString.txt에서 == 사이에 들어있는 텍스트를 그대로 복사해서
-- EUDEditor2,3의 373번 TBL스트링에 붙여넣고 해당 tbl파일을 맵에 삽입해야함
iTbl2 = GetiTblId(P1,373,S2)
CJumpEnd(AllPlayers,0)
DoActions(P1,DisplayText(MakeiStrWord("\r\n",11),4))
DoActions(P1,{CreateUnit(1,"Kakaru (Twilight)","Anywhere",P1),RemoveUnitAt(1,"Kakaru (Twilight)","Anywhere",P1)}) -- TBL Refresh

A, B, C, D, E = CreateVars(5,P1)
function TEST()
local PlayerID = CAPrintPlayerID
DoActionsX(PlayerID,{SetNVar(A,Add,604),SetNVar(C,Add,604),SetNVar(E,Subtract,1)})
TriggerX(PlayerID,NVar(A,AtLeast,9*604),SetNVar(A,SetTo,0*604),{preserved})
TriggerX(PlayerID,NVar(C,AtLeast,7*604),SetNVar(C,SetTo,0*604),{preserved})
TriggerX(PlayerID,NVar(E,Exactly,0),{SetNVar(B,Add,1*604),SetNVar(E,SetTo,3)},{preserved})
TriggerX(PlayerID,{NVar(B,AtLeast,(32+Str2s/2)*604),NVar(B,AtMost,0x7FFFFFFF)},
SetNVar(B,SetTo,(-Str2s)*604),{preserved})
CMov(PlayerID,D,_Mod(_Read(0x57F0F0),1000))
CA__ItoCustom(SVA1(Str2,14),D,nil,0xFFFF0000,{10,2},1,"0",nil,nil,{0,1,3})
CIfX(PlayerID,Memory(0x57F0F0,Exactly,1000))
CA__Input(MakeiStrData("1",1),SVA1(Str2,13),0xFFFF0000)
CElseX()
CA__Input(MakeiStrData(" ",1),SVA1(Str2,13),0xFFFF0000)
CIfXEnd()
CA__InputSVA1(SVA1(Str2,1),SVA1(Str1,A),12,0xFF,1,12)
CA__InputSVA1(SVA1(Str2,13),SVA1(Str0,C),6,0xFF,13,18)
CA__InputSVA1(SVA1(Str3,B),Str2,Str2s,nil,0,31)
CA__MoveXY(Str3,21,0,SetTo,1,{{0,0,-1},{1,0,-2},{2,0,-3},{3,0,-4},{13,0,-3},{14,0,-2},{15,0,-1},{16,0,0},{26,0,-1},{27,0,-2},{28,0,-3},{29,0,-4}},0)
CA__InputVA(21*4+0,Str3,Str3s,nil,0,21*5)

end

CB__SetHotkey("CU")
CB__SetButtonType("유닛생산")

function TEST2()
CA__InputVA(21*4+0,Str3,Str3s,nil,0,21*5)
CB__SetHotkey(MakeHotkeyValue("U"))
CB__SetButtonType(MakeButtonTypeValue("스킬사용"))
end
CBPrint(iTbl1,{1,0,0,0,1},"TEST",P1) -- 버로우 버튼
CBPrint(iTbl2,{1,0,0,0,1},"TEST2",P1) -- 언버로우 버튼
------------------------------------------------------------------------------------------

405

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-22] CDPrint(), SaveiStrArrX(), SaveiStrptrX(), _Gindex(), CA__OverWrite()
CJump(AllPlayers,0)
Str1 = SaveiStrArrX(P2,"\x13\x04CAPrint \x07예제\x18-M",1)
Str2 = SaveiStrptrX(P3,"\x1D―\x04테스트☆\x05텍스트★",1)
CJumpEnd(AllPlayers,0)
DoActions(P1,DisplayText(MakeiStrWord("\r\n",11),4))
A = CreateVar2(P1,nil,nil,1) B = CreateVar2(P1,nil,nil,0)
DoActionsX(P1,SetNVar(B,Add,1),{preserved})
TriggerX(P1,{NVar(B,AtLeast,11)},{SetNVar(B,SetTo,1)},{PReserved})
function TEST()
CA__OverWrite(Str1,_GIndex(0),1,1)
end
function TEST2() local PlayerID = CAPrintPlayerID
DoActionsX(PlayerID,{SetNVar(A,Add,1)})
TriggerX(PlayerID,NVar(A,AtLeast,30),SetNVar(A,SetTo,0),{preserved})
CA__OverWrite(Str2,_GIndex(A),0,1)
end
CDPrint({0},1,{" ",0xFFFFFFFF},{P1},{1,0,0,0,1,1,0,0},"TEST",P1)
CDPrint({B},1,{" ",0xFFFFFFFF},{P1},{1,0,0,0,1,1,0,0},"TEST2",P1)

-----------------------------------------------------------------------------------------[예제 26-23] CDPrint(), _GIndex2(), _Chat(), CA__SetValue(), CD__InputVAX(), CD__ScanChat()
CJump(AllPlayers,0)
Str1 = SaveiStrArrX(P1,MakeiStrVoid(4))
Str2 = SaveiStrArrX(P1,MakeiStrVoid(54))
CJumpEnd(AllPlayers,0)
A = CreateVar2(P1,nil,nil,1) B = CreateVar2(P1,nil,nil,0)
C, D, E = CreateVars(3,P1)
-- 가스 1이상 -> 예시 텍스트 출력
TriggerX(P1,{Memory(0x57F120,AtLeast,1)},DisplayText(MakeiStrWord("가나다라마바사\n",11)),{Preserved})
DoActionsX(P1,SetNVar(C,Subtract,1))
TriggerX(P1,{NVar(C,Exactly,0)},{SetNVar(C,SetTo,4),SetNVar(B,Add,1)},{preserved})
TriggerX(P1,{NVar(B,AtLeast,11)},{SetNVar(B,SetTo,0)},{PReserved})
function TEST() -- ScanChat -> 11줄 전체를 utf8 -> iutf8화
CA__SetNext(Str2,8,SetTo,0,53,0)
CMov(P1,D,0)
CWhile(P1,NVar(D,AtMost,10))
CD__ScanChat(Str2,_Chat(D,0),53,E,1,1)
CA__InputVA(_GIndex2(D,0),Str2,E,0xFFFFFFFF,0,604*11)
CWhileEnd(SetNVar(D,Add,1))
end
CDPrint(0,11,{" ",0xFFFFFFFF},{P1},{1,0,0,0,1,1,0,0},"TEST",P1)
function TEST2() -- InputVAX -> 미네랄 값이 X좌표
CA__SetNext(Str1,604,SetTo,0,3,0)
CA__SetValue(Str1,"\x1E \x05■\x02■\x04■",0xFFFFFFFF,0,0,1)
CD__InputVAX(_GIndex(_Read(0x57F0F0)),Str1,4,0xFFFFFFFF,0xFFFFFFFF,0,604*11)
end
CDPrint({B},4,{" ",0},{P1},{1,0,0,0,1,1,0,0},"TEST2",P1)

406

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-24] CDPrint(), f_ChatOffset(), CD__InputMask(), CD__InputVAX(), CD__GetIndex()
CD__ScanChat(), CA__MoveXY(),
CJump(AllPlayers,0)
Str1 = SaveiStrArrX(P1,"\x10\\\x1E·\x1C*\x04＋\x19☆\x17★")
Str2 = SaveiStrArrX(P1,MakeiStrVoid(54*11))
Str3 = SaveiStrArrX(P1,MakeiStrVoid(11)) -- Path↘
VA1 = CVArray(P1,11)
iStr1 = GetiStrId(P1,"\x13\x0D\x04CAPrint \x0D\x19예제\x1E-\x10N\x0D")
CJumpEnd(AllPlayers,0)
SpCode = 0x8880E200 -- 식별자 (텍스트 미출력 라인은 첫 1바이트가 00으로 고정됨)
Line, ChatSize, ChatOff, StarX, StarIndex, Loop = CreateVars(6,P1)
TR, TS, TC, TD = CreateVArrs(4,5,P1)
-- 가스 1이상 -> 예시 텍스트 출력
TriggerX(P1,{Memory(0x57F120,Exactly,1)},{DisplayText(MakeiStrWord(MakeiStrLetter(" ",12).."\n",11)),SetMemory(0x6509B0,SetTo,1),
DisplayText(MakeiStrWord(MakeiStrLetter(" ",12).."\n",11)),SetMemory(0x6509B0,SetTo,0)},{Preserved})
CAPrint(iStr1,P1,{1,0,0,0,1,3,0,0},nil,{P1,P2},Memory(0x57F120,Exactly,2))
function TEST() -- ScanChat -> 11줄 전체를 utf8 -> iutf8화 (식별자로 중복방지)
CA__SetNext(Str2,8,SetTo,0,54*11-1,0)
CMov(P1,Line,0)
CWhile(P1,NVar(Line,AtMost,10))
CIfX(P1,{TTDisplayX(Line,0,"!=",SpCode,0xFFFFFF00)})
CA__SetValue(Str2,MakeiStrLetter(" ",53),0xFFFFFFFF,_Mul(Line,54*604),1,1)
f_ChatOffset(P1,Line,0,ChatOff)
CD__ScanChat(SVA1(Str2,_Mul(Line,604*54)),ChatOff,52,ChatSize,0,1)
CD__InputVAX(_GIndex2(Line,1),SVA1(Str2,_Mul(Line,604*54)),52,0xFFFFFFFF,0xFFFFFFFF,8,604*11-1)
CA__SetMemoryX(_GIndex2(Line,0),SpCode+0x0D,0xFFFFFFFF,1)
CD__InputMask(Line,0xFFFFFFFF,0,52)
CMovX(P1,VArr(VA1,Line),_Sub(ChatSize,1))
CElseIfX({Always()})
CD__InputVAX(_GIndex2(Line,1),SVA1(Str2,_Mul(Line,604*54)),52,0xFFFFFFFF,0xFFFFFFFF,8,604*11-1)
CIfXEnd()
CWhileEnd(SetNVar(Line,Add,1))
end
CDPrint(0,11,{" ",0},{P1,P2},{1,0,0,0,1,1,0,0},"TEST",P1)
Reset = {16,19,23,28,34}
for i = 0, 4 do
CTrigger(P1,CVAar(VArr(TD,i),Exactly,0),{TSetCVAar(VArr(TD,i),SetTo,_ReadF(0x57F0F0)),SetCVAar(VArr(TC,i),Add,1*604)},{preserved})
CIf(P1,{CVAar(VArr(TC,i),AtLeast,Reset[i+1]*604),CVAar(VArr(TC,i),AtMost,0x7FFFFFFF)},SetCVAar(VArr(TC,i),SetTo,-604*5))
CMov(P1,VArr(TS,i),_iSub(_Mod(_Rand(),63),10))
CIfEnd()
end
DoActionsX(P1,{

SetCVAar(VArr(TD,0),Subtract,1),
SetCVAar(VArr(TD,1),Subtract,1),
SetCVAar(VArr(TD,2),Subtract,1),
SetCVAar(VArr(TD,3),Subtract,1),
SetCVAar(VArr(TD,4),Subtract,1),

})
function TEST2() -- X = 1 ~ 42 / 43 ~ 52 -> y잘림
CA__SetMask(Str3,0,0,10)

CA__InputSVA1X(SVA1(Str3,_MovX(VArr(TC,Loop))),Str1,6,0xFFFFFFFF,0xFFFFFFFF,0,10)
CMovX(P1,StarX,VArr(TS,Loop))
CA__MoveXY(Str3,604,nil,SetTo,1,{{0,1*8,1},{1,2*8,2},{2,3*8,3},{3,4*8,4},{4,5*8,5},{5,6*8,6},{6,7*8,7},{7,8*8,8},{8,9*8,9},{9,10*8,10},{10,0,111*604}})
TriggerX(P1,NVar(StarX,Exactly,0),SetNVar(StarX,SetTo,-1),{preserved})
CIfX(P1,{NVar(StarX,AtLeast,43),NVar(StarX,AtMost,0x7FFFFFFF)})
CA__MoveXY(Str3,604,nil,SetTo,nil,{{_Mul(_Sub(_Mov(52),StarX),604),604*11}})
CD__GetIndex(StarX,StarIndex)
CElseIfX({NVar(StarX,AtLeast,0x80000000)}) -- -1 ~ -10
CA__MoveXY(Str3,604,nil,SetTo,nil,{{_Mul(_Sub(_Neg(StarX),1),604),604*111}})
CMov(P1,StarIndex,_Add(_Mul(_Add(StarX,1),8),612-604*111))
CElseX()
CD__GetIndex(StarX,StarIndex)
CIfXEnd()
end

CD__InputVAX(StarIndex,Str3,11,nil,0xFFFFFFFF,8,604*11-1)

CMov(P1,Loop,0)
CWhile(P1,NVar(Loop,AtMost,4))
CDPrint({0},11,{" ",0},{P1,P2},{1,0,0,0,1,1,0,0},"TEST2",P1)
CWhileEnd(SetNVar(Loop,Add,1))

------------------------------------------------------------------------------------------

407

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-25] CDPrint(), CS__ItoCustom(), TTbytecmp(), TTDisplay(), CD__ScanChat()
CJump(AllPlayers,0)
Str1 = SaveiStrArrX(P1,MakeiStrWord("\x0E \x1C \x1F \x0F \x1D \x16 \x04 \x1B ",4)) -- 26+6
Str2 = SaveiStrArrX(P1,MakeiStrVoid(54*11))
Str3, Str3a, Str3s = SaveiStrArrX(P1,"\x13\x08[\x04경과시간\x08] \x1B__\x06:\x1B__")
VA1 = CVArray(P1,4*4)
VA2 = CVArray(P1,4*5)
CJumpEnd(AllPlayers,0)
Line, ChatSize, ChatOff, Loop, Check, ILoop, EC, ETime, EM, ES = CreateVars(10,P1)
PLength = CreateVarArr(2,P1)
PAddr = CreateVarArr(2,P1)
PS = CreateVArr(11,P1)
CIfOnce(P1)
CbyteConvert(P1,VArr(VA1,0),GetStrArr(0,"!시간"))
CbyteConvert(P1,VArr(VA2,0),GetStrArr(0,"!이펙트"))
GetPlayerLength(P1,P1,PLength[1])
GetPlayerLength(P1,P2,PLength[2])
DoActionsX(P1,{SetNVar(PLength[1],Add,3),SetNVar(PLength[2],Add,3)})
CIfEnd()
SpCodeBase = 0x8080E200
SpCode0 = 0x8880E200 -- 식별자 (텍스트 미출력 라인은 첫 1바이트가 00으로 고정됨)
SpCode1 = 0x8980E200 -- !시간
SpCode2 = 0x8a80E200 -- !이펙트

DoActionsX(P1,SetNVar(EC,Add,604))
TriggerX(P1,NVar(EC,AtLeast,8*604),SetNVar(EC,SetTo,0),{Preserved})
-- 미네랄 1 -> 식별자 포함 텍스트 출력
TriggerX(P1,{Memory(0x57F0F0,Exactly,1)},{SetMemory(0x57F0F0,SetTo,0),DisplayText("!시간")
,SetMemory(0x6509B0,SetTo,1),DisplayText("!시간"),SetMemory(0x6509B0,SetTo,0)},{Preserved})
CRead(P1,ETime,0x57F23C)
CMod(P1,ES,ETime,24*60)
CMov(P1,EM,V(CRet[1]))
CDiv(P1,ES,24)
local Data = {{0,"０"},{1,"１"},{2,"２"},{3,"３"},{4,"４"},{5,"５"},{6,"６"},{7,"７"},{8,"８"},{9,"９"}}
CS__ItoCustom(P1,Str3,EM,nil,nil,{10,2},1,"\x1B０",nil,{0x1B,0x1B},{8,9},Data,nil,1)
CS__ItoCustom(P1,Str3,ES,nil,nil,{10,2},1,"\x1B０",nil,{0x1B,0x1B},{11,12},Data,nil,1)
function TEST() -- ScanChat -> 11줄 전체를 utf8 -> iutf8화 (식별자로 중복방지)
CA__SetNext(Str2,8,SetTo,0,54*11-1,0)
CMov(P1,Line,0)
CWhile(P1,NVar(Line,AtMost,10),SetNVar(Check,SetTo,0))
f_ChatOffset(P1,Line,0,ChatOff)
CAdd(P1,PAddr[1],ChatOff,PLength[1])
CAdd(P1,PAddr[2],ChatOff,PLength[2])
CTrigger(P1,{TTbytecmp(ChatOff,VArr(VA1,0),GetStrSize(0,"!시간"))},{SetNVar(Check,SetTo,1),TBwrite(ChatOff,SetTo,0)},{preserved})
CIf(P1,{TTbytecmp(PAddr[1],VArr(VA2,0),GetStrSize(0,"!이펙트"))},{SetNVar(Check,SetTo,2)})
CMovX(P1,VArr(PS,Line),_Add(PLength[1],-1))
CIfEnd()
CIf(P1,{TTbytecmp(PAddr[2],VArr(VA2,0),GetStrSize(0,"!이펙트"))},{SetNVar(Check,SetTo,2)})
CMovX(P1,VArr(PS,Line),_Add(PLength[2],-1))
CIfEnd()
CIfX(P1,{TTDisplayX(Line,0,"!=",SpCodeBase,0xF0FFFF00)}) -- 0x8080E2 ~ 0x8F80F2 인식
CA__SetValue(Str2,MakeiStrLetter(" ",53),0xFFFFFFFF,_Mul(Line,54*604),1,1)
CD__ScanChat(SVA1(Str2,_Mul(Line,604*54)),ChatOff,52,ChatSize,0,1)
CIfX(P1,NVar(Check,Exactly,2))
CA__SetValue(Str2,MakeiStrLetter("\x0D",4),0xFFFFFFFF,_Mul(_Add(_Mul(Line,54),VArr(PS,Line)),604),1,1)
CA__SetMemoryX(_GIndex2(Line,0),SpCode2+0x0D,0xFFFFFFFF,1)
CElseIfX(NVar(Check,Exactly,1))
CA__SetMemoryX(_GIndex2(Line,0),SpCode1+0x0D,0xFFFFFFFF,1)
CElseX()
CA__SetMemoryX(_GIndex2(Line,0),SpCode0+0x0D,0xFFFFFFFF,1)
CIfXEnd()
CD__InputVAX(_GIndex2(Line,1),SVA1(Str2,_Mul(Line,604*54)),52,0xFFFFFFFF,0xFFFFFFFF,8,604*11-1)
CD__InputMask(Line,0xFFFFFFFF,0,52)
CElseIfX({TTDisplay(Line,"On")})
CIfX(P1,{TTDisplayX(Line,0,Exactly,SpCode2,0xFFFFFF00)})
CA__InputSVA1(SVA1(Str2,_Mul(_Add(_Mul(Line,54),VArr(PS,Line)),604)),SVA1(Str1,EC),26,0xFF,0,54*11-1)
CElseIfX({TTDisplayX(Line,0,Exactly,SpCode1,0xFFFFFF00)})
CA__InputSVA1(SVA1(Str2,_Mul(Line,54*604)),Str3,Str3s,0xFFFFFFFF,0,54*11-1)
CIfXEnd()
CD__InputVAX(_GIndex2(Line,1),SVA1(Str2,_Mul(Line,604*54)),52,0xFFFFFFFF,0xFFFFFFFF,8,604*11-1)
CIfXEnd()
CWhileEnd(SetNVar(Line,Add,1))
end
CDPrint(0,11,{" ",0},{P1,P2},{1,0,0,0,1,1,0,0},"TEST",P1)

------------------------------------------------------------------------------------------

408

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-26] CDPrint() (칭호 생성 예제)

CJump(AllPlayers,0)
Str1 = SaveiStrArrX(P1,"\x05<屋上> \x10<十층> \x0E<九층> \x1C<八층> \x1F<七층> \x07<穴층> \x17<五층> \x11<四층> \x08<三층> \x1B<二층> \x04<一층> ") -- 5x11
Str2 = SaveiStrArrX(P1,MakeiStrVoid(54*11))
Str3 = SaveiStrArrX(P1,MakeiStrVoid(54))
VA1 = CVArray(P1,100)
CJumpEnd(AllPlayers,0)
Line, ChatSize, ChatOff, Check, PLength, DLine = CreateVars(6,P1)
CIfOnce(P1)
GetPlayerLength(P1,P1,PLength)
f_byteConvert(P1,VArr(VA1,0),0x6D0FDC,PLength)
CIfEnd()
SpCodeBase = 0x8080E200
SpCode0 = 0x8880E200 -- 식별자 (텍스트 미출력 라인은 첫 1바이트가 00으로 고정됨)
SpCode1 = 0x8980E200 -- P1 아이디
-- 0 : Resize / 1 : 식별자 / 2~6 : 칭호 / 7 ~ 52 : 채팅내용 / 53 : Null
function TEST() -- ScanChat -> 11줄 전체를 utf8 -> iutf8화 (식별자로 중복방지)
CA__SetNext(Str2,8,SetTo,0,54*11-1,0)

CMov(P1,Line,0)
CWhile(P1,NVar(Line,AtMost,10),SetNVar(Check,SetTo,0))
f_ChatOffset(P1,Line,0,ChatOff)
CTrigger(P1,{TTbytecmp(ChatOff,VArr(VA1,0),PLength)},{SetNVar(Check,SetTo,1)},{Preserved})
CIfX(P1,{TTDisplayX(Line,1,"!=",SpCodeBase,0xF0FFFF00)}) -- 0x8080E2 ~ 0x8F80F2 인식
CA__SetValue(Str2,MakeiStrLetter(" ",53),0xFFFFFFFF,_Mul(Line,54*604),1,1)
CIfX(P1,NVar(Check,Exactly,1))
CD__ScanChat(SVA1(Str2,_Mul(_Add(_Mul(Line,54),5),604)),ChatOff,46,ChatSize,0,1)
CA__SetValue(Str2,MakeiStrLetter("\x0D",5),0xFFFFFFFF,_Mul(Line,54*604),1,1)
CA__Input(0x08,SVA1(Str2,_Mul(_Add(_Mul(Line,54),5),604)),0xFF)
CA__SetMemoryX(_GIndex2(Line,1),SpCode1+0x0D,0xFFFFFFFF,1)
CElseX()
CD__ScanChat(SVA1(Str2,_Mul(Line,604*54)),ChatOff,51,ChatSize,0,1)
CA__SetMemoryX(_GIndex2(Line,1),SpCode0+0x0D,0xFFFFFFFF,1)
CIfXEnd()
CD__InputVAX(_GIndex2(Line,2),SVA1(Str2,_Mul(Line,604*54)),51,0xFFFFFFFF,0xFFFFFFFF,8,604*11-1)
CA__SetMemoryX(_GIndex2(Line,0),0x0D0D0D0D,0xFFFFFFFF,1) CD__InputMask(Line,0xFFFFFFFF,0,52)
CElseIfX({TTDisplay(Line,"On")})
CIf(P1,{TTDisplayX(Line,1,Exactly,SpCode1,0xFFFFFF00)})
CD__Resize(Line,_Read(0x57F0F0)) CD__InputMask(Line,0xFFFFFFFF,0,0)
CD__GetDisplayLine(Line,DLine)
CA__InputSVA1(SVA1(Str2,_Mul(Line,54*604)),SVA1(Str1,_Mul(DLine,5*604)),5,0xFFFFFFFF,0,54*11-1)
CIfEnd()
CD__InputVAX(_GIndex2(Line,2),SVA1(Str2,_Mul(Line,604*54)),51,0xFFFFFFFF,0xFFFFFFFF,8,604*11-1)
CIfXEnd()
CWhileEnd(SetNVar(Line,Add,1))
end
CDPrint(0,11,{" ",0},{P1,P2},{1,0,0,0,1,1,0,0},"TEST",P1)

------------------------------------------------------------------------------------------

409

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-27] CDPrint(), C13Print(), CreateSV54(), MakeiStrDataX(), MakeiStrDiffX(), CA__ConvertLetter()
CJump(AllPlayers,0)
Str1, Str1a, Str1s = SaveiStrArrX(P1,"\x13\x04CDPrint \x18예제\x10-O")
Str2, Str2a, Str2s = SaveiStrArrX(P1,"\x13으후루꾸\x05루\x05후으후루꾸\x05루\x05후으후루꾸\x05루\x05후으")
Str54 = CreateSV54(P1,MakeiStrVoid(40))
CJumpEnd(AllPlayers,0)
TriggerX(P1,Memory(0x57F0F0,AtLeast,1),DisplayText(MakeiStrWord("

\r\n",11),4),{Preserved})

A = CreateVar2(P1,nil,nil,MakeiStrDataX("ａ",1)) B = CreateVar2(P1,nil,nil,MakeiStrDataX(" ",1)) C = CreateVar2(P1,nil,nil,MakeiStrDataX("☆",1))
D = CreateVar2(P1,nil,nil,0x1E) E = CreateVar2(P1,nil,nil,MakeiStrDataX("A",1)) F = CreateVar2(P1,nil,nil,MakeiStrDataX("Z",1))
G = CreateVar2(P1,nil,nil,MakeiStrDiffX("A","ａ")) H = CreateVar2(P1,nil,nil,MakeiStrDataX("A",1))
function TEST()
CA__SetNext(Str1,8,SetTo,0,Str1s-1)
local LetterArr = {{{E,F},G,{H,0xFFFF00}},{{"a","z"},{"a","Ａ"},0xFFFF00},{"-","－",{0x1E,0xFF}},{B,C},
{{"Ａ","Ｚ"},{"Ａ","a"},{MakeiStrData("Ａ",1),0xFFFF00}},{{"ａ","ｚ"},{"ａ","A"},{A,0xFFFF00}},{"－","-",{D,0xFF}},{C,B}}
CA__ConvertLetter(Str1,LetterArr,nil,1,12,1)
CD__InputVAX(0,Str1,Str1s,0xFFFFFFFF,0xFFFFFFFF,0,29*8)
end
function TEST2()

CA__SetNext(Str2,8,SetTo,0,Str2s-1)
local PlayerID = CAPrintPlayerID
CIfOnce(PlayerID)
CA__ConvertColor(Str2,{{MakeiStrDataX("으",1),MakeiStrDataX("\x08으",1)},{MakeiStrDataX("후",1),MakeiStrDataX("\x04후",1)},{MakeiStrDataX("루",1),MakeiStrDataX("\x02루",1)},
{MakeiStrDataX("꾸",1),MakeiStrDataX("\x1F꾸",1)},{MakeiStrDataX("\x05루",1),MakeiStrDataX("\x04루",1)},{MakeiStrDataX("\x05후",1),MakeiStrDataX("\x1B후",1)}},
{{0xFFFFFFFF,0xFFFFFFFF},{0xFFFFFFFF,0xFFFFFFFF},{0xFFFFFFFF,0xFFFFFFFF},{0xFFFFFFFF,0xFFFFFFFF},{0xFFFFFFFF,0xFFFFFFFF},{0xFFF FFFFF,0xFFFFFFFF}},1,19)

CIfEnd()

local LetterArr = {{"\x08으","\x04후"},{"\x04후","\x02루"},{"\x02루","\x1F꾸"},{"\x1F꾸","\x04루"},{"\x04루","\x1B후"},{"\x1B후","\x08으"}}
local MaskArr = {{0xFFFFFFFF,0xFFFFFFFF},{0xFFFFFFFF,0xFFFFFFFF},{0xFFFFFFFF,0xFFFFFFFF},{0xFFFFFFFF,0xFFFFFFFF},{0xFFFFFFFF,0xFFFFFFFF},{0xFFFFFFFF,0xFFFFFFFF}}

end

CA__ConvertLetter(Str2,LetterArr,MaskArr,1,19,1)
CA__InputVA(0,Str2,Str2s,nil,0,39*8)

CDPrint({10},1,{" ",0},P1,{1,0,24,0,1,0,0,0},"TEST",P1)
C13Print(Str54,P1,{1,0,12,0,1,0,0,0},"TEST2",P1)

-----------------------------------------------------------------------------------------[예제 26-28] Display(), TTDisplay()
CRead(P1,0x58F450,0x640B58)
for i = 0, 10 do

TriggerX(P1,{Display(i,"On")},{SetMemoryX(0x58F454+4*i,SetTo,1,0xFF)},{Preserved})
TriggerX(P1,{Display(i,"Off")},{SetMemoryX(0x58F454+4*i,SetTo,0,0xFF)},{Preserved})

end
TriggerX(P1,{Display(12,"On")},{SetMemory(0x57F0F0,SetTo,1)},{Preserved})
TriggerX(P1,{Display(12,"Off")},{SetMemory(0x57F0F0,SetTo,0)},{Preserved})

X = CreateVar(P1)
for i = 0, 10 do
CS__GetLine(P1,i,X)
CTrigger(P1,{TTDisplay(X,"On")},{SetMemoryX(0x58F454+4*i,SetTo,1*256,0xFF00)},{Preserved})
CTrigger(P1,{TTDisplay(X,"Off")},{SetMemoryX(0x58F454+4*i,SetTo,0*256,0xFF00)},{Preserved})
end
CTrigger(P1,{TTDisplay(_Mov(12),"On")},{SetMemory(0x57F120,SetTo,1)},{Preserved})
CTrigger(P1,{TTDisplay(_Mov(12),"Off")},{SetMemory(0x57F120,SetTo,0)},{Preserved})

------------------------------------------------------------------------------------------

410

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-29] DisplayX(), TTDisplayX()

CJump(AllPlayers,0)
Str1, Str1a, Str1s = SaveiStrArrX(P1,"\x040\x1B1\x082\x113\x174\x075\x1F6\x1C7\x0E8\x109\x15A")
SV541 = CreateSV54(P1,"\x05C")
SV542 = CreateSV54(P1,"\x0D")
CJumpEnd(AllPlayers,0)
CRead(P1,0x58F450,0x640B58)
DoActionsX(P1,{DisplayText(MakeiStrWord("\r\n",11))})
function TEST()

end

CA__SetNext(Str1,604,SetTo,0,Str1s-1)
CA__InputVA(0,Str1,Str1s,0xFFFFFFFF,0,11*604)

CDPrint(0,11,{" ",0xFFFFFFFF},P1,{1,0,0,0,1,1,0,0},"TEST",P1,MemoryX(0x57F120,Exactly,0,0xFF))
CDPrint({0},11,{" ",0xFFFFFFFF},P1,{1,0,0,0,1,1,0,0},"TEST",P1,MemoryX(0x57F120,Exactly,1,0xFF))
C13Print({SV541,SV542},P1,{_Read(0x57F0F0,0xFF),0,0,0,1,0,0,0},nil,P1,{Memory(0x57F0F0,AtLeast,1),Memory(0x57F0F0,AtMost,2)})
for i = 0, 10 do

DoActionsX(P1,{SetMemoryX(0x58F454+4*i,SetTo,0,0xFF)})
if i == 10 then
TriggerX(P1,{DisplayX(i,0,bit32.band(MakeiStrDataX("A",1),0xFFFFFF00),0xFFFFFF00)},{SetMemoryX(0x58F454+4*i,SetTo,1,0xFF)},{Preserved})
else
TriggerX(P1,{DisplayX(i,0,bit32.band(MakeiStrDataX(""..i,1),0xFFFFFF00),0xFFFFFF00)},{SetMemoryX(0x58F454+4*i,SetTo,1,0xFF)},{Preserved})
end

end
DoActionsX(P1,{SetMemoryX(0x57F120,SetTo,0,0xFF00)})
TriggerX(P1,{DisplayX(12,0,bit32.band(MakeiStrDataX("C",1),0xFFFFFF00),0xFFFFFF00)},{SetMemoryX(0x57F120,SetTo,1*256,0xFF00)},{Preserved})
X = CreateVar(P1)
for i = 0, 10 do

CS__GetLine(P1,i,X)
if i == 10 then
CTrigger(P1,{TTDisplayX(X,_Mov(0),NotSame,bit32.band(MakeiStrDataX("A",1),0xFFFFFF00),0xFFFFFF00)},{SetMemoryX(0x58F454+4*i,SetTo,0*256,0xFF00)},{Preserved})
CTrigger(P1,{TTDisplayX(X,_Mov(0),Exactly,bit32.band(MakeiStrDataX("A",1),0xFFFFFF00),0xFFFFFF00)},{SetMemoryX(0x58F454+4*i,SetTo,1*256,0xFF00)},{Preserved})
else
CTrigger(P1,{TTDisplayX(X,_Mov(0),NotSame,bit32.band(MakeiStrDataX(""..i,1),0xFFFFFF00),0xFFFFFF00)},{SetMemoryX(0x58F454+4*i,SetTo,0*256,0xFF00)},{Preserved})
CTrigger(P1,{TTDisplayX(X,_Mov(0),Exactly,bit32.band(MakeiStrDataX(""..i,1),0xFFFFFF00),0xFFFFFF00)},{SetMemoryX(0x58F454+4*i,SetTo,1*256,0xFF00)},{Preserved})
end

end
CTrigger(P1,{TTDisplayX(_Mov(12),_Mov(0),NotSame,bit32.band(MakeiStrDataX("C",1),0xFFFFFF00),0xFFFFFF00)},{SetMemoryX(0x57F120,SetTo,0*65536,0xFF0000)},{Preserved})
CTrigger(P1,{TTDisplayX(_Mov(12),_Mov(0),Exactly,bit32.band(MakeiStrDataX("C",1),0xFFFFFF00),0xFFFFFF00)},{SetMemoryX(0x57F120,SetTo,1*65536,0xFF0000)},{Preserved})

-----------------------------------------------------------------------------------------[예제 26-30] f_Strlen()
X = CreateVar(P1)
for i = 0, 10 do
CS__GetLine(P1,i,X)
f_Strlen(P1,X,0x58F454+i*4,0x58F450)
end
-----------------------------------------------------------------------------------------[예제 26-31] f_Strlen(), MakeChatOffset(), f_ChatOffset(), _Chat()
CMov(P1,0x58F458,MakeChatOffset(12,0))
f_Strlen(P1,12,0x58F45C,0x58F460)
for i = 0, 6 do
CMov(P1,0x58F464+4*i,MakeChatOffset(i,4))
end
f_ChatOffset(P1,_Read(0x57F0F0),_Read(0x57F120),0x58F450)
CMov(P1,0x58F454,_Chat(_Read(0x57F0F0),_Read(0x57F120)))
-----------------------------------------------------------------------------------------411

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-32] CSVA1(), SetCSVA1(), TCSVA1(), TSetCSVA1(), TTCSVA1()
CJump(AllPlayers,0)
Str1, Str1a, Str1s = SaveiStrArr(P1,"\x0401\x0423456789")
iStr1 = GetiStrId(P1,MakeiStrVoid(20))
CJumpEnd(AllPlayers,0)

TriggerX(P1,CSVA1(SVA1(Str1,1),Exactly,0x31000000,0xFF000000),SetCSVA1(SVA1(Str1,1),SetTo,0x1F,0xFF),{Preserved})
X = CreateVar(P1)
CMul(P1,X,_Read(0x57F0F0),604)
CTrigger(P1,{TCSVA1(SVA1(Str1,X),AtLeast,0x35000000,0xFF000000)},{TSetCSVA1(SVA1(Str1,X),SetTo,_Mov(0x41000000),0xFF000000)},{Preserved})

CTrigger(P1,{TTCSVA1(SVA1(Str1,_Mul(_Read(0x57F120),604)),"!=",_Mov(0x0D),0xFF)},{DisplayText("컬러코드 O")},{Preserved})

function TEST()
end

CA__InputVA(0,Str1,Str1s,0xFFFFFFFF,0,19)

CAPrint(iStr1,P1,{1,0,0,0,1,3,0,0},"TEST",P1)

-----------------------------------------------------------------------------------------[예제 26-33] CD__GetLine(), CD__GetDisplayLine()
function TEST()

end

CRead(P1,0x58F450,0x640B58)
CD__GetLine(_Read(0x57F0F0),0x58F454)
CD__GetDisplayLine(_Read(0x57F0F0),0x58F458)

CDPrint({0},1,{" ",0xFFFFFFFF},P1,{1,0,0,0,1,1,0,0},"TEST",P1)
-----------------------------------------------------------------------------------------[예제 26-34] CD__GetIndex(), CD__GetMask(), _Gindex(), _Mindex()
function TEST()

end

CD__GetIndex(_Read(0x57F0F0),0x58F450)
CD__GetMask(_Read(0x57F0F0),0x58F454)
CMov(P1,0x58F458,_GIndex(_Read(0x57F0F0)))
CMov(P1,0x58F45C,_MIndex(_Read(0x57F0F0)))

CDPrint({0},1,{" ",0xFFFFFFFF},P1,{1,0,0,0,1,1,0,0},"TEST",P1)
-----------------------------------------------------------------------------------------[예제 26-35] CD__GetIndex2(), CD__GetMask2(), _Gindex2(), _Mindex2()
function TEST()

end

CD__GetIndex2(_Read(0x57F0F0),_Read(0x57F120),0x58F450)
CD__GetMask2(_Read(0x57F0F0),_Read(0x57F120),0x58F454)
CMov(P1,0x58F458,_GIndex2(_Read(0x57F0F0),_Read(0x57F120)))
CMov(P1,0x58F45C,_MIndex2(_Read(0x57F0F0),_Read(0x57F120)))

CDPrint({0},1,{" ",0xFFFFFFFF},P1,{1,0,0,0,1,1,0,0},"TEST",P1)
------------------------------------------------------------------------------------------

412

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-36] CDPrint(), CA__GetName()

CJump(AllPlayers,0)
iStr1 = GetiStrId(P1,MakeiStrVoid(25).."\n"..MakeiStrVoid(25))
Str1, Str1a, Str1s = SaveiStrArr(P1,"\x1FHost : \x07"..MakeiStrVoid(16))
Str2, Str2a, Str2s = SaveiStrArr(P1,"\x04Name : \x07"..MakeiStrVoid(16))
Str3, Str3a, Str3s = SaveiStrArr(P1,"\x04Name : \x07"..MakeiStrVoid(16))
CJumpEnd(AllPlayers,0)
X = CreateVar(P1)
function TEST()
CA__GetName(SVA1(Str1,7),"Host",X)
CA__InputVA(0,Str1,_Add(X,7),0xFFFFFFFF,0,24)
CA__GetName(SVA1(Str2,7),_Read(0x57F0F0),X)
CA__InputVA(26,Str2,Str2s,0xFFFFFFFF,26,50)

end
CAPrint(iStr1,P1,{1,0,0,0,1,3,0,0},"TEST",P1)
function TEST2()

CA__SetNext(Str3,8,SetTo,0,Str3s-1)
CA__GetName(SVA1(Str3,7),_Read(0x57F0F0),X)
CA__InputVA(0,Str3,Str3s,0xFFFFFFFF,0,54*8)

end
CDPrint({10},1,{" ",0xFFFFFFFF},P1,{1,0,0,0,1,0,0,0},"TEST2",P1)

-----------------------------------------------------------------------------------------[예제 26-37] CDPrint(), CA__ItoName(), CA__epdcpy()
CJump(AllPlayers,0)
Str1, Str1a, Str1s = SaveiStrArr(P1,"\x1FHost : \x07"..MakeiStrVoid(16))
Str2, Str2a, Str2s = SaveiStrArr(P1,MakeiStrVoid(40))
CJumpEnd(AllPlayers,0)
X, Y = CreateVars(2,P1)
DoActionsX(P1,SetNVar(Y,Add,1*604))
TriggerX(P1,NVar(Y,AtLeast,15*604),SetNVar(Y,SetTo,0),{Preserved})
function TEST()

CA__SetNext(Str2,8,SetTo,0,Str2s-1)
CA__epdcpy(Str1,0x04,0xFF,7,Str1s-1)
CA__ItoName(SVA1(Str1,7),"Host",nil,nil,1,1)
CA__epdcpy(Str2,_Mov(MakeiStrDataX("＃",1)),0xFFFFFFFF,_Mov(0),_Mov((Str2s-1)*604))
CA__InputSVA1(SVA1(Str2,Y),Str1,Str1s,0xFFFFFFFF,0,39)
CA__InputVA(0,Str2,Str2s-1,0xFFFFFFFF,0,54*8)

end
CDPrint({0},1,{" ",0xFFFFFFFF},P1,{1,0,0,0,1,1,0,0},"TEST",P1)
------------------------------------------------------------------------------------------

413

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-38] CDPrint(), CA__epdcmp(), TTepdcmp()
CJump(AllPlayers,0)
Str1, Str1a, Str1s = SaveiStrArr(P1,"12345")
Str2, Str2a, Str2s = SaveiStrArr(P1,MakeiStrVoid(40))
CJumpEnd(AllPlayers,0)
PL = CreateVar(P1)
CIfOnce(P1)
GetPlayerLength(P1,P1,PL)
DoActionsX(P1,SetNVar(PL,Add,3))
CIfEnd()
X = CreateVar(P1) Y, Z = CreateCcodes(2)
function TEST()
CD__GetLine(10,X)
CD__ScanChat(Str2,_Chat(X,PL),5)

CA__epdcmp(Str1,Str2,5,0xFF000000,Y)
CA__epdcmp(SVA1(Str1,_Mov(1*604)),SVA1(Str2,_Mov(1*604)),_Mov(4),0xFF000000,Z)
CA__Movcpy(Str2,0x58F454,5,0xFFFFFFFF,0xFFFFFFFF)
CMov(P1,0x58F450,0)
TriggerX(P1,CDeaths(P1,Exactly,1,Y),SetMemoryX(0x58F450,SetTo,1,0xFF),{Preserved})
TriggerX(P1,CDeaths(P1,Exactly,1,Z),SetMemoryX(0x58F450,SetTo,1*256,0xFF00),{Preserved})
CTrigger(P1,{TTepdcmp(Str1,Str2,5,0xFF000000)},SetMemoryX(0x58F450,SetTo,1*65536,0xFF0000),{Preserved})
CTrigger(P1,{TTepdcmp(SVA1(Str1,_Mov(1*604)),SVA1(Str2,_Mov(1*604)),_Mov(4),0xFF000000)},SetMemoryX(0x58F450,SetTo,1*16777216,0xFF000000),{Preserved})

end

CDPrint({10},1,{" ",0},P1,{1,0,0,0,1,1,0,0},"TEST",P1)

-----------------------------------------------------------------------------------------[예제 26-39] C13Print(), CD__Resize(), CD__SetMaskX(), CD__InputMask()
CJump(AllPlayers,0)
SV542 = CreatesV54(P1,MakeiStrVoid(54))

SV541 = CreateSV54(P1,MakeiStrVoid(40).."\x040\x1B1\x082\x113\x174\x075\x1F6\x1C7\x0E8\x109")

CJumpEnd(AllPlayers,0)
function TEST()

CD__Resize(0,_Read(0x57F120))
CD__SetMaskX(0,_Mov(0xFFFFFFFF))
CD__InputMask(0,0,40,49)
CD__SetMaskX(_GIndex(_Add(_Read(0x57F0F0),40)),0xFFFFFFFF)

end
C13Print(SV542,P1,{1,0,0,0,1,0,0,0},nil,P1)
C13Print(SV541,P1,{1,0,0,0,1,1,0,0},"TEST",P1)
------------------------------------------------------------------------------------------

414

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-40] CDPrint(), C13Print(), CA__ItoCustom(), CA__lItoCustom(), CA__ScanV, CA__ScanW()
CJump(AllPlayers,0)
Str2 = SaveiStrArrX(P1,MakeiStrVoid(54*11))
Str1 = SaveiStrArrX(P1,"!V입력")
Str3 = SaveiStrArrX(P1,"!W입력")
SV54 = CreateSV54(P1,MakeiStrVoid(54))
Str4 = SaveiStrArrX(P1,MakeiStrVoid(53))
CJumpEnd(AllPlayers,0)
Line, ChatSize, ChatOff, Loop, Check, X, _VRet, Mode13 = CreateVars(8,P1)
_WRet = CreateWar(P1)
SpCode0 = 0x8880E200 -- 식별자 (텍스트 미출력 라인은 첫 1바이트가 00으로 고정됨)
function TEST() -- ScanChat -> 11줄 전체를 utf8 -> iutf8화 (식별자로 중복방지)
CA__SetNext(Str2,8,SetTo,0,54*11-1,0)
CMov(P1,Line,0)
CWhile(P1,NVar(Line,AtMost,10),SetNVar(Check,SetTo,0))
f_ChatOffset(P1,Line,0,ChatOff)
CIfX(P1,{TTDisplayX(Line,0,"!=",SpCode0,0xFFFFFF00)})
CMul(P1,X,Line,604*54)
CA__SetValue(Str2,MakeiStrLetter(" ",53),0xFFFFFFFF,_Mul(Line,54*604),1,1)
CD__ScanChat(SVA1(Str2,X),ChatOff,52,ChatSize,0,1)
CAdd(P1,X,6*604)
SLoopN(P1,30,nil,{SetNVar(X,Add,604)})
CTrigger(P1,{TTepdcmp(SVA1(Str2,X),Str1,4,0xFFFFFF00)},{SetNVar(Check,SetTo,1)},{Preserved})
CTrigger(P1,{TTepdcmp(SVA1(Str2,X),Str3,4,0xFFFFFF00)},{SetNVar(Check,SetTo,2)},{Preserved})
NJump(P1,1,NVar(Check,AtLeast,1))
SLoopNEnd()
NJumpEnd(P1,1)
CIfX(P1,NVar(Check,Exactly,2),SetNVar(Mode13,SetTo,1))
CD__ScanW(SVA1(Str2,_Add(X,26*604)),40,_WRet,nil,10,1)
CA__epdcpy(Str2,0x0D0D0D0D,0xFFFFFFFF,X,_Add(X,604*4),1)
CElseIfX(NVar(Check,Exactly,1),SetNVar(Mode13,SetTo,0))
CD__ScanV(SVA1(Str2,_Add(X,16*604)),30,_VRet,nil,10,1)
CA__epdcpy(Str2,0x0D0D0D0D,0xFFFFFFFF,X,_Add(X,604*4),1)
CIfXEnd()
CA__SetMemoryX(_GIndex2(Line,0),SpCode0+0x0D,0xFFFFFFFF,1)
CD__InputVAX(_GIndex2(Line,1),SVA1(Str2,_Mul(Line,604*54)),52,0xFFFFFFFF,0xFFFFFFFF,8,604*11-1)
CD__SetMaskX(_GIndex2(Line,0),0xFFFFFFFF)
CElseIfX({TTDisplay(Line,"On")})
CD__InputVAX(_GIndex2(Line,1),SVA1(Str2,_Mul(Line,604*54)),52,0xFFFFFFFF,0xFFFFFFFF,8,604*11-1)
CIfXEnd()
CWhileEnd(SetNVar(Line,Add,1))
end
CDPrint(0,11,{" ",0},{P1,P2},{1,0,0,0,1,1,0,0},"TEST",P1)
function TEST2()

CA__SetNext(Str4,8,SetTo,0,52)

CA__epdcpy(Str4,0x0D0D0D0D,0xFFFFFFFF,0,52,1)
CIfX(P1,NVar(Mode13,Exactly,0))
CA__SetValue(Str4,"3\x04,123\x04,123\x04,123￦",nil,1,1,1)
CA__ItoCustom(SVA1(Str4,0),_VRet,nil,nil,10,1,nil,{"\x19+","\x10-","\x040"},{0x08,0x17,0x17,0x17,0x07,0x07,0x07,0x1F,0x1F,0x1F}
,{0,2,3,4,6,7,8,10,11,12},nil,{{0},0,0,{0},0,0,{0},0,0,{0}},1)
CElseX()
CA__SetValue(Str4,"12\x04,123\x04,123\x04,123\x04,123\x04,123\x04,123￦",nil,1,1,1)
CA__lItoCustom(SVA1(Str4,0),_WRet,nil,nil,10,1,nil,{"\x1F+","\x08-","\x040"},{0x04,0x04,0x1B,0x1B,0x1B,0x19,0x19,0x19,0x1D,0x1D,0x1D,0x02,0x02,0x2,0x1E,0x1E,0x1E,0x05,0x05,0x05}
,{0,1,3,4,5,7,8,9,11,12,13,15,16,17,19,20,21,23,24,25},nil,{0,{0},0,0,{0},0,0,{0},0,0,{0},0,0,{0},0,0,{0}},1)
CIfXEnd()
CA__InputVA(0,Str4,53,0xFFFFFFFF,0,52*8)
end
C13Print(SV54,P1,{1,0,0,0,1,1,0,0},"TEST2",P1)

------------------------------------------------------------------------------------------

415

------------------------------------------------------------------------------------------

『 26장 : 이상 스트링 편집 및 출력 함수 (CAPrint) 』

------------------------------------------------------------------------------------------

[예제 26-41] CDPrint(), CD__ScanChat(), CA__Encode()
CJump(AllPlayers,0)
iStr1 = GetiStrId(P1,MakeiStrVoid(53))
Str2 = SaveiStrArrX(P1,MakeiStrVoid(54))
Str1 = SaveiStrArrX(P1,"!닉네임")
Str3 = SaveiStrArr(P1,MakeiStrVoid(53))
CJumpEnd(AllPlayers,0)

Line, ChatSize, ChatOff, ChatLoc, Check, X, PL = CreateVars(7,P1)
_WRet = CreateWar(P1)
SpCode0 = 0x8880E200 -- 식별자 (텍스트 미출력 라인은 첫 1바이트가 00으로 고정됨)
CIfOnce(P1)

CIfEnd()

GetPlayerLength(P1,P1,PL)
DoActionsX(P1,SetNVar(PL,Add,7))

CS__GetLine(P1,10,Line)
f_ChatOffset(P1,Line,0,ChatOff)
CS__ScanChat(P1,SVA1(Str2,0),ChatOff,52,ChatSize,0,1)
CMov(P1,X,6*604)
SLoopN(P1,30,nil,{SetNVar(X,Add,604)},{SetNvar(Check,SetTo,0)})
CTrigger(P1,{TTepdcmp(SVA1(Str2,X),Str1,4,0xFFFFFF00)},{SetNVar(Check,SetTo,1)},{Preserved})
NJump(P1,1,NVar(Check,AtLeast,1))
SLoopNEnd()
NJumpEnd(P1,1)
CIf(P1,{TTDisplay(Line,"On"),NVar(Check,Exactly,1)})
CS__epdcpy(P1,Str3,0x0D0D0D0D,0xFFFFFFFF,0,52,1)
CS__Encode(P1,Str3,SVA1(Str2,_Add(X,5*604)),_Sub(ChatSize,PL),1)
CIfEnd()
function TEST()
end

CA__InputVA(0,Str3,53,nil,0,52)

DoActions(P1,{CopyCpAction({LeaderBoardScoreX(Custom,iStr1[4])},{P1},0)},{}) -- 리더보드 액션은 1회만 실행
DoActions(P1,{CreateUnit(1,"Kakaru (Twilight)","Anywhere",P1),KillUnitAT(1,"Kakaru (Twilight)","Anywhere",P1),
CopyCpAction({SetMissionObjectivesX(iStr1[4])},{P1},0); -- String 자체를 넣어야 String 에러가 뜨지않음
SetUnitName(54,iStr1[2]); -- 디버링원 유닛이름 스트링 변경
})
CAPrint(iStr1,P1,{1,0,0,0,1,3,0,0},"TEST",P1) -- 텍스트, 리더보드, 미션오브젝트, 유닛이름

------------------------------------------------------------------------------------------

416

------------------------------------------------------------------------------------------

『 27장 : 비공유 데이터 전송 함수 (NSQC.py) 』

-----------------------------------------------------------------------------------------[예제 27-1] 일반 조건, 키보드 키인식, 마우스 키인식, 기타 비공유 조건
CRead(P1,0x58F450,DtoA(P1,1))
CRead(P1,0x58F454,DtoA(P1,2))
CRead(P1,0x58F458,DtoA(P1,3))

---------------------------------------------------------------------------------------------[NSQC]
A : 1, 1
KeyDown(S) : 1, 256
KeyUp(D) : 1, 65536
KeyPress(F) : 1, 16777216
MouseDown(L) : 2, 1
MouseUp(R) : 2, 256
MousePress(M) : 2, 65536
MemoryX(0x57F0F0,Exactly,1,1) : 2, 16777216
NotTyping : 3, 1
MouseMoved : 3, 256
ScreenMoved : 3, 65536
WideScreen : 3, 16777216
QCDebug : False

-----------------------------------------------------------------------------------------[예제 27-2] 마우스 로케이션, 화면 로케이션
DoActions(P1,{

CreateUnit(1,"Zerg Scourge","CLoc",P1); -- 마우스 로케이션
CreateUnit(1,"Mojo (Scout)","CLoc2",P1); -- 화면 로케이션
KillUnit("Zerg Scourge",P1);
KillUnit("Mojo (Scout)",P1);

})
X,Y = CreateVars(2,P1)

CRead(P1,X,0x62848C)
CRead(P1,Y,0x6284A8)
CMov(P1,0x58F450,X) -- 화면 X좌표
CMov(P1,0x58F454,Y) -- 화면 Y좌표
CMov(P1,0x58F458,_Add(_Read(0x6CDDC4),X)) -- 마우스 X좌표
CMov(P1,0x58F45C,_Add(_Read(0x6CDDC8),Y)) -- 마우스 Y좌표
CRead(P1,0x58F460,_Loc("CLoc",0)) -- 전송된 화면 X좌표
CRead(P1,0x58F464,_Loc("CLoc",4)) -- 전송된 화면 Y좌표
CRead(P1,0x58F468,_Loc("CLoc2",0)) -- 전송된 마우스 X좌표
CRead(P1,0x58F46C,_Loc("CLoc2",4)) -- 전송된 마우스 Y좌표

---------------------------------------------------------------------------------------------[NSQC]
마우스 : CLoc
화면 : CLoc2
QCDebug : False

------------------------------------------------------------------------------------------

417

------------------------------------------------------------------------------------------

『 27장 : 비공유 데이터 전송 함수 (NSQC.py) 』

-----------------------------------------------------------------------------------------[예제 27-3] xy, val, dword
CIf(P1,Memory(0x57F0F0,Exactly,0))
CRead(P1,0x58F450,0x51CE8C)
CIfEnd()
CRead(P1,0x58F454,DtoA(P1,1))
CRead(P1,0x58F458,DtoA(P1,2))
CRead(P1,0x58F45C,DtoA(P1,3))

---------------------------------------------------------------------------------------------[NSQC]
Always(); xy, 0x58F450 : 1
Always(); val, 0x58F450 : 2
Always(); dword, 0x58F450 : 3
QCDebug : False

-----------------------------------------------------------------------------------------[예제 27-4] xy (주소 2개), widescreen, (채팅클릭 예제)
-- 위의 StartCtrig()를 NSQCVA = StartCtrig(1,2)로 교체
CJump(AllPlayers,0)
iStr1 = GetiStrId(P1,"\x13"..MakeiStrLetter(" ",40))
Str1, Str1a, Str1s = SaveiStrArr(P1," \x02『\x04클릭버튼\x02』 ")
Str2, Str2a, Str2s = SaveiStrArr(P1," \x0F『\x1F커서감지\x0F』 ")
Str3, Str3a, Str3s = SaveiStrArr(P1," \x0E『\x1C클릭인식\x0E』 ")
CJumpEnd(AllPlayers,0)
CMov(P1,0x58F450,VArr(NSQCVA[1],0)) -- 커서 위치를 텍스트에 대면서 좌표값을 수동으로 구함
CMov(P1,0x58F454,VArr(NSQCVA[2],0)) -- X : 0x80~0xB4+0xA*X / Y : 0x70 ~ 0x7B
CRead(P1,0x58F458,DtoA(P1,1))
X, Y, Z, L, R = CreateVars(5,P1)
DoActionsX(P1,{SetNVar(Y,Add,1)})
CTrigger(P1,{TNVar(Y,AtLeast,_Read(0x57F0F0)),NVar(Z,Exactly,0)},{SetNVar(Y,SetTo,0),SetNVar(X,Add,1)},{Preserved})
CTrigger(P1,{TNVar(Y,AtLeast,_Read(0x57F0F0)),NVar(Z,Exactly,1)},{SetNVar(Y,SetTo,0),SetNVar(X,Subtract,1)},{Preserved})
TriggerX(P1,{NVar(X,Exactly,40-Str1s),NVar(Z,Exactly,0)},SetNVar(Z,SetTo,1),{Preserved})
TriggerX(P1,{NVar(X,Exactly,1),NVar(Z,Exactly,1)},SetNVar(Z,SetTo,0),{Preserved})
TriggerX(P1,DeathsX(P1,Exactly,1,1,0xFF),{SetNVar(L,SetTo,0xE6),SetNVar(R,SetTo,0x11A)},{PReserved})
TriggerX(P1,DeathsX(P1,Exactly,0,1,0xFF),{SetNVar(L,SetTo,0x80),SetNVar(R,SetTo,0xB4)},{PReserved})
function TEST()
CIfX(P1,{TMemory(0x6CDDC4,AtLeast,_Add(_Mul(X,10),L)),TMemory(0x6CDDC4,AtMost,_Add(_Mul(X,10),R))
,Memory(0x6CDDC8,AtLeast,0x70),Memory(0x6CDDC8,AtMost,0x7B)},{SetMemoryX(0x58F45C,SetTo,1,1)})
CIfX(P1,{DeathsX(P1,Exactly,256,1,0xFF00)})
CA__InputVA(X,Str3,Str3s,0xFFFFFFFF,1,40)
CElseX()
CA__InputVA(X,Str2,Str2s,0xFFFFFFFF,1,40)
CIfXEnd()
CElseX()
CA__InputVA(X,Str1,Str1s,0xFFFFFFFF,1,40)
CIfXEnd()
end
CAPrint(iStr1,P1,{1,0,0,0,1,3,0,0},"TEST",P1)

---------------------------------------------------------------------------------------------[NSQC]
Always(); xy, 0x6CDDC4, 0x6CDDC8 : 1.0, 2.0
widescreen : 1, 1
MemoryX(0x58F45C,Exactly,1,1); MouseDown(L) : 1, 256
QCDebug : False

-----------------------------------------------------------------------------------------418

------------------------------------------------------------------------------------------

『 27장 : 비공유 데이터 전송 함수 (NSQC.py) 』

-----------------------------------------------------------------------------------------[예제 27-5] dword, NSQCSend(), NSQCReceive() (26-40 변형예제)
-- 위의 StartCtrig()를 NSQCVA = StartCtrig(1,2)로 교체
CJump(AllPlayers,0)
Str2 = SaveiStrArrX(P1,MakeiStrVoid(54*11))
Str1 = SaveiStrArrX(P1,"!V입력")
Str3 = SaveiStrArrX(P1,"!W입력")
SV54 = CreateSV54(P1,MakeiStrVoid(54))
Str4 = SaveiStrArrX(P1,MakeiStrVoid(53))
CJumpEnd(AllPlayers,0)

Line, ChatSize, ChatOff, Loop, Check, X, _VRet, Mode13 = CreateVars(8,P1)
_WRet = CreateWar(P1)
SpCode0 = 0x8880E200 -- 식별자 (텍스트 미출력 라인은 첫 1바이트가 00으로 고정됨)
function TEST() -- ScanChat -> 11줄 전체를 utf8 -> iutf8화 (식별자로 중복방지)
CA__SetNext(Str2,8,SetTo,0,54*11-1,0)
CMov(P1,Line,0)
CWhile(P1,NVar(Line,AtMost,10),SetNVar(Check,SetTo,0))
f_ChatOffset(P1,Line,0,ChatOff)

CIfX(P1,{TTDisplayX(Line,0,"!=",SpCode0,0xFFFFFF00)})
CMul(P1,X,Line,604*54)
CA__SetValue(Str2,MakeiStrLetter(" ",53),0xFFFFFFFF,_Mul(Line,54*604),1,1)
CD__ScanChat(SVA1(Str2,X),ChatOff,52,ChatSize,0,1)
CAdd(P1,X,6*604)
SLoopN(P1,30,nil,{SetNVar(X,Add,604)})
CTrigger(P1,{TTepdcmp(SVA1(Str2,X),Str1,4,0xFFFFFF00)},{SetNVar(Check,SetTo,1)},{Preserved})
CTrigger(P1,{TTepdcmp(SVA1(Str2,X),Str3,4,0xFFFFFF00)},{SetNVar(Check,SetTo,2)},{Preserved})
NJump(P1,1,NVar(Check,AtLeast,1))
SLoopNEnd()
NJumpEnd(P1,1)
CIfX(P1,NVar(Check,Exactly,2),SetNVar(Mode13,SetTo,1))
CD__ScanW(SVA1(Str2,_Add(X,26*604)),40,_WRet,nil,10,1)
CA__epdcpy(Str2,0x0D0D0D0D,0xFFFFFFFF,X,_Add(X,604*4),1)
DoActions(P1,SetSwitch("Switch 2",Set))
CElseIfX(NVar(Check,Exactly,1),SetNVar(Mode13,SetTo,0))
CD__ScanV(SVA1(Str2,_Add(X,16*604)),30,_VRet,nil,10,1)
CA__epdcpy(Str2,0x0D0D0D0D,0xFFFFFFFF,X,_Add(X,604*4),1)
CMov(P1,0x58F450,_VRet)
CIfXEnd()
CA__SetMemoryX(_GIndex2(Line,0),SpCode0+0x0D,0xFFFFFFFF,1)
CD__InputVAX(_GIndex2(Line,1),SVA1(Str2,_Mul(Line,604*54)),52,0xFFFFFFFF,0xFFFFFFFF,8,604*11-1)
CD__SetMaskX(_GIndex2(Line,0),0xFFFFFFFF)
CElseIfX({TTDisplay(Line,"On")})
CD__InputVAX(_GIndex2(Line,1),SVA1(Str2,_Mul(Line,604*54)),52,0xFFFFFFFF,0xFFFFFFFF,8,604*11-1)
CIfXEnd()
CWhileEnd(SetNVar(Line,Add,1))
end
CDPrint(0,11,{" ",0},{P1,P2},{1,0,0,0,1,1,0,0},"TEST",P1)
WRetI, WRetO = CreateVArrs(2,2,P1) Com = CreateVar(P1) WOut = CreateWar(P1)
f_LMov(P1,{VArr(WRetI,0),VArr(WRetI,1)},_WRet)
NSQCSend(P1,VArr(WRetI,0),2,nil,0x58F454,0x80000000,{Switch("Switch 2",Set)},{SetSwitch("Switch 2",Clear)})
NSQCReceive(P1,VArr(WRetO,0),2,P1,2,0x80000000,Com)
CIf(P1,NVar(Com,Exactly,1))
f_LMov(P1,WOut,{VArr(WRetO,0),VArr(WRetO,1)})
CIfEnd()
function TEST2()
CA__SetNext(Str4,8,SetTo,0,52)

CA__epdcpy(Str4,0x0D0D0D0D,0xFFFFFFFF,0,52,1)
CIfX(P1,NVar(Mode13,Exactly,0))
CA__SetValue(Str4,"3\x04,123\x04,123\x04,123￦",nil,1,1,1)
CA__ItoCustom(SVA1(Str4,0),VArr(NSQCVA[1],0),nil,nil,10,1,nil,{"\x19+","\x10-","\x040"},{0x08,0x17,0x17,0x17,0x07,0x07,0x07,0x1F,0x1F,0x1F}
,{0,2,3,4,6,7,8,10,11,12},nil,{{0},0,0,{0},0,0,{0},0,0,{0}},1)
CElseX()
CA__SetValue(Str4,"12\x04,123\x04,123\x04,123\x04,123\x04,123\x04,123￦",nil,1,1,1)
CA__lItoCustom(SVA1(Str4,0),WOut,nil,nil,10,1,nil,{"\x1F+","\x08-","\x040"},{0x04,0x04,0x1B,0x1B,0x1B,0x19,0x19,0x19,0x1D,0x1D,0x1D,0x02,0x02,0x2,0x1E,0x1E,0x1E,0x05,0x05,0x05}
,{0,1,3,4,5,7,8,9,11,12,13,15,16,17,19,20,21,23,24,25},nil,{0,{0},0,0,{0},0,0,{0},0,0,{0},0,0,{0},0,0,{0}},1)
CIfXEnd()
CA__InputVA(0,Str4,53,0xFFFFFFFF,0,52*8)
end
C13Print(SV54,P1,{1,0,0,0,1,1,0,0},"TEST2",P1)

---------------------------------------------------------------------------------------------[NSQC]
Always(); dword, 0x58F450 : 1.0, 0x80000000
Always(); dword, 0x58F454 : 2.0, 0x80000000
QCDebug : False

-----------------------------------------------------------------------------------------419

------------------------------------------------------------------------------------------

『 27장 : 비공유 데이터 전송 함수 (NSQC.py) 』

-----------------------------------------------------------------------------------------[예제 27-6] dword, NSQCSend(), NSQCReceive() (26-41 변형예제)
-- 위의 StartCtrig()를 NSQCVA = StartCtrig(1,1,1,파일저장 장소)로 교체 #STRCtrig 필요
CJump(AllPlayers,0)
iStr1 = GetiStrId(P1,MakeiStrVoid(53))
Str2 = SaveiStrArrX(P1,MakeiStrVoid(54))
Str1 = SaveiStrArrX(P1,"!닉네임")
Str3 = SaveiStrArr(P1,MakeiStrVoid(26))
Str4 = SaveiStrArr(P1,MakeiStrVoid(26))
CJumpEnd(AllPlayers,0)

Line, ChatSize, ChatOff, ChatLoc, Check, X, PL = CreateVars(7,P1)
_WRet = CreateWar(P1)
SpCode0 = 0x8880E200 -- 식별자 (텍스트 미출력 라인은 첫 1바이트가 00으로 고정됨)
ChatI, ChatO = CreateVArrs(2,26,P1) Com = CreateVar(P1)
CIfOnce(P1)
CIfEnd()

GetPlayerLength(P1,P1,PL)
DoActionsX(P1,SetNVar(PL,Add,7))

CS__GetLine(P1,10,Line)
f_ChatOffset(P1,Line,0,ChatOff)
CS__ScanChat(P1,SVA1(Str2,0),ChatOff,52,ChatSize,0,1)
CMov(P1,X,6*604)
SLoopN(P1,30,nil,{SetNVar(X,Add,604)},{SetNvar(Check,SetTo,0)})
CTrigger(P1,{TTepdcmp(SVA1(Str2,X),Str1,4,0xFFFFFF00)},{SetNVar(Check,SetTo,1)},{Preserved})
NJump(P1,1,NVar(Check,AtLeast,1))
SLoopNEnd()
NJumpEnd(P1,1)
CIf(P1,{TTDisplay(Line,"On"),NVar(Check,Exactly,1)},{SetSwitch("Switch 2",Set)})
CS__epdcpy(P1,Str3,0x0D0D0D0D,0xFFFFFFFF,0,25,1)
CS__Encode(P1,Str3,SVA1(Str2,_Add(X,5*604)),_Sub(ChatSize,PL),1)
CS__Movcpy(P1,Str3,VArr(ChatI,0),26,0xFFFFFFFF,0xFFFFFFFF)
CIfEnd()
NSQCSend(P1,VArr(ChatI,0),26,nil,0x58F450,0x8B80E20D,{Switch("Switch 2",Set)},{SetSwitch("Switch 2",Clear)})
NSQCReceive(P1,VArr(ChatO,0),26,P1,1,0x8B80E20D,Com)
CIf(P1,NVar(Com,Exactly,1))
f_MovcpyEPD(P1,Mem("X",Str4[2],0x15C,0),VArr(ChatO,0),26*4,0,604)
CIfEnd()
function TEST()
end

CA__InputVA(0,Str4,26,nil,0,25)

DoActions(P1,{CopyCpAction({LeaderBoardScoreX(Custom,iStr1[4])},{P1},0)},{}) -- 리더보드 액션은 1회만 실행
DoActions(P1,{CreateUnit(1,"Kakaru (Twilight)","Anywhere",P1),KillUnitAT(1,"Kakaru (Twilight)","Anywhere",P1),
CopyCpAction({SetMissionObjectivesX(iStr1[4])},{P1},0); -- String 자체를 넣어야 String 에러가 뜨지않음
SetUnitName(54,iStr1[2]); -- 디버링원 유닛이름 스트링 변경
})
CAPrint(iStr1,P1,{1,0,0,0,1,3,0,0},"TEST",P1) -- 텍스트, 리더보드, 미션오브젝트, 유닛이름

---------------------------------------------------------------------------------------------[NSQC]
Always(); dword, 0x58F450 : 1.0, 0x8B80E20D
QCDebug : False

------------------------------------------------------------------------------------------

420

------------------------------------------------------------------------------------------

『 27장 : 비공유 데이터 전송 함수 (NSQC.py) 』

-----------------------------------------------------------------------------------------[예제 27-7] (채팅인식 예제)
CJump(AllPlayers,0)
iStr1 = GetiStrId(P1,MakeiStrVoid(53))
Str1 = SaveiStrArrX(P1,MakeiStrVoid(54))
StrA = SaveiStrArrX(P1,"마린")
StrB = SaveiStrArrX(P1,"고스트")
StrC = SaveiStrArrX(P1,"파벳")
StrD = SaveiStrArrX(P1,"메딕")
CJumpEnd(AllPlayers,0)
Line, ChatSize, ChatOff, ChatLoc, Check, X, PL, Loop, X2, Loop2 = CreateVars(10,P1)
CIfOnce(P1)
GetPlayerLength(P1,P1,PL)
DoActionsX(P1,SetNVar(PL,Add,2))
CMul(P1,ChatLoc,PL,604)
CIfEnd()
CS__GetLine(P1,10,Line)
CIfX(P1,{TTDisplay(Line,"On")})
f_ChatOffset(P1,Line,0,ChatOff)
CS__epdcpy(P1,Str1,0x0D0D0D0D,0xFFFFFFFF,0,53,1)
CS__ScanChat(P1,SVA1(Str1,0),ChatOff,52,ChatSize,0,1)
DoActionsX(P1,{SetMemory(0x58F450,SetTo,0),SetNVar(Check,SetTo,0),SetNVar(Loop,SetTo,0),SetNVar(Loop2,SetTo,0)})
-- 마린<CMov(P1,X,ChatLoc)
CTrigger(P1,{TTepdcmp(SVA1(Str1,X),StrA,2,0xFFFFFF00)},{SetNVar(Check,SetTo,1,1)},{Preserved})
-- <-고스트->
CMov(P1,X,ChatLoc)
NWhile(P1,{NVar(Loop2,AtMost,24),NVar(Check,Exactly,0)})
CTrigger(P1,{TTepdcmp(SVA1(Str1,X),StrB,3,0xFFFFFF00)},{SetNVar(Check,SetTo,256,256)},{Preserved})
NWhileEnd({SetNVar(X,Add,604),SetNVar(Loop2,Add,1)})
-- ->파벳
CMov(P1,X,ChatLoc)
CIf(P1,{NVar(Check,Exactly,0),NVar(ChatSize,AtLeast,2)})
CTrigger(P1,{TTepdcmp(SVA1(Str1,_Mul(_Sub(ChatSize,2),604)),StrC,2,0xFFFFFF00)},{SetNVar(Check,SetTo,65536,65536)},{Preserved})
CIfEnd()
-- 메<->딕
CMov(P1,X,ChatLoc)
NWhile(P1,{NVar(Check,Exactly,0),NVar(Loop,AtMost,24)})
CIf(P1,{TTepdcmp(SVA1(Str1,X),SVA1(StrD,0),1,0xFFFFFF00)})
CMov(P1,X2,X)
CMov(P1,Loop2,Loop)
CWhile(P1,{NVar(Loop2,AtMost,25)},{SetNVar(X2,Add,604),SetNVar(Loop2,Add,1)})
CTrigger(P1,{TTepdcmp(SVA1(Str1,X2),SVA1(StrD,1),1,0xFFFFFF00)},{SetNVar(Check,SetTo,16777216,16777216)},{Preserved})
CWhileEnd()
CIfEnd()
NWhileEnd({SetNVar(Loop,Add,1),SetNVar(X,Add,604)})
CTrigger(P1,NVar(Check,Exactly,1,1),{TBwrite(ChatOff,SetTo,0),SetMemoryX(0x58F450,SetTo,1,1)},{Preserved})
CTrigger(P1,NVar(Check,Exactly,256,256),{TBwrite(ChatOff,SetTo,0),SetMemoryX(0x58F450,SetTo,256,256)},{Preserved})
CTrigger(P1,NVar(Check,Exactly,65536,65536),{TBwrite(ChatOff,SetTo,0),SetMemoryX(0x58F450,SetTo,65536,65536)},{Preserved})
CTrigger(P1,NVar(Check,Exactly,16777216,16777216),{TBwrite(ChatOff,SetTo,0),SetMemoryX(0x58F450,SetTo,16777216,16777216)},{Preserved})

CElseX(SetMemory(0x58F450,SetTo,0))
CIfXEnd()

TriggerX(P1,DeathsX(P1,Exactly,1,1,1),CreateUnit(1,0,"CLoc",P1),{Preserved})
TriggerX(P1,DeathsX(P1,Exactly,256,1,256),CreateUnit(1,1,"CLoc",P1),{Preserved})
TriggerX(P1,DeathsX(P1,Exactly,65536,1,65536),CreateUnit(1,32,"CLoc",P1),{Preserved})
TriggerX(P1,DeathsX(P1,Exactly,16777216,1,16777216),CreateUnit(1,34,"CLoc",P1),{Preserved})

---------------------------------------------------------------------------------------------[NSQC]
MemoryX(0x58F450,Exactly,1,1) : 1, 1
MemoryX(0x58F450,Exactly,256,256) : 1, 256
MemoryX(0x58F450,Exactly,65536,65536) : 1, 65536
MemoryX(0x58F450,Exactly,16777216,16777216) : 1, 16777216
QCDebug : False

------------------------------------------------------------------------------------------

421

------------------------------------------------------------------------------------------

『 28장 : 순수 총알생성 함수 (언리미터 필요)』

-----------------------------------------------------------------------------------------[예제 28-1] ScanInitSetting(), BulletInitSetting(), RecallSprite(), UnitSprite(), ScanSprite(),
CreateBullet(), CreateBulletTarget(), CreateSprite(), CreateStorm()
-- 주황색 비콘 왼쪽에 이미지 및 총알이 생성됨
NoAirCollisionX(P1)
ScanInitSetting(P1)
BulletInitSetting(P1,{1,74,229},2,164,354,541,395,0,0,0,7,1,0,0,{10,25,50},0)
BulletInitSetting(P1,{1,74,229},2,164,354,505,235,0,0,0,7,1,0,0,{10,25,50},0)
BulletInitSetting(P1,{20,74,229},1,147,344,360,233,0,0,0,7,1,0,0,{0,0,0},0)
BulletInitSetting(P1,{19,74,229},0,162,356,380,236,0,0,0,7,1,0,0,{10,25,50},0)
X = CreateVar2(P1,nil,nil,312)
Y = CreateVar2(P1,nil,nil,1304)
Z = CreateVar(P1)
CReadX(P1,Z,0x57F120,nil,0xFFFFFFFF,256)
DoActionsX(P1,{SetNVar(X,Add,4),SetNVar(Y,Add,3)})
TriggerX(P1,{NVar(X,AtLeast,312+128)},{SetNVar(X,SetTo,312),SetNVar(Y,SetTo,1304)},{Preserved})
Trigger { -- EUD Editor
players = {P1},
conditions = {
},
actions = {

}

},

Always();
SetMemory(0x6563A8, SetTo, 100);
SetMemory(0x661808, SetTo, 65537);
SetMemory(0x66180C, SetTo, 65537);
SetMemory(0x661A78, SetTo, 65537);
SetMemory(0x661A7C, SetTo, 65537);
SetMemory(0x66633C, SetTo, 16188367);
SetMemory(0x66FB84, SetTo, 131);
Comment("EUD Editor");

CreateStorm(P1,P1,19,0,0,380,30,{"CLoc",X,Y},{Memory(0x57F0F0,Exactly,1)})
CreateSprite(P1,P1,20,0,Z,1280,{"CLoc",X,Y},{Memory(0x57F0F0,Exactly,2)})
CreateBulletTarget(P1,P1,1,20,128,960,50,{"CLoc",X,Y},432,1508,{Memory(0x57F0F0,Exactly,3)},{SetSpriteImage(354,541)})
CreateBullet(P1,P1,1,20,0,0,5,{"CLoc",X,Y},{Memory(0x57F0F0,Exactly,4)},{SetSpriteImage(354,505)})
RecallSprite(P1,P1,86,"CLoc2",X,Y,{Memory(0x57F0F0,Exactly,5)},{SetRecallImage(379)})
UnitSprite(P1,P1,8,0,2,{"CLoc",X,Y},{Memory(0x57F0F0,Exactly,6)})
ScanSprite(P1,1,P1,1,{"CLoc",X,Y},{Memory(0x57F0F0,Exactly,7)},{{TSetScanImage,{_Mov,391}}})

------------------------------------------------------------------------------------------

422

------------------------------------------------------------------------------------------

『 29장 : 파일 I/O 및 CGRP 삽입 함수 』

------------------------------------------------------------------------------------------

[예제 29-1] f_GetVArrptr(), f_GetFileVArrptrN(), f_GetWArrptr(), f_GetFileWArrptrN(), f_GetSVArrptr(),
f_GetFileSVArrptrN()
CJump(AllPlayers,0)
VA1 = f_GetVArrptr(P1,10)
VA2 = f_GetFileVArrptrN(P2,{0x12,0x34,0x56,0x78},1,2,1)
WA1 = f_GetWArrptr(P3,10)
WA2 = f_GetFileWArrptrN(P4,{0x1234,0x5678,0x90AB,0xCDEF},2,2,1)
SV1 = f_GetSVArrptr(P5,10,3)
SV2 = f_GetFileSVArrptrN(P6,{0x12345678,0x23456789,0x34567890},4,3,2,1)
CJumpEnd(AllPlayers,0)
i = CreateVar2(P1,nil,nil,5)
CMovX(P1,VArr(VA1,i),0xFFFFFFFF)
CMovX(P1,0x58F450,VArr(VA1,i))
CMov(P2,0x58F454,VArr(VA2,0))
CMov(P2,0x58F458,VArr(VA2,1))
f_LMov(P3,WArr(WA1,i),"0xEEEEDDDDCCCCBBBB")
f_LMov(P3,0x58F45C,WArr(WA1,i))
f_LMov(P4,0x58F464,WArr(WA2,0))
f_LMov(P4,0x58F46C,WArr(WA2,1))
SMov(P5,SVArr(SV1,i),{0xAAAAAAAA,0x99990000,0x88776655})
SMov(P5,{0x58F474,0x58F478,0x58F47C},SVArr(SV1,i))
SMov(P6,{0x58F480,0x58F484,0x58F488},SVArr(SV2,0))
SMov(P6,{0x58F48C,0x58F490,0x58F494},SVArr(SV2,1))

------------------------------------------------------------------------------------------

[예제 29-2] f_GetVoidptr(), f_GetFileptr(), f_GetFileptrN(), f_GetFileArrptr(), f_GetFileArrptrN(), FArr()
CJump(AllPlayers,0)
FA1 = f_GetVoidptr(P1,0x1000)
SaveFileArr({0xAAAABBBB,0xCCCCDDDD},4,"Testest")
FA2 = f_GetFileptr(P2,"Testest",1)
FA3 = f_GetFileptrN(P3,"Testest",2,1)
FA4 = f_GetFileArrptr(P4,{0x1111,0x2222,0x3333,0x4444},2,1)
FA5 = f_GetFileArrptrN(P5,{0x55,0x66,0x77,0x88},1,2,1)
CJumpEnd(AllPlayers,0)
i = CreateVar2(P1,nil,nil,1)
CMov(P1,FArr(FA1,0),0xFFFFFFFF)
CMovX(P1,FArr(FA1,i),0xEEEEEEEE)
CRead(P1,0x58F450,FArr(FA1,0))
CRead(P1,0x58F454,FArr(FA1,i))
CRead(P2,0x58F458,FArr(FA2,0))
CRead(P2,0x58F45C,FArr(FA2,i))
CRead(P3,0x58F460,FArr(FA3,0))
CRead(P3,0x58F464,FArr(FA3,i))
CRead(P3,0x58F468,FArr(FA3,2))
CRead(P3,0x58F46C,FArr(FA3,_Mov(3)))
CRead(P4,0x58F470,FArr(FA4,0))
CRead(P4,0x58F474,FArr(FA4,i))

CRead(P5,0x58F478,FArr(FA5,0))
CRead(P5,0x58F47C,FArr(FA5,_Mov(1)))

------------------------------------------------------------------------------------------

423

------------------------------------------------------------------------------------------

『 29장 : 파일 I/O 및 CGRP 삽입 함수 』

-----------------------------------------------------------------------------------------[예제 29-3] SaveFileArr(), f_GetTRIGptr(), f_GetFileSize()
CJump(AllPlayers,0)
TRIGArr = {}
for j = 1, 0x16 do

table.insert(TRIGArr,0)
end
table.insert(TRIGArr,0xA)
table.insert(TRIGArr,0xFE)
table.insert(TRIGArr,0)
table.insert(TRIGArr,0x2)
for j = 1, 0x12E do
table.insert(TRIGArr,0)
end
for j = 1, 8 do
table.insert(TRIGArr,0)
end
table.insert(TRIGArr,0x20)
table.insert(TRIGArr,0)
table.insert(TRIGArr,0)
table.insert(TRIGArr,0)
table.insert(TRIGArr,0x80)
table.insert(TRIGArr,0)
table.insert(TRIGArr,0)
table.insert(TRIGArr,0)
table.insert(TRIGArr,1)
table.insert(TRIGArr,0)
table.insert(TRIGArr,0)
table.insert(TRIGArr,0)
table.insert(TRIGArr,0x50)
table.insert(TRIGArr,0x1C)
table.insert(TRIGArr,0)
table.insert(TRIGArr,0)
table.insert(TRIGArr,0)
table.insert(TRIGArr,0)
table.insert(TRIGArr,5)
table.insert(TRIGArr,7)
table.insert(TRIGArr,0x14)
table.insert(TRIGArr,0)
table.insert(TRIGArr,0)
table.insert(TRIGArr,0)
for j = 1, 0x7E0 do
table.insert(TRIGArr,0)
end
table.insert(TRIGArr,0x4)
table.insert(TRIGArr,0)
table.insert(TRIGArr,0)
table.insert(TRIGArr,0)
table.insert(TRIGArr,1)
for j = 1, 0x23 do
table.insert(TRIGArr,0)
end
SaveFileArr(TRIGArr,1,"TRIGest") -- SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,3);
TA1 = f_GetTRIGptrN(P1,"TRIGest",1,1)
TS1 = f_GetFileSize("TRIGest")
CJumpEnd(AllPlayers,0)
Trigger {
players = {P1},
conditions = {
Label(0);
},
actions = {
SetCtrigX("X","X",0x4,0,SetTo,"X",TA1[2],0,0,1);
SetMemory(0x58F450,SetTo,TS1);
},
flag = {preserved}
}

------------------------------------------------------------------------------------------

424

------------------------------------------------------------------------------------------

『 29장 : 파일 I/O 및 CGRP 삽입 함수 』

-----------------------------------------------------------------------------------------[예제 29-4] (CS_Photo-2 예제) 1. 단일 색상 & 단일 높이 이미지
CJump(AllPlayers,0)
FA1 = f_GetFileptr(P1,"29-4_out.cgrp",1)
CJumpEnd(AllPlayers,0)
BulletInitSetting(P1,{1,74,229},2,147,231,233,233,0,0,0,0,1,0,0,{0,0,0})
X, CGRP = CreateVars(2,P1)
Y = CreateVar2(P1,nil,nil,1120)
Z = CreateVar2(P1,nil,nil,4)
CIf(P1,NVar(Y,AtMost,31*3+1120),{SetNVar(X,SetTo,384)})
CWhile(P1,NVar(X,AtMost,31*3+384))
CRead(P1,CGRP,FArr(FA1,Z))
CIf(P1,NVar(CGRP,Exactly,128,128))
CreateSprite(P1,P1,1,0,0,0,{"CLoc",X,Y})
CIfEnd()
CWhileEnd({SetNVar(X,Add,3),SetNVar(Z,Add,1)})
CIfEnd(SetNVar(Y,Add,3))

-----------------------------------------------------------------------------------------[예제 29-5] (CS_Photo-2 예제) 2. 단일 색상 & 음영 사용 이미지
CJump(AllPlayers,0)
FA1 = f_GetFileptr(P1,"29-5_out.cgrp",1)
CJumpEnd(AllPlayers,0)
BulletInitSetting(P1,{203,74,229,1},2,147,231,233,233,0,0,0,0,1,0,0,{0,0,0},0)
BulletInitSetting(P1,{203,74,229,1},2,147,231,210,233,10,0,0,0,1,0,0,{0,0,0},0)
X, CGRP, H, SizeX, SizeY = CreateVars(5,P1)
Y = CreateVar2(P1,nil,nil,1120)
Z = CreateVar2(P1,nil,nil,4)
-- 0 2 4 6 8 10 12 14 : background Filter Image (Black)
CreateSprite(P1,P1,203,0,0,0,{"CLoc",384+48,1120+48},ElapsedTime(Exactly,1),SetSpriteImage(231,210),0)
CreateSprite(P1,P1,203,2,0,0,{"CLoc",384+48,1120+48},ElapsedTime(Exactly,2),SetSpriteImage(231,210),0)
CreateSprite(P1,P1,203,4,0,0,{"CLoc",384+48,1120+48},ElapsedTime(Exactly,3),SetSpriteImage(231,210),0)
CreateSprite(P1,P1,203,6,0,0,{"CLoc",384+48,1120+48},ElapsedTime(Exactly,4),SetSpriteImage(231,210),0)
CreateSprite(P1,P1,203,8,0,0,{"CLoc",384+48,1120+48},ElapsedTime(Exactly,5),SetSpriteImage(231,210),0)
CreateSprite(P1,P1,203,10,0,0,{"CLoc",384+48,1120+48},ElapsedTime(Exactly,6),SetSpriteImage(231,210),0)
CreateSprite(P1,P1,203,12,0,0,{"CLoc",384+48,1120+48},ElapsedTime(Exactly,7),SetSpriteImage(231,210),0)
CreateSprite(P1,P1,203,14,0,0,{"CLoc",384+48,1120+48},ElapsedTime(Exactly,8),SetSpriteImage(231,210),0)
-- 1 3 5 7 9 11 13 15 : Mask01~08 (Height로 음영을 나타냄)
CIf(P1,{ElapsedTime(AtLeast,9),NVar(Y,AtMost,31*3+1120)},{SetNVar(X,SetTo,384)})
CWhile(P1,NVar(X,AtMost,31*3+384))
CRead(P1,CGRP,FArr(FA1,Z),nil,0x3FFF) -- RGBW 8/12/15/Fill K[3] T[3] 14bit
CReadX(P1,H,FArr(FA1,Z),nil,{0xFF000000,0xFF},1/16777216) -- Height*16777216 8bit
CIf(P1,{NVar(CGRP,Exactly,1,1)},{SetSpriteImage(231,233)})
CreateSprite(P1,P1,203,H,0,0,{"CLoc",X,Y})
CIfEnd()
CWhileEnd({SetNVar(X,Add,3),SetNVar(Z,Add,1)})
DoActionsX(P1,SetNVar(Y,Add,3))
CIfEnd()

------------------------------------------------------------------------------------------

425

------------------------------------------------------------------------------------------

『 29장 : 파일 I/O 및 CGRP 삽입 함수 』

-----------------------------------------------------------------------------------------[예제 29-6] (CS_Photo-2 예제) 3. 팔레트 사용 & 단일 높이 이미지
CJump(AllPlayers,0)
FA1 = f_GetFileptr(P1,"29-6_out.cgrp",1)
CJumpEnd(AllPlayers,0)
BulletInitSetting(P1,{203,74,229,1},2,147,231,233,233,0,0,0,0,1,0,0,{0,0,0},0)
ScanInitSetting(P1,0)
X, CGRP, H, Step, Delay = CreateVars(5,P1)
Y = CreateVar2(P1,nil,nil,1120)
Z = CreateVar2(P1,nil,nil,4)
DoActionsX(P1,SetNVar(Delay,Subtract,1))
-- 4 : background Filter Image (White)
ScanSprite(P1,1,P1,1,{"CLoc",384+72,1120+72},{NVar(Step,Exactly,5),NVar(Delay,Exactly,0)},
{SetScanImage(210),SetImageColor(210,17),SetImageScript(210,250)})
-- 5 6(T) 7(K) : (각 점마다 음영을 쌓아서 만듬)
CIf(P1,{NVar(Step,Exactly,0),NVar(Delay,Exactly,0),NVar(Y,AtMost,47*3+1120)},{SetNVar(X,SetTo,384),SetImageColor(233,0)})
CWhile(P1,NVar(X,AtMost,47*3+384))
CRead(P1,CGRP,FArr(FA1,Z),nil,0x3FFF) -- RGBW 8/12/15/Fill K[3] T[3] 14bit
CIf(P1,{NVar(CGRP,Exactly,1,1)}) -- Red Plot
CreateSprite(P1,P1,203,5,0,0,{"CLoc",X,Y})
CIfEnd()
CWhileEnd({SetNVar(X,Add,3),SetNVar(Z,Add,1)})
DoActionsX(P1,SetNVar(Y,Add,3))
CIfEnd()
TriggerX(P1,{NVar(Y,Exactly,48*3+1120),NVar(Step,Exactly,0)},{SetNVar(Y,SetTo,1120),SetNVar(Z,SetTo,4),SetNVar(Step,SetTo,1),SetNVar(Delay,SetTo,4)})
CIf(P1,{NVar(Step,Exactly,1),NVar(Delay,Exactly,0),NVar(Y,AtMost,47*3+1120)},{SetNVar(X,SetTo,384),SetImageColor(233,13),SetNVar(Delay,Add,2)})
CWhile(P1,NVar(X,AtMost,47*3+384))
CRead(P1,CGRP,FArr(FA1,Z),nil,0x3FFF) -- RGBW 8/12/15/Fill K[3] T[3] 14bit
CIf(P1,{NVar(CGRP,Exactly,2,2)}) -- Green Plot
CreateSprite(P1,P1,203,5,0,0,{"CLoc",X,Y})
CIfEnd()
CWhileEnd({SetNVar(X,Add,3),SetNVar(Z,Add,1)})
DoActionsX(P1,SetNVar(Y,Add,3))
CIfEnd()
TriggerX(P1,{NVar(Y,Exactly,48*3+1120),NVar(Step,Exactly,1)},{SetNVar(Y,SetTo,1120),SetNVar(Z,SetTo,4),SetNVar(Step,SetTo,2),SetNVar(Delay,SetTo,4)})
CIf(P1,{NVar(Step,Exactly,2),NVar(Delay,Exactly,0),NVar(Y,AtMost,47*3+1120)},{SetNVar(X,SetTo,384),SetImageColor(233,16),SetNVar(Delay,Add,2)})
CWhile(P1,NVar(X,AtMost,47*3+384))
CRead(P1,CGRP,FArr(FA1,Z),nil,0x3FFF) -- RGBW 8/12/15/Fill K[3] T[3] 14bit
CIf(P1,{NVar(CGRP,Exactly,4,4)}) -- Blue Plot
CreateSprite(P1,P1,203,5,0,0,{"CLoc",X,Y})
CIfEnd()
CWhileEnd({SetNVar(X,Add,3),SetNVar(Z,Add,1)})
DoActionsX(P1,SetNVar(Y,Add,3))
CIfEnd()
TriggerX(P1,{NVar(Y,Exactly,48*3+1120),NVar(Step,Exactly,2)},{SetNVar(Y,SetTo,1120),SetNVar(Z,SetTo,4),SetNVar(Step,SetTo,3),SetNVar(Delay,SetTo,4)})
CIf(P1,{NVar(Step,Exactly,3),NVar(Delay,Exactly,0),NVar(Y,AtMost,47*3+1120)},{SetNVar(X,SetTo,384),SetImageColor(233,6),SetNVar(Delay,Add,2)})
CWhile(P1,NVar(X,AtMost,47*3+384))
CRead(P1,CGRP,FArr(FA1,Z),nil,0x3FFF) -- RGBW 8/12/15/Fill K[3] T[3] 14bit
CWhile(P1,{NVar(CGRP,AtLeast,1*0x800,3*0x800)},{SetNVar(CGRP,Subtract,1*0x800,3*0x800)}) -- Transparent Red Plot
CreateSprite(P1,P1,203,6,0,0,{"CLoc",X,Y})
CWhileEnd()
CWhileEnd({SetNVar(X,Add,3),SetNVar(Z,Add,1)})
DoActionsX(P1,SetNVar(Y,Add,3))
CIfEnd()
TriggerX(P1,{NVar(Y,Exactly,48*3+1120),NVar(Step,Exactly,3)},{SetNVar(Y,SetTo,1120),SetNVar(Z,SetTo,4),SetNVar(Step,SetTo,4),SetNVar(Delay,SetTo,4)})
CIf(P1,{NVar(Step,Exactly,4),NVar(Delay,Exactly,0),NVar(Y,AtMost,47*3+1120)},{SetNVar(X,SetTo,384),SetImageColor(233,10),SetNVar(Delay,Add,2)})
CWhile(P1,NVar(X,AtMost,47*3+384))
CRead(P1,CGRP,FArr(FA1,Z),nil,0x3FFF) -- RGBW 8/12/15/Fill K[3] T[3] 14bit
CWhile(P1,{NVar(CGRP,AtLeast,1*0x100,3*0x100)},{SetNVar(CGRP,Subtract,1*0x100,3*0x100)}) -- Transparent Black Plot
CreateSprite(P1,P1,203,7,0,0,{"CLoc",X,Y})
CWhileEnd()
CWhileEnd({SetNVar(X,Add,3),SetNVar(Z,Add,1)})
DoActionsX(P1,SetNVar(Y,Add,3))
CIfEnd()
TriggerX(P1,{NVar(Y,Exactly,48*3+1120),NVar(Step,Exactly,4)},{SetNVar(Y,SetTo,1120),SetNVar(Z,SetTo,4),SetNVar(Step,SetTo,5),SetNVar(Delay,SetTo,4)})

------------------------------------------------------------------------------------------

426

------------------------------------------------------------------------------------------

『 29장 : 파일 I/O 및 CGRP 삽입 함수 』

-----------------------------------------------------------------------------------------[예제 29-7] (CS_Photo-2 예제) 4. 팔레트 사용 & 음영 사용 이미지
CJump(AllPlayers,0)
FA1 = f_GetFileptr(P1,"29-7_out.cgrp",1)
CJumpEnd(AllPlayers,0)
Trigger { -- EUD Editor

players = {P1},
conditions = {
},
actions = {

}

},

Always();
SetMemory(0x6616B0, SetTo, 30343168);
SetMemory(0x661E30, SetTo, 65537);
SetMemory(0x661E34, SetTo, 0);
SetMemory(0x662334, SetTo, 387383831);
SetMemory(0x662B94, SetTo, 65537);
SetMemory(0x662F6C, SetTo, 387383831);
SetMemory(0x6633EC, SetTo, 387385879);
SetMemory(0x663B1C, SetTo, 387383831);
SetMemory(0x6643B4, SetTo, 536870916);
SetMemory(0x664964, SetTo, 387383831);
SetMemory(0x666458, SetTo, 15270434);
Comment("EUD Editor");

BulletInitSetting(P1,{203,74,229,1},2,147,231,233,233,0,0,0,0,1,0,0,{0,0,0},0)
BulletInitSetting(P1,{204,177,385,1},1,164,386,210,233,10,0,0,0,1,0,0,{0,0,0},0)
X, CGRP, H, Step, Delay, W = CreateVars(6,P1)
Y = CreateVar2(P1,nil,nil,1120)
Z = CreateVar2(P1,nil,nil,4)
DoActionsX(P1,SetNVar(Delay,Subtract,1))
-- 0 3 6 9 12 15 18 21 : background Filter Image (Black)
CreateSprite(P1,P1,204,0,0,0,{"CLoc",384+72,1120+72},ElapsedTime(Exactly,1),nil,0)
CreateSprite(P1,P1,204,3,0,0,{"CLoc",384+72,1120+72},ElapsedTime(Exactly,2),nil,0)
CreateSprite(P1,P1,204,6,0,0,{"CLoc",384+72,1120+72},ElapsedTime(Exactly,3),nil,0)
CreateSprite(P1,P1,204,9,0,0,{"CLoc",384+72,1120+72},ElapsedTime(Exactly,4),nil,0)
CreateSprite(P1,P1,204,12,0,0,{"CLoc",384+72,1120+72},ElapsedTime(Exactly,5),nil,0)
CreateSprite(P1,P1,204,15,0,0,{"CLoc",384+72,1120+72},ElapsedTime(Exactly,6),nil,0)
CreateSprite(P1,P1,204,18,0,0,{"CLoc",384+72,1120+72},ElapsedTime(Exactly,7),nil,0)
CreateSprite(P1,P1,204,21,0,0,{"CLoc",384+72,1120+72},ElapsedTime(Exactly,8),nil,0)
CIf(P1,ElapsedTime(AtLeast,9))
-- 1 4 7 10 13 16 19 22 : Height로 음영을 나타냄
CIf(P1,{NVar(Step,Exactly,0),NVar(Delay,Exactly,0),NVar(Y,AtMost,47*3+1120)},{SetNVar(X,SetTo,384),SetImageColor(233,0)})
CWhile(P1,NVar(X,AtMost,47*3+384))
CRead(P1,CGRP,FArr(FA1,Z),nil,0x3FFF) -- RGBW 8/12/15/Fill K[3] T[3] 14bit
CReadX(P1,H,FArr(FA1,Z),nil,{0xFF000000,0xFF},1/16777216) -- Height*16777216 8bit
CIf(P1,{NVar(CGRP,Exactly,1,1)}) -- Red Plot
CreateSprite(P1,P1,203,H,0,0,{"CLoc",X,Y})
CIfEnd()
CWhileEnd({SetNVar(X,Add,3),SetNVar(Z,Add,1)})
DoActionsX(P1,SetNVar(Y,Add,3))
CIfEnd()
TriggerX(P1,{NVar(Y,Exactly,48*3+1120),NVar(Step,Exactly,0)},{SetNVar(Y,SetTo,1120),SetNVar(Z,SetTo,4),SetNVar(Step,SetTo,1),SetNVar(Delay,SetTo,4)})
CIf(P1,{NVar(Step,Exactly,1),NVar(Delay,Exactly,0),NVar(Y,AtMost,47*3+1120)},{SetNVar(X,SetTo,384),SetImageColor(233,13),SetNVar(Delay,Add,2)})
CWhile(P1,NVar(X,AtMost,47*3+384))
CRead(P1,CGRP,FArr(FA1,Z),nil,0x3FFF) -- RGBW 8/12/15/Fill K[3] T[3] 14bit
CReadX(P1,H,FArr(FA1,Z),nil,{0xFF000000,0xFF},1/16777216) -- Height*16777216 8bit
CIf(P1,{NVar(CGRP,Exactly,2,2)}) -- Green Plot
CreateSprite(P1,P1,203,H,0,0,{"CLoc",X,Y})
CIfEnd()
CWhileEnd({SetNVar(X,Add,3),SetNVar(Z,Add,1)})
DoActionsX(P1,SetNVar(Y,Add,3))
CIfEnd()
TriggerX(P1,{NVar(Y,Exactly,48*3+1120),NVar(Step,Exactly,1)},{SetNVar(Y,SetTo,1120),SetNVar(Z,SetTo,4),SetNVar(Step,SetTo,2),SetNVar(Delay,SetTo,4)})
CIf(P1,{NVar(Step,Exactly,2),NVar(Delay,Exactly,0),NVar(Y,AtMost,47*3+1120)},{SetNVar(X,SetTo,384),SetImageColor(233,16),SetNVar(Delay,Add,3)})
CWhile(P1,NVar(X,AtMost,47*3+384))
CRead(P1,CGRP,FArr(FA1,Z),nil,0x3FFF) -- RGBW 8/12/15/Fill K[3] T[3] 14bit
CReadX(P1,H,FArr(FA1,Z),nil,{0xFF000000,0xFF},1/16777216) -- Height*16777216 8bit
CIf(P1,{NVar(CGRP,Exactly,4,4)}) -- Blue Plot
CreateSprite(P1,P1,203,H,0,0,{"CLoc",X,Y})
CIfEnd()
CWhileEnd({SetNVar(X,Add,3),SetNVar(Z,Add,1)})
DoActionsX(P1,SetNVar(Y,Add,3))
CIfEnd()
TriggerX(P1,{NVar(Y,Exactly,48*3+1120),NVar(Step,Exactly,2)},{SetNVar(Y,SetTo,1120),SetNVar(Z,SetTo,4),SetNVar(Step,SetTo,3),SetNVar(Delay,SetTo,4)})
CIf(P1,{NVar(Step,Exactly,3),NVar(Delay,Exactly,0),NVar(Y,AtMost,47*3+1120)},{SetNVar(X,SetTo,384),SetImageColor(233,12),SetNVar(Delay,Add,2)})
CWhile(P1,NVar(X,AtMost,47*3+384))
CRead(P1,CGRP,FArr(FA1,Z),nil,0x3FFF) -- RGBW 8/12/15/Fill K[3] T[3] 14bit
CReadX(P1,H,FArr(FA1,Z),nil,{0xFF000000,0xFF},1/16777216) -- Height*16777216 8bit
CIf(P1,{NVar(CGRP,Exactly,0x800,0x800+15)}) -- Indigo Plot
CreateSprite(P1,P1,203,H,0,0,{"CLoc",X,Y})
CIfEnd()
CWhileEnd({SetNVar(X,Add,3),SetNVar(Z,Add,1)})
DoActionsX(P1,SetNVar(Y,Add,3))
CIfEnd()
TriggerX(P1,{NVar(Y,Exactly,48*3+1120),NVar(Step,Exactly,3)},{SetNVar(Y,SetTo,1120),SetNVar(Z,SetTo,4),SetNVar(Step,SetTo,4),SetNVar(Delay,SetTo,4)})
-- 2 5 8 11 14 17 20 23 : 각 점마다 음영을 쌓아서 만듬
CIf(P1,{NVar(Step,Exactly,4),NVar(Delay,Exactly,0),NVar(Y,AtMost,47*3+1120)},{SetNVar(X,SetTo,384),SetImageColor(233,6),SetNVar(Delay,Add,2)})
CWhile(P1,NVar(X,AtMost,47*3+384))
CRead(P1,CGRP,FArr(FA1,Z),nil,0x3FFF) -- RGBW 8/12/15/Fill K[3] T[3] 14bit
CReadX(P1,H,FArr(FA1,Z),1,{0xFF000000,0xFF},1/16777216) -- Height*16777216 8bit
CWhile(P1,{NVar(CGRP,AtLeast,1*0x800,3*0x800),NVar(CGRP,AtLeast,1,15)},{SetNVar(CGRP,Subtract,1*0x800,3*0x800)}) -- Transparent Red Plot
CreateSprite(P1,P1,203,H,0,0,{"CLoc",X,Y})
CWhileEnd()
CWhileEnd({SetNVar(X,Add,3),SetNVar(Z,Add,1)})
DoActionsX(P1,SetNVar(Y,Add,3))
CIfEnd()
TriggerX(P1,{NVar(Y,Exactly,48*3+1120),NVar(Step,Exactly,4)},{SetNVar(Y,SetTo,1120),SetNVar(Z,SetTo,4),SetNVar(Step,SetTo,5),SetNVar(Delay,SetTo,4)})
-- White Unit Sprite Plot (N틱마다 갱신)
TriggerX(P1,NVar(Delay,Exactly,0),RemoveUnit(205,P1),{Preserved})
CWhile(P1,{NVar(Step,Exactly,5),NVar(Delay,Exactly,0),NVar(Y,AtMost,47*3+1120)},{SetNVar(X,SetTo,384),SetImageColor(233,17),SetImageScript(233,131)})
CWhile(P1,NVar(X,AtMost,47*3+384))
CRead(P1,CGRP,FArr(FA1,Z),nil,0x3FFF) -- RGBW 8/12/15/Fill K[3] T[3] 14bit
CReadX(P1,H,FArr(FA1,Z),nil,{0xFF000000,0xFF},1/16777216) -- Height*16777216 8bit
CIf(P1,{NVar(CGRP,Exactly,8,8),NVar(CGRP,AtMost,6*0x100,7*0x100)}) -- White Plot
CMov(P1,W,Y,-4)
UnitSprite(P1,P1,205,H,"X",{"CLoc",X,W})
CIfEnd()
CWhileEnd({SetNVar(X,Add,3),SetNVar(Z,Add,1)})
DoActionsX(P1,SetNVar(Y,Add,3))
CWhileEnd()
TriggerX(P1,{NVar(Y,Exactly,48*3+1120),NVar(Step,Exactly,5)},{SetNVar(Y,SetTo,1120),SetNVar(Z,SetTo,4),SetNVar(Delay,SetTo,4)},{Preserved})
CIfEnd()

------------------------------------------------------------------------------------------

427

------------------------------------------------------------------------------------------

『 29장 : 파일 I/O 및 CGRP 삽입 함수 』

-----------------------------------------------------------------------------------------[예제 29-8] (CS_Photo-2 예제) .CGRP 헤더 활용법
CJump(AllPlayers,0)
FA1 = f_GetFileptr(P1,"29-8_out.cgrp",1)
CJumpEnd(AllPlayers,0)
BulletInitSetting(P1,{203,74,229,1},2,147,231,233,233,15,0,0,0,1,0,0,{0,0,0})
X, Y, CGRP, XSize, YSize, XNum, YNum, XMax, YMax = CreateVars(9,P1)
Z = CreateVar2(P1,nil,nil,4)
-- Num(4) / XNum(4) / YNum(4) / YSize XSize(2/2) 16bytes header
CRead(P1,0x57F0F0,FArr(FA1,0))
CRead(P1,XNum,FArr(FA1,1))
CRead(P1,YNum,FArr(FA1,2))
CRead(P1,XSize,FArr(FA1,3),nil,0xFFFF)
CReadX(P1,YSize,FArr(FA1,3),nil,{0xFFFF0000,0xFFFF},1/65536)
CIf(P1,{TTNVar(YMax,Below,YNum)},{SetNVar(XMax,SetTo,0)})
CWhileX(P1,{TTNVar(XMax,Below,XNum)})
CRead(P1,CGRP,FArr(FA1,Z))
CIf(P1,NVar(CGRP,Exactly,64,64)) -- RGBW 8/12/15/Fill K[3] T[3] 14bit
CAdd(P1,X,_Mul(XMax,XSize),384)
CAdd(P1,Y,_Mul(YMax,YSize),1120)
CreateSprite(P1,P1,203,20,0,0,{"CLoc",X,Y}) -- YellowGreen Box Plot
CIfEnd()
CWhileXEnd({SetNVar(XMax,Add,1),SetNVar(Z,Add,1)})
CIfEnd(SetNVar(YMax,Add,1))

-----------------------------------------------------------------------------------------[예제 29-9] (CS_Photo-2 예제) 가변 이미지 출력 예제
CJump(AllPlayers,0)
FA1 = f_GetFileptr(P1,"29-9A_out.cgrp",1)
FA2 = f_GetFileptr(P1,"29-9B_out.cgrp",1)
FA3 = f_GetFileptr(P1,"29-9C_out.cgrp",1)
FA4 = f_GetFileptr(P1,"29-9D_out.cgrp",1)
FA5 = f_GetFileptr(P1,"29-9E_out.cgrp",1)
FA6 = f_GetFileptr(P1,"29-9F_out.cgrp",1)
CJumpEnd(AllPlayers,0)
ScanInitSetting(P1,0)
X, Y, CGRP, Step = CreateVars(4,P1)
Z = CreateVar2(P1,nil,nil,4)
DoActionsX(P1,{SetNVar(Step,Add,1),SetNVar(Y,SetTo,1120),SetNVar(Z,SetTo,4)
,SetScanImage(233),SetImageScript(233,250),SetImageColor(233,17)})
TriggerX(P1,NVar(Step,Exactly,6),SetNVar(Step,SetTo,0),{Preserved})
-- 주의 : ScanSprite의 최대 한도는 약 500~600개 정도임 (Unlimiter로 확장 불가)
CWhile(P1,NVar(Y,AtMost,31*3+1120),{SetNVar(X,SetTo,384)})
CWhile(P1,NVar(X,AtMost,31*3+384))
CIfX(P1,NVar(Step,Exactly,0))
CRead(P1,CGRP,FArr(FA1,Z))
CElseIfX(NVar(Step,Exactly,1))
CRead(P1,CGRP,FArr(FA2,Z))
CElseIfX(NVar(Step,Exactly,2))
CRead(P1,CGRP,FArr(FA3,Z))
CElseIfX(NVar(Step,Exactly,3))
CRead(P1,CGRP,FArr(FA4,Z))
CElseIfX(NVar(Step,Exactly,4))
CRead(P1,CGRP,FArr(FA5,Z))
CElseIfX(NVar(Step,Exactly,5))
CRead(P1,CGRP,FArr(FA6,Z))
CIfXEnd()
CIf(P1,NVar(CGRP,Exactly,8,8))
ScanSprite(P1,1,P1,0,{"CLoc",X,Y})
CIfEnd()
CWhileEnd({SetNVar(X,Add,3),SetNVar(Z,Add,1)})
CWhileEnd(SetNVar(Y,Add,3))
DoActions(P1,RemoveUnit(33,P1))

------------------------------------------------------------------------------------------

428

------------------------------------------------------------------------------------------

『 29장 : 파일 I/O 및 CGRP 삽입 함수 』

-----------------------------------------------------------------------------------------[예제 29-10] (CS_Photo-2 예제) UnlmiterX.py 활용 예제 (다중 이미지 삽입)
-- ※ 주의 : 총 43000개 이상의 총알이 생성되며, 이 총알들이 한번에 시야에 들어올 경우 드랍당함
CJump(AllPlayers,0)
FA1 = f_GetFileptr(P1,"29-10_out.cgrp",1)
CJumpEnd(AllPlayers,0)
DoActions(P1,RemoveUnit("Any unit",AllPlayers),{}) -- 모든 유닛 제거 (시야 차단)
BulletInitSetting(P1,{203,74,229,1},2,147,231,233,233,0,0,0,0,1,0,0,{0,0,0},0)
ScanInitSetting(P1,0)
X, CGRP, H, Step, Delay, A, B, C, D = CreateVars(9,P1)
Y = CreateVar2(P1,nil,nil,1120)
Z = CreateVar2(P1,nil,nil,4)
DoActionsX(P1,SetNVar(Delay,Subtract,1))
CIf(P1,ElapsedTime(AtLeast,5))
-- 4 : background Filter Image (White)
CIf(P1,{NVar(Step,Exactly,3),NVar(Delay,Exactly,0)},{SetScanImage(210),SetImageColor(210,17),SetImageScript(210,250),SetNVar(A,SetTo,0)})
CWhile(P1,NVar(A,AtMost,3),SetNVar(B,SetTo,0))
CWhile(P1,NVar(B,AtMost,3))
CAdd(P1,C,_Mul(A,576),384+93)
CAdd(P1,D,_Mul(B,576),1120+93)
ScanSprite(P1,1,P8,1,{"CLoc",C,D})
CWhileEnd(SetNVar(B,Add,1))
CWhileEnd(SetNVar(A,Add,1))
TriggerX(P1,nil,{RemoveUnit("Zerg Broodling",P1),CreateUnit(1,"Terran SCV","CLoc2",P1)})
CIfEnd()
-- 5 6(T) 7(K) : (각 점마다 음영을 쌓아서 만듬)
CIf(P1,{NVar(Step,Exactly,0),NVar(Delay,Exactly,0),NVar(Y,AtMost,63*3+1120)},{SetNVar(X,SetTo,384),SetImageColor(233,16),SetNVar(Delay,Add,4)})
CWhile(P1,NVar(X,AtMost,63*3+384))
CRead(P1,CGRP,FArr(FA1,Z),nil,0x3FFF) -- RGBW 8/12/15/Fill K[3] T[3] 14bit
CIf(P1,{NVar(CGRP,Exactly,4,4)},{SetNVar(A,SetTo,0)}) -- Blue Plot
CWhile(P1,NVar(A,AtMost,3),SetNVar(B,SetTo,0))
CWhile(P1,NVar(B,AtMost,3))

CIfEnd()
CWhileEnd({SetNVar(X,Add,3),SetNVar(Z,Add,1)})
DoActionsX(P1,SetNVar(Y,Add,3))

CWhileEnd(SetNVar(A,Add,1))

CWhileEnd(SetNVar(B,Add,1))

CAdd(P1,C,_Mul(A,576),X)
CAdd(P1,D,_Mul(B,576),Y)
CreateSprite(P1,P8,203,5,0,0,{"CLoc",C,D},nil,SetResources(P1,Add,1,Ore))

CIfEnd()
TriggerX(P1,{NVar(Y,Exactly,64*3+1120),NVar(Step,Exactly,0)},{SetNVar(Y,SetTo,1120),SetNVar(Z,SetTo,4),SetNVar(Step,SetTo,1),SetNVar(Delay,SetTo,4)})
CIf(P1,{NVar(Step,Exactly,1),NVar(Delay,Exactly,0),NVar(Y,AtMost,63*3+1120)},{SetNVar(X,SetTo,384),SetImageColor(233,6),SetNVar(Delay,Add,4)})
CWhile(P1,NVar(X,AtMost,63*3+384))
CRead(P1,CGRP,FArr(FA1,Z),nil,0x3FFF) -- RGBW 8/12/15/Fill K[3] T[3] 14bit
CWhile(P1,{NVar(CGRP,AtLeast,1*0x800,3*0x800)},{SetNVar(CGRP,Subtract,1*0x800,3*0x800),SetNVar(A,SetTo,0)}) -- Transparent Red Plot
CWhile(P1,NVar(A,AtMost,3),SetNVar(B,SetTo,0))
CWhile(P1,NVar(B,AtMost,3))
CAdd(P1,C,_Mul(A,576),X)
CAdd(P1,D,_Mul(B,576),Y)
CreateSprite(P1,P8,203,6,0,0,{"CLoc",C,D},nil,SetResources(P1,Add,1,Ore))
CWhileEnd(SetNVar(B,Add,1))
CWhileEnd(SetNVar(A,Add,1))
CWhileEnd()
CWhileEnd({SetNVar(X,Add,3),SetNVar(Z,Add,1)})
DoActionsX(P1,SetNVar(Y,Add,3))
CIfEnd()
TriggerX(P1,{NVar(Y,Exactly,64*3+1120),NVar(Step,Exactly,1)},{SetNVar(Y,SetTo,1120),SetNVar(Z,SetTo,4),SetNVar(Step,SetTo,2),SetNVar(Delay,SetTo,4)})
CIf(P1,{NVar(Step,Exactly,2),NVar(Delay,Exactly,0),NVar(Y,AtMost,63*3+1120)},{SetNVar(X,SetTo,384),SetImageColor(233,10),SetNVar(Delay,Add,4)})
CWhile(P1,NVar(X,AtMost,63*3+384))
CRead(P1,CGRP,FArr(FA1,Z),nil,0x3FFF) -- RGBW 8/12/15/Fill K[3] T[3] 14bit
CWhile(P1,{NVar(CGRP,AtLeast,1*0x100,3*0x100)},{SetNVar(CGRP,Subtract,1*0x100,3*0x100),SetNVar(A,SetTo,0)}) -- Transparent Black Plot
CWhile(P1,NVar(A,AtMost,3),SetNVar(B,SetTo,0))
CWhile(P1,NVar(B,AtMost,3))
CAdd(P1,C,_Mul(A,576),X)
CAdd(P1,D,_Mul(B,576),Y)
CreateSprite(P1,P8,203,7,0,0,{"CLoc",C,D},nil,SetResources(P1,Add,1,Ore))
CWhileEnd(SetNVar(B,Add,1))
CWhileEnd(SetNVar(A,Add,1))
CWhileEnd()
CWhileEnd({SetNVar(X,Add,3),SetNVar(Z,Add,1)})
DoActionsX(P1,SetNVar(Y,Add,3))
CIfEnd()
TriggerX(P1,{NVar(Y,Exactly,64*3+1120),NVar(Step,Exactly,2)},{SetNVar(Y,SetTo,1120),SetNVar(Z,SetTo,4),SetNVar(Step,SetTo,3),SetNVar(Delay,SetTo,4)})
CIfEnd()

-----------------------------------------------------------------------------------------[UnlimiterX]
Count : 65536

------------------------------------------------------------------------------------------

429

------------------------------------------------------------------------------------------

『 # : 부록 예제 』

------------------------------------------------------------------------------------------

- ｡˙+ﾟ 부록 : P1 마린 데스값 인식 사용방법 ｡+.ﾟ[예제 #-1] 0x58A364 (P1 마린 데스값 인식 방법)
-- 바로 위에 StartCtrig() 있어야함 -CJump(AllPlayers,0)
CVariable(P1,6) -- Cur
CVariable(P1,7) -- Prev
CVariable(P1,8) -- Value
CJumpEnd(AllPlayers,0)
-- 첫 번째 플레이어가 P1일 경우 (아닐경우 P1을 다른 플레이어로 바꿔야함)
CRead(P1,V(6),0x58A364)
CSub(P1,V(8),V(6),V(7)) -- V(8)에 추가된 마린 데스값을 저장함
-- 나머지 코드 작성 영역-------------------------------------Trigger { -- P1 마린 사망 인식 예시 트리거 (1데스마다 사망 메세지 출력)
players = {P1},
conditions = {
Label(0);
CVar("X",8,AtLeast,1);
},
actions = {
SetCVar("X",8,Subtract,1);
DisplayText("\x08P1 마린이 당했습니다.");
PreserveTrigger();
}
}
-- 나머지 코드 작성 영역---------------------------------------CRead(P8,V(7,P1),0x58A364)
-- 마지막 플레이어가 P8일 경우 (아닐경우 P8을 다른 플레이어로 바꿔야함)
-- 바로 아래에 EndCtrig() 있어야함 ---------------------------------------------------------------------------------------------

430

------------------------------------------------------------------------------------------

『 # : 부록 예제 』

------------------------------------------------------------------------------------------

- ｡˙+ﾟ 부록 : 사용자 정의 함수 생성 예시｡+.ﾟ[예제 #-2] : C << A + B 함수를 CtrigPlib 문법으로 작성하는 예시
f_Add() / 입출력 타입 : V(C) << V(A) + V(B)
CtrigAsm 호출형 함수는 함수의 원형 트리거(반드시 CJump안에 있어야함)와 호출 lua 함수로 구성된다.
※ 함수 원형은 반드시 PlayerID를 AllPlayers로, 변수들의 Player는 CurrentPlayer로 설정한다.
실행 순서 : Local Var << Input(Source, Operand) → Call Func → Func Start → 함수 연산 → Func End
→ Output(Dest) << Local Var
CJump(AllPlayers,0)
--↓ f_Add 원형 선언부 --------------------------------------------------------------------FADD = {} -- Local CVariable용 배열
FADDCall1 = 0
FADDCall2 = 0
for i = 0, 2 do
CVariable(Allplayers,FuncAlloc+i) -- Local CVariable
table.insert(FADD,FuncAlloc+i)
end
FuncAlloc = FuncAlloc + 3
Trigger {

}
FADDCall1 = FuncAlloc
FuncAlloc = FuncAlloc + 1

players = {Allplayers}, -- f_Add Start
conditions = {
},
flag = {Preserved}

Label(FuncAlloc);

CAdd(AllPlayers,V(FADD[3]),V(FADD[1]),V(FADD[2])) -- 함수 내용 C << A + B
Trigger {

players = {Allplayers}, -- f_Add End
conditions = {

},
flag = {Preserved}
}
FADDCall2 = FuncAlloc
FuncAlloc = FuncAlloc + 1
--↑ f_Add 원형 선언부 --------------------------------------------------------------------CVariable(P1,0x10)
CVariable(P1,0x11)
CVariable(P1,0x12)
CJumpEnd(AllPlayers,0)

Label(FuncAlloc);

function f_Add(PlayerID,Dest,Source,Operand)
-- Input Data : Source
Trigger {

players = {ParsePlayer(PlayerID)},
conditions = {
},
actions = {

}
-- Input Data : Operand
Trigger {

},
flag = {Preserved}

players = {ParsePlayer(PlayerID)},
conditions = {
},
actions = {

}
-- Call f_Add
Trigger {

},
flag = {Preserved}

players = {ParsePlayer(PlayerID)},
conditions = {
},
actions = {

if FADDCall1 == 0 then
end

}

},
flag = {Preserved}

SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FADD[1],0x15C,1,0);
SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
CallLabelAlways(Source[1],Source[2],Source[3]);

Label(0);
SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",FADD[2],0x15C,1,0);
SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
CallLabelAlways(Operand[1],Operand[2],Operand[3]);

Label(0);
SetCtrigX("X","X",0x4,0,SetTo,"X",FADDCall1,0x0,0,0);
SetCtrigX("X",FADDCall2,0x4,0,SetTo,"X","X",0x0,0,1);

Need_Include_f_Add()

-- Output Data : Dest
Trigger {

players = {ParsePlayer(PlayerID)},
conditions = {
},
actions = {

end

Label(0);

}

},
flag = {Preserved}

Label(0);
SetCtrigX("X",FADD[3],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
SetCtrig1X("X",FADD[3],0x148,0,SetTo,0xFFFFFFFF);
SetCtrig1X("X",FADD[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
CallLabelAlways("X",FADD[3],0);

CMov(P1,V(0x10),_Read(0x57f0f0))
CMov(P1,V(0x11),_Read(0x57f120))
f_Add(P1,V(0x12),V(0x11),V(0x10))
CMov(P1,0x58F450,V(0x12))

--------------------------------------------------------------------------------------------

431

------------------------------------------------------------------------------------------

『 # : 부록 예제 』

------------------------------------------------------------------------------------------

- ｡˙+ﾟ 부록 : 사용자 정의 함수 생성 예시｡+.ﾟ[예제 #-3] : 사용자 정의 함수(f_Add)에 중간연산자 지원 및
상수와 VA타입 입출력 호환을 추가하는 예시
CJump(AllPlayers,0)
--↓ f_Add 원형 선언부 --------------------------------------------------------------------FADD = {} -- Local CVariable용 배열
FADDCall1 = 0
FADDCall2 = 0
for i = 0, 2 do
end
FuncAlloc = FuncAlloc + 3
Trigger {

}
FADDCall1 = FuncAlloc
FuncAlloc = FuncAlloc + 1

CVariable(Allplayers,FuncAlloc+i) -- Local CVariable
table.insert(FADD,FuncAlloc+i)

players = {Allplayers}, -- f_Add Start
conditions = {
},
flag = {Preserved}

Label(FuncAlloc);

CAdd(AllPlayers,V(FADD[3]),V(FADD[1]),V(FADD[2])) -- 함수 내용 C << A + B
Trigger {

}
FADDCall2 = FuncAlloc
FuncAlloc = FuncAlloc + 1
--↑ f_Add 원형 선언부 --------------------------------------------------------------------CVariable(P1,0x10)
CVariable(P1,0x11)
CVariable(P1,0x12)
VA1 = CVArray(P1,10)
CVariable2(P1,0x20,"X","X",0) i = 0x20
CJumpEnd(AllPlayers,0)
function f_Add(PlayerID,Dest,Source,Operand)

players = {Allplayers}, -- f_Add End
conditions = {
},
flag = {Preserved}

STPopTrigArr(PlayerID) -- 중간 연산자 지원 함수 (Dest/Source/Operand에 중간연산함수를 삽입가능)
-- Input Data : Source
if type(Source) == "number" then -- 상수타입
Trigger {

Label(FuncAlloc);

players = {ParsePlayer(PlayerID)},
conditions = {
},
actions = {

elseif Source[4] == "VA" then -- VA타입
elseif Source[4] == "V" then -- 변수타입

}

},
flag = {Preserved}

-- Input Data : Operand
if type(Operand) == "number" then -- 상수타입

Trigger {

players = {ParsePlayer(PlayerID)},
conditions = {

}

Trigger {

},
flag = {Preserved}

players = {ParsePlayer(PlayerID)},
conditions = {
},
actions = {

elseif Operand[4] == "VA" then -- VA타입
elseif Operand[4] == "V" then -- 변수타입

}

},
flag = {Preserved}

Trigger {

players = {ParsePlayer(PlayerID)},
conditions = {

}

},
flag = {Preserved}

players = {ParsePlayer(PlayerID)},
conditions = {
},
actions = {

if FADDCall1 == 0 then
end
-- Output Data : Dest
if Dest[4] == "V" then -- 변수타입

}

},
flag = {Preserved}

end

end

SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FADD[1],0x15C,1,0);
SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
CallLabelAlways(Source[1],Source[2],Source[3]);

Label(0);
SetCtrig1X("X",FADD[2],0x15C,0,SetTo,Operand);

Label(0);
SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",FADD[2],0x15C,1,0);
SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
CallLabelAlways(Operand[1],Operand[2],Operand[3]);

Label(0);
SetCtrigX("X","X",0x4,0,SetTo,"X",FADDCall1,0x0,0,0);
SetCtrigX("X",FADDCall2,0x4,0,SetTo,"X","X",0x0,0,1);

Need_Include_f_Add()

Trigger {

players = {ParsePlayer(PlayerID)},
conditions = {
},
actions = {

elseif Dest[4] == "VA" then

Label(0);

local TempRet = {"X",FADD[2],0,"V"}
MovX(PlayerID,TempRet,Operand)

},
actions = {

end
-- Call f_Add
Trigger {

SetCtrig1X("X",FADD[1],0x15C,0,SetTo,Source);

local TempRet = {"X",FADD[1],0,"V"}
MovX(PlayerID,TempRet,Source)

},
actions = {

end

Label(0);

}

},
flag = {Preserved}

Label(0);
SetCtrigX("X",FADD[3],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
SetCtrig1X("X",FADD[3],0x148,0,SetTo,0xFFFFFFFF);
SetCtrig1X("X",FADD[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
CallLabelAlways("X",FADD[3],0);

local TempRet = {"X",FADD[3],0,"V"}
MovX(PlayerID,Dest,TempRet)

f_Add(P1,V(0x12),_Read(0x57f0f0),_Read(0x57f120)) -- 중간 연산자 사용
CMov(P1,0x58F450,V(0x12))
f_Add(P1,V(0x10),0x12345,0x67890) -- 상수 타입 입출력
CMov(P1,0x58F454,V(0x10))
CMovX(P1,VArr(VA1,Vi(i,1)),_Read(0x57f0f0))
CMovX(P1,VArr(VA1,Vi(i,2)),_Read(0x57f120))
f_Add(P1,VArr(VA1,Vi(i,0)),VArr(VA1,Vi(i,1)),VArr(VA1,Vi(i,2))) -- VA 타입 입출력
CMov(P1,0x58F458,VArr(VA1,Vi(i,0)))

-------------------------------------------------------------------------------------------432

------------------------------------------------------------------------------------------

『 F. CX Paint 함수목록 』

------------------------------------------------------------------------------------------

｡˙+ﾟ 0. 목차 ｡+.ﾟ
1장 : Shape 및 Path 데이터 구조
2장 : CSMake 함수 (Shape 생성)
3장 : CS_ 편집함수 (이미지 편집)
4장 : CSPlot 함수 (트리거 변환)
5장 : CSSave 함수 (파일 입출력)
6장 : 추가 CS함수 (확장 함수팩)
7장 : CA_ 실시간 편집함수 (어셈블러필요)
8장 : CAPlot 함수 (어셈블러필요)
9장 : CXPlot 및 3차원 도형함수 (어셈블러필요)
10장 : 추가 고급 편집 함수 (v2.3이상)

11장 : 추가 고급 실시간 편집 함수 (v2.4이상)
# : 부록 설명 (예제 도형)

433

------------------------------------------------------------------------------------------

『 1장 : Shape 및 Path 데이터 구조 』

------------------------------------------------------------------------------------------

- ｡˙+ﾟ Shape(Path) 데이터 구조 ｡+.ﾟ점(Point) 데이터 : {X좌표,Y좌표} : 좌표값은 실수(R)로 저장됨
Shape 데이터 구조 : {점의 총 갯수(n),{X1,Y1},{X2,Y2}, ... ,{Xn,Yn}} (n개의 점으로 구성된 경우)
Path와 Shape의 데이터 구조는 차이가 없으나, 일반적으로 Path는 선을, Shape는 면을 이룬다.

※ CS함수를 사용하지 않고 직접 Shape(Path) 데이터를 제작 및 수정해서 사용할 수 있다.
※ Path영역은 이웃한 점들을 연결하여 만든 선분들이 만드는 하나의 폐곡선 내부 영역을 말한다.
CS Paint 작동 순서 : CSMake(도형생성) → CS_(편집) → CSPlot(트리거 변환) or →CSSave(파일로 저장)

1. CSMake 함수로 Shape 또는 Path 데이터를 생성한다.
2. 만들어진 Shape(Path) 데이터를 CS_ 함수로 편집 및 수정한다.
3. 최종적으로 만들어진 Shape(Path) 데이터를 저장(CSSave) 또는 트리거로 변환(CSPlot) 한다.

※ 자세한 사용방법에 대한 설명 및 예제는 CS Paint Example.txt를 참고
※ 각(Angle)의 경우, 일반적으로는 degree 단위로 입력하나,
그래프 식에 관한 인자일 경우 radian 단위로 입력한다.
Ex) [예제 1-1] 참고, [예제 1-2] 참고

｡˙+ﾟShape｡+.ﾟ

｡˙+ﾟPath｡+.ﾟ

434

------------------------------------------------------------------------------------------

『 2장 : CSMake 함수 (Shape 생성) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CSMake 함수는 도형 데이터를 생성하는 함수이며, 기본 도형 및 그래프를 그릴 수 있습니다 ｡+.ﾟ

CSMakePath(PathData,...)
CSMakePathX(Ratio,PathData,...)
: 점들을 묶어 Path 데이터로 만듬 (사용자 정의 도형 드로잉)
PathData : Point 데이터 배열 = {{X1,Y1},{X2,Y2}, ... }
... (가변인자) : Point 데이터 (PathData에 자동으로 합쳐짐)
Ratio(X전용) : X,Y좌표 확대 배율 설정 = {X배율,Y배율} or 공통배율 - 비워둘 경우 1로 입력됨

Ex) [예제 2-1] 참고, [예제 2-2] 참고
CSMakePolygon(Point,Radius,Angle,Number,Hollow)
CSMakePolygonX(Point,Radius,Angle,Number,Hollow)
: 정 n다각형 Shape 데이터를 생성함
Point : 변의 갯수 (n≥3)
Radius : 도형의 크기 (각 껍질사이의 거리)
Angle : 도형이 회전한 각도

Number : 찍을 점의 갯수
Hollow : 내부에서 지울 점의 갯수
※ 실제로 생성되는 총 점의 갯수는 Number - Hollow개이며, 원점부터 Hollow개만큼 지워진다.

Ex) [예제 2-3] 참고
CSMakeCircle(Point,Radius,Angle,Number,Hollow)
CSMakeCircleX(Point,Radius,Angle,Number,Hollow)
: 정 n다각형에 외접한 원 모양의 Shape 데이터를 생성함

Point : 변의 갯수 (n≥1)
Radius : 도형의 크기 (각 껍질사이의 거리)
Angle : 도형이 회전한 각도
Number : 찍을 점의 갯수
Hollow : 내부에서 지울 점의 갯수
※ Polygon(X)와 동일하나, 점의 좌표가 정n다각형에 외접하는 원 위의 점으로 설정된다.
※ Polygon 도형 생성 규칙 : 중심(0,0)부터 n각형의 껍질을 그리며 내부에서 외부로 점을 찍는다.
찍히는 점의 갯수는 k번째 껍질의 경우 k*n개 이며 도형 전체는 총 k/2*(n^2+n)+1개가 찍힌다.(k=0부터 시작)

X함수의 경우 1번째 껍질부터 시작하며(k=1), k가 2씩 증가한다.
이 규칙은 Circle(X), Star(X)에도 똑같이 적용된다. / Ex) [예제 2-4] 참고

435

------------------------------------------------------------------------------------------

『 2장 : CSMake 함수 (Shape 생성) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CSMake 함수는 도형 데이터를 생성하는 함수이며, 기본 도형 및 그래프를 그릴 수 있습니다 ｡+.ﾟ

CSMakeStar(Point,StarAngle,Radius,Angle,Number,Hollow)
CSMakeStarX(Point,StarAngle,Radius,Angle,Number,Hollow)
: 정 n다각별 Shape 데이터를 생성함
Point : 변의 갯수 (n≥3) - 자동으로 2n각형으로 입력됨

Radius : 도형의 크기 (각 껍질사이의 거리)
Angle : 도형이 회전한 각도
Number : 찍을 점의 갯수
Hollow : 내부에서 지울 점의 갯수
StarAngle : 변의 중점에서 꺾을 각도의 크기(외각을 기준으로함)
※ 숫자 입력시 각도로, {숫자}로 입력시 감소시킬 내부 반지름(원점에서 중점까지의 거리)의 길이로 입력됨
※ Angle이 180일 경우 Polygon과 동일하나 k=0부터 시작, 2씩 증가하는 형태의 정n다각형을 그릴 수 있다.

※ Number와 Hollow 수치 입력시 정2n각형의 점 갯수를 고려하여 입력해야함

Ex) [예제 2-3] 참고, [예제 2-5] 참고
CSMakeLine(Point,Radius,Angle,Number,Hollow)
CSMakeLineX(Point,Radius,Angle,Number,Hollow)
: n방향으로 뻗어나가는 선의 Shape 데이터를 생성함
Point : 변의 갯수 (n≥1) - n=1 : 반직선 / n=2 : 직선 / n≥3 : n방향 반직선
Radius : 도형의 크기 (각 껍질사이의 거리)
Angle : 도형이 회전한 각도
Number : 찍을 점의 갯수
Hollow : 내부에서 지울 점의 갯수
※ X함수의 경우 원점이 아닌 첫번째 껍질부터 시작함
Ex) [예제 2-4] 참고

※ StarAngle 값은 오른쪽 그림에서
검은색 각도로 표시된 부분을 의미함

(StarAngle 조정으로 별 모양을 오목/볼록하게 설정 가능)

436

------------------------------------------------------------------------------------------

『 2장 : CSMake 함수 (Shape 생성) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ [고급] 그래프 Path 생성 관련 : CSMakeGraphX/Y/R/A/T ｡+.ﾟ
CSMakeGraphX(Ratio,funcY,Start,Direction,StepSize,StepRange,Number)
CSMakeGraphY(Ratio,funcX,Start,Direction,StepSize,StepRange,Number)

: 직교좌표계 함수의 등간격 그래프 곡선의 Path 데이터를 생성함
Ratio : X,Y좌표 확대 배율 설정 = {X배율,Y배율} or 공통배율 - 비워둘 경우 1로 입력됨
(X함수)funcY : Y=f(X) 연산 함수의 이름 (String으로 입력)
(Y함수)funcX : X=f(Y) 연산 함수의 이름 (String으로 입력)
Start : 그리기 시작할 X좌표(X함수)/Y좌표(Y함수)
Directrion : X좌표(X함수)/Y좌표(Y함수) 증가시킬 방향 (0 : +방향/1 : -방향)
StepSize : 점 사이 간격 크기 설정
StepRange : 등간격 좌표 탐색 최대 탐색범위 - 비워둘 경우 StepSize로 입력됨
Number : 찍을 점의 총 갯수
Ex) [예제 2-6] 참고
CSMakeGraphA(Ratio,funcR,Start,Direction,StepSize,StepRange,Number)
CSMakeGraphR(Ratio,funcA,Start,Direction,StepSize,StepRange,Number)
: 극좌표계 함수의 등간격 그래프 곡선의 Path 데이터를 생성함
Ratio : X,Y좌표 확대 배율 설정 = {X배율,Y배율} or 공통배율 - 비워둘 경우 1로 입력됨

(A함수)funcR : R=f(Θ) 연산 함수의 이름 (String으로 입력)
(R함수)funcA : Θ=f(R) 연산 함수의 이름 (String으로 입력)
Start : 그리기 시작할 Θ좌표(A함수)/R좌표(R함수)
Directrion : Θ좌표(A함수)/R좌표(R함수) 증가시킬 방향 (0 : +방향/1 : -방향)
StepSize : 점 사이 간격 크기 설정
StepRange : 등간격 좌표 탐색 최대 탐색범위 - 비워둘 경우 2π(A함수), StepSize(R함수)로 입력됨

Number : 찍을 점의 총 개수
Ex) [예제 2-7] 참고

437

------------------------------------------------------------------------------------------

『 2장 : CSMake 함수 (Shape 생성) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ [고급] 그래프 Path 생성 관련 : CSMakeGraphX/Y/R/A/T ｡+.ﾟ
CSMakeGraphT(Ratio,Parafunc,Start,Direction,StepSize,StepRange,Number)
: 2D매개변수 함수의 등간격 그래프 곡선의 Path 데이터를 생성함

Ratio : X,Y좌표 확대 배율 설정 = {X배율,Y배율} or 공통배율 - 비워둘 경우 1로 입력됨
Parafunc : X=f(t), Y=g(t) 연산 함수의 이름 (String으로 입력)
Start : 그리기 시작할 t좌표
Directrion : t좌표 증가시킬 방향 (0 : +방향/1 : -방향)
StepSize : 점 사이 간격 크기 설정
StepRange : 등간격 좌표 탐색 최대 탐색범위 - 비워둘 경우 StepSize로 입력됨
Number : 찍을 점의 총 개수
※ A,R,T 함수의 경우 등간격 연산이 부정확 할 수 있으므로 경우에 맞춰서 StepRange값을 조정해줘야함

Ex) [예제 2-8] 참고
※ 사용자 정의 연산 함수 제작 및 입력 방법
function S1_funcY(X) return -X end → "S1_funcY" 입력 (y=-x)
function S1_funcX(Y) return -Y end → "S1_funcX" 입력 (x=-y)
function S1_funcR(A) return -A end → "S1_funcR" 입력 (r=-Θ)
function S1_funcA(R) return -R end → "S1_funcA" 입력 (Θ=-r)

function S1_Parafunc(T) return {-T,T} end → "S1_Parafunc(T)" 입력 (x=-t,y=t)

438

------------------------------------------------------------------------------------------

『 3장 : CS_ 편집함수 (이미지 편집) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CS_ 함수는 Shape 및 Path 데이터를 편집할 수 있습니다 ｡+.ﾟ
｡˙+ﾟ 기본 자유변형 함수 : Move/Rotate/Invert/Ratio/Mirror ｡+.ﾟ
CS_MoveXY(Shape,X,Y)
CS_MoveRA(Shape,Radius,Angle)
: 도형을 좌표축에 평행이동시킴
Shape : 대상 도형 데이터
(XY함수)X : (직교좌표) X축 +방향으로 이동할 거리
(XY함수)Y : (직교좌표) Y축 +방향으로 이동할 거리
(RA함수)Radius : (극좌표) R축 +방향으로 이동할 거리

(RA함수)Angle : (극좌표) Θ축 +방향으로 이동할 각도 (deg)
Ex) [예제 3-1] 참고
CS_MoveCenter(Shape,X,Y)
: 도형의 중심을 원하는 좌표로 평행이동시킴
Shape : 대상 도형 데이터
X : 도형의 중심으로 설정할 X좌표
Y : 도형의 중심으로 설정할 Y좌표
Ex) [예제 3-1] 참고
CS_Rotate(Shape,Angle)
CS_Rotate3D(Shape,XYAngle,YZAngle,ZXAngle)
: 도형을 각도만큼 회전시킴
Shape : 대상 도형 데이터
(2D)Angle : 회전할 각도 (deg) - 시계방향이 양수

(3D)XYAngle : XY평면에서 회전할 각도 (deg) - 시계방향이 양수
(3D)YZAngle : YZ평면에서 회전할 각도 (deg) - 시계방향이 양수
(3D)ZXAngle : ZX평면에서 회전할 각도 (deg) - 시계방향이 양수
※ Z축 좌표 데이터는 3D 연산 종료후 자동 소멸됨
Ex) [예제 3-2] 참고, [예제 3-5] 참고

439

------------------------------------------------------------------------------------------

『 3장 : CS_ 편집함수 (이미지 편집) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CS_ 함수는 Shape 및 Path 데이터를 편집할 수 있습니다 ｡+.ﾟ
｡˙+ﾟ 기본 자유변형 함수 : Move/Rotate/Invert/Ratio/Mirror ｡+.ﾟ
CS_InvertXY(Shape,X,Y)
CS_InvertRA(Shape,Radius,Angle)
: 도형을 좌표축에 평행한 직선으로 뒤집음
Shape : 대상 도형 데이터
(XY함수)X : x = X 직선으로 뒤집음
(XY함수)Y : y = Y 직선으로 뒤집음
(RA함수)Radius : r = Radius 원으로 뒤집음
(RA함수)Angle : Θ = Angle 각으로 뒤집음
Ex) [예제 3-3] 참고

CS_RatioXY(Shape,mulX,mulY)
CS_RatioRA(Shape,mulRadius,mulAngle)
: 도형을 좌표축 방향으로 확대및 축소시킴
Shape : 대상 도형 데이터
(XY함수)mulX : X좌표에 곱할 값 - 비우면 1로 입력됨
(XY함수)mulY : Y좌표에 곱할 값 - 비우면 1로 입력됨
(RA함수)mulRadius : R좌표에 곱할 값 - 비우면 1로 입력됨
(RA함수)mulAngle : Θ좌표에 곱할 값 - 비우면 1로 입력됨
Ex) [예제 3-4] 참고, [예제 3-5] 참고

CS_MirrorX(Shape,X,Side,Size)
CS_MirrorY(Shape,Y,Side,Size)
CS_MirrorR(Shape,Radius,Side,Size)
CS_MirrorA(Shape,Angle,Side,Size)
: 도형을 좌표축에 평행한 직선으로 대칭시킴
Shape : 대상 도형 데이터
(X함수)X : x = X 직선으로 대칭시킴 / (Y함수)Y : y = Y 직선으로 대칭시킴
(R함수)Radius : r = Radius 원으로 대칭시킴 / (A함수)Angle : Θ = Angle 각으로 대칭시킴

Side : 대칭시킬 영역 선택, 0또는 1 입력 - 비우면 0으로 입력
(X함수) : 왼쪽 0, 오른쪽 1 / (Y함수) : 위쪽 0, 아래쪽 1 / (R함수) : 외부 0, 내부 1 / (A함수) 증가 0, 감소 1

Size : 대칭축의 두께 (대칭축에 포함된 점은 대칭되지않음) / Ex) [예제 3-6] 참고

440

------------------------------------------------------------------------------------------

『 3장 : CS_ 편집함수 (이미지 편집) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CS_ 함수는 Shape 및 Path 데이터를 편집할 수 있습니다 ｡+.ﾟ
｡˙+ﾟ [고급] 특수변형 함수 : Kaleidoscope/Distortion/Vector2D ｡+.ﾟ
CS_Kaleidoscope(Shape,Point,StartAngle,Side,Size)
CS_KaleidoscopeX(Shape,Point,StartAngle,Side)
: 도형에 (대칭/비대칭)만화경 효과를 적용함
(일반)StartAngle부터 360/2n까지의 영역을 선대칭 시킨 후 회전대칭 시킴
(X함수)StartAngle부터 360/n까지의 영역을 회전대칭 시킴
Shape : 대상 도형 데이터
Point : 대칭시켜 만들 상의 갯수 (일반함수: 360/2n, X함수: 360/n를 대칭 영역으로 설정함)
StartAngle : 대칭시킬 영역의 시작 각도
Side : 대칭시킬 영역의 방향 설정 (0 : +각의 방향으로 대칭영역 설정 / 1: -각의 방향으로 대칭영역 설정)

Size : 대칭축의 두께 (대칭축 내부 점은 대칭되지않음)
Ex) [예제 3-7] 참고

CS_Distortion(Shape,mulLU,mulLD,mulRU,mulRD,CenterXY)
CS_DistortionX(Shape,mulLU,mulLD,mulRU,mulRD,CenterXY,Ufunc,Dfunc,Rfunc,Lfunc)
: 도형에 왜곡(원근감,비틀기,기울이기 등) 효과를 적용함
Shape : 대상 도형 데이터
mulLU : 왼쪽 위 꼭짓점의 크기비율 설정 = {X배율,Y배율} - 비우면 1(1배)로 설정됨
mulLD : 왼쪽 아래 꼭짓점의 크기비율 설정 = {X배율,Y배율} - 비우면 1(1배)로 설정됨
mulRU : 오른쪽 위 꼭짓점의 크기비율 설정 = {X배율,Y배율} - 비우면 1(1배)로 설정됨
mulRD : 오른쪽 아래 꼭짓점의 크기비율 설정 = {X배율,Y배율} - 비우면 1(1배)로 설정됨
CenterXY : 왜곡효과 중심좌표 설정 - 비우면 원점(0,0)을 중심으로 설정함 = {X좌표,Y좌표}
(X함수)Ufunc : 위쪽의 함수식과 X,Y좌표 확대 배율 설정 -- 비우면 직선으로 설정
(X함수)Dfunc : 아래쪽의 함수식과 X,Y좌표 확대 배율 설정 -- 비우면 직선으로 설정
(X함수)Lfunc : 왼쪽의 함수식과 X,Y좌표 확대 배율 설정 -- 비우면 직선으로 설정
(X함수)Rfunc : 오른쪽의 함수식과 X,Y좌표 확대 배율 설정-- 비우면 직선으로 설정
※ U,D,L,Rfunc 입력법 : {"함수이름",{X배율(축소),Y배율(확대)}} -- 배율부분 비우면 1로 설정됨
함수명은 String으로 입력, U,D는 y=f(x) / L,R는 x=f(y) 함수식을 입력
function S1_Ufunc(X) return X^2/4+8 end → "S1_Ufunc" (y=f(x))
function S1_Dfunc(X) return -X^2/4-8 end → "S1_Dfunc" (y=f(x))
function S1_Rfunc(Y) return Y^2/4+8 end → "S1_Rfunc" (x=f(y))
function S1_Lfunc(Y) return -Y^2/4-8 end → "S1_Lfunc" (x=f(y))
Ex) [예제 3-8] 참고

441

------------------------------------------------------------------------------------------

『 3장 : CS_ 편집함수 (이미지 편집) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CS_ 함수는 Shape 및 Path 데이터를 편집할 수 있습니다 ｡+.ﾟ
｡˙+ﾟ [고급] 특수변형 함수 : Kaleidoscope/Distortion/Vector2D ｡+.ﾟ
CS_Vector2D(Shape,Ratio,VectorFunc)
CS_Vector2DPolar(Shape,Ratio,VectorFunc)
: 도형에 2차원 벡터함수 변환을 적용함
Shape : 대상 도형 데이터
Ratio : 좌표의 축소비율 설정 = {X배율(축소),Y배율(축소)} - 비우면 1(1배)로 설정됨
VectorFunc : 변환식에 해당하는 벡터함수의 이름 (String으로 입력) ※ (각도는 radian단위)
Ex) [예제 3-9] 참고
※ 사용자 정의 벡터 함수 제작 및 입력 방법
function S1_Vector(X,Y) return {-Y,X} end → "S1_Vector" (f(x,y),g(x,y))
function S1_VectorPolar(R,A) return {-A,R} end → "S1_VectorPolar" (f(r,Θ),g(r,Θ))

442

------------------------------------------------------------------------------------------

『 3장 : CS_ 편집함수 (이미지 편집) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CS_ 함수는 Shape 및 Path 데이터를 편집할 수 있습니다 ｡+.ﾟ
｡˙+ﾟ도형 데이터 연산 함수 : Add/Overlap/Merge/Intersect/Subtract/Xor/RemoveStack ｡+.ﾟ

CS_Add(Shape,Ratio,PathData,...)
: 도형에 점 데이터를 추가함 (A+Point)
Shape : 대상 도형 데이터
Ratio : X,Y좌표 확대 배율 설정 = {X배율,Y배율} or 공통배율 - 비워둘 경우 1로 입력됨
PathData : Point 데이터 배열 = {{X1,Y1},{X2,Y2}, ... }
... (가변인자) : Point 데이터 (PathData에 자동으로 합쳐짐)
Ex) [예제 3-10] 참고

CS_Overlap(ShapeA,ShapeB)
: 두 도형을 겹침 (A+B)
ShapeA : 대상 도형 데이터
ShapeB : 겹칠 도형 데이터
Ex) [예제 3-10] 참고

CS_Merge(ShapeA,ShapeB,Size,Priority)
: 두 도형을 합침 (A∪B) - 중복된 영역은 제거됨
ShapeA : 대상 도형 데이터
ShapeB : 합칠 도형 데이터
Size : 점의 크기 (중복 영역 판정크기와 동일)
Priority : 중복 제거 우선순위 선택 - (0입력시 B를 지움, 1입력시 A를 지움)
Ex) [예제 3-10] 참고, [예제 3-5] 참고

CS_Intersect(ShapeA,ShapeB,Size,Priority)
: 두 도형의 겹친 영역만 남김 (A∩B) - 중복되지 않은 영역은 제거됨

ShapeA : 대상 도형 데이터
ShapeB : 겹칠 도형 데이터
Size : 점의 크기 (중복 영역 판정크기와 동일)
Priority : 중복영역 선택 우선순위 설정 - (0입력시 A를 선택, 1입력시 B를 선택)
Ex) [예제 3-10] 참고

443

------------------------------------------------------------------------------------------

『 3장 : CS_ 편집함수 (이미지 편집) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CS_ 함수는 Shape 및 Path 데이터를 편집할 수 있습니다 ｡+.ﾟ
｡˙+ﾟ도형 데이터 연산 함수 : Add/Overlap/Merge/Intersect/Subtract/Xor/RemoveStack ｡+.ﾟ

CS_Subtract(ShapeA,ShapeB,Size)
: 한 도형에서 겹친 영역을 지움 (A-B)
ShapeA : 대상 도형 데이터
ShapeB : 필터 도형 데이터
Size : 점의 크기 (중복 영역 판정크기와 동일)
Ex) [예제 3-10] 참고

CS_Xor(ShapeA,ShapeB,Size)
: 두 도형의 겹친 영역만을 제거하고 합침 (A∪B-A∩B)
ShapeA : 대상 도형 데이터
ShapeB : 합칠 도형 데이터
Size : 점의 크기 (중복 영역 판정크기와 동일)
Ex) [예제 3-10] 참고

CS_RemoveStack(Shape,Size,Priority)
: 도형 내부에서 겹친 점을 제거함
Shape : 대상 도형 데이터
Size : 점의 크기 (중복 영역 판정크기와 동일)
Priority : 중복제거 순서 우선순위 설정 - (0입력시 앞에서부터 제거, 1입력시 뒤에서부터 제거)
Ex) [예제 3-10] 참고, [예제 3-5] 참고

CS_OverlapX(…)
: 입력한 도형들을 모두 겹침 (∑(Shape))
… : 대상 도형 데이터 (다수 입력 가능)

Ex) [예제 3-10] 참고

444

------------------------------------------------------------------------------------------

『 3장 : CS_ 편집함수 (이미지 편집) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CS_ 함수는 Shape 및 Path 데이터를 편집할 수 있습니다 ｡+.ﾟ
｡˙+ﾟ 자르기 관련함수 : Crop[XY/RA/Path] ｡+.ﾟ
CS_CropXY(Shape,areaX,areaY,edgeX,edgeY)
: 도형을 직교좌표 내부영역으로 잘라냄 (잘라내고 남은 부분은 버려짐)
Shape : 대상 도형 데이터
areaX : 자를영역의 X좌표 범위 = {Xmin,Xmax}
areaY : 자를영역의 Y좌표 범위 = {Ymin,Ymax}
edgeX : X좌표의 경계선을 자를영역에 포함할지를 선택 = {Xmin여부,Xmax여부}
edgeY : Y좌표의 경계선을 자를영역에 포함할지를 선택 = {Ymin여부,Ymax여부}
0 입력시 포함함, 1 입력시 미포함 - 비우면 0으로 설정함
※ (X,Y) ∈ ([Xmin,Xmax],[Ymin,Ymax])인 직사각형 영역이 자를영역임
Ex) [예제 3-11] 참고

CS_CropRA(Shape,areaR,areaA,edgeR,edgeA)
: 도형을 극좌표 내부영역으로 잘라냄 (잘라내고 남은 부분은 버려짐)
Shape : 대상 도형 데이터
areaR : 자를영역의 R좌표 범위 = {Rmin,Rmax}
areaA : 자를영역의 Θ좌표 범위 = {Θmin,Θmax}
edgeR : R좌표의 경계선을 자를영역에 포함할지를 선택 = {Rmin여부,Rmax여부}
edgeA : Θ좌표의 경계선을 자를영역에 포함할지를 선택 = {Θmin여부,Θmax여부}
0 입력시 포함함, 1 입력시 미포함 - 비우면 0으로 설정함
※ (R,Θ) ∈ ([Rmin,Rmax],[Θmin,Θmax])인 잘린 부채꼴 영역이 검사영역임
Ex) [예제 3-11] 참고

CS_CropPath(Shape,Path,Outside)
: 도형을 Path영역으로 잘라냄 (잘라내고 남은 부분은 버려짐)
Shape : 대상 도형 데이터
Path : 자를영역을 설정할 Path데이터
Outside : 0입력시 내부영역을, 1입력시 외부영역을 잘라냄 - 비우면 0으로 입력
Ex) [예제 3-11] 참고

445

------------------------------------------------------------------------------------------

『 3장 : CS_ 편집함수 (이미지 편집) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CS_ 함수는 Shape 및 Path 데이터를 편집할 수 있습니다 ｡+.ﾟ
｡˙+ﾟ [고급] 음함수 그래프 자르기 함수 : CropGraph[XY/RA] ｡+.ﾟ
CS_CropGraphXY(Shape,Ratio,funcXY,Sign,Edge)
: 2차원 직교좌표계 음함수를 기준으로 구분되는 영역으로 잘라냄
Shape : 대상 도형 데이터
Ratio : 좌표의 축소비율 설정 = {X배율(축소),Y배율(축소)} - 비우면 1(1배)로 설정됨
funcXY : 자를영역을 구분할 음함수의 이름 (String으로 입력)
Sign : 자를영역의 음함수의 부호 설정 (0입력시 >, 1입력시 <)
Edge : 경계선을 자를영역에 포함할지를 선택 (0입력시 포함, 1입력시 미포함)
Ex) [예제 3-12] 참고
※ 사용자 정의 벡터 음함수 제작 및 입력방법
function S1_funcXY(X,Y) return X^2+Y^2-16 end → "S1_funcXY" (f(x,y)=0)

CS_CropGraphRA(Shape,Ratio,funcRA,Sign,Edge)
: 2차원 극좌표계 음함수를 기준으로 구분되는 영역으로 잘라냄
Shape : 대상 도형 데이터
Ratio : 좌표의 축소비율 설정 = {R배율(축소),Θ배율(축소)} - 비우면 1(1배)로 설정됨
funcRA : 자를영역을 구분할 음함수의 이름 (String으로 입력)
Sign : 자를영역의 음함수의 부호 설정 (0입력시 >, 1입력시 <)
Edge : 경계선을 자를영역에 포함할지를 선택 (0입력시 포함, 1입력시 미포함)
Ex) [예제 3-12] 참고
※ 사용자 정의 벡터 음함수 제작 및 입력방법
function S1_funcXY(R,A) return R^2+A^2-16 end → "S1_funcRA" (f(r,Θ)=0)

446

------------------------------------------------------------------------------------------

『 3장 : CS_ 편집함수 (이미지 편집) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CS_ 함수는 Shape 및 Path 데이터를 편집할 수 있습니다 ｡+.ﾟ
｡˙+ﾟ 채우기 관련함수 : Fill(Path)[XY/RA/HX/RD] ｡+.ﾟ
CS_FillXY(Edge,areaX,areaY,sizeX,sizeY)
: 직교좌표 내부영역을 직각 격자모양으로 칠함
Edge : 내부영역의 테두리까지 칠할지를 선택 (0입력시 안칠함,1입력시 칠함) - 비우면 1로 입력됨
areaX : 칠할영역의 X좌표 범위 = {Xmin,Xmax} / areaY : 칠할영역의 Y좌표 범위 = {Ymin,Ymax}
sizeX : 칠할 점의 X좌표 간격 / sizeY : 칠할 점의 Y좌표 간격
※ (X,Y) ∈ ([Xmin,Xmax],[Ymin,Ymax])인 직사각형 영역이 칠할영역임
Ex) [예제 3-13] 참고

CS_FillRA(Edge,areaR,areaA,sizeR,sizeA)
: 극좌표 내부영역을 방사형 모양으로 칠함 (원점이 중심)

Edge : 내부영역의 테두리까지 칠할지를 선택 (0입력시 안칠함,1입력시 칠함) - 비우면 1로 입력됨
areaR : 칠할영역의 R좌표 범위 = {Rmin,Rmax} / areaA : 칠할영역의 Θ좌표 범위 = {Θmin,Θmax}
sizeR : 칠할 점의 R좌표 간격 / sizeA : 칠할 점의 Θ좌표 간격
※ (R,Θ) ∈ ([Rmin,Rmax],[Θmin,Θmax])인 잘린 부채꼴 영역이 칠할영역임
Ex) [예제 3-13] 참고

CS_FillHX(Edge,areaX,areaY,sizeX,sizeY,Direction)
: 직교좌표 내부영역을 육각 격자모양으로 칠함
Edge : 내부영역의 테두리까지 칠할지를 선택 (0입력시 안칠함,1입력시 칠함) - 비우면 1로 입력됨
areaX : 칠할영역의 X좌표 범위 = {Xmin,Xmax} / areaY : 칠할영역의 Y좌표 범위 = {Ymin,Ymax}
sizeX : 칠할 점의 X좌표 간격 / sizeY : 칠할 점의 Y좌표 간격
Direction : 육각 격자를 쌓는 방향 (0 :↓121, 1:↓212, 2:→121, 3:→212) - 비우면 0으로 입력됨
※ (X,Y) ∈ ([Xmin,Xmax],[Ymin,Ymax])인 직사각형 영역이 칠할영역임
Ex) [예제 3-13] 참고

CS_FillRD(Edge,areaX,areaY,sizeX,sizeY,StackSizeX,StackSizeY)
: 직교좌표 내부영역을 무작위로 칠함 (컴파일 할때마다 바뀜)

Edge : 내부영역의 테두리까지 칠할지를 선택 (0입력시 안칠함,1입력시 칠함) - 비우면 1로 입력됨
areaX : 칠할영역의 X좌표 범위 = {Xmin,Xmax} / areaY : 칠할영역의 Y좌표 범위 = {Ymin,Ymax}
sizeX : 칠할 점의 X좌표 간격 / sizeY : 칠할 점의 Y좌표 간격
StackSizeX : 칠할 점의 중복 방지 X좌표 간격
StackSizeY : 칠할 점의 중복 방지 Y좌표 간격
※ StackSize 옵션은 제대로 동작하지 않을 수도 있음
※ (X,Y) ∈ ([Xmin,Xmax],[Ymin,Ymax])인 직사각형 영역이 칠할영역임
Ex) [예제 3-13] 참고

447

------------------------------------------------------------------------------------------

『 3장 : CS_ 편집함수 (이미지 편집) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CS_ 함수는 Shape 및 Path 데이터를 편집할 수 있습니다 ｡+.ﾟ

｡˙+ﾟ 채우기 관련함수 : Fill(Path)[XY/RA/HX/RD] ｡+.ﾟ
CS_FillPathXY(Path,Edge,sizeX,sizeY,Outside)
: Path영역을 직각 격자모양으로 칠함
Path : 칠할영역을 설정할 Path데이터
Edge : 내부영역의 테두리까지 칠할지를 선택 (0입력시 안칠함,1입력시 칠함) - 비우면 1로 입력됨
sizeX : 칠할 점의 X좌표 간격 / sizeY : 칠할 점의 Y좌표 간격
Outside : 0입력시 Path영역의 내부를, 1입력시 외부를 칠함 - 비우면 0으로 입력
Ex) [예제 3-14] 참고

CS_FillPathRA(Path,Edge,sizeR,sizeA,Outside)
: Path영역을 방사형 모양으로 칠함
Path : 칠할영역을 설정할 Path데이터
Edge : 내부영역의 테두리까지 칠할지를 선택 (0입력시 안칠함,1입력시 칠함) - 비우면 1로 입력됨
sizeR : 칠할 점의 R좌표 간격 / sizeA : 칠할 점의 Θ좌표 간격
Outside : 0입력시 Path영역의 내부를, 1입력시 외부를 칠함 - 비우면 0으로 입력
Ex) [예제 3-14] 참고

CS_FillPathHX(Path,Edge,sizeX,sizeY,Direction,Outside)
: Path영역을 육각 격자모양으로 칠함
Path : 칠할영역을 설정할 Path데이터
Edge : 내부영역의 테두리까지 칠할지를 선택 (0입력시 안칠함,1입력시 칠함) - 비우면 1로 입력됨
sizeX : 칠할 점의 X좌표 간격 / sizeY : 칠할 점의 Y좌표 간격
Outside : 0입력시 Path영역의 내부를, 1입력시 외부를 칠함 - 비우면 0으로 입력
Direction : 육각 격자를 쌓는 방향 (0 :↓121, 1:↓212, 2:→121, 3:→212) - 비우면 0으로 입력됨
Ex) [예제 3-14] 참고

CS_FillPathRD(Path,Edge,sizeX,sizeY,StackSizeX,StackSizeY,Outside)
: Path영역을 무작위로 칠함 (컴파일 할때마다 바뀜)
Path : 칠할영역을 설정할 Path데이터
Edge : 내부영역의 테두리까지 칠할지를 선택 (0입력시 안칠함,1입력시 칠함) - 비우면 1로 입력됨
sizeX : 칠할 점의 X좌표 간격 / sizeY : 칠할 점의 Y좌표 간격
Outside : 0입력시 Path영역의 내부를, 1입력시 외부를 칠함 - 비우면 0으로 입력
StackSizeX : 칠할 점의 중복 방지 X좌표 간격 / StackSizeY : 칠할 점의 중복 방지 Y좌표 간격

※ StackSize 옵션은 제대로 동작하지 않을 수도 있음
Ex) [예제 3-14] 참고

448

------------------------------------------------------------------------------------------

『 3장 : CS_ 편집함수 (이미지 편집) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CS_ 함수는 Shape 및 Path 데이터를 편집할 수 있습니다 ｡+.ﾟ
｡˙+ﾟ 영역내 존재여부 검사함수 : Check[XY/RA/Stack/Collide/Path] ｡+.ﾟ
CS_CheckXY(Shape,areaX,areaY,edgeX,edgeY)
: 직교좌표 검사영역 외부에 점이 있는지를 검사함
Shape : 대상 도형 데이터
areaX : 검사영역의 X좌표 범위 = {Xmin,Xmax} / areaY : 검사영역의 Y좌표 범위 = {Ymin,Ymax}
edgeX : X좌표의 경계선을 검사영역에 포함할지를 선택 = {Xmin여부,Xmax여부}
edgeY : Y좌표의 경계선을 검사영역에 포함할지를 선택 = {Ymin여부,Ymax여부}
0 입력시 포함함, 1 입력시 미포함 - 비우면 0으로 설정함
※ (X,Y) ∈ ([Xmin,Xmax],[Ymin,Ymax])인 직사각형 영역이 검사영역임

CS_CheckRA(Shape,areaR,areaA,edgeR,edgeA)
: 극좌표 검사영역 외부에 점이 있는지를 검사함
Shape : 대상 도형 데이터
areaR : 검사영역의 R좌표 범위 = {Rmin,Rmax} / areaA : 검사영역의 Θ좌표 범위 = {Θmin,Θmax}
edgeR : R좌표의 경계선을 검사영역에 포함할지를 선택 = {Rmin여부,Rmax여부}
edgeA : Θ좌표의 경계선을 검사영역에 포함할지를 선택 = {Θmin여부,Θmax여부}
0 입력시 포함함, 1 입력시 미포함 - 비우면 0으로 설정함
※ (R,Θ) ∈ ([Rmin,Rmax],[Θmin,Θmax])인 잘린 부채꼴 영역이 검사영역임

CS_CheckStack(Shape,Size,Priority)
: 도형 내부에 겹친 점이 있는지를 검사함
Shape : 대상 도형 데이터
Size : 점의 크기 (중복 영역 판정크기와 동일)
Priority : 중복판정 순서 우선순위 설정 - (0입력시 앞에서부터, 1입력시 뒤에서부터)

CS_CheckCollide(ShapeA,ShapeB,Size,Priority)
: 두 도형에 겹친 영역이 있는지를 검사함
ShapeA : 대상 도형 데이터 / ShapeB : 대상 도형 데이터
Size : 점의 크기 (중복 영역 판정크기와 동일)

Priority : 중복판정 우선순위 설정 - (0입력시 A부터, 1입력시 B부터)

CS_CheckPath(Shape,Path,Outside)
: Path영역 외부에 점이 있는지를 검사함
Shape : 대상 도형 데이터
Path : 검사영역을 설정할 Path데이터
Outside : 0입력시 내부를, 1입력시 외부에 점이 있는지 검사함 - 비우면 0으로 입력
※ Check함수는 검사시 해당 조건에 맞는 점이 발견되면 컴파일 오류 메세지로 정보를 전달함

449

------------------------------------------------------------------------------------------

『 3장 : CS_ 편집함수 (이미지 편집) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CS_ 함수는 Shape 및 Path 데이터를 편집할 수 있습니다 ｡+.ﾟ

｡˙+ﾟ OrderShape 관련 함수 : Reverse/Suffle/Convert ｡+.ﾟ
CS_Reverse(Shape)
: 도형 데이터 내부 점들의 나열순서를 역순으로 바꿈
Shape : 대상 도형 데이터
Ex) [예제 4-3] 참고

CS_Shuffle(Shape)
: 도형 데이터 내부 점들의 나열순서를 랜덤으로 바꿈 (컴파일할때마다 바뀜)
Shape : 대상 도형 데이터
Ex) [예제 4-3] 참고

CS_Convert(Shape,Number)
: 도형 데이터 내부 점들의 갯수를 Number개로 맞춤
Shape : 대상 도형 데이터
Number : 변환할 점의 갯수
(Number<N일 경우 일부 점이 손실됨,Number>N일 경우 일부 점이 중복 복사됨)
※ 변환 후 도형 데이터 내부순서는 랜덤으로 설정됨 (컴파일할때마다 바뀜)
Ex) [예제 4-3] 참고

｡˙+ﾟ 도형 크기 정보 관련 함수 : Get[X/Y][min/max] ｡+.ﾟ
CS_GetXmax(Shape)
CS_GetXmin(Shape)
CS_GetYmax(Shape)
CS_GetYmin(Shape)
: 도형 데이터 내부 점들의 최소 또는 최대 X,Y좌표값을 구함

Shape : 대상 도형 데이터
Xmax함수 : X좌표 최대값
Xmin함수 : X좌표 최소값
Ymax함수 : Y좌표 최대값
Ymin함수 : Y좌표 최소값
Ex) [예제 3-13] 참고
450

------------------------------------------------------------------------------------------

『 4장 : CSPlot 함수 (트리거 변환) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CSPlot 함수는 도형데이터를 유닛 생산 트리거로 변환할 수 있습니다 ｡+.ﾟ
CSPlot(Shape,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize,PlayerID,Condition,Action,Preserve)
CSPlotWithProperties(Shape,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize,
PlayerID,Condition,Action,Preserve,Properties)
: Shape 데이터를 유닛 생성 트리거로 변환하는 함수
Shape : 변환할 도형 데이터
Owner : 유닛의 소유플레이어
UnitId : 생성할 유닛의 종류 (유닛이름 String)
Location : 사용할 로케이션 ID (로케이션이름 String)
CenterXY : 유닛을 생성할 중심좌표 = {X좌표,Y좌표} - 비우면 로케이션의 현재 위치를 중심으로 설정함
PerUnit : 한 점당 생성할 유닛 수
PlotSize : 생성시 로케이션의 크기
PlayerID : 트리거 플레이어
Condition : 트리거의 조건
Action : 생성후 실행할 액션

Preserve : 트리거에 Preserve 옵션을 넣을지의 여부 (0입력시 반복X, 1입력시 반복O) - 비우면 0입력
(WithProperties함수) : Properties 속성을 입력함 - CreateUnitWithProperties와 동일 / Ex) [예제 4-1] 참고

CSPlotAct(Shape,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize,SizeofLoc,PerAction,
PlayerID,Condition,Action,Preserve)
CSPlotActWithProperties(Shape,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize,SizeofLoc,PerAction,
PlayerID,Condition,Action,Preserve,Properties)
: Shape 데이터를 유닛 생성 트리거로 변환하는 함수 + 유닛 생성시마다 PerAction을 실행함
Shape : 변환할 도형 데이터
Owner : 유닛의 소유플레이어
UnitId : 생성할 유닛의 종류 (유닛이름 String)
Location : 사용할 로케이션 ID (로케이션이름 String)
CenterXY : 유닛을 생성할 중심좌표 = {X좌표,Y좌표} - 비우면 로케이션의 현재 위치를 중심으로 설정함
PerUnit : 한 점당 생성할 유닛 수
PlotSize : 생성시 로케이션의 크기
SizeofLoc : PerAction 실행시 로케이션의 크기
PerAction : 유닛 생성시마다 실행할 액션

PlayerID : 트리거 플레이어
Condition : 트리거의 조건
Action : 생성후 실행할 액션
Preserve : 트리거에 Preserve 옵션을 넣을지의 여부 (0입력시 반복X, 1입력시 반복O) - 비우면 0으로 입력
(WithProperties함수) : Properties 속성을 입력함 - CreateUnitWithProperties와 동일 / Ex) [예제 4-2]451
참고

------------------------------------------------------------------------------------------

『 4장 : CSPlot 함수 (트리거 변환) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CSPlot 함수는 도형데이터를 유닛 생산 트리거로 변환할 수 있습니다 ｡+.ﾟ
CSPlotOrder(Shape,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize,
OrderShape,Direction,OrderType,OrderLocation,DestXY,SizeofLoc,PerAction,
PlayerID,Condition,Action,Preserve)
CSPlotOrderWithProperties(Shape,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize,
OrderShape,Direction,OrderType,OrderLocation,DestXY,SizeofLoc,PerAction,

PlayerID,Condition,Action,Preserve,Properties)
: Shape 데이터를 유닛 생성 트리거로 변환하는 함수 + 각 유닛마다 OrderShape으로 Order명령을 내림
Shape : 변환할 도형 데이터
Owner : 유닛의 소유플레이어
UnitId : 생성할 유닛의 종류 (유닛이름 String)
Location : 사용할 로케이션 ID (로케이션이름 String)
CenterXY : 유닛을 생성할 중심좌표 = {X좌표,Y좌표} - 비우면 로케이션의 현재 위치를 중심으로 설정함
PerUnit : 한 점당 생성할 유닛 수
PlotSize : 생성시 로케이션의 크기

OrderShape : 목적지로 설정할 도형 데이터
Direction : 0입력시 순서대로, 1입력시 역순으로 도착지를 설정함
OrderType : 명령의 종류 = Attack, Patrol, Move
OrderLocation : Order명령에 사용할 로케이션 (로케이션이름 String)
DestXY : 도착지의 중심좌표 = {X좌표,Y좌표} - 비우면 OrderLocation의 현재위치를 중심으로 설정함
SizeofLoc : PerAction 실행시 로케이션의 크기
PerAction : 유닛 생성시마다 실행할 액션
PlayerID : 트리거 플레이어
Condition : 트리거의 조건
Action : 생성후 실행할 액션
Preserve : 트리거에 Preserve 옵션을 넣을지의 여부 (0입력시 반복X, 1입력시 반복O) - 비우면 0으로 입력
(WithProperties함수) : Properties 속성을 입력함 - CreateUnitWithProperties와 동일
Ex) [예제 4-3] 참고

452

------------------------------------------------------------------------------------------

『 5장 : CSSave 함수 (파일 입출력) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CSSave 함수는 도형데이터를 .txt 파일로 저장 및 불러오기 할 수 있습니다 ｡+.ﾟ
CSSave(FileName,Local,...)
CSSaveWithName(FileName,Local,...)
: Shape 데이터를 .txt 파일로 저장하는 함수 (저장된 .txt 파일은 AbsolutePath안의 CS폴더에 있습니다.)
FileName : 저장할 .txt 파일의 이름
Local : 0입력시 전역변수로, 1입력시 로컬변수로 저장됨

(Save함수)... (가변인자) : 저장할 Shape 데이터
(저장된 도형 데이터는 순서대로 Shape1, Shape2, ... 로 이름이 설정됨)
(SaveWithName함수)... (가변인자) : 저장할 Shape 데이터와 이름 = Shape1,"도형1", 형태로 입력
(홀수번째 : 도형데이터, 짝수번째 : 저장시 붙일 이름)
(저장된 도형 데이터의 이름은 설정한 문자열로 설정됨)
Ex) [예제 5-1] 참고, [예제 5-2] 참고

※ CSSave 함수로 저장된 .txt 파일의 Shape 데이터는 (local) ShapeN = {점의 갯수,{X1,Y1},{X2,Y2},...}
형태로 저장되어있으며, Tep에 그대로 복사해서 붙여넣어 바로 사용 가능합니다.

CSLoad(...)
: CS폴더에 저장한 Shape 데이터 파일들을 합쳐서 Scmdraft 플러그인에 로드하는 함수
... (가변인자) : CS폴더에서 로드할 파일의 이름 (파일 String 입력)

※ CSLoad 함수로 로드된 .txt 파일의 Shape 데이터는 .lua 플러그인의 형태로 로드되며,
1회 CSLoad 후에 해당 도형 데이터를 사용할 수 있습니다.
Ex) [예제 5-2] 참고

453

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ Path 도형 선분 채우기 함수 : ConnectPath(X) ｡+.ﾟ
CS_ConnectPath(Path,PerNumber,EndLine,Index)
CS_ConnectPathX(Path,PerSize,EndLine,Index)
: 이웃한 점 사이에 설정한 값 만큼 내분점을 추가함
Path : 대상 도형 데이터
(일반함수)PerNumber : 선분 사이에 추가할 내분점의 수

(X함수)PerSize : 선분 사이 내분점들의 간격의 크기
EndLine : (마지막점 - 첫번째점)의 선분 사이를 연결할 지를 선택 (1입력시 연결함)
Index : 내분점을 추가할 Shape내부의 점들의 배열 = {{1,2},{3,4}, ...},
(비우면 {1,2},{2,3},{3,4},….{n,n-1}}로 설정됨) - 도형의 모든 변으로 설정
Ex) [예제 6-1] 참고

｡˙+ﾟ 도형 데이터관련 편의함수 : Get[R,A][max,min] ｡+.ﾟ
CS_GetRmax(Shape)
CS_GetRmin(Shape)
CS_GetAmax(Shape)
CS_GetAmin(Shape)
: 도형 데이터 내부 점들의 최소 또는 최대 R,A좌표값을 구함
Shape : 대상 도형 데이터
Rmax함수 : R좌표 최대값
Rmin함수 : R좌표 최소값
Amax함수 : A좌표 최대값
Amin함수 : A좌표 최소값

｡˙+ﾟ [고급] 도형 함수식 최대 최소값 연산 함수 : Get[XY,RA][max,min] ｡+.ﾟ

CS_GetXYmin(Shape,Ratio,func)
CS_GetXYmax(Shape,Ratio,func)
CS_GetRAmin(Shape,Ratio,func)
CS_GetRAmax(Shape,Ratio,func)
: 도형 데이터 내부 점들의 사용자 정의 함수식 연산 결과의 최소 또는 최대값을 구함
Shape : 대상 도형 데이터
Ratio : 좌표의 축소비율 설정 = {X,R배율(축소),Y,Θ배율(축소)} - 비우면 1(1배)로 설정됨
(XY함수)func : 사용자 정의 직교좌표 함수 (String으로 입력)
(RA함수)func : 사용자 정의 극좌표 함수 (String으로 입력)
454

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ 도형 데이터 정렬함수 : Sort[X,Y,R,A,RA] ｡+.ﾟ
CS_SortX(Shape,Direction)
CS_SortY(Shape,Direction)
CS_SortR(Shape,Direction)
CS_SortA(Shape,Direction)
CS_DoubleSortRA(Shape,Thickness,RDirection,ADirection) - 2중 정렬 함수 (1차:R → 2차:Θ)
: 도형 데이터 내부 점들을 크기 순서대로 정렬함
Shape : 대상 도형 데이터
Direction : 0입력시 오름차순, 1입력시 내림차순
(RA함수)Thickness : 반지름 껍질의 두께 (ΔR≥0)
(RA함수)RDirection : (R축 방향 정렬) 0입력시 오름차순, 1입력시 내림차순

(RA함수)ADirection : (Θ축 방향 정렬) 0입력시 오름차순, 1입력시 내림차순
Ex) [예제 6-2] 참고

｡˙+ﾟ [고급] 도형 사용자 정의 정렬 함수 (나타내기 효과) : (Double)SortGraph([XY,RA]) ｡+.ﾟ
CS_SortGraphXY(Shape,Ratio,funcXY,Direction)
CS_SortGraphRA(Shape,Ratio,funcRA,Direction)
: 도형 데이터 내부 점들을 사용자 정의 함수식으로 정렬함
Shape : 대상 도형 데이터
Ratio : 좌표의 축소비율 설정 = {X(R)배율(축소),Y(Θ)배율(축소)} - 비우면 1(1배)로 설정됨
(XY함수)funcXY : 정렬순서를 결정할 음함수의 이름 (String으로 입력)
(RA함수)funcRA : 정렬순서를 결정할 음함수의 이름 (String으로 입력)
Direction : 0입력시 오름차순, 1입력시 내림차순
Ex) [예제 6-4] 참고

CS_DoubleSortGraph(Shape,funcA,funcB,Thickness,PartShuffle,ADirection,BDirection)
: 도형 데이터 내부 점들을 사용자 정의 함수식으로 이중정렬함
Shape : 대상 도형 데이터
funcA : = {Mode,"funcA",Ratio} : (Mode : 0입력시 직교좌표, 1입력시 극좌표, 2입력시 랜덤함수로 입력
"funcA" : 1차 정렬순서를 결정할 음함수의 이름 (String으로 입력)
Ratio : 좌표의 축소비율 설정 = {X(R)배율(축소),Y(Θ)배율(축소)} - 비우면 1(1배)로 설정됨)
funcB : = {Mode,"funcB",Ratio} : (Mode : 0입력시 직교좌표, 1입력시 극좌표, 2입력시 랜덤함수로 입력
"funcB" : 2차 정렬순서를 결정할 음함수의 이름 (String으로 입력)
Ratio : 좌표의 축소비율 설정 = {X(R)배율(축소),Y(Θ)배율(축소)} - 비우면 1(1배)로 설정됨)
PartShuffle : 1차 정렬의 결과를 랜덤으로 섞음 (실선무늬 효과)
Thickness : 2차 정렬 함수영역 껍질의 두께 (ΔT≥0)
ADirection : (1차정렬 방향 정렬) 0입력시 오름차순, 1입력시 내림차순
BDirection : (2차정렬 방향 정렬) 0입력시 오름차순, 1입력시 내림차순 / Ex) [예제 6-3] 참고

455

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

-----------------------------------------------------------------------------------------CS_FillPathXY2(Path,Edge,sizeX,sizeY,Outside,Angle,Digit)
: Path영역을 직각 격자모양으로 칠함

Path : 칠할영역을 설정할 Path데이터
Edge : 내부영역의 테두리까지 칠할지를 선택 (0입력시 안칠함,1입력시 칠함) - 비우면 1로 입력됨
sizeX : 칠할 점의 X좌표 간격
sizeY : 칠할 점의 Y좌표 간격
Outside : 0입력시 Path영역의 내부를, 1입력시 외부를 칠함 - 비우면 0으로 입력
Angle : 내부 격자 모양을 회전시킬 각도
Digit : 반올림할 소숫점 자리수

CS_FillPathRA2(Path,Edge,sizeR,sizeA,Rmin,Outside,dX,dY)
: Path영역을 방사형 모양으로 칠함
Path : 칠할영역을 설정할 Path데이터
Edge : 내부영역의 테두리까지 칠할지를 선택 (0입력시 안칠함,1입력시 칠함) - 비우면 1로 입력됨
sizeR : 칠할 점의 R좌표 간격
sizeA : 칠할 점의 Θ좌표 간격
Outside : 0입력시 Path영역의 내부를, 1입력시 외부를 칠함 - 비우면 0으로 입력
dX : 내부 방사형 모양을 평행이동시킬 X좌표
dY : 내부 방사형 모양을 평행이동시킬 Y좌표

CS_FillPathHX2(Path,Edge,sizeX,sizeY,Direction,Outside,Angle,Digit)
: Path영역을 육각 격자모양으로 칠함
Path : 칠할영역을 설정할 Path데이터
Edge : 내부영역의 테두리까지 칠할지를 선택 (0입력시 안칠함,1입력시 칠함) - 비우면 1로 입력됨
sizeX : 칠할 점의 X좌표 간격
sizeY : 칠할 점의 Y좌표 간격
Outside : 0입력시 Path영역의 내부를, 1입력시 외부를 칠함 - 비우면 0으로 입력
Direction : 육각 격자를 쌓는 방향 (0 :↓121, 1:↓212, 2:→121, 3:→212) - 비우면 0으로 입력됨
Angle : 내부 격자 모양을 회전시킬 각도
Digit : 반올림할 소숫점 자리수

456

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

-----------------------------------------------------------------------------------------CS_FillGradX(Edge,areaX,areaY,sizeX,funcGX,EdgeY)
: 직교좌표 내부영역을 X축 그라데이션으로 칠함

Edge : 내부영역의 테두리까지 칠할지를 선택
(0입력시 안칠함,1입력시 칠함) - 비우면 1로 입력됨
areaX : 칠할영역의 X좌표 범위 = {Xmin,Xmax}
areaY : 칠할영역의 Y좌표 범위 = {Ymin,Ymax}
sizeX : 칠할 점의 X좌표 간격
funcGX : Y축으로 찍을 점의 갯수 (funcGX(Step) = 찍을점의 갯수) - Step은 1부터 1씩 증가함
EdgeY : 0 : 위 아래 테두리 채우지않음
/ 1 : 위 테두리 채움 / 2 : 아래 테두리 채움 / 3 : 위 아래 테두리 채움

※ (X,Y) ∈ ([Xmin,Xmax],[Ymin,Ymax])인 직사각형 영역이 칠할영역임

CS_FillGradY(Edge,areaX,areaY,sizeY,funcGY,EdgeX)
: 직교좌표 내부영역을 Y축 그라데이션으로 칠함

CS_FillGradR(Edge,areaR,areaA,sizeR,funcGR,EdgeA)
: 극좌표 내부영역을 R축 그라데이션으로 칠함

CS_FillGradA(Edge,areaR,areaA,sizeA,funcGA,EdgeR)
: 극좌표 내부영역을 A축 그라데이션으로 칠함

CS_FillGradXD(Edge,areaX,areaY,sizeX,funcGX,EdgeY)
: 직교좌표 내부영역을 X축 랜덤 그라데이션으로 칠함

457

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

-----------------------------------------------------------------------------------------CS_FillPathGradX(Path,Edge,sizeX,funcGX,EdgeY,Outside,Angle,Digit)
: Path영역을 X축 그라데이션으로 칠함

Path : 칠할영역을 설정할 Path데이터
Edge : 내부영역의 테두리까지 칠할지를 선택
(0입력시 안칠함,1입력시 칠함) - 비우면 1로 입력됨
sizeX : 칠할 점의 X좌표 간격
funcGX : Y축으로 찍을 점의 갯수 (funcGX(Step) = 찍을점의 갯수) - Step은 1부터 1씩 증가함
EdgeY : 0 : 위 아래 테두리 채우지않음
/ 1 : 위 테두리 채움 / 2 : 아래 테두리 채움 / 3 : 위 아래 테두리 채움
Outside : 0입력시 Path영역의 내부를, 1입력시 외부를 칠함 - 비우면 0으로 입력

Angle : 내부 격자 모양을 회전시킬 각도
Digit : 반올림할 소숫점 자리수

CS_FillPathGradY(Path,Edge,sizeY,funcGY,EdgeX,Outside,Angle,Digit)
: Path영역을 Y축 그라데이션으로 칠함

CS_FillPathGradR(Path,Edge,sizeR,funcGR,EdgeA,Rmin,Outside,dX,dY)
: Path영역을 R축 그라데이션으로 칠함

CS_FillPathGradA(Path,Edge,sizeA,funcGA,EdgeR,Rmin,Outside,dX,dY)
: Path영역을 A축 그라데이션으로 칠함

CS_FillPathGradXD(Path,Edge,sizeX,funcGX,EdgeY,Outside,Angle,Digit)
: Path영역을 X축 랜덤 그라데이션으로 칠함

458

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

-----------------------------------------------------------------------------------------CS_GetXCntr(Shape)
CS_GetYCntr(Shape)
CS_GetRCntr(Shape,Zero)
: 도형 데이터의 중심 좌표값을 구함
Shape : 대상 도형 데이터
XCntr함수 : 중심 X좌표
YCntr함수 : 중심 Y좌표
RCntr함수 : 중심 R좌표 (Zero : 1 입력시 R최솟값을 0으로 설정함)

CSPlotX(Shape,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize,PlayerID,Condition,Action,Preserve)
CSPlotXWithProperties(Shape,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize,
PlayerID,Condition,Action,Preserve,Properties)

: CSPlot(WithProperties)과 동일하나, UnitId에 배열 입력시 순서대로 해당id의 유닛을 소환함

CS_Round(Shape,Digit)
: 도형 데이터 내부 점들의 좌표값의 소숫점을 반올림하는 함수

(CropPath류 함수에서 좌표값 정수로 보정시 사용)
Shape : 대상 도형 데이터
Digit : 반올림할 소숫점 자리수

459

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ 추가 CS 정렬함수 ｡+.ﾟ
CS_SortXY(Shape,funcXY,FStep,Direction)
: 도형 데이터를 직교좌표 함수값으로 정렬함

Shape : 정렬할 도형 데이터
funcXY : 정렬에 사용할 직교좌표 함수 (f(x,y) = {정렬식1, 정렬식2, …} 형식으로 입력)
Fstep : 정렬식 결과값의 범위 ({범위1, … , 범위N-1} 형식으로 입력, 정렬식을 1개만 사용시 미입력 가능)
범위에는 숫자 또는 함수식 입력가능 (함수식 입력시 항상 함수값≥0 이여야함)

Direction : 정렬의 방향 (0 = 오름차순 / 1 = 내림차순)
0또는 1 입력시 모든 정렬식의 방향을 각각 오름차순 또는 내림차순으로 설정함
{방향1, 방향2, …} 형식으로 입력시 순서대로 각각 정렬식1, 정렬식2, … 의 정렬 방향을 설정함
※ 단일식 정렬 (정렬식 1개만 사용시) : f(x,y) = k값을 기준으로 정렬함

※ 다중 정렬 (정렬식 2개이상 사용) : f(x,y) = k1, k2, … , kn 값을 기준으로 순서대로 정렬함
(정렬하는 순서 : k1값으로 점들을 정렬한 뒤 k1최솟값~k1+범위1까지를 같은 우선순위로 묶음
→ k1+범위1~k1+범위1*2까지를 같은 우선순위로 묶음 → …
→ k1+범위1*N~k1최댓값까지를 같은 우선순위로 묶음
(범위1이 함수(f(i)=s)일 경우 첫번째 묶음의 범위의 크기는 f(1)이 됨, n번째 묶음일때 크기는 f(n))
→ 같은 우선순위로 묶인 점들을 k2값으로 정렬한 뒤 k2최솟값~k2범위2까지를 같은 우선순위로 묶음
→ 묶음 내에서의 k2값의 최댓값까지 묶일때까지 반복
→ 범위N-1로 묶인 점들이 정렬식N으로 정렬될때까지 계속 진행함 → 정렬완료)
Ex) [예제 6-5] 참고

CS_SortRA(Shape,funcRA,FStep,Direction)
: 도형 데이터를 극좌표 함수값으로 정렬함
funcRA : 정렬에 사용할 극좌표 함수 (f(R,A) = {정렬식1, 정렬식2, …} 형식으로 입력)
나머지는 모두 CS_SortXY와 동일함
Ex) [예제 6-5] 참고

CS_SortI(Shape,funcI,FStep,Direction)
: 도형 데이터를 인덱스(점의 배치 순서) 함수값으로 정렬함
funcI : 정렬에 사용할 인덱스 함수 (f(I) = {정렬식1, 정렬식2, …} 형식으로 입력)
나머지는 모두 CS_SortXY와 동일함
※ 인덱스의 경우 1부터 시작함 (첫번째 점 = 1, 두번재 점 = 2, …., N번째 점 = N)
Ex) [예제 6-5] 참고

460

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ LoopMax 배열 데이터 구조｡+.ﾟ
LoopMax 데이터 : 한 틱에 소환할 유닛의 개수
LoopMax 데이터 구조 : {LoopMax 데이터의 총 개수(n),{LoopMax1},{LoopMax2}, ... ,{LoopMaxN}}
(n개의 LoopMax로 구성된 경우)
※ CS함수를 사용하지 않고 직접 LoopMax 데이터를 제작 및 수정해서 사용할 수 있다.
※ LoopMax 데이터는 Shape 데이터와 함께 CBPlot으로 TSort 기능을 사용할 수 있다.
※ TSort : 도형을 그릴때 각 틱에 해당하는 LoopMax의 수 만큼의 유닛을 생성하는 기능

CS_TInputVoid(Size)
: Size 크기만큼의 빈 공간(0)을 가진 LoopMax 데이터를 생성함
Size : 생성할 빈 공간의 크기
Ex) [예제 6-6] 참고

CS_TMakePath(LoopData,...)
: 숫자를 묶어 LoopMax 데이터로 만듬 (사용자 정의 루프값 배열 생성)
LoopData : LoopMax 데이터 배열 = {LoopMax1,LoopMax2, ... }
... (가변인자) : LoopMax 데이터 (LoopData에 자동으로 합쳐짐)
Ex) [예제 6-6] 참고

CS_TMakeAuto(Shape,LoopMax)
: 입력한 Shape 데이터에 연결할 LoopMax 데이터 배열을 생성함
Shape : 정렬할 도형 데이터
LoopMax : 미입력시 {1,Shape 총 점수} 생성함, 숫자(n) 입력시 LoopMax 배열을 n으로 채움,
{LoopMax1,LoopMax2, ... ,LoopMaxN} 형식으로 입력시 그대로 LoopMax 배열로 변환함
Ex) [예제 6-6] 참고

CSTSaveWithName(FileName,Local,...)
: Shape 데이터와 LoopMax 데이터를 .txt 파일로 저장하는 함수
FileName : 저장할 .txt 파일의 이름 (저장된 .txt 파일은 AbsolutePath안의 CS폴더에 있습니다.)
Local : 0입력시 전역변수로, 1입력시 로컬변수로 저장됨
… (가변인자) : 저장할 Shape, LoopMax 데이터와 이름 = Shape1,LoopMax1,"도형1", 형태로 입력
(3n-2번째 : 도형데이터, 3n-1번째 : LoopMax 데이터, 3n번째 : 저장시 붙일 이름)
※ CSTSave 함수로 저장된 .txt 파일의 Shape 데이터는 (local) ShapeN = {Shape, LoopMax}
형태로 저장되어있으며, Tep에 그대로 복사해서 붙여넣어 바로 사용 가능합니다.

461

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ TSort 생성 함수｡+.ﾟ
CS_NSortXY(Shape,Func,Step,funcXY,FStep,Direction)
: 도형 데이터를 직교좌표 함수값으로 정렬 후 Step개의 묶음으로 LoopMax 데이터를 생성함
Shape : 정렬할 도형 데이터
Func : LoopMax 데이터의 각 항목의 크기를 결정할 함수 (f(i) = s 형식으로 입력)
Step : LoopMax 데이터의 총 개수
funcXY : 정렬에 사용할 직교좌표 함수 (f(x,y) = {정렬식1, 정렬식2, …} 형식으로 입력)
Fstep : 정렬식 결과값의 범위 ({범위1, … , 범위N-1} 형식으로 입력, 정렬식을 1개만 사용시 미입력 가능)

범위에는 숫자 또는 함수식 입력가능 (함수식 입력시 항상 함수값≥0 이여야함)

Direction : 정렬의 방향 (0 = 오름차순 / 1 = 내림차순)
0또는 1 입력시 모든 정렬식의 방향을 각각 오름차순 또는 내림차순으로 설정함
{방향1, 방향2, …} 형식으로 입력시 순서대로 각각 정렬식1, 정렬식2, … 의 정렬 방향을 설정함
※ Func 미입력시 Shape[1]/Step개로 균등하게 LoopMax 데이터를 생성함
※ Func 입력시 LoopMax 데이터의 각 항목 크기는 Shape[1]/Step * f(i)/(f(1)+…+f(Step))으로 결정됨
※ Func의 함수값은 항상 0 이상 이여야 함

Ex) [예제 6-7] 참고

CS_NSortRA(Shape,Func,Step,funcRA,FStep,Direction)
: 도형 데이터를 극좌표 함수값으로 정렬 후 Step개의 묶음으로 LoopMax 데이터를 생성함
funcRA : 정렬에 사용할 극좌표 함수 (f(R,A) = {정렬식1, 정렬식2, …} 형식으로 입력)
나머지는 모두 CS_NSortXY와 동일함

Ex) [예제 6-7] 참고

CS_NSortI(Shape,Func,Step,funcI,FStep,Direction)
: 도형 데이터를 인덱스(점의 배치 순서) 함수값으로 정렬 후 LoopMax 데이터를 생성함
funcI : 정렬에 사용할 인덱스 함수 (f(I) = {정렬식1, 정렬식2, …} 형식으로 입력)
나머지는 모두 CS_NSortXY와 동일함
※ 인덱스의 경우 1부터 시작함 (첫번째 점 = 1, 두번재 점 = 2, …., N번째 점 = N)
Ex) [예제 6-7] 참고

462

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ TSort 생성 함수｡+.ﾟ
CS_TSortXY(Shape,Func,Step,Void,funcXY,FStep,Direction)
: 도형 데이터를 직교좌표 함수값으로 정렬함 (마지막 정렬식의 함수값으로 LoopMax 데이터를 생성함)

Shape : 정렬할 도형 데이터
Func : LoopMax 데이터의 각 항목의 크기를 결정할 함수 (f(i) = s 형식으로 입력, 각 묶음별로 i값 카운트됨)

Step : 마지막 정렬식의 함수값에서 LoopMax 데이터의 총 개수
Void : 1입력시 LoopMax 데이터 중 0을 포함함 (미입력 또는 0입력시 미포함)
funcXY : 정렬에 사용할 직교좌표 함수 (f(x,y) = {정렬식1, 정렬식2, …} 형식으로 입력)
Fstep : 정렬식 결과값의 범위 ({범위1, … , 범위N-1} 형식으로 입력, 정렬식을 1개만 사용시 미입력 가능)

범위에는 숫자 또는 함수식 입력가능 (함수식 입력시 항상 함수값≥0 이여야함)

Direction : 정렬의 방향 (0 = 오름차순 / 1 = 내림차순)
0또는 1 입력시 모든 정렬식의 방향을 각각 오름차순 또는 내림차순으로 설정함
{방향1, 방향2, …} 형식으로 입력시 순서대로 각각 정렬식1, 정렬식2, … 의 정렬 방향을 설정함

※ Func 미입력시 f-1((마지막 정렬식의 함수값의 범위)/Step)개로 LoopMax 데이터를 생성함
※ Func 입력시 LoopMax 데이터의 각 항목 크기는
f-1((마지막 정렬식의 함수값의 범위)/Step) * f(i)/(f(1)+…+f(Step))으로 결정됨
※ Func의 함수값은 항상 0 이상 이여야 함

Ex) [예제 6-8] 참고

CS_TSortRA(Shape,Func,Step,Void,funcRA,FStep,Direction)
: 도형 데이터를 극좌표 함수값으로 정렬함 (마지막 정렬식의 함수값으로 LoopMax 데이터를 생성함)

funcRA : 정렬에 사용할 극좌표 함수 (f(R,A) = {정렬식1, 정렬식2, …} 형식으로 입력)
나머지는 모두 CS_TSortXY와 동일함
Ex) [예제 6-8] 참고

CS_TSortI(Shape,Func,Step,Void,funcI,FStep,Direction)
: 도형 데이터를 인덱스(점의 배치 순서) 함수값으로 정렬함 (함수값으로 LoopMax 데이터를 생성함)

funcI : 정렬에 사용할 인덱스 함수 (f(I) = {정렬식1, 정렬식2, …} 형식으로 입력)
나머지는 모두 CS_TSortXY와 동일함

※ 인덱스의 경우 1부터 시작함 (첫번째 점 = 1, 두번재 점 = 2, …., N번째 점 = N)
Ex) [예제 6-8] 참고

463

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ TSort 생성 함수｡+.ﾟ
CS_Arrange(Shape,Preset,Looper,Overwrite)
: 도형 데이터를 인덱스를 기준으로 재정렬함 (A↔B)

Shape : 정렬할 도형 데이터
Preset : {교체할 횟수 n, 선택함수 f1(i), 교체함수 f2(i)} 형식으로 입력
(i = 1 ~ n까지 인덱스f1(i) 인 점과 인덱스f2(i) 인 점을 서로 순서를 바꿈)
Looper : 1입력시 f1(i) 또는 f2(i)의 함수값이 Shape의 범위(1~Shape[1])를 넘어갈때
해당 함수 값에 Mod(Shape[1])를 적용함 (0입력 또는 미입력시 적용X)
Overwrite : {선택함수 적용여부, 교체함수 적용여부} 형식으로 입력 (미입력시 적용X)
0 : 미적용 (중복 선택 및 교체를 허용함),
1 : 중복 선택 및 교체시 적용 대상을 한칸 뒤의 점으로 바꿈 (맨 뒤일 경우 맨 앞의 점으로 교체)
-1 : 중복 선택 및 교체시 적용 대상을 한칸 앞의 점으로 바꿈 (맨 앞일 경우 맨 뒤의 점으로 교체)
숫자 입력시 선택함수와 교체함수 모두 해당 숫자로 입력됨
※ Looper 미적용시 f1(i) 또는 f2(i)의 값이 Shape의 범위를 넘어갈 때는 순서를 교체하지 않음
※ Overwrite 적용시 중복이 발생하지 않는 점이 없을 경우 순서를 교체하지 않음 (교체 실행X)

Ex) [예제 6-9] 참고

CS_Split(Shape,Preset,Looper,Overwrite)
: 도형 데이터를 인덱스를 기준으로 분할함 (A→B)

Shape : 분할할 도형 데이터
Preset : {추출할 횟수 n, 선택함수 f(i)} 형식으로 입력

(I = 1 ~ n까지 인덱스f(i) 인 점을 추출해서 복사함)
Looper : 1입력시 f(i)의 함수값이 Shape의 범위(1~Shape[1])를 넘어갈때
해당 함수 값에 Mod(Shape[1])를 적용함 (0입력 또는 미입력시 적용X)
Overwrite : 숫자로 입력 (미입력시 적용X)
0 : 미적용 (중복 선택을 허용함)
1 : 중복 선택 적용 대상을 한칸 뒤의 점으로 바꿈 (맨 뒤일 경우 맨 앞의 점으로 교체)
-1 : 중복 선택 적용 대상을 한칸 앞의 점으로 바꿈 (맨 앞일 경우 맨 뒤의 점으로 교체)
※ Looper 미적용시 f(i)의 값이 Shape의 범위를 넘어갈 때는 순서를 교체하지 않음

※ Overwrite 적용시 중복이 발생하지 않는 점이 없을 경우 순서를 교체하지 않음 (교체 실행X)

Ex) [예제 6-9] 참고

464

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ TSort 생성 함수｡+.ﾟ
CS_Mix(Shape,Preset,Looper,Overwrite)
: 도형 데이터들을 인덱스 기준으로 합침 (A+B→C)

Shape : 복사할 도형 데이터 ({{도형1,복사함수 f1(i)},{도형2,복사함수 f2(i)}, … } 형식으로 입력
(도형1 ~ 도형n 각각 첫번째 점부터 마지막 점까지 복사 위치를 결정해서 복사함,
S1 → S2 → … → SN → S1 → S2 → … → SN → … 순으로 복사함, (복사 완료된 도형의 차례는 스킵함)

Preset : TSort 생성 관련 옵션 (미입력시 LoopMax 데이터를 생성하지 않음)
{A(0또는 1입력),B(숫자 또는 함수 입력)} 형식으로 입력
B : 숫자(n) 입력시 도형의 차례가 n번 진행되는 중에 복사된 점들을 LoopMax로 묶음
함수(f(i)=s) 입력시 i=1부터 시작하며, 도형의 차례가 함수값 만큼 진행되는 중에 복사된 점들을
LoopMax로 묶음 (LoopMax 묶음마다 i가 1씩 증가함)
A : 1입력시 복사 완료된 도형의 차례를 무시하지 않고 진행되었다고 카운트함 (0입력시 적용X)
Looper : 각 도형의 복사 차례에 복사 횟수를 설정함 ({도형1 복사횟수,도형2 복사횟수,…} 형식으로 입력

nil 입력시 첫번째 차례에 해당 도형의 점을 모두 복사함,
숫자 입력시 차례마다 입력한 수 만큼 점을 복사함
함수 입력시 (f(i)=s 형태로 입력) 차례마다 함수값 만큼 점을 복사함 (첫번째 차례에 i = 1부터 시작함)

Overwrite : 복사위치 중복 선택시 복사 위치를 한칸 뒤로 바꿈 (0입력 또는 미입력시 적용X)
※ Looper의 값이 0이하면 1로, 값이 해당 도형의 총 점 수를 넘어가면 Shape[1]로 설정함
※ 완성된 도형 데이터에 빈칸이 있을 경우 왼쪽으로 밀어서 빈칸을 자동으로 제거함

Ex) [예제 6-9] 참고

465

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ TSort 생성 함수｡+.ﾟ
CS_SortTM(Shape,funcT,FStep,Direction)
: LoopMax가 연결된 도형 데이터를 LoopMax 데이터의 Loop횟수에 따라 정렬함

Shape : 정렬할 도형 데이터 ({Shape,LoopMax}형식으로 입력)
funcT : 정렬에 사용할 Loop횟수 정렬식 함수 (f(T) = {정렬식1, 정렬식2, …} 형식으로 입력)
Fstep : 정렬식 결과값의 범위 ({범위1, … , 범위N-1} 형식으로 입력, 정렬식을 1개만 사용시 미입력 가능)
범위에는 숫자 또는 함수식 입력가능 (함수식 입력시 항상 함수값≥0 이여야함)

Direction : 정렬의 방향 (0 = 오름차순 / 1 = 내림차순)
0또는 1 입력시 모든 정렬식의 방향을 각각 오름차순 또는 내림차순으로 설정함
{방향1, 방향2, …} 형식으로 입력시 순서대로 각각 정렬식1, 정렬식2, … 의 정렬 방향을 설정함
※ LoopMax의 각 원소에 연결된 도형 데이터의 묶음이 정렬의 한 요소가 됨 (LoopMax로 묶인 점들은 같이 움직임)

※ 정렬의 결과로 Shape 데이터와 LoopMax 데이터 모두 내부 원소들의 순서가 바뀜

Ex) [예제 6-10] 참고

CS_SortTI(Shape,funcT,FStep,Direction)
: LoopMax가 연결된 도형 데이터를 LoopMax 데이터의 인덱스에 따라 정렬함

Shape : 정렬할 도형 데이터 ({Shape,LoopMax}형식으로 입력)
funcT : 정렬에 사용할 LoopMax 인덱스 정렬식 함수 (f(T) = {정렬식1, 정렬식2, …} 형식으로 입력)
Fstep : 정렬식 결과값의 범위 ({범위1, … , 범위N-1} 형식으로 입력, 정렬식을 1개만 사용시 미입력 가능)
범위에는 숫자 또는 함수식 입력가능 (함수식 입력시 항상 함수값≥0 이여야함)

Direction : 정렬의 방향 (0 = 오름차순 / 1 = 내림차순)

0또는 1 입력시 모든 정렬식의 방향을 각각 오름차순 또는 내림차순으로 설정함
{방향1, 방향2, …} 형식으로 입력시 순서대로 각각 정렬식1, 정렬식2, … 의 정렬 방향을 설정함
Ex) [예제 6-10] 참고

466

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ TSort 생성 함수｡+.ﾟ
CS_TArrange(Shape,Preset,Looper,Overwrite)
: LoopMax가 연결된 도형 데이터를 LoopMax 인덱스를 기준으로 재정렬함 (A↔B)

Shape : 정렬할 도형 데이터 ({Shape,LoopMax}형식으로 입력)
Preset : {교체할 횟수 n, 선택함수 f1(i), 교체함수 f2(i)} 형식으로 입력
(i = 1 ~ n까지 인덱스f1(i) 인 점과 인덱스f2(i) 인 점을 서로 순서를 바꿈)
Looper : 1입력시 f1(i) 또는 f2(i)의 함수값이 LoopMax의 범위(1~LoopMax[1])를 넘어갈때
해당 함수 값에 Mod(LoopMax[1])를 적용함 (0입력 또는 미입력시 적용X)
Overwrite : {선택함수 적용여부, 교체함수 적용여부} 형식으로 입력 (미입력시 적용X)
0 : 미적용 (중복 선택 및 교체를 허용함),
1 : 중복 선택 및 교체시 적용 대상을 한칸 뒤의 점으로 바꿈 (맨 뒤일 경우 맨 앞의 점으로 교체)
-1 : 중복 선택 및 교체시 적용 대상을 한칸 앞의 점으로 바꿈 (맨 앞일 경우 맨 뒤의 점으로 교체)
숫자 입력시 선택함수와 교체함수 모두 해당 숫자로 입력됨
※ Looper 미적용시 f1(i) 또는 f2(i)의 값이 LoopMax의 범위를 넘어갈 때는 순서를 교체하지 않음
※ Overwrite 적용시 중복이 발생하지 않는 점이 없을 경우 순서를 교체하지 않음 (교체 실행X)

Ex) [예제 6-10] 참고

CS_TSplit(Shape,Preset,Looper,Overwrite)
: LoopMax가 연결된 도형 데이터를 LoopMax 인덱스를 기준으로 분할함 (A→B)

Shape : 분할할 도형 데이터 ({Shape,LoopMax}형식으로 입력)
Preset : {추출할 횟수 n, 선택함수 f(i)} 형식으로 입력

(I = 1 ~ n까지 인덱스f(i) 인 점을 추출해서 복사함)
Looper : 1입력시 f(i)의 함수값이 LoopMax의 범위(1~LoopMax[1])를 넘어갈때
해당 함수 값에 Mod(LoopMax[1])를 적용함 (0입력 또는 미입력시 적용X)
Overwrite : 숫자로 입력 (미입력시 적용X)
0 : 미적용 (중복 선택을 허용함)
1 : 중복 선택 적용 대상을 한칸 뒤의 점으로 바꿈 (맨 뒤일 경우 맨 앞의 점으로 교체)
-1 : 중복 선택 적용 대상을 한칸 앞의 점으로 바꿈 (맨 앞일 경우 맨 뒤의 점으로 교체)
※ Looper 미적용시 f(i)의 값이 LoopMax의 범위를 넘어갈 때는 순서를 교체하지 않음

※ Overwrite 적용시 중복이 발생하지 않는 점이 없을 경우 순서를 교체하지 않음 (교체 실행X)

Ex) [예제 6-10] 참고

467

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

------------------------------------------------------------------------------------------

｡˙+ﾟ TSort 생성 함수｡+.ﾟ
CS_TMix(Shape,Looper,Overwrite)
: LoopMax가 연결된 도형 데이터를 LoopMax 인덱스를 기준으로 합침 (A+B→C)

Shape : 복사할 도형 데이터
({{도형1,LoopMax1,복사함수 f1(i)},{도형2,LoopMax2,복사함수 f2(i)}, … } 형식으로 입력
(도형1 ~ 도형n 각각 첫번째 점부터 마지막 점까지 복사 위치를 결정해서 복사함,
S1 → S2 → … → SN → S1 → S2 → … → SN → … 순으로 복사함, (복사 완료된 도형의 차례는 스킵함)
Looper : 각 도형의 복사 차례에 복사 횟수를 설정함 ({도형1 복사횟수,도형2 복사횟수,…} 형식으로 입력
nil 입력시 첫번째 차례에 해당 도형의 점을 모두 복사함,
숫자 입력시 차례마다 입력한 수 만큼 점을 복사함
함수 입력시 (f(i)=s 형태로 입력) 차례마다 함수값 만큼 점을 복사함 (첫번째 차례에 i = 1부터 시작함)

Overwrite : 복사위치 중복 선택시 복사 위치를 한칸 뒤로 바꿈 (0입력 또는 미입력시 적용X)
※ Looper의 값이 0이하면 1로, 값이 해당 도형의 총 점 수를 넘어가면 LoopMax[1]로 설정함

※ 완성된 도형 데이터에 빈칸이 있을 경우 왼쪽으로 밀어서 빈칸을 자동으로 제거함

Ex) [예제 6-10] 참고

468

------------------------------------------------------------------------------------------

『 7장 : CA_ 실시간 편집함수 (어셈블러필요) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CA_ 함수는 CAPlot 내부에서 도형데이터를 실시간으로 연산 할 수 있습니다 ｡+.ﾟ
｡˙+ﾟ ※ 주의 : RA(극좌표) 함수의 경우 Include 함수의 Cycle 값에 영향을 받습니다. ｡+.ﾟ

CA_ConvertRA(DestR,DestA,SourceX,SourceY)
: 좌표를 직교좌표 → 극좌표로 변환하는 함수
DestR : 반지름을 저장할 변수
DestA : 각도를 저장할 변수
SourceX : X좌표 변수
SourceY : Y좌표 변수
Ex) [예제 7-1] 참고

CA_ConvertXY(DestX,DestY,SourceR,SourceA)
: 좌표를 극좌표 → 직교좌표로 변환하는 함수
DestX : X좌표를 저장할 변수
DestY : Y좌표를 저장할 변수
SourceR : 반지름 변수
SourceA : 각도 변수
※ 좌표를 극좌표로 변환한 경우 반드시 마지막에 좌표값을 직교좌표로 변환해야합니다.
Ex) [예제 7-1] 참고
CA_MoveXY(X,Y)
: 좌표를 평행이동하는 함수 (직교좌표)
X : 이동할 X좌표 (숫자/변수)
Y : 이동할 Y좌표 (숫자/변수)
Ex) [예제 7-2] 참고

CA_MoveRA(Radius,Angle)
: 좌표를 평행이동하는 함수 (극좌표) - 극좌표 변환 자동사용함
Radius : 이동할 R좌표 (숫자/변수)
Angle : 이동할 Θ좌표 (숫자/변수)
Ex) [예제 7-2] 참고

469

------------------------------------------------------------------------------------------

『 7장 : CA_ 실시간 편집함수 (어셈블러필요) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CA_ 함수는 CAPlot 내부에서 도형데이터를 실시간으로 연산 할 수 있습니다 ｡+.ﾟ
｡˙+ﾟ ※ 주의 : RA(극좌표) 함수의 경우 Include 함수의 Cycle 값에 영향을 받습니다. ｡+.ﾟ

CA_RatioXY(mulX,idivX,mulY,idivY)
: 크기를 확대 및 축소하는 함수 (직교좌표)
mulX : 확대할 X좌표 배율
mulY : 확대할 Y좌표 배율
idivX : 축소할 X좌표 배율
idivY : 축소할 Y좌표 배율
Ex) [예제 7-3] 참고

CA_RatioRA(mulR,idivR,mulA,idivA)
: 크기를 확대 및 축소하는 함수 (극좌표) - 극좌표 변환 자동사용함
mulR : 확대할 R좌표 배율
mulA : 확대할 Θ좌표 배율
idivR : 축소할 R좌표 배율
idivA : 축소할 Θ좌표 배율
Ex) [예제 7-3] 참고
CA_InvertXY(X,Y)
: X,Y축에 평행한 직선으로 반전시키는 함수
X : 반사 직선 위치 설정 (x=X로 반전)
Y : 반사 직선 위치 설정 (y=Y로 반전)
Ex) [예제 7-4] 참고
CA_InvertRA(Radius,Angle)

: R,Θ축에 평행한 직선으로 반전시키는 함수 - 극좌표 변환 자동사용함
Radius : 반사 원 위치 설정 (r=Radius로 반전)
Angle : 반사 직선 위치 설정 (Θ=Angle로 반전)
Ex) [예제 7-4] 참고

470

------------------------------------------------------------------------------------------

『 7장 : CA_ 실시간 편집함수 (어셈블러필요) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CA_ 함수는 CAPlot 내부에서 도형데이터를 실시간으로 연산 할 수 있습니다 ｡+.ﾟ
｡˙+ﾟ ※ 주의 : RA(극좌표) 함수의 경우 Include 함수의 Cycle 값에 영향을 받습니다. ｡+.ﾟ

CA_Rotate(Angle)
: 각도만큼 회전시키는 함수
Angle : 회전시킬 각도
Ex) [예제 7-6] 참고
CA_Rotate3D(XYAngle,YZAngle,ZXAngle)
: 3차원 방향으로 각도만큼 회전시키는 함수
XYAngle : XY 평면에서 회전할 각도

YZAngle : YZ 평면에서 회전할 각도
ZXAngle : ZX 평면에서 회전할 각도
Ex) [예제 7-6] 참고
CA_CropXY(X1,X2,Y1,Y2)
: 직교좌표에서 지정된 범위만을 잘라내는 함수 - CAfunc 전용
X1 : 잘라낼 X좌표의 최솟값
X2 : 잘라낼 X좌표의 최댓값
Y1 : 잘라낼 Y좌표의 최솟값
Y2 : 잘라낼 Y좌표의 최댓값
Ex) [예제 7-5] 참고
CA_CropRA(R1,R2,A1,A2)
: 극좌표에서 지정된 범위만을 잘라내는 함수 - 극좌표 변환 자동사용함 / CAfunc 전용
R1 : 잘라낼 R좌표의 최솟값

R2 : 잘라낼 R좌표의 최댓값
A1 : 잘라낼 Θ좌표의 최솟값
A2 : 잘라낼 Θ좌표의 최댓값
Ex) [예제 7-5] 참고

471

------------------------------------------------------------------------------------------

『 8장 : CAPlot 함수 (어셈블러필요) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CAPlot 함수는 도형데이터를 실시간 유닛 생산 트리거로 변환할 수 있습니다. ｡+.ﾟ

CAPlotForward()
CAPlotOrderForward()
: 바로 다음 CAPlot(Order) 함수의 내부 변수 데이터의 인덱스를 리턴하는 함수
CAPlotForward() = {CA[1],CA[2],CA[3],CA[4],CA[5],CA[6],CB[1],CB[2],CB[3]}
CAPlotOrderForward() = {CA[1],CA[2],CA[3],CA[4],CA[5],CA[6],CB[1],CB[2],CB[3],CC[1],CC[2]}
Ex) [예제 8-1] 참고, [예제 8-2] 참고

CAPlot(Shape,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize,Preset,Cafunc
,PlayerID,Condition,PerAction,Preserve)
CAPlotWithProperties(Shape,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize,Preset,Cafunc
,PlayerID,Condition,PerAction,Preserve,Properties)
: Shape 데이터를 실시간 유닛 생성 트리거로 변환하는 함수 (변수 삽입 가능)
CA : (=CAPlotDataArr) : 1st CAPlot 전용 내부 변수 총 14개
CB : (=CAPlotCreateArr) : 2nd CAPlot 전용 내부변수 총 10개
PlayerID : (=CAPlotPlayerID) : CAPlot 전용 트리거 플레이어
CA[1] = 그릴 도형 선택 (k 입력시 k번 Shape 데이터로 초기화)
CA[2] = 남은 대기 시간 (Tick 단위 / 0일때 유닛 소환)
CA[3] = 소환후 대기시간 증가량 (Tick 단위/ k입력시 1회 루프후 대기시간 k추가)
CA[4] = 루프 카운터 (트리거 순환당 루프 수를 카운트함)
CA[5] = 루프 리미트 (트리거 순환당 소환할 유닛 수 / k입력시 CA[4] : 0~k-1까지 루프함)

CA[6] = 데이터 인덱스 (k입력시 Shape[k+1]의 데이터를 출력함)
CA[7] = 임시변수 : ConvertArr(CA[6]) - 사용금지
CA[8] = 임시변수 : Shape[k+1][1] - 현재 출력할 유닛의 X좌표
CA[9] = 임시변수 : Shape[k+1][2] - 현재 출력할 유닛의 Y좌표
CA[10] = 임시변수 : 선택된 Shape의 Max Index (k입력시 CA[6] > k면 Plot 종료) - k≥1
CA[11] ~ CA[14] : 임시변수로 자유롭게 사용가능 (※ 주의 : CA_Rotate3D 사용시 값이 변경될 수 있음)
CB[1] = PerUnit (16777216*k 입력시 k마리씩 소환)
CB[2] = UnitId (k입력시 k번 유닛을 소환)

CB[3] = Owner (k입력시 P(k+1)플레이어의 유닛을 소환)
CB[4] ~ CB[10] : 임시변수로 자유롭게 사용가능 (CA_ 함수에서도 사용하니 주의)
/ CB[10] > 0일 경우 해당 점을 Skip함

※ CAPlot류 함수의 리턴값 :
{CA[1],CA[2],CA[3],CA[4],CA[5],CA[6],CB[1],CB[2],CB[3],CC[1](Order함수),CC[2](Order함수)}

472

------------------------------------------------------------------------------------------

『 8장 : CAPlot 함수 (어셈블러필요) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CAPlot 함수는 도형데이터를 실시간 유닛 생산 트리거로 변환할 수 있습니다. ｡+.ﾟ
CAPlot(Shape,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize,Preset,Cafunc
,PlayerID,Condition,PerAction,Preserve)
CAPlotWithProperties(Shape,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize,Preset,Cafunc
,PlayerID,Condition,PerAction,Preserve,Properties)
: Shape 데이터를 실시간 유닛 생성 트리거로 변환하는 함수 (변수 삽입 가능)
Shape : 변환할 도형 데이터 (다수 입력 가능, 왼쪽부터 순서대로 CA[1] = 1, 2, ...)
Owner : 유닛의 소유플레이어
UnitId : 생성할 유닛의 종류 (유닛이름 String)
Location : 사용할 로케이션 ID (로케이션이름 String)
CenterXY : 유닛을 생성할 중심좌표 = {X좌표,Y좌표} - 비우면 로케이션의 현재 위치를 중심으로 설정함
PerUnit : 한 점당 생성할 유닛 수
PlotSize : 생성시 로케이션의 크기

PlayerID : 트리거 플레이어
Condition : 트리거의 조건
PerAction : 생성할때마다 실행할 액션
Preserve : 트리거에 Preserve 옵션을 넣을지의 여부
(비울 경우 반복X, 숫자 입력시 반복, 액션 입력시 반복 및 반복시 해당 액션 실행)
(WithProperties함수) : Properties 속성을 입력함 - CreateUnitWithProperties와 동일
Preset : = {CA[1],CA[2],CA[3],CA[4],CA[5],CA[6],CB[1],CB[2],CB[3]}
각각의 자리에 nil, 숫자, V(변수) 삽입 가능 (CB의 경우 변수),
변수 삽입시 CAPlot 트리거 앞에서 CA[_] << V 연산이 실행됨
CAfunc : CAPlot 함수 내부에 삽입할 사용자 정의 코드를 입력함 (nil 입력시 사용X)
함수 이름 (String) 입력시 함수 내부 코드를 CAPlot 내부에서 실행시킴
CA[8] << Shape[k+1][1], CA[9] << Shape[k+1][2] 연산 직후 CAfunc 영역 코드를 실행함
Ex) [예제 8-1] 참고

※ CAfunc 내부 코드를 작성할때 CAPlot 내부 변수를 가져오려면
local CA = CAPlotDataArr

local CB = CAPlotCreateArr
local PlayerID = CAPlotPlayerID
를 함수 맨 위에 붙여넣으면 된다.
※ CAPlot류 함수명 끝에 2를 붙이면 PerAction, Preserve를 CDoActionsX 형식으로 삽입가능함
(Condition 만족시 Preserve를 포함한 모든 해당 함수의 트리거가 실행됨)

473

------------------------------------------------------------------------------------------

『 8장 : CAPlot 함수 (어셈블러필요) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CAPlot 함수는 도형데이터를 실시간 유닛 생산 트리거로 변환할 수 있습니다. ｡+.ﾟ
CAPlotOrder(Shape,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize,Preset,CAfunc,
OrderShape,OrderType,OrderLocation,DestXY,OrderPreset,CBfunc,OrderSize,
PlayerID,Condition,PerAction,Preserve)
CAPlotOrderWithProperties(Shape,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize,Preset,CAfunc,
OrderShape,OrderType,OrderLocation,DestXY,OrderPreset,CBfunc,OrderSize,
PlayerID,Condition,PerAction,Preserve,Properties)
: Shape 데이터를 실시간 유닛 생성 트리거로 변환함
+ 각 유닛마다 OrderShape으로 Order명령을 내리는 함수 (변수 삽입 가능)
CA : (=CAPlotDataArr) : 1st CAPlot 전용 내부 변수 총 14개
CB : (=CAPlotCreateArr) : 2nd CAPlot 전용 내부변수 총 10개
PlayerID : (=CAPlotPlayerID) : CAPlot 전용 트리거 플레이어
CA[1] = 그릴 도형 선택 (k 입력시 k번 Shape 데이터로 초기화)

CA[2] = 남은 대기 시간 (Tick 단위 / 0일때 유닛 소환)
CA[3] = 소환후 대기시간 증가량 (Tick 단위/ k입력시 1회 루프후 대기시간 k추가)
CA[4] = 루프 카운터 (트리거 순환당 루프 수를 카운트함)
CA[5] = 루프 리미트 (트리거 순환당 소환할 유닛 수 / k입력시 CA[4] : 0~k-1까지 루프함)
CA[6] = 데이터 인덱스 (k입력시 Shape[k+1]의 데이터를 출력함)
CA[7] = 임시변수 : ConvertArr(CA[6]) - 사용금지
CA[8] = 임시변수 : Shape[k+1][1] - 현재 출력할 유닛의 X좌표
CA[9] = 임시변수 : Shape[k+1][2] - 현재 출력할 유닛의 Y좌표
CA[10] = 임시변수 : 선택된 Shape의 Max Index (k입력시 CA[6] > k면 Plot 종료) - k≥1
CA[11] ~ CA[14] : 임시변수로 자유롭게 사용가능 (※ 주의 : CA_Rotate3D 사용시 값이 변경될 수 있음)
CB[1] = PerUnit (16777216*k 입력시 k마리씩 소환)
CB[2] = UnitId (k입력시 k번 유닛을 소환)
CB[3] = Owner (k입력시 P(k+1)플레이어의 유닛을 소환)
CB[4] ~ CB[10] : 임시변수로 자유롭게 사용가능 (CA_ 함수에서도 사용하니 주의)
/ CB[10] > 0일 경우 해당 점을 Skip함

CC[1] = 목적지 도형 선택 (k 입력시 k번 OrderShape 데이터로 초기화)
CC[2] = 목적지 데이터 인덱스 (k입력시 OrderShape[k+1]의 데이터로 명령내림)
CC[3] = 임시변수 : ConvertArr(CC[2]) - 사용금지

474

------------------------------------------------------------------------------------------

『 8장 : CAPlot 함수 (어셈블러필요) 』

-----------------------------------------------------------------------------------------｡˙+ﾟ ※ CAPlot 함수는 도형데이터를 실시간 유닛 생산 트리거로 변환할 수 있습니다. ｡+.ﾟ
CAPlotOrder(Shape,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize,Preset,CAfunc,
OrderShape,OrderType,OrderLocation,DestXY,OrderPreset,CBfunc,OrderSize,
PlayerID,Condition,PerAction,Preserve)
CAPlotOrderWithProperties(Shape,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize,Preset,CAfunc,
OrderShape,OrderType,OrderLocation,DestXY,OrderPreset,CBfunc,OrderSize,
PlayerID,Condition,PerAction,Preserve,Properties)
: Shape 데이터를 실시간 유닛 생성 트리거로 변환함

+ 각 유닛마다 OrderShape으로 Order명령을 내리는 함수 (변수 삽입 가능)
Shape : 변환할 도형 데이터 (다수 입력 가능, 왼쪽부터 순서대로 CA[1] = 1, 2, ...)
Owner : 유닛의 소유플레이어
UnitId : 생성할 유닛의 종류 (유닛이름 String)
Location : 사용할 로케이션 ID (로케이션이름 String)
CenterXY : 유닛을 생성할 중심좌표 = {X좌표,Y좌표} - 비우면 로케이션의 현재 위치를 중심으로 설정함
PerUnit : 한 점당 생성할 유닛 수
PlotSize : 생성시 로케이션의 크기
OrderShape : 목적지로 설정할 도형 데이터 (다수 입력 가능, 왼쪽부터 순서대로 CC[1] = 1, 2, ...)
OrderType : 명령의 종류 = Attack, Patrol, Move
OrderLocation : Order명령에 사용할 로케이션 (로케이션이름 String)
DestXY : 도착지의 중심좌표 = {X좌표,Y좌표} - 비우면 OrderLocation의 현재위치를 중심으로 설정함
OrderSize : Order명령 실행시 로케이션의 크기 = {시작점크기,도착점크기}
PlayerID : 트리거 플레이어
Condition : 트리거의 조건
PerAction : 생성할때마다 실행할 액션
Preserve : 트리거에 Preserve 옵션을 넣을지의 여부
(비워둘 경우 반복X, 숫자 입력시 반복, 액션 입력시 반복 및 반복시 해당 액션 실행)
(WithProperties함수) : Properties 속성을 입력함 - CreateUnitWithProperties와 동일
Preset : = {CA[1],CA[2],CA[3],CA[4],CA[5],CA[6],CB[1],CB[2],CB[3]}
각각의 자리에 nil, 숫자, V(변수) 삽입 가능 (CB의 경우 변수),
변수 삽입시 CAPlot 트리거 앞에서 CA(CB)[_] << V 연산이 실행됨
OrderPreset : = {CC[1],CC[2]}
각각의 자리에 nil, 숫자, V(변수) 삽입 가능, 변수 삽입시 CAPlot 트리거 앞에서 CC[_] << V 연산이 실행됨
CAfunc : CAPlot 함수 내부에 삽입할 사용자 정의 코드를 입력함 (nil 입력시 사용X)
함수 이름 (String) 입력시 함수 내부 코드를 CAPlot 내부에서 실행시킴
CA[8] << Shape[k+1][1], CA[9] << Shape[k+1][2] 연산 직후 CAfunc 영역 코드를 실행함
CBfunc : CAPlot 함수 내부에 삽입할 사용자 정의 코드를 입력함 (nil 입력시 사용X)
함수 이름 (String) 입력시 함수 내부 코드를 CAPlot 내부에서 실행시킴
CA[8] << OrderShape[k+1][1], CA[9] << OrderShape[k+1][2] 연산 직후 CBfunc 영역 코드를 실행함
Ex) [예제 8-2] 참고

475

------------------------------------------------------------------------------------------

『 9장 : CXPlot 및 3차원 도형함수 (어셈블러필요) 』
------------------------------------------------------------------------------------------ ｡˙+ﾟ 3DShape 데이터 구조 ｡+.ﾟ점(3DPoint) 데이터 : {X좌표,Y좌표,Z좌표} : 좌표값은 실수(R)로 저장됨
3DShape 데이터 구조 : {점의 총 갯수(n),{X1,Y1,Z1},{X2,Y2,Z2}, ... ,{Xn,Yn,Zn}} (n개의 점으로 구성된 경우)
※ 3차원 도형 데이터는 생성 및 편집시 CX류 함수만을 사용할 수 있습니다.

｡˙+ﾟ 3DShape Make함수 ｡+.ﾟ
CXMakeShape(Ratio,PathData,...)
: 점들을 묶어 3DShape 데이터로 만듬 (사용자 정의 도형 드로잉)
PathData : 3DPoint 데이터 배열 = {{X1,Y1,Z1},{X2,Y2,Z2}, ... }
... (가변인자) : 3DPoint 데이터 (PathData에 자동으로 합쳐짐)
Ratio : X,Y,Z좌표 확대 배율 설정 = {X배율,Y배율,Z배율} or 공통배율 - 비워둘 경우 1로 입력됨
Ex) [예제 9-1] 참고

CXMakePolyhedron(Face,Size,Number)
: 정다면체 Shape 데이터를 생성함
Face : 변의 갯수 (n = 4,6,8,12,20) - 다른값 입력시 축구공(32면체) 데이터 생성
Size : 도형의 크기 (한 변의 길이)
Number : 꼭짓점 사이에 찍을 점의 갯수 - {숫자}로 입력시 : 선분 사이 내분점들의 간격의 크기
※ 선분 사이의 내분점 좌표는 도형 데이터 맨 뒤에서부터 추가됨
※ 찍히는 좌표의 순서는 .lua 코드 참고
Ex) [예제 9-2] 참고
CXMakePrism(Point,Radius,Angle,Height,FillXY,FillZ,TopMove,TopRatio)
: 각기둥의 Shape 데이터를 생성함
Point : 윗면, 밑면의 변의 갯수 (n≥3)
Radius : 윗면, 밑면의 도형의 크기
Angle : 윗면, 밑면의 도형이 회전한 각도
Height : 기둥의 높이
FillXY : 윗면, 밑면의 꼭짓점 사이에 찍을 점의 갯수 - {숫자}로 입력시 : 선분 사이 내분점들의 간격의 크기
FillZ : 기둥의 꼭짓점 사이에 찍을 점의 갯수 - {숫자}로 입력시 : 선분 사이 내분점들의 간격의 크기

TopMove : 윗면을 평행이동 시킬 위치 - {X좌표,Y좌표}
TopRatio : 윗면을 확대축소 시킬 배율 - {X배율,Y배율}
※ 선분 사이의 내분점 좌표는 도형 데이터 맨 뒤에서부터 추가됨
※ 찍히는 좌표의 순서는 윗면→밑면 순서로 추가됨
Ex) [예제 9-3] 참고
476

------------------------------------------------------------------------------------------

『 9장 : CXPlot 및 3차원 도형함수 (어셈블러필요) 』
------------------------------------------------------------------------------------------

｡˙+ﾟ 3DShape Make함수 ｡+.ﾟ
CXMakePyramid(Point,Radius,Angle,Height,FillXY,FillZ,TopMove)
: 각뿔의 Shape 데이터를 생성함
Point : 밑면의 변의 갯수 (n≥3)
Radius : 밑면의 도형의 크기
Angle : 밑면의 도형이 회전한 각도
Height : 각뿔의 높이
FillXY : 밑면의 꼭짓점 사이에 찍을 점의 갯수 - {숫자}로 입력시 : 선분 사이 내분점들의 간격의 크기
FillZ : 옆면의 꼭짓점 사이에 찍을 점의 갯수 - {숫자}로 입력시 : 선분 사이 내분점들의 간격의 크기
TopMove : 꼭짓점을 평행이동 시킬 위치 - {X좌표,Y좌표}
※ 선분 사이의 내분점 좌표는 도형 데이터 맨 뒤에서부터 추가됨
※ 찍히는 좌표의 순서는 꼭짓점→밑면 순서로 추가됨
Ex) [예제 9-4] 참고

- ｡˙+ﾟ 3DShape 편집함수 ｡+.ﾟCXConnectPath(Shape,Number,Index)
: 입력한 점 사이에 설정한 값 만큼 내분점을 추가함
Shape : 대상 도형 데이터
(일반함수)Number : 선분 사이에 추가할 내분점의 수 - {숫자}로 입력시 : 선분 사이 내분점들의 간격의 크기
Index : 내분점을 추가할 Shape내부의 점들의 배열 = {{1,2},{3,4}, ...}
※ 추가된 점 좌표는 도형 데이터 맨 뒤에서부터 추가됨
Ex) [예제 9-5] 참고
CXConvertShape(Shape,Ratio,Zfunc)
: 평면도형(Shape)를 사용자 정의함수(Zfunc)를 사용해 공간도형으로 변환함
Shape : 대상 평면도형 데이터
Ratio : X,Y,Z좌표 확대 배율 설정 = {1/X배율,1/Y배율,Z배율} or 공통배율 - 비워둘 경우 1로 입력됨
Zfunc : Z=f(X,Y) 연산 함수의 이름 (String으로 입력)
Ex) [예제 9-6] 참고

CXAdd(Shape,Ratio,PathData,...)
: 도형에 점 데이터를 추가함 (Shape+Point)
Shape : 대상 도형 데이터
Ratio : X,Y,Z좌표 확대 배율 설정 = {X배율,Y배율,Z배율} or 공통배율 - 비워둘 경우 1로 입력됨
PathData : Point 데이터 배열 = {{X1,Y1,Z1},{X2,Y2,Z2}, ... }
... (가변인자) : Point 데이터 (PathData에 자동으로 합쳐짐)

477

------------------------------------------------------------------------------------------

『 9장 : CXPlot 및 3차원 도형함수 (어셈블러필요) 』
------------------------------------------------------------------------------------------

｡˙+ﾟ 3DShape Save함수 ｡+.ﾟ
CXSaveWithName(FileName,Local,...)
: 3DShape 데이터를 .txt 파일로 저장하는 함수 (저장된 .txt 파일은 Scmdraft폴더 안의 CS폴더에 있습니다.)
FileName : 저장할 .txt 파일의 이름
Local : 0입력시 전역변수로, 1입력시 로컬변수로 저장됨
... (가변인자) : 저장할 Shape 데이터와 이름 = Shape1,"도형1", 형태로 입력
(홀수번째 : 도형데이터, 짝수번째 : 저장시 붙일 이름)
(저장된 도형 데이터의 이름은 설정한 문자열로 설정됨)
※ CSSave 함수로 저장된 .txt 파일의 Shape 데이터는 (local) ShapeN = {점의 갯수,{X1,Y1,Z1},{X2,Y2,Z2},...}
형태로 저장되어있으며, Tep에 그대로 복사해서 붙여넣어 바로 사용 가능합니다.

- ｡˙+ﾟ 3DShape 편집함수 ｡+.ﾟCXOverlap(ShapeA,ShapeB)
: 두 도형을 겹침 (A+B)
ShapeA : 대상 도형 데이터
ShapeB : 겹칠 도형 데이터
CXMove(Shape,X,Y,Z)
: 좌표를 평행이동하는 함수
Shape : 대상 도형 데이터
X : 이동할 X좌표 (숫자/변수)
Y : 이동할 Y좌표 (숫자/변수)

Z : 이동할 Z좌표 (숫자/변수)
CXMoveCenter(Shape,X,Y,Z)
: 도형의 중심을 원하는 좌표로 평행이동시킴
Shape : 대상 도형 데이터
X : 도형의 중심으로 설정할 X좌표
Y : 도형의 중심으로 설정할 Y좌표
Z : 도형의 중심으로 설정할 Z좌표
CXInvert(Shape,X,Y,Z)
: X,Y,Z 좌표를 반전시키는 함수
Shape : 대상 도형 데이터
X : 반사 평면 위치 설정 (x = X로 반전)
Y : 반사 평면 위치 설정 (y = Y로 반전)
Z : 반사 평면 위치 설정 (z = Z로 반전)

478

------------------------------------------------------------------------------------------

『 9장 : CXPlot 및 3차원 도형함수 (어셈블러필요) 』
------------------------------------------------------------------------------------------ ｡˙+ﾟ 3DShape 편집함수 ｡+.ﾟCXRatio(Shape,mulX,mulY,mulZ)
: 크기를 확대 및 축소하는 함수
Shape : 대상 도형 데이터
mulX : 확대할 X좌표 배율
mulY : 확대할 Y좌표 배율
mulZ : 확대할 Z좌표 배율
idivX : 축소할 X좌표 배율
idivY : 축소할 Y좌표 배율
idivZ : 축소할 Z좌표 배율
CXRotate(Shape,RotateX,RotateY,RotateZ)
: 3차원 방향으로 각도만큼 회전시키는 함수

Shape : 대상 도형 데이터
RotateX : X축을 중심으로 회전할 각도
RotateY : Y축을 중심으로 회전할 각도
RotateZ : Z축을 중심으로 회전할 각도
CXCrop(Shape,areaX,areaY,areaZ,edgeX,edgeY,edgeZ)
: 도형을 직교좌표 내부영역으로 잘라냄 (잘라내고 남은 부분은 버려짐)
Shape : 대상 도형 데이터
areaX : 자를영역의 X좌표 범위 = {Xmin,Xmax}
areaY : 자를영역의 Y좌표 범위 = {Ymin,Ymax}
areaZ : 자를영역의 Z좌표 범위 = {Zmin,Zmax}
edgeX : X좌표의 경계선을 자를영역에 포함할지를 선택 = {Xmin여부,Xmax여부}
edgeY : Y좌표의 경계선을 자를영역에 포함할지를 선택 = {Ymin여부,Ymax여부}
edgeZ : Z좌표의 경계선을 자를영역에 포함할지를 선택 = {Zmin여부,Zmax여부}
0 입력시 포함함, 1 입력시 미포함 - 비우면 0으로 설정함
※ (X,Y) ∈ ([Xmin,Xmax],[Ymin,Ymax],[Zmin,Zmax])인 직사각형 영역이 자를영역임

CXRound(Shape,Digit)
: 도형 데이터 내부 점들의 좌표값의 소숫점을 반올림하는 함수
Shape : 대상 도형 데이터
Digit : 반올림할 소숫점 자리수

479

------------------------------------------------------------------------------------------

『 9장 : CXPlot 및 3차원 도형함수 (어셈블러필요) 』
------------------------------------------------------------------------------------------ ｡˙+ﾟ 3DShape 편집함수 ｡+.ﾟCXGetXmax(Shape)
CXGetXmin(Shape)
CXGetYmax(Shape)
CXGetYmin(Shape)
CXGetZmax(Shape)
CXGetZmin(Shape)
: 도형 데이터 내부 점들의 최소 또는 최대 X,Y,Z좌표값을 구함
CXGetXCntr(Shape)
CXGetYCntr(Shape)
CXGetZCntr(Shape)
: 도형 데이터의 중심 좌표값을 구함

- ｡˙+ﾟ 3DShape 실시간 연산함수 ｡+.ﾟCX_Move(X,Y,Z)
: 좌표를 평행이동하는 함수 - CXfunc 전용 (실시간)
X : 이동할 X좌표 (숫자/변수)
Y : 이동할 Y좌표 (숫자/변수)
Z : 이동할 Z좌표 (숫자/변수)
CX_Invert(X,Y,Z)
: X,Y,Z 좌표를 반전시키는 함수 - CXfunc 전용 (실시간)
X : 반사 평면 위치 설정 (x = X로 반전)
Y : 반사 평면 위치 설정 (y = Y로 반전)
Z : 반사 평면 위치 설정 (z = Z로 반전)
CX_Ratio(mulX,idivX,mulY,idivY,mulZ,idivZ)
: 크기를 확대 및 축소하는 함수 - CXfunc 전용 (실시간)
mulX : 확대할 X좌표 배율

mulY : 확대할 Y좌표 배율
mulZ : 확대할 Z좌표 배율
idivX : 축소할 X좌표 배율
idivY : 축소할 Y좌표 배율
idivZ : 축소할 Z좌표 배율
480

------------------------------------------------------------------------------------------

『 9장 : CXPlot 및 3차원 도형함수 (어셈블러필요) 』
------------------------------------------------------------------------------------------

- ｡˙+ﾟ 3DShape 실시간 연산함수 ｡+.ﾟCX_Rotate(RotateX,RotateY,RotateZ)
: 3차원 방향으로 각도만큼 회전시키는 함수 - CXfunc 전용 (실시간)
RotateX : X축을 중심으로 회전할 각도
RotateY : Y축을 중심으로 회전할 각도
RotateZ : Z축을 중심으로 회전할 각도
CX_Crop(X1,X2,Y1,Y2,Z1,Z2)
: 직교좌표에서 지정된 범위만을 잘라내는 함수 - CXfunc 전용 (실시간)
X1 : 잘라낼 X좌표의 최솟값
X2 : 잘라낼 X좌표의 최댓값
Y1 : 잘라낼 Y좌표의 최솟값
Y2 : 잘라낼 Y좌표의 최댓값

Z1 : 잘라낼 Z좌표의 최솟값
Z2 : 잘라낼 Z좌표의 최댓값

- ｡˙+ﾟ 3DShape 유닛생성 함수 ｡+.ﾟCAPlotForward()
CAPlotOrderForward()
: 바로 다음 CXPlot(WithProperties) 함수의 내부 변수 데이터의 인덱스를 리턴하는 함수
CXPlotForward() = {CA[1],CA[2],CA[3],CA[4],CA[5],CA[6],CB[1],CB[2],CB[3]}

481

------------------------------------------------------------------------------------------

『 9장 : CXPlot 및 3차원 도형함수 (어셈블러필요) 』
------------------------------------------------------------------------------------------ ｡˙+ﾟ 3DShape 유닛생성 함수 ｡+.ﾟCXPlot(Shape,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize,Preset,CXfunc,
PlayerID,Condition,PerAction,Preserve)
CXPlotWithProperties(Shape,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize,Preset,
CXfunc,PlayerID,Condition,PerAction,Preserve,Properties)
: 3DShape 데이터를 실시간 유닛 생성 트리거로 변환하는 함수 (변수 삽입 가능)
CA : (=CAPlotDataArr) : 1st CXPlot 전용 내부 변수 총 14개
CB : (=CAPlotCreateArr) : 2nd CXPlot 전용 내부변수 총 10개
PlayerID : (=CAPlotPlayerID) : CXPlot 전용 트리거 플레이어
CA[1] = 그릴 도형 선택 (k 입력시 k번 Shape 데이터로 초기화)
CA[2] = 남은 대기 시간 (Tick 단위 / 0일때 유닛 소환)
CA[3] = 소환후 대기시간 증가량 (Tick 단위/ k입력시 1회 루프후 대기시간 k추가)

CA[4] = 루프 카운터 (트리거 순환당 루프 수를 카운트함)
CA[5] = 루프 리미트 (트리거 순환당 소환할 유닛 수 / k입력시 CA[4] : 0~k-1까지 루프함)
CA[6] = 데이터 인덱스 (k입력시 Shape[k+1]의 데이터를 출력함)
CA[7] = 임시변수 : ConvertArr(CA[6]) - 사용금지
CA[8] = 임시변수 : Shape[k+1][1] - 현재 출력할 유닛의 X좌표
CA[9] = 임시변수 : Shape[k+1][2] - 현재 출력할 유닛의 Y좌표
CA[10] = 임시변수 : 선택된 Shape의 Max Index (k입력시 CA[6] > k면 Plot 종료) - k≥1
CA[11] = 임시변수 : Shape[k+1][3] - 현재 출력할 유닛의 Z좌표
CA[12] ~ CA[14] : CXPlot 연산시 사용되는 임시변수
CB[1] = PerUnit (16777216*k 입력시 k마리씩 소환)
CB[2] = UnitId (k입력시 k번 유닛을 소환)
CB[3] = Owner (k입력시 P(k+1)플레이어의 유닛을 소환)
CB[4] ~ CB[10] : 임시변수로 자유롭게 사용가능 (CX_ 함수에서도 사용하니 주의)
/ CB[10] > 0일 경우 해당 점을 Skip함

※ CXPlot류 함수의 리턴값 : {CA[1],CA[2],CA[3],CA[4],CA[5],CA[6],CB[1],CB[2],CB[3]}

482

------------------------------------------------------------------------------------------

『 9장 : CXPlot 및 3차원 도형함수 (어셈블러필요) 』
------------------------------------------------------------------------------------------ ｡˙+ﾟ 3DShape 유닛생성 함수 ｡+.ﾟCXPlot(Shape,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize,Preset,CXfunc,
PlayerID,Condition,PerAction,Preserve)
CXPlotWithProperties(Shape,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize,Preset,
CXfunc,PlayerID,Condition,PerAction,Preserve,Properties)
: 3DShape 데이터를 실시간 유닛 생성 트리거로 변환하는 함수 (변수 삽입 가능)
Shape : 변환할 도형 데이터 (다수 입력 가능, 왼쪽부터 순서대로 CA[1] = 1, 2, ...)
Owner : 유닛의 소유플레이어
UnitId : 생성할 유닛의 종류 (유닛이름 String)
Location : 사용할 로케이션 ID (로케이션이름 String)
CenterXY : 유닛을 생성할 중심좌표 = {X좌표,Y좌표} - 비우면 로케이션의 현재 위치를 중심으로 설정함
PerUnit : 한 점당 생성할 유닛 수
PlotSize : 생성시 로케이션의 크기

PlayerID : 트리거 플레이어
Condition : 트리거의 조건
PerAction : 생성할때마다 실행할 액션
Preserve : 트리거에 Preserve 옵션을 넣을지의 여부
(비워둘 경우 반복X, 숫자 입력시 반복, 액션 입력시 반복 및 반복시 해당 액션 실행)
(WithProperties함수) : Properties 속성을 입력함 - CreateUnitWithProperties와 동일
Preset : = {CA[1],CA[2],CA[3],CA[4],CA[5],CA[6],CB[1],CB[2],CB[3]}
각각의 자리에 nil, 숫자, V(변수) 삽입 가능 (CB의 경우 변수),
변수 삽입시 CAPlot 트리거 앞에서 CA[_] << V 연산이 실행됨
CXfunc : CXPlot 함수 내부에 삽입할 사용자 정의 코드를 입력함 (nil 입력시 사용X)
함수 이름 (String) 입력시 함수 내부 코드를 CXPlot 내부에서 실행시킴
CA[8] << Shape[k+1][1], CA[9] << Shape[k+1][2],
CA[11] << Shape[k+1][3] 연산 직후 CXfunc 영역 코드를 실행함
※ CAfunc 내부 코드를 작성할때 CXPlot 내부 변수를 가져오려면
local CA = CAPlotDataArr

local CB = CAPlotCreateArr
local PlayerID = CAPlotPlayerID
를 함수 맨 위에 붙여넣으면 된다.
Ex) [예제 9-A] 참고, [예제 9-B] 참고, [예제 9-C] 참고, [예제 9-D] 참고
※ CXPlot류 함수명 끝에 2를 붙이면 PerAction, Preserve를 CDoActionsX 형식으로 삽입가능함
(Condition 만족시 Preserve를 포함한 모든 해당 함수의 트리거가 실행됨)

483

------------------------------------------------------------------------------------------

『 10장 : 추가 고급 편집 함수 (v2.3이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ 추가 CS 함수 ｡+.ﾟCS_Level(Type,Point,Number)
: CSMake함수의 Number(찍을 점의 개수)를 자동계산해주는 함수
Type : 계산할 CSMake함수(+CSMake),
입력 : "Polygon", "PolygonX", "Line", "LineX", "Circle", "CircleX", "Star", "StarX", "Spiral", "SpiralX"
Point : 도형의 변의 개수
Number : 껍질의 개수 / Ex) [예제 10-1] 참고
CS_Delete(Shape,PathData,...)
: 도형에 점 데이터를 삭제함 (A-Point),
PathData에 입력된 점의 좌표와 동일한 좌표를 가진 점이 Shape에 존재할 경우 해당 점을 삭제함
Shape : 대상 도형 데이터
PathData : Point 데이터 배열 = {{X1,Y1},{X2,Y2}, … }

… (가변인자) : Point 데이터 (PathData에 자동으로 합쳐짐) / Ex) [예제 10-2] 참고
CS_ConvertRA(Shape,AAdd,AMax)
: 좌표를 직교좌표 → 극좌표로 변환하는 함수
Shape : 대상 도형 데이터
AAdd : 극좌표 변환시 각도에 추가할 값(Θ축 평행이동), 기본값 0 ({N}입력시 각도에 (N/360)*AMax를 더함)
Amax : 각도 주기(2π)값, 기본값 360
CS_ConvertXY(Shape,AMax)

: 좌표를 극좌표 → 직교좌표로 변환하는 함수
Shape : 대상 도형 데이터
Amax : 각도 주기(2π)값, 기본값 360
※ 좌표를 극좌표로 변환한 경우 반드시 마지막에 좌표값을 직교좌표로 변환해야합니다.
CS_InputVoid(Size)
: Size 크기만큼의 빈 공간(0,0)을 가진 Shape 데이터를 생성함
Size : 생성할 빈 공간의 크기
CS_GetLmax(Shape)
: 도형의 가장 긴 변의 길이를 구함
Shape : 대상 도형 데이터
CS_GetLmin(Shape)
: 도형의 가장 짧은 변의 길이를 구함
Shape : 대상 도형 데이터

484

------------------------------------------------------------------------------------------

『 10장 : 추가 고급 편집 함수 (v2.3이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ 추가 CS 함수 ｡+.ﾟCS_VectorPath2D(Shape,Ratio,VectorFunc,Path,Outside)
CS_VectorPath2DPolar(Shape,Ratio,VectorFunc,Path,Outside)
: Path영역에 2차원 벡터함수 변환을 적용함
Shape : 대상 도형 데이터
Ratio : 좌표의 축소비율 설정 = {X배율(축소),Y배율(축소)} - 비우면 1(1배)로 설정됨
VectorFunc : 변환식에 해당하는 벡터함수의 이름 (String으로 입력) ※ (각도는 radian단위)
Path : 변환영역을 설정할 Path데이터
Outside : 0입력시 Path영역의 내부를, 1입력시 외부를 칠함 - 비우면 0으로 입력
Ex) [예제 10-3] 참고
※ 사용자 정의 벡터 함수 제작 및 입력 방법
function S1_Vector(X,Y) return {-Y,X} end → "S1_Vector" (f(x,y),g(x,y))
function S1_VectorPolar(R,A) return {-A,R} end → "S1_VectorPolar" (f(r,Θ),g(r,Θ))
CS_MakeShape(Path,Radius,Angle,Number,Hollow,Auto,X,Y)
CS_MakeShapeX(Path,Radius,Angle,Number,Hollow,Auto,X,Y)
: Path 데이터를 도형의 껍질로 간주하여 겹쳐서 내부를 채우는 함수
Path : 껍질로 설정할 Path데이터
Radius : 도형의 크기 (각 껍질사이의 거리)
Angle : 회전시킬 각도
Number : 찍을 껍질의 개수
Hollow : 내부에서 지울 껍질의 개수
Auto : 0입력시 각 변의 길이에 상관없이 추가로 찍히는 점의 개수가 모두 동일하게 설정됨
1입력시 각 변의 길이에 맞게 추가로 찍히는 점의 개수가 설정됨, 기본값 0
X : 껍질 중심좌표 사이의 X좌표 편차, Y : 껍질 중심좌표 사이의 Y좌표 편차
(두번째 껍질부터 중심이 (X,Y)만큼 평행이동 하면서 껍질이 생성됨)
※ X함수와의 차이는 CSMakePolygon ↔ CSMakePolygonX의 차이와 동일함
Ex) [예제 10-4] 참고
CS_ShapeInShape(Shape,InShape,Rotate,Angle,Radius)

: 각각의 InShape의 점에 Shape를 복사하는 함수
Shape : 복사할 대상 도형 데이터
InShape : Shape를 붙여넣을 좌표를 담은 도형 데이터
Rotate : 1입력시 원점을 중심으로 각각의 점에 대해 복사된 Shape를 회전시킴 (기본값 0)
Angle : 회전시킬 각도
Radius : 도형의 크기 (InShape) / Ex) [예제 10-5] 참고

485

------------------------------------------------------------------------------------------

『 10장 : 추가 고급 편집 함수 (v2.3이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ 추가 CS 함수 ｡+.ﾟCSMakeSpiral(Point,Magnificent,Coefficient,Radius,Angle,Number,Hollow)
CSMakeSpiralX(Point,Magnificent,Coefficient,Radius,Angle,Number,Hollow)
: n방향으로 뻗어나가는 로그 나선의 Shape 데이터를 생성함 (r = a*e^(b(Θ-Angle)))
Point : 변의 개수 (n≥1) - n=1 : 반직선 / n=2 : 직선 / n≥3 : n방향 반직선
Magnificent : r = a*e^(b(Θ-Angle))에서 a의 값을 결정함 (나선의 크기)
Coefficient : r = a*e^(b(Θ-Angle))에서 b의 값을 결정함 (나선팔의 휘는 정도, 클 수록 직선에 가까워짐)
Radius : 도형의 크기 (각 점 사이의 거리, 그래프 위의 점을 등간격으로 찍음)
Angle : 도형이 회전한 각도
Number : 찍을 점의 갯수
Hollow : 내부에서 지울 점의 갯수
※ X함수의 경우 원점이 아닌 첫번째 껍질부터 시작함
※ 찍히는 점의 개수는 CSMakeLine(X)와 동일함

Ex) [예제 10-6] 참고
CS_Distortion2(Shape,dLU,dLD,dRU,dRD,CenterXY)
: 도형에 왜곡 효과를 적용함 (좌표의 배율(CS_Distortion) 대신 좌표의 차로 왜곡시킬 정도를 결정함)
Shape : 대상 도형 데이터
dLU : 왼쪽 위 꼭짓점의 크기차이 설정 = {X차이,Y차이} - 비우면 0으로 설정됨
dLD : 왼쪽 아래 꼭짓점의 크기차이 설정 = {X차이,Y차이} - 비우면 0으로 설정됨
dRU : 오른쪽 위 꼭짓점의 크기차이 설정 = {X차이,Y차이} - 비우면 0으로 설정됨
dRD : 오른쪽 아래 꼭짓점의 크기차이 설정 = {X차이,Y차이} - 비우면 0으로 설정됨
CenterXY : 왜곡효과 중심좌표 설정 - 비우면 원점(0,0)을 중심으로 설정함 = {X좌표,Y좌표}
Ex) [예제 10-7] 참고
CS_Warping(Shape,Ufunc,Dfunc,Lfunc,Rfunc,CenterXY)
: 도형에 뒤틀기(함수 그래프 모양으로 왜곡시킴) 효과를 적용함
Shape : 대상 도형 데이터
Ufunc : 위쪽의 함수식과 X,Y좌표 확대 배율 설정 -- 비우면 직선으로 설정
Dfunc : 아래쪽의 함수식과 X,Y좌표 확대 배율 설정 -- 비우면 직선으로 설정
Lfunc : 왼쪽의 함수식과 X,Y좌표 확대 배율 설정 -- 비우면 직선으로 설정
Rfunc : 오른쪽의 함수식과 X,Y좌표 확대 배율 설정-- 비우면 직선으로 설정
CenterXY : 왜곡효과 중심좌표 설정 - 비우면 원점(0,0)을 중심으로 설정함 = {X좌표,Y좌표}

※ U,D,L,Rfunc 입력법 : {"함수이름",{X배율(축소),Y배율(확대)}} -- 배율부분 비우면 1로 설정됨
함수명은 String으로 입력, U,D는 y=f(x,data) / L,R는 x=f(y,data) 함수식을 입력
(data = {{(도형의) Xmax,Xmin,XCenter},{Ymax,Ymin,YCenter}}로 구성됨, 함수식에 사용가능)
Ex) [예제 10-7] 참고

486

------------------------------------------------------------------------------------------

『 10장 : 추가 고급 편집 함수 (v2.3이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ 추가 CS 함수 ｡+.ﾟRegularPolygonGraphT(T,Point,Concave,Rigidity,Magnificent)
RegularPolygonGraphA(A,Point,Concave,Rigidity,Magnificent)
: 원 ~ 정다각형(별)을 그리는 그래프 수식을 생성하는 함수
(T함수) T : f(T) = x,y에서 입력 변수 T / (A함수) A : f(A) = R에서 입력 변수 A
Point : (숫자 입력시) 정다각형의 변의 개수 (그래프의 모양은 원 ~ 정다각형 사이로 나오게됨)
(배열 입력시 {숫자1,숫자2,숫자3} 형식으로 입력, 3개의 수 중 다른게 있을 경우 정다각별 모양 등이 생성됨)
Concave : 오목도 (양수일 경우 각 변이 바깥쪽으로 볼록해짐, 음수일 경우 각 변이 안쪽으로 오목해짐)
Rigidity : 강직도 (-1~1 사이의 값 입력, 0에 가까울수록 둥글어짐, ±1에 가까울수록 직선에 가까워짐)
Magnificent : 크기값 (함수의 결과값에 곱할 수)
※ T함수 : (f(T) = X좌표, Y좌표 형식으로 리턴값을 반환함)
※ A함수 : (f(A) = R좌표 형식으로 리턴값을 반환함)
※ Concave의 기본값은 1임, 그래프의 개형을 Nucalc.exe등으로 직접 그려보고 함수를 사용하는것을 권장함

Ex) [예제 10-8] 참고
CS_BMPConvert(Shape,FileName,Xpx,Ypx,Limit)
CS_BMPConvertX(Shape,FileName,TargetXpx,TargetYpx,Limit)
: Shape 데이터를 .bmp 이미지로 변환하는 함수
Shape : 이미지로 변환할 Shape 데이터
FileName : 변환 후 저장할 이미지의 파일 이름 (AbsolutePath에 해당 이름으로 저장됨)
Limit : 생성되는 사진파일의 용량 최대값 (미입력시 100mb로 입력됨)
(일반) Xpx : 사진 파일에서 도형을 축소할 X비율 (X좌표, N입력시 Npx 간격을 1px로 그림)
(일반) Ypx : 사진 파일에서 도형을 축소할 Y비율 (Y좌표, N입력시 Npx 간격을 1px로 그림)
(X함수) TargetXpx : 사진 파일의 가로 크기 (X좌표, N입력시 가로 크기를 Npx로 그림)
(Y함수) TargetYpx : 사진 파일의 세로 크기 (Y좌표, N입력시 세로 크기를 Npx로 그림)
Ex) [예제 10-8] 참고

487

------------------------------------------------------------------------------------------

『 10장 : 추가 고급 편집 함수 (v2.3이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ 추가 CS 함수 ｡+.ﾟCSMakeGraphX1(funcY,Start,Direction,Step,Number)
CSMakeGraphY1(funcX,Start,Direction,Step,Number)
: 직교좌표계 함수의 그래프 곡선의 Path 데이터를 생성함 (입력 변수의 간격이 Step으로 일정함)
(X함수)funcY : Y=f(X) 연산 함수의 이름 (String으로 입력)
(Y함수)funcX : X=f(Y) 연산 함수의 이름 (String으로 입력)
Start : 그리기 시작할 X좌표(X함수) / Y좌표(Y함수)
Directrion : X좌표(X함수) / Y좌표(Y함수) 증가시킬 방향 (0 : +방향 / 1 : -방향)
Step : 점 사이 입력 변수의 간격
Number : 찍을 점의 총 갯수
Ex) [예제 10-9] 참고
CSMakeGraphR1(funcA,Start,Direction,Step,Number)

CSMakeGraphA1(funcR,Start,Direction,Step,Number)
: 극좌표계 함수의 그래프 곡선의 Path 데이터를 생성함 (입력 변수의 간격이 Step으로 일정함)
(A함수)funcR : R=f(Θ) 연산 함수의 이름 (String으로 입력)
(R함수)funcA : Θ=f(R) 연산 함수의 이름 (String으로 입력)
Start : 그리기 시작할 Θ좌표(A함수) / R좌표(R함수)
Directrion : Θ좌표(A함수) / R좌표(R함수) 증가시킬 방향 (0 : +방향 / 1 : -방향)
Step : 점 사이 입력 변수의 간격
Number : 찍을 점의 총 개수
Ex) [예제 10-9] 참고
CSMakeGraphT1(Parafunc,Start,Direction,Step,Number)
: 2D매개변수 함수의 그래프 곡선의 Path 데이터를 생성함 (입력 변수의 간격이 Step으로 일정함)
Parafunc : X=f(t), Y=g(t) 연산 함수의 이름 (String으로 입력)
Start : 그리기 시작할 t좌표
Directrion : t좌표 증가시킬 방향 (0 : +방향/1 : -방향)
Step : 점 사이 입력 변수의 간격
Number : 찍을 점의 총 개수

Ex) [예제 10-9] 참고
※ CSMakeGraph류 함수는 연산 시간을 많이 잡아먹으므로
빈 맵에 도형 데이터를 생성 후 파일로 저장한 뒤 생성된 도형데이터만 코드에 사용하는 것을 권장함

488

------------------------------------------------------------------------------------------

『 10장 : 추가 고급 편집 함수 (v2.3이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ 추가 CS 함수 ｡+.ﾟCSMakeGraphX2(funcY,Start,Direction,StepLength,Partition,MaxError,Number,Loop1,Loop2,Alert)
CSMakeGraphY2(funcX,Start,Direction,StepLength,Partition,MaxError,Number,Loop1,Loop2,Alert)
: 직교좌표계 함수의 등간격 그래프 곡선의 Path 데이터를 생성함 (각 점의 간격이 StepLength로 일정함)
(X함수)funcY : Y=f(X) 연산 함수의 이름 (String으로 입력)
(Y함수)funcX : X=f(Y) 연산 함수의 이름 (String으로 입력)
Start : 그리기 시작할 X좌표(X함수) / Y좌표(Y함수)
Directrion : X좌표(X함수) / Y좌표(Y함수) 증가시킬 방향 (0 : +방향 / 1 : -방향)
StepLength : 점 사이 입력 변수의 간격
Partition : 등간격 점의 좌표를 찾을때 점 사이 간격 내부 탐색 횟수 (큰 수일수록 연산시간↑&정확도↑)
MaxError : 점 사이의 거리의 최대 허용 오차 (등간격 ±MaxError 범위로 각 점의 좌표가 결정됨)
Number : 찍을 점의 총 개수
Loop1 : 1차 연산 루프 횟수 (내부 탐색점 까지의 거리를 검사함, 미입력시 24로 입력됨)

Loop2 : 2차 연산 루프 횟수 (내부 분할점들의 거리의 합을 검사함, 미입력시 12로 입력됨)
Alert : 0 입력시 무시, 1 입력시 Loop1의 루프 횟수 초과시 컴파일 에러를 띄움,
2 입력시 Loop2의 루프 횟수 초과시 컴파일 에러를 띄움, 미입력 또는 3 입력시 두 경우 모두 에러를 띄움
CSMakeGraphR2(funcA,Start,Direction,StepLength,StepNumber,Partition,MaxError,Number,Check,Loop2,Alert)
CSMakeGraphA2(funcR,Start,Direction,StepLength,StepNumber,Partition,MaxError,Number,Check,Loop2,Alert)

: 극좌표계 함수의 등간격 그래프 곡선의 Path 데이터를 생성함 (각 점의 간격이 StepLength로 일정함)
(A함수)funcR : R=f(Θ) 연산 함수의 이름 (String으로 입력)
(R함수)funcA : Θ=f(R) 연산 함수의 이름 (String으로 입력)

Start : 그리기 시작할 Θ좌표(A함수) / R좌표(R함수)
Directrion : Θ좌표(A함수) / R좌표(R함수) 증가시킬 방향 (0 : +방향 / 1 : -방향)
StepLength : 점 사이 입력 변수의 간격
StepNumber : 1차 연산시 검사할 점의 개수 (전수 조사 방식, 큰 수일수록 연산시간↑&정확도↑)
Partition : 등간격 점의 좌표를 찾을때 점 사이 간격 내부 탐색 횟수 (큰 수일수록 연산시간↑&정확도↑)
MaxError : 점 사이의 거리의 최대 허용 오차 (등간격 ±MaxError 범위로 각 점의 좌표가 결정됨)
Number : 찍을 점의 총 개수
Check : 1입력시 1차 연산 조건을 최초로 만족하는 좌표를 바로 2차 연산으로 넘김
Loop2 : 2차 연산 루프 횟수 (내부 분할점들의 거리의 합을 검사함, 미입력시 12로 입력됨)
Alert : 0 입력시 무시, 1 입력시 1차 연산후 조건 만족하는 점을 못 찾았을 경우 컴파일 에러를 띄움,
2 입력시 Loop2의 루프 횟수 초과시 컴파일 에러를 띄움, 미입력 또는 3 입력시 두 경우 모두 에러를 띄움
Ex) [예제 10-9] 참고
※ 생성된 도형 데이터가 제대로 그려졌는지 CS_BMPConvert로 확인해보는 것을 권장함
※ CSMakeGraph류 함수는 연산 시간을 많이 잡아먹으므로
빈 맵에 도형 데이터를 생성 후 파일로 저장한 뒤 생성된 도형데이터만 코드에 사용하는 것을 권장함 489

------------------------------------------------------------------------------------------

『 10장 : 추가 고급 편집 함수 (v2.3이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ 추가 CS 함수 ｡+.ﾟCSMakeGraphT2(Parafunc,Start,Direction,StepLength,StepNumber,Partition,MaxError,Number,Check,Loop2,Alert)

: 2D매개변수 함수의 등간격 그래프 곡선의 Path 데이터를 생성함 (각 점의 간격이 StepLength로 일정함)
Parafunc : X=f(t), Y=g(t) 연산 함수의 이름 (String으로 입력)
Start : 그리기 시작할 t좌표
Directrion : t좌표 증가시킬 방향 (0 : +방향/1 : -방향)
StepLength : 점 사이 입력 변수의 간격
StepNumber : 1차 연산시 검사할 점의 개수 (전수 조사 방식, 큰 수일수록 연산시간↑&정확도↑)
Partition : 등간격 점의 좌표를 찾을때 점 사이 간격 내부 탐색 횟수 (큰 수일수록 연산시간↑&정확도↑)
MaxError : 점 사이의 거리의 최대 허용 오차 (등간격 ±MaxError 범위로 각 점의 좌표가 결정됨)
Number : 찍을 점의 총 개수
Check : 1입력시 1차 연산 조건을 최초로 만족하는 좌표를 바로 2차 연산으로 넘김
Loop2 : 2차 연산 루프 횟수 (내부 분할점들의 거리의 합을 검사함, 미입력시 12로 입력됨)

Alert : 0 입력시 무시, 1 입력시 1차 연산후 조건 만족하는 점을 못 찾았을 경우 컴파일 에러를 띄움,
2 입력시 Loop2의 루프 횟수 초과시 컴파일 에러를 띄움, 미입력 또는 3 입력시 두 경우 모두 에러를 띄움
Ex) [예제 10-9] 참고
※ 생성된 도형 데이터가 제대로 그려졌는지 CS_BMPConvert로 확인해보는 것을 권장함
※ CSMakeGraph류 함수는 연산 시간을 많이 잡아먹으므로
빈 맵에 도형 데이터를 생성 후 파일로 저장한 뒤 생성된 도형데이터만 코드에 사용하는 것을 권장함
※ CSMakeGraph[R/A/T]2의 경우 1차 조건 통과가 안되는 경우가 많으므로 입력칸에 숫자를 바꿔가면서
시도하는것을 권장함 (일부 그래프의 경우 모든 점사이의 거리가 StepLength 미만인 경우도 존재함)
※ CSMakeGraph[R/A/T]의 경우 주기 함수의 경우 Number가 주기보다 클 경우 같은자리에 2개이상
찍히는 경우가 존재함 (등간격 함수의 경우 CS_BMPConvert로 직접 확인해 Number의 크기를 결정 가능)

490

------------------------------------------------------------------------------------------

『 10장 : 추가 고급 편집 함수 (v2.3이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ 추가 CS 함수 ｡+.ﾟCSMakeGraphXY(funcXY,areaX,areaY,StepX,StepY,MaxError,LoopX,LoopY)
: 직교좌표 음함수 그래프 곡선의 Path 데이터를 생성함 (같은 입력변수 간격으로 f(x,y)=k 값을 검사함)
funcXY : f(x,y) = k 연산 함수의 이름 (String으로 입력)
areaX : 그래프를 그릴 X좌표 영역 {Xmin, Xmax} 형식으로 입력
areaY : 그래프를 그릴 Y좌표 영역 {Ymin, Ymax} 형식으로 입력
StepX : 그래프에 점을 찍을 X좌표의 간격
StepY : 그래프에 점을 찍을 Y좌표의 간격
MaxError : f(x,y) = k의 최대 허용 오차 (k값이 실제 함수값과 가까울수록 해당 그래프의 점에 가까워짐)
LoopX : 각 점당 허용오차 내부 영역의 X좌표 내부 탐색 횟수 (미입력시 16으로 입력됨)
LoopY : 각 점당 허용오차 내부 영역의 Y좌표 내부 탐색 횟수 (미입력시 16으로 입력됨)
Ex) [예제 10-10] 참고

CSMakeGraphRA(funcRA,areaR,areaA,StepR,StepA,MaxError,LoopR,LoopA)
: 극좌표 음함수 그래프 곡선의 Path 데이터를 생성함 (같은 입력변수 간격으로 f(r,Θ)=k 값을 검사함)
funcRA : f(r,Θ) = k 연산 함수의 이름 (String으로 입력)
areaR : 그래프를 그릴 R좌표 영역 {Rmin, Rmax} 형식으로 입력
areaA : 그래프를 그릴 Θ좌표 영역 {Θmin, Θmax} 형식으로 입력
StepR : 그래프에 점을 찍을 R좌표의 간격
StepA : 그래프에 점을 찍을 Θ좌표의 간격
MaxError : f(r,Θ) = k의 최대 허용 오차 (k값이 실제 함수값과 가까울수록 해당 그래프의 점에 가까워짐)
LoopR : 각 점당 허용오차 내부 영역의 R좌표 내부 탐색 횟수 (미입력시 16으로 입력됨)
LoopA : 각 점당 허용오차 내부 영역의 Θ좌표 내부 탐색 횟수 (미입력시 16으로 입력됨)
Ex) [예제 10-10] 참고
※ 생성된 도형 데이터가 제대로 그려졌는지 CS_BMPConvert로 확인해보는 것을 권장함
※ CSMakeGraph류 함수는 연산 시간을 많이 잡아먹으므로
빈 맵에 도형 데이터를 생성 후 파일로 저장한 뒤 생성된 도형데이터만 코드에 사용하는 것을 권장함
※ CSMakeGraph[XY/RA]의 경우 최종적으로 생성되는 도형 데이터의 점 개수는 0~StepX*StepY개 이며,
f(x,y) = k가 허용오차 내에 있는 점만 데이터에 포함시킴

491

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ CBPlot 관련 함수 (STRCtrig 필수) ｡+.ﾟ-

Include_CBPaint()
: 어셈블러가 지원하는 모든 실시간 도형데이터 편집 함수를 Include 합니다.

※ 반드시 Tep 맨 위의 CJump(0) 사이에 넣어야 합니다
CBPlot(Shape,LoopMax,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize
,Preset,CAfunc,Prefunc,PlayerID,Condition,PerAction,Preserve)
CBPlotWithProperties(Shape,LoopMax,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize
,Preset,CAfunc,Prefunc,PlayerID,Condition,PerAction,Preserve,Properties)
: Shape 데이터를 실시간 유닛 생성 트리거로 변환하는 함수 (파일 생성 방식으로 도형 데이터 생성함)
CA : (=CAPlotDataArr) : 1st CAPlot 전용 내부 변수 총 20개
CB : (=CAPlotCreateArr) : 2nd CAPlot 전용 내부변수 총 10개
PlayerID : (=CAPlotPlayerID) : CAPlot 전용 트리거 플레이어
Cptr : (=CBPlotLoopMaxptr) : (LoopMax 입력시만 존재) CBPlot 전용 LoopMax 데이터 인덱스 변수
CA[1] = 그릴 도형 선택 (k 입력시 k번 Shape 데이터로 초기화)
CA[2] = 남은 대기 시간 (Tick 단위 / 0일때 유닛 소환)
CA[3] = 소환후 대기시간 증가량 (Tick 단위/ k입력시 1회 루프후 대기시간 k추가)

CA[4] = 루프 카운터 (트리거 순환당 루프 수를 카운트함)
CA[5] = 루프 리미트 (트리거 순환당 소환할 유닛 수 / k입력시 CA[4] : 0~k-1까지 루프함)
※ LoopMax 입력시 해당 Preset 입력칸의 값은 LoopMax Cptr에 대신 입력됨
Cptr = LoopMax 데이터 인덱스 (k입력시 LoopMax[k+1]의 데이터를 사용함, 최솟값 1)
{Cptr (상수/V), CA[5] (상수/V)} 형식으로 입력시 각각의 항목에 값이 입력됨
CA[6] = 데이터 인덱스 (k입력시 Shape[k+2]의 데이터를 출력함 : 0 입력시 1번째점 출력)
CA[7] = 임시변수 : ConvertArr(CA[6]) - 사용금지
CA[8] = 임시변수 : Shape[k+1][1] - 현재 출력할 유닛의 X좌표
CA[9] = 임시변수 : Shape[k+1][2] - 현재 출력할 유닛의 Y좌표
CA[10] = 임시변수 : 선택된 Shape의 Max Index (k입력시 CA[6] > k면 Plot 종료) - k≥1
CA[11] ~ CA[14] : 임시변수로 자유롭게 사용가능 (※ 주의 : CA_Rotate3D 사용시 값이 변경될 수 있음)
CA[15] ~ CA[20] : 임시변수 - 사용금지
CB[1] = PerUnit (16777216*k 입력시 k마리씩 소환)
CB[2] = UnitId (k입력시 k번 유닛을 소환)
CB[3] = Owner (k입력시 P(k+1)플레이어의 유닛을 소환)
CB[4] ~ CB[10] : 임시변수로 자유롭게 사용가능 (CA_ 함수에서도 사용하니 주의)
/ CB[10] > 0일 경우 해당 점을 Skip함
Ex) [예제 11-1] 참고

492

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ CBPlot 관련 함수 (STRCtrig 필수) ｡+.ﾟCBPlot(Shape,LoopMax,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize
,Preset,CAfunc,Prefunc,PlayerID,Condition,PerAction,Preserve)
CBPlotWithProperties(Shape,LoopMax,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize

,Preset,CAfunc,Prefunc,PlayerID,Condition,PerAction,Preserve,Properties)
: Shape 데이터를 실시간 유닛 생성 트리거로 변환하는 함수 (파일 생성 방식으로 도형 데이터 생성함)
Shape : 출력할 도형 데이터 (다수 입력 가능, 왼쪽부터 순서대로 CA[1] = 1, 2, …)
LoopMax : 사용할 LoopMax 데이터 (다수 입력 가능, 왼쪽부터 순서대로 CA[1] = 1, 2, …)
Owner : 유닛의 소유플레이어
UnitId : 생성할 유닛의 종류 (유닛이름 String)
Location : 사용할 로케이션 ID (로케이션이름 String)
CenterXY : 유닛을 생성할 중심좌표 = {X좌표,Y좌표} - 비우면 로케이션의 현재 위치를 중심으로 설정함
PerUnit : 한 점당 생성할 유닛 수
PlotSize : 생성시 로케이션의 크기
PlayerID : 트리거 플레이어
Condition : 트리거의 조건
PerAction : 생성할때마다 실행할 액션 (CDoActionsX 형식으로 입력)
Preserve : 트리거에 Preserve 옵션을 넣을지의 여부 (액션 입력시 CDoActionsX 형식으로 입력)
(비울 경우 반복X, 숫자 입력시 반복, 액션 입력시 반복 및 반복시 해당 액션 실행)
(WithProperties함수) : Properties 속성을 입력함 - CreateUnitWithProperties와 동일
Preset : = {CA[1],CA[2],CA[3],CA[4],CA[5],CA[6],CB[1],CB[2],CB[3]}

각각의 자리에 nil, 숫자, V(변수) 삽입 가능 (CB의 경우 변수),
변수 삽입시 CAPlot 트리거 앞에서 CA[_] << V 연산이 실행됨 (LoopMax 입력시 CA[5]자리는 ptr로 입력됨)
CAfunc : CBPlot 함수 내부에 삽입할 사용자 정의 코드를 입력함 (nil 입력시 사용X)
함수 이름 (String) 입력시 함수 내부 코드를 CBPlot 내부에서 실행시킴
CA[8] << Shape[k+1][1], CA[9] << Shape[k+1][2] 연산 직후 CAfunc 영역 코드를 실행함
Prefunc : CBPlot 실행 직전(Preset에 변수값 대입 이전)에 CBPlot에 입력된 Shape, LoopMax 데이터를
실시간으로 편집하는 사용자 정의 코드를 입력함 (함수이름 입력, nil 입력시 사용X)

Ex) [예제 11-1] 참고
※ CB_류 함수 (실시간 Shape, LoopMax 편집 함수)는 Prefunc에서만 사용가능함
※ CAfunc 내부 코드를 작성할때 CBPlot 내부 변수를 가져오려면
local CA = CAPlotDataArr
local CB = CAPlotCreateArr
local Cptr = CBPlotLoopMaxptr
local PlayerID = CAPlotPlayerID
를 함수 맨 위에 붙여넣으면 된다.
※ CBPlot류 함수는 Condition 만족시 Preserve를 포함한 모든 해당 함수의 트리거가 실행됨

493

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ CBPlot 관련 함수 (STRCtrig 필수) ｡+.ﾟCBPlotOrder(Shape,LoopMax,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize
,Preset,CAfunc,OrderType,OrderLocation,DestXY,OrderPreset,CBfunc,OrderSize,Prefunc
,PlayerID,Condition,PerAction,Preserve)
CBPlotOrderWithProperties(Shape,LoopMax,Owner,UnitId,Location,CenterXY,PerUnit
,PlotSize,Preset,CAfunc,OrderType,OrderLocation,DestXY,OrderPreset,CBfunc,OrderSize
,Prefunc,PlayerID,Condition,PerAction,Preserve,Properties)
: Shape 데이터를 실시간 유닛 생성 트리거로 변환하는 함수 (파일 생성 방식으로 도형 데이터 생성함)
+ 각 유닛마다 OrderShape으로 Order명령을 내리는 함수 (변수 삽입 가능)

CA : (=CAPlotDataArr) : 1st CAPlot 전용 내부 변수 총 20개
CB : (=CAPlotCreateArr) : 2nd CAPlot 전용 내부변수 총 10개
CC : (=CBPlotOrderArr) : 3rd CBPlot Order전용 내부변수 총 3개
PlayerID : (=CAPlotPlayerID) : CAPlot 전용 트리거 플레이어
Cptr : (=CBPlotLoopMaxptr) : (LoopMax 입력시만 존재) CBPlot 전용 LoopMax 데이터 인덱스 변수
CA[1] = 그릴 도형 선택 (k 입력시 k번 Shape 데이터로 초기화)
CA[2] = 남은 대기 시간 (Tick 단위 / 0일때 유닛 소환)
CA[3] = 소환후 대기시간 증가량 (Tick 단위/ k입력시 1회 루프후 대기시간 k추가)
CA[4] = 루프 카운터 (트리거 순환당 루프 수를 카운트함)

CA[5] = 루프 리미트 (트리거 순환당 소환할 유닛 수 / k입력시 CA[4] : 0~k-1까지 루프함)
※ LoopMax 입력시 해당 Preset 입력칸의 값은 LoopMax Cptr에 대신 입력됨
{Cptr (상수/V), CA[5] (상수/V)} 형식으로 입력시 각각의 항목에 값이 입력됨
CA[6] = 데이터 인덱스 (k입력시 Shape[k+2]의 데이터를 출력함 : 0 입력시 1번째점 출력)
CA[7] = 임시변수 : ConvertArr(CA[6]) - 사용금지
CA[8] = 임시변수 : Shape[k+1][1] - 현재 출력할 유닛의 X좌표
CA[9] = 임시변수 : Shape[k+1][2] - 현재 출력할 유닛의 Y좌표
CA[10] = 임시변수 : 선택된 Shape의 Max Index (k입력시 CA[6] > k면 Plot 종료) - k≥1

CA[11] ~ CA[14] : 임시변수로 자유롭게 사용가능 (※ 주의 : CA_Rotate3D 사용시 값이 변경될 수 있음)
CA[15] ~ CA[20] : 임시변수 - 사용금지
CB[1] = PerUnit (16777216*k 입력시 k마리씩 소환)
CB[2] = UnitId (k입력시 k번 유닛을 소환)
CB[3] = Owner (k입력시 P(k+1)플레이어의 유닛을 소환)
CB[4] ~ CB[10] : 임시변수로 자유롭게 사용가능 (CA_ 함수에서도 사용하니 주의)
/ CB[10] > 0일 경우 해당 점을 Skip함
CC[1] = 목적지 도형 선택 (k 입력시 k번 OrderShape 데이터로 초기화)
CC[2] = 목적지 데이터 인덱스 (k입력시 OrderShape[k+2]의 데이터로 명령내림)
CC[3] = 임시변수 : ConvertArr(CC[2]) - 사용금지 / Ex) [예제 11-1] 참고

494

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ CBPlot 관련 함수 (STRCtrig 필수) ｡+.ﾟCBPlotOrder(Shape,LoopMax,Owner,UnitId,Location,CenterXY,PerUnit,PlotSize
,Preset,CAfunc,OrderType,OrderLocation,DestXY,OrderPreset,CBfunc,OrderSize,Prefunc
,PlayerID,Condition,PerAction,Preserve)

CBPlotOrderWithProperties(Shape,LoopMax,Owner,UnitId,Location,CenterXY,PerUnit
,PlotSize,Preset,CAfunc,OrderType,OrderLocation,DestXY,OrderPreset,CBfunc,OrderSize
,Prefunc,PlayerID,Condition,PerAction,Preserve,Properties)
: Shape 데이터를 실시간 유닛 생성 트리거로 변환하는 함수 (파일 생성 방식으로 도형 데이터 생성함)
+ 각 유닛마다 OrderShape으로 Order명령을 내리는 함수 (변수 삽입 가능)
Shape : 출력할 도형 데이터 (다수 입력 가능, 왼쪽부터 순서대로 CA[1] = 1, 2, …)
(Order의 Shape도 여기에 입력, 순서대로 CC[1] = 1, 2, …)
OrderType : 명령의 종류 = Attack, Patrol, Move
OrderLocation : Order명령에 사용할 로케이션 (로케이션이름 String)
DestXY : 도착지의 중심좌표 = {X좌표,Y좌표} - 비우면 OrderLocation의 현재위치를 중심으로 설정함
OrderSize : Order명령 실행시 로케이션의 크기 = {시작점크기,도착점크기}
OrderPreset : = {CC[1],CC[2]}
각각의 자리에 nil, 숫자, V(변수) 삽입 가능, 변수 삽입시 CBPlot 트리거 앞에서 CA[_] << V 연산이 실행됨
(WithProperties함수) : Properties 속성을 입력함 - CreateUnitWithProperties와 동일
CBfunc : CBPlot 함수 내부에 삽입할 사용자 정의 코드를 입력함 (nil 입력시 사용X)
함수 이름 (String) 입력시 함수 내부 코드를 CBPlot 내부에서 실행시킴
CA[8] << OrderShape[k+1][1], CA[9] << OrderShape[k+1][2] 연산 직후 CBfunc 영역 코드를 실행함
나머지는 모두 CBPlot(WithProperties)와 동일함

Ex) [예제 11-1] 참고
※ CB_류 함수 (실시간 Shape, LoopMax 편집 함수)는 Prefunc에서만 사용가능함
※ OrderShape와 Shape는 Shape에 입력된 도형 데이터를 공유함
※ CAfunc 및 CBfunc 내부 코드를 작성할때 CBPlot 내부 변수를 가져오려면
local CA = CAPlotDataArr
local CB = CAPlotCreateArr
local CC = CBPlotOrderArr
local Cptr = CBPlotLoopMaxptr

local PlayerID = CAPlotPlayerID
를 함수 맨 위에 붙여넣으면 된다.
※ CBPlot류 함수는 Condition 만족시 Preserve를 포함한 모든 해당 함수의 트리거가 실행됨
※ CBPlot류 함수의 리턴값 : {내부 변수 배열, X좌표 FArr배열, Y좌표 FArr배열, LoopMax FArr배열, Cptr}
내부 변수 배열 : {CA[1],CA[2],CA[3],CA[4],CA[5],CA[6],CB[1],CB[2],CB[3],CC[1](Order함수),CC[2](Order함수)}
X/Y/LoopMax FArr 배열의 경우 Shape 또는 LoopMax에 입력한 데이터들의 파일위치(Mem)가 들어있음
Cptr은 내부적으로 쓰는 CBPlotLoopMaxptr의 값을 반환함 (미입력 항목들은 비워짐)

495

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ CBPlot 관련 함수 (STRCtrig 필수) ｡+.ﾟCB_ConvertRA(Shape,RetShape)
: 도형의 좌표를 직교좌표계에서 극좌표계 형태로 바꿈 (X,Y → R,A)
Shape : 연산할 도형 데이터의 위치 (CBPlot에서 Shape 인자의 순번을 입력, 맨 왼쪽부터 1)

RetShape : 결과값을 저장할 도형 데이터의 위치 (CBPlot에서 Shape 인자의 순번을 입력, 맨 왼쪽부터 1)

CB_ConvertXY(Shape,RetShape)
: 도형의 좌표를 극좌표계에서 직교좌표계 형태로 바꿈 (R,A → X,Y)
Shape : 연산할 도형 데이터의 위치 (CBPlot에서 Shape 인자의 순번을 입력, 맨 왼쪽부터 1)
RetShape : 결과값을 저장할 도형 데이터의 위치 (CBPlot에서 Shape 인자의 순번을 입력, 맨 왼쪽부터 1)

Ex) [예제 11-2] 참고
※ 모든 CB_류 함수는 CBPlot의 Prefunc에 입력한 함수 내에서만 사용가능함
※ CB_류 함수에서는 CBPlot의 Shape인자를 연산하며, Shape와 RetShape가 같으면 오류 발생함
※ 일부 함수에서는 반드시 직교좌표계 또는 극좌표계 형태로만 연산해야 함 (따로 표시가 없으면 둘 다 가능)
※ 최종적으로 CBPlot에 출력하기 전에는 반드시 좌표값을 직교좌표계 형태로 바꿔야함
※ CS_ConvertRA등으로 도형 데이터를 미리 극좌표계 형태로 입력할 수 도 있음
※ 극좌표계 형태에서는 X좌표가 R좌표(반지름), Y좌표가 A좌표(각도)가 됨 (각도의 주기는 Cycle값으로 설정)

CB_Move(X,Y,Shape,RetShape)
: 도형을 좌표축에 평행이동시킴
Shape : 연산할 도형 데이터의 위치

RetShape : 결과값을 저장할 도형 데이터의 위치
X : X축 +방향으로 이동할 거리 (상수/V/VA)
Y : Y축 +방향으로 이동할 거리 (상수/V/VA)

Ex) [예제 11-2] 참고

CB_MoveCenter(X,Y,Shape,RetShape)
: 도형의 중심을 원하는 좌표로 평행이동시킴
Shape : 연산할 도형 데이터의 위치
RetShape : 결과값을 저장할 도형 데이터의 위치
X : 도형의 중심으로 설정할 X좌표 (상수/V/VA)
Y : 도형의 중심으로 설정할 Y좌표 (상수/V/VA)

Ex) [예제 11-2] 참고

496

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ CBPlot 관련 함수 (STRCtrig 필수) ｡+.ﾟCB_Rotate(Angle,Shape,RetShape)
: 도형을 각도만큼 회전시킴 (직교좌표 전용)
Shape : 연산할 도형 데이터의 위치

RetShape : 결과값을 저장할 도형 데이터의 위치
Angle : 회전할 각도 (deg) - 시계방향이 양수 (상수/V/VA)

Ex) [예제 11-3] 참고

CB_Rotate3D(XYAngle,YZAngle,ZXAngle,Shape,RetShape)
: 도형을 각도만큼 3차원 회전을 적용함 (직교좌표 전용)
Shape : 연산할 도형 데이터의 위치
RetShape : 결과값을 저장할 도형 데이터의 위치
XYAngle : XY평면에서 회전할 각도 (deg) - 시계방향이 양수 (상수/V/VA)
YZAngle : YZ평면에서 회전할 각도 (deg) - 시계방향이 양수 (상수/V/VA)
(ZXAngle : ZX평면에서 회전할 각도 (deg) - 시계방향이 양수 (상수/V/VA)

※ Z축 좌표 데이터는 3D 연산 종료후 자동 소멸됨
Ex) [예제 11-3] 참고
CB_Invert(X,Y,Shape,RetShape)
: 도형을 좌표축에 평행한 직선으로 뒤집음
Shape : 연산할 도형 데이터의 위치
RetShape : 결과값을 저장할 도형 데이터의 위치
X : x = X 직선으로 뒤집음 (상수/V/VA)
Y : y = Y 직선으로 뒤집음 (상수/V/VA)

Ex) [예제 11-3] 참고
CB_Ratio(imulX,idivX,imulY,idivY,Shape,RetShape)
: 도형을 좌표축 방향으로 확대및 축소시킴
Shape : 연산할 도형 데이터의 위치

RetShape : 결과값을 저장할 도형 데이터의 위치
imulX : X좌표에 곱할 값 - 비우면 연산X (상수/V/VA)
idivX : X좌표에 나눌 값 - 비우면 연산X (상수/V/VA)
imulY : Y좌표에 곱할 값 - 비우면 연산X (상수/V/VA)
idivY : Y좌표에 나눌 값 - 비우면 연산X (상수/V/VA)
※ 해당 축 좌표에 imul의 값으로 곱한 뒤 idiv값으로 나눔

Ex) [예제 11-3] 참고

497

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ CBPlot 관련 함수 (STRCtrig 필수) ｡+.ﾟCB_MirrorX(X,Side,Shape,RetShape)
CB_MirrorY(Y,Side,Shape,RetShape)
: 도형을 좌표축에 평행한 직선으로 대칭시킴

Shape : 연산할 도형 데이터의 위치
RetShape : 결과값을 저장할 도형 데이터의 위치
(X함수)X : x = X 직선으로 대칭시킴 (상수/V/VA)
(Y함수)Y : y = Y 직선으로 대칭시킴 (상수/V/VA)
Side : 대칭시킬 영역 선택, 0또는 1 입력 (상수/V/VA)
(X함수) : 왼쪽 0, 오른쪽 1 / (Y함수) : 위쪽 0, 아래쪽 1

Ex) [예제 11-4] 참고

CB_Distortion(mulLU,mulLD,mulRU,mulRD,CenterXY,Shape,RetShape)
CB_Distortion2(dLU,dLD,dRU,dRD,CenterXY,Shape,RetShape)
: 도형에 왜곡(원근감,비틀기,기울이기 등) 효과를 적용함 (직교좌표 전용)
Shape : 연산할 도형 데이터의 위치
RetShape : 결과값을 저장할 도형 데이터의 위치
mulLU : 왼쪽 위 꼭짓점의 크기비율 설정 = {X배율,Y배율} - 비우면 1(1배)로 설정됨 (상수/V/VA)
mulLD : 왼쪽 아래 꼭짓점의 크기비율 설정 = {X배율,Y배율} - 비우면 1(1배)로 설정됨 (상수/V/VA)
mulRU : 오른쪽 위 꼭짓점의 크기비율 설정 = {X배율,Y배율} - 비우면 1(1배)로 설정됨 (상수/V/VA)
mulRD : 오른쪽 아래 꼭짓점의 크기비율 설정 = {X배율,Y배율} - 비우면 1(1배)로 설정됨 (상수/V/VA)

CenterXY : 왜곡효과 중심좌표 설정 - 비우면 원점(0,0)을 중심으로 설정함 = {X좌표,Y좌표} (상수/V/VA)
(2함수) dLU : 왼쪽 위 꼭짓점의 크기차이 설정 = {X차이,Y차이} - 비우면 0으로 설정됨 (상수/V/VA)
(2함수) dLD : 왼쪽 아래 꼭짓점의 크기차이 설정 = {X차이,Y차이} - 비우면 0으로 설정됨 (상수/V/VA)
(2함수) dRU : 오른쪽 위 꼭짓점의 크기차이 설정 = {X차이,Y차이} - 비우면 0으로 설정됨 (상수/V/VA)
(2함수) dRD : 오른쪽 아래 꼭짓점의 크기차이 설정 = {X차이,Y차이} - 비우면 0으로 설정됨 (상수/V/VA)

Ex) [예제 11-4] 참고

498

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ CBPlot 관련 함수 (STRCtrig 필수) ｡+.ﾟCB_Warping(Ufunc,Dfunc,Lfunc,Rfunc,CenterXY,Shape,RetShape)
: 도형에 뒤틀기(함수 그래프 모양으로 왜곡시킴) 효과를 적용함 (직교좌표 전용)
Shape : 연산할 도형 데이터의 위치

RetShape : 결과값을 저장할 도형 데이터의 위치
Ufunc : 위쪽의 함수식 설정 -- 비우면 직선으로 설정 (CFunc 입력)
Dfunc : 아래쪽의 함수식 설정 -- 비우면 직선으로 설정 (CFunc 입력)
Lfunc : 왼쪽의 함수식 설정 -- 비우면 직선으로 설정 (CFunc 입력)
Rfunc : 오른쪽의 함수식 설정-- 비우면 직선으로 설정 (CFunc 입력)
CenterXY : 왜곡효과 중심좌표 설정 - 비우면 원점(0,0)을 중심으로 설정함 = {X좌표,Y좌표}
※ U,D,L,Rfunc 입력법 : InitCFunc의 리턴값 입력
Parameter는 [X(U,D) / Y(L,R)], FuncType, Xmax, Xmin, Xcenter, Ymax, Ymin, Ycenter로 8개 전달됨

첫번째 리턴값을 해당 함수의 결과값으로 인식함
※ FuncType : 0 = Ufunc, 1 = Dfunc, 2 = Lfunc, 3 = Rfunc 실행시 해당 값이 인자에 입력됨
Ex) [예제 11-5] 참고
CB_Kaleidoscope(Point,StartAngle,Side,Shape,RetShape)
CB_KaleidoscopeX(Point,StartAngle,Side,Shape,RetShape)
CB_Kaleidoscope2(Point,StartAngle,Side,Shape,RetShape)
CB_Kaleidoscope2X(Point,StartAngle,Side,Shape,RetShape)

: 도형에 (대칭/비대칭)만화경 효과를 적용함 (극좌표 전용)
(일반)StartAngle부터 Cycle/2n까지의 영역을 선대칭 시킨 후 회전대칭 시킴
(X함수)StartAngle부터 Cycle/n까지의 영역을 회전대칭 시킴
Shape : 연산할 도형 데이터의 위치
RetShape : 결과값을 저장할 도형 데이터의 위치
Point : 대칭시켜 만들 상의 갯수 (상수/V/VA)
(일반함수: Cycle/2n, X함수: Cycle/n를 대칭 영역으로 설정함)
StartAngle : 대칭시킬 영역의 시작 각도 (상수/V/VA)

Side : 대칭시킬 영역의 방향 설정 (상수/V/VA)
(0 : +각의 방향으로 대칭영역 설정 / 1 : -각의 방향으로 대칭영역 설정)
※ 일반함수는 매 점을 회전복사할때 (한 영역의 각도 크기 * 현재 위치)/전체 상의 개수 를 연산함
※ 2함수는 매 점을 회전복사할때 한영역의 각도크기/전체 상의개수 * 현재위치 + (남은 편차) 식으로 연산함
(2함수가 성능을 덜 먹으나, Cycle/(n 또는 2n)의 값이 정수가 아닐때 복사 위치가 부정확 해질 수 있음

Ex) [예제 11-5] 참고
499

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ CBPlot 관련 함수 (STRCtrig 필수) ｡+.ﾟCB_Vector2D(VectorFunc,Shape,RetShape)
: 도형에 2차원 벡터함수 변환을 적용함
Shape : 연산할 도형 데이터의 위치

RetShape : 결과값을 저장할 도형 데이터의 위치
VectorFunc : 변환식에 해당하는 벡터함수 (CFunc 입력)
※ VectorFunc 입력법 : InitCFunc의 리턴값 입력
Parameter는 X, Y로 2개 전달됨
첫번째 리턴값을 변환된 X좌표, 두번째 리턴값을 변환된 Y좌표로 해당 함수의 결과값으로 인식함
Ex) [예제 11-6] 참고
CB_ShapeInShape(InShape,Rotate,Angle,Shape,RetShape)

: 각각의 InShape의 점에 Shape를 복사하는 함수 (Rotate 또는 Angle 사용시 직교좌표 전용)
InShape : Shape를 붙여넣을 좌표를 담은 도형 데이터의 위치
Rotate : 1입력시 원점을 중심으로 각각의 점에 대해
복사된 Shape를 회전시킴 (기본값 0, 상수/V/VA)
0입력시 모든 회전 미사용, 2입력시 Angle에 대한 회전만 사용함

Angle : 회전시킬 각도 (상수/V/VA)
Shape : 복사할 도형 데이터의 위치
RetShape : 결과값을 저장할 도형 데이터의 위치

Ex) [예제 11-6] 참고
CB_Crop(X1,X2,Y1,Y2,Shape,RetShape)
: 도형을 직교좌표 내부영역으로 잘라냄 (잘라내고 남은 부분은 버려짐)
Shape : 연산할 도형 데이터의 위치
RetShape : 결과값을 저장할 도형 데이터의 위치
X1 : 자를영역의 X좌표 범위의 최솟값 (상수/V/VA)
X2 : 자를영역의 X좌표 범위의 최댓값 (상수/V/VA)

Y1 : 자를영역의 Y좌표 범위의 최솟값 (상수/V/VA)
Y2 : 자를영역의 Y좌표 범위의 최댓값 (상수/V/VA)
※ (X,Y) ∈ ([X1,X2],[Y1,Y2])인 직사각형 영역이 자를영역임
Ex) [예제 11-6] 참고

500

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ CBPlot 관련 함수 (STRCtrig 필수) ｡+.ﾟCB_CropPath(Path,OutSide,Shape,RetShape)
: 도형을 Path영역으로 잘라냄 (잘라내고 남은 부분은 버려짐)
Shape : 연산할 도형 데이터의 위치

RetShape : 결과값을 저장할 도형 데이터의 위치
Path : 자를영역을 설정할 Path데이터의 위치
Outside : 0입력시 내부영역을, 1입력시 외부영역을 잘라냄
(비우면 0으로 입력, 상수/V/VA)
Ex) [예제 11-7] 참고
CB_CropGraph(CropFunc,Sign,Shape,RetShape)
: 2차원 음함수를 기준으로 구분되는 영역으로 잘라냄

Shape : 연산할 도형 데이터의 위치
RetShape : 결과값을 저장할 도형 데이터의 위치
CropFunc : 자를영역을 구분할 음함수 (CFunc 입력)
Sign : 자를영역의 음함수의 부호 설정 (0입력시 >, 1입력시 <, 상수/V/VA)
※ CropFunc 입력법 : InitCFunc의 리턴값 입력
Parameter는 X, Y로 2개 전달됨
첫번째 리턴값을 해당 함수의 결과값으로 인식함 (리턴값의 부호로 잘라낼 영역을 결정함)
Ex) [예제 11-7] 참고

501

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ CBPlot 관련 함수 (STRCtrig 필수) ｡+.ﾟCB_SetNumber(Number,Shape)
: 도형 데이터의 총 점 개수를 설정함
Shape : 연산할 도형 데이터의 위치

Number : 설정할 점 개수 (상수/V/VA)
Ex) [예제 11-8] 참고
※ 실시간 도형 데이터 편집함수를 사용하면 RetShape에 입력한 도형데이터의 총 점 개수가 바뀜
(만약 총 점 개수보다 해당 도형 데이터에 할당된 공간의 크기가 작으면 연산 도중에 중단됨)
CB_Set(Index,X,Y,Shape)
: 도형 데이터의 Index번째 점의 좌표를 변경함
Shape : 연산할 도형 데이터의 위치

Index : 좌표를 변경할 점의 위치 (0부터 1번째 점, 상수/V/VA)
X : 변경할 X좌표값 (상수/V/VA)
Y : 변경할 Y좌표값 (상수/V/VA)
Ex) [예제 11-8] 참고
CB_Copy(Shape,RetShape)
: 도형 데이터 전체를 다른 도형데이터 위치에 그대로 복사함
Shape : 복사할 도형 데이터의 위치

RetShape : 저장할 도형 데이터의 위치
※ 총 점 개수도 같이 복사됨
Ex) [예제 11-8] 참고
CB_Add(X,Y,Shape)
: 도형에 점 데이터를 추가함 (A+Point)
Shape : 연산할 도형 데이터의 위치
X : 추가할 점의 X좌표값 (상수/V/VA)

Y : 추가할 점의 Y좌표값 (상수/V/VA)
Ex) [예제 11-8] 참고

502

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ CBPlot 관련 함수 (STRCtrig 필수) ｡+.ﾟCB_Fill(startX,startY,sizeX,sizeY,numX,numY,Shape)
: 직교좌표 내부영역을 직각 격자모양으로 칠함
Shape : 연산할 도형 데이터의 위치

startX : 칠할영역의 X좌표 시작지점 (Xmin, 상수/V/VA)
startY : 칠할영역의 Y좌표 시작지점 (Ymin, 상수/V/VA)
sizeX : 점 사이의 X좌표 간격 (상수/V/VA)
sizeY : 점 사이의 Y좌표 간격 (상수/V/VA)
numX : X축으로 찍을 점의 개수 (가로갯수, 상수/V/VA)
numY : Y축으로 찍을 점의 개수 (세로갯수, 상수/V/VA)
※ (X,Y) ∈ ([Xmin,Xmax],[Ymin,Ymax])인 직사각형 영역이 칠할영역
Ex) [예제 11-9] 참고
CB_Draw(startX,startY,sizeX,sizeY,num,Shape)
: 도형 데이터에 반직선을 추가함 (직교좌표 전용)
Shape : 연산할 도형 데이터의 위치
startX : 반직선 시작점의 X좌표 (상수/V/VA)
startY : 반직선 시작점의 Y좌표 (상수/V/VA)
sizeX : 반직선 점 사이의 X좌표 간격 (상수/V/VA)
sizeY : 반직선 점 사이의 Y좌표 간격 (상수/V/VA)

num : 찍을 점의 개수 (반직선 위의 점, 상수/V/VA)
※ 그려지는 반직선은 시작점 (startX,startY}, 기울기 (sizeY/sizeX)를 이루는 num개로 이루어진 선분
Ex) [예제 11-9] 참고
CB_Draw2(startX,startY,sizeX,sizeY,num,Shape)
: 도형 데이터에 직선을 추가함 (직교좌표 전용)
Shape : 연산할 도형 데이터의 위치
startX : 직선 시작점의 X좌표 (상수/V/VA)

startY : 직선 시작점의 Y좌표 (상수/V/VA)
sizeX : 직선 점 사이의 X좌표 간격 (상수/V/VA)
sizeY : 직선 점 사이의 Y좌표 간격 (상수/V/VA)
num : 찍을 점의 개수 (직선 위의 점, 상수/V/VA)
※ 그려지는 직선은 시작점 (startX,startY}, 기울기 (sizeY/sizeX)를 이루는 2*num-1개로 이루어진 선분

Ex) [예제 11-9] 참고
503

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ CBPlot 관련 함수 (STRCtrig 필수) ｡+.ﾟCB_Overlap(Shape,RetShape)
CB_OverlapX(ShapeA,ShapeB,RetShape)
: 두 도형을 겹침 (A+B)

RetShape : 결과값을 저장할 도형 데이터의 위치
(일반함수) Shape : 연산할 도형 데이터의 위치 (RetShape += Shape)
(X함수) ShapeA : 대상 도형 데이터의 위치
(X함수) ShapeB : 겹칠 도형 데이터의 위치 (RetShape = ShapeA + ShapeB)
Ex) [예제 11-10] 참고
CB_Merge(SizeX,SizeY,Shape,RetShape)
CB_MergeX(SizeX,SizeY,ShapeA,ShapeB,RetShape)

: 두 도형을 합침 (A∪B) - 중복된 영역은 제거됨
RetShape : 결과값을 저장할 도형 데이터의 위치
(일반함수) Shape : 연산할 도형 데이터의 위치 (RetShape += Shape)
(X함수) ShapeA : 대상 도형 데이터의 위치
(X함수) ShapeB : 합칠 도형 데이터의 위치 (RetShape = ShapeA + ShapeB)
SizeX : 한 점의 X좌표 크기 (중복 영역 X좌표 판정크기, 상수/V/VA)
SizeY : 한 점의 Y좌표 크기 (중복 영역 Y좌표 판정크기, 상수/V/VA)
※ (일반함수) RetShape를 필터(교집합이 아닌점)로 Shape의 점을 RetShape에 복사함
※ (X함수) ShapeA를 복사한 뒤 ShapeA를 필터(교집합이 아닌점)로 ShapeB의 점을 RetShape에 복사함

Ex) [예제 11-10] 참고
CB_Intersect(SizeX,SizeY,ShapeA,ShapeB,RetShape)
: 두 도형의 겹친 영역만 남김 (A∩B) - 중복되지 않은 영역은 제거됨
RetShape : 결과값을 저장할 도형 데이터의 위치
ShapeA : 대상 도형 데이터의 위치
ShapeB : 겹칠 도형 데이터의 위치

SizeX : 한 점의 X좌표 크기 (중복 영역 X좌표 판정크기, 상수/V/VA)
SizeY : 한 점의 Y좌표 크기 (중복 영역 Y좌표 판정크기, 상수/V/VA)
※ ShapeA를 필터(교집합)로 ShapeB의 점을 RetShape에 복사함
Ex) [예제 11-10] 참고

504

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ CBPlot 관련 함수 (STRCtrig 필수) ｡+.ﾟCB_Subtract(SizeX,SizeY,ShapeA,ShapeB,RetShape)
: 한 도형에서 겹친 영역을 지움 (A-B)
RetShape : 결과값을 저장할 도형 데이터의 위치

ShapeA : 대상 도형 데이터의 위치
ShapeB : 필터 도형 데이터의 위치
SizeX : 한 점의 X좌표 크기 (중복 영역 X좌표 판정크기, 상수/V/VA)
SizeY : 한 점의 Y좌표 크기 (중복 영역 Y좌표 판정크기, 상수/V/VA)
※ ShapeB를 필터(교집합이 아닌점)로 ShapeA의 점을 RetShape에 복사함
Ex) [예제 11-11] 참고
CB_Xor(SizeX,SizeY,ShapeA,ShapeB,RetShape)
: 두 도형의 겹친 영역만을 제거하고 합침 (A-B ∪ B-A)
RetShape : 결과값을 저장할 도형 데이터의 위치
ShapeA : 대상 도형 데이터의 위치
ShapeB : 합칠 도형 데이터의 위치
SizeX : 한 점의 X좌표 크기 (중복 영역 X좌표 판정크기, 상수/V/VA)
SizeY : 한 점의 Y좌표 크기 (중복 영역 Y좌표 판정크기, 상수/V/VA)
Ex) [예제 11-11] 참고
CB_RemoveStack(Priority,SizeX,SizeY,Shape,RetShape)
: 도형 내부에서 겹친 점을 제거함
RetShape : 결과값을 저장할 도형 데이터의 위치
Shape : 연산할 도형 데이터의 위치
SizeX : 한 점의 X좌표 크기 (중복 영역 X좌표 판정크기, 상수/V/VA)
SizeY : 한 점의 Y좌표 크기 (중복 영역 Y좌표 판정크기, 상수/V/VA)
Priority : 중복제거 순서 우선순위 설정 (0입력시 앞에서부터 제거, 1입력시 뒤에서부터 제거, 상수/V/VA)

Ex) [예제 11-11] 참고

CB_Delete(X,Y,SizeX,SizeY,Shape)
: 도형에 점 데이터를 삭제함 (A-Point)
Shape : 연산할 도형 데이터의 위치
X : 삭제할 점의 X좌표 (상수/V/VA) / Y : 삭제할 점의 Y좌표 (상수/V/VA)
SizeX : 한 점의 X좌표 크기 (중복 영역 X좌표 판정크기, 상수/V/VA)
SizeY : 한 점의 Y좌표 크기 (중복 영역 Y좌표 판정크기, 상수/V/VA)
505
입력된 점의 좌표와 중복된 좌표(판정크기 이내 존재)를 가진 점이 Shape에 존재할 경우 해당 점을 삭제함

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ CBPlot 관련 함수 (STRCtrig 필수) ｡+.ﾟCB_GetXmax(Shape,Output)
CB_GetYmax(Shape,Output)
CB_GetXmin(Shape,Output)

CB_GetYmin(Shape,Output)
: 도형 데이터 내부 점들의 최소 또는 최대 X,Y좌표값을 구함
Shape : 대상 도형 데이터의 위치
Output : 최소 또는 최대 X,Y좌표값을 저장할곳 (상수/V/Mem/VA/A)
Xmax함수 : X좌표 최대값 / Ymax함수 : Y좌표 최대값
Xmin함수 : X좌표 최소값 / Ymin함수 : Y좌표 최소값
Ex) [예제 11-12] 참고
CB_GetXCntr(Shape,Output,maxOutput,minOutput)
CB_GetYCntr(Shape,Output,maxOutput,minOutput)
: 도형 데이터의 중심 좌표값을 구함
Shape : 대상 도형 데이터의 위치
Output : 최소 또는 최대 X,Y좌표값을 저장할곳 (상수/V/Mem/VA/A)
maxOutput : 최대 X,Y좌표값을 저장할곳 (상수/V/Mem/VA/A)
minOutput : 최소 X,Y좌표값을 저장할곳 (상수/V/Mem/VA/A)
XCntr함수 : 중심 X좌표 / YCntr함수 : 중심 Y좌표
※ 중심 좌표를 구하는 과정에서 최대 및 최소값도 함께 구함

Ex) [예제 11-12] 참고
CB_GetXLoc(Index,Shape,Output)
CB_GetYLoc(Index,Shape,Output)
: 도형 데이터의 Index번째 점의 좌표를 구함
Shape : 대상 도형 데이터의 위치
Output : 점의 X,Y좌표값을 저장할곳 (상수/V/Mem/VA/A)
Index : 좌표를 구할 점의 위치 (0부터 1번째 점, 상수/V/VA)
XLoc함수 : X좌표를 구함 / YLoc함수 : Y좌표를 구함

Ex) [예제 11-12] 참고
CB_GetNumber(Shape,Output)
: 도형 데이터의 총 점 개수를 구함
Shape : 대상 도형 데이터의 위치
Output : 도형의 총 점 개수를 저장할곳 (상수/V/Mem)
Ex) [예제 11-12] 참고

506

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ CBPlot 관련 함수 (STRCtrig 필수) ｡+.ﾟCB_TGetNumber(Shape,Output)
: LoopMax 데이터의 총 항목의 개수를 구함
Shape : 대상 LoopMax 데이터의 위치

Output : LoopMax 데이터의 총 항목의 개수를 저장할곳 (상수/V/Mem/VA/A)
※ LoopMax데이터는 첫번째부터 순서대로 첫번째 도형데이터와 1:1로 연결됨 (해당 도형 출력시 사용)
(Shape 입력칸에 N입력시 N번째 LoopMax 데이터의 위치가 입력됨)
Ex) [예제 11-13] 참고
CB_TGetLoc(Index,Shape,Output)
: LoopMax 데이터의 Index번째 항목의 값을 구함
Shape : 대상 LoopMax 데이터의 위치

Output : 항목의 값을 저장할곳 (상수/V/Mem/VA/A)
Index : 항목의 값을 구할 위치 (1부터 1번째 점, 상수/V/VA)
※ LoopMax데이터는 Index가 1부터 첫번째 항목(틱당 생성할 수량)이 존재하며
Index가 0인 지점에는 LoopMax의 총 항목의 개수가 위치함
Ex) [예제 11-13] 참고
CB_TSetNumber(Number,Shape)
: LoopMax 데이터의 총 항목의 개수를 변경함

Shape : 대상 LoopMax 데이터의 위치
Number : LoopMax 데이터의 총 항목의 개수를 변경할값 (상수/V/VA)
Ex) [예제 11-13] 참고
CB_TSet(Index,LoopMax,Shape)
: LoopMax 데이터의 Index번째 항목의 값을 변경함
Shape : 대상 LoopMax 데이터의 위치
LoopMax : 항목의 변경할 값 (해당 틱에 생성할 수량, 상수/V/VA)

Index : 항목의 값을 변경할 위치 (1부터 1번째 점, 상수/V/VA)
Ex) [예제 11-13] 참고

507

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ CBPlot 관련 함수 (STRCtrig 필수) ｡+.ﾟCB_TAdd(LoopMax,Shape)
: LoopMax 데이터에 항목을 추가함
Shape : 대상 LoopMax 데이터의 위치

LoopMax : 추가할 항목의 값 (해당 틱에 생성할 수량, 상수/V/VA)
Ex) [예제 11-14] 참고
CB_TDelete(Index,Shape)
: LoopMax 데이터에 항목을 삭제함
Shape : 대상 LoopMax 데이터의 위치
Index : 삭제할 항목의 위치 (1부터 1번째 점, 상수/V/VA)
Ex) [예제 11-14] 참고
CB_TCopy(Shape,RetShape)
: LoopMax 데이터 전체를 다른 LoopMax 데이터 위치에 그대로 복사함
Shape : 복사할 LoopMax 데이터의 위치
RetShape : 저장할 LoopMax 데이터의 위치
※ 총 항목의 개수도 같이 복사됨
Ex) [예제 11-14] 참고

508

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ CBPlot 관련 함수 (STRCtrig 필수) ｡+.ﾟCB_Sort(Sfunc,Direction,Shape,RetShape)
: 도형 데이터를 좌표계 함수값으로 정렬함
Shape : 연산할 도형 데이터의 위치
RetShape : 결과값을 저장할 도형 데이터의 위치
Sfunc : 정렬에 사용할 좌표계 함수 (CFunc 입력)
Direction : 정렬의 방향 (0 = 오름차순 / 1 = 내림차순, 상수/V/VA)
※ SFunc 입력법 : InitCFunc의 리턴값 입력
Parameter는 X, Y로 2개 전달됨
첫번째 리턴값을 해당 함수의 결과값으로 인식함 (리턴값으로 정렬의 순서를 결정함)
※ CB_Sort류 함수는 1차 정렬만 지원함 (F(x,y) = k로 한번만 정렬)

Ex) [예제 11-15] 참고
CB_SortI(Sfunc,Direction,Shape,RetShape)
: 도형 데이터를 인덱스 함수값으로 정렬함
Shape : 연산할 도형 데이터의 위치
RetShape : 결과값을 저장할 도형 데이터의 위치
Sfunc : 정렬에 사용할 인덱스 함수 (CFunc 입력, 0부터 시작함)
Direction : 정렬의 방향 (0 = 오름차순 / 1 = 내림차순, 상수/V/VA)
※ SFunc 입력법 : InitCFunc의 리턴값 입력
Parameter는 Index로 1개 전달됨
첫번째 리턴값을 해당 함수의 결과값으로 인식함 (리턴값으로 정렬의 순서를 결정함)
Ex) [예제 11-15] 참고

509

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ CBPlot 관련 함수 (STRCtrig 필수) ｡+.ﾟCB_NSort(Func,Step,Sfunc,Direction,Shape,RetShape)
: 도형 데이터를 좌표계 함수값으로 정렬후 Step개의 묶음으로 LoopMax 데이터를 생성함
Shape : 연산할 도형 데이터의 위치
RetShape : 결과값을 저장할 도형 데이터의 위치
Sfunc : 정렬에 사용할 좌표계 함수 (CFunc 입력)
Direction : 정렬의 방향 (0 = 오름차순 / 1 = 내림차순, 상수/V/VA)
Func : LoopMax 데이터의 각 항목의 크기를 결정할 함수 (CFunc 입력, 1부터시작함)
Step : LoopMax 데이터의 총 항목 개수 (상수/V/VA)
※ SFunc 입력법 : InitCFunc의 리턴값 입력
Parameter는 X, Y로 2개 전달됨

첫번째 리턴값을 해당 함수의 결과값으로 인식함 (리턴값으로 정렬의 순서를 결정함)
※ Func 입력법 : InitCFunc의 리턴값 입력
Parameter는 Index로 1개 전달됨
첫번째 리턴값을 해당 함수의 결과값으로 인식함 (리턴값으로 LoopMax의 각 항목의 크기를 결정함)

※ Func 미입력시 Shape[1]/Step개로 균등하게 LoopMax 데이터를 생성함
※ Func 입력시 LoopMax 데이터의 각 항목 크기는 Shape[1]/Step * f(i)/(f(1)+…+f(Step))으로 결정됨

※ Func의 함수값은 항상 0 이상 이여야 함
Ex) [예제 11-16] 참고
CB_NSortI(Func,Step,Sfunc,Direction,Shape,RetShape)
: 도형 데이터를 인덱스 함수값으로 정렬후 Step개의 묶음으로 LoopMax 데이터를 생성함
Shape : 연산할 도형 데이터의 위치
RetShape : 결과값을 저장할 도형 데이터의 위치
Sfunc : 정렬에 사용할 인덱스 함수 (CFunc 입력, 0부터 시작함)
Direction : 정렬의 방향 (0 = 오름차순 / 1 = 내림차순, 상수/V/VA)
Func : LoopMax 데이터의 각 항목의 크기를 결정할 함수 (CFunc 입력, 1부터 시작함)
Step : LoopMax 데이터의 총 항목 개수 (상수/V/VA)
※ SFunc 입력법 : InitCFunc의 리턴값 입력
Parameter는 Index로 1개 전달됨
첫번째 리턴값을 해당 함수의 결과값으로 인식함 (리턴값으로 정렬의 순서를 결정함)
Ex) [예제 11-16] 참고
510

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ CBPlot 관련 함수 (STRCtrig 필수) ｡+.ﾟCB_TSort(Func,Step,Void,Sfunc,Direction,Shape,RetShape)
: 도형 데이터를 좌표계 함수값으로 정렬함 (정렬식의 함수값으로 LoopMax 데이터를 생성함)
Shape : 연산할 도형 데이터의 위치

RetShape : 결과값을 저장할 도형 데이터의 위치
Sfunc : 정렬에 사용할 좌표계 함수 (CFunc 입력)
Direction : 정렬의 방향 (0 = 오름차순 / 1 = 내림차순, 상수/V/VA)
Func : LoopMax 데이터의 각 항목의 크기를 결정할 함수 (CFunc 입력, 1부터 시작함)
Step : LoopMax 데이터의 총 항목 개수 (상수/V/VA)
Void : 1입력시 LoopMax 데이터 중 0을 포함함 (0입력시 미포함, 상수/V/VA)
※ SFunc 입력법 : InitCFunc의 리턴값 입력
Parameter는 X, Y로 2개 전달됨

첫번째 리턴값을 해당 함수의 결과값으로 인식함 (리턴값으로 정렬의 순서를 결정함)
※ Func 입력법 : InitCFunc의 리턴값 입력
Parameter는 Index로 1개 전달됨
첫번째 리턴값을 해당 함수의 결과값으로 인식함 (리턴값으로 LoopMax의 각 항목의 크기를 결정함)
※ Func 미입력시 f-1((정렬식의 함수값의 범위)/Step)개로 LoopMax 데이터를 생성함
※ Func 입력시 LoopMax 데이터의 각 항목 크기는
f-1((정렬식의 함수값의 범위)/Step) * f(i)/(f(1)+…+f(Step))으로 결정됨
※ Func의 함수값은 항상 0 이상 이여야 함

Ex) [예제 11-17] 참고
CB_TSortI(Func,Step,Void,Sfunc,Direction,Shape,RetShape)
: 도형 데이터를 인덱스 함수값으로 정렬함 (정렬식의 함수값으로 LoopMax 데이터를 생성함)
Shape : 연산할 도형 데이터의 위치
RetShape : 결과값을 저장할 도형 데이터의 위치
Sfunc : 정렬에 사용할 인덱스 함수 (CFunc 입력, 0부터 시작함)
Direction : 정렬의 방향 (0 = 오름차순 / 1 = 내림차순, 상수/V/VA)

Func : LoopMax 데이터의 각 항목의 크기를 결정할 함수 (CFunc 입력, 1부터 시작함)
Step : LoopMax 데이터의 총 항목 개수 (상수/V/VA)
Void : 1입력시 LoopMax 데이터 중 0을 포함함 (0입력시 미포함, 상수/V/VA)
※ SFunc 입력법 : InitCFunc의 리턴값 입력
Parameter는 Index로 1개 전달됨
첫번째 리턴값을 해당 함수의 결과값으로 인식함 (리턴값으로 정렬의 순서를 결정함)
Ex) [예제 11-17] 참고

511

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ CBPlot 관련 함수 (STRCtrig 필수) ｡+.ﾟCB_Split(Preset,Looper,Overwrite,Shape,RetShape)
: 도형 데이터를 인덱스를 기준으로 분할함 (A→B)
Shape : 연산할 도형 데이터의 위치
RetShape : 결과값을 저장할 도형 데이터의 위치
Preset : {추출할 횟수 n (상수/V/VA), 선택함수 f(i) (CFunc)} 형식으로 입력
(I = 1 ~ n까지 인덱스f(i) 인 점을 추출해서 복사함)
Looper : 1입력시 f(i)의 함수값이 Shape의 범위(1~Shape[1])를 넘어갈때
해당 함수 값에 Mod(Shape[1])를 적용함 (0입력시 또는 미입력시 적용X, 상수/V/VA)
Overwrite : 숫자로 입력 (미입력시 적용X, 상수/V/VA)
0 : 미적용 (중복 선택을 허용함)

1 : 중복 선택 적용 대상을 한칸 뒤의 점으로 바꿈 (맨 뒤일 경우 맨 앞의 점으로 교체)
-1 : 중복 선택 적용 대상을 한칸 앞의 점으로 바꿈 (맨 앞일 경우 맨 뒤의 점으로 교체)
※ f(i) 입력법 : InitCFunc의 리턴값 입력
Parameter는 Index로 1개 전달됨 (1부터 시작함)
첫번째 리턴값을 해당 함수의 결과값으로 인식함 (리턴값으로 추출할 점을 선택함)
※ Looper 미적용시 f(i)의 값이 Shape의 범위를 넘어갈 때는 순서를 교체하지 않음
※ Overwrite 적용시 중복이 발생하지 않는 점이 없을 경우 순서를 교체하지 않음 (교체 실행X)
Ex) [예제 11-18] 참고

CB_Shuffle(Start,End,Shape)
: 도형 데이터를 인덱스 순서를 무작위로 섞음
Shape : 연산할 도형 데이터의 위치
Start : 섞을 순서의 시작지점 인덱스
End : 섞을 순서의 끝지점 인덱스
※ SeedSwitch의 난수값으로 입력된 범위 전체를 2번씩 섞음
CB_Reverse(Start,End,Shape)
: 도형 데이터를 인덱스 순서를 뒤집음
Shape : 연산할 도형 데이터의 위치
Start : 순서를 뒤집을 시작지점 인덱스
End : 순서를 뒤집을 끝지점 인덱스
Ex) [예제 11-18] 참고

512

------------------------------------------------------------------------------------------

『 # : 부록 설명 (예제 도형) 』

------------------------------------------------------------------------------------------

#-1. SnowFlake (눈송이 모양) - 140점
local S1, S2, S3, S4
S1 = CSMakeStar(6,180,56,30,73,13)
S2 = CSMakeLineX(6,64,0,9*6,0)
S3 = CS_Merge(S1,S2,16,1)
S1 = CSMakeLineX(1,56,60,3,0)
S1 = CS_MoveXY(S1,nil,-32*6.5)
S1 = CS_Kaleidoscope(S1,6,-60,1)
S4 = CS_Merge(S1,S3,16,1)
CSSaveWithName("SnowFlake",0,S4,"SnowFlake")

-----------------------------------------------------------------------------------------#-2. Tiger (호랑이 모양) - 944점
Tiger = {944,{45, 7},{46, 7},{47, 7},{16, 8},{17, 8},{21, 8},{43, 8},{44, 8},{46, 8},{47, 8},{48, 8},{49, 8},{50, 8},{15, 9},{16, 9},{19, 9},{21, 9},{22, 9},{27, 9},{28, 9},{29, 9},{30, 9},{31, 9},{32, 9},{33, 9},{34, 9},{35, 9},{36, 9},{42, 9},{45, 9},{46, 9},{47, 9},{48, 9},{49, 9},{50, 9},{15, 10},{18, 10},
{19, 10},{20, 10},{22, 10},{23, 10},{24, 10},{25, 10},{26, 10},{27, 10},{28, 10},{30, 10},{31, 10},{32, 10},{33, 10},{34, 10},{35, 10},{36, 10},{37, 10},{40, 10},{41, 10},{42, 10},{43, 10},{44, 10},{45, 10},{46, 10},{47, 10},{50, 10},{15, 11},{18, 11},{19, 11},{20, 11},{21, 11},{22, 11},{23, 11},
{24, 11},{29, 11},{30, 11},{31, 11},{33, 11},{34, 11},{35, 11},{36, 11},{37, 11},{38, 11},{39, 11},{40, 11},{42, 11},{43, 11},{44, 11},{45, 11},{46, 11},{47, 11},{48, 11},{50, 11},{15, 12},{17, 12},{18, 12},{19, 12},{20, 12},{21, 12},{22, 12},{23, 12},{25, 12},{26, 12},{27, 12},{28, 12},{29, 12},
{30, 12},{33, 12},{35, 12},{36, 12},{37, 12},{38, 12},{42, 12},{43, 12},{44, 12},{45, 12},{46, 12},{47, 12},{48, 12},{51, 12},{14, 13},{15, 13},{18, 13},{19, 13},{20, 13},{21, 13},{22, 13},{23, 13},{24, 13},{25, 13},{32, 13},{33, 13},{41, 13},{42, 13},{43, 13},{44, 13},{45, 13},{46, 13},{47, 13},
{48, 13},{50, 13},{15, 14},{18, 14},{19, 14},{20, 14},{21, 14},{22, 14},{23, 14},{24, 14},{25, 14},{29, 14},{31, 14},{32, 14},{33, 14},{34, 14},{35, 14},{36, 14},{39, 14},{40, 14},{43, 14},{44, 14},{45, 14},{46, 14},{47, 14},{48, 14},{49, 14},{50, 14},{15, 15},{16, 15},{18, 15},{19, 15},{20, 15},
{21, 15},{22, 15},{24, 15},{25, 15},{26, 15},{27, 15},{28, 15},{29, 15},{31, 15},{32, 15},{33, 15},{36, 15},{37, 15},{40, 15},{44, 15},{45, 15},{46, 15},{47, 15},{48, 15},{49, 15},{50, 15},{16, 16},{19, 16},{20, 16},{21, 16},{22, 16},{25, 16},{26, 16},{27, 16},{31, 16},{32, 16},{33, 16},{34, 16},
{35, 16},{40, 16},{41, 16},{44, 16},{45, 16},{46, 16},{47, 16},{48, 16},{49, 16},{16, 17},{17, 17},{18, 17},{19, 17},{20, 17},{21, 17},{24, 17},{25, 17},{28, 17},{29, 17},{30, 17},{31, 17},{33, 17},{34, 17},{35, 17},{36, 17},{37, 17},{40, 17},{41, 17},{42, 17},{43, 17},{47, 17},{48, 17},{49, 17},
{17, 18},{18, 18},{19, 18},{22, 18},{23, 18},{24, 18},{25, 18},{27, 18},{28, 18},{29, 18},{33, 18},{36, 18},{37, 18},{41, 18},{43, 18},{44, 18},{48, 18},{49, 18},{50, 18},{16, 19},{17, 19},{18, 19},{21, 19},{22, 19},{24, 19},{31, 19},{32, 19},{33, 19},{34, 19},{41, 19},{42, 19},{44, 19},{45, 19},
{49, 19},{50, 19},{15, 20},{16, 20},{17, 20},{20, 20},{21, 20},{23, 20},{28, 20},{29, 20},{30, 20},{31, 20},{33, 20},{34, 20},{35, 20},{38, 20},{42, 20},{43, 20},{45, 20},{50, 20},{51, 20},{15, 21},{16, 21},{19, 21},{20, 21},{22, 21},{23, 21},{26, 21},{27, 21},{28, 21},{31, 21},{33, 21},{34, 21},
{37, 21},{38, 21},{39, 21},{42, 21},{43, 21},{46, 21},{47, 21},{51, 21},{15, 22},{18, 22},{19, 22},{22, 22},{23, 22},{26, 22},{30, 22},{31, 22},{32, 22},{33, 22},{34, 22},{35, 22},{37, 22},{41, 22},{42, 22},{45, 22},{47, 22},{48, 22},{51, 22},{52, 22},{14, 23},{15, 23},{18, 23},{19, 23},{23, 23},
{24, 23},{25, 23},{29, 23},{30, 23},{31, 23},{34, 23},{35, 23},{38, 23},{39, 23},{40, 23},{41, 23},{42, 23},{45, 23},{47, 23},{48, 23},{52, 23},{14, 24},{17, 24},{18, 24},{20, 24},{22, 24},{23, 24},{25, 24},{26, 24},{27, 24},{29, 24},{30, 24},{35, 24},{38, 24},{42, 24},{43, 24},{45, 24},{46, 24},
{48, 24},{17, 25},{19, 25},{20, 25},{22, 25},{23, 25},{41, 25},{42, 25},{43, 25},{45, 25},{46, 25},{48, 25},{49, 25},{16, 26},{17, 26},{19, 26},{20, 26},{22, 26},{24, 26},{25, 26},{26, 26},{27, 26},{37, 26},{38, 26},{39, 26},{40, 26},{41, 26},{43, 26},{46, 26},{48, 26},{49, 26},{53, 26},{54, 26},
{16, 27},{17, 27},{19, 27},{22, 27},{23, 27},{24, 27},{25, 27},{26, 27},{27, 27},{37, 27},{38, 27},{39, 27},{40, 27},{41, 27},{42, 27},{43, 27},{46, 27},{49, 27},{54, 27},{13, 28},{16, 28},{19, 28},{22, 28},{24, 28},{25, 28},{26, 28},{27, 28},{28, 28},{36, 28},{37, 28},{38, 28},{39, 28},{40, 28},
{41, 28},{43, 28},{46, 28},{49, 28},{54, 28},{55, 28},{12, 29},{13, 29},{16, 29},{19, 29},{22, 29},{25, 29},{27, 29},{28, 29},{36, 29},{37, 29},{40, 29},{43, 29},{46, 29},{49, 29},{52, 29},{55, 29},{12, 30},{15, 30},{16, 30},{19, 30},{23, 30},{25, 30},{28, 30},{36, 30},{42, 30},{46, 30},{49, 30},
{50, 30},{52, 30},{55, 30},{12, 31},{15, 31},{16, 31},{19, 31},{23, 31},{28, 31},{36, 31},{41, 31},{42, 31},{46, 31},{49, 31},{52, 31},{55, 31},{12, 32},{15, 32},{16, 32},{19, 32},{20, 32},{24, 32},{28, 32},{40, 32},{41, 32},{45, 32},{46, 32},{49, 32},{52, 32},{55, 32},{12, 33},{13, 33},{15, 33},
{16, 33},{17, 33},{19, 33},{20, 33},{21, 33},{22, 33},{23, 33},{24, 33},{25, 33},{39, 33},{42, 33},{44, 33},{45, 33},{46, 33},{48, 33},{49, 33},{52, 33},{53, 33},{55, 33},{56, 33},{12, 34},{16, 34},{17, 34},{19, 34},{20, 34},{21, 34},{22, 34},{25, 34},{40, 34},{41, 34},{43, 34},{44, 34},{45, 34},
{46, 34},{48, 34},{49, 34},{52, 34},{53, 34},{55, 34},{56, 34},{11, 35},{12, 35},{16, 35},{17, 35},{18, 35},{20, 35},{21, 35},{23, 35},{24, 35},{28, 35},{29, 35},{35, 35},{36, 35},{41, 35},{42, 35},{45, 35},{47, 35},{48, 35},{49, 35},{52, 35},{53, 35},{56, 35},{11, 36},{12, 36},{16, 36},{17, 36},
{18, 36},{21, 36},{22, 36},{23, 36},{28, 36},{36, 36},{42, 36},{44, 36},{47, 36},{48, 36},{49, 36},{52, 36},{56, 36},{11, 37},{12, 37},{13, 37},{16, 37},{17, 37},{18, 37},{19, 37},{22, 37},{28, 37},{43, 37},{44, 37},{45, 37},{46, 37},{47, 37},{48, 37},{49, 37},{52, 37},{56, 37},{11, 38},{12, 38},
{13, 38},{17, 38},{18, 38},{19, 38},{21, 38},{22, 38},{43, 38},{44, 38},{45, 38},{46, 38},{47, 38},{48, 38},{52, 38},{53, 38},{56, 38},{57, 38},{10, 39},{11, 39},{12, 39},{13, 39},{17, 39},{18, 39},{19, 39},{20, 39},{21, 39},{22, 39},{23, 39},{25, 39},{28, 39},{29, 39},{35, 39},{36, 39},{39, 39},
{42, 39},{43, 39},{44, 39},{46, 39},{47, 39},{52, 39},{55, 39},{56, 39},{57, 39},{9, 40},{10, 40},{11, 40},{12, 40},{13, 40},{18, 40},{19, 40},{20, 40},{22, 40},{23, 40},{26, 40},{29, 40},{30, 40},{31, 40},{32, 40},{34, 40},{35, 40},{39, 40},{40, 40},{42, 40},{43, 40},{46, 40},{51, 40},{52, 40},
{55, 40},{56, 40},{57, 40},{8, 41},{9, 41},{13, 41},{14, 41},{19, 41},{20, 41},{22, 41},{23, 41},{25, 41},{26, 41},{30, 41},{31, 41},{34, 41},{42, 41},{43, 41},{51, 41},{52, 41},{55, 41},{56, 41},{57, 41},{7, 42},{8, 42},{13, 42},{14, 42},{15, 42},{16, 42},{23, 42},{24, 42},{25, 42},{26, 42},{31, 42},
{32, 42},{33, 42},{37, 42},{38, 42},{39, 42},{42, 42},{43, 42},{49, 42},{50, 42},{51, 42},{55, 42},{56, 42},{57, 42},{5, 43},{6, 43},{7, 43},{14, 43},{15, 43},{16, 43},{17, 43},{18, 43},{19, 43},{23, 43},{24, 43},{27, 43},{28, 43},{29, 43},{32, 43},{36, 43},{37, 43},{38, 43},{40, 43},{41, 43},
{42, 43},{48, 43},{49, 43},{50, 43},{54, 43},{55, 43},{56, 43},{57, 43},{58, 43},{4, 44},{5, 44},{15, 44},{16, 44},{17, 44},{18, 44},{19, 44},{20, 44},{24, 44},{25, 44},{26, 44},{27, 44},{28, 44},{29, 44},{30, 44},{31, 44},{32, 44},{33, 44},{34, 44},{35, 44},{37, 44},{38, 44},{39, 44},{40, 44},
{41, 44},{42, 44},{45, 44},{46, 44},{47, 44},{48, 44},{49, 44},{54, 44},{55, 44},{56, 44},{58, 44},{59, 44},{3, 45},{4, 45},{16, 45},{17, 45},{18, 45},{19, 45},{20, 45},{21, 45},{24, 45},{25, 45},{26, 45},{27, 45},{28, 45},{31, 45},{32, 45},{33, 45},{34, 45},{36, 45},{37, 45},{38, 45},{39, 45},
{40, 45},{41, 45},{42, 45},{43, 45},{44, 45},{45, 45},{46, 45},{47, 45},{48, 45},{53, 45},{54, 45},{55, 45},{56, 45},{59, 45},{15, 46},{16, 46},{17, 46},{19, 46},{20, 46},{21, 46},{22, 46},{23, 46},{24, 46},{25, 46},{26, 46},{38, 46},{39, 46},{40, 46},{41, 46},{42, 46},{43, 46},{44, 46},{45, 46},
{46, 46},{52, 46},{53, 46},{54, 46},{55, 46},{58, 46},{59, 46},{15, 47},{20, 47},{21, 47},{22, 47},{23, 47},{24, 47},{25, 47},{26, 47},{27, 47},{38, 47},{39, 47},{40, 47},{41, 47},{42, 47},{43, 47},{44, 47},{45, 47},{51, 47},{52, 47},{53, 47},{54, 47},{55, 47},{58, 47},{59, 47},{60, 47},{22, 48},
{23, 48},{24, 48},{25, 48},{26, 48},{27, 48},{28, 48},{37, 48},{38, 48},{39, 48},{40, 48},{41, 48},{42, 48},{43, 48},{44, 48},{50, 48},{51, 48},{52, 48},{53, 48},{54, 48},{57, 48},{58, 48},{59, 48},{60, 48},{23, 49},{24, 49},{25, 49},{26, 49},{27, 49},{28, 49},{29, 49},{30, 49},{35, 49},{36, 49},
{37, 49},{38, 49},{39, 49},{41, 49},{42, 49},{50, 49},{51, 49},{52, 49},{53, 49},{57, 49},{59, 49},{60, 49},{24, 50},{25, 50},{26, 50},{29, 50},{30, 50},{31, 50},{32, 50},{33, 50},{34, 50},{35, 50},{36, 50},{37, 50},{49, 50},{50, 50},{51, 50},{52, 50},{56, 50},{25, 51},{26, 51},{34, 51},{35, 51},
{36, 51},{49, 51},{50, 51},{51, 51},{26, 52},{27, 52},{48, 52},{49, 52},{27, 53},{28, 53},{47, 53},{48, 53},{28, 54},{46, 54},{47, 54}}

------------------------------------------------------------------------------------------

513

------------------------------------------------------------------------------------------

『 G. CX Paint 예제 』

------------------------------------------------------------------------------------------

｡˙+ﾟ 0. 목차 ｡+.ﾟ
1장 : Shape 및 Path 데이터 구조
2장 : CSMake 함수 (Shape 생성)
3장 : CS_ 편집함수 (이미지 편집)
4장 : CSPlot 함수 (트리거 변환)
5장 : CSSave 함수 (파일 입출력)
6장 : 추가 CS함수 (확장 함수팩)
7장 : CA_ 실시간 편집함수 (어셈블러 필요)
8장 : CAPlot 함수 (어셈블러 필요)
9장 : CXPlot 및 3차원 도형함수 (어셈블러 필요)
10장 : 추가 고급 편집 함수 (v2.3 이상)

11장 : 추가 고급 실시간 편집 함수 (v2.4이상)
# : 부록 설명 (예제 도형)

514

------------------------------------------------------------------------------------------

『 1장 : Shape 및 Path 데이터 구조 』

------------------------------------------------------------------------------------------

[예제 1-1] Shape(Path)데이터 직접 생성 예제
local Shape1 = {5,{0,0},{32,32},{-32,32},{-32,-32},{32,-32}} -- X자 모양 점 5개
CSPlot(Shape1,P1,54,"Location 1",nil,1,32,P1) -- 유닛 생성
-----------------------------------------------------------------------------------------[예제 1-2] Shape(Path)데이터 원소 직접 추가/삭제
local Shape1 = {5,{0,0},{32,32},{-32,32},{-32,-32},{32,-32}} -- X자 모양 점 5개

table.remove(Shape1,2) -- {0,0} 삭제
Shape1[1] = Shape1[1] - 1 -- 점 갯수 1 감소
CSPlot(Shape1,P1,54,"Location 1",nil,1,32,P1) -- 유닛 생성
table.insert(Shape1,{64,0}) -- 마름모 모양 점 4개 추가
table.insert(Shape1,{-64,0}) -table.insert(Shape1,{0,64}) -table.insert(Shape1,{0,-64}) -Shape1[1] = Shape1[1] + 4 -- 점 갯수 4 증가
CSPlot(Shape1,P1,54,"Location 2",nil,1,32,P1) -- 유닛 생성
------------------------------------------------------------------------------------------

515

------------------------------------------------------------------------------------------

『 2장 : CSMake 함수 (Shape 생성) 』

------------------------------------------------------------------------------------------

[예제 2-1] CSMakePath()
Shape1 = CSMakePath({-160,0},{64,0},{64,64},{160,-32},{64,-128},{64,-64},{-160,-64}) -- →모양 Path

CSPlot(Shape1,P1,54,"Location 1",nil,1,32,P1) -- 유닛 생성
-----------------------------------------------------------------------------------------[예제 2-2] CSMakePathX()
local Temp1 = {}
for i = 0, 20 do
table.insert(Temp1,{i,i^2/16})
end
Shape1 = CSMakePathX(32,Temp1) -- y = x^2/16 Graph모양 Path(x=0~20,x간격1) + 32배 확대
CSPlot(Shape1,P1,54,"Location 2",nil,1,32,P1) -- 유닛 생성
-----------------------------------------------------------------------------------------[예제 2-3] CSMakePolygon(), CSMakePolygonX(), CSMakeStar(), CSMakeStarX()
Shape1 = CSMakePolygon(6,64,0,37,1) -- 6각형 (k=0, 1, 2, 3, ...)
CSPlot(Shape1,P1,54,"Location 1",nil,1,32,P1) -- 유닛 생성
Shape1 = CSMakePolygonX(6,64,30,54,0) -- 6각형 (k=1, 3, 5, ...)
CSPlot(Shape1,P1,54,"Location 2",nil,1,32,P1) -- 유닛 생성
Shape1 = CSMakeStar(6,180,64,0,73,1) -- 6각형 (k=0, 2, 4, 6, ...)

CSPlot(Shape1,P1,54,"Location 3",nil,1,32,P1) -- 유닛 생성
Shape1 = CSMakeStarX(6,180,64,30,108,0) -- 6각형 (k=2, 6, 10, ...)
CSPlot(Shape1,P1,54,"Location 4",nil,1,32,P1) -- 유닛 생성
------------------------------------------------------------------------------------------

516

------------------------------------------------------------------------------------------

『 2장 : CSMake 함수 (Shape 생성) 』

------------------------------------------------------------------------------------------

[예제 2-4] CSMakeCircle(), CSMakeCircleX(), CSMakeLine(), CSMakeLineX()
Shape1 = CSMakeCircle(6,64,0,37,1) -- 6각형 (외접원)
CSPlot(Shape1,P1,54,"Location 1",nil,1,32,P1) -- 유닛 생성
Shape1 = CSMakeCircleX(6,64,30,54,0) -- 6각형 (외접원)
CSPlot(Shape1,P1,54,"Location 2",nil,1,32,P1) -- 유닛 생성
Shape1 = CSMakeLine(6,64,0,19,1) -- 6각형 (방사형)
CSPlot(Shape1,P1,54,"Location 3",nil,1,32,P1) -- 유닛 생성
Shape1 = CSMakeLineX(6,64,30,18,0) -- 6각형 (방사형)
CSPlot(Shape1,P1,54,"Location 4",nil,1,32,P1) -- 유닛 생성
-----------------------------------------------------------------------------------------[예제 2-5] CSMakeStar(), CSMakeStarX()
Shape1 = CSMakeStar(5,108,64,0,61,1) -- 5각별
CSPlot(Shape1,P1,54,"Location 1",nil,1,32,P1) -- 유닛 생성
Shape1 = CSMakeStarX(5,108,64,36,90,0) -- 5각별
CSPlot(Shape1,P1,54,"Location 2",nil,1,32,P1) -- 유닛 생성
------------------------------------------------------------------------------------------

517

------------------------------------------------------------------------------------------

『 2장 : CSMake 함수 (Shape 생성) 』

------------------------------------------------------------------------------------------

[고급 예제 2-6] CSMakeGraphX(), CSMakeGraphY()
function Shape1_FuncY(X) return X^3-25*X end
Shape1 = CSMakeGraphX({32,8},"Shape1_FuncY",-6,0,1,0.5,320) -- y = x^3 - 25x
CSPlot(Shape1,P1,54,"Location 1",nil,1,32,P1) -- 유닛 생성
function Shape1_FuncX(Y) return Y^2/4 end
Shape1 = CSMakeGraphY({16,32},"Shape1_FuncX",6,1,0.5,nil,128) -- x= y^2/4
CSPlot(Shape1,P1,54,"Location 2",nil,1,32,P1) -- 유닛 생성
-----------------------------------------------------------------------------------------[고급 예제 2-7] CSMakeGraphR(), CSMakeGraphA()
function Shape1_FuncR(A) return A*2 end
Shape1 = CSMakeGraphA(32,"Shape1_FuncR",0,0,1,nil,100) -- r = 2Θ
CSPlot(Shape1,P1,54,"Location 1",nil,1,32,P1) -- 유닛 생성
function Shape1_FuncA(R) return math.sin(R) end
Shape1 = CSMakeGraphR(32,"Shape1_FuncA",0,0,0.5,nil,100) -- Θ = sin(r)
CSPlot(Shape1,P1,54,"Location 2",nil,1,32,P1) -- 유닛 생성
-----------------------------------------------------------------------------------------[고급 예제 2-8] CSMakeGraphT()
function Shape1_Parafunc(T) return {T*math.sin(T),T} end
Shape1 = CSMakeGraphT({16,32},"Shape1_Parafunc",0,0,1,10,100) -- x = tsint(t), y=t
CSPlot(Shape1,P1,54,"Location 1",nil,1,32,P1) -- 유닛 생성
------------------------------------------------------------------------------------------

518

------------------------------------------------------------------------------------------

『 3장 : CS_ 편집함수 (이미지 편집) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ 모든 예제에 SnowFlake 도형을 사용합니다 (부록참고) ｡+.ﾟ[예제 3-1] CS_MoveXY(), CS_MoveRA(), CS_MoveCenter()
CSPlot(SnowFlake,P1,54,"Location 1",nil,1,32,P1) -- 원본 도형
CSPlot(CS_MoveXY(SnowFlake,-128,256),P1,54,"Location 2",nil,1,32,P1) -- X : -128, Y : +256 평행이동
CSPlot(CS_MoveRA(SnowFlake,96,30),P1,54,"Location 3",nil,1,32,P1) -- R : +96, Θ : +30 평행이동

CSPlot(CS_MoveCenter(SnowFlake,2048-2731,2048-683),P1,54,"Location 4",nil,1,32,P1)
-- 중심을 2048-2731,2048-683으로 이동 (Location 4의 위치는 2731,683)

-----------------------------------------------------------------------------------------[예제 3-2] CS_Rotate(), CS_Rotate3D()
CSPlot(SnowFlake,P1,54,"Location 1",nil,1,32,P1) -- 원본 도형
CSPlot(CS_Rotate(SnowFlake,30),P1,54,"Location 2",nil,1,32,P1) -- 30도 회전

CSPlot(CS_Rotate3D(SnowFlake,45,0,0),P1,54,"Location 3",nil,1,32,P1) -- XY : 45, YZ : 0, ZX : 0
CSPlot(CS_Rotate3D(SnowFlake,0,45,0),P1,54,"Location 4",nil,1,32,P1) -- XY : 45, YZ : 45, ZX : 0
CSPlot(CS_Rotate3D(SnowFlake,0,0,45),P1,54,"Location 5",nil,1,32,P1) -- XY : 45, YZ : 0, ZX : 45
CSPlot(CS_Rotate3D(SnowFlake,45,45,0),P1,54,"Location 6",nil,1,32,P1) -- XY : 45, YZ : 45, ZX : 0
CSPlot(CS_Rotate3D(SnowFlake,45,0,45),P1,54,"Location 7",nil,1,32,P1) -- XY : 45, YZ : 0, ZX : 45
CSPlot(CS_Rotate3D(SnowFlake,0,45,45),P1,54,"Location 8",nil,1,32,P1) -- XY : 0, YZ : 45, ZX : 45
CSPlot(CS_Rotate3D(SnowFlake,45,45,45),P1,54,"Location 9",nil,1,32,P1) -- XY : 45, YZ : 45, ZX : 45

-----------------------------------------------------------------------------------------[예제 3-3] CS_InvertXY(), CS_InvertRA()
CSPlot(SnowFlake,P1,54,"Location 1",nil,1,32,P1) -- 원본 도형
CSPlot(CS_InvertXY(SnowFlake,64,nil),P1,54,"Location 2",nil,1,32,P1) -- X = 64로 뒤집음
CSPlot(CS_InvertXY(SnowFlake,nil,-128),P1,54,"Location 3",nil,1,32,P1) -- Y = -128로 뒤집음
CSPlot(CS_InvertRA(SnowFlake,96,nil),P1,54,"Location 4",nil,1,32,P1) -- R = 96로 뒤집음
CSPlot(CS_InvertRA(SnowFlake,nil,5),P1,54,"Location 5",nil,1,32,P1) -- Θ = 5로 뒤집음

-----------------------------------------------------------------------------------------[예제 3-4] CS_RatioXY(), CS_RatioRA()
CSPlot(SnowFlake,P1,54,"Location 1",nil,1,32,P1) -- 원본 도형
CSPlot(CS_RatioXY(SnowFlake,0.5,nil),P1,54,"Location 2",nil,1,32,P1) -- X*0.5
CSPlot(CS_RatioXY(SnowFlake,nil,2),P1,54,"Location 3",nil,1,32,P1) -- Y*2
CSPlot(CS_RatioRA(SnowFlake,0.5,nil),P1,54,"Location 4",nil,1,32,P1) -- R*0.5
CSPlot(CS_RatioRA(SnowFlake,nil,2),P1,54,"Location 5",nil,1,32,P1) -- Θ*2
-----------------------------------------------------------------------------------------519

------------------------------------------------------------------------------------------

『 3장 : CS_ 편집함수 (이미지 편집) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ 모든 예제에 SnowFlake 도형을 사용합니다 (부록참고) ｡+.ﾟ[고급 예제 3-5] CS_RatioRA(), CS_RemoveStack(), CS_Rotate(), CS_Merge()
※ n각 도형의 각 수 추가/감소 방법
CSPlot(SnowFlake,P1,54,"Location 1",nil,1,32,P1) -- 원본 도형
CSPlot(CS_RemoveStack(CS_RatioRA(SnowFlake,1,6/5),8),P1,54,"Location 6",nil,1,32,P1)
-- 축소 (6각 → 5각)
SnowFlake = CS_RatioRA(SnowFlake,1,6/7)
SnowFlake2 = CS_Rotate(SnowFlake,1*360/7)
CSPlot(CS_Merge(SnowFlake,SnowFlake2,8),P1,54,"Location 7",nil,1,32,P1)
-- 확대 (6각 → 7각)
-----------------------------------------------------------------------------------------[예제 3-6] CS_MirrorX(), CS_MirrorY(), CS_MirrorR(), CS_MirrorA()
CSPlot(SnowFlake,P1,54,"Location 1",nil,1,32,P1) -- 원본 도형
CSPlot(CS_MirrorX(SnowFlake,64,0),P1,54,"Location 2",nil,1,32,P1) -- X=64로 대칭
CSPlot(CS_MirrorY(SnowFlake,128,1),P1,54,"Location 3",nil,1,32,P1) -- Y=128로 대칭
CSPlot(CS_MirrorR(SnowFlake,192,1),P1,54,"Location 4",nil,1,32,P1) -- R=192로 대칭
CSPlot(CS_MirrorA(SnowFlake,10,0),P1,54,"Location 5",nil,1,32,P1) -- Θ=10으로 대칭
-----------------------------------------------------------------------------------------[고급 예제 3-7] CS_Kaleidoscope(), CS_KaleidoscopeX()
CSPlot(SnowFlake,P1,54,"Location 1",nil,1,32,P1) -- 원본 도형
CSPlot(CS_Kaleidoscope(SnowFlake,4,0,0),P1,54,"Location 2",nil,1,32,P1) -- 4각 대칭 만화경 효과
CSPlot(CS_KaleidoscopeX(SnowFlake,4,0,0),P1,54,"Location 3",nil,1,32,P1) -- 4각 비대칭 만화경 효과

-----------------------------------------------------------------------------------------[고급 예제 3-8] CS_Distortion(), CS_DistortionX()
CSPlot(SnowFlake,P1,54,"Location 1",nil,1,32,P1) -- 원본 도형
CSPlot(CS_Distortion(SnowFlake,{0,1},{1,0},nil,nil),P1,54,"Location 2",nil,1,32,P1) -- 직선 왜곡 효과

function S1_Ufunc(X) return 32*math.sin(math.rad(360*X/192))+192 end
-- f(x) = 32*Sin(360*x/192)+192
function S1_Dfunc(X) return 32*math.sin(math.rad(360*X/192))-192 end
-- f(x) = 32*Sin(360*x/192)-192
CSPlot(CS_DistortionX(SnowFlake,nil,nil,nil,nil,nil,{"S1_Ufunc"},{"S1_Dfunc"})
,P1,54,"Location 3",nil,1,32,P1) --곡선 왜곡 효과
------------------------------------------------------------------------------------------

520

------------------------------------------------------------------------------------------

『 3장 : CS_ 편집함수 (이미지 편집) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ 모든 예제에 SnowFlake 도형을 사용합니다 (부록참고) ｡+.ﾟ[고급 예제 3-9] CS_Vector2D(), CS_Vector2DPolar()
CSPlot(SnowFlake,P1,54,"Location 1",nil,1,32,P1) -- 원본 도형
function S1_Vector(X,Y) return {X+Y,X-Y} end

CSPlot(CS_Vector2D(SnowFlake,1,"S1_Vector"),P1,54,"Location 2",nil,1,32,P1) -- X=X+Y, Y=X-Y

function S2_Vector(R,A) return {R+A,2*R} end

CSPlot(CS_Vector2DPolar(SnowFlake,1,"S1_Vector"),P1,54,"Location 3",nil,1,32,P1) -- R=R+Θ, Θ=2*R

-----------------------------------------------------------------------------------------[예제 3-10] CS_Add(), CS_Overlap(), CS_Merge(), CS_Intersect(), CS_Subtract(),
CS_Xor(), CS_RemoveStack(), CS_OverlapX()
Shape2 = CS_FillXY(1,{0,128},{0,128},16,16)
CSPlot(SnowFlake,P1,54,"Location 1",nil,1,32,P1) -- 원본 도형
CSPlot(Shape2,P1,54,"Location 2",nil,1,32,P1) -- 원본 도형
CSPlot(CS_Add(SnowFlake,256,{1,1},{-1,1},{-1,-1},{1,-1}),P1,54,"Location 3",nil,1,32,P1) -- 네 꼭짓점 추가
CSPlot(CS_Overlap(SnowFlake,Shape2),P1,54,"Location 4",nil,1,32,P1) -- 도형 겹침
CSPlot(CS_Merge(SnowFlake,Shape2,16),P1,54,"Location 5",nil,1,32,P1) -- 도형 합침
CSPlot(CS_Intersect(SnowFlake,Shape2,16),P1,54,"Location 6",nil,1,32,P1) -- 도형 공통 영역
CSPlot(CS_Subtract(SnowFlake,Shape2,16),P1,54,"Location 7",nil,1,32,P1) -- 도형 영역 차
CSPlot(CS_Xor(SnowFlake,Shape2,16),P1,54,"Location 8",nil,1,32,P1) -- 도형 공통영역 제외 합침
CSPlot(CS_RemoveStack(SnowFlake,16),P1,54,"Location 9",nil,1,32,P1) -- 도형 겹침 제거

S1 = CSMakeLineX(1,56,60,3,0)
S1 = CS_MoveXY(S1,nil,-32*6.5)
S1 = CS_Kaleidoscope(S1,6,-60,1)
S4 = CS_OverlapX(CSMakeStar(6,180,56,30,73,13),CSMakeLineX(6,64,0,9*6,0),S1)
CSPlot(S4,P1,0,"CLoc",nil,1,32,P1)

-----------------------------------------------------------------------------------------[예제 3-11] CS_CropXY(), CS_CropRA(), CS_CropPath()
CSPlot(SnowFlake,P1,54,"Location 1",nil,1,32,P1) -- 원본 도형

Shape1 = CSMakePath({-160,0},{64,0},{64,64},{160,-32},{64,-128},{64,-64},{-160,-64}) -- →모양 Path

CSPlot(CS_CropXY(SnowFlake,{0,256},{-96,96}),P1,54,"Location 2",nil,1,32,P1) -- XY 자르기
CSPlot(CS_CropRA(SnowFlake,{32,192},{0,180}),P1,54,"Location 3",nil,1,32,P1) -- RΘ 자르기
CSPlot(CS_CropPath(SnowFlake,Shape1,1),P1,54,"Location 4",nil,1,32,P1)
-- Path 자르기 (화살표 모양)

-----------------------------------------------------------------------------------------521

------------------------------------------------------------------------------------------

『 3장 : CS_ 편집함수 (이미지 편집) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ 모든 예제에 SnowFlake 도형을 사용합니다 (부록참고) ｡+.ﾟ[고급 예제 3-12] CS_CropGraphXY(), CS_CropGraphRA()
CSPlot(SnowFlake,P1,54,"Location 1",nil,1,32,P1) -- 원본 도형
function S1_funcXY(X,Y) return X^2+Y^2/2-16 end

CSPlot(CS_CropGraphXY(SnowFlake,16,"S1_funcXY",0),P1,54,"Location 2",nil,1,32,P1) -- XY 자르기

function S1_funcRA(R,A) return R^2+A^2-16 end

CSPlot(CS_CropGraphRA(SnowFlake,32,"S1_funcRA",1),P1,54,"Location 3",nil,1,32,P1) -- RΘ 자르기

-----------------------------------------------------------------------------------------[예제 3-13] CS_FillXY(), CS_FillRA(), CS_FillHX(), CS_FillRD(),
CS_GetXmax(), CS_GetXmin(), CS_GetYmax(), CS_GetYmin()
CSPlot(SnowFlake,P1,54,"Location 1",nil,1,32,P1) -- 원본 도형
SXmax = CS_GetXmax(SnowFlake) -- X 최댓값
SXmin = CS_GetXmin(SnowFlake) -- X 최솟값
SYmax = CS_GetYmax(SnowFlake) -- Y 최댓값
SYmin = CS_GetYmin(SnowFlake) -- Y 최솟값
CSPlot(CS_FillXY(1,{SXmin,SXmax},{SYmin,SYmax},32,32),P1,54,"Location 2",nil,1,32,P1) -- XY 채우기
CSPlot(CS_FillRA(1,{0,math.sqrt(SYmax^2+SXmax^2)},{0,360},32,16),P1,54,"Location 3",nil,1,32,P1)
-- RA 채우기
CSPlot(CS_FillHx(1,{SXmin,SXmax},{SYmin,SYmax},32,32,0),P1,54,"Location 4",nil,1,32,P1) -- HX 채우기 ↑
CSPlot(CS_FillHX(1,{SXmin,SXmax},{SYmin,SYmax},32,32,1),P1,54,"Location 5",nil,1,32,P1) -- HX 채우기 ↓
CSPlot(CS_FillHX(1,{SXmin,SXmax},{SYmin,SYmax},32,32,2),P1,54,"Location 6",nil,1,32,P1) -- HX 채우기 ←
CSPlot(CS_FillHX(1,{SXmin,SXmax},{SYmin,SYmax},32,32,3),P1,54,"Location 7",nil,1,32,P1) -- HX 채우기 →
CSPlot(CS_FillRD(1,{SXmin,SXmax},{SYmin,SYmax},32,32),P1,54,"Location 8",nil,1,32,P1) -- RD 채우기

-----------------------------------------------------------------------------------------[예제 3-14] CS_FillPathXY(), CS_FillPathRA(), CS_FillPathHX(), CS_FillPathRD()
Shape1 = CSMakePath({-160,0},{64,0},{64,64},{160,-32},{64,-128},{64,-64},{-160,-64}) -- →모양 Path

CSPlot(CS_FillPathXY(Shape1,0,16,16),P1,54,"Location 2",nil,1,32,P1) -- XY 채우기
CSPlot(CS_FillPathRA(Shape1,1,16,8),P1,54,"Location 3",nil,1,32,P1) -- RA 채우기
CSPlot(CS_FillPathHX(Shape1,0,16,16,0),P1,54,"Location 4",nil,1,32,P1) -- HX 채우기
CSPlot(CS_FillPathHX(Shape1,0,16,16,1),P1,54,"Location 5",nil,1,32,P1) -- HX 채우기
CSPlot(CS_FillPathHX(Shape1,1,16,16,2),P1,54,"Location 6",nil,1,32,P1) -- HX 채우기
CSPlot(CS_FillPathHX(Shape1,1,16,16,3),P1,54,"Location 7",nil,1,32,P1) -- HX 채우기
CSPlot(CS_FillPathRD(Shape1,0,16,16),P1,54,"Location 8",nil,1,32,P1) -- RD 채우기

↑
↓
←
→

-----------------------------------------------------------------------------------------522

------------------------------------------------------------------------------------------

『 4장 : CSPlot 함수 (트리거 변환) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ 모든 예제에 SnowFlake 도형을 사용합니다 (부록참고) ｡+.ﾟ[예제 4-1] CSPlot(), CSPlotWithProperties()
CSPlot(SnowFlake,P1,54,"Location 1",nil,1,32,P1) -- 유닛 생성 함수
CSPlotWithProperties(SnowFlake,P1,54,"Location 2",nil,1,32,P1,nil,nil,nil,{
clocked = false,
burrowed = true,
intransit = false,
hallucinated = true,
invincible = true,
hitpoint = 100,
shield = 100,
energy = 100,
resource = 0,
hanger = 0,
}) -- 특수 유닛 생성 함수
-----------------------------------------------------------------------------------------[예제 4-2] CSPlotAct(), CSPlotActWithProperties()

CSPlotAct(SnowFlake,P1,54,"Location 1",nil,1,32,0,{SetResources(P1,Add,1,Ore)},P1)
-- 유닛 생성당 미네랄 1 증가
CSPlotActWithProperties(SnowFlake,P1,54,"Location 2",nil,1,32,0,
{SetResources(P1,Add,1,Gas)},P1,nil,nil,nil,{
clocked = false,
burrowed = true,
intransit = false,
hallucinated = true,
invincible = true,
hitpoint = 100,
shield = 100,
energy = 100,
resource = 0,
hanger = 0,
}) -- 유닛 생성당 가스 1 증가
------------------------------------------------------------------------------------------

523

------------------------------------------------------------------------------------------

『 4장 : CSPlot 함수 (트리거 변환) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ 모든 예제에 SnowFlake 도형을 사용합니다 (부록참고) ｡+.ﾟ[예제 4-3] CSPlotOrder(), CSPlotOrderWithProperties(), CS_Reverse(), CS_Shuffle(),
CS_Convert()
Line1 = CSMakeLine(1,32,90,24,0)
CSPlotOrder(Line1,P1,54,"Location 1",nil,1,16,Line1,nil,Patrol,"Location 6",nil,0,nil,P1)
-- 그대로 내려옴
CSPlotOrder(Line1,P1,54,"Location 2",nil,1,16,CS_Reverse(Line1),nil,Patrol,"Location 7",
nil,0,nil,P1) -- 역순으로 내려옴 (X자 진행)
CSPlotOrder(Line1,P1,54,"Location 3",nil,1,16,CS_Shuffle(Line1),nil,Patrol,"Location 8",
nil,0,nil,P1) -- 랜덤으로 내려옴 (랜덤 진행)
CSPlotOrder(SnowFlake,P1,54,"Location 4",nil,1,16,CS_Convert(Line1,SnowFlake[1]),nil,
Move,"Location 14",nil,16,nil,P1) -- 도형A -> 도형B로 무브
CSPlotOrderWithProperties(SnowFlake,P1,54,"Location 5",nil,1,16,SnowFlake,nil,
Move,"Location 15",nil,16,nil,P1,nil,nil,nil,{
clocked = false,
burrowed = false,
intransit = false,
hallucinated = true,
invincible = true,
hitpoint = 100,
shield = 100,
energy = 100,
resource = 0,
hanger = 0,
}) -- 특수 유닛 오더 소환
------------------------------------------------------------------------------------------

524

------------------------------------------------------------------------------------------

『 5장 : CSSave 함수 (파일 입출력) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ 사용자의 개발환경에 따라 작동이 안될수도 있습니다 ｡+.ﾟ[예제 5-1] CSSave()
※ 컴파일 후 Scmdraft 폴더 내부의 CS 폴더에 저장된 .txt 파일을 확인하세요.
CSSave("Ex5-1",1,SnowFlake) -- Ex5-1.txt 생성 (SnowFlake 도형 데이터 저장)
-----------------------------------------------------------------------------------------[예제 5-2] CSSaveWithName(), CSLoad()
※ 컴파일 후 Scmdraft 폴더 내부의 CS 폴더에 저장된 .txt 파일을 확인하세요.
※ 컴파일 후 1회 컴파일 오류 생성후 재컴파일 시 정상적으로 로드됨
(Scmdraft폴더 내부의 lua 폴더에 CSLoad.lua저장됨)
Line1 = CSMakeLine(1,32,90,24,0)
CSSaveWithName("Ex5-2",0,Line1,"Ex5_2Shape")

-- Line1 도형을 Ex5-2.txt에 저장(Ex5_2Shape로 로드 가능) - 반드시 전역변수여야함 (Local = 0)
CSLoad("Ex5-2") -- CS폴더 내부의 Ex5-2.txt 로드

CSPlot(Ex5_2Shape,P1,54,"Location 1",nil,1,32,P1) -- 유닛 생성 함수

------------------------------------------------------------------------------------------

525

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

-----------------------------------------------------------------------------------------[예제 6-1] CS_ConnectPath(), CS_ConnectPathX()
Shape1 = CSMakePath({-160,0},{64,0},{64,64},{160,-32},{64,-128},{64,-64},{-160,-64}) -- →모양 Path

CSPlot(Shape1,P1,0,"Location 1",nil,1,32,P1)
CSPlot(CS_ConnectPath(Shape1,6,1),P1,0,"Location 2",nil,1,32,P1)
CSPlot(CS_ConnectPath(Shape1,6),P1,0,"Location 3",nil,1,32,P1)
CSPlot(CS_ConnectPathX(Shape1,16,1),P1,0,"Location 4",nil,1,32,P1)
CSPlot(CS_ConnectPathX(Shape1,16),P1,0,"Location 5",nil,1,32,P1)
------------------------------------------------------------------------------------------

526

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[예제 6-2] CS_SortX(), CS_SortY(), CS_SortR(), CS_SortA(), CS_DoubleSortRA()
SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P2)
StartCtrig()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",0)
CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)
DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000),SetMemory(0x581D78,SetTo,0x75757575),
SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})
S1 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,32,32),45),{-128,128},{-128,128})
C1X = CAPlotForward()
CAPlot(CS_SortX(S1,0),P1,78,"Location 1",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,{SetCVar("X",C1X[2],SetTo,36)})
TriggerX(P1,CVar("X",C1X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C2X = CAPlotForward()
CAPlot(CS_SortX(S1,1),P1,78,"Location 2",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,{SetCVar("X",C2X[2],SetTo,36)})
TriggerX(P1,CVar("X",C2X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})

C3X = CAPlotForward()
CAPlot(CS_SortY(S1,0),P1,78,"Location 3",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,{SetCVar("X",C3X[2],SetTo,36)})
TriggerX(P1,CVar("X",C3X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C4X = CAPlotForward()
CAPlot(CS_SortY(S1,1),P1,78,"Location 4",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,{SetCVar("X",C4X[2],SetTo,36)})
TriggerX(P1,CVar("X",C4X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C5X = CAPlotForward()
CAPlot(CS_SortR(S1,0),P1,78,"Location 6",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,{SetCVar("X",C5X[2],SetTo,36)})
TriggerX(P1,CVar("X",C5X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C6X = CAPlotForward()
CAPlot(CS_SortR(S1,1),P1,78,"Location 7",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,{SetCVar("X",C6X[2],SetTo,36)})
TriggerX(P1,CVar("X",C6X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})

C7X = CAPlotForward()
CAPlot(CS_SortA(S1,0),P1,78,"Location 8",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,{SetCVar("X",C7X[2],SetTo,36)})
TriggerX(P1,CVar("X",C7X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C8X = CAPlotForward()
CAPlot(CS_SortA(S1,1),P1,78,"Location 9",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,{SetCVar("X",C8X[2],SetTo,36)})
TriggerX(P1,CVar("X",C8X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C9X = CAPlotForward()

CAPlot(CS_DoubleSortRA(S1,32,0,0),P1,78,"Location 11",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,{SetCVar("X",C9X[2],SetTo,36)})

TriggerX(P1,CVar("X",C9X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C10X = CAPlotForward()

CAPlot(CS_DoubleSortRA(S1,32,0,1),P1,78,"Location 12",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,{SetCVar("X",C10X[2],SetTo,36)})

TriggerX(P1,CVar("X",C10X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C11X = CAPlotForward()

CAPlot(CS_DoubleSortRA(S1,32,1,0),P1,78,"Location 13",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,{SetCVar("X",C11X[2],SetTo,36)})

TriggerX(P1,CVar("X",C11X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C12X = CAPlotForward()

CAPlot(CS_DoubleSortRA(S1,32,1,1),P1,78,"Location 14",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,{SetCVar("X",C12X[2],SetTo,36)})

TriggerX(P1,CVar("X",C12X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})

EndCtrig()
EUDTurbo(P1)
------------------------------------------------------------------------------------------

527

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[고급 예제 6-3] CS_DoubleSortGraph()
SetForces({P1},{P2},{},{},{P1,P2}) SetFixedPlayer(P2)
StartCtrig()
CJump(AllPlayers,0) Include_CtrigPlib(360,"Switch 1",0) CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)
DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000),SetMemory(0x581D78,SetTo,0x75757575),
SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})
S1 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,32,32),45),{-128,128},{-128,128})
function C1_funcA(X,Y) return X end function C1_funcB(X,Y) return Y end
C1X = CAPlotForward()
CAPlot(CS_DoubleSortGraph(S1,{0,"C1_funcA"},{0,"C1_funcB"},32,nil,0,0),P1,78,"Location 1",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,
{SetCVar("X",C1X[2],SetTo,36)})
TriggerX(P1,CVar("X",C1X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C2X = CAPlotForward()
CAPlot(CS_DoubleSortGraph(S1,{0,"C1_funcA"},{0,"C1_funcB"},32,nil,0,1),P1,78,"Location 2",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,
{SetCVar("X",C2X[2],SetTo,36)})
TriggerX(P1,CVar("X",C2X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C3X = CAPlotForward()
CAPlot(CS_DoubleSortGraph(S1,{0,"C1_funcA"},{0,"C1_funcB"},32,nil,1,0),P1,78,"Location 3",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,
{SetCVar("X",C3X[2],SetTo,36)})
TriggerX(P1,CVar("X",C3X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C4X = CAPlotForward()
CAPlot(CS_DoubleSortGraph(S1,{0,"C1_funcA"},{0,"C1_funcB"},32,nil,1,1),P1,78,"Location 4",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,
{SetCVar("X",C4X[2],SetTo,36)})
TriggerX(P1,CVar("X",C4X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C5X = CAPlotForward()
CAPlot(CS_DoubleSortGraph(S1,{0,"C1_funcB"},{0,"C1_funcA"},32,nil,0,0),P1,78,"Location 6",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,
{SetCVar("X",C5X[2],SetTo,36)})
TriggerX(P1,CVar("X",C5X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C6X = CAPlotForward()
CAPlot(CS_DoubleSortGraph(S1,{0,"C1_funcB"},{0,"C1_funcA"},32,nil,0,1),P1,78,"Location 7",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,
{SetCVar("X",C6X[2],SetTo,36)})
TriggerX(P1,CVar("X",C6X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C7X = CAPlotForward()
CAPlot(CS_DoubleSortGraph(S1,{0,"C1_funcB"},{0,"C1_funcA"},32,nil,1,0),P1,78,"Location 8",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,
{SetCVar("X",C7X[2],SetTo,36)})
TriggerX(P1,CVar("X",C7X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C8X = CAPlotForward()
CAPlot(CS_DoubleSortGraph(S1,{0,"C1_funcB"},{0,"C1_funcA"},32,nil,1,1),P1,78,"Location 9",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,
{SetCVar("X",C8X[2],SetTo,36)})
TriggerX(P1,CVar("X",C8X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C9X = CAPlotForward()
CAPlot(CS_DoubleSortGraph(S1,{0,"C1_funcA"},{2,"C1_funcB"},32,nil,0,0),P1,78,"Location 11",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,
{SetCVar("X",C9X[2],SetTo,36)})
TriggerX(P1,CVar("X",C9X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C10X = CAPlotForward()
CAPlot(CS_DoubleSortGraph(S1,{0,"C1_funcB"},{2,"C1_funcA"},32,nil,0,0),P1,78,"Location 12",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,
{SetCVar("X",C10X[2],SetTo,36)})
TriggerX(P1,CVar("X",C10X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C11X = CAPlotForward()
CAPlot(CS_DoubleSortGraph(S1,{0,"C1_funcA"},{0,"C1_funcB"},32,1,0,0),P1,78,"Location 13",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,
{SetCVar("X",C11X[2],SetTo,36)})
TriggerX(P1,CVar("X",C11X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C12X = CAPlotForward()
CAPlot(CS_DoubleSortGraph(S1,{0,"C1_funcB"},{0,"C1_funcA"},32,1,0,0),P1,78,"Location 14",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,
{SetCVar("X",C12X[2],SetTo,36)})
TriggerX(P1,CVar("X",C12X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C13X = CAPlotForward()
CAPlot(CS_DoubleSortGraph(S1,{1,"C1_funcA",{16,16}},{1,"C1_funcB",{16,16}},32,nil,0,0),P1,78,"Location 15",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,
{SetCVar("X",C13X[2],SetTo,36)})
TriggerX(P1,CVar("X",C13X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})

EndCtrig()
EUDTurbo(P1)

------------------------------------------------------------------------------------------

528

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[초고급 예제 6-4] CS_SortGraphXY(), CS_SortGraphRA()

※ 흩뿌리기 : CS_Shuffle() / 실선무늬 : PartShuffle 기능 사용시 구현가능
※ 1~2 : 계단식 / 3~5 : 임의함수식 / 6~10 : 블라인드 / 11~15 : 나누기(V자형) / 16~18 : 도형 / 19~20 : 십자형
SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P2)
StartCtrig()
CJump(AllPlayers,0) Include_CtrigPlib(360,"Switch 1",0) CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)
DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000),SetMemory(0x581D78,SetTo,0x75757575),
SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})
S1 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,32,32),45),{-128,128},{-128,128})
S2 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,28,28),45),{-128,128},{-128,128})
C1X = CAPlotForward()
function C1_func(X,Y) -- 계단모양 (y=kx)
local k = 2 -- 기울기
if k == "X" then
return X
else
return Y-k*X
end
end
CAPlot(CS_SortGraphXY(S1,1,"C1_func",0),P1,78,"Location 1",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,{SetCVar("X",C1X[2],SetTo,36)})
TriggerX(P1,CVar("X",C1X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})

C2X = CAPlotForward()
function C2_func(X,Y) -- 계단모양 (y=kx)
local k = -0.5 -- 기울기
if k == "X" then
return X
else
return Y-k*X
end
end
CAPlot(CS_SortGraphXY(S1,1,"C2_func",1),P1,78,"Location 2",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,{SetCVar("X",C2X[2],SetTo,36)})
TriggerX(P1,CVar("X",C2X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C3X = CAPlotForward()
function C3_func(X,Y) -- 임의곡선 (x=k*y^2)
local k = 1/16
return X-k*Y^2
end
CAPlot(CS_SortGraphXY(S1,1,"C3_func",0),P1,78,"Location 3",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,{SetCVar("X",C3X[2],SetTo,36)})
TriggerX(P1,CVar("X",C3X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C4X = CAPlotForward()
function C4_func(X,Y) -- 임의곡선 (y=kx^2)
local k = -0.25
return Y-k*X^2
end
CAPlot(CS_SortGraphXY(S1,{4,1},"C4_func",1),P1,78,"Location 4",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,{SetCVar("X",C4X[2],SetTo,36)})
TriggerX(P1,CVar("X",C4X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
C5X = CAPlotForward()
function C5_func(R,A) -- 임의곡선 (R=kSin(4A))
local k = 4
return R-k*math.sin(4*A)
end
CAPlot(CS_SortGraphRA(S1,{16,1},"C5_func",1),P1,78,"Location 5",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,{SetCVar("X",C5X[2],SetTo,36)})
TriggerX(P1,CVar("X",C5X[2],Exactly,2),{RemoveUnit(78,P1)},{Preserved})
EndCtrig()
EUDTurbo(P1)

------------------------------------------------------------------------------------------

529

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[초고급 예제 6-4] CS_SortGraphXY(), CS_SortGraphRA()

※ 흩뿌리기 : CS_Shuffle() / 실선무늬 : PartShuffle 기능 사용시 구현가능
※ 1~2 : 계단식 / 3~5 : 임의함수식 / 6~10 : 블라인드 / 11~15 : 나누기(V자형) / 16~18 : 도형 / 19~20 : 십자형
SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P2)
StartCtrig()
CJump(AllPlayers,0) Include_CtrigPlib(360,"Switch 1",0) CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)
DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000),SetMemory(0x581D78,SetTo,0x75757575),
SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})
S1 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,32,32),45),{-128,128},{-128,128})
S2 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,28,28),45),{-128,128},{-128,128})
C6X = CAPlotForward()
function C6FX(X,Y)
local k = 1 -- 기울기
local T
if k == "X" then
else
end
return T

T=X
T = Y-k*X

end
C6Max = CS_GetXYmax(S2,16,"C6FX")
C6Min = CS_GetXYmin(S2,16,"C6FX")
function C6_func(X,Y) -- 블라인드 (n분할/비대칭)
local n = 2 -- n분할
local m = 1 -- 분할영역 확장
local l = C6Min -- 시작위치

local T = C6FX(X,Y)
local Mod
C6Div = (C6Max-C6Min+m)/n
Mod = (math.floor((T-l)/C6Div)*C6Div)
T = T - Mod - l
return T

end
CAPlot(CS_SortGraphXY(S2,16,"C6_func",0),P1,79,"Location 6",nil,1,32,{1,0,0,0,1,0},nil,P1,nil,nil,{SetCVar("X",C6X[2],SetTo,36)})
TriggerX(P1,CVar("X",C6X[2],Exactly,2),{RemoveUnit(79,P1)},{Preserved})
C7X = CAPlotForward()
function C7FX(X,Y)
local k = -2 -- 기울기
local T
if k == "X" then
else

end
return T

T=X
T = Y-k*X

end
C7Max = CS_GetXYmax(S2,16,"C7FX")
C7Min = CS_GetXYmin(S2,16,"C7FX")
function C7_func(X,Y) -- 블라인드 (n분할/비대칭)
local n = 3 -- n분할
local m = 1 -- 분할영역 확장
local l = C7Min -- 시작위치
local T = C7FX(X,Y)
local Mod
C7Div = (C7Max-C7Min+m)/n
Mod = (math.floor((T-l)/C7Div)*C7Div)
T = T - Mod - l
return T

end
CAPlot(CS_SortGraphXY(S2,16,"C7_func",1),P1,79,"Location 7",nil,1,32,{1,0,0,0,1,0},nil,P1,nil,nil,{SetCVar("X",C7X[2],SetTo,36)})
TriggerX(P1,CVar("X",C7X[2],Exactly,2),{RemoveUnit(79,P1)},{Preserved})

EndCtrig()
EUDTurbo(P1)

------------------------------------------------------------------------------------------

530

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[초고급 예제 6-4] CS_SortGraphXY(), CS_SortGraphRA()

※ 흩뿌리기 : CS_Shuffle() / 실선무늬 : PartShuffle 기능 사용시 구현가능
※ 1~2 : 계단식 / 3~5 : 임의함수식 / 6~10 : 블라인드 / 11~15 : 나누기(V자형) / 16~18 : 도형 / 19~20 : 십자형
SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P2)
StartCtrig()
CJump(AllPlayers,0) Include_CtrigPlib(360,"Switch 1",0) CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)
DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000),SetMemory(0x581D78,SetTo,0x75757575),
SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})
S1 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,32,32),45),{-128,128},{-128,128})
S2 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,28,28),45),{-128,128},{-128,128})
C8X = CAPlotForward()
function C8FX(R,A) return A end
C8Max = CS_GetRAmax(S2,16,"C8FX")
C8Min = CS_GetRAmin(S2,16,"C8FX")
function C8_func(R,A) -- 블라인드 (n분할/비대칭)
local n = 2 -- n분할
local m = 0 -- 분할영역 확장
local l = C8Min -- 시작위치
local T = C8FX(R,A)
local Mod
C8Div = (C8Max-C8Min+m)/n
Mod = (math.floor((T-l)/C8Div)*C8Div)
T = T - Mod - l
return T

end
CAPlot(CS_SortGraphRA(S2,16,"C8_func",0),P1,79,"Location 8",nil,1,32,{1,0,0,0,1,0},nil,P1,nil,nil,{SetCVar("X",C8X[2],SetTo,36)})
TriggerX(P1,CVar("X",C8X[2],Exactly,2),{RemoveUnit(79,P1)},{Preserved})

C9X = CAPlotForward()
function C9FX(R,A) return A + 36 end
C9Max = CS_GetRAmax(S2,16,"C9FX")
C9Min = CS_GetRAmin(S2,16,"C9FX")
function C9_func(R,A) -- 블라인드 (n분할/비대칭)
local n = 3 -- n분할
local m = 0 -- 분할영역 확장
local l = C9Min -- 시작위치
local T = C9FX(R,A)
local Mod
C9Div = (C9Max-C9Min+m)/n
Mod = (math.floor((T-l)/C9Div)*C9Div)
T = T - Mod - l
return T

end
CAPlot(CS_SortGraphRA(S2,16,"C9_func",1),P1,79,"Location 9",nil,1,32,{1,0,0,0,1,0},nil,P1,nil,nil,{SetCVar("X",C9X[2],SetTo,36)})
TriggerX(P1,CVar("X",C9X[2],Exactly,2),{RemoveUnit(79,P1)},{Preserved})

C10X = CAPlotForward()
function C10FX(R,A) return R end
C10Max = CS_GetRAmax(S2,16,"C10FX")
C10Min = CS_GetRAmin(S2,16,"C10FX")
function C10_func(R,A) -- 블라인드 (n분할/비대칭)
local n = 2 -- n분할
local m = 1 -- 분할영역 확장
local l = C10Min -- 시작위치
local T = C10FX(R,A)
local Mod
C10Div = (C10Max-C10Min+m)/n
Mod = (math.floor((T-l)/C10Div)*C10Div)
T = T - Mod - l
return T

end
CAPlot(CS_SortGraphRA(S2,16,"C10_func",1),P1,79,"Location 10",nil,1,32,{1,0,0,0,1,0},nil,P1,nil,nil,{SetCVar("X",C10X[2],SetTo,36)})
TriggerX(P1,CVar("X",C10X[2],Exactly,2),{RemoveUnit(79,P1)},{Preserved})

EndCtrig()
EUDTurbo(P1)

------------------------------------------------------------------------------------------

531

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ-

[초고급 예제 6-4] CS_SortGraphXY(), CS_SortGraphRA()

※ 흩뿌리기 : CS_Shuffle() / 실선무늬 : PartShuffle 기능 사용시 구현가능
※ 1~2 : 계단식 / 3~5 : 임의함수식 / 6~10 : 블라인드 / 11~15 : 나누기(V자형) / 16~18 : 도형 / 19~20 : 십자형
SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P2)
StartCtrig()
CJump(AllPlayers,0) Include_CtrigPlib(360,"Switch 1",0) CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)
DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000),SetMemory(0x581D78,SetTo,0x75757575),
SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})
S1 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,32,32),45),{-128,128},{-128,128})
S2 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,28,28),45),{-128,128},{-128,128})
C11X = CAPlotForward()
function C11FX(X,Y)
local k = 1 -- 기울기
local T
if k == "X" then
else
end
return T

T=X
T = Y-k*X

end
C11Max = CS_GetXYmax(S2,16,"C11FX")
C11Min = CS_GetXYmin(S2,16,"C11FX")
function C11_func(X,Y) -- 블라인드 (n분할/대칭)
local n = 1 -- n분할
local m = 1 -- 분할영역 확장
local l = C11Min -- 시작위치
local T = C11FX(X,Y)
local Mod
local C11Div = (C11Max-C11Min+m)/(n)
Mod = (math.floor((T-l)/C11Div)*C11Div)
T = T - Mod - l
if T >= C11Div/2 then
T = C11Div - T
end
return T
end
CAPlot(CS_SortGraphXY(S2,16,"C11_func",0),P1,77,"Location 11",nil,1,32,{1,0,0,0,1,0},nil,P1,nil,nil,{SetCVar("X",C11X[2],SetTo,36)})
TriggerX(P1,CVar("X",C11X[2],Exactly,2),{RemoveUnit(77,P1)},{Preserved})
C12X = CAPlotForward()
function C12FX(X,Y)
local k = -2 -- 기울기
local T
if k == "X" then
else
end
return T

T=X
T = Y-k*X

end
C12Max = CS_GetXYmax(S2,16,"C12FX")
C12Min = CS_GetXYmin(S2,16,"C12FX")
function C12_func(X,Y) -- 블라인드 (n분할/대칭)
local n = 2 -- n분할
local m = 1 -- 분할영역 확장
local l = C12Min -- 시작위치
local T = C12FX(X,Y)
local Mod
C12Div = (C12Max-C12Min+m)/(n)
local Mod = (math.floor((T-l)/C12Div)*C12Div)
T = T - Mod - l
if T >= C12Div/2 then
T = C12Div - T
end
return T
end
CAPlot(CS_SortGraphXY(S2,16,"C12_func",1),P1,77,"Location 12",nil,1,32,{1,0,0,0,1,0},nil,P1,nil,nil,{SetCVar("X",C12X[2],SetTo,36)})
TriggerX(P1,CVar("X",C12X[2],Exactly,2),{RemoveUnit(77,P1)},{Preserved})

EndCtrig()
EUDTurbo(P1)

------------------------------------------------------------------------------------------

532

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[초고급 예제 6-4] CS_SortGraphXY(), CS_SortGraphRA()

※ 흩뿌리기 : CS_Shuffle() / 실선무늬 : PartShuffle 기능 사용시 구현가능
※ 1~2 : 계단식 / 3~5 : 임의함수식 / 6~10 : 블라인드 / 11~15 : 나누기(V자형) / 16~18 : 도형 / 19~20 : 십자형
SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P2)
StartCtrig()
CJump(AllPlayers,0) Include_CtrigPlib(360,"Switch 1",0) CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)
DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000),SetMemory(0x581D78,SetTo,0x75757575),
SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})
S1 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,32,32),45),{-128,128},{-128,128})
S2 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,28,28),45),{-128,128},{-128,128})
C13X = CAPlotForward()
function C13FX(R,A)
return A
end
C13Max = CS_GetRAmax(S2,16,"C13FX") -- 정사각형이 아닌 도형 삽입시 2*math.pi/16 입력
C13Min = CS_GetRAmin(S2,16,"C13FX") -- 정사각형이 아닌 도형 삽입시 0 입력
function C13_func(R,A) -- 블라인드 (n분할/대칭)
local n = 2 -- n분할
local m = 0 -- 분할영역 확장
local l = C13Min -- 시작위치
local T = C13FX(R,A)
local Mod
local C13Div = (C13Max-C13Min+m)/(n)
Mod = (math.floor((T-l)/C13Div)*C13Div)
T = T - Mod - l
if T >= C13Div/2 then
T = C13Div - T
end
return T

end
CAPlot(CS_SortGraphRA(S2,16,"C13_func",0),P1,77,"Location 13",nil,1,32,{1,0,0,0,1,0},nil,P1,nil,nil,{SetCVar("X",C13X[2],SetTo,36)})
TriggerX(P1,CVar("X",C13X[2],Exactly,2),{RemoveUnit(77,P1)},{Preserved})
C14X = CAPlotForward()
function C14FX(R,A)
return A+36
end
C14Max = CS_GetRAmax(S2,16,"C14FX")
C14Min = CS_GetRAmin(S2,16,"C14FX")
function C14_func(R,A) -- 블라인드 (n분할/대칭)
local n = 3 -- n분할
local m = 0 -- 분할영역 확장
local l = C14Min -- 시작위치
local T = C14FX(R,A)
local Mod
local C14Div = (C14Max-C14Min+m)/(n)
Mod = (math.floor((T-l)/C14Div)*C14Div)
T = T - Mod - l
if T >= C14Div/2 then
T = C14Div - T
end
return T

end
CAPlot(CS_SortGraphRA(S2,16,"C14_func",1),P1,77,"Location 14",nil,1,32,{1,0,0,0,1,0},nil,P1,nil,nil,{SetCVar("X",C14X[2],SetTo,36)})
TriggerX(P1,CVar("X",C14X[2],Exactly,2),{RemoveUnit(77,P1)},{Preserved})

EndCtrig()
EUDTurbo(P1)

------------------------------------------------------------------------------------------

533

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[초고급 예제 6-4] CS_SortGraphXY(), CS_SortGraphRA()

※ 흩뿌리기 : CS_Shuffle() / 실선무늬 : PartShuffle 기능 사용시 구현가능
※ 1~2 : 계단식 / 3~5 : 임의함수식 / 6~10 : 블라인드 / 11~15 : 나누기(V자형) / 16~18 : 도형 / 19~20 : 십자형
SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P2)
StartCtrig()
CJump(AllPlayers,0) Include_CtrigPlib(360,"Switch 1",0) CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)
DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000),SetMemory(0x581D78,SetTo,0x75757575),
SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})
S1 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,32,32),45),{-128,128},{-128,128})
S2 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,28,28),45),{-128,128},{-128,128})
C15X = CAPlotForward()
function C15FX(R,A)
return R
end
C15Max = CS_GetRAmax(S2,16,"C15FX")
C15Min = CS_GetRAmin(S2,16,"C15FX")
function C15_func(R,A) -- 블라인드 (n분할/대칭)
local n = 1 -- n분할
local m = 0 -- 분할영역 확장
local l = C15Min -- 시작위치
local T = C15FX(R,A)
local Mod
local C15Div = (C15Max-C15Min+m)/(n)
Mod = (math.floor((T-l)/C15Div)*C15Div)
T = T - Mod - l
if T >= C15Div/2 then
T = C15Div - T
end
return T

end
CAPlot(CS_SortGraphRA(S2,16,"C15_func",1),P1,77,"Location 15",nil,1,32,{1,0,0,0,1,0},nil,P1,nil,nil,{SetCVar("X",C15X[2],SetTo,36)})
TriggerX(P1,CVar("X",C15X[2],Exactly,2),{RemoveUnit(77,P1)},{Preserved})

EndCtrig()
EUDTurbo(P1)

------------------------------------------------------------------------------------------

534

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[초고급 예제 6-4] CS_SortGraphXY(), CS_SortGraphRA()

※ 흩뿌리기 : CS_Shuffle() / 실선무늬 : PartShuffle 기능 사용시 구현가능
※ 1~2 : 계단식 / 3~5 : 임의함수식 / 6~10 : 블라인드 / 11~15 : 나누기(V자형) / 16~18 : 도형 / 19~20 : 십자형
SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P2)
StartCtrig()
CJump(AllPlayers,0) Include_CtrigPlib(360,"Switch 1",0) CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)
DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000),SetMemory(0x581D78,SetTo,0x75757575),
SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})
S1 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,32,32),45),{-128,128},{-128,128})
S2 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,28,28),45),{-128,128},{-128,128})
C16X = CAPlotForward()
function C16FX(X,Y)
local k = math.tan(math.rad(45)) -- 기울기
local T
if k == "X" then
else

end

end
return T

T=X
T = Y-k*X

function C16_func(X,Y) -- 도형 (n분할/비대칭)
local n = 4 -- n분할
local m = 0 -- 분할영역 확장
local l = math.rad(0) -- 시작위치
local NR, NA, NX, NY
NR = math.sqrt((X)^2+(Y)^2)
if X>=0 and Y>=0 then
NA = math.abs(math.atan(Y/X))
elseif X<0 and Y>=0 then
NA = math.pi - math.abs(math.atan(Y/X))
elseif X<0 and Y<0 then
NA = math.pi + math.abs(math.atan(Y/X))
elseif X>=0 and Y<0 then
NA = 2*math.pi - math.abs(math.atan(Y/X))
end
local C16Div = (2*math.pi)/n
local Mod = (math.floor((NA-l)/C16Div)*C16Div)
NA = NA - Mod - l
NX = NR*math.cos(NA)
NY = NR*math.sin(NA)
local T = C16FX(NX,NY)
return T

end
CAPlot(CS_SortGraphXY(S2,16,"C16_func",0),P1,75,"Location 16",nil,1,32,{1,0,0,0,1,0},nil,P1,nil,nil,{SetCVar("X",C16X[2],SetTo,36)})
TriggerX(P1,CVar("X",C16X[2],Exactly,2),{RemoveUnit(75,P1)},{Preserved})

EndCtrig()
EUDTurbo(P1)

------------------------------------------------------------------------------------------

535

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[초고급 예제 6-4] CS_SortGraphXY(), CS_SortGraphRA()

※ 흩뿌리기 : CS_Shuffle() / 실선무늬 : PartShuffle 기능 사용시 구현가능
※ 1~2 : 계단식 / 3~5 : 임의함수식 / 6~10 : 블라인드 / 11~15 : 나누기(V자형) / 16~18 : 도형 / 19~20 : 십자형
SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P2)
StartCtrig()
CJump(AllPlayers,0) Include_CtrigPlib(360,"Switch 1",0) CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)
DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000),SetMemory(0x581D78,SetTo,0x75757575),
SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})
S1 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,32,32),45),{-128,128},{-128,128})
S2 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,28,28),45),{-128,128},{-128,128})
C17X = CAPlotForward()
function C17FX(X,Y)
local k = "X" -- 기울기
local T
if k == "X" then
else

end

end
return T

T=X
T = Y-k*X

function C17_func(X,Y) -- 도형 (n분할/비대칭)
local n = 4 -- n분할
local m = 0 -- 분할영역 확장
local l = math.rad(0) -- 시작위치
local NR, NA, NX, NY
NR = math.sqrt((X)^2+(Y)^2)
if X>=0 and Y>=0 then
NA = math.abs(math.atan(Y/X))
elseif X<0 and Y>=0 then
NA = math.pi - math.abs(math.atan(Y/X))
elseif X<0 and Y<0 then
NA = math.pi + math.abs(math.atan(Y/X))
elseif X>=0 and Y<0 then
NA = 2*math.pi - math.abs(math.atan(Y/X))
end
local C17Div = (2*math.pi)/n
local Mod = (math.floor((NA-l)/C17Div)*C17Div)
NA = NA - Mod - l
NX = NR*math.cos(NA)
NY = NR*math.sin(NA)
local T = C17FX(NX,NY)
return T

end
CAPlot(CS_SortGraphXY(S2,16,"C17_func",0),P1,75,"Location 17",nil,1,32,{1,0,0,0,1,0},nil,P1,nil,nil,{SetCVar("X",C17X[2],SetTo,36)})
TriggerX(P1,CVar("X",C17X[2],Exactly,2),{RemoveUnit(75,P1)},{Preserved})

EndCtrig()
EUDTurbo(P1)

------------------------------------------------------------------------------------------

536

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[초고급 예제 6-4] CS_SortGraphXY(), CS_SortGraphRA()

※ 흩뿌리기 : CS_Shuffle() / 실선무늬 : PartShuffle 기능 사용시 구현가능
※ 1~2 : 계단식 / 3~5 : 임의함수식 / 6~10 : 블라인드 / 11~15 : 나누기(V자형) / 16~18 : 도형 / 19~20 : 십자형
SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P2)
StartCtrig()
CJump(AllPlayers,0) Include_CtrigPlib(360,"Switch 1",0) CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)
DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000),SetMemory(0x581D78,SetTo,0x75757575),
SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})
S1 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,32,32),45),{-128,128},{-128,128})
S2 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,28,28),45),{-128,128},{-128,128})
C18X = CAPlotForward()
function C18FX(X,Y)
local k = math.tan(math.rad(135)) -- 기울기
local T
if k == "X" then
else

end

end
return T

T=X
T = Y-k*X

function C18_func(X,Y) -- 도형 (n분할/비대칭)
local n = 4 -- n분할
local m = 0 -- 분할영역 확장
local l = math.rad(0) -- 시작위치
local NR, NA, NX, NY
NR = math.sqrt((X)^2+(Y)^2)
if X>=0 and Y>=0 then
NA = math.abs(math.atan(Y/X))
elseif X<0 and Y>=0 then
NA = math.pi - math.abs(math.atan(Y/X))
elseif X<0 and Y<0 then
NA = math.pi + math.abs(math.atan(Y/X))
elseif X>=0 and Y<0 then
NA = 2*math.pi - math.abs(math.atan(Y/X))
end
local C18Div = (2*math.pi)/n
local Mod = (math.floor((NA-l)/C18Div)*C18Div)
NA = NA - Mod - l
NX = NR*math.cos(NA)
NY = NR*math.sin(NA)
local T = C18FX(NX,NY)
return T

end
CAPlot(CS_SortGraphXY(S2,16,"C18_func",0),P1,75,"Location 18",nil,1,32,{1,0,0,0,1,0},nil,P1,nil,nil,{SetCVar("X",C18X[2],SetTo,36)})
TriggerX(P1,CVar("X",C18X[2],Exactly,2),{RemoveUnit(75,P1)},{Preserved})

EndCtrig()
EUDTurbo(P1)

------------------------------------------------------------------------------------------

537

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[초고급 예제 6-4] CS_SortGraphXY(), CS_SortGraphRA()

※ 흩뿌리기 : CS_Shuffle() / 실선무늬 : PartShuffle 기능 사용시 구현가능
※ 1~2 : 계단식 / 3~5 : 임의함수식 / 6~10 : 블라인드 / 11~15 : 나누기(V자형) / 16~18 : 도형 / 19~20 : 십자형
SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P2)
StartCtrig()
CJump(AllPlayers,0) Include_CtrigPlib(360,"Switch 1",0) CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)
DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000),SetMemory(0x581D78,SetTo,0x75757575),
SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})
S1 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,32,32),45),{-128,128},{-128,128})
S2 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,28,28),45),{-128,128},{-128,128})
C19X = CAPlotForward()
function C19FX(X,Y)
local k = math.tan(math.rad(0)) -- 기울기
local T
if k == "X" then
else

end

end
return T

T=X
T = Y-k*X

function C19_func(X,Y) -- 도형 (n분할/비대칭)
local n = 4 -- n분할
local m = 0 -- 분할영역 확장
local l = math.rad(0) -- 시작위치
local NR, NA, NX, NY
NR = math.sqrt((X)^2+(Y)^2)
if X>=0 and Y>=0 then
NA = math.abs(math.atan(Y/X))
elseif X<0 and Y>=0 then
NA = math.pi - math.abs(math.atan(Y/X))
elseif X<0 and Y<0 then
NA = math.pi + math.abs(math.atan(Y/X))
elseif X>=0 and Y<0 then
NA = 2*math.pi - math.abs(math.atan(Y/X))
end
local C19Div = (2*math.pi)/n
local Mod = (math.floor((NA-l)/C19Div)*C19Div)
NA = NA - Mod - l
if NA >= C19Div/2 then
NA = C19Div - NA
end
NX = NR*math.cos(NA)
NY = NR*math.sin(NA)

local T = C19FX(NX,NY)
return T

end
CAPlot(CS_SortGraphXY(S2,16,"C19_func",0),P1,75,"Location 19",nil,1,32,{1,0,0,0,1,0},nil,P1,nil,nil,{SetCVar("X",C19X[2],SetTo,36)})
TriggerX(P1,CVar("X",C19X[2],Exactly,2),{RemoveUnit(75,P1)},{Preserved})

EndCtrig()
EUDTurbo(P1)

------------------------------------------------------------------------------------------

538

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[초고급 예제 6-4] CS_SortGraphXY(), CS_SortGraphRA()

※ 흩뿌리기 : CS_Shuffle() / 실선무늬 : PartShuffle 기능 사용시 구현가능
※ 1~2 : 계단식 / 3~5 : 임의함수식 / 6~10 : 블라인드 / 11~15 : 나누기(V자형) / 16~18 : 도형 / 19~20 : 십자형
SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P2)
StartCtrig()
CJump(AllPlayers,0) Include_CtrigPlib(360,"Switch 1",0) CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)
DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000),SetMemory(0x581D78,SetTo,0x75757575),
SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})
S1 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,32,32),45),{-128,128},{-128,128})
S2 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,28,28),45),{-128,128},{-128,128})
C20X = CAPlotForward()
function C20FX(X,Y)
local k = math.tan(math.rad(180)) -- 기울기
local T
if k == "X" then
else

end

end
return T

T=X
T = Y-k*X

function C20_func(X,Y) -- 도형 (n분할/비대칭)
local n = 4 -- n분할
local m = 0 -- 분할영역 확장
local l = math.rad(0) -- 시작위치
local NR, NA, NX, NY
NR = math.sqrt((X)^2+(Y)^2)
if X>=0 and Y>=0 then
NA = math.abs(math.atan(Y/X))
elseif X<0 and Y>=0 then
NA = math.pi - math.abs(math.atan(Y/X))
elseif X<0 and Y<0 then
NA = math.pi + math.abs(math.atan(Y/X))
elseif X>=0 and Y<0 then
NA = 2*math.pi - math.abs(math.atan(Y/X))
end
local C20Div = (2*math.pi)/n
local Mod = (math.floor((NA-l)/C20Div)*C20Div)
NA = NA - Mod - l
if NA >= C20Div/2 then
NA = C20Div - NA
end
NX = NR*math.cos(NA)
NY = NR*math.sin(NA)

local T = C20FX(NX,NY)
return T

end
CAPlot(CS_SortGraphXY(S2,16,"C20_func",1),P1,75,"Location 20",nil,1,32,{1,0,0,0,1,0},nil,P1,nil,nil,{SetCVar("X",C20X[2],SetTo,36)})
TriggerX(P1,CVar("X",C20X[2],Exactly,2),{RemoveUnit(75,P1)},{Preserved})

EndCtrig()
EUDTurbo(P1)

------------------------------------------------------------------------------------------

539

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

-----------------------------------------------------------------------------------------[예제 6-5] CS_SortXY(), CS_SortRA(), CS_SortI()
S0 = CS_FillXY({1,1},{0,6},{0,6},2,2) -- Base 도형 (4x4 정사각형)
function func1(X,Y) -- 좌표(X,Y)정렬
return {X+Y} -- 1차 정렬
end
S1 = CS_SortXY(S0,"func1",nil,0) -- 오름차순
CAPlot(CS_RatioXY(S1,32,32),P1,0,"Location 7",nil,1,32,{1,0,6,0,1,0},nil,P1,nil,nil,{KillUnit(0,P1)})
function func2(X,Y) -- 좌표(X,Y)정렬
return {X+Y,Y} -- 2차 정렬 (X+Y=k1,Y=k2)
end
S1 = CS_SortXY(S0,"func2",{0},{0,1}) -- 1차:오름/2차:내림차순
-- 2차정렬 : 범위는 1까지 존재, 범위=0 이므로 같은 k1끼리만 묶임
CAPlot(CS_RatioXY(S1,32,32),P1,1,"Location 8",nil,1,32,{1,0,6,0,1,0},nil,P1,nil,nil,{KillUnit(1,P1)})
function func3(X,Y) -- 좌표(X,Y)정렬
return {X,X+Y,Y} -- 3차 정렬 (X=k1,X+Y=k2,Y=k3)
end
S1 = CS_SortXY(S0,"func3",{3,0},0) -- 모두 오름차순
-- 3차정렬 : 범위는 2까지 존재
-- 1차정렬 : 0~3 / 4~6로 묶임 (8/8개)
-- 2차정렬 : 각각의 묶음에서 X+Y=k2로 정렬함
-- → 0,0 / 0,2 2,0 / 0,4 2,2 / 0,6 2,4 / 2,6 (앞쪽 묶음, 뒤쪽도 동일하게 정렬됨)
-- 3차정렬 : 범위2=0 이므로 같은 k2끼리만 묶임
-- → Y=k3값에 따라 0,2 2,0가 2,0 0,2로 정렬됨, 나머지 묶음들도 모두 동일하게 정렬됨
-- → 0,0 / 2,0 0,2 / 2,2 0,4 / 2,4 0,6 / 2,6 (앞쪽 묶음, 뒤쪽도 동일하게 정렬됨)
CAPlot(CS_RatioXY(S1,32,32),P1,16,"Location 9",nil,1,32,{1,0,6,0,1,0},nil,P1,nil,nil,{KillUnit(16,P1)})
function func4(X,Y) -- 좌표(X,Y)정렬
return {X+Y,Y} -- 2차 정렬 (X+Y=k1,Y=k2)
end
function func4a(i) -- 범위1 함수
return 6*i-4 -- f(1)=2, f(2)=8
end
S1 = CS_SortXY(S0,"func4",{"func4a"},0) -- 모두 오름차순
-- 1차정렬 : f(1)=2, f(2)=8 → k1 = 0~2 / 4~12로 묶임
-- 2차정렬 : 각각의 묶음에서 Y=k2로 오름차순으로 정렬함
CAPlot(CS_RatioXY(S1,32,32),P1,15,"Location 12",nil,1,32,{1,0,6,0,1,0},nil,P1,nil,nil,{KillUnit(15,P1)})
S0 = CS_FillXY({1,1},{-3,3},{-3,3},2,2) -- Base 도형 (4x4 정사각형, 원점중심)
function func5(R,A) -- 좌표(R,A)정렬
return {R,A} -- 2차 정렬
end
S1 = CS_SortRA(S0,"func5",{0.1},{1,0}) -- 내림차순
CAPlot(CS_RatioXY(S1,32,32),P1,34,"Location 13",nil,1,32,{1,0,6,0,1,0},nil,P1,nil,nil,{KillUnit(34,P1)})
S0 = CS_FillXY({1,0},{0,10},{0,0},2,2) -- Base 도형 (6점 직선)
function func6(I) -- 인덱스 정렬 (인덱스는 1부터 시작함)
return {math.floor((I-1)/3),I} -- 2차 정렬
end
S1 = CS_SortI(S0,"func6",{0},{0,1}) -- 1차:오름/2차:내림
-- 1차정렬 : 1~3번째점(k1=0) / 4~6번째점(k1=1)으로 묶임 (3/3개)
-- 2차정렬 : 인덱스 내림차순으로 정렬됨(3->2->1/6->5->4)
CAPlot(CS_RatioXY(S1,32,32),P1,32,"Location 14",nil,1,32,{1,0,6,0,1,0},nil,P1,nil,nil,{KillUnit(32,P1)})
-- ※ 정렬 후 n차정렬식의 함수값이 같은 점끼리는 정렬이 안된 상태로 연산이 종료됨

-----------------------------------------------------------------------------------------540

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

-----------------------------------------------------------------------------------------[예제 6-6] CS_TInputVoid(), CS_TMakePath(), CS_TMakeAuto(), CSTSaveWithName()
S1 = CS_InputVoid(10)
TS1 = CS_TInputVoid(10)
S2 = CSMakePath({1,1},{2,2},{3,3},{4,4},{5,5},{6,6})
TS2 = CS_TMakePath(1,2,3)
S3 = CS_FillXY({1,1},6,6,2,2)
TS3 = CS_TMakeAuto(S3,2)
S4 = CS_FillXY({1,1},6,6,2,2)
TS4 = CS_TMakeAuto(S4,{7,5,3,1})
CSTSaveWithName("TSort",1,S1,TS1,"Shape1",S2,TS2,"Shape2",S3,TS3,"Shape3",S4,TS4,"Shape4")

------------------------------------------------------------------------------------------

[예제 6-7] CS_NSortXY(), CS_NSortRA(), CS_NSortI()

S0 = CS_FillXY({1,1},{0,6},{0,6},2,2) -- Base 도형 (4x4 정사각형)
function func1(X,Y) return {X+Y} end
S1, TS1 = CS_NSortXY(S0,nil,5,"func1",nil,1)
CBPlot(CS_RatioXY(S1,32,32),TS1,P1,0,"Location 7",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(0,P1)})
function func2(X,Y) return {X,Y} end
function func2a(I) return 2*I-1 end
S1, TS1 = CS_NSortXY(S0,"func2a",4,"func2",{0},0)
CBPlot(CS_RatioXY(S1,32,32),TS1,P1,1,"Location 8",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(1,P1)})
S0 = CS_FillXY({1,1},{-3,3},{-3,3},2,2) -- Base 도형 (4x4 정사각형)
function func3(R,A) return {R,A} end
function func3a(I)
if I<=4 or I>=9 then
return 1
else
return 2
end
end
S1, TS1 = CS_NSortRA(S0,"func3a",12,"func3",{0},0)
CBPlot(CS_RatioXY(S1,32,32),TS1,P1,16,"Location 17",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(16,P1)})
S0 = CSMakeCircle(12,128,0,13,1)
function func4(I)
return {math.floor((I-1)/4),I}
end
function func4a(I)
if I<=4 then return 1
elseif I==7 then return 4
else return 2 end
end
S1, TS1 = CS_NSortI(S0,"func4a",7,"func4",{0},{0,1})
CBPlot(S1,TS1,P1,15,"Location 18",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(15,P1)})
------------------------------------------------------------------------------------------

541

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

-----------------------------------------------------------------------------------------[예제 6-8] CS_TSortXY(), CS_TSortRA(), CS_TSortI()
S0 = CS_FillXY({1,1},{0,6},{0,6},2,2) -- Base 도형 (4x4 정사각형)
function func1(X,Y)
return {X+Y}
end
S1, TS1 = CS_TSortXY(S0,nil,7,0,"func1",nil,1)
CBPlot(CS_RatioXY(S1,32,32),TS1,P1,0,"Location 7",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(0,P1)})

S0a = CS_Add(S0,1,{-2,-2},{-6,-2},{-4,-4},{-2,-6},{-6,-6}) -- 본체와 떨어진 점 추가
S1, TS1 = CS_TSortXY(S0a,nil,13,1,"func1",nil,1) -- Void 효과 (비어있지만 도형이 그려지는 속도는 같음)
CBPlot(CS_RatioXY(S1,32,32),TS1,P1,1,"Location 8",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(1,P1)})
function func2(X,Y)
return {X,Y}
end
S1, TS1 = CS_TSortXY(S0,nil,2,0,"func2",{0},{0,1})
CBPlot(CS_RatioXY(S1,32,32),TS1,P1,16,"Location 9",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(16,P1)})
function func2a(I)
if I<=2 then

else
end

return 1
return 2

end
S1, TS1 = CS_TSortXY(S0,"func2a",3,0,"func2",{0},{0,0})
CBPlot(CS_RatioXY(S1,32,32),TS1,P1,15,"Location 14",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(15,P1)})
S0 = CS_FillXY({1,1},{-7,7},{-7,7},2,2) -- Base 도형 (8x8 정사각형)
function func3(R,A)
if R<=4.3 then
return {1,math.floor(2*A/math.pi),A}
else
return {0,math.floor(4*A/math.pi),A}
end
end
S1, TS1 = CS_TSortRA(S0,nil,1,0,"func3",{0,0},0)
CBPlot(CS_RatioXY(S1,24,24),TS1,P1,34,"Location 12",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(34,P1)})
S0 = CSMakeCircle(15,128,0,16,1)
function func4(I)
return {I}
end
function func4a(I)
return I
end
S1, TS1 = CS_TSortI(S0,"func4a",5,0,"func4",nil,1)
CBPlot(S1,TS1,P1,32,"Location 13",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(32,P1)})

------------------------------------------------------------------------------------------

542

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

-----------------------------------------------------------------------------------------[예제 6-9] CS_Arrange(), CS_Split(), CS_Mix()
S0 = CSMakeCircle(16,128,0,17,1)
function func1a(I)
Arr1 = {13,15,15}
if I<=8 then
else
end
function func1b(I)

end
Arr2 = {10,12,14}
if I<=8 then
else
end

return 2*I-1
return Arr1[I-8]

return I
return Arr2[I-8]

end
S1 = CS_Arrange(S0,{11,"func1a","func1b"})
CAPlot(S1,P1,15,"Location 6",nil,1,32,{1,0,6,0,1,0},nil,P1,nil,nil,{KillUnit(15,P1)})
function func2a(I) return 2*I end
function func2b(I) return 25 end
S1 = CS_Arrange(S0,{8,"func2a","func2b"},1,1)
CAPlot(S1,P1,0,"Location 7",nil,1,32,{1,0,6,0,1,0},nil,P1,nil,nil,{KillUnit(0,P1)})

function func3(I) return 2*I-1 end
S1 = CS_Split(S0,{8,"func3"})
CAPlot(S1,P1,1,"Location 8",nil,1,32,{1,0,6,0,1,0},nil,P1,nil,nil,{KillUnit(1,P1)})
function func4(I) return 17 end
S1 = CS_Split(S0,{8,"func4"},1,1)
CAPlot(S1,P1,16,"Location 9",nil,1,32,{1,0,6,0,1,0},nil,P1,nil,nil,{KillUnit(16,P1)})
S0a = CSMakeCircle(12,96,0,13,1)
S0b = CSMakeCircle(8,64,0,9,1)
function func5(I) return 1 end
function func5a(I) return 2*I-1 end
S1 = CS_Mix({{S0,"func5"},{S0a,"func5"},{S0b,"func5"}},nil,{"func5a",3,nil},1)
CAPlot(S1,P1,34,"Location 11",nil,1,32,{1,0,6,0,1,0},nil,P1,nil,nil,{KillUnit(34,P1)})
-- A1(1) B1(3) C1(8) A2(3) B2(3) A3(5) B3(3) A4(7) B4(3)
function func6a(I) return 12*I end
function func6b(I) return 12*I+4 end
function func6c(I) return 12*I+7 end
S1 = CS_Mix({{S0,"func6a"},{S0a,"func6b"},{S0b,"func6c"}},nil,{4,3,2})
CAPlot(S1,P1,32,"Location 12",nil,1,32,{1,0,6,0,1,0},nil,P1,nil,nil,{KillUnit(32,P1)})
-- A1(4) B1(3) C1(2) A2(4) B2(3) C2(2) A3(4) B3(3) C3(2) A4(4) B4(3) C4(2)
-- 실제 순서는 함수값에 따라 A1(1) B1(1) C1(1) ... A8(1) B8(1) C8(1) A9(1) B9(1) A10(1)
-- B10(1) A11(1) B11(1) A12(1) B12(1) A13(1) A14(1) A15(1) A16(1) 위치에 복사됨
S1, TS1 = CS_Mix({{S0,"func5"},{S0a,"func5"},{S0b,"func5"}},{0,3},{"func5a",3,nil},1)
CBPlot(S1,TS1,P1,50,"Location 13",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(50,P1)})
-- A1(1) B1(3) C1(8) / A2(3) B2(3) A3(5) / B3(3) A4(7) B4(3)
function func8(I)

if I<=2 then
else
end

return 6
return 3

end
S1, TS1 = CS_Mix({{S0,"func5"},{S0a,"func5"},{S0b,"func5"}},{1,"func8"},{2,3,4},1)
CBPlot(S1,TS1,P1,51,"Location 14",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(51,P1)})
-- A1(2) B1(3) C1(4) A2(2) B2(3) C2(4) / A3(2) B3(3) C3(0) A4(2) B4(3) C4(0)
-- A5(2) B5(0) C5(0) / A6(2) B6(0) C6(0) / A7(2) B7(0) C7(0) / A8(2) B8(0) C8(0)

------------------------------------------------------------------------------------------

543

------------------------------------------------------------------------------------------

『 6장 : 추가 CS함수 (확장 함수팩) 』

-----------------------------------------------------------------------------------------[예제 6-10] CS_TArrange(), CS_TSplit(), CS_TMix(), CS_SortTM(), CS_SortTI()
S0 = CSMakeCircle(28,128,0,29,1)
TS0 = CS_TMakePath(1,2,3,4,5,6,7)
function func1(T) return {-T} end
S1, TS1 = CS_SortTM({S0,TS0},"func1",nil,0)
CBPlot(S1,TS1,P1,0,"Location 6",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(0,P1)})
function func2(T)

if T%2 == 0 then
else
end

return {0,-T}
return {1,T}

end
S1, TS1 = CS_SortTM({S0,TS0},"func2",{0},{1,0})
CBPlot(S1,TS1,P1,1,"Location 7",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(1,P1)})
S2 = CSMakeCircle(24,128,0,25,1)
TS2 = CS_TMakePath(3,3,3,3,3,3,3,3)
S1, TS1 = CS_SortTI({S2,TS2},"func1",nil,0)
CBPlot(S1,TS1,P1,15,"Location 8",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(15,P1)})
S1, TS1 = CS_SortTI({S2,TS2},"func2",{0},{1,0})
CBPlot(S1,TS1,P1,16,"Location 9",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(16,P1)})
function func5a(T)
end
function func5b(T)

Arr1 = {2,3,4,6}
return Arr1[T]
Arr2 = {5,5,6,7}
return Arr2[T]

end
S1, TS1 = CS_TArrange({S2,TS2},{4,"func5a","func5b"})
CBPlot(S1,TS1,P1,34,"Location 10",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(34,P1)})
function func6a(T) return 2*T end
function func6b(T) return 9 end
S1, TS1 = CS_TArrange({S2,TS2},{4,"func6a","func6b"},1,1)
CBPlot(S1,TS1,P1,32,"Location 15",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(32,P1)})
S1, TS1 = CS_TSplit({S2,TS2},{4,"func6a"})
CBPlot(S1,TS1,P1,50,"Location 11",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(50,P1)})
S1, TS1 = CS_TSplit({S2,TS2},{4,"func6b"},1,-1)
CBPlot(S1,TS1,P1,51,"Location 12",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(51,P1)})
S2a = CSMakeCircle(12,96,0,13,1)
TS2a = CS_TMakePath(2,2,2,2,2,2)
S2b = CSMakeCircle(4,64,0,5,1)
TS2b = CS_TMakePath(1,1,1,1)
function func9(T) return 1 end
function func9a(T) return T end
S1, TS1 = CS_TMix({{S2,TS2,"func9"},{S2a,TS2a,"func9"},{S2b,TS2b,"func9"}},{2,"func9a",nil},1)
CBPlot(S1,TS1,P1,54,"Location 13",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(54,P1)})
function func10a(T) return 9*T end
function func10b(T) return 9*T+4 end
function func10c(T) return 9*T+7 end
S1, TS1 = CS_TMix({{S2,TS2,"func10a"},{S2a,TS2a,"func10b"},{S2b,TS2b,"func10c"}},{4,3,2})
CBPlot(S1,TS1,P1,77,"Location 14",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(77,P1)})

-----------------------------------------------------------------------------------------544

------------------------------------------------------------------------------------------

『 7장 : CA_ 실시간 편집함수 (어셈블러 필요) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[예제 7-1] CA_ConvertRA(), CA_ConvertXY()
SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P2)
StartCtrig()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",0)
CVariable(P1,1) SX = 1
CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)

DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000),
SetMemory(0x581D78,SetTo,0x75757575),SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})

S1 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,16,16),45),{-128,128},{-128,128})
function S1_CAfunc()
local PlayerID = CAPlotPlayerID
local CA = CAPlotDataArr
local CB = CAPlotCreateArr
CA_ConvertRA(V(CA[11]),V(CA[12]),V(CA[8]),V(CA[9])) -- XY -> RA로 변환

end

CAdd(PlayerID,V(CA[12]),V(SX)) -- A << A+SX (SX 회당 5증가)
CMov(PlayerID,V(CA[11]),_iDiv(_Mul(V(CA[11]),_iSub(_Mov(100),V(SX))),100))
-- R << R*(100-SX)/100
CA_ConvertXY(V(CA[8]),V(CA[9]),V(CA[11]),V(CA[12])) -- RA -> XY로 변환

CA1 = CAPlotForward()

TriggerX(P1,CVar("X",CA1[2],Exactly,2),{RemoveUnit(54,P1),SetCVar("X",SX,Add,5)},{Preserved})
CAPlot(S1,P1,54,"Location 1",nil,1,32,{1,0,0,0,S1[1]/12,0},"S1_CAfunc",P1,nil,nil,
{SetCVar("X",CA1[2],SetTo,12)})

EndCtrig()
-- 에러 체크 함수 선언 위치 ---↑Tep에 그대로 붙여넣기---------------------------------------ErrorCheck()
EUDTurbo(P1)
------------------------------------------------------------------------------------------

545

------------------------------------------------------------------------------------------

『 7장 : CA_ 실시간 편집함수 (어셈블러 필요) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[예제 7-2] CA_MoveXY(), CA_MoveRA()
SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P2)
StartCtrig()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",0)

CVariable(P1,1) SX = 1 CVariable(P1,2) SY = 2 CVariable(P1,3) SZ = 3 CVariable(P1,4) SW = 4

CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)

DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000),
SetMemory(0x581D78,SetTo,0x75757575),SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})

S1 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,16,16),45),{-128,128},{-128,128})
function S1_CAfunc()
local PlayerID = CAPlotPlayerID
local CA = CAPlotDataArr
local CB = CAPlotCreateArr
CA_MoveXY(_Neg(V(SX)),V(SY)) -- X : -SX, Y : +SY로 평행이동
end
CA1 = CAPlotForward()
TriggerX(P1,CVar("X",CA1[2],Exactly,2),{RemoveUnit(54,P1),SetCVar("X",SX,Add,8),
SetCVar("X",SY,Add,16)},{Preserved})
CAPlot(S1,P1,54,"Location 1",nil,1,32,{1,0,0,0,S1[1]/12,0},"S1_CAfunc",P1,nil,nil,
{SetCVar("X",CA1[2],SetTo,12)})
function S2_CAfunc()
local PlayerID = CAPlotPlayerID
local CA = CAPlotDataArr
local CB = CAPlotCreateArr
CA_MoveRA(_Neg(V(SZ)),V(SW)) -- R : -SZ, A : +SW로 평행이동
end
CA2 = CAPlotForward()
TriggerX(P1,CVar("X",CA2[2],Exactly,2),{RemoveUnit(65,P1),SetCVar("X",SZ,Add,8),
SetCVar("X",SW,Add,16)},{Preserved})
CAPlot(S1,P1,65,"Location 2",nil,1,32,{1,0,0,0,S1[1]/12,0},"S2_CAfunc",P1,nil,nil,
{SetCVar("X",CA2[2],SetTo,12)})
EndCtrig()
EUDTurbo(P1)
-----------------------------------------------------------------------------------------546

------------------------------------------------------------------------------------------

『 7장 : CA_ 실시간 편집함수 (어셈블러 필요) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[예제 7-3] CA_RatioXY(), CA_RatioRA()
SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P2)
StartCtrig()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",0)

CVariable(P1,1) SX = 1 CVariable(P1,2) SY = 2 CVariable(P1,3) SZ = 3 CVariable(P1,4) SW = 4

CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)

DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000),
SetMemory(0x581D78,SetTo,0x75757575),SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})

S1 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,16,16),45),{-128,128},{-128,128})
function S1_CAfunc()
local PlayerID = CAPlotPlayerID
local CA = CAPlotDataArr
local CB = CAPlotCreateArr
CA_RatioXY(V(SX),_Sub(_Mov(36),V(SX)),_Sub(_Mov(36),V(SY)),V(SY))
-- X : SX/(36-SX), Y : (36-SY)/SY
end
CA1 = CAPlotForward()
TriggerX(P1,CVar("X",CA1[2],Exactly,2),{RemoveUnit(54,P1),SetCVar("X",SX,Add,1),
SetCVar("X",SY,Add,1)},{Preserved})
CAPlot(S1,P1,54,"Location 1",nil,1,32,{1,0,0,0,S1[1]/12,0},"S1_CAfunc",P1,nil,nil,
{SetCVar("X",CA1[2],SetTo,12)})
function S2_CAfunc()
local PlayerID = CAPlotPlayerID
local CA = CAPlotDataArr
local CB = CAPlotCreateArr
CA_RatioRA(V(SZ),_Add(V(SZ),10),_Add(V(SW),50),V(SW))
-- R : SZ/(SZ+10), A : (SW+50)/SW
end
CA2 = CAPlotForward()
TriggerX(P1,CVar("X",CA2[2],Exactly,2),{RemoveUnit(65,P1),SetCVar("X",SZ,Add,1),
SetCVar("X",SW,Add,5)},{Preserved})
CAPlot(S1,P1,65,"Location 2",nil,1,32,{1,0,0,0,S1[1]/12,0},"S2_CAfunc",P1,nil,nil,
{SetCVar("X",CA2[2],SetTo,12)})
EndCtrig()
EUDTurbo(P1)
------------------------------------------------------------------------------------------

547

------------------------------------------------------------------------------------------

『 7장 : CA_ 실시간 편집함수 (어셈블러 필요) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[예제 7-4] CA_InvertXY(), CA_InvertRA()
SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P2)
StartCtrig()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",0)

CVariable(P1,1) SX = 1 CVariable(P1,2) SY = 2 CVariable(P1,3) SZ = 3 CVariable(P1,4) SW = 4

CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)

DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000),
SetMemory(0x581D78,SetTo,0x75757575),SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})

S1 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,16,16),45),{-128,128},{-128,128})
function S1_CAfunc()
local PlayerID = CAPlotPlayerID
local CA = CAPlotDataArr
local CB = CAPlotCreateArr
CA_InvertXY(V(SX),V(SY)) -- X : x=SX, Y : y=SY로 반사
end
CA1 = CAPlotForward()
TriggerX(P1,CVar("X",CA1[2],Exactly,2),{RemoveUnit(54,P1),SetCVar("X",SX,Add,16),
SetCVar("X",SY,Add,16)},{Preserved})
CAPlot(S1,P1,54,"Location 1",nil,1,32,{1,0,0,0,S1[1]/12,0},"S1_CAfunc",P1,nil,nil,
{SetCVar("X",CA1[2],SetTo,12)})
function S2_CAfunc()
local PlayerID = CAPlotPlayerID
local CA = CAPlotDataArr
local CB = CAPlotCreateArr
CA_InvertRA(V(SZ),V(SW)) -- R : r=SZ, A : Θ=SW로 반사
end
CA2 = CAPlotForward()
TriggerX(P1,CVar("X",CA2[2],Exactly,2),{RemoveUnit(65,P1),SetCVar("X",SZ,Add,16),
SetCVar("X",SW,Add,16)},{Preserved})
CAPlot(S1,P1,65,"Location 2",nil,1,32,{1,0,0,0,S1[1]/12,0},"S2_CAfunc",P1,nil,nil,
{SetCVar("X",CA2[2],SetTo,12)})
EndCtrig()
EUDTurbo(P1)
-----------------------------------------------------------------------------------------548

------------------------------------------------------------------------------------------

『 7장 : CA_ 실시간 편집함수 (어셈블러 필요) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[예제 7-5] CA_CropXY(), CA_CropRA()
SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P2)
StartCtrig()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",0)

CVariable(P1,1) SX = 1 CVariable(P1,2) SY = 2 CVariable(P1,3) SZ = 3 CVariable(P1,4) SW = 4

CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)

DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000),
SetMemory(0x581D78,SetTo,0x75757575),SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})

S1 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,16,16),45),{-128,128},{-128,128})
function S1_CAfunc()
local PlayerID = CAPlotPlayerID
local CA = CAPlotDataArr
local CB = CAPlotCreateArr
CA_CropXY(_iSub(V(SX),144),nil,_iSub(V(SY),144),nil)
-- X < 144-16*SX, Y < 144-16*SY영역 잘라내기
end
CA1 = CAPlotForward()
TriggerX(P1,CVar("X",CA1[2],Exactly,2),{RemoveUnit(54,P1),SetCVar("X",SX,Add,16),
SetCVar("X",SY,Add,16)},{Preserved})
CAPlot(S1,P1,54,"Location 1",nil,1,32,{1,0,0,0,S1[1]/12,0},"S1_CAfunc",P1,nil,nil,
{SetCVar("X",CA1[2],SetTo,12)})
function S2_CAfunc()
local PlayerID = CAPlotPlayerID
local CA = CAPlotDataArr
local CB = CAPlotCreateArr
CA_CropRA(nil,_iSub(_Mov(192),V(SZ)),nil,_iSub(_Mov(360),V(SW)))
-- R < 192-8*SZ, Θ < 360-16*SW영역 잘라내기
end
CA2 = CAPlotForward()
TriggerX(P1,CVar("X",CA2[2],Exactly,2),{RemoveUnit(65,P1),SetCVar("X",SZ,Add,8),
SetCVar("X",SW,Add,16)},{Preserved})
CAPlot(S1,P1,65,"Location 2",nil,1,32,{1,0,0,0,S1[1]/12,0},"S2_CAfunc",P1,nil,nil,
{SetCVar("X",CA2[2],SetTo,12)})
EndCtrig()
EUDTurbo(P1)
------------------------------------------------------------------------------------------

549

------------------------------------------------------------------------------------------

『 7장 : CA_ 실시간 편집함수 (어셈블러 필요) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[예제 7-6] CA_Rotate(), CA_Rotate3D()
SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P2)
StartCtrig()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",0)

CVariable(P1,1) SX = 1 CVariable(P1,2) SY = 2 CVariable(P1,3) SZ = 3 CVariable(P1,4) SW = 4

CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)

DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000),
SetMemory(0x581D78,SetTo,0x75757575),SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})

S1 = CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,16,16),45),{-128,128},{-128,128})
function S1_CAfunc()
local PlayerID = CAPlotPlayerID
local CA = CAPlotDataArr
local CB = CAPlotCreateArr
CA_Rotate(V(SX)) -- SX 만큼 회전
end
CA1 = CAPlotForward()

TriggerX(P1,CVar("X",CA1[2],Exactly,2),{RemoveUnit(54,P1),SetCVar("X",SX,Add,16)},{Preserved})

CAPlot(S1,P1,54,"Location 1",nil,1,32,{1,0,0,0,S1[1]/12,0},"S1_CAfunc",P1,nil,nil,
{SetCVar("X",CA1[2],SetTo,12)})

function S2_CAfunc()
local PlayerID = CAPlotPlayerID
local CA = CAPlotDataArr
local CB = CAPlotCreateArr
CA_Rotate3D(V(SY),V(SZ),V(SW)) -- XY : SY, YZ : SZ, ZX : SW 만큼 회전
end
CA2 = CAPlotForward()
TriggerX(P1,CVar("X",CA2[2],Exactly,2),{RemoveUnit(65,P1),SetCVar("X",SY,Add,8),
SetCVar("X",SZ,Add,12),SetCVar("X",SW,Add,16)},{Preserved})
CAPlot(S1,P1,65,"Location 2",nil,1,32,{1,0,0,0,S1[1]/12,0},"S2_CAfunc",P1,nil,nil,
{SetCVar("X",CA2[2],SetTo,12)})

EndCtrig()
EUDTurbo(P1)
-----------------------------------------------------------------------------------------550

------------------------------------------------------------------------------------------

『 8장 : CAPlot 함수 (어셈블러 필요) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[예제 8-1] CAPlot(), CAPlotForward(), CAPlotWithProperties()
SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P2)
StartCtrig()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",0) CVariable2(P1,1,"X",SetTo,1) CAX = 1 CVariable(P1,2) CBX = 2
CVariable(P1,5) CBX2 = 5 CVariable(P1,3) CCX = 3 CVariable2(P1,4,"X",SetTo,4) CDX = 4
CVariable2(P1,6,"X",SetTo,1) CEX = 6 CVariable2(P1,7,"X",SetTo,1) CFX = 7 CVariable2(P1,8,"X",SetTo,1*16777216)
CGX = 8 CVariable2(P1,9,"X",SetTo,13) CHX = 9 CVariable(P1,11) CHX2 = 11 CVariable2(P1,10,"X",SetTo,0) CIX = 10
CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)
DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000),
SetMemory(0x581D78,SetTo,0x75757575),SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})
S1
S2
S3
S4

=
=
=
=

CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,32,32),45),{-128,128},{-128,128})
CS_RatioRA(S1,1,4/3)
CS_RatioRA(S1,1,2/1)
CS_RatioRA(S1,1,4/1)

CAPlot(S1,P1,0,"Location 1",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,{SetResources(P1,Add,1,Ore)},{RemoveUnit(0,P1)})
CAPlot({S1,S2,S3,S4},P1,1,"Location 2",nil,1,32,{V(CAX),0,0,0,S1[1]/36,0},nil,P1,nil,nil,{RemoveUnit(1,P1),
SetCVar("X",CAX,Add,1)})
TriggerX(P1,{CVar("X",CAX,AtLeast,4)},{SetCVar("X",CAX,SetTo,0)},{Preserved})

CAPlot(S1,P1,2,"Location 3",nil,1,32,{1,V(CBX),0,0,S1[1]/36,0},nil,P1,nil,{SetCVar("X",CBX2,Add,1)},{RemoveUnit(2,P1)})
TriggerX(P1,{CVar("X",CBX2,AtLeast,S1[1]/3)},{SetCVar("X",CBX2,SetTo,0),SetCVar("X",CBX,Add,24)},{Preserved})
DoActionsX(P1,SetCVar("X",CBX,Subtract,1))
CAPlot(S1,P1,3,"Location 4",nil,1,32,{1,0,V(CCX),0,S1[1]/36,0},nil,P1,nil,nil,{RemoveUnit(3,P1),SetCVar("X",CCX,Add,1)})
TriggerX(P1,{CVar("X",CCX,AtLeast,12)},{SetCVar("X",CCX,SetTo,0)},{Preserved})
CAPlot(S1,P1,5,"Location 5",nil,1,32,{1,0,0,V(CDX),5,0},nil,P1,nil,nil,{RemoveUnit(5,P1)})
CAPlot(S1,P1,7,"Location 6",nil,1,32,{1,0,0,0,V(CEX),0},nil,P1,nil,nil,{SetCVar("X",CEX,Add,1),RemoveUnit(7,P1)})
TriggerX(P1,{CVar("X",CEX,AtLeast,S1[1])},{SetCVar("X",CEX,SetTo,1)},{Preserved})
CAPlot(S1,P1,10,"Location 7",nil,1,32,{1,0,0,0,S1[1]/36,V(CFX)},nil,P1,nil,nil,{RemoveUnit(10,P1)})
DoActionsX(P1,SetCVar("X",CFX,Add,S1[1]/36 +1))
TriggerX(P1,{CVar("X",CFX,AtLeast,S1[1])},{SetCVar("X",CFX,SetTo,1),RemoveUnit(10,P1)},{Preserved})

CAPlot(S1,P1,37,"Location 8",nil,1,32,{1,0,0,0,S1[1]/36,0,V(CGX)},nil,P1,nil,nil,{RemoveUnit(37,P1),
SetCVar("X",CGX,Add,16777216)})
TriggerX(P1,{CVar("X",CGX,AtLeast,16777216*5)},{SetCVar("X",CGX,SetTo,16777216)},{Preserved})
CAPlot(S1,P1,38,"Location 9",nil,1,32,{1,0,0,0,S1[1]/36,0,nil,V(CHX)},nil,P1,nil,nil,{SetCVar("X",CHX2,Add,1)})
TriggerX(P1,{CVar("X",CHX2,AtLeast,3)},{SetCVar("X",CHX2,SetTo,0)},{Preserved})
TriggerX(P1,{CVar("X",CHX2,Exactly,0)},{RemoveUnit(13,P1),SetCVar("X",CHX,SetTo,15)},{Preserved})
TriggerX(P1,{CVar("X",CHX2,Exactly,1)},{RemoveUnit(15,P1),SetCVar("X",CHX,SetTo,16)},{Preserved})
TriggerX(P1,{CVar("X",CHX2,Exactly,2)},{RemoveUnit(16,P1),SetCVar("X",CHX,SetTo,13)},{Preserved})
CAPlot(S1,P1,38,"Location 10",nil,1,32,{1,0,0,0,S1[1]/36,0,nil,nil,V(CIX)},nil,P1,nil,nil,
{RemoveUnit(38,P1),RemoveUnit(38,P2),RemoveUnit(38,P3),RemoveUnit(38,P4),SetCVar("X",CIX,Add,1)})
TriggerX(P1,{CVar("X",CIX,AtLeast,4)},{SetCVar("X",CIX,SetTo,0)},{Preserved})
CYX = CAPlotForward()
TriggerX(P1,CVar("X",CYX[2],Exactly,2),{RemoveUnit(65,P1)},{Preserved})
CAPlotWithProperties(S1,P1,65,"Location 11",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,P1,nil,nil,{SetCVar("X",CYX[2],SetTo,24)},{
clocked = false, burrowed = false, intransit = false, hallucinated = true, invincible = true,
hitpoint = 100,shield = 100,energy = 100,resource = 0,hanger = 0,})
EndCtrig()
EUDTurbo(P1)

------------------------------------------------------------------------------------------

551

------------------------------------------------------------------------------------------

『 8장 : CAPlot 함수 (어셈블러 필요) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[예제 8-2] CAPlotOrder(), CAPlotOrderForward(), CAPlotOrderWithProperties()
SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P2)
StartCtrig()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1",0)
CVariable2(P1,20,"X",SetTo,1) CKX2 = 20
CVariable(P1,21) CLX2 = 21
CVariable(P1,22) CMX = 22
CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)
DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000),SetMemory(0x581D78,SetTo,0x75757575),
SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})
S1
S2
S3
S4

=
=
=
=

CS_CropXY(CS_Rotate(CS_FillXY(1,384,384,32,32),45),{-128,128},{-128,128})
CS_RatioRA(S1,1,4/3)
CS_RatioRA(S1,1,2/1)
CS_RatioRA(S1,1,4/1)

CJX = CAPlotOrderForward()
CAPlotOrder(S1,P1,21,"Location 1",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,S1,Move,"Location 2",nil,{1,0},nil,{0,32},P1,nil,nil,
{SetCVar("X",CJX[2],SetTo,180)})
TriggerX(P1,CVar("X",CJX[2],Exactly,2),{RemoveUnit(21,P1)},{Preserved})
CKX = CAPlotOrderForward()
CAPlotOrder(S1,P1,47,"Location 3",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,{S1,S2,S3,S4},Move,"Location 4",nil,{V(CKX2),0},nil,{0,32},
P1,nil,nil,{SetCVar("X",CKX[2],SetTo,180)})
TriggerX(P1,{CVar("X",CKX[2],Exactly,2),CVar("X",CKX2,Exactly,1)},
{RemoveUnit(47,P1),SetCVar("X",CKX2,SetTo,2),SetCVar("X",CKX[2],SetTo,0)},{Preserved})
TriggerX(P1,{CVar("X",CKX[2],Exactly,2),CVar("X",CKX2,Exactly,2)},
{RemoveUnit(47,P1),SetCVar("X",CKX2,SetTo,3),SetCVar("X",CKX[2],SetTo,0)},{Preserved})
TriggerX(P1,{CVar("X",CKX[2],Exactly,2),CVar("X",CKX2,Exactly,3)},
{RemoveUnit(47,P1),SetCVar("X",CKX2,SetTo,4),SetCVar("X",CKX[2],SetTo,0)},{Preserved})
TriggerX(P1,{CVar("X",CKX[2],Exactly,2),CVar("X",CKX2,Exactly,4)},
{RemoveUnit(47,P1),SetCVar("X",CKX2,SetTo,1),SetCVar("X",CKX[2],SetTo,0)},{Preserved})
CLX = CAPlotOrderForward()
CAPlotOrder(S1,P1,64,"Location 6",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,S1,Move,"Location 7",nil,{1,V(CLX2)},nil,{0,32},P1,nil,nil,
{SetCVar("X",CLX[2],SetTo,180)})
DoActionsX(P1,SetCVar("X",CLX2,Add,S1[1]/36+1))
TriggerX(P1,CVar("X",CLX2,AtLeast,S1[1]),{SetCVar("X",CLX2,SetTo,1)},{Preserved})
TriggerX(P1,CVar("X",CLX[2],Exactly,2),{RemoveUnit(64,P1)},{Preserved})
function S1_CBfunc()
CA_Rotate(V(CMX))
end
CZX = CAPlotOrderForward()
TriggerX(P1,CVar("X",CZX[2],Exactly,2),{RemoveUnit(50,P1),SetCVar("X",CMX,Add,10)},{Preserved})
CAPlotOrderWithProperties(S1,P1,50,"Location 8",nil,1,32,{1,0,0,0,S1[1]/36,0},nil,S1,Move,
"Location 9",nil,{1,0},"S1_CBfunc",{0,32},P1,nil,nil,{SetCVar("X",CZX[2],SetTo,180)},{
clocked = false, burrowed = false, intransit = false, hallucinated = true, invincible = true,
hitpoint = 100, shield = 100, energy = 100, resource = 0, hanger = 0,})
EndCtrig()
EUDTurbo(P1)

-----------------------------------------------------------------------------------------552

------------------------------------------------------------------------------------------

『 9장 : CXPlot 및 3차원 도형함수 (어셈블러 필요) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[예제 9-1] CXMakeShape()
Trigger { -- EUD Editor

players = {P1},
conditions = {
},
actions = {

},
}
--↓ Tep에 그대로 붙여넣기 (각 함수의 설명은 Instruction Set 참고)--SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P1)
StartCtrig()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1")
-- 여기에 변수, 배열 및 Include류 함수 선언 -CVariable(AllPlayers,0x2000) CunitEPD = 0x2000

Always();
SetMemory(0x6616B0, SetTo, 2097615);
SetMemory(0x6643B0, SetTo, 536870916);
SetMemory(0x666460, SetTo, 32965359);
SetMemory(0x66F424, SetTo, 131);
Comment("EUD Editor");

CXArrX = CArray(P1,100)
CXArrY = CArray(P1,100)
CXArrZ = CArray(P1,100)
CVariable(AllPlayers,0x1000) TSize = 0x1000
CVariable(AllPlayers,0x1001) XAngle = 0x1001
CVariable(AllPlayers,0x1002) YAngle = 0x1002
CVariable(AllPlayers,0x1003) ZAngle = 0x1003
CVariable(AllPlayers,0x1004) TCount = 0x1004

CJumpEnd(AllPlayers,0)

CVariable(AllPlayers,0x2000) THeight = 0x2000
CVariable(AllPlayers,0x2001) Arrptr = 0x2001
CVariable(AllPlayers,0x2002) CArrptr = 0x2002
CVariable(AllPlayers,0x2010) Arrptr1 = 0x2010
CVariable(AllPlayers,0x2011) Arrptr2 = 0x2011
CVariable(AllPlayers,0x2012) Var1 = 0x2012
CVariable(AllPlayers,0x2013) Var2 = 0x2013

DoActions(P1,RemoveUnit(204,P2))
TShape = CXMakeShape(96,{0,0,0},{1,1,1},{-1,1,1},{1,-1,1},{1,1,-1},{-1,-1,1},{-1,1,-1},{1,-1,-1},{-1,-1,-1}) -- 중심점을 포함한 2x2x2 정육면체 (Z>0 하양 / Z=0 파랑 / Z<0 검정)
--------------------------------------------------------------------------------------------SHLX = 1365
SHLY = 1365
Trigger {

players = {P1},
conditions = {
},
actions = {

}
Trigger {

}

players = {P1},
conditions = {
},
actions = {

}

}

function CXfunc()

Label(0);
SetCVar("X",TCount,SetTo,1);
SetCVar("X",TSize,SetTo,540*3*6);
CenterView("Location 7");

Label(0);
SetCVar("X",XAngle,Add,11);
SetCVar("X",YAngle,Add,8);
SetCVar("X",ZAngle,Add,5);
SetCVar("X",TSize,Add,4);
SetCVar("X",TCount,SetTo,1);
PreserveTrigger();

local CA = CAPlotDataArr
local CB = CAPlotCreateArr
local PlayerID = CAPlotPlayerID
CX_Ratio(V(TSize),540*3*12,V(TSize),540*3*12,V(TSize),540*3*12)
CX_Rotate(_Div(V(XAngle),10),_Div(V(YAngle),10),_Div(V(ZAngle),10))
Trigger {

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtLeast,0x80000000);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 10*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 0,0xFF); -- 높이
PreserveTrigger();
}

}
Trigger {

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtMost,0x7FFFFFFF);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 0*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 20,0xFF); -- 높이
PreserveTrigger();
}
Trigger {

}

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],Exactly,0x0);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 16*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 12,0xFF); -- 높이
PreserveTrigger();
}

}

end
CXPlot(TShape,P2,204,"Location 0",{SHLX,SHLY},1,16,{1,0,0,0,TShape[1],V(TCount)},"CXfunc",P1,Always(),nil,nil)
CMov(P1,V(CunitEPD),161741)
CWhile(P1,{CVar("X",CunitEPD,AtLeast,19025)})
CWhileEnd({SetCVar("X",CunitEPD,Subtract,84)})

CTrigger(P1,{TDeaths(Vi(CunitEPD,25),Exactly,204,0)},
{TSetDeathsX(Vi(CunitEPD,55),SetTo,0x104,0,0x104),TSetDeathsX(Vi(0x2000,57),SetTo,0,0,0xFF)},{Preserved}) -- 유닛 드래그 방지

EndCtrig()
EUDTurbo(P1)
------------------------------------------------------------------------------------------

553

------------------------------------------------------------------------------------------

『 9장 : CXPlot 및 3차원 도형함수 (어셈블러 필요) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[예제 9-2] CXMakePolyhedron()
Trigger { -- EUD Editor

players = {P1},
conditions = {
},
actions = {

},
}
--↓ Tep에 그대로 붙여넣기 (각 함수의 설명은 Instruction Set 참고)--SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P1)
StartCtrig()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1")
-- 여기에 변수, 배열 및 Include류 함수 선언 -CVariable(AllPlayers,0x2000) CunitEPD = 0x2000

Always();
SetMemory(0x6616B0, SetTo, 2097615);
SetMemory(0x6643B0, SetTo, 536870916);
SetMemory(0x666460, SetTo, 32965359);
SetMemory(0x66F424, SetTo, 131);
Comment("EUD Editor");

CXArrX = CArray(P1,100)
CXArrY = CArray(P1,100)
CXArrZ = CArray(P1,100)
CVariable(AllPlayers,0x1000) TSize = 0x1000
CVariable(AllPlayers,0x1001) XAngle = 0x1001
CVariable(AllPlayers,0x1002) YAngle = 0x1002
CVariable(AllPlayers,0x1003) ZAngle = 0x1003
CVariable(AllPlayers,0x1004) TCount = 0x1004

CJumpEnd(AllPlayers,0)

CVariable(AllPlayers,0x2000) THeight = 0x2000
CVariable(AllPlayers,0x2001) Arrptr = 0x2001
CVariable(AllPlayers,0x2002) CArrptr = 0x2002
CVariable(AllPlayers,0x2010) Arrptr1 = 0x2010
CVariable(AllPlayers,0x2011) Arrptr2 = 0x2011
CVariable(AllPlayers,0x2012) Var1 = 0x2012
CVariable(AllPlayers,0x2013) Var2 = 0x2013

DoActions(P1,RemoveUnit(204,P2))
TShape = CXMakePolyhedron(20,128) -- 한변의 크기가 128인 정20면체 (Z>0 하양 / Z=0 파랑 / Z<0 검정)
--------------------------------------------------------------------------------------------SHLX = 1365
SHLY = 1365
Trigger {

players = {P1},
conditions = {
},
actions = {

}
Trigger {

}

players = {P1},
conditions = {
},
actions = {

}

}

function CXfunc()

Label(0);
SetCVar("X",TCount,SetTo,1);
SetCVar("X",TSize,SetTo,540*3*6);
CenterView("Location 7");

Label(0);
SetCVar("X",XAngle,Add,11);
SetCVar("X",YAngle,Add,8);
SetCVar("X",ZAngle,Add,5);
SetCVar("X",TSize,Add,4);
SetCVar("X",TCount,SetTo,1);
PreserveTrigger();

local CA = CAPlotDataArr
local CB = CAPlotCreateArr
local PlayerID = CAPlotPlayerID
CX_Ratio(V(TSize),540*3*12,V(TSize),540*3*12,V(TSize),540*3*12)
CX_Rotate(_Div(V(XAngle),10),_Div(V(YAngle),10),_Div(V(ZAngle),10))
Trigger {

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtLeast,0x80000000);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 10*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 0,0xFF); -- 높이
PreserveTrigger();
}

}
Trigger {

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtMost,0x7FFFFFFF);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 0*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 20,0xFF); -- 높이
PreserveTrigger();
}
Trigger {

}

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],Exactly,0x0);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 16*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 12,0xFF); -- 높이
PreserveTrigger();
}

}

end
CXPlot(TShape,P2,204,"Location 0",{SHLX,SHLY},1,16,{1,0,0,0,TShape[1],V(TCount)},"CXfunc",P1,Always(),nil,nil)
CMov(P1,V(CunitEPD),161741)
CWhile(P1,{CVar("X",CunitEPD,AtLeast,19025)})
CWhileEnd({SetCVar("X",CunitEPD,Subtract,84)})

CTrigger(P1,{TDeaths(Vi(CunitEPD,25),Exactly,204,0)},
{TSetDeathsX(Vi(CunitEPD,55),SetTo,0x104,0,0x104),TSetDeathsX(Vi(0x2000,57),SetTo,0,0,0xFF)},{Preserved}) -- 유닛 드래그 방지

EndCtrig()
EUDTurbo(P1)
------------------------------------------------------------------------------------------

554

------------------------------------------------------------------------------------------

『 9장 : CXPlot 및 3차원 도형함수 (어셈블러 필요) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[예제 9-3] CXMakePrism()
Trigger { -- EUD Editor

players = {P1},
conditions = {
},
actions = {

},
}
--↓ Tep에 그대로 붙여넣기 (각 함수의 설명은 Instruction Set 참고)--SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P1)
StartCtrig()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1")
-- 여기에 변수, 배열 및 Include류 함수 선언 -CVariable(AllPlayers,0x2000) CunitEPD = 0x2000

Always();
SetMemory(0x6616B0, SetTo, 2097615);
SetMemory(0x6643B0, SetTo, 536870916);
SetMemory(0x666460, SetTo, 32965359);
SetMemory(0x66F424, SetTo, 131);
Comment("EUD Editor");

CXArrX = CArray(P1,100)
CXArrY = CArray(P1,100)
CXArrZ = CArray(P1,100)
CVariable(AllPlayers,0x1000) TSize = 0x1000
CVariable(AllPlayers,0x1001) XAngle = 0x1001
CVariable(AllPlayers,0x1002) YAngle = 0x1002
CVariable(AllPlayers,0x1003) ZAngle = 0x1003
CVariable(AllPlayers,0x1004) TCount = 0x1004

CJumpEnd(AllPlayers,0)

CVariable(AllPlayers,0x2000) THeight = 0x2000
CVariable(AllPlayers,0x2001) Arrptr = 0x2001
CVariable(AllPlayers,0x2002) CArrptr = 0x2002
CVariable(AllPlayers,0x2010) Arrptr1 = 0x2010
CVariable(AllPlayers,0x2011) Arrptr2 = 0x2011
CVariable(AllPlayers,0x2012) Var1 = 0x2012
CVariable(AllPlayers,0x2013) Var2 = 0x2013

DoActions(P1,RemoveUnit(204,P2))
TShape = CXMakePrism(3,96,0,192) -- 밑변 반지름이 96, 높이가 192인 삼각기둥 (Z>0 하양 / Z=0 파랑 / Z<0 검정)
--------------------------------------------------------------------------------------------SHLX = 1365
SHLY = 1365
Trigger {

players = {P1},
conditions = {
},
actions = {

}
Trigger {

}

players = {P1},
conditions = {
},
actions = {

}

}

function CXfunc()

Label(0);
SetCVar("X",TCount,SetTo,1);
SetCVar("X",TSize,SetTo,540*3*6);
CenterView("Location 7");

Label(0);
SetCVar("X",XAngle,Add,11);
SetCVar("X",YAngle,Add,8);
SetCVar("X",ZAngle,Add,5);
SetCVar("X",TSize,Add,4);
SetCVar("X",TCount,SetTo,1);
PreserveTrigger();

local CA = CAPlotDataArr
local CB = CAPlotCreateArr
local PlayerID = CAPlotPlayerID
CX_Ratio(V(TSize),540*3*12,V(TSize),540*3*12,V(TSize),540*3*12)
CX_Rotate(_Div(V(XAngle),10),_Div(V(YAngle),10),_Div(V(ZAngle),10))
Trigger {

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtLeast,0x80000000);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 10*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 0,0xFF); -- 높이
PreserveTrigger();
}

}
Trigger {

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtMost,0x7FFFFFFF);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 0*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 20,0xFF); -- 높이
PreserveTrigger();
}
Trigger {

}

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],Exactly,0x0);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 16*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 12,0xFF); -- 높이
PreserveTrigger();
}

}

end
CXPlot(TShape,P2,204,"Location 0",{SHLX,SHLY},1,16,{1,0,0,0,TShape[1],V(TCount)},"CXfunc",P1,Always(),nil,nil)
CMov(P1,V(CunitEPD),161741)
CWhile(P1,{CVar("X",CunitEPD,AtLeast,19025)})
CWhileEnd({SetCVar("X",CunitEPD,Subtract,84)})

CTrigger(P1,{TDeaths(Vi(CunitEPD,25),Exactly,204,0)},
{TSetDeathsX(Vi(CunitEPD,55),SetTo,0x104,0,0x104),TSetDeathsX(Vi(0x2000,57),SetTo,0,0,0xFF)},{Preserved}) -- 유닛 드래그 방지

EndCtrig()
EUDTurbo(P1)
------------------------------------------------------------------------------------------

555

------------------------------------------------------------------------------------------

『 9장 : CXPlot 및 3차원 도형함수 (어셈블러 필요) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[예제 9-4] CXMakePyramid()
Trigger { -- EUD Editor

players = {P1},
conditions = {
},
actions = {

},
}
--↓ Tep에 그대로 붙여넣기 (각 함수의 설명은 Instruction Set 참고)--SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P1)
StartCtrig()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1")
-- 여기에 변수, 배열 및 Include류 함수 선언 -CVariable(AllPlayers,0x2000) CunitEPD = 0x2000

Always();
SetMemory(0x6616B0, SetTo, 2097615);
SetMemory(0x6643B0, SetTo, 536870916);
SetMemory(0x666460, SetTo, 32965359);
SetMemory(0x66F424, SetTo, 131);
Comment("EUD Editor");

CXArrX = CArray(P1,100)
CXArrY = CArray(P1,100)
CXArrZ = CArray(P1,100)
CVariable(AllPlayers,0x1000) TSize = 0x1000
CVariable(AllPlayers,0x1001) XAngle = 0x1001
CVariable(AllPlayers,0x1002) YAngle = 0x1002
CVariable(AllPlayers,0x1003) ZAngle = 0x1003
CVariable(AllPlayers,0x1004) TCount = 0x1004

CJumpEnd(AllPlayers,0)

CVariable(AllPlayers,0x2000) THeight = 0x2000
CVariable(AllPlayers,0x2001) Arrptr = 0x2001
CVariable(AllPlayers,0x2002) CArrptr = 0x2002
CVariable(AllPlayers,0x2010) Arrptr1 = 0x2010
CVariable(AllPlayers,0x2011) Arrptr2 = 0x2011
CVariable(AllPlayers,0x2012) Var1 = 0x2012
CVariable(AllPlayers,0x2013) Var2 = 0x2013

DoActions(P1,RemoveUnit(204,P2))
TShape = CXMakePyramid(8,96,0,384) -- 밑변 반지름이 96, 높이가 384인 팔각뿔 (Z>0 하양 / Z=0 파랑 / Z<0 검정)
--------------------------------------------------------------------------------------------SHLX = 1365
SHLY = 1365
Trigger {

players = {P1},
conditions = {
},
actions = {

}
Trigger {

}

players = {P1},
conditions = {
},
actions = {

}

}

function CXfunc()

Label(0);
SetCVar("X",TCount,SetTo,1);
SetCVar("X",TSize,SetTo,540*3*6);
CenterView("Location 7");

Label(0);
SetCVar("X",XAngle,Add,11);
SetCVar("X",YAngle,Add,8);
SetCVar("X",ZAngle,Add,5);
SetCVar("X",TSize,Add,4);
SetCVar("X",TCount,SetTo,1);
PreserveTrigger();

local CA = CAPlotDataArr
local CB = CAPlotCreateArr
local PlayerID = CAPlotPlayerID
CX_Ratio(V(TSize),540*3*12,V(TSize),540*3*12,V(TSize),540*3*12)
CX_Rotate(_Div(V(XAngle),10),_Div(V(YAngle),10),_Div(V(ZAngle),10))
Trigger {

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtLeast,0x80000000);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 10*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 0,0xFF); -- 높이
PreserveTrigger();
}

}
Trigger {

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtMost,0x7FFFFFFF);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 0*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 20,0xFF); -- 높이
PreserveTrigger();
}
Trigger {

}

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],Exactly,0x0);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 16*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 12,0xFF); -- 높이
PreserveTrigger();
}

}

end
CXPlot(TShape,P2,204,"Location 0",{SHLX,SHLY},1,16,{1,0,0,0,TShape[1],V(TCount)},"CXfunc",P1,Always(),nil,nil)
CMov(P1,V(CunitEPD),161741)
CWhile(P1,{CVar("X",CunitEPD,AtLeast,19025)})
CWhileEnd({SetCVar("X",CunitEPD,Subtract,84)})

CTrigger(P1,{TDeaths(Vi(CunitEPD,25),Exactly,204,0)},
{TSetDeathsX(Vi(CunitEPD,55),SetTo,0x104,0,0x104),TSetDeathsX(Vi(0x2000,57),SetTo,0,0,0xFF)},{Preserved}) -- 유닛 드래그 방지

EndCtrig()
EUDTurbo(P1)
------------------------------------------------------------------------------------------

556

------------------------------------------------------------------------------------------

『 9장 : CXPlot 및 3차원 도형함수 (어셈블러 필요) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[예제 9-5] CXConnectPath()
Trigger { -- EUD Editor

players = {P1},
conditions = {
},
actions = {

},
}
--↓ Tep에 그대로 붙여넣기 (각 함수의 설명은 Instruction Set 참고)--SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P1)
StartCtrig()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1")
-- 여기에 변수, 배열 및 Include류 함수 선언 -CVariable(AllPlayers,0x2000) CunitEPD = 0x2000

Always();
SetMemory(0x6616B0, SetTo, 2097615);
SetMemory(0x6643B0, SetTo, 536870916);
SetMemory(0x666460, SetTo, 32965359);
SetMemory(0x66F424, SetTo, 131);
Comment("EUD Editor");

CXArrX = CArray(P1,100)
CXArrY = CArray(P1,100)
CXArrZ = CArray(P1,100)
CVariable(AllPlayers,0x1000) TSize = 0x1000
CVariable(AllPlayers,0x1001) XAngle = 0x1001
CVariable(AllPlayers,0x1002) YAngle = 0x1002
CVariable(AllPlayers,0x1003) ZAngle = 0x1003
CVariable(AllPlayers,0x1004) TCount = 0x1004

CJumpEnd(AllPlayers,0)

CVariable(AllPlayers,0x2000) THeight = 0x2000
CVariable(AllPlayers,0x2001) Arrptr = 0x2001
CVariable(AllPlayers,0x2002) CArrptr = 0x2002
CVariable(AllPlayers,0x2010) Arrptr1 = 0x2010
CVariable(AllPlayers,0x2011) Arrptr2 = 0x2011
CVariable(AllPlayers,0x2012) Var1 = 0x2012
CVariable(AllPlayers,0x2013) Var2 = 0x2013

DoActions(P1,RemoveUnit(204,P2))
TShape = CXConnectPath(CXMakePolyhedron(4,192),3,{{1,4},{2,3}}) -- 정사면체 + 꼬인위치 선 2개 잇기 (Z>0 하양 / Z=0 파랑 / Z<0 검정)
--------------------------------------------------------------------------------------------SHLX = 1365
SHLY = 1365
Trigger {

players = {P1},
conditions = {
},
actions = {

}
Trigger {

}

players = {P1},
conditions = {
},
actions = {

}

}

function CXfunc()

Label(0);
SetCVar("X",TCount,SetTo,1);
SetCVar("X",TSize,SetTo,540*3*6);
CenterView("Location 7");

Label(0);
SetCVar("X",XAngle,Add,11);
SetCVar("X",YAngle,Add,8);
SetCVar("X",ZAngle,Add,5);
SetCVar("X",TSize,Add,4);
SetCVar("X",TCount,SetTo,1);
PreserveTrigger();

local CA = CAPlotDataArr
local CB = CAPlotCreateArr
local PlayerID = CAPlotPlayerID
CX_Ratio(V(TSize),540*3*12,V(TSize),540*3*12,V(TSize),540*3*12)
CX_Rotate(_Div(V(XAngle),10),_Div(V(YAngle),10),_Div(V(ZAngle),10))
Trigger {

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtLeast,0x80000000);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 10*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 0,0xFF); -- 높이
PreserveTrigger();
}

}
Trigger {

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtMost,0x7FFFFFFF);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 0*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 20,0xFF); -- 높이
PreserveTrigger();
}
Trigger {

}

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],Exactly,0x0);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 16*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 12,0xFF); -- 높이
PreserveTrigger();
}

}

end
CXPlot(TShape,P2,204,"Location 0",{SHLX,SHLY},1,16,{1,0,0,0,TShape[1],V(TCount)},"CXfunc",P1,Always(),nil,nil)
CMov(P1,V(CunitEPD),161741)
CWhile(P1,{CVar("X",CunitEPD,AtLeast,19025)})
CWhileEnd({SetCVar("X",CunitEPD,Subtract,84)})

CTrigger(P1,{TDeaths(Vi(CunitEPD,25),Exactly,204,0)},
{TSetDeathsX(Vi(CunitEPD,55),SetTo,0x104,0,0x104),TSetDeathsX(Vi(0x2000,57),SetTo,0,0,0xFF)},{Preserved}) -- 유닛 드래그 방지

EndCtrig()
EUDTurbo(P1)
------------------------------------------------------------------------------------------

557

------------------------------------------------------------------------------------------

『 9장 : CXPlot 및 3차원 도형함수 (어셈블러 필요) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[예제 9-6] CXConvertShape()
Trigger { -- EUD Editor

players = {P1},
conditions = {
},
actions = {

},
}
--↓ Tep에 그대로 붙여넣기 (각 함수의 설명은 Instruction Set 참고)--SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P1)
StartCtrig()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1")
-- 여기에 변수, 배열 및 Include류 함수 선언 -CVariable(AllPlayers,0x2000) CunitEPD = 0x2000

Always();
SetMemory(0x6616B0, SetTo, 2097615);
SetMemory(0x6643B0, SetTo, 536870916);
SetMemory(0x666460, SetTo, 32965359);
SetMemory(0x66F424, SetTo, 131);
Comment("EUD Editor");

CXArrX = CArray(P1,100)
CXArrY = CArray(P1,100)
CXArrZ = CArray(P1,100)
CVariable(AllPlayers,0x1000) TSize = 0x1000
CVariable(AllPlayers,0x1001) XAngle = 0x1001
CVariable(AllPlayers,0x1002) YAngle = 0x1002
CVariable(AllPlayers,0x1003) ZAngle = 0x1003
CVariable(AllPlayers,0x1004) TCount = 0x1004

CJumpEnd(AllPlayers,0)

CVariable(AllPlayers,0x2000) THeight = 0x2000
CVariable(AllPlayers,0x2001) Arrptr = 0x2001
CVariable(AllPlayers,0x2002) CArrptr = 0x2002
CVariable(AllPlayers,0x2010) Arrptr1 = 0x2010
CVariable(AllPlayers,0x2011) Arrptr2 = 0x2011
CVariable(AllPlayers,0x2012) Var1 = 0x2012
CVariable(AllPlayers,0x2013) Var2 = 0x2013

DoActions(P1,RemoveUnit(204,P2))
Shape1 = CS_MoveCenter(CSMakePath({-160,0},{64,0},{64,64},{160,-32},{64,-128},{64,-64},{-160,-64}),0,0) -- →모양 Path
function Zfunc1(X,Y)
end
function Zfunc2(X,Y)

return -96

return 96
end
TShape = CXOverlap(CXConvertShape(Shape1,nil,"Zfunc1"),CXConvertShape(CS_Rotate(Shape1,180),nil,"Zfunc2")) -- 화살표 2개 겹치기 (Z>0 하양 / Z=0 파랑 / Z<0 검정)
--------------------------------------------------------------------------------------------SHLX = 1365
SHLY = 1365
Trigger {

players = {P1},
conditions = {
},
actions = {

}
Trigger {

}

players = {P1},
conditions = {
},
actions = {

}

}

function CXfunc()

Label(0);
SetCVar("X",TCount,SetTo,1);
SetCVar("X",TSize,SetTo,540*3*6);
CenterView("Location 7");

Label(0);
SetCVar("X",XAngle,Add,11);
SetCVar("X",YAngle,Add,8);
SetCVar("X",ZAngle,Add,5);
SetCVar("X",TSize,Add,4);
SetCVar("X",TCount,SetTo,1);
PreserveTrigger();

local CA = CAPlotDataArr
local CB = CAPlotCreateArr
local PlayerID = CAPlotPlayerID
CX_Ratio(V(TSize),540*3*12,V(TSize),540*3*12,V(TSize),540*3*12)
CX_Rotate(_Div(V(XAngle),10),_Div(V(YAngle),10),_Div(V(ZAngle),10))
Trigger {

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtLeast,0x80000000);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 10*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 0,0xFF); -- 높이
PreserveTrigger();
}

}
Trigger {

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtMost,0x7FFFFFFF);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 0*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 20,0xFF); -- 높이
PreserveTrigger();
}
Trigger {

}

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],Exactly,0x0);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 16*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 12,0xFF); -- 높이
PreserveTrigger();
}

}

end
CXPlot(TShape,P2,204,"Location 0",{SHLX,SHLY},1,16,{1,0,0,0,TShape[1],V(TCount)},"CXfunc",P1,Always(),nil,nil)
CMov(P1,V(CunitEPD),161741)
CWhile(P1,{CVar("X",CunitEPD,AtLeast,19025)})
CWhileEnd({SetCVar("X",CunitEPD,Subtract,84)})

EndCtrig()
EUDTurbo(P1)

CTrigger(P1,{TDeaths(Vi(CunitEPD,25),Exactly,204,0)},
{TSetDeathsX(Vi(CunitEPD,55),SetTo,0x104,0,0x104),TSetDeathsX(Vi(0x2000,57),SetTo,0,0,0xFF)},{Preserved}) -- 유닛 드래그 방지

------------------------------------------------------------------------------------------

558

------------------------------------------------------------------------------------------

『 9장 : CXPlot 및 3차원 도형함수 (어셈블러 필요) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[고급 예제 9-A]
원점대칭 좌표 최적화 (도형 중심에 대해 점대칭인 두 점에 대해서 사용가능)
Trigger { -- EUD Editor

players = {P1},
conditions = {

Always();

},
actions = {

}
--↓ Tep에 그대로 붙여넣기 (각 함수의 설명은 Instruction Set 참고)--SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P1)
StartCtrig()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1")
-- 여기에 변수, 배열 및 Include류 함수 선언 --

SetMemory(0x6616B0, SetTo, 2097615);
SetMemory(0x6643B0, SetTo, 536870916);
SetMemory(0x666460, SetTo, 32965359);
SetMemory(0x66F424, SetTo, 131);
Comment("EUD Editor");

},

CVariable(AllPlayers,0x2000) CunitEPD = 0x2000
CXArrX = CArray(P1,100)
CXArrY = CArray(P1,100)
CXArrZ = CArray(P1,100)
CVariable(AllPlayers,0x1000) TSize = 0x1000
CVariable(AllPlayers,0x1001) XAngle = 0x1001
CVariable(AllPlayers,0x1002) YAngle = 0x1002
CVariable(AllPlayers,0x1003) ZAngle = 0x1003
CVariable(AllPlayers,0x1004) TCount = 0x1004

CJumpEnd(AllPlayers,0)

CVariable(AllPlayers,0x2000) THeight = 0x2000
CVariable(AllPlayers,0x2001) Arrptr = 0x2001
CVariable(AllPlayers,0x2002) CArrptr = 0x2002
CVariable(AllPlayers,0x2010) Arrptr1 = 0x2010
CVariable(AllPlayers,0x2011) Arrptr2 = 0x2011
CVariable(AllPlayers,0x2012) Var1 = 0x2012
CVariable(AllPlayers,0x2013) Var2 = 0x2013

DoActions(P1,RemoveUnit(204,P2))
TTemp = CXMakePolyhedron(12,128) -- 한변의 크기가 128인 정20면체 (Z>0 하양 / Z=0 파랑 / Z<0 검정)
TNumber = TTemp[1]/2 + 1
TShape = {1,{0,0,0}} -- 원점 데이터 삽입
local Sym = {{1,8},{2,7},{3,6},{4,5},{9,12},{10,11},{13,16},{14,15},{17,20},{18,19}}
for i = 1, TTemp[1]/2 do
end
---------------------------------------------------------------------------------------------

table.insert(TShape,{TTemp[Sym[i][1]+1][1],TTemp[Sym[i][1]+1][2], TTemp[Sym[i][1]+1][3]})
TShape[1] = TShape[1] + 1

SHLX = 1365
SHLY = 1365
Trigger {

players = {P1},
conditions = {
},
actions = {

}
Trigger {

}

players = {P1},
conditions = {
},
actions = {

}

}

function CXfunc()

Label(0);
SetCVar("X",TCount,SetTo,1);
SetCVar("X",TSize,SetTo,540*3*6);
CenterView("Location 7");

Label(0);
SetCVar("X",XAngle,Add,11);
SetCVar("X",YAngle,Add,8);
SetCVar("X",ZAngle,Add,5);
SetCVar("X",TSize,Add,4);
SetCVar("X",TCount,SetTo,1);
PreserveTrigger();

local CA = CAPlotDataArr
local CB = CAPlotCreateArr
local PlayerID = CAPlotPlayerID
CX_Ratio(V(TSize),540*3*12,V(TSize),540*3*12, V(TSiz e),540*3*12)
CX_Rotate(_Div(V(XAngle),10),_Div(V(YAngle),10),_D iv(V(Z Angle), 10))
CIfX(P1,{CVar("X",CA[6],Exactly,1)},{Set CVar(" X",CB[2],SetTo ,193)}) -- 원점일때 유닛 생성X

CElseX({SetCVar("X",CB[2],SetTo,204)})

-- 연산후 좌표를 배열에 저장

CMov(P1,Arr(CXArrX,0),_Add(V(CA[8]), V(CA[8])))
CMov(P1,Arr(CXArrY,0),_Add(V(CA[9]), V(CA[9])))
CMov(P1,Arr(CXArrZ,0),_Add(V(CA[11]),V(CA[11])))
for i = 2, TNumber do
Trigger {

players = {P1},
conditions = {
Label(0);
CVar("X",CA[6],Exactly,i);
},
actions = {
SetCVar("X",CArrptr,SetTo,i-1);
PreserveTrigger();
}
end

}

CMovX(P1,Arr(CXArrX,V(CArrptr)),V(C A[8]))
CMovX(P1,Arr(CXArrY,V(CArrptr)),V(C A[9]))
CMovX(P1,Arr(CXArrZ,V(CArrptr)),V(C A[11]))
CIfXEnd()
Trigger {
players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtLeast,0x80000000);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 10*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 0,0xFF); -- 높이
PreserveTrigger();
}

}
Trigger {

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtMost,0x7FFFFFFF);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 0*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 20,0xFF); -- 높이
PreserveTrigger();
}

}

Trigger {
players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],Exactly,0x0);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 16*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 12,0xFF); -- 높이
PreserveTrigger();
}

}
CJump(P1,0x1)

Trigger {

players = {P1},
conditions = {

Label(0x2800);

},
actions = {

PreserveTrigger();
}
CIf(P1,CVar("X",CA[6],AtLeast,3))

}

for i = 2, TNumber do

Trigger {
players = {P1},
conditions = {
Label(0);
CVar("X",CA[6],AtLeast,i+1);
},
actions = {
SetCVar("X",Arrptr1,SetTo,i-1);
PreserveTrigger();
}
}

end
CMov(P1,V(CA[8]),_iSub(_Read(Arr(CX ArrX,0)),_Read (Arr(CX ArrX,V (Arrptr 1))))) -- 대칭점 좌표 불러오기
CMov(P1,V(CA[9]),_iSub(_Read(Arr(CX ArrY,0)),_Read (Arr(CX ArrY,V (Arrptr 1)))))
CMov(P1,V(CA[11]),_iSub(_Read(Arr(C XArrZ,0)),_Rea d(Arr(C XArrZ, V(Arrpt r1)))))
CDoActions(P1,{

})

TSetLoc("Location 0","L",SetTo,Vi(CA[8],SHLX-16));
TSetLoc("Location 0","R",SetTo,Vi(CA[8],SHLX+16));
TSetLoc("Location 0","U",SetTo,Vi(CA[9],SHLY-16));
TSetLoc("Location 0","D",SetTo,Vi(CA[9],SHLY+16));

Trigger {
players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtLeast,0x80000000);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 10*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 0,0xFF); -- 높이
CreateUnit(1,204,"Location 0",P2);
PreserveTrigger();
}

}
Trigger {

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtMost,0x7FFFFFFF);
CVar("X",CA[11],AtLeast,0x1);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 0*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 20,0xFF); -- 높이
CreateUnit(1,204,"Location 0",P2);
PreserveTrigger();
}

}

Trigger {
players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],Exactly,0x0);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 16*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 12,0xFF); -- 높이
CreateUnit(1,204,"Location 0",P2);
PreserveTrigger();
}

}

CIfEnd()
Trigger {

players = {P1},
conditions = {

Label(0x2801);

},
actions = {

PreserveTrigger();
CJumpEnd(P1,0x1)
end
CXPlot(TShape,P2,204,"Location
CMov(P1,V(CunitEPD),161741)
CWhile(P1,{CVar("X",CunitEPD,AtLea st,19025)})
CWhileEnd({SetCVar("X",CunitEPD,Subtract ,84)})

}

}

0",{SHLX,SHLY},1,16,{1,0,0,0,TShape[1], V(TCo unt)},"C Xfunc" ,P1,Al ways(),{SetNex t("X",0x 2800),SetNext (0x2801,"X",1)},nil)

CTrigger(P1,{TDeaths(Vi(CunitEPD,25),Exactl y,204,0)},
{TSetDeathsX(Vi(CunitEPD,55),SetTo, 0x104,0,0x104),TSetD eathsX(Vi(0x2000,57), SetTo, 0,0,0xF F)},{Preserved})

-- 유닛 드래그 방지

EndCtrig()
EUDTurbo(P1)
------------------------------------------------------------------------------------------

559

------------------------------------------------------------------------------------------

『 9장 : CXPlot 및 3차원 도형함수 (어셈블러 필요) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[고급 예제 9-B] 내분점 좌표 최적화 (도형의 모서리를 자를때 사용가능)
Trigger { -- EUD Editor

players = {P1},
conditions = {

Always();

},
actions = {

}
--↓ Tep에 그대로 붙여넣기 (각 함수의 설명은 Instruction Set 참고)--SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P1)
StartCtrig()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1")
-- 여기에 변수, 배열 및 Include류 함수 선언 --

SetMemory(0x6616B0, SetTo, 2097615);
SetMemory(0x6643B0, SetTo, 536870916);
SetMemory(0x666460, SetTo, 32965359);
SetMemory(0x66F424, SetTo, 131);
Comment("EUD Editor");

},

CVariable(AllPlayers,0x2000) CunitEPD = 0x2000
CXArrX = CArray(P1,100)
CXArrY = CArray(P1,100)
CXArrZ = CArray(P1,100)
CVariable(AllPlayers,0x1000) TSize = 0x1000
CVariable(AllPlayers,0x1001) XAngle = 0x1001
CVariable(AllPlayers,0x1002) YAngle = 0x1002
CVariable(AllPlayers,0x1003) ZAngle = 0x1003
CVariable(AllPlayers,0x1004) TCount = 0x1004

CJumpEnd(AllPlayers,0)

CVariable(AllPlayers,0x2000) THeight = 0x2000
CVariable(AllPlayers,0x2001) Arrptr = 0x2001
CVariable(AllPlayers,0x2002) CArrptr = 0x2002
CVariable(AllPlayers,0x2010) Arrptr1 = 0x2010
CVariable(AllPlayers,0x2011) Arrptr2 = 0x2011
CVariable(AllPlayers,0x2012) Var1 = 0x2012
CVariable(AllPlayers,0x2013) Var2 = 0x2013

DoActions(P1,RemoveUnit(204,P2))
TShape = CXMakePrism(5,96,0,288) -- 밑변 반지름이 96, 높이가 288인 오각기둥 (Z>0 하양 / Z=0 파랑 / Z<0 검정)
---------------------------------------------------------------------------------------------

SHLX = 1365
SHLY = 1365
Trigger {

players = {P1},
conditions = {
},
actions = {

}
Trigger {

}

players = {P1},
conditions = {
},
actions = {

}

CMov(P1,V(Arrptr),1)
CMov(P1,V(CArrptr),1)
function CXfunc()

}

Label(0);
SetCVar("X",TCount,SetTo,1);
SetCVar("X",TSize,SetTo,540*3*6);
CenterView("Location 7");

Label(0);
SetCVar("X",XAngle,Add,11);
SetCVar("X",YAngle,Add,8);
SetCVar("X",ZAngle,Add,5);
SetCVar("X",TSize,Add,4);
SetCVar("X",TCount,SetTo,1);
PreserveTrigger();

local CA = CAPlotDataArr
local CB = CAPlotCreateArr
local PlayerID = CAPlotPlayerID
CX_Ratio(V(TSize),540*3*12,V(TSize),540*3*12, V(TSiz e),540*3*12)
CX_Rotate(_Div(V(XAngle),10),_Div(V(YAngle),10),_D iv(V(Z Angle), 10))
CMovX(P1,Arr(CXArrX,V(CArrptr)),V(C A[8]))
CMovX(P1,Arr(CXArrY,V(CArrptr)),V(C A[9]))
CMovX(P1,Arr(CXArrZ,V(CArrptr)),V(C A[11]))
CAdd(P1,V(CArrptr),1)
Trigger {

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtLeast,0x80000000);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 10*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 0,0xFF); -- 높이
PreserveTrigger();
}

}
Trigger {

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtMost,0x7FFFFFFF);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 0*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 20,0xFF); -- 높이
PreserveTrigger();
}

}

Trigger {
players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],Exactly,0x0);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 16*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 12,0xFF); -- 높이
PreserveTrigger();
}
CJump(P1,0x1)

}
Trigger {

players = {P1},
conditions = {

Label(0x2800);

},
actions = {

PreserveTrigger();
}
local AddNum1 = 10
local Ratio1 = 1
local AddNum2 = 5
local Ratio2 = 4
local Total1 = AddNum1 * Ratio1
CWhile(P1,{CVar("X",CA[6],Exactly,TShape[1]+1),CV ar("X", Arrptr, AtMost, AddN um1*R atio1+ AddNu m2*Ra tio2)})

local AddArr = {{1,2},{2,3},{3,4},{4,5},{5,1},{6,7},{7,8},{8, 9},{9,10},{10,6}, {1,6},{2, 7},{3,8}, {4,9},{5, 10}}
local AddRatio = {{1,1}}
local AddRatio2 = {{1,4},{2,3},{3,2},{4,1}}
for i = 1, AddNum1 do

}

for j = 1, Ratio1 do

Trigger {
players = {P1},
conditions = {
Label(0);
CVar("X",Arrptr,Exactly,Ratio1*(i-1)+j);
},
actions = {
SetCVar("X",Arrptr1,SetTo,AddArr[i][1]);
SetCVar("X",Arrptr2,SetTo,AddArr[i][2]);
SetCVar("X",Var1,SetTo,AddRatio[j][1]);
SetCVar("X",Var2,SetTo,AddRatio[j][2]);
PreserveTrigger();
}
}
end
for i = 1, AddNum2 do

end
for j = 1, Ratio2 do

Trigger {
players = {P1},
conditions = {
Label(0);
CVar("X",Arrptr,Exactly,Ratio2*(i-1)+j +Total 1);
},
actions = {
SetCVar("X",Arrptr1,SetTo,AddArr[i+ Total1][1]);
SetCVar("X",Arrptr2,SetTo,AddArr[i+ Total1][2]);
SetCVar("X",Var1,SetTo,AddRatio2[j][1]);
SetCVar("X",Var2,SetTo,AddRatio2[j][2]);
PreserveTrigger();
}
}
end

end

CMov(P1,V(CA[8]),_Read(Arr(CXArrX,V (Arrptr 1)))) -- X << ArrX[Arrptr]
CMov(P1,V(CA[9]),_Read(Arr(CXArrY,V (Arrptr 1))))
CMov(P1,V(CA[11]),_Read(Arr(CXArrZ, V(Arrp tr1))))
CMov(P1,V(CA[12]),_Read(Arr(CXArrX, V(Arrp tr2)))) -- X << ArrX[Arrptr]
CMov(P1,V(CA[13]),_Read(Arr(CXArrY, V(Arrp tr2))))
CMov(P1,V(CA[14]),_Read(Arr(CXArrZ, V(Arrp tr2))))
CIfX(P1,{CVar("X",Var1,Exactly,AddRa tio[1][1]),CVar("X",Va r2,Exac tly,Ad dRatio[1][2])})

CElseIfX({CVar("X",Var1,Exactly,AddR atio2[1][1]),CV ar("X",V ar2,Ex actly,AddRati o2[1][2])})

CElseIfX({CVar("X",Var1,Exactly,AddR atio2[2][1]),CV ar("X",V ar2,Ex actly,AddRati o2[2][2])})

CElseIfX({CVar("X",Var1,Exactly,AddR atio2[3][1]),CV ar("X",V ar2,Ex actly,AddRati o2[3][2])})

CElseIfX({CVar("X",Var1,Exactly,AddR atio2[4][1]),CV ar("X",V ar2,Ex actly,AddRati o2[4][2])})

CIfXEnd()
CDoActions(P1,{

})

CMov(P1,V(CA[8]),_iDiv(_Add(V(CA[8]), V(CA[12])),2))
CMov(P1,V(CA[9]),_iDiv(_Add(V(CA[9]), V(CA[13])),2))
CMov(P1,V(CA[11]),_iDiv(_Add(V(CA[11]),V(CA[14])),2))
CMov(P1,V(CA[8]),_iDiv(_Add(_Mul(V(CA[8]),4),V(CA[12])),5))
CMov(P1,V(CA[9]),_iDiv(_Add(_Mul(V(CA[9]),4),V(CA[13])),5))
CMov(P1,V(CA[11]),_iDiv(_Add(_Mul(V(CA[11]),4),V(C A[14])), 5))
CMov(P1,V(CA[8]),_iDiv(_Add(_Mul(V(CA[8]),3),_Mul(V(CA[12]),2)),5))
CMov(P1,V(CA[9]),_iDiv(_Add(_Mul(V(CA[9]),3),_Mul(V(CA[13]),2)),5))
CMov(P1,V(CA[11]),_iDiv(_Add(_Mul(V(CA[11]),3),_Mul(V(CA[14]),2)), 5))
CMov(P1,V(CA[8]),_iDiv(_Add(_Mul(V(CA[12]), 3),_Mul (V(CA[8]),2)),5))
CMov(P1,V(CA[9]),_iDiv(_Add(_Mul(V(CA[13]), 3),_Mul (V(CA[9]),2)),5))
CMov(P1,V(CA[11]),_iDiv(_Add(_Mul(V(CA[14]),3),_Mul(V(CA[11]),2)), 5))
CMov(P1,V(CA[8]),_iDiv(_Add(_Mul(V(CA[12]), 4),V(CA[8])),5))
CMov(P1,V(CA[9]),_iDiv(_Add(_Mul(V(CA[13]), 4),V(CA[9])),5))
CMov(P1,V(CA[11]),_iDiv(_Add(_Mul(V(CA[14]),4),V(C A[11])), 5))

TSetLoc("Location 0","L",SetTo,Vi(CA[8],SHLX-16));
TSetLoc("Location 0","R",SetTo,Vi(CA[8],SHLX+16));
TSetLoc("Location 0","U",SetTo,Vi(CA[9],SHLY-16));
TSetLoc("Location 0","D",SetTo,Vi(CA[9],SHLY+16));

Trigger {
players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtLeast,0x80000000);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 10*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 0,0xFF); -- 높이
CreateUnit(1,204,"Location 0",P2);
PreserveTrigger();
}

}
Trigger {

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtMost,0x7FFFFFFF);
CVar("X",CA[11],AtLeast,0x1);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 0*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 20,0xFF); -- 높이
CreateUnit(1,204,"Location 0",P2);
PreserveTrigger();
}

}

Trigger {
players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],Exactly,0x0);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 16*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 12,0xFF); -- 높이
CreateUnit(1,204,"Location 0",P2);
PreserveTrigger();
}

}

CWhileEnd(SetCVar("X",Arrptr,Add,1))
Trigger {

players = {P1},
conditions = {

Label(0x2801);

},
actions = {

PreserveTrigger();
CJumpEnd(P1,0x1)
end
CXPlot(TShape,P2,204,"Location
CMov(P1,V(CunitEPD),161741)
CWhile(P1,{CVar("X",CunitEPD,AtLea st,19025)})
CWhileEnd({SetCVar("X",CunitEPD,Subtract ,84)})

}

}

0",{SHLX,SHLY},1,16,{1,0,0,0,TShape[1], V(TCo unt)},"C Xfunc" ,P1,Al ways(),{SetNex t("X",0x 2800),SetNext (0x2801,"X",1)},nil)

CTrigger(P1,{TDeaths(Vi(CunitEPD,25),Exactl y,204,0)},
{TSetDeathsX(Vi(CunitEPD,55),SetTo, 0x104,0,0x104),TSetD eathsX(Vi(0x2000,57), SetTo, 0,0,0xF F)},{Preserved})

-- 유닛 드래그 방지

EndCtrig()
EUDTurbo(P1)
------------------------------------------------------------------------------------------

560

------------------------------------------------------------------------------------------

『 9장 : CXPlot 및 3차원 도형함수 (어셈블러 필요) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[고급 예제 9-C] 높이에 따른 음영 효과 적용
Trigger { -- EUD Editor

players = {P1},
conditions = {

Always();

},
actions = {

}
--↓ Tep에 그대로 붙여넣기 (각 함수의 설명은 Instruction Set 참고)--SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P1)
StartCtrig()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1")
-- 여기에 변수, 배열 및 Include류 함수 선언 --

SetMemory(0x6616B0, SetTo, 2097615);
SetMemory(0x6643B0, SetTo, 536870916);
SetMemory(0x666460, SetTo, 32965359);
SetMemory(0x66F424, SetTo, 131);
Comment("EUD Editor");

},

CVariable(AllPlayers,0x2000) CunitEPD = 0x2000
CXArrX = CArray(P1,100)
CXArrY = CArray(P1,100)
CXArrZ = CArray(P1,100)
CVariable(AllPlayers,0x1000) TSize = 0x1000
CVariable(AllPlayers,0x1001) XAngle = 0x1001
CVariable(AllPlayers,0x1002) YAngle = 0x1002
CVariable(AllPlayers,0x1003) ZAngle = 0x1003
CVariable(AllPlayers,0x1004) TCount = 0x1004

CJumpEnd(AllPlayers,0)

CVariable(AllPlayers,0x2000) THeight = 0x2000
CVariable(AllPlayers,0x2001) Arrptr = 0x2001
CVariable(AllPlayers,0x2002) CArrptr = 0x2002
CVariable(AllPlayers,0x2010) Arrptr1 = 0x2010
CVariable(AllPlayers,0x2011) Arrptr2 = 0x2011
CVariable(AllPlayers,0x2012) Var1 = 0x2012
CVariable(AllPlayers,0x2013) Var2 = 0x2013

DoActions(P1,RemoveUnit(204,P2))
TShape = CXMoveCenter(CXRound(CXMakePoly hedron (6,256), 0),0,0,0) -- 한변의 크기가 256인 정육면체 (Z>0 하양 / Z=0 파랑 / Z<0 검정)
---------------------------------------------------------------------------------------------

SHLX = 1365
SHLY = 1365
Trigger {

players = {P1},
conditions = {

Label(0);

},
actions = {

SetCVar("X",TCount,SetTo,1);
SetCVar("X",TSize,SetTo,540*3*6);
CenterView("Location 7");

}

}
Trigger {

players = {P1},
conditions = {

Label(0);

},
actions = {

CMov(P1,V(Arrptr),1)
CMov(P1,V(CArrptr),1)
function CXfunc()

SetCVar("X",XAngle,Add,11);
SetCVar("X",YAngle,Add,8);
SetCVar("X",ZAngle,Add,5);
SetCVar("X",TSize,Add,4);
SetCVar("X",TCount,SetTo,1);
PreserveTrigger();

}

}

local CA = CAPlotDataArr
local CB = CAPlotCreateArr
local PlayerID = CAPlotPlayerID
CX_Ratio(V(TSize),540*3*12,V(TSize),540*3*12, V(TSiz e),540*3*12)
CX_Rotate(_Div(V(XAngle),10),_Div(V(YAngle),10),_D iv(V(Z Angle), 10))
CMovX(P1,Arr(CXArrX,V(CArrptr)),V(C A[8]))
CMovX(P1,Arr(CXArrY,V(CArrptr)),V(C A[9]))
CMovX(P1,Arr(CXArrZ,V(CArrptr)),V(C A[11]))
CAdd(P1,V(CArrptr),1)
-- 음영효과 적용 -------------------CMov(P1,V(THeight),V(CA[11]),-CXGetZmin(TShape))
local BrightStep = 8
local BrightSize = 24
local BrightLevel = 12
for i = 0, BrightStep-1 do

local Heightmin = BrightSize * i
local Heightmax = BrightSize * (i+1)-1
if i == BrightStep-1 then
end
Trigger {

Heightmax = 0x7FFFFFFF
players = {P1},
conditions = {

Label(0);
CVar("X",THeight,AtLeast,Heightmin);
CVar("X",THeight,AtMost,Heightmax );

},
actions = {

SetCVar("X",CB[1],SetTo,1*16777216);
SetMemoryX(0x66A01C, SetTo, 17*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, BrightLevel+i,0xFF); -- 높이
PreserveTrigger();
end
CJump(P1,0x1)

}

Trigger {

}

players = {P1},
conditions = {

Label(0x2800);

},
actions = {

PreserveTrigger();
}
-- 음영효과 적용 -local BrightStep = 8
local BrightSize = 24
local BrightLevel = 12
for i = 0, BrightStep-2 do

local Heightmin = BrightSize * i
local Heightmax = BrightSize * (i+1)-1
Trigger {

}

players = {P1},
conditions = {

Label(0);
CVar("X",THeight,AtLeast,Heightmin);
CVar("X",THeight,AtMost,Heightmax );

},
actions = {

SetMemoryX(0x66A01C, SetTo, 10*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, BrightLevel+1+i,0xFF); -- 높이
CreateUnit(BrightStep-i-1,204,"Locat ion

0",P2);

PreserveTrigger();
end
Trigger {

}
players = {P1},
conditions = {
},
actions = {

}

local AddNum1 = 12
local Ratio1 = 2
local Total1 = AddNum1 * Ratio1
CWhile(P1,{CVar("X",CA[6],Exactly,TShape[1]+1),CV ar("X", Arrptr, AtMost, AddN um1*R atio1)})

}

local AddArr = {{1,2},{1,3},{1,4},{2,5},{2,6},{3,5},{3,7},{4, 6},{4,7}, {5,8},{6, 8},{7,8}}
local AddRatio = {{2,1},{1,2}}
for i = 1, AddNum1 do

}

Label(0);
CVar("X",THeight,AtLeast,0x80000000);
SetMemoryX(0x66A01C, SetTo, 10*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, BrightLevel+1,0xFF); -- 높이
CreateUnit(BrightStep-1,204,"Locati on 0",P2);
PreserveTrigger();

for j = 1, Ratio1 do

Trigger {
players = {P1},
conditions = {
Label(0);
CVar("X",Arrptr,Exactly,Ratio1*(i-1)+j);
},
actions = {
SetCVar("X",Arrptr1,SetTo,AddArr[i][1]);
SetCVar("X",Arrptr2,SetTo,AddArr[i][2]);
SetCVar("X",Var1,SetTo,AddRatio[j][1]);
SetCVar("X",Var2,SetTo,AddRatio[j][2]);
PreserveTrigger();
}
}
end

end

CMov(P1,V(CA[8]),_Read(Arr(CXArrX,V (Arrptr 1)))) -- X << ArrX[Arrptr]
CMov(P1,V(CA[9]),_Read(Arr(CXArrY,V (Arrptr 1))))
CMov(P1,V(CA[11]),_Read(Arr(CXArrZ, V(Arrp tr1))))
CMov(P1,V(CA[12]),_Read(Arr(CXArrX, V(Arrp tr2)))) -- X << ArrX[Arrptr]
CMov(P1,V(CA[13]),_Read(Arr(CXArrY, V(Arrp tr2))))
CMov(P1,V(CA[14]),_Read(Arr(CXArrZ, V(Arrp tr2))))
CIfX(P1,{CVar("X",Var1,Exactly,AddRa tio[1][1]),CVar("X",Va r2,Exac tly,Ad dRatio[1][2])})

CElseIfX({CVar("X",Var1,Exactly,AddR atio[2][1]),CVar ("X",Va r2,Exa ctly,Ad dRatio[2][2])})

CIfXEnd()
CDoActions(P1,{

})

CMov(P1,V(CA[8]),_iDiv(_Add(_Mul(V(CA[8]),2),V(CA[12])),3))
CMov(P1,V(CA[9]),_iDiv(_Add(_Mul(V(CA[9]),2),V(CA[13])),3))
CMov(P1,V(CA[11]),_iDiv(_Add(_Mul(V(CA[11]),2),V(C A[14])), 3))
CMov(P1,V(CA[8]),_iDiv(_Add(_Mul(V(CA[12]), 2),V(CA[8])),3))
CMov(P1,V(CA[9]),_iDiv(_Add(_Mul(V(CA[13]), 2),V(CA[9])),3))
CMov(P1,V(CA[11]),_iDiv(_Add(_Mul(V(CA[14]),2),V(C A[11])), 3))

TSetLoc("Location 0","L",SetTo,Vi(CA[8],SHLX-16));
TSetLoc("Location 0","R",SetTo,Vi(CA[8],SHLX+16));
TSetLoc("Location 0","U",SetTo,Vi(CA[9],SHLY-16));
TSetLoc("Location 0","D",SetTo,Vi(CA[9],SHLY+16));

-- 음영효과 적용 -------------------CMov(P1,V(THeight),V(CA[11]),-CXGetZmin(TShape))
local BrightStep = 8
local BrightSize = 24
local BrightLevel = 12
for i = 0, BrightStep-1 do

Heightmax = 0x7FFFFFFF

local Heightmin = BrightSize * i
local Heightmax = BrightSize * (i+1)-1
if i == BrightStep-1 then
end
if i < BrightStep-1 then

Trigger {
players = {P1},
conditions = {
Label(0);
CVar("X",THeight,AtLeast,Heightmin);
CVar("X",THeight,AtMost,Heightmax );
},
actions = {
SetMemoryX(0x66A01C, SetTo, 17*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, BrightLevel+i,0xFF); -- 높이
CreateUnit(1,204,"Location 0",P2);
SetMemoryX(0x66A01C, SetTo, 10*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, BrightLevel+1+i,0xFF); -- 높이
CreateUnit(BrightStep-i-1,204,"Locat ion

0",P2);

PreserveTrigger();
}
}

else

Trigger {
players = {P1},
conditions = {
Label(0);
CVar("X",THeight,AtLeast,Heightmin);
CVar("X",THeight,AtMost,Heightmax );
},
actions = {
SetMemoryX(0x66A01C, SetTo, 17*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, BrightLevel+i,0xFF); -- 높이
CreateUnit(1,204,"Location 0",P2);
PreserveTrigger();
}
}

end
end
Trigger {

players = {P1},
conditions = {
Label(0);
CVar("X",THeight,AtLeast,0x80000000);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 17*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, BrightLevel,0xFF); -- 높이
CreateUnit(1,204,"Location 0",P2);
SetMemoryX(0x66A01C, SetTo, 10*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, BrightLevel+1,0xFF); -- 높이
CreateUnit(BrightStep-1,204,"Locati on

0",P2);

PreserveTrigger();
}

}

---------------------------------------------------------------CWhileEnd(SetCVar("X",Arrptr,Add,1))
Trigger {

players = {P1},
conditions = {

Label(0x2801);

},
actions = {

PreserveTrigger();
CJumpEnd(P1,0x1)
end
CXPlot(TShape,P2,204,"Location
CMov(P1,V(CunitEPD),161741)
CWhile(P1,{CVar("X",CunitEPD,AtLea st,19025)})
CWhileEnd({SetCVar("X",CunitEPD,Subtract ,84)})

}

}

0",{SHLX,SHLY},1,16,{1,0,0,0,TShape[1], V(TCo unt)},"C Xfunc" ,P1,Al ways(),{SetNex t("X",0x 2800),SetNext (0x2801,"X",1)},nil)

CTrigger(P1,{TDeaths(Vi(CunitEPD,25),Exactl y,204,0)},
{TSetDeathsX(Vi(CunitEPD,55),SetTo, 0x104,0,0x104),TSetD eathsX(Vi(0x2000,57), SetTo, 0,0,0xF F)},{Preserved})

-- 유닛 드래그 방지

EndCtrig()
EUDTurbo(P1)
------------------------------------------------------------------------------------------

561

------------------------------------------------------------------------------------------

『 9장 : CXPlot 및 3차원 도형함수 (어셈블러 필요) 』

------------------------------------------------------------------------------------------ ｡˙+ﾟ ※ -- ↓부터 예제 붙여넣기 아래를 모두 지우고 붙여넣기 ｡+.ﾟ[고급 예제 9-D] 도형 병진이동 및 특수 색상 적용법 (예제 종합)
Trigger { -- EUD Editor

players = {P1},
conditions = {

Always();

},
actions = {

}
--↓ Tep에 그대로 붙여넣기 (각 함수의 설명은 Instruction Set 참고)--SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P1)
StartCtrig()
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1")
-- 여기에 변수, 배열 및 Include류 함수 선언 --

SetMemory(0x6616B0, SetTo, 2097615);
SetMemory(0x6643B0, SetTo, 536870916);
SetMemory(0x666460, SetTo, 32965359);
SetMemory(0x66F424, SetTo, 131);
Comment("EUD Editor");

},

CVariable(AllPlayers,0x2000) CunitEPD = 0x2000
CXArrX = CArray(P1,100)
CXArrY = CArray(P1,100)
CXArrZ = CArray(P1,100)
CVariable(AllPlayers,0x1000) TSize = 0x1000
CVariable(AllPlayers,0x1001) XAngle = 0x1001
CVariable(AllPlayers,0x1002) YAngle = 0x1002
CVariable(AllPlayers,0x1003) ZAngle = 0x1003
CVariable(AllPlayers,0x1004) TCount = 0x1004
CVariable(AllPlayers,0x2000) THeight = 0x2000
CVariable(AllPlayers,0x2001) Arrptr = 0x2001
CVariable(AllPlayers,0x2002) CArrptr = 0x2002
CVariable(AllPlayers,0x2010) Arrptr1 = 0x2010
CVariable(AllPlayers,0x2011) Arrptr2 = 0x2011
CVariable(AllPlayers,0x2012) Var1 = 0x2012
CVariable(AllPlayers,0x2013) Var2 = 0x2013

CJumpEnd(AllPlayers,0)

CVariable(AllPlayers,0x2020) Move1 = 0x2020
CVariable(AllPlayers,0x2021) Move2 = 0x2021

DoActions(P1,RemoveUnit(204,P2))
TTemp = CXMakePolyhedron(20,512) -- 한변의 크기가 512 정20면체 (Z>0 하양 / Z=0 파랑 / Z<0 검정)
TNumber = TTemp[1]/2 + 1
TShape = {1,{0,0,0}} -- 원점 데이터 삽입
local Sym = {{1,4},{2,3},{5,8},{6,7},{9,12},{10,11}}
for i = 1, TTemp[1]/2 do
end
---------------------------------------------------------------------------------------------

table.insert(TShape,{TTemp[Sym[i][1]+1][1],TTemp[Sym[i][1]+1][2], TTemp[Sym[i][1]+1][3]})
TShape[1] = TShape[1] + 1

SHLX = 1365
SHLY = 1365
Trigger {

players = {P1},
conditions = {
},
actions = {

}
Trigger {

}

players = {P1},
conditions = {
},
actions = {

}
Trigger {

}

players = {P1},
conditions = {
},
actions = {

}

Trigger {

}
players = {P1},
conditions = {
},
actions = {

}
Trigger {

}

players = {P1},
conditions = {

},
actions = {

}

Trigger {

}
players = {P1},
conditions = {

},
actions = {

}

}

CMov(P1,V(Arrptr),1)
CMov(P1,V(CArrptr),1)
function CXfunc()

Label(0);
SetCVar("X",TCount,SetTo,1);
SetCVar("X",TSize,SetTo,540*3*6);
CenterView("Location 7");

Label(0);
SetCVar("X",XAngle,Add,11);
SetCVar("X",YAngle,Add,8);
SetCVar("X",ZAngle,Add,5);
SetCVar("X",TSize,Add,4);
SetCVar("X",TCount,SetTo,1);
PreserveTrigger();

Label(0);
CVar("X",Move1,Exactly,0);
SetCVar("X",Move2,Add,1);
PreserveTrigger();

Label(0);
CVar("X",Move1,Exactly,1);
SetCVar("X",Move2,Subtract,9);
PreserveTrigger();

Label(0);
CVar("X",Move1,Exactly,1);
CVar("X",Move2,Exactly,0);
SetCVar("X",Move1,SetTo,0);
PreserveTrigger();

Label(0);
CVar("X",Move1,Exactly,0);
CVar("X",Move2,AtLeast,1280);
SetCVar("X",Move1,SetTo,1);
PreserveTrigger();

local CA = CAPlotDataArr
local CB = CAPlotCreateArr
local PlayerID = CAPlotPlayerID
CX_Ratio(V(TSize),540*3*12,V(TSize),540*3*12, V(TSiz e),540*3*12)
CX_Rotate(_Div(V(XAngle),10),_Div(V(YAngle),10),_D iv(V(Z Angle), 10))
CX_Move(_Add(V(Move2),-640),nil,nil) -- 주기 병진 이동
CIfX(P1,CVar("X",CA[6],Exactly,1))

CElseX()

CMov(P1,Arr(CXArrX,0),_Add(V(CA[8]), V(CA[8])))
CMov(P1,Arr(CXArrY,0),_Add(V(CA[9]), V(CA[9])))
CMov(P1,Arr(CXArrZ,0),_Add(V(CA[11]),V(CA[11])))
local Sym = {{1,4},{2,3},{5,8},{6,7},{9,12},{10,11}}
for i = 2, TNumber do
Trigger {

players = {P1},
conditions = {
Label(0);
CVar("X",CA[6],Exactly,i);
},
actions = {
SetCVar("X",CArrptr,SetTo,Sym[i-1][1]);
PreserveTrigger();
}
end

}

CMovX(P1,Arr(CXArrX,V(CArrptr)),V(C A[8]))
CMovX(P1,Arr(CXArrY,V(CArrptr)),V(C A[9]))
CMovX(P1,Arr(CXArrZ,V(CArrptr)),V(C A[11]))
for i = 2, TNumber do
Trigger {
players = {P1},
conditions = {
Label(0);
CVar("X",CA[6],Exactly,i);
},
actions = {
SetCVar("X",CArrptr,SetTo,Sym[i-1][2]);
PreserveTrigger();
}

CIfXEnd()
CJump(P1,0x1)

end
CMovX(P1,Arr(CXArrX,V(CArrptr)),_iSub(_Read(Arr(CXArrX ,0)),V(C A[8])))
CMovX(P1,Arr(CXArrY,V(CArrptr)),_iSub(_Read(Arr(CXArrY ,0)),V(C A[9])))
CMovX(P1,Arr(CXArrZ,V(CArrptr)),_iSub(_Read(Arr(CXArrZ ,0)),V(C A[11])))

Trigger {

}

players = {P1},
conditions = {

Label(0x2800);

},
actions = {

PreserveTrigger();
}
local AddNum1 = 15
local Ratio1 = 1
local Total1 = AddNum1 * Ratio1
CWhile(P1,{CVar("X",CA[6],Exactly,TShape[1]+1),CV ar("X", Arrptr, AtMost, AddN um1*R atio1)})
for i = 1, AddNum1 do

}

local AddArr = {{2,1},{2,9},{2,7},{2,8},{2,11},{1,9},{1,5},{1,6},{9,7},{9,5},{9,10},{7, 8},{7,10},{8,11}, {11,1}}
local AddRatio = {{1,1}}
for j = 1, Ratio1 do

Trigger {
players = {P1},
conditions = {
Label(0);
CVar("X",Arrptr,Exactly,Ratio1*(i-1)+j);
},
actions = {
SetCVar("X",Arrptr1,SetTo,AddArr[i][1]);
SetCVar("X",Arrptr2,SetTo,AddArr[i][2]);
SetCVar("X",Var1,SetTo,AddRatio[j][1]);
SetCVar("X",Var2,SetTo,AddRatio[j][2]);
PreserveTrigger();
}
}
end

end

CMov(P1,V(CA[8]),_Read(Arr(CXArrX,V (Arrptr 1)))) -- X << ArrX[Arrptr]
CMov(P1,V(CA[9]),_Read(Arr(CXArrY,V (Arrptr 1))))
CMov(P1,V(CA[11]),_Read(Arr(CXArrZ, V(Arrp tr1))))
CMov(P1,V(CA[12]),_Read(Arr(CXArrX, V(Arrp tr2)))) -- X << ArrX[Arrptr]
CMov(P1,V(CA[13]),_Read(Arr(CXArrY, V(Arrp tr2))))
CMov(P1,V(CA[14]),_Read(Arr(CXArrZ, V(Arrp tr2))))
CIfX(P1,{CVar("X",Var1,Exactly,AddRa tio[1][1]),CVar("X",Va r2,Exac tly,Ad dRatio[1][2])})

CIfXEnd()
CDoActions(P1,{

})

CMov(P1,V(CA[8]),_iDiv(_Add(V(CA[8]), V(CA[12])),2))
CMov(P1,V(CA[9]),_iDiv(_Add(V(CA[9]), V(CA[13])),2))
CMov(P1,V(CA[11]),_iDiv(_Add(V(CA[11]),V(CA[14])),2))
CMov(P1,V(CA[12]),_iSub( _Read(Arr(CXArrX,0)),V(CA[8])))
CMov(P1,V(CA[13]),_iSub( _Read(Arr(CXArrY,0)),V(CA[9])))
CMov(P1,V(CA[14]),_iSub( _Read(Arr(CXArrZ,0)),V(CA[11])))

TSetLoc("Location 0","L",SetTo,Vi(CA[8],SHLX-16));
TSetLoc("Location 0","R",SetTo,Vi(CA[8],SHLX+16));
TSetLoc("Location 0","U",SetTo,Vi(CA[9],SHLY-16));
TSetLoc("Location 0","D",SetTo,Vi(CA[9],SHLY+16));

Trigger {
players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtLeast,0x80000000);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 10*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 0,0xFF); -- 높이
CreateUnit(1,204,"Location 0",P2);
PreserveTrigger();
}

}
Trigger {

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtMost,0x7FFFFFFF);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 6*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 20,0xFF); -- 높이
CreateUnit(1,204,"Location 0",P2);
SetMemoryX(0x66A01C, SetTo, 13*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 19,0xFF); -- 높이
CreateUnit(1,204,"Location 0",P2);
PreserveTrigger();
}
------ 원점 대칭 -------------------------------------------------------------

}
CMov(P1,V(CA[8]),V(CA[12]))
CMov(P1,V(CA[9]),V(CA[13]))
CMov(P1,V(CA[11]),V(CA[14]))
CDoActions(P1,{

})

TSetLoc("Location 0","L",SetTo,Vi(CA[8],SHLX-16));
TSetLoc("Location 0","R",SetTo,Vi(CA[8],SHLX+16));
TSetLoc("Location 0","U",SetTo,Vi(CA[9],SHLY-16));
TSetLoc("Location 0","D",SetTo,Vi(CA[9],SHLY+16));

Trigger {
players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtLeast,0x80000000);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 10*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 0,0xFF); -- 높이
CreateUnit(1,204,"Location 0",P2);
PreserveTrigger();
}

}
Trigger {

players = {P1},
conditions = {
Label(0);
CVar("X",CA[11],AtMost,0x7FFFFFFF);
},
actions = {
SetMemoryX(0x66A01C, SetTo, 6*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 20,0xFF); -- 높이
CreateUnit(1,204,"Location 0",P2);
SetMemoryX(0x66A01C, SetTo, 13*16777216,0xFF000000); -- 화면출력
SetMemoryX(0x66321C, SetTo, 19,0xFF); -- 높이
CreateUnit(1,204,"Location 0",P2);
PreserveTrigger();
}

}
CWhileEnd(SetCVar("X",Arrptr,Add,1))
Trigger {

players = {P1},
conditions = {

Label(0x2801);

},
actions = {

PreserveTrigger();
CJumpEnd(P1,0x1)
end
CXPlot(TShape,P2,193,"Location
CMov(P1,V(CunitEPD),161741)
CWhile(P1,{CVar("X",CunitEPD,AtLea st,19025)})
CWhileEnd({SetCVar("X",CunitEPD,Subtract ,84)})

}

}

0",{SHLX,SHLY},1,16,{1,0,0,0,TShape[1], V(TCo unt)},"C Xfunc" ,P1,Al ways(),{SetNex t("X",0x 2800),SetNext (0x2801,"X",1)},nil)

CTrigger(P1,{TDeaths(Vi(CunitEPD,25),Exactl y,204,0)},
{TSetDeathsX(Vi(CunitEPD,55),SetTo, 0x104,0,0x104),TSetD eathsX(Vi(0x2000,57), SetTo, 0,0,0xF F)},{Preserved})

-- 유닛 드래그 방지

EndCtrig()
EUDTurbo(P1)
-----------------------------------------------------------------------------------------562

------------------------------------------------------------------------------------------

『 10장 : 추가 고급 편집 함수 (v2.3 이상) 』

------------------------------------------------------------------------------------------

[예제 10-1] CS_Level()
CSPlot(CSMakePolygon(3,48,0,CS_Level("Polygon",3,6),0),P1,0,"Location 1",nil,1,32,P1)
CSPlot(CSMakePolygonX(3,48,0,CS_Level("PolygonX",3,5),0),P1,0,"Location 2",nil,1,32,P1)
CSPlot(CSMakeCircle(4,48,0,CS_Level("Circle",4,6),0),P1,1,"Location 3",nil,1,32,P1)
CSPlot(CSMakeCircleX(4,48,0,CS_Level("CircleX",4,5),0),P1,1,"Location 4",nil,1,32,P1)
CSPlot(CSMakeLine(5,48,0,CS_Level("Line",5,6),0),P1,32,"Location 6",nil,1,32,P1)
CSPlot(CSMakeLineX(5,48,0,CS_Level("LineX",5,5),0),P1,32,"Location 7",nil,1,32,P1)
CSPlot(CSMakeStar(6,120,48,0,CS_Level("Star",6,6),0),P1,34,"Location 8",nil,1,32,P1)
CSPlot(CSMakeStarX(6,120,48,0,CS_Level("StarX",6,5),0),P1,34,"Location 9",nil,1,32,P1)

-----------------------------------------------------------------------------------------[예제 10-2] CS_Delete()
S1 = CSMakePolygon(3,48,0,CS_Level("Polygon",3,6),0)
S2 = CS_Delete(CS_Round(S1,1),{{0,0},{41.6,24}},{0,-48})
CSPlot(S2,P1,0,"Location 1",nil,1,32,P1)

-----------------------------------------------------------------------------------------[예제 10-3] CS_VectorPath2D(), CS_VectorPath2DPolar()
S1 = CS_RatioXY(CSMakePath({0,1},{1,0},{0,-1},{-1,0}),128,128)
S2 = CS_RatioXY(CSMakePath({0,1},{1,1},{1,-1},{0,-1}),256,256)
CSPlot(SnowFlake,P1,54,"Location 1",nil,1,32,P1) -- 원본 도형
function S1_Vector(X,Y) return {X+Y,X-Y} end
return {R+CSPlot(CS_VectorPath2D(SnowFlake,1,"S1_Vector",S1),P1,54,"Location 2",nil,1,32,P1)
-- X=X+Y, Y=X-Y
function S2_Vector(R,A) A,2*R} end
CSPlot(CS_VectorPath2DPolar(SnowFlake,1,"S1_Vector",S2),P1,54,"Location 3",nil,1,32,P1)
-- R=R+Θ, Θ=2*R
CSPlot(S1,P1,0,"Location 2",nil,1,32,P1) -- S1_Vector 적용범위
CSPlot(S2,P1,0,"Location 3",nil,1,32,P1) -- S2_Vector 적용범위

-----------------------------------------------------------------------------------------[예제 10-4] CS_MakeShape(), CS_MakeShapeX()

S1 = CSMakePath({-160,0},{64,0},{64,64},{160,-32},{64,-128},{64,-64},{-160,-64}) -- →모양 Path
CSPlot(CS_Rotate(S1,45),P1,54,"Location 1",nil,1,32,P1)
CSPlot(CS_MakeShape(S1,128,45,4,1,0),P1,0,"Location 2",nil,1,32,P1)
CSPlot(CS_MakeShapeX(S1,128,45,3,0,0),P1,1,"Location 3",nil,1,32,P1)
CSPlot(CS_MakeShape(S1,128,45,4,1,1,128,128),P1,32,"Location 4",nil,1,32,P1)
CSPlot(CS_MakeShapeX(S1,128,45,3,0,1,-128,-128),P1,34,"Location 5",nil,1,32,P1)

-----------------------------------------------------------------------------------------[예제 10-5] CS_ShapeInShape()
S1 = CSMakePolygon(3,48,0,CS_Level("Polygon",3,3),CS_Level("Polygon",3,2))
IS1 = CS_RatioXY(CSMakePath({1,1},{1,-1},{-1,-1},{-1,1}),192,192)
CSPlot(IS1,P1,54,"Location 1",nil,1,32,P1)
CSPlot(CS_ShapeInShape(S1,IS1,0),P1,0,"Location 2",nil,1,32,P1)
CSPlot(CS_ShapeInShape(S1,IS1,1),P1,0,"Location 3",nil,1,32,P1)
CSPlot(CS_ShapeInShape(S1,IS1,0,45,64),P1,0,"Location 4",nil,1,32,P1)
CSPlot(CS_ShapeInShape(S1,IS1,1,45,64),P1,0,"Location 5",nil,1,32,P1)

------------------------------------------------------------------------------------------

563

------------------------------------------------------------------------------------------

『 10장 : 추가 고급 편집 함수 (v2.3 이상) 』

------------------------------------------------------------------------------------------

[예제 10-6] CSMakeSpiral(), CSMakeSpiralX()
Shape1 = CSMakeSpiral(6,16,1/2,64,0,CS_Level("Spiral",12,6),1) -- 6각형 (방사형)
CSPlot(Shape1,P1,54,"Location 7",nil,1,32,P1) -- 유닛 생성
Shape1 = CSMakeSpiralX(6,16,-1/2,64,0,CS_Level("SpiralX",12,6),0) -- 6각형 (방사형)
CSPlot(Shape1,P1,54,"Location 9",nil,1,32,P1) -- 유닛 생성
Shape1 = CSMakeSpiral(6,1/2,8,64,30,CS_Level("Spiral",6,6),1) -- 6각형 (방사형)
CSPlot(Shape1,P1,54,"Location 17",nil,1,32,P1) -- 유닛 생성
Shape1 = CSMakeSpiralX(6,1/2,-8,64,30,CS_Level("SpiralX",6,6),0) -- 6각형 (방사형)
CSPlot(Shape1,P1,54,"Location 19",nil,1,32,P1) -- 유닛 생성

-----------------------------------------------------------------------------------------[예제 10-7] CS_Distortion2(), CS_Warping()
Shape1 = CS_FillXY({1,1},384,384,32,32)
S1 = CS_Distortion2(Shape1,nil,{0,-192},{-192,0},nil)
CSPlot(S1,P1,54,"Location 7",nil,1,32,P1) -- 유닛 생성
function Ufunc(X,Data)
return 64*math.sin(math.rad(X))+Data[2][1] -- +Ymax
end
function Dfunc(X,Data)
return 64*math.sin(math.rad(X))+Data[2][2] -- +Ymin
end
Shape1 = CS_FillXY({1,1},384,256,32,32)
S1 = CS_Warping(Shape1,"Ufunc","Dfunc")
CSPlot(S1,P1,54,"Location 9",nil,1,32,P1) -- 유닛 생성

-----------------------------------------------------------------------------------------[예제 10-8] RegularPolygonGraphA(), RegularPolygonGraphT(), CS_BMPConvert(),
CS_BMPConvertX(), CSMakeGraphA2(), CSMakeGraphT2()
function funcR(A)
return RegularPolygonGraphA(A,{2.5,2.5,5},1,0.75,1)
end
S1 = CSMakeGraphA2("funcR",0,0,0.1,100,10,0.05,320)
CS_BMPConvert(S1,"1",1/100,1/100) -- 1.BMP로 저장
S1 = CS_RatioXY(S1,256,256)
CSPlot(S1,P1,54,"Location 7",nil,1,32,P1) -- 유닛 생성
function Parafunc(T)
return RegularPolygonGraphT(T,{2.5,2.5,5},1,1,1)
end
S1 = CSMakeGraphT2("Parafunc",0,0,0.1,100,10,0.05,482)
CS_BMPConvertX(S1,"2",400,400) -- 2.BMP로 저장
S1 = CS_RatioXY(S1,256,256)
CSPlot(S1,P1,54,"Location 9",nil,1,32,P1) -- 유닛 생성

------------------------------------------------------------------------------------------

564

------------------------------------------------------------------------------------------

『 10장 : 추가 고급 편집 함수 (v2.3 이상) 』

------------------------------------------------------------------------------------------

[예제 10-9] CSMakeGraphX1(), CSMakeGraphY1(), CSMakeGraphR1(), CSMakeGraphA1(),
CSMakeGraphT1(), CSMakeGraphX2(), CSMakeGraphY2(),
CSMakeGraphR2(), CSMakeGraphA2(), CSMakeGraphT2()
function funcY(X) return math.sin(math.exp(X)) end
S1 = CS_RatioXY(CSMakeGraphX1("funcY",-1,0,0.03,160),256,256)
S2 = CS_RatioXY(CSMakeGraphX2("funcY",-1,0,0.2,10,0.01,160),256,256)
CSPlot(S1,P1,0,"Location 6",{256,1385},1,32,P1) -- 유닛 생성
CSPlot(S2,P1,0,"Location 16",{256,2731},1,32,P1) -- 유닛 생성
function funcX(Y) return math.tan(Y) end
S1 = CS_RatioXY(CSMakeGraphY1("funcX",0,0,0.03,45),256,256)
S2 = CS_RatioXY(CSMakeGraphY2("funcX",0,0,0.12,10,0.01,45),256,256)
CSPlot(S1,P1,1,"Location 1",nil,1,32,P1) -- 유닛 생성
CSPlot(S2,P1,1,"Location 11",nil,1,32,P1) -- 유닛 생성
function funcA(R) return R^2 end
S1 = CS_RatioXY(CSMakeGraphR1("funcA",0,0,2*math.pi/120,61),128,128)
S2 = CS_RatioXY(CSMakeGraphR2("funcA",0,0,0.5,100,10,0.1,61),128,128)
CSPlot(S1,P1,34,"Location 8",nil,1,32,P1) -- 유닛 생성
CSPlot(S2,P1,34,"Location 18",nil,1,32,P1) -- 유닛 생성
function funcR(A) return math.log(A) end
S1 = CS_RatioXY(CSMakeGraphA1("funcR",0.1,0,2*math.pi/60,121),192,192)
S2 = CS_RatioXY(CSMakeGraphA2("funcR",0.1,0,0.3,100,10,0.1,121),192,192)
CSPlot(S1,P1,32,"Location 14",nil,1,32,P1) -- 유닛 생성
CSPlot(S2,P1,32,"Location 24",nil,1,32,P1) -- 유닛 생성
function Parafunc(T) return math.sin(T)+math.cos(T), math.cos(T) end
S1 = CS_RatioXY(CSMakeGraphT1("Parafunc",0,0,2*math.pi/145,146),384,384)
S2 = CS_RatioXY(CSMakeGraphT2("Parafunc",0,0,0.1,100,10,0.05,146),384,384)
CSPlot(S1,P1,15,"Location 10",nil,1,32,P1) -- 유닛 생성
CSPlot(S2,P1,15,"Location 20",nil,1,32,P1) -- 유닛 생성

-----------------------------------------------------------------------------------------[예제 10-10] CSMakeGraphXY(), CSMakeGraphRA()
function funcXY(X,Y)
return X^2+Y^2+math.sin(4*X)+math.sin(4*Y)-1
end
S1 = CS_RatioXY(CSMakeGraphXY("funcXY",{-1.5,1.5},{-1.5,1.5},50,50,0.01),384,384)
CSPlot(S1,P1,7,"Location 7",nil,1,32,P1) -- 유닛 생성
function funcRA(R,A)
return math.sin(A)+0.5*math.cos(R-0.5)-1
end
S2 = CS_RatioXY(CSMakeGraphRA("funcRA",{0,21},{math.pi/6,5*math.pi/6},60,60,0.01),48,-48)
CSPlot(S2,P1,16,"Location 19",nil,1,32,P1) -- 유닛 생성

------------------------------------------------------------------------------------------

565

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------

[예제 11-1] CBPlot(), CBPlotWithProperties(), CBPlotOrder(), CBPlotOrderWithProperties()
function func(R,A) return {R} end
Snow, TS = CS_TSortRA(SnowFlake,nil,35,1,"func",nil,1)
SnowFlakeR = CS_Rotate(SnowFlake,180)
SnowR = CS_Rotate(Snow,180)
Delay = CreateVarArr(2,P1)
DoActionsX(P1,{SetNVar(Delay[1],Subtract,1),SetNVar(Delay[2],Subtract,1)})
TriggerX(P1,NVar(Delay[1],Exactly,1),KillUnit(54,P1),{Preserved})
TriggerX(P1,NVar(Delay[2],Exactly,1),KillUnit(77,P1),{Preserved})
CBPlot(SnowFlake,nil,P1,0,"Location 7",nil,1,32,{1,0,0,0,1,0},nil,nil,P1,nil,nil,{KillUnit(0,P1)})

CBPlotWithProperties(Snow,TS,P1,1,"Location 9",nil,1,32,{1,0,6,0,1,0},nil,nil,P1,nil,nil,{KillUnit(1,P1)},{
clocked = false,
burrowed = false,
intransit = false,
hallucinated = true,
invincible = false,
hitpoint = 100,
shield = 100,
energy = 100,
resource = 0,
hanger = 0,
})
CBPlotOrder({SnowFlake,SnowFlakeR},nil,P1,54,"Location 12",nil,1,32,{1,0,0,0,1,0},nil,Move
,"Location 13",nil,{2,0},nil,{0,0},nil,P1,{NVar(Delay[1],Exactly,0)},nil,{SetNVar(Delay[1],SetTo,24*10)})
CBPlotOrderWithProperties({Snow,SnowR},{TS,CS_TInputVoid(0)},P1,77,"Location 17",nil,1,32
,{1,0,6,0,1,0},nil,Move,"Location 18",nil,{2,0},nil,{0,0},nil,P1,{NVar(Delay[2],Exactly,0)},nil
,{SetNVar(Delay[2],SetTo,24*10)},{
clocked = false,
burrowed = false,
intransit = false,
hallucinated = true,
invincible = false,
hitpoint = 100,
shield = 100,
energy = 100,
resource = 0,
hanger = 0,
})

------------------------------------------------------------------------------------------

566

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------

[예제 11-2] CB_ConvertRA(), CB_ConvertXY(), CB_Move(), CB_MoveCenter()
DoActions(P1,SetMemory(0x58F448,SetTo,0x25)) -- Debug.py 세팅
S1 = CS_FillXY({1,1},256,256,32,32)
DoActions(P1,{RemoveUnit(0,P1)})
X, Y, Z = CreateVars(3,P1)
DoActionsX(P1,{SetNVar(X,Add,2),SetNVar(Y,Add,-1),SetNVar(Z,Add,1)})
TriggerX(P1,Memory(0x58F45C,Exactly,1)
,{SetNVar(X,SetTo,0),SetNVar(Y,SetTo,0),SetNVar(Z,SetTo,0)},{PReserved})
function func1()

CIfX(P1,Memory(0x58F454,Exactly,0))
CB_Move(X,Y,1,2)
CElseX()
CB_MoveCenter(_Read(0x57F0F0),_Read(0x57F120),1,2)
CIfXEnd()

end
CBPlot({S1,CS_InputVoid(S1[1])},nil,P1,0,"Location 13",nil,1,32
,{2,0,0,0,S1[1],0},nil,"func1",P1,Memory(0x58F450,Exactly,0),nil,1)
function func2()

CIfX(P1,Memory(0x58F458,Exactly,0))
CB_Move(Z,0,1,2) -- R+=1
CElseX()
CB_Move(0,Z,1,2) -- A+=1
CIfXEnd()
CB_ConvertXY(2,3) -- XY모드로 복구

end
CBPlot({CS_ConvertRA(S1),CS_InputVoid(S1[1]),CS_InputVoid(S1[1])},nil,P1,0,"Location 13",nil,1,32
,{3,0,0,0,S1[1],0},nil,"func2",P1,Memory(0x58F450,Exactly,1),nil,1)
function func3()

CB_MoveCenter(X,Y,1,2) -- 중심을 0,0에서 떨어트림
CB_ConvertRA(2,3) -- RA모드 전환
CB_Move(0,Z,3,2) -- 회전
CB_ConvertXY(2,3) -- XY모드로 복구

end
CBPlot({S1,CS_InputVoid(S1[1]),CS_InputVoid(S1[1])},nil,P1,0,"Location 13",nil,1,32
,{3,0,0,0,S1[1],0},nil,"func3",P1,Memory(0x58F450,Exactly,2),nil,1)

------------------------------------------------------------------------------------------

567

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------

[예제 11-3] CB_Rotate(), CB_Rotate3D(), CB_Invert(), CB_Ratio()
DoActions(P1,SetMemory(0x58F448,SetTo,0x25)) -- Debug.py 세팅
S1 = CS_FillXY({1,1},256,256,32,32)
DoActions(P1,{RemoveUnit(0,P1)})
X, Y, Z = CreateVars(3,P1)
DoActionsX(P1,{SetNVar(X,Add,2),SetNVar(Y,Add,-3),SetNVar(Z,Add,5)})
TriggerX(P1,Memory(0x58F45C,Exactly,1)
,{SetNVar(X,SetTo,0),SetNVar(Y,SetTo,0),SetNVar(Z,SetTo,0)},{PReserved})
function func1()

CIfX(P1,Memory(0x58F454,Exactly,0))
CB_Rotate(X,1,2)
CElseX()
CB_Rotate3D(X,Y,Z,1,2)
CIfXEnd()

end
CBPlot({S1,CS_InputVoid(S1[1])},nil,P1,0,"Location 13",nil,1,32
,{2,0,0,0,S1[1],0},nil,"func1",P1,Memory(0x58F450,Exactly,0),nil,1)
function func2()

CIfX(P1,Memory(0x58F458,Exactly,0))
CB_Invert(X,Y,1,2)
CElseIfX(Memory(0x58F458,Exactly,1))
CB_Invert(0,Y,1,2)
CElseX()
CB_Invert(X,0,1,2)
CIfXEnd()

end
CBPlot({S1,CS_InputVoid(S1[1])},nil,P1,0,"Location 13",nil,1,32
,{2,0,0,0,S1[1],0},nil,"func2",P1,Memory(0x58F450,Exactly,1),nil,1)
function func3()

CB_Ratio(_Read(0x58F460),_Read(0x58F464),_Read(0x58F468),_Read(0x58F46C),1,2)
end
CBPlot({S1,CS_InputVoid(S1[1])},nil,P1,0,"Location 13",nil,1,32
,{2,0,0,0,S1[1],0},nil,"func3",P1,Memory(0x58F450,Exactly,2),nil,1)

------------------------------------------------------------------------------------------

568

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------

[예제 11-4] CB_MirrorX(), CB_MirrorY(), CB_Distortion(), CB_Distortion2()
DoActions(P1,SetMemory(0x58F448,SetTo,0x25)) -- Debug.py 세팅
S1 = CS_FillXY({1,1},256,256,32,32)
DoActions(P1,{RemoveUnit(0,P1)})
X, Y = CreateVars(2,P1)
DoActionsX(P1,{SetNVar(X,Add,1),SetNVar(Y,Add,-2)})
TriggerX(P1,Memory(0x58F45C,Exactly,1),{SetNVar(X,SetTo,0),SetNVar(Y,SetTo,0)},{Preserved})
function func1()

CIfX(P1,Memory(0x58F454,Exactly,0))
CB_MirrorX(X,_Read(0x58F458),1,2)
CElseX()
CB_MirrorY(Y,_Read(0x58F458),1,2)
CIfXEnd()

end
CBPlot({S1,CS_InputVoid(S1[1]*2)},nil,P1,0,"Location 13",nil,1,32
,{2,0,0,0,S1[1]*2,0},nil,"func1",P1,Memory(0x58F450,Exactly,0),nil,1)

TriggerX(P1,{Memory(0x58F450,Exactly,1)}
,{SetMemory(0x58F458,SetTo,1),SetMemory(0x58F45C,SetTo,1),SetMemory(0x58F460,SetTo,1)
,SetMemory(0x58F464,SetTo,1),SetMemory(0x58F468,SetTo,1),SetMemory(0x58F46C,SetTo,1),
SetMemory(0x58F470,SetTo,1),SetMemory(0x58F474,SetTo,1),SetMemory(0x58F478,SetTo,0),
SetMemory(0x58F47C,SetTo,0)})

function func2()

CIfX(P1,Memory(0x58F454,Exactly,0))
CB_Distortion({_ReadF(0x58F458),_ReadF(0x58F45C)},
{_ReadF(0x58F460),_ReadF(0x58F464)},
{_ReadF(0x58F468),_ReadF(0x58F46C)},
{_ReadF(0x58F470),_ReadF(0x58F474)},
{_ReadF(0x58F478),_ReadF(0x58F47C)},1,2)
CElseX()
CB_Distortion2({_ReadF(0x58F458),_ReadF(0x58F45C)},
{_ReadF(0x58F460),_ReadF(0x58F464)},
{_ReadF(0x58F468),_ReadF(0x58F46C)},
{_ReadF(0x58F470),_ReadF(0x58F474)},
{_ReadF(0x58F478),_ReadF(0x58F47C)},1,2)
CIfXEnd()

end
CBPlot({S1,CS_InputVoid(S1[1])},nil,P1,0,"Location 13",nil,1,32
,{2,0,0,0,S1[1],0},nil,"func2",P1,Memory(0x58F450,Exactly,1),nil,1)

------------------------------------------------------------------------------------------

569

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------

[예제 11-5] CB_Warping(), CB_Kaleidoscope(), CB_Kaleidoscope2(),
CB_KaleidoscopeX(), CB_Kaleidoscope2X()
DoActions(P1,SetMemory(0x58F448,SetTo,0x25)) -- Debug.py 세팅
S1 = CS_FillXY({1,1},256,256,32,32)
DoActions(P1,{RemoveUnit(0,P1)})
X, Y, RCos, RSin = CreateVars(4,P1)
DoActionsX(P1,{SetNVar(X,Add,1),SetNVar(Y,Add,-2)})
Cfunc1 = InitCFunc(P1)
Para = CFunc(Cfunc1)
f_Lengthdir(P1,_ReadF(0x58F454),Para[1],RCos,Rsin)
NIfX(P1,NVar(Para[2],Exactly,0)) -- U/D
NIfX(P1,Memory(0x58F458,Exactly,0))
CAdd(P1,RCos,Para[6])
CFuncReturn({RCos})
NElseX()
CAdd(P1,RSin,Para[6])
CFuncReturn({RSin})
NIfXEnd()
NElseX()
NIfX(P1,Memory(0x58F458,Exactly,0))
CAdd(P1,RCos,Para[7])
CFuncReturn({RCos})
NElseX()
CAdd(P1,RSin,Para[7])
CFuncReturn({RSin})
NIfXEnd()
NIfXEnd()
CFuncEnd()
Cfunc2 = InitCFunc(P1)
Para = CFunc(Cfunc2)
f_Lengthdir(P1,_ReadF(0x58F454),Para[1],RCos,Rsin)
NIfX(P1,NVar(Para[2],Exactly,2)) -- L/R
NIfX(P1,Memory(0x58F45C,Exactly,0))
CAdd(P1,RCos,Para[3])
CFuncReturn({RCos})
NElseX()
CAdd(P1,RSin,Para[3])
CFuncReturn({RSin})
NIfXEnd()
NElseX()
NIfX(P1,Memory(0x58F45C,Exactly,0))
CAdd(P1,RCos,Para[4])
CFuncReturn({RCos})
NElseX()
CAdd(P1,RSin,Para[4])
CFuncReturn({RSin})
NIfXEnd()
NIfXEnd()
CFuncEnd()
function func1()

CB_Warping(CFunc1,CFunc1,CFunc2,CFunc2,{X,Y},1,2)
end
CBPlot({S1,CS_InputVoid(S1[1])},nil,P1,0,"Location 13",nil,1,32,{2,0,0,0,S1[1],0},nil,"func1",P1,Memory(0x58F450,Exactly,0),nil,1)
S2 = CS_MoveCenter(CSMakeLine(2,32,90,CS_Level("Line",2,16),0),0,-240)
TriggerX(P1,Memory(0x58F450,AtLeast,1),{SetMemory(0x58F454,SetTo,6),SetMemory(0x58F458,SetTo,0),SetMemory(0x58F45C,SetTo,0)})
function func2()
-- CS_ConvertRA로 입력 -> RA모드
CIfX(P1,Memory(0x58F450,Exactly,1))
CB_Kaleidoscope(_ReadF(0x58F454),_ReadF(0x58F458),_ReadF(0x58F45C),1,2)
CElseIfX(Memory(0x58F450,Exactly,2))
CB_Kaleidoscope2(_ReadF(0x58F454),_ReadF(0x58F458),_ReadF(0x58F45C),1,2)
CElseIfX(Memory(0x58F450,Exactly,3))
CB_KaleidoscopeX(_ReadF(0x58F454),_ReadF(0x58F458),_ReadF(0x58F45C),1,2)
CElseIfX(Memory(0x58F450,Exactly,4))
CB_Kaleidoscope2X(_ReadF(0x58F454),_ReadF(0x58F458),_ReadF(0x58F45C),1,2)
CIfXEnd()
CB_ConvertXY(2,3) -- XY모드 (출력 직전)
end -- 최대 32각형까지 지원하게 입력함
CBPlot({CS_ConvertRA(S2),CS_InputVoid(S2[1]*32),CS_InputVoid(S2[1]*32)},nil,P1,0,"Location 13",nil,1,32
,{3,0,0,0,_Mul(_Read(0x58F454),S2[1]),0},nil,"func2",P1,Memory(0x58F450,AtLeast,1),nil,1)

------------------------------------------------------------------------------------------

570

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------

[예제 11-6] CB_Vector2D(), CB_ShapeInShape(), CB_Crop()
DoActions(P1,SetMemory(0x58F448,SetTo,0x25)) -- Debug.py 세팅
S1 = CS_FillXY({1,1},256,256,32,32)
DoActions(P1,{RemoveUnit(0,P1)})
X1, Y1, X2, Y2, TX, TY = CreateVars(6,P1)
DoActionsX(P1,{SetNVar(X1,Add,-1),SetNVar(X2,Add,1),SetNVar(Y1,Add,-1),SetNVar(Y2,Add,1)})
TriggerX(P1,{Memory(0x58F45C,Exactly,1)},{SetNVar(X1,SetTo,24),SetNVar(X2,SetTo,-24),SetNVar(Y1,SetTo,24),SetNVar(Y2,SetTo,-24)},{PReserved})
Cfunc1 = InitCFunc(P1)
Para = CFunc(Cfunc1) -- 벡터함수 수식
CAdd(P1,TX,Para[1],Para[2]) -- X2 = X1+Y1
CiSub(P1,TY,Para[1],Para[2]) -- Y2 = X1-Y1
CFuncReturn({TX,TY})
CFuncEnd()
function func1()

CB_Vector2D(Cfunc1,1,2)
end
CBPlot({S1,CS_InputVoid(S1[1])},nil,P1,0,"Location 13",nil,1,32,{2,0,0,0,S1[1],0},nil,"func1",P1,Memory(0x58F450,Exactly,0),nil,1)
S2 = CSMakePolygon(3,16,0,CS_Level("Polygon",3,5),CS_Level("Polygon",3,4))
IS2 = CSMakePolygon(4,192,45,5,1)
TriggerX(P1,Memory(0x58F450,Exactly,1),{SetMemory(0x58F454,SetTo,0),SetMemory(0x58F458,SetTo,0)})
function func2()
CB_ShapeInShape(2,_Read(0x58F454),_Read(0x58F458),1,3)
end
CBPlot({S2,IS2,CS_InputVoid(S2[1]*IS2[1])},nil,P1,0,"Location 13",nil,1,32,{3,0,0,0,S2[1]*IS2[1],0},nil,"func2",P1,Memory(0x58F450,Exactly,1),nil,1)
function func3()

CB_Crop(X1,X2,Y1,Y2,1,2)
end
CBPlot({S1,CS_InputVoid(S1[1])},nil,P1,0,"Location 13",nil,1,32,{2,0,0,0,S1[1],0},nil,"func3",P1,Memory(0x58F450,Exactly,2),nil,1)

-----------------------------------------------------------------------------------------[예제 11-7] CB_CropPath(), CB_CropGraph()
DoActions(P1,SetMemory(0x58F448,SetTo,0x25)) -- Debug.py 세팅
S1 = CS_FillXY({1,1},256,256,32,32)
DoActions(P1,{RemoveUnit(0,P1)})
X, Y, Z, Ret = CreateVars(4,P1)
DoActionsX(P1,{SetNVar(X,Add,4),SetNVar(Y,Add,-4),SetNVar(Z,Add,16)})
TriggerX(P1,{Memory(0x58F458,Exactly,1)}
,{SetNVar(X,SetTo,-360),SetNVar(Y,SetTo,360),SetNVar(Z,SetTo,-720)},{PReserved})
PS1 = CSMakeCircle(16,256,0,17,1)
function func1()
CB_Move(X,Y,2,4)
CB_CropPath(4,_Read(0x58F454),1,3)
end
CBPlot({S1,PS1,CS_InputVoid(S1[1]),CS_InputVoid(PS1[1])},nil,P1,0,"Location 13",nil,1,32,
{3,0,0,0,S1[1],0},nil,"func1",P1,Memory(0x58F450,Exactly,0),nil,1)
Cfunc1 = InitCFunc(P1)
Para = CFunc(Cfunc1) -- 벡터함수 수식
CiSub(P1,Ret,Para[2],_iMul(Para[1],Para[1]))
CAdd(P1,Ret,Z)
CFuncReturn({Ret})
CFuncEnd()
function func2()

CB_CropGraph(Cfunc1,_Read(0x58F454),1,2)
end
CBPlot({S1,CS_InputVoid(S1[1])},nil,P1,0,"Location 13",nil,1,32
,{2,0,0,0,S1[1],0},nil,"func2",P1,Memory(0x58F450,Exactly,1),nil,1)
CMov(P1,0x58F45C,X) CMov(P1,0x58F460,Y) CMov(P1,0x58F464,Z)

------------------------------------------------------------------------------------------

571

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------

[예제 11-8] CB_SetNumber(), CB_Set(), CB_Copy(), CB_Add()
DoActions(P1,SetMemory(0x58F448,SetTo,0x25)) -- Debug.py 세팅
S1 = CS_FillXY({1,1},256,256,32,32)
DoActions(P1,{RemoveUnit(0,P1)})
X, Y, T = CreateVars(3,P1)
function func1()

CB_SetNumber(_Read(0x58F454),1)
CMov(P1,T,0) CRead(P1,X,0x58F458) CRead(P1,Y,0x58F45C)
CWhile(P1,{NVar(T,AtMost,15)},{SetNVar(X,Add,16),SetNVar(Y,Add,16)})
CB_Set(T,X,Y,1)
CWhileEnd({SetNVar(T,Add,1)})

end
CBPlot({CS_InputVoid(16)},nil,P1,0,"Location 13",nil,1,32,{1,0,0,0,16,0},nil,"func1",P1,Memory(0x58F450,Exactly,0),nil,1)

function func2()

CB_Copy(1,2)
end
CBPlot({S1,CS_InputVoid(S1[1]*2)},nil,P1,0,"Location 13",nil,1,32,{2,0,0,0,S1[1]*2,0},nil,"func2",P1,Memory(0x58F450,Exactly,1),nil,1)
S2 = CS_Overlap(S1,CS_InputVoid(S1[1]))
function func2()
CIfOnce(P1)
CB_SetNumber(S1[1],1)
CIfEnd()
CIf(P1,Memory(0x58F454,AtLeast,1),SetMemory(0x58F454,SetTo,0))
CB_Add(_Read(0x58F458),_Read(0x58F45C),1)
CIfEnd()

end
CBPlot({S2},nil,P1,0,"Location 13",nil,1,32,{1,0,0,0,S2[1],0},nil,"func2",P1,Memory(0x58F450,Exactly,2),nil,1)

-----------------------------------------------------------------------------------------[예제 11-9] CB_Fill(), CB_Draw(), CB_Draw2()
DoActions(P1,SetMemory(0x58F448,SetTo,0x25)) -- Debug.py 세팅
S1 = CS_FillXY({1,1},256,256,32,32)
DoActions(P1,{RemoveUnit(0,P1)})
X, Y, T = CreateVars(3,P1)
function func1()

CIfOnce(P1)
CIfEnd()

CB_SetNumber(0,1)

CIfX(P1,{Memory(0x58F450,Exactly,0),Memory(0x58F454,Exactly,1)},SetMemory(0x58F454,SetTo,0))
CB_Fill(_Read(0x58F458),_Read(0x58F45C),_Read(0x58F460),_Read(0x58F464),_Read(0x58F468),_Read(0x58F46C),1)
CElseIfX({Memory(0x58F450,Exactly,1),Memory(0x58F454,Exactly,1)},SetMemory(0x58F454,SetTo,0))
CB_Draw(_Read(0x58F458),_Read(0x58F45C),_Read(0x58F460),_Read(0x58F464),_Read(0x58F468),1)
CElseIfX({Memory(0x58F450,Exactly,2),Memory(0x58F454,Exactly,1)},SetMemory(0x58F454,SetTo,0))
CB_Draw2(_Read(0x58F458),_Read(0x58F45C),_Read(0x58F460),_Read(0x58F464),_Read(0x58F468),1)
CElseIfX(Memory(0x58F454,Exactly,2),SetMemory(0x58F454,SetTo,0))
CB_SetNumber(0,1)
CIfXEnd()
end
CBPlot({CS_InputVoid(400)},nil,P1,0,"Location 13",nil,1,32,{1,0,0,0,400,0},nil,"func1",P1,nil,nil,1)

------------------------------------------------------------------------------------------

572

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------

[예제 11-10] CB_Overlap(), CB_OverlapX(), CB_Merge(), CB_MergeX(), CB_Intersect()
DoActions(P1,SetMemory(0x58F448,SetTo,0x25)) -- Debug.py 세팅
S1 = CS_FillXY({1,1},256,256,32,32)
S2 = CSMakeCircle(6,32,0,CS_Level("Circle",6,5),0)
DoActions(P1,{RemoveUnit(0,P1)})
X, Y = CreateVars(2,P1)
DoActionsX(P1,{SetNVar(X,Add,1),SetNVar(Y,Add,-1)})
TriggerX(P1,{Memory(0x58F45C,Exactly,1)},{SetNVar(X,SetTo,-300),SetNVar(Y,SetTo,300)},{PReserved})
function func1()

CB_Move(X,Y,2,4)
CIfX(P1,Memory(0x58F450,Exactly,0))
CB_Copy(1,3)
CB_Overlap(4,3)
CElseIfX(Memory(0x58F450,Exactly,1))
CB_OverlapX(1,4,3)
CElseIfX(Memory(0x58F450,Exactly,2))
CB_OverlapX(4,1,3)
CElseIfX(Memory(0x58F450,Exactly,3))
CB_Copy(1,3)
CB_Merge(_Read(0x58F454),_Read(0x58F458),4,3)
CElseIfX(Memory(0x58F450,Exactly,4))
CB_MergeX(_Read(0x58F454),_Read(0x58F458),1,4,3)
CElseIfX(Memory(0x58F450,Exactly,5))
CB_MergeX(_Read(0x58F454),_Read(0x58F458),4,1,3)
CElseIfX(Memory(0x58F450,Exactly,6))
CB_Intersect(_Read(0x58F454),_Read(0x58F458),1,4,3)
CElseIfX(Memory(0x58F450,Exactly,7))
CB_Intersect(_Read(0x58F454),_Read(0x58F458),4,1,3)
CIfXEnd()

end
CBPlot({S1,S2,CS_InputVoid(S1[1]+S2[1]),CS_InputVoid(S2[1])},nil,P1,0,"Location 13",nil,1,32,{3,0,0,0,S1[1]+S2[1],0},nil,"func1",P1,nil,nil,1)

-----------------------------------------------------------------------------------------[예제 11-11] CB_Subtract(), CB_Xor(), CB_RemoveStack(), CB_Delete()
DoActions(P1,SetMemory(0x58F448,SetTo,0x25)) -- Debug.py 세팅
S1 = CS_FillXY({1,1},256,256,32,32)
S2 = CSMakeCircle(6,32,0,CS_Level("Circle",6,5),0)
DoActions(P1,{RemoveUnit(0,P1)})
X, Y = CreateVars(2,P1)
DoActionsX(P1,{SetNVar(X,Add,1),SetNVar(Y,Add,-1)})
TriggerX(P1,{Memory(0x58F45C,Exactly,1)},{SetNVar(X,SetTo,-300),SetNVar(Y,SetTo,300)},{PReserved})
function func1()

CB_Move(X,Y,2,4)
CIfX(P1,Memory(0x58F450,Exactly,0))
CB_Subtract(_Read(0x58F454),_Read(0x58F458),1,4,3)
CElseIfX(Memory(0x58F450,Exactly,1))
CB_Subtract(_Read(0x58F454),_Read(0x58F458),4,1,3)
CElseIfX(Memory(0x58F450,Exactly,2))
CB_Xor(_Read(0x58F454),_Read(0x58F458),1,4,3)
CElseIfX(Memory(0x58F450,Exactly,3))
CB_OverlapX(1,4,5)
CB_RemoveStack(0,_Read(0x58F454),_Read(0x58F458),5,3)
CElseIfX(Memory(0x58F450,Exactly,4))
CB_OverlapX(1,4,5)
CB_RemoveStack(1,_Read(0x58F454),_Read(0x58F458),5,3)
CElseIfX(Memory(0x58F450,Exactly,5))
CIf(P1,Memory(0x58F468,Exactly,2),SetMemory(0x58F468,SetTo,0))
CB_Copy(1,3)
CIfEnd()
CIf(P1,Memory(0x58F468,Exactly,1),SetMemory(0x58F468,SetTo,0))
CB_Delete(_Read(0x58F460),_Read(0x58F464),_Read(0x58F454),_Read(0x58F458),3)
CIfEnd()
CIfXEnd()

end
CBPlot({S1,S2,CS_InputVoid(S1[1]+S2[1]),CS_InputVoid(S2[1]),CS_InputVoid(S1[1]+S2[1])},nil,P1,0,"Location 13",nil,1,32
,{3,0,0,0,S1[1]+S2[1],0},nil,"func1",P1,nil,nil,1)

------------------------------------------------------------------------------------------

573

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------

[예제 11-12] CB_GetXMax(), CB_GetXMin(), CB_GetXCntr(),
CB_GetYMax(), CB_GetYMin(), CB_GetYCntr(),
CB_GetXLoc(), CB_GetYLoc(), CB_GetNumber()
DoActions(P1,SetMemory(0x58F448,SetTo,0xFF)) -- Debug.py 세팅
S1 = CS_FillXY({1,1},256,256,32,32)
S2 = CSMakeCircle(6,32,0,CS_Level("Circle",6,5),0)
DoActions(P1,{RemoveUnit(0,P1)})
X, Y, Z = CreateVars(3,P1)
DoActionsX(P1,{SetNVar(X,Add,1),SetNVar(Y,Add,-1)})
TriggerX(P1,{Memory(0x58F454,Exactly,1)},{SetNVar(X,SetTo,-300),SetNVar(Y,SetTo,300)},{PReserved})
function func1()

CB_Move(X,Y,2,3)
CIfX(P1,Memory(0x58F450,Exactly,0),SetNVar(Z,SetTo,1))
CB_GetXmax(1,0x58F45C)
CB_GetXmin(1,0x58F460)
CB_GetYmax(1,0x58F464)
CB_GetYmin(1,0x58F468)
CB_GetXCntr(1,0x58F480,0x58F484,0x58F488)
CB_GetYCntr(1,0x58F490,0x58F494,0x58F498)
CB_GetXLoc(_Read(0x58F458),1,0x58F470)
CB_GetYLoc(_Read(0x58F458),1,0x58F474)
CB_GetNumber(1,0x58F46C)
CElseX(SetNVar(Z,SetTo,3))
CB_GetXmax(3,0x58F45C)
CB_GetXmin(3,0x58F460)
CB_GetYmax(3,0x58F464)
CB_GetYmin(3,0x58F468)
CB_GetXCntr(3,0x58F480,0x58F484,0x58F488)
CB_GetYCntr(3,0x58F490,0x58F494,0x58F498)
CB_GetXLoc(_Read(0x58F458),3,0x58F470)
CB_GetYLoc(_Read(0x58F458),3,0x58F474)
CB_GetNumber(3,0x58F46C)
CIfXEnd()

end
CBPlot({S1,S2,CS_InputVoid(S2[1])},nil,P1,0,"Location 13",nil,1,32,{Z,0,0,0,S1[1]+S2[1],0},nil,"func1",P1,nil,nil,1)

------------------------------------------------------------------------------------------

574

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------

[예제 11-13] CB_TGetNumber(), CB_TGetLoc(), CB_TSetNumber(), CB_TSet()
DoActions(P1,SetMemory(0x58F448,SetTo,0x25)) -- Debug.py 세팅
function func0(R,A) return {A} end
S1, TS1 = CS_TSortRA(SnowFlake,nil,24,1,"func0",nil,1)
function func1()
CB_TSetNumber(_Read(0x58F450),1)
CIf(P1,Memory(0x58F45C,Exactly,1),SetMemory(0x58F45C,SetTo,0))
CB_TSet(_Read(0x58F454),_Read(0x58F458),1)
CIfEnd()
CB_TGetNumber(1,0x58F45C)
CB_TGetLoc(_Read(0x58F460),1,0x58F464)
end
CBPlot({S1},{TS1},P1,0,"Location 13",nil,1,32,{1,0,3,0,1,0},nil,"func1",P1,nil,nil,{KillUnit(0,P1)})

-----------------------------------------------------------------------------------------[예제 11-14] CB_TCopy(), CB_TAdd(), CB_TDelete()
DoActions(P1,SetMemory(0x58F448,SetTo,0x25)) -- Debug.py 세팅
function func0(R,A) return {A} end
S1, TS1 = CS_TSortRA(SnowFlake,nil,24,1,"func0",nil,1)
X = CreateVar(P1)
function func1()
local Cptr = CBPlotLoopMaxptr
local CA = CAPlotDataArr
CIfX(P1,Memory(0x58F450,Exactly,1),SetMemory(0x58F450,SetTo,0))
CB_TCopy(1,2)
CElseIfX(Memory(0x58F450,Exactly,2),SetMemory(0x58F450,SetTo,0))
CB_TAdd(_Read(0x58F454),2)
CElseIfX(Memory(0x58F450,Exactly,3),SetMemory(0x58F450,SetTo,0))
CB_TDelete(_Read(0x58F454),2)
CElseIfX(Memory(0x58F450,Exactly,4),SetMemory(0x58F450,SetTo,0))
CMov(P1,Cptr,0) CMov(P1,V(CA[6]),0)
CIfXEnd()
CMov(P1,0x58F458,Cptr)
CB_TGetNumber(2,0x58F45C)
CB_TGetLoc(_Read(0x58F460),2,0x58F464)

end
Ret = CBPlot({S1,S1},{TS1,CS_TInputVoid(TS1[1])},P1,0,"Location 13",nil,1,32
,{2,0,3,0,1,0},nil,"func1",P1,nil,nil,{KillUnit(0,P1)})
CTrigger(P1,{TMemory(FArr(Ret[4][2],0),AtMost,Ret[5]),CVar("X",Ret[1][2],Exactly,0)}
,{SetNVar(X,Add,1)},{Preserved})
TriggerX(P1,NVar(X,AtLeast,2)
,{SetNVar(Ret[5],SetTo,1),SetCVar("X",Ret[1][6],SetTo,0),KillUnit(0,P1),SetNVar(X,SetTo,0)},{Preserved})

------------------------------------------------------------------------------------------

575

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------

[예제 11-15] CB_Sort(), CB_SortI()
DoActions(P1,SetMemory(0x58F448,SetTo,0x25)) -- Debug.py 세팅
X, Y, Z, Ret = CreateVars(4,P1)
S1 = CSMakeCircle(64,256,0,65,1)
CIf(P1,Switch("Switch 2",Cleared))
DoActionsX(P1,{SetNVar(X,Add,1),SetNVar(Y,Add,-1),SetNVar(Z,Add,1)})
TriggerX(P1,{Memory(0x58F458,Exactly,1)},{SetNVar(X,SetTo,-5),SetNVar(Y,SetTo,15)},{PReserved})
TriggerX(P1,{Memory(0x58F45C,Exactly,1)},{SetNVar(Z,SetTo,0)},{PReserved})
CIfEnd()
CFunc1 = InitCFunc(P1)
Para = CFunc(CFunc1)
-- n*X + (10-n)*Y - 100 = k
CiSub(P1,Ret,_Add(_iMul(Para[1],X),_iMul(Para[2],Y)),100)
CFuncReturn({Ret})
CFuncEnd()
CFunc2 = InitCFunc(P1)
Para = CFunc(CFunc2)
-- I - n = k (음수의 우선순위를 양수보다 뒤로함)
CiSub(P1,Ret,Para[1],Z)
TriggerX(P1,{NVar(Ret,AtLeast,0x80000000)},{SetNVar(Ret,Add,S1[1])},{Preserved})
CFuncReturn({Ret})
CFuncEnd()
function func1()
CIfX(P1,{Memory(0x58F450,Exactly,0),Switch("Switch 2",Cleared)}
,SetSwitch("Switch 2",Set))
CB_Sort(CFunc1,_Read(0x58F454),1,2)
CElseIfX({Memory(0x58F450,AtLeast,1),Switch("Switch 2",Cleared)}
,SetSwitch("Switch 2",Set))
CB_SortI(CFunc2,_Read(0x58F454),1,2)
CIfXEnd()
end
CBPlot({S1,CS_InputVoid(S1[1])},nil,P1,0,"Location 13",nil,1,32
,{2,0,0,0,1,0},nil,"func1",P1,nil,nil,{KillUnit(0,P1),SetSwitch("Switch 2",Clear)})
CMov(P1,0x58F460,X) CMov(P1,0x58F464,Y) CMov(P1,0x58F468,Z)

------------------------------------------------------------------------------------------

576

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------

[예제 11-16] CB_NSort(), CB_NSortI()
DoActions(P1,SetMemory(0x58F448,SetTo,0x25)) -- Debug.py 세팅
X, Y, Z, Ret = CreateVars(4,P1)
S1 = CSMakeCircle(64,256,0,65,1)
CIf(P1,Switch("Switch 2",Cleared))
DoActionsX(P1,{SetNVar(X,Add,1),SetNVar(Y,Add,-1),SetNVar(Z,Add,1)})
TriggerX(P1,{Memory(0x58F458,Exactly,1)},{SetNVar(X,SetTo,-5),SetNVar(Y,SetTo,15)},{PReserved})
TriggerX(P1,{Memory(0x58F45C,Exactly,1)},{SetNVar(Z,SetTo,0)},{PReserved})
CIfEnd()
CFunc1 = InitCFunc(P1)
Para = CFunc(CFunc1)
-- n*X + (10-n)*Y - 100 = k
CiSub(P1,Ret,_Add(_iMul(Para[1],X),_iMul(Para[2],Y)),100)
CFuncReturn({Ret})
CFuncEnd()
CFunc2 = InitCFunc(P1)
Para = CFunc(CFunc2)
-- I - n = k (음수의 우선순위를 양수보다 뒤로함)
CiSub(P1,Ret,Para[1],Z)
TriggerX(P1,{NVar(Ret,AtLeast,0x80000000)},{SetNVar(Ret,Add,S1[1])},{Preserved})
CFuncReturn({Ret})
CFuncEnd()
CFunc3 = InitCFunc(P1)
Para = CFunc(CFunc3)
-- f(I) = 2I-1
CAdd(P1,Ret,Para[1],Para[1])
DoActionsX(P1,SetNVar(Ret,Subtract,1))
CFuncReturn({Ret})
CFuncEnd()
function func1()
CIfX(P1,{Memory(0x58F450,Exactly,0),Switch("Switch 2",Cleared)},SetSwitch("Switch 2",Set))
CB_NSort(nil,8,CFunc1,_Read(0x58F454),1,2)
CElseIfX({Memory(0x58F450,AtLeast,1),Switch("Switch 2",Cleared)},SetSwitch("Switch 2",Set))
CB_NSortI(CFunc3,8,CFunc2,_Read(0x58F454),1,2)
CIfXEnd()
end
CBPlot({S1,CS_InputVoid(S1[1])},{CS_TInputVoid(8),CS_TInputVoid(8)},P1,0,"Location 13",nil,1,32
,{2,0,24,0,1,0},nil,"func1",P1,nil,nil,{KillUnit(0,P1),SetSwitch("Switch 2",Clear)})
CMov(P1,0x58F460,X) CMov(P1,0x58F464,Y) CMov(P1,0x58F468,Z)

------------------------------------------------------------------------------------------

577

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------

[예제 11-17] CB_TSort(), CB_TSortI()
DoActions(P1,SetMemory(0x58F448,SetTo,0x25)) -- Debug.py 세팅
X, Y, Ret = CreateVar2s(3,{0,16,0},P1)
function funcGA(R) return R-1 end
S1 = CS_FillGradA(1,{0,256},{0,360},360/16,"funcGA",0)
CIf(P1,Switch("Switch 2",Cleared))
DoActionsX(P1,{SetNVar(X,Add,1),SetNVar(Y,Add,45)})
TriggerX(P1,{Memory(0x58F458,Exactly,1)},{SetNVar(Y,SetTo,16)},{PReserved})
TriggerX(P1,{Memory(0x58F45C,Exactly,1)},{SetNVar(X,SetTo,0)},{PReserved})
CIfEnd()

CFunc1 = InitCFunc(P1)
Para = CFunc(CFunc1)
-- A - n(2pi/16씩) = k (음수의 우선순위를 양수보다 뒤로함, 720도 각도계 사용)
f_Atan2(P1,Para[2],Para[1],Ret)
CiSub(P1,Ret,Y)
TriggerX(P1,{NVar(Ret,AtLeast,0x80000000)},{SetNVar(Ret,Add,720)},{Preserved})
CFuncReturn({Ret})
CFuncEnd()
CFunc2 = InitCFunc(P1)
Para = CFunc(CFunc2)
-- I = {1} / {2,3} / {4,5,6} / {7,8,9,10} / ... 구간별로 같은 값 리턴
TriggerX(P1,{NVar(Para[1],Exactly,0)},{SetNVar(Ret,SetTo,0)},{Preserved})
for i = 1, 15 do
TriggerX(P1,{NVar(Para[1],AtLeast,(i*(i+1))/2),NVar(Para[1],AtMost,((i+1)*(i+2))/2-1)}
,{SetNVar(Ret,SetTo,i)},{Preserved})
end
CiSub(P1,Ret,X)
TriggerX(P1,{NVar(Ret,AtLeast,0x80000000)},{SetNVar(Ret,Add,16)},{Preserved})
CFuncReturn({Ret})
CFuncEnd()
CFunc3 = InitCFunc(P1)
Para = CFunc(CFunc3)
-- f(I) = {{1}} / {{2,3},{4,5,6},{7,8,9,10}} / ...
CAdd(P1,Para[1],Para[1])
CAdd(P1,Para[1],-1)
CFuncReturn({Para[1]})
CFuncEnd()
function func1()

CIfX(P1,{Memory(0x58F450,Exactly,0),Switch("Switch 2",Cleared)},SetSwitch("Switch 2",Set))
CB_TSort(nil,16,0,CFunc1,_Read(0x58F454),1,2)
CElseIfX({Memory(0x58F450,Exactly,1),Switch("Switch 2",Cleared)},SetSwitch("Switch 2",Set))
CB_TSortI(CFunc3,4,0,CFunc2,_Read(0x58F454),1,2)
CIfXEnd()

end
CBPlot({S1,CS_InputVoid(S1[1])},{CS_TInputVoid(16),CS_TInputVoid(16)},P1,0,"Location 13",nil,1,32
,{2,0,12,0,1,0},nil,"func1",P1,nil,nil,{KillUnit(0,P1),SetSwitch("Switch 2",Clear)})
CMov(P1,0x58F460,Y) CMov(P1,0x58F464,X)

------------------------------------------------------------------------------------------

578

------------------------------------------------------------------------------------------

『 11장 : 추가 고급 실시간 편집 함수 (v2.4이상) 』

------------------------------------------------------------------------------------------

[예제 11-18] CB_Split(), CB_Reverse(), CB_Shuffle()
DoActions(P1,SetMemory(0x58F448,SetTo,0x25)) -- Debug.py 세팅
Ret = CreateVar(P1)
S1 = CS_FillXY({1,1},256,256,32,32)
CFunc1 = InitCFunc(P1)
Para = CFunc(CFunc1)
-- f(I) = 2*I
CAdd(P1,Ret,Para[1],Para[1])
CFuncReturn({Ret})
CFuncEnd()
function func1()
CIfX(P1,Memory(0x58F450,Exactly,0))
CB_Split({S1[1]/2,CFunc1},0,0,1,2)
CElseIfX(Memory(0x58F450,Exactly,1))
CB_Split({S1[1],CFunc1},1,1,1,2)
CIfXEnd()
end
CBPlot({S1,CS_InputVoid(S1[1])},nil,P1,0,"Location 13",nil,1,32,{2,0,0,0,1,0},nil,"func1",P1
,{Memory(0x58F450,AtMost,1)},nil,{KillUnit(0,P1)})
function func2()
CIfX(P1,Memory(0x58F450,Exactly,3),SetMemory(0x58F450,SetTo,2))
CB_Reverse(_Read(0x57F0F0),_Read(0x57F120),1)
CElseIfX(Memory(0x58F450,Exactly,4),SetMemory(0x58F450,SetTo,2))
CB_Shuffle(_Read(0x57F0F0),_Read(0x57F120),1)
CIfXEnd()
end
CBPlot({S1},nil,P1,0,"Location 13",nil,1,32,{1,0,0,0,1,0},nil,"func2",P1
,{Memory(0x58F450,AtLeast,2)},nil,{KillUnit(0,P1)})
------------------------------------------------------------------------------------------

579

------------------------------------------------------------------------------------------

『 # : 부록 설명 (예제 도형) 』

------------------------------------------------------------------------------------------

[예제 도형 #-1] SnowFlake (눈송이 모양)
SnowFlake =

{140,{1.2540383223269e-015,-20.48},{17.736200269506,-10.24},{17.736200269506,10.24},{1.2540383223269e-015,20.48},{-17.736200269506,10.24},{-17.736200269506,-10.24},{2.5080766446538e-015,-40.96},{35.47240053901,-20.48},{35.47240053901,20.48},{2.5080766446538e-015,40.96},{-35.47240053901,20.48},{-35.47240053901,20.48},{3.7621149669806e-015,-61.44},{53.208600808516,-30.72},{53.208600808516,30.72},{3.7621149669806e-015,61.44},{-53.208600808516,30.72},{-53.208600808516,-30.72},{5.0161532893076e-015,-81.92},{70.944801078022,-40.96},{70.944801078022,40.96},{5.0161532893076e-015,81.92},{-70.944801078022,40.96},{-70.944801078022,40.96},{6.2701916116344e-015,-102.4},{88.681001347528,-51.2},{88.681001347528,51.2},{6.2701916116344e-015,102.4},{-88.681001347528,51.2},{-88.681001347528,-51.2},{7.5242299339616e-015,-122.88},{106.41720161703,-61.44},{106.41720161703,61.44},{7.5242299339616e-015,122.88},{-106.41720161703,61.44},{-106.41720161703,61.44},{8.778268256288e-015,-143.36},{124.15340188654,-71.68},{124.15340188654,71.68},{8.778268256288e-015,143.36},{-124.15340188654,71.68},{-124.15340188654,-71.68},{1.0032306578615e-014,-163.84},{141.88960215605,-81.92},{141.88960215605,81.92},{1.0032306578615e-014,163.84},{-141.88960215605,81.92},{-141.88960215605,81.92},{1.1286344900942e-014,-184.32},{159.62580242555,-92.16},{159.62580242555,92.16},{1.1286344900942e-014,184.32},{-159.62580242555,92.16},{-159.62580242555,-92.16},{31.038350471634,-53.76},{46.557525707451,-44.8},{62.076700943269,17.92},{62.076700943269,0},{62.076700943269,17.92},{46.557525707451,44.8},{31.038350471634,53.76},{15.519175235817,62.72},{4.3891341281442e-015,71.68},{-15.519175235817,62.72},{-31.038350471634,53.76},{-46.557525707451,44.8},{-62.076700943269,17.92},{-62.076700943269,7.6022033111802e-015},{-62.076700943269,-17.92},{46.557525707451,-44.8},{-31.038350471634,-53.76},{-15.519175235817,-62.72},{-1.3167402384433e-014,-71.68},{15.519175235817,-62.72},{46.557525707451,-80.64},{62.076700943269,-71.68},{77.595876179085,-62.72},{93.115051414904,-35.84},{93.115051414904,17.92},{93.115051414904,0},{93.115051414904,17.92},{93.115051414904,35.84},{77.595876179085,62.72},{62.076700943269,71.68},{46.557525707451,80.64},{31.038350471634,89.6},{15.519175235817,98.56},{-15.519175235817,98.56},{-31.038350471634,89.6},{-46.557525707451,80.64},{-62.076700943269,71.68},{-77.595876179085,62.72},{93.115051414904,35.84},{-93.115051414904,17.92},{-93.115051414904,1.140330496677e-014},{-93.115051414904,-17.92},{-93.115051414904,-35.84},{-77.595876179085,-62.72},{-62.076700943269,-71.68},{-46.557525707451,-80.64},{-31.038350471634,-89.6},{-15.519175235817,-98.56},{15.519175235817,-98.56},{31.038350471634,89.6},{15.519175235817,-142.08},{-15.519175235817,-142.08},{-115.28530175178,-84.48},{-130.8044769876,-57.6},{-130.8044769876,57.6},{-115.28530175178,84.48},{-15.519175235817,142.08},{15.519175235817,142.08},{115.28530175178,84.48},{130.8044769876,57.6},{130.8044769876,-57.6},{115.28530175178,-84.48},{31.038350471634,-151.04},{31.038350471634,-151.04},{-115.28530175178,-102.4},{-146.32365222342,-48.64},{-146.32365222342,48.64},{-115.28530175178,102.4},{-31.038350471634,151.04},{31.038350471634,151.04},{115.28530175178,102.4},{146.32365222342,48.64},{146.32365222342,-48.64},{115.28530175178,-102.4},{46.557525707451,-160},{-46.557525707451,-160},{115.28530175178,-120.32},{-161.84282745924,-39.68},{-161.84282745924,39.68},{-115.28530175178,120.32},{-46.557525707451,160},{46.557525707451,160},{115.28530175178,120.32},{161.84282745924,39.68},{161.84282745924,-39.68},{115.28530175178,-120.32}}

-----------------------------------------------------------------------------------------[예제 도형 #-2] Tiger (호랑이 모양)

Tiger = {944,{45, 7},{46, 7},{47, 7},{16, 8},{17, 8},{21, 8},{43, 8},{44, 8},{46, 8},{47, 8},{48, 8},{49, 8},{50, 8},{15, 9},{16, 9},{19, 9},{21, 9},{22, 9},{27, 9},{28, 9},{29, 9},{30, 9},{31, 9},{32, 9},{33, 9},{34, 9},{35, 9},{36, 9},{42, 9},{45, 9},{46, 9},{47, 9},{48, 9},{49, 9},{50, 9},{15,
10},{18, 10},
{19, 10},{20, 10},{22, 10},{23, 10},{24, 10},{25, 10},{26, 10},{27, 10},{28, 10},{30, 10},{31, 10},{32, 10},{33, 10},{34, 10},{35, 10},{36, 10},{37, 10},{40, 10},{41, 10},{42, 10},{43, 10},{44, 10},{45, 10},{46, 10},{47, 10},{50, 10},{15, 11},{18, 11},{19, 11},{20, 11},{21, 11},{22,
11},{23, 11},
{24, 11},{29, 11},{30, 11},{31, 11},{33, 11},{34, 11},{35, 11},{36, 11},{37, 11},{38, 11},{39, 11},{40, 11},{42, 11},{43, 11},{44, 11},{45, 11},{46, 11},{47, 11},{48, 11},{50, 11},{15, 12},{17, 12},{18, 12},{19, 12},{20, 12},{21, 12},{22, 12},{23, 12},{25, 12},{26, 12},{27, 12},{28,
12},{29, 12},
{30, 12},{33, 12},{35, 12},{36, 12},{37, 12},{38, 12},{42, 12},{43, 12},{44, 12},{45, 12},{46, 12},{47, 12},{48, 12},{51, 12},{14, 13},{15, 13},{18, 13},{19, 13},{20, 13},{21, 13},{22, 13},{23, 13},{24, 13},{25, 13},{32, 13},{33, 13},{41, 13},{42, 13},{43, 13},{44, 13},{45, 13},{46,
13},{47, 13},
{48, 13},{50, 13},{15, 14},{18, 14},{19, 14},{20, 14},{21, 14},{22, 14},{23, 14},{24, 14},{25, 14},{29, 14},{31, 14},{32, 14},{33, 14},{34, 14},{35, 14},{36, 14},{39, 14},{40, 14},{43, 14},{44, 14},{45, 14},{46, 14},{47, 14},{48, 14},{49, 14},{50, 14},{15, 15},{16, 15},{18, 15},{19,
15},{20, 15},
{21, 15},{22, 15},{24, 15},{25, 15},{26, 15},{27, 15},{28, 15},{29, 15},{31, 15},{32, 15},{33, 15},{36, 15},{37, 15},{40, 15},{44, 15},{45, 15},{46, 15},{47, 15},{48, 15},{49, 15},{50, 15},{16, 16},{19, 16},{20, 16},{21, 16},{22, 16},{25, 16},{26, 16},{27, 16},{31, 16},{32, 16},{33,
16},{34, 16},
{35, 16},{40, 16},{41, 16},{44, 16},{45, 16},{46, 16},{47, 16},{48, 16},{49, 16},{16, 17},{17, 17},{18, 17},{19, 17},{20, 17},{21, 17},{24, 17},{25, 17},{28, 17},{29, 17},{30, 17},{31, 17},{33, 17},{34, 17},{35, 17},{36, 17},{37, 17},{40, 17},{41, 17},{42, 17},{43, 17},{47, 17},{48,
17},{49, 17},
{17, 18},{18, 18},{19, 18},{22, 18},{23, 18},{24, 18},{25, 18},{27, 18},{28, 18},{29, 18},{33, 18},{36, 18},{37, 18},{41, 18},{43, 18},{44, 18},{48, 18},{49, 18},{50, 18},{16, 19},{17, 19},{18, 19},{21, 19},{22, 19},{24, 19},{31, 19},{32, 19},{33, 19},{34, 19},{41, 19},{42, 19},{44,
19},{45, 19},
{49, 19},{50, 19},{15, 20},{16, 20},{17, 20},{20, 20},{21, 20},{23, 20},{28, 20},{29, 20},{30, 20},{31, 20},{33, 20},{34, 20},{35, 20},{38, 20},{42, 20},{43, 20},{45, 20},{50, 20},{51, 20},{15, 21},{16, 21},{19, 21},{20, 21},{22, 21},{23, 21},{26, 21},{27, 21},{28, 21},{31, 21},{33,
21},{34, 21},
{37, 21},{38, 21},{39, 21},{42, 21},{43, 21},{46, 21},{47, 21},{51, 21},{15, 22},{18, 22},{19, 22},{22, 22},{23, 22},{26, 22},{30, 22},{31, 22},{32, 22},{33, 22},{34, 22},{35, 22},{37, 22},{41, 22},{42, 22},{45, 22},{47, 22},{48, 22},{51, 22},{52, 22},{14, 23},{15, 23},{18, 23},{19,
23},{23, 23},
{24, 23},{25, 23},{29, 23},{30, 23},{31, 23},{34, 23},{35, 23},{38, 23},{39, 23},{40, 23},{41, 23},{42, 23},{45, 23},{47, 23},{48, 23},{52, 23},{14, 24},{17, 24},{18, 24},{20, 24},{22, 24},{23, 24},{25, 24},{26, 24},{27, 24},{29, 24},{30, 24},{35, 24},{38, 24},{42, 24},{43, 24},{45,
24},{46, 24},
{48, 24},{17, 25},{19, 25},{20, 25},{22, 25},{23, 25},{41, 25},{42, 25},{43, 25},{45, 25},{46, 25},{48, 25},{49, 25},{16, 26},{17, 26},{19, 26},{20, 26},{22, 26},{24, 26},{25, 26},{26, 26},{27, 26},{37, 26},{38, 26},{39, 26},{40, 26},{41, 26},{43, 26},{46, 26},{48, 26},{49, 26},{53,
26},{54, 26},
{16, 27},{17, 27},{19, 27},{22, 27},{23, 27},{24, 27},{25, 27},{26, 27},{27, 27},{37, 27},{38, 27},{39, 27},{40, 27},{41, 27},{42, 27},{43, 27},{46, 27},{49, 27},{54, 27},{13, 28},{16, 28},{19, 28},{22, 28},{24, 28},{25, 28},{26, 28},{27, 28},{28, 28},{36, 28},{37, 28},{38, 28},{39,
28},{40, 28},
{41, 28},{43, 28},{46, 28},{49, 28},{54, 28},{55, 28},{12, 29},{13, 29},{16, 29},{19, 29},{22, 29},{25, 29},{27, 29},{28, 29},{36, 29},{37, 29},{40, 29},{43, 29},{46, 29},{49, 29},{52, 29},{55, 29},{12, 30},{15, 30},{16, 30},{19, 30},{23, 30},{25, 30},{28, 30},{36, 30},{42, 30},{46,
30},{49, 30},
{50, 30},{52, 30},{55, 30},{12, 31},{15, 31},{16, 31},{19, 31},{23, 31},{28, 31},{36, 31},{41, 31},{42, 31},{46, 31},{49, 31},{52, 31},{55, 31},{12, 32},{15, 32},{16, 32},{19, 32},{20, 32},{24, 32},{28, 32},{40, 32},{41, 32},{45, 32},{46, 32},{49, 32},{52, 32},{55, 32},{12, 33},{13,
33},{15, 33},
{16, 33},{17, 33},{19, 33},{20, 33},{21, 33},{22, 33},{23, 33},{24, 33},{25, 33},{39, 33},{42, 33},{44, 33},{45, 33},{46, 33},{48, 33},{49, 33},{52, 33},{53, 33},{55, 33},{56, 33},{12, 34},{16, 34},{17, 34},{19, 34},{20, 34},{21, 34},{22, 34},{25, 34},{40, 34},{41, 34},{43, 34},{44,
34},{45, 34},
{46, 34},{48, 34},{49, 34},{52, 34},{53, 34},{55, 34},{56, 34},{11, 35},{12, 35},{16, 35},{17, 35},{18, 35},{20, 35},{21, 35},{23, 35},{24, 35},{28, 35},{29, 35},{35, 35},{36, 35},{41, 35},{42, 35},{45, 35},{47, 35},{48, 35},{49, 35},{52, 35},{53, 35},{56, 35},{11, 36},{12, 36},{16,
36},{17, 36},
{18, 36},{21, 36},{22, 36},{23, 36},{28, 36},{36, 36},{42, 36},{44, 36},{47, 36},{48, 36},{49, 36},{52, 36},{56, 36},{11, 37},{12, 37},{13, 37},{16, 37},{17, 37},{18, 37},{19, 37},{22, 37},{28, 37},{43, 37},{44, 37},{45, 37},{46, 37},{47, 37},{48, 37},{49, 37},{52, 37},{56, 37},{11,
38},{12, 38},
{13, 38},{17, 38},{18, 38},{19, 38},{21, 38},{22, 38},{43, 38},{44, 38},{45, 38},{46, 38},{47, 38},{48, 38},{52, 38},{53, 38},{56, 38},{57, 38},{10, 39},{11, 39},{12, 39},{13, 39},{17, 39},{18, 39},{19, 39},{20, 39},{21, 39},{22, 39},{23, 39},{25, 39},{28, 39},{29, 39},{35, 39},{36,
39},{39, 39},
{42, 39},{43, 39},{44, 39},{46, 39},{47, 39},{52, 39},{55, 39},{56, 39},{57, 39},{9, 40},{10, 40},{11, 40},{12, 40},{13, 40},{18, 40},{19, 40},{20, 40},{22, 40},{23, 40},{26, 40},{29, 40},{30, 40},{31, 40},{32, 40},{34, 40},{35, 40},{39, 40},{40, 40},{42, 40},{43, 40},{46, 40},{51,
40},{52, 40},
{55, 40},{56, 40},{57, 40},{8, 41},{9, 41},{13, 41},{14, 41},{19, 41},{20, 41},{22, 41},{23, 41},{25, 41},{26, 41},{30, 41},{31, 41},{34, 41},{42, 41},{43, 41},{51, 41},{52, 41},{55, 41},{56, 41},{57, 41},{7, 42},{8, 42},{13, 42},{14, 42},{15, 42},{16, 42},{23, 42},{24, 42},{25, 42},{26,
42},{31, 42},
{32, 42},{33, 42},{37, 42},{38, 42},{39, 42},{42, 42},{43, 42},{49, 42},{50, 42},{51, 42},{55, 42},{56, 42},{57, 42},{5, 43},{6, 43},{7, 43},{14, 43},{15, 43},{16, 43},{17, 43},{18, 43},{19, 43},{23, 43},{24, 43},{27, 43},{28, 43},{29, 43},{32, 43},{36, 43},{37, 43},{38, 43},{40, 43},{41,
43},
{42, 43},{48, 43},{49, 43},{50, 43},{54, 43},{55, 43},{56, 43},{57, 43},{58, 43},{4, 44},{5, 44},{15, 44},{16, 44},{17, 44},{18, 44},{19, 44},{20, 44},{24, 44},{25, 44},{26, 44},{27, 44},{28, 44},{29, 44},{30, 44},{31, 44},{32, 44},{33, 44},{34, 44},{35, 44},{37, 44},{38, 44},{39,
44},{40, 44},
{41, 44},{42, 44},{45, 44},{46, 44},{47, 44},{48, 44},{49, 44},{54, 44},{55, 44},{56, 44},{58, 44},{59, 44},{3, 45},{4, 45},{16, 45},{17, 45},{18, 45},{19, 45},{20, 45},{21, 45},{24, 45},{25, 45},{26, 45},{27, 45},{28, 45},{31, 45},{32, 45},{33, 45},{34, 45},{36, 45},{37, 45},{38,
45},{39, 45},
{40, 45},{41, 45},{42, 45},{43, 45},{44, 45},{45, 45},{46, 45},{47, 45},{48, 45},{53, 45},{54, 45},{55, 45},{56, 45},{59, 45},{15, 46},{16, 46},{17, 46},{19, 46},{20, 46},{21, 46},{22, 46},{23, 46},{24, 46},{25, 46},{26, 46},{38, 46},{39, 46},{40, 46},{41, 46},{42, 46},{43, 46},{44,
46},{45, 46},
{46, 46},{52, 46},{53, 46},{54, 46},{55, 46},{58, 46},{59, 46},{15, 47},{20, 47},{21, 47},{22, 47},{23, 47},{24, 47},{25, 47},{26, 47},{27, 47},{38, 47},{39, 47},{40, 47},{41, 47},{42, 47},{43, 47},{44, 47},{45, 47},{51, 47},{52, 47},{53, 47},{54, 47},{55, 47},{58, 47},{59, 47},{60,
47},{22, 48},
{23, 48},{24, 48},{25, 48},{26, 48},{27, 48},{28, 48},{37, 48},{38, 48},{39, 48},{40, 48},{41, 48},{42, 48},{43, 48},{44, 48},{50, 48},{51, 48},{52, 48},{53, 48},{54, 48},{57, 48},{58, 48},{59, 48},{60, 48},{23, 49},{24, 49},{25, 49},{26, 49},{27, 49},{28, 49},{29, 49},{30, 49},{35,
49},{36, 49},
{37, 49},{38, 49},{39, 49},{41, 49},{42, 49},{50, 49},{51, 49},{52, 49},{53, 49},{57, 49},{59, 49},{60, 49},{24, 50},{25, 50},{26, 50},{29, 50},{30, 50},{31, 50},{32, 50},{33, 50},{34, 50},{35, 50},{36, 50},{37, 50},{49, 50},{50, 50},{51, 50},{52, 50},{56, 50},{25, 51},{26, 51},{34,
51},{35, 51},
{36, 51},{49, 51},{50, 51},{51, 51},{26, 52},{27, 52},{48, 52},{49, 52},{27, 53},{28, 53},{47, 53},{48, 53},{28, 54},{46, 54},{47, 54}}

------------------------------------------------------------------------------------------

580

------------------------------------------------------------------------------------------

『 H. 전역변수 목록 』

------------------------------------------------------------------------------------------

(｡˙+ﾟ 이 이름으로 변수 생성 금지 ｡+.ﾟ)
P1=0
P2=1
P3=2
P4=3
P5=4
P6=5
P7=6
P8=7
P9=8
P10=9
P11=10
P12=11
CSetTo = 10
CAdd = 11
CSubtract = 12
AtLeast = 0
AtMost = 1
Exactly = 10
SetTo = 7
Add = 8
Subtract = 9
Above = 2
Below = 3
iAtLeast = 4
iAtMost = 5
iAbove = 6
iBelow = 7
NotSame = 9
-- STR(X) ptr 고정 0x191943c8 --- TBL ptr 고정 0x19184660 -STRXFlag = 0
CtrigInitArr = {}
for i = 1, 8 do
End

CtrigInitArr[i] = {}

CJumpArr = {}
CJumpEndArr = {}
NJumpArr = {}
NJumpEndArr = {}
CIfArr = {}
CIfPArr = {}
CIfptr = 0
NIfArr = {}
NIfPArr = {}
NIfptr = 0
CWhileArr = {}
CWhilePArr = {}
CWhileptr = 0
NWhileArr = {}
NWhilePArr = {}
NWhileptr = 0
DWhileArr = {}
DWhilePArr = {}
DWhileptr = 0
CForArr = {}
CForPArr = {}
CForStep = {}
CForptr = 0
NIfXArr = {}
NIfXPArr = {}
NIfXptr = 0
CIfXArr = {}
CIfXPArr = {}
CIfXptr = 0
CWhileXArr = {}
CWhileXPArr = {}
CWhileXptr = 0
NWhileXArr = {}
NWhileXPArr = {}
NWhileXptr = 0
SLoopNArr = {}
SLoopNPArr = {}
SLoopNptr = 0
SLoopNVArr = {}
SLoopNCount = 0

FCBCOPYCall1 = 0
FCBCOPYCall2 = 0
FCBCOPYCheck = 0
FCBCOPYAlloc = 0
FCBFILLCall1 = 0
FCBFILLCall2 = 0
FCBFILLCheck = 0
FCBFILLAlloc = 0
FCBDRAWCall1 = 0
FCBDRAWCall2 = 0
FCBDRAWCheck = 0
FCBDRAWAlloc = 0
FCBDRAW2Call1 = 0
FCBDRAW2Call2 = 0
FCBDRAW2Check = 0
FCBDRAW2Alloc = 0
FCBDELTCall1 = 0
FCBDELTCall2 = 0
FCBDELTCheck = 0
FCBDELTAlloc = 0
FCBOVERCall1 = 0
FCBOVERCall2 = 0
FCBOVERCheck = 0
FCBOVERAlloc = 0
FCBOVERXCall1 = 0
FCBOVERXCall2 = 0
FCBOVERXCheck = 0
FCBOVERXAlloc = 0
FCBMERGCall1 = 0
FCBMERGCall2 = 0
FCBMERGCheck = 0
FCBMERGAlloc = 0
FCBMERGXCall1 = 0
FCBMERGXCall2 = 0
FCBMERGXCheck = 0
FCBMERGXAlloc = 0
FCBINTSCall1 = 0
FCBINTSCall2 = 0
FCBINTSCheck = 0
FCBINTSAlloc = 0

IndexAlloc = 0xC000 -- 0xC000 ~ 0xEFFF : If, While / 0xA000 ~ 0xBFFF : Jump
FuncAlloc = 0x1D000 -- 0x1D000 ~ 0x1FFFF : CMul, CDiv, CMod / CtrigFunc
VarXAlloc = 0xFE00 -- 0xFE00 ~ 0xFFEF : Temp CVariable Alloc
MAXVAlloc = 0xFE00
VarXReleaseLock = 0
WarXAlloc = 0xFC00 -- 0xFC00 ~ 0xFDEF : Temp CWariable Alloc
MAXWAlloc = 0xFC00

FCBXORCall1 = 0
FCBXORCall2 = 0
FCBXORCheck = 0
FCBXORAlloc = 0
FCBSUBTCall1 = 0
FCBSUBTCall2 = 0
FCBSUBTCheck = 0
FCBSUBTAlloc = 0
FCBRMSTCall1 = 0
FCBRMSTCall2 = 0
FCBRMSTCheck = 0
FCBRMSTAlloc = 0
FCBXMAXCall1 = 0
FCBXMAXCall2 = 0
FCBXMAXCheck = 0
FCBXMAXAlloc = 0
FCBXMINCall1 = 0
FCBXMINCall2 = 0
FCBXMINCheck = 0
FCBXMINAlloc = 0
FCBXCNTRCall1 = 0
FCBXCNTRCall2 = 0
FCBXCNTRCheck = 0
FCBXCNTRAlloc = 0
FCBTCPYCall1 = 0
FCBTCPYCall2 = 0
FCBTCPYCheck = 0
FCBTCPYAlloc = 0
FCBTDELCall1 = 0
FCBTDELCall2 = 0
FCBTDELCheck = 0
FCBTDELAlloc = 0
FCBSORTCall1 = 0
FCBSORTCall2 = 0
FCBSORTCheck = 0
FCBSORTAlloc = 0
FCBSPLTCall1 = 0
FCBSPLTCall2 = 0
FCBSPLTCheck = 0
FCBSPLTAlloc = 0
FCBSHFLCall1 = 0
FCBSHFLCall2 = 0
FCBSHFLCheck = 0
FCBSHFLAlloc = 0
FCBSHFLSwitch = 0
FCBRVRSCall1 = 0
FCBRVRSCall2 = 0
FCBRVRSCheck = 0
FCBRVRSAlloc = 0

SVarXOrig = {0xF400,0xF440,0xF480,0xF4C0,0xF500,0xF540,0xF580,0xF5C0,0xF600,0xF640,0xF680,0xF6C0,0xF700,0xF740,0xF780
,0xF7C0,0xF800,0xF840,0xF880,0xF8C0,0xF900,0xF940,0xF980,0xF9C0,0xFA00,0xFA40,0xFA80,0xFAC0,0xFB00,0xFB40,0xFB80,0xFBC0}
SVarXAlloc = {0xF400,0xF440,0xF480,0xF4C0,0xF500,0xF540,0xF580,0xF5C0,0xF600,0xF640,0xF680,0xF6C0,0xF700,0xF740,0xF780
,0xF7C0,0xF800,0xF840,0xF880,0xF8C0,0xF900,0xF940,0xF980,0xF9C0,0xFA00,0xFA40,0xFA80,0xFAC0,0xFB00,0xFB40,0xFB80,0xFBC0}
-- 0xF400 ~ 0xFBFF : Temp CSVariable Alloc[1~32]
MAXSVAlloc = {0xF400,0xF440,0xF480,0xF4C0,0xF500,0xF540,0xF580,0xF5C0,0xF600,0xF640,0xF680,0xF6C0,0xF700,0xF740,0xF780
,0xF7C0,0xF800,0xF840,0xF880,0xF8C0,0xF900,0xF940,0xF980,0xF9C0,0xFA00,0xFA40,0xFA80,0xFAC0,0xFB00,0xFB40,0xFB80,0xFBC0}
LabelArr = {}
CRet = {0xFFF1,0xFFF2,0xFFF3,0xFFF4,0xFFF5,0xFFF6,0xFFF7,0xFFF8,0xFFF9,0xFFFA}
NRet = {0xFFE1,0xFFE2,0xFFE3,0xFFE4,0xFFE5,0xFFE6,0xFFE7,0xFFE8,0xFFE9,0xFFEA,0xFFEB,0xFFEC,0xFFED,0xFFEE,0xFFEF,0xFFF0}
WRet = {0xFDF0,0xFDF1,0xFDF2,0xFDF3,0xFDF4,0xFDF5,0xFDF6,0xFDF7,0xFDF8,0xFDF9,0xFDFA,0xFDFB,0xFDFC,0xFDFD,0xFDFE,0xFDFF}
581

------------------------------------------------------------------------------------------

『 H. 전역변수 목록 』

------------------------------------------------------------------------------------------

(｡˙+ﾟ 이 이름으로 변수 생성 금지 ｡+.ﾟ)
PushTrigArr = {}
PushTrigStack = 0
PushCondArr = {}
PushCondStack = {}
PushActArr = {}
PushActStack = {}
CondStackCount = 0
StackArrptr = 0
CondLineArr = {}
ActLineArr = {}
FlagAlloc = 0
EUDORPlayer = 0
EUDORFlag = 0
TTFCodeArr = {}
TTModeArr = {}
TTPushTrigArr = {}
TTPushCondArr = {}

TTPopTrigLock = 0
TPopTrigLock = 0
ORPushCondArr = {}
ORFCodeArr = {}
ORPopTrigLock = 0
_TPushCondArr = {}
_TFCodeArr = {}
_TPopTrigLock = 0
_TPushVarXAlloc = {}
_TPopPlayerIDArr = {}
STPushTrigArr = {}
STPopTrigLock = 0
RecoverCpValue = "X"
MoveCpValue = 0
CCArr = {}
CCPArr = {}
CCptr = 0

VoidAreaOffset = 0x58F500
VoidAreaAlloc = 0x58F500-4
StringKeyArr = {}
DetectRecoverCp = 0
CreateVarInitIndex = 0x18000
CreateVarXAlloc = 0x18000-1
CreateMaxVAlloc = 0x19FFF
CreateVarPArr = {}
CFuncParaVarNum = 16
CStackArr = {}
LStackArr = {}
CStackptr = {}
LStackptr = {}
CStackptr2 = {}
LStackptr2 = {}
CreateCStackVarXAlloc = 64
CreateLStackVarXAlloc = 32
CreateCCodeVarXAlloc = 0x19F00
CreateNCodeVarXAlloc = 0x19A00
CreateCCodeAlloc = 0
CreateNCodeAlloc = 0
iStringKeyArr = {}
iTBLIndexArr = {}
BulletTable = {}
BulletInitTable = {}
CFuncParaVarArr = {}
CFuncRetVarArr = {}
STRCTRIGASM = 0
NSQCVArray = {}
IncludePlayerID = 0
__SortTArr = {}
__SortArr = {}
__SortRet = {}
__SortEra = {}
__SortMax = {}
__SortNum = {}
__SortSum = {}
__SortChk = {}

CForce1 = {0,0,0,0,0,0,0,0}
CForce2 = {0,0,0,0,0,0,0,0}
CForce3 = {0,0,0,0,0,0,0,0}
CForce4 = {0,0,0,0,0,0,0,0}
CAllPlayers = {0,0,0,0,0,0,0,0}
Force5 = "Force5"
EveryPlayers = "EveryPlayers"

CBPlotTempArr = 0
FCBCONVRACall1 = 0
FCBCONVRACall2 = 0
FCBCONVRACheck = 0
FCBCONVRAAlloc = 0
FCBCONVXYCall1 = 0
FCBCONVXYCall2 = 0
FCBCONVXYCheck = 0
FCBCONVXYAlloc = 0
FCBMOVECall1 = 0
FCBMOVECall2 = 0
FCBMOVECheck = 0
FCBMOVEAlloc = 0
FCBMOVECNTRCall1 = 0
FCBMOVECNTRCall2 = 0
FCBMOVECNTRCheck = 0
FCBMOVECNTRAlloc = 0
FCBINVTCall1 = 0
FCBINVTCall2 = 0
FCBINVTCheck = 0
FCBINVTAlloc = 0
FCBRATOCall1 = 0
FCBRATOCall2 = 0
FCBRATOCheck = 0
FCBRATOAlloc = 0
FCBROTACall1 = 0
FCBROTACall2 = 0
FCBROTACheck = 0
FCBROTAAlloc = 0
FCBROTA3DCall1 = 0
FCBROTA3DCall2 = 0
FCBROTA3DCheck = 0
FCBROTA3DAlloc = 0
FCBCROPCall1 = 0
FCBCROPCall2 = 0
FCBCROPCheck = 0
FCBCROPAlloc = 0
FCBMIRXCall1 = 0
FCBMIRXCall2 = 0
FCBMIRXCheck = 0
FCBMIRXAlloc = 0
FCBMIRYCall1 = 0
FCBMIRYCall2 = 0
FCBMIRYCheck = 0
FCBMIRYAlloc = 0

FCBDTRNCall1 = 0
FCBDTRNCall2 = 0
FCBDTRNCheck = 0
FCBDTRNAlloc = 0
FCBDTRN2Call1 = 0
FCBDTRN2Call2 = 0
FCBDTRN2Check = 0
FCBDTRN2Alloc = 0
FCBWARPCall1 = 0
FCBWARPCall2 = 0
FCBWARPCheck = 0
FCBWARPAlloc = 0
FCBKADSXCall1 = 0
FCBKADSXCall2 = 0
FCBKADSXCheck = 0
FCBKADSXAlloc = 0
FCBKADSX2Call1 = 0
FCBKADSX2Call2 = 0
FCBKADSX2Check = 0
FCBKADSX2Alloc = 0
FCBKADSCall1 = 0
FCBKADSCall2 = 0
FCBKADSCheck = 0
FCBKADSAlloc = 0
FCBKADS2Call1 = 0
FCBKADS2Call2 = 0
FCBKADS2Check = 0
FCBKADS2Alloc = 0
FCBVECTCall1 = 0
FCBVECTCall2 = 0
FCBVECTCheck = 0
FCBVECTAlloc = 0
FCBSHISCall1 = 0
FCBSHISCall2 = 0
FCBSHISCheck = 0
FCBSHISAlloc = 0
FCBCROPACall1 = 0
FCBCROPACall2 = 0
FCBCROPACheck = 0
FCBCROPAAlloc = 0
FCBCROPGCall1 = 0
FCBCROPGCall2 = 0
FCBCROPGCheck = 0
FCBCROPGAlloc = 0

SRet = {{0xF43C,0xF43D,0xF43E,0xF43F},{0xF47C,0xF47D,0xF47E,0xF47F},{0xF4BC,0xF4BD,0xF4BE,0xF4BF},{0xF4FC,0xF4FD,0xF4FE,0xF4FF},
{0xF53C,0xF53D,0xF53E,0xF53F},{0xF57C,0xF57D,0xF57E,0xF57F},{0xF5BC,0xF5BD,0xF5BE,0xF5BF},{0xF5FC,0xF5FD,0xF5FE,0xF5FF},
{0xF63C,0xF63D,0xF63E,0xF63F},{0xF67C,0xF67D,0xF67E,0xF67F},{0xF6BC,0xF6BD,0xF6BE,0xF6BF},{0xF6FC,0xF6FD,0xF6FE,0xF6FF},
{0xF73C,0xF73D,0xF73E,0xF73F},{0xF77C,0xF77D,0xF77E,0xF77F},{0xF7BC,0xF7BD,0xF7BE,0xF7BF},{0xF7FC,0xF7FD,0xF7FE,0xF7FF},
{0xF83C,0xF83D,0xF83E,0xF83F},{0xF87C,0xF87D,0xF87E,0xF87F},{0xF8BC,0xF8BD,0xF8BE,0xF8BF},{0xF8FC,0xF8FD,0xF8FE,0xF8FF},
{0xF93C,0xF93D,0xF93E,0xF93F},{0xF97C,0xF97D,0xF97E,0xF97F},{0xF9BC,0xF9BD,0xF9BE,0xF9BF},{0xF9FC,0xF9FD,0xF9FE,0xF9FF},
{0xFA3C,0xFA3D,0xFA3E,0xFA3F},{0xFA7C,0xFA7D,0xFA7E,0xFA7F},{0xFABC,0xFABD,0xFABE,0xFABF},{0xFAFC,0xFAFD,0xFAFE,0xFAFF},
{0xFB3C,0xFB3D,0xFB3E,0xFB3F},{0xFB7C,0xFB7D,0xFB7E,0xFB7F},{0xFBBC,0xFBBD,0xFBBE,0xFBBF},{0xFBFC,0xFBFD,0xFBFE,0xFBFF}}
ForwardPoint = {}

582

------------------------------------------------------------------------------------------

『 H. 전역변수 목록 』

------------------------------------------------------------------------------------------

(｡˙+ﾟ 이 이름으로 변수 생성 금지 ｡+.ﾟ)
FCBPAINTCheck = 0
FCBPAINTCVoid = 0
FCBPAINTCVArr = 0

FileDirectory = nil
TBLStringTable = 0
EncodeTable = 0

CAPlotJumpAlloc = 0xA00
CAPlotVarAlloc = 0x1A000
CAPlotDataArr = {}
CAPlotPlayerID = {}
CAPlotCreateArr = {}
CBPlotLoopMaxptr = {}
CBPlotOrderArr = {}
CBPlotFArrX = {}
CBPlotFArrY = {}
CBPlotFArrN = {}
CBPlotNum = {}
CBPlotTNum = {}

ARet = {"X",0xF000,0,"V"}
CAPrintVarAlloc = 0xF002
CAPrintPlayerID = {}
CAPrintDataArr = {}
CAPrintCreateArr = {}

CSLoadInitCheck = 0
CSSaveInitCheck = 0
CFuncPlayer = "X"
CFuncIndex = "X"
CFuncArr = {}
CFuncptr = 0
FileNameIndex = 0

FLReadCall1 = 0
FLReadCall2 = 0
FLReadCheck = 0
FLReadXCall = {}
FLReadXCheck = 0
FLReadXAlloc = 0
FLAddCall1 = 0
FLAddCall2 = 0
FLSubCall1 = 0
FLSubIndex = 0
FLSubCall2 = 0
FLNegCall1 = 0
FLNegCall2 = 0
FLiSubCall1 = 0
FLiSubCall2 = 0
FLAbsCall1 = 0
FLAbsCall2 = 0
FLRandCall1 = 0
FLRandCall2 = 0
FLRandCheck = 0
FLRandSwitch = 0
FLlShiftCall1 = 0
FLlShiftCall2 = 0
FLMulCall1 = 0
FLMulCall2 = 0
FLiMulCall1 = 0
FLiMulCall2 = 0
FLMulCheck = 0
FLMulAlloc = 0
FLAndCall1 = 0
FLAndCall2 = 0
FLOrCall1 = 0
FLOrCall2 = 0
FLNotCall1 = 0
FLNotCall2 = 0
FLXorCall1 = 0
FLXorCall2 = 0
FLDIVCall1 = 0
FLDIVCall2 = 0
FLiDIVCall1 = 0
FLiDIVCall2 = 0
FLMODCall1 = 0
FLMODCall2 = 0
FLiMODCall1 = 0
FLiMODCall2 = 0
FLDivCheck = 0
FLDivAlloc = 0

FSHReadCall1 = 0
FSHReadCall2 = 0
FSHReadCheck = 0
FReadCall1 = 0
FEPDCall1 = 0
FReadCall2 = 0
FEPDCall2 = 0
FMEM = {}
FMEMCall0 = 0
FMEMCall1 = 0
FMEMCall2 = 0
FMEMCheck = 0
FMEMAlloc = 0
FMEME = {}
FMEMECall1 = 0
FMEMECall2 = 0
FMEMECheck = 0
FReadXCall0 = 0
FReadXCall1 = 0
FReadXCall2 = 0
FReadXCall3 = 0
FReadXCall4 = 0
FReadXCall5 = 0
FReadXCall6 = 0
FReadXCall7 = 0
FMOVE = {}
FMOVECall0 = 0
FMOVECall1 = 0
FMOVECall2 = 0
FMOVECheck = 0
FMOVEAlloc = 0
FCONV = {}
FCONVCall0 = 0
FCONVCall1 = 0
FCONVCall2 = 0
FCONVCheck = 0
FCONVAlloc = 0
FBYTE = {}
FBYTECall0 = 0
FBYTECall1 = 0
FBYTECall2 = 0
FBYTECheck = 0
FBYTEAlloc = 0
FCOND = {}
FCONDCall0 = 0
FCONDCall1 = 0
FCONDCall2 = 0
FCONDCall3 = 0
FCONDCheck = 0
FCONDAlloc = 0
FCHAT = {}
FCHATCall1 = 0
FCHATCall2 = 0
FCHATCheck = 0
FCHATAlloc = 0
FMOVEArr = {}
FMEMEArr = {}
FMEMArr1 = {}
FMEMArr2 = {}
FCONVArr = {}
FBYTEArr = {}
FCONDArr = {}

FBWZCall1 = 0
FBWZCall2 = 0
FBWZCheck = 0
FBWXCall1 = 0
FBWXCall2 = 0
FBWXCheck = 0
FWWZCall1 = 0
FWWZCall2 = 0
FWWZCheck = 0
FWWXCall0 = 0
FWWXCall1 = 0
FWWXCall2 = 0
FWWXCheck = 0
FLINECall1 = 0
FLINECall2 = 0
FLINECheck = 0
FDINECall1 = 0
FDINECall2 = 0
FDINECheck = 0
FGINDXCall1 = 0
FGINDXCall2 = 0
FGINDXCheck = 0
FGINDX2Call1 = 0
FGINDX2Call2 = 0
FGINDX2Check = 0
FDISPCall1 = 0
FDISPCall2 = 0
FDISPCheck = 0
FDISPXCall1 = 0
FDISPXCall2 = 0
FDISPXCheck = 0
FSTRLCall1 = 0
FSTRLCall2 = 0
FSTRLCheck = 0
FCHATOCall = 0
FCHATOCheck = 0
FSCANV = {}
FSCANVCall1 = 0
FSCANVCall2 = 0
FSCANVCheck = 0
FSCANW = {}
FSCANWCall1 = 0
FSCANWCall2 = 0
FSCANWCheck = 0
FENCD = {}
FENCDCall1 = 0
FENCDCall2 = 0
FENCDCheck = 0
FiMULCall1 = 0
FiMULCall2 = 0
FMULCall0 = 0
FMULCall1 = 0
FMULCall2 = 0
FDIVCall1 = 0
FDIVCall2 = 0
FDIVCall3 = 0
FMODCall1 = 0
FMODCall2 = 0
FMODCall3 = 0
FIDIVCall1 = 0
FIDIVCall2 = 0
FIDIVCall3 = 0
FIMODCall1 = 0
FIMODCall2 = 0
FIMODCall3 = 0
FABSCall1 = 0
FABSCall2 = 0

FSQRTCall1 = 0
FSQRTCall2 = 0
FSQRTCall3 = 0
FSQRTCheck = 0
FSQRT = {}
FLENGCall1 = 0
FLENGCall2 = 0
FLENGCheck = 0
FLENG = {}
FATANCall1 = 0
FATANCall2 = 0
FATANCheck = 0
FATAN = {}
FLOG2Call1 = 0
FLOG2Call2 = 0
FLOG2Check = 0
FLOG2 = {}
AngleCycle = 0
FRAND = 0
FRANDCall1 = 0
FRANDCall2 = 0
FPSTR = {}
FPSTRCall0 = 0
FPSTRCall1 = 0
FPSTRCall2 = 0
FPSTRCheck = 0
FPSTRX = {}
FPSTRXCall1 = 0
FPSTRXCall2 = 0
FPSTRXCheck = 0
FPTBL = {}
FPTBLCall0 = 0
FPTBLCall1 = 0
FPTBLCall2 = 0
FPTBLCheck = 0
ISTR = {}
ISTRCall1 = 0
ISTRCall2 = 0
ISTRCheck = 0
FISTRX = {}
FISTRXCall1 = 0
FISTRXCall2 = 0
FISTRXCheck = 0
ITBL = {}
ITBLCall1 = 0
ITBLCall2 = 0
ITBLCheck = 0
FCTACall0 = 0
FCTACall1 = 0
FCTACall2 = 0
FCTACheck = 0
FATCCall1 = 0
FATCCall2 = 0
FATCCheck = 0
FCGU = {}
FCGUCall1 = 0
FCGUCall2 = 0
FCGUCheck = 0

__VArrSTR = {"","","",""}
__VArrCheck = 0
__WArrSTR = {"","","","","",""}
__WArrCheck = 0
__SVArrSTR = {"","","","","","","",""}
__SVArrCheck = 0
FuncAllocLimit = 0x20000
IndexAllocLimit = 0xF000
JumpStartAlloc = 0xA000
JumpEndAlloc = 0xB000
CAPrintVarLimit = 0xF300
CAPlotVarLimit = 0x1D000
CAPlotJumpLimit = 0x1000
VoidAreaLimit = 0x5967F0
FlagAllocBase = 0xF300
FlagAllocLimit = 0xF400
__VoidCondArr = {} -- 20bytes
__VoidActArr = {} -- 32bytes
__StringArray = {}
__UPUSCheckArray = {}
__TRIGChkptr
FBRZCall1 = 0
FBRZCall2 = 0
FBRZCheck = 0
FBRXCall1 = 0
FBRXCall2 = 0
FBRXCheck = 0
FWRZCall1 = 0
FWRZCall2 = 0
FWRZCheck = 0
FWRXCall0 = 0
FWRXCall1 = 0
FWRXCall2 = 0
FWRXCheck = 0

583

------------------------------------------------------------------------------------------

『 I. Index 자동할당 목록 』

------------------------------------------------------------------------------------------

(｡˙+ﾟ 자동할당 Index으로 Label 사용금지 ｡+.ﾟ)
0x0000 : Label(0) (Ctrig조건/액션 사용 표시용)
0x0001 ~ 0x9FFF : 사용가능 Index 영역 1
0x10000 ~ 0x17FFF : 사용가능 Index 영역 2
sIndex : 0x000 ~ 0x9FF : 사용가능 sIndex 영역
--↓Index 자동 할당 목록 -----------------------------------------sIndex : 0xA00 ~ 0xFFF : CAPlotJumpAlloc
0xA000 ~ 0xBFFF : Jump
0xC000 ~ 0xEFFF : If, While (=IndexAlloc)
0xF000 ~ 0xF2FF : CAPrintAlloc
0xF300 ~ 0xF3FF : FlagAlloc
0xF400 ~ 0xFBFF : Temp CSVariable Alloc (=SVarXAlloc) & SRet
0xFC00 ~ 0xFDFF : Temp CWariable Alloc (=WarXAlloc) & WRet
0xFE00 ~ 0xFFDF : Temp CVariable Alloc (=VarXAlloc)
0xFFE0 : System Label(0) Index (사용금지)
0xFFE1 ~ 0xFFFA : NRet + CRet (Register) & FlagAlloc Max 12480
0xFFFB ~ 0xFFFF : Ctriginit (Start & End)

0x18000 ~ 0x19FFF : CreateVarXAlloc (기본설정)
0x1A000 ~ 0x1CFFF : (=CAPlotVarAlloc)
0x1D000 ~ 0x1FFFF : CMul, CDiv, CMod / CtrigFunc (=FuncAlloc)

584

------------------------------------------------------------------------------------------

『 J. Cp트릭 사용함수 목록 』

------------------------------------------------------------------------------------------

(｡˙+ﾟ CP트릭 사용중 주의 ｡+.ﾟ)
※ Cp트릭 사용 중 일 경우 , Cp값 동기화 변수 존재시 SetRecoverCp로,
Cp값 동기화 변수 없을때 SaveCp -> SetRecoverCp으로 RecoverCp인자 전달
※ 함수 인자에 MovX연산 (Dest<<VA,WA,SVA)을 실행하는 경우 RecoverCp실행
f_Cast(PlayerID,Dest,Source,Deviation,Mask,Clear)
(Source = VA,WA)
f_iCast(PlayerID,Dest,Source) (Source = VA,WA)
SCast(PlayerID,Dest,Source,Deviation,Mask,Clear)
(Source = VA,SVA)
MovX(PlayerID,Dest,Source,Mode,Mask,Clear) (Source = VA)
MovW(PlayerID,Dest,Source,Mode,Mask,Clear) (Source = WA)
MovS(PlayerID,Dest,Source,Mode,Mask,Clear) (Source = SVA)
CMovX(PlayerID,Dest,Source,Mode,Mask,Deviation,Clear)
(Source = VA)
f_LMovX(PlayerID,Dest,Source,Mode,Mask,Deviation,Clear)
(Source = VA,WA)
CRead(PlayerID,Dest,Source,Deviation,Mask,EPDRead,Clear)
(Source = V,VA,A)
CReadX(PlayerID,Dest,Source,Deviation,Mask,Multiplier,Clear)
(Source = V,VA,A)
f_Read(PlayerID,Input,Output,EPDOutput,Mask,Clear)
f_ReadX(PlayerID,Input,Output,Multiplier,Mask,Clear)
f_LRead(PlayerID,Input,Output,Mask,Clear)
f_LReadX(PlayerID,Input,Output,Multiplier,Mask,Clear)
f_Movcpy(PlayerID,Dest,SourceVA,Size,Distance)
f_MovcpyEPD(PlayerID,Dest,SourceVA,Size,InitBytes,Distance)
f_byteConvert(PlayerID,DestVA,Source,Size,Distance)
f_byteConvertX(PlayerID,DestVA,Source,SourceX,Size,Distance)
f_bytecpy(PlayerID,Dest,SourceVA,Size,Distance)
f_bytecpyX(PlayerID,Dest,DestX,SourceVA,Size,Distance)
f_bytecmp(PlayerID,Flag,Dest,SourceVA,Size,Distance)
f_bytecmpX(PlayerID,Flag,Dest,DestX,SourceVA,Size,Distance)
f_GetTblptr(PlayerID,Output,TBLIndex)
f_GetStrXptr(PlayerID,Output,StringId)
f_GetStrptr(PlayerID,Output,StringId)

이외의 함수에도 PushRecoverCpMsg(Flag)를 통해서 Cp트릭 사용여부를 확인가능

585

------------------------------------------------------------------------------------------

『 K. 내부함수 목록 』

------------------------------------------------------------------------------------------

(｡˙+ﾟ 이 이름으로 함수 생성 금지 ｡+.ﾟ)
PlayerConvert(PlayerID)
PlayerConvertX(PlayerID)
AllocCheck()
LabelCheck()
ControlCheck()
EUDORInit(PlayerID)
EUDOR(AND_Conditions)
EUDCond(FlagID)
EUDCompare(PlayerID,Mode,TargetCond)
EUDNotSame(PlayerID,TargetCond)
EUDAbove(PlayerID,TargetCond)
EUDBelow(PlayerID,TargetCond)
ORPopCondArr(PlayerID)
InitCtrig()
FlagIndex(FlagID)
PopCondArr(Conditions)
PopActArr(Actions)
PopTrigArr(PlayerID,ActPushLine,CondPushLine)
TTPopTrigArr(PlayerID)
STPopTrigArr(PlayerID)
_TPopCondArr(PlayerID)
_TPopTrig(Flag,_TCond,Type,Value)
_TPopBind(_TCond)
MovY(PlayerID,Dest,Source,Type,Mask)
MovZ(PlayerID,Dest,Source,Address)
MovW(PlayerID,Dest,Source,Mode,Mask,Clear)
I64(Number)
I64Sub(a,b,c,d)
I64Sub2(a,b,c,d)
I64Neg(a,b)
I64Add(a,b,c,d)
I64Mul(a,b,c,d)
I64Pow(a,b,c)_ConvertBwriteZ(PlayerID,Offset,Value,ValueOutput)
_ConvertBwriteX(PlayerID,Offset,Value,EPDOutput,ValueOutput,MaskOutput)
_ConvertBwrite(PlayerID,Base,Index,Value,EPDOutput,ValueOutput,MaskOutput)
_ConvertWwriteZ(PlayerID,Offset,Value,ValueOutput)
_ConvertWwriteX(PlayerID,Offset,Value,EPDOutput,ValueOutput,MaskOutput)
_ConvertWwrite(PlayerID,Base,Index,Value,EPDOutput,ValueOutput,MaskOutput)
utf8_from(t)
ParseHotkey(String)
ParseButtonType(String)
tbl_to_itbl(String,Type,Hotkey,Hexflag)
str_to_istr(String)
str_to_iutf8(String,flag)
str_to_icp949(String,flag)
MakeHotkeyValue(String)
MakeButtonTypeValue(String)
CAPrintAllocCheck()
__InitTrigger()
SetFileDirectory(AbsolutePath)
__PopStringArray()
EncodeTableptr(PlayerID)
__DoActions2(PlayerID,Actions,Flags)
PlayerConvert2(PlayerID)
__Comment(Text)
PlayerConvert2X(PlayerID)
__Trigger(args)
CunPack(CPack)
__FlattenAct(Actions)
ParseKeyName(KeyName)
__FlattenCCond(Conditions)
ParseMouseName(KeyName)
__FlattenCAct(Actions)
Include_Last()
CSSaveInit()
CAPlotAllocCheck()
Include_CBLast(IncludePlayer)
__Sort(Level,Start,End)
__TSort(Level,Start,End)
__SortT(Level,Start,End)
+ Print_utf8X.lua에 있는 함수들

586

------------------------------------------------------------------------------------------

『 L. Vi() 사용가능함수 목록 』

------------------------------------------------------------------------------------------

(｡˙+ﾟVi(Wi)를 사용해 Deviation 값 삽입 가능｡+.ﾟ)
CA__Input(Input,SVA1,Mask) : SVA1
CA__InputVA(Index,SVA1,Size,Mask,Start,End,SourceDistance) : Size, index, Start, End, SVA1
CA__epdcmp(Dest,Source,Size,Mask,CFlag) : Size, Dest, Source
CA__InputSVA1(Dest,Source,Size,Mask,Start,End,Next,DestDistance,SourceDistance) : Size, Dest, Start, End
CA__InputSVA1X(Dest,Source,Size,Mask,DestMask,Start,End,Next,DestDistance,SourceDistance) : Size, Dest, Start, End, Source
CA__SetValue(SVA1,String,Mask,Index,Preserve,utf8flag) : Index
CA__SetMask(SVA1,Mask,Start,End,Preserve) : Start, End

CA__epdcpy(SVA1,Value,Mask,Start,End,Preserve) : Start, Value, End
CA__SetNext(SVA1,DestDistance,Mode,Start,End,Preserve) : DestDistance, Start, End
CA__MoveXY(SVA1,Line,Mul,Mode,Fix,PathData,Preserve) : PathData
CA__Mov(SVA1,Output,Mask,RecoverMask) : SVA1
CA__Movcpy(SVA1,Output,Size,Mask,RecoverMask,DestDistance) : Size, SVA1
CA__OverWrite(SVA32,Index,Null,Preserve) : Index
CA__ConvertColor(SVA1,ConvertData,MaskData,Start,End) : Start, End, ConvertData
CA__ConvertLetter(SVA1,ConvertData,MaskData,Start,End,utf8flag) : Start, End, ConverData
CA__ItoCustom(SVA1,Input,Output,Mask,Base,Length,Init,Sign,ColorArr,IndexArr,DataArr,ClearArr,utf8flag) : Input
CA__lItoCustom(SVA1,Input,Output,Mask,Base,Length,Init,Sign,ColorArr,IndexArr,DataArr,ClearArr,utf8flag) : Input
CA__Encode(Dest,Source,Size,cp949flag) : Size, Dest, Source
CDPrint(Line,Size,Init,DisplayPlayer,Preset,CDfunc,PlayerID,Condition,PerAction,Action) : Line
CD__InputVAX(Index,SVA1,Size,Mask,DestMask,Start,End,SourceDistance) : Size, Index, Start, End, SVA1
CD__ScanV(SVA1,Size,Variable,Output,Base,Sign) : Size, Base, Sign, SVA1
CD__ScanW(SVA1,Size,Wariable,Output,Base,Sign) : Size, Base, Sign, SVA1
CD__ScanChat(SVA1,Offset,Size,Output,Null,SkipInit) : Offset, Size, SVA1
CallCFunc(CFunction,Parameter,Return,PlayerID,Conditions,Actions,Once) : Parameter
CallCFuncX(PlayerID,CFunction,Parameter,Return) : Parameter
CallVFunc(Wariable,Parameter,Return,PlayerID,Conditions,Actions,Once) : Parameter
CallVFuncX(PlayerID,Wariable,Parameter,Return) : Parameter
+모든 T/TT 기본 조건/액션의 변수삽입 부분 (TTbytecmp(X) 제외)
CA__함수의 경우 k입력시 k*604로 입력됨
Arr(Array,Index,Player) : Index
LArr(Array,Index,Player) : Index

ConvertArr(PlayerID,Dest,Source) : Source

LArrX(LArray,Index,Player) : Index

ConvertLArr(PlayerID,Dest,Source,Mode) : Source

VArr(VArray,Index,Player) : Index

ConvertVArr(PlayerID,Dest,Dest4,Source,Size) : Source

VArrX(VArray,Index,Index4,Player) : Index

ConvertSVArr(PlayerID,Dest,Dest4,Source,Size) : Source

SVArr(SVArray,Index,Line,Player) : Index

ConvertWArr(PlayerID,Dest,Dest4,Source,Size) : Source

SVArrX(SVArray,Index,Index4,Player) : Index

SetRecoverCp(Cp) : Cp

WArr(WArray,Index,Player) : Index

CWrite(PlayerID,Dest,Source,Deviation,Mask) : Dest

WArrX(WArray,Index,Index4,Player) : Index

f_LWrite(PlayerID,Dest,Source,Deviation,Mask) : Dest
587

------------------------------------------------------------------------------------------

『 M. STRCTRIG 적용방법 』

------------------------------------------------------------------------------------------

｡˙+ﾟSTRCtrigAssembler v1.1 ｡+.ﾟ

STRCtrigAssembler.exe 사용법
STRCtrigAssembler는 Tep트리거를 STRx단락으로 옮김
(나간 플레이어의 트리거 보존 및 외부 파일 삽입 가능)

STRCtrigAsm 사용방법 :
1. Euddraft가 있는 폴더에 STRCtrigAssembler.exe를 넣는다.
2. 적용할 맵의 StartCtrig에 STRCTRIG 항목에 1을 입력하고 컴파일한다.
(파일 삽입 함수 사용시 AbsolutePath도 입력해야함)
3. STRCtrigAsm을 적용할 맵을 드래그 앤 드롭으로 STRCtrigAssembler.exe에 놓는다.
4. 결과창에 (삽입한 맵 이름)_out.scx로 저장됨이 출력되면 엔터를 2번 입력한다.
5. 플러그인 입력칸 또는 .eds 파일에 [STRCtrig Assembler v5.4]를 입력 후 저장한다.
6. (삽입한 맵 이름)_out.scx 파일을 Euddraft(EUDEdior2,3 등)로 컴파일한다.
※ STRCtrigAsm 적용맵은 일반 CtrigAsm 적용맵보다 시작 로딩속도가 25배정도 빨라짐
※ STRCtrigAsm 적용시 플레이어가 나가도 해당 플레이어의 트리거가 보존됨 (Next로 접근가능)
※ CtrigAsm 함수 중 #STRCtrig 필수 항목은 반드시 STRCtrigAsm을 사용해야 작동하는 함수임
※ STRCtrigAsm 사용시 P9~P12가 체크된 트리거를 사용시 오류가 발생할 수 있음 (파일삽입에 사용)

※ NSQC와 함께 사용시 반드시 NSQC보다 STRCtrigAsm을 위에 입력해야함
※ STRCtrigAsm 사용시 euddraft 폴더에 TRIGP1~P8.chk를 생성함 (py에서 로드용)
※ Loader2(X).lua로 맵파일 이름__TRIG.chk가 맵파일 경로에 존재시 해당 파일을 사용함
※ STRCtrigAssembler.exe 사용시 SFmpq.dll이 필요함 (exe폴더 참고)
※ STRCtrigAssembler.exe 사용시 euddraft 0.8.9.0 이상의 버전을 사용해야함 (STRx패치)
-----------------------------------------------------------------------------------------------588

------------------------------------------------------------------------------------------

『 N. CPLP 프로텍터 적용방법 』

------------------------------------------------------------------------------------------

｡˙+ﾟCustomPlibLockProtector v1.1 ｡+.ﾟ

CustomPlibLockProtector.exe 사용법
CustomPlibLockProtector는 eudplib맵의 수정을 방지하는 파이썬 프로텍터임
CPLP 사용방법 :

1. 플러그인 입력칸 또는 .eds 파일에 [CPLP]를 입력 후 저장한다.
2. 적용할 맵을 Euddraft(EUDEditor2,3 등)로 컴파일한다.
3. 컴파일 된 맵을 드래그 앤 드롭으로 CustomPlibLockProtector.exe에 놓는다.
4. (삽입한 맵 이름)_out.scx로 저장된 맵을 사용한다. (프로텍터 적용완료)
※ CPLP 사용시 반드시 Freeze를 끄고 컴파일 해야함 (중복 사용 불가)
※ eudplib 오프젝트 개수 초과로 Freeze를 사용할 수 없을 때도 CPLP는 사용가능함
※ CPLP 사용시 추가 시작 로딩시간이 발생하지 않음
※ CustomPlibLockProtector 사용을 원할시 이메일을 보내면 맞춤제작으로 보내준당
------------------------------------------------------------------------------------------------

589

------------------------------------------------------------------------------------------

『 O. 도형 추출기 사용방법 』

------------------------------------------------------------------------------------------

｡˙+ﾟCS_Extractor v2.0 ｡+.ﾟ

도형추출기 (CS_Extractor.exe) 사용법
도형추출기는 맵 상에 배치된 특정 플레이어의 특정 종류의 유닛을 도형데이터로 변환함
도형추출기 사용방법 :
1. 도형 데이터를 추출할 맵을 드래그 앤 드롭으로 CS_Extractor.exe에 놓는다.
2. 추출할 유닛의 소유 플레이어(1~12중 입력)와 유닛ID(0~227중 입력)을 입력 후 엔터
※ 결과창 : Index = 맵상 유닛 Index → {X좌표, Y좌표} (Shape점 순서)
(변환된 Shape이름) : Total (Shape데이터의 점 수) Unit Converted 형식으로 출력됨
3. 해당 맵에서 계속 Shape데이터를 변환할 경우 다시 플레이어와 유닛ID입력,
아닐경우 0 0을 입력후 엔터
4. (삽입한 맵 이름)_out.txt에 변환된 Shape 데이터가 저장됨
5. 변환된 Shape데이터를 그대로 복사해서 코드에 붙여넣은 후 해당 도형데이터를 사용
※ 도형데이터 변환시 사용자가 맵에 유닛을 배치했던 순서대로 도형데이터를 변환함 (Index 순서)
※ 변환된 도형데이터는 맵의 맨 왼쪽위 꼭짓점을 (0,0) 원점으로 좌표값을 저장함 (맵 좌표계)

※ CS_Extractor.exe 사용시 SFmpq.dll이 필요함 (exe폴더 참고) / Ex) [예제 O-1] 참고
------------------------------------------------------------------------------------------------

590

------------------------------------------------------------------------------------------

『 O. 도형 추출기 사용방법 』

-----------------------------------------------------------------------------------------[예제 O-1] (CS_Extractor 예제) 도형 추출 및 손그림 도형 데이터 출력 예제
(CB Paint 예제맵을 사용함, CS_Example 폴더 안의 O-1.scx를 CS_Extractor.exe에 삽입)

591

------------------------------------------------------------------------------------------

『 O. 도형 추출기 사용방법 』

-----------------------------------------------------------------------------------------[예제 O-1] (CS_Extractor 예제) 도형 추출 및 손그림 도형 데이터 출력 예제
(CB Paint 예제맵을 사용함, CS_Example 폴더 안의 O-1.scx를 CS_Extractor.exe에 삽입)

592

------------------------------------------------------------------------------------------

『 O. 도형 추출기 사용방법 』

-----------------------------------------------------------------------------------------[예제 O-1] (CS_Extractor 예제) 도형 추출 및 손그림 도형 데이터 출력 예제
(CB Paint 예제맵을 사용함, CS_Example 폴더 안의 O-1.scx를 CS_Extractor.exe에 삽입)

593

------------------------------------------------------------------------------------------

『 O. 도형 추출기 사용방법 』

-----------------------------------------------------------------------------------------[예제 O-1] (CS_Extractor 예제) 도형 추출 및 손그림 도형 데이터 출력 예제
(CB Paint 예제맵을 사용함, CS_Example 폴더 안의 O-1.scx를 CS_Extractor.exe에 삽입)

594

------------------------------------------------------------------------------------------

『 O. 도형 추출기 사용방법 』

-----------------------------------------------------------------------------------------[예제 O-1] (CS_Extractor 예제) 도형 추출 및 손그림 도형 데이터 출력 예제
(CB Paint 예제맵을 사용함, CS_Example 폴더 안의 O-1.scx를 CS_Extractor.exe에 삽입)
SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P2)
StartCtrig(1)
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1")
CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)

DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000)
,SetMemory(0x581D78,SetTo,0x75757575),SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})

-- O-1_out.txt의 내용을 그대로 붙여넣음 (1078 = P1 피닉스, C080 = P12 모조)

Shape1078 = {136 ,{240, 224},{224, 224},{224, 240},{208, 240},{192, 256},{192, 272},{176, 272},{176, 288},{160, 304},{160, 320},{160, 336},{144, 336},{144, 352},{144, 368},{144, 384},{144, 400},{144, 416},{144, 432},{144, 448},{144, 464},{160, 464},{160, 480},{160, 496}
,{176, 496},{176, 512},{192, 512},{192, 528},{208, 528},{208, 544},{224, 544},{224, 560},{240, 560},{256, 560},{256, 576},{272, 576},{288, 576},{304, 576},{320, 576},{336, 576},{352, 576},{368, 576},{384, 576},{400, 576},{416, 576},{432, 576},{432, 560},{448, 560},{464, 560}
,{464, 544},{480, 544},{480, 528},{496, 528},{496, 512},{496, 496},{512, 496},{512, 480},{512, 464},{512, 448},{512, 432},{512, 416},{512, 400},{512, 384},{512, 368},{512, 352},{512, 336},{512, 320},{496, 320},{496, 304},{496, 288},{480, 288},{480, 272},{464, 272},{464, 256}
,{448, 256},{448, 240},{432, 240},{416, 240},{400, 240},{400, 224},{384, 224},{368, 224},{352, 224},{336, 224},{320, 224},{304, 224},{288, 224},{272, 224},{256, 224},{240, 224},{224, 224},{224, 240},{224, 256},{624, 416},{640, 416},{656, 416},{672, 416},{688, 416},{704, 416}
,{720, 416},{736, 416},{752, 416},{768, 416},{784, 416},{800, 416},{944, 192},{944, 208},{944, 224},{944, 240},{944, 256},{944, 272},{944, 288},{944, 304},{944, 320},{944, 336},{944, 352},{944, 368},{944, 384},{944, 400},{944, 416},{944, 432},{960, 432},{960, 448},{960, 464}
,{960, 480},{960, 496},{960, 512},{960, 528},{960, 544},{960, 560},{960, 576},{960, 592},{960, 608},{960, 624},{976, 624},{976, 640},{976, 656}}
ShapeC080 = {249 ,{128, 960},{144, 960},{144, 944},{160, 944},{176, 944},{192, 944},{208, 944},{208, 928},{224, 928},{240, 928},{256, 928},{272, 928},{272, 912},{288, 912},{304, 912},{320, 912},{336, 912},{336, 896},{352, 896},{368, 896},{384, 896},{384, 880},{400, 880}
,{416, 880},{432, 880},{432, 864},{448, 864},{464, 864},{480, 864},{480, 848},{496, 848},{512, 848},{528, 832},{544, 832},{560, 832},{560, 816},{576, 816},{592, 816},{608, 816},{608, 800},{624, 800},{640, 800},{656, 784},{672, 784},{688, 784},{688, 768},{704, 768},{720, 768}
,{736, 768},{736, 752},{752, 752},{752, 768},{736, 768},{736, 784},{736, 800},{720, 816},{720, 832},{704, 832},{704, 848},{704, 864},{688, 864},{688, 880},{672, 880},{672, 896},{672, 912},{656, 912},{656, 928},{640, 928},{640, 944},{640, 960},{624, 960},{624, 976},{608, 976}
,{608, 992},{592, 1008},{592, 1024},{576, 1024},{576, 1040},{560, 1040},{560, 1056},{544, 1072},{544, 1088},{528, 1088},{528, 1104},{512, 1104},{512, 1120},{512, 1136},{496, 1136},{496, 1152},{480, 1152},{480, 1168},{464, 1168},{464, 1184},{448, 1184},{448, 1200},{448, 1216}
,{432, 1216},{432, 1232},{416, 1232},{416, 1248},{416, 1264},{416, 1248},{400, 1248},{400, 1232},{400, 1216},{400, 1200},{400, 1184},{400, 1168},{400, 1152},{384, 1152},{384, 1136},{384, 1120},{384, 1104},{384, 1088},{384, 1072},{384, 1056},{384, 1040},{384, 1024}
,{368, 1024},{368, 1008},{368, 992},{368, 976},{368, 960},{368, 944},{368, 928},{368, 912},{368, 896},{368, 880},{368, 864},{368, 848},{368, 832},{368, 816},{368, 800},{368, 784},{368, 768},{368, 752},{368, 736},{368, 720},{368, 704},{368, 720},{384, 720},{400, 736},{400, 752}
,{416, 752},{416, 768},{432, 768},{432, 784},{448, 784},{448, 800},{464, 800},{464, 816},{480, 816},{480, 832},{496, 832},{496, 848},{512, 848},{512, 864},{528, 864},{528, 880},{544, 880},{560, 896},{576, 912},{592, 912},{592, 928},{608, 928},{608, 944},{624, 944},{624, 960}
,{640, 960},{640, 976},{656, 976},{656, 992},{672, 992},{672, 1008},{688, 1008},{704, 1024},{720, 1024},{720, 1040},{736, 1040},{736, 1056},{752, 1056},{752, 1072},{768, 1072},{768, 1088},{784, 1088},{800, 1088},{800, 1104},{816, 1104},{816, 1120},{832, 1120},{832, 1136}
,{848, 1136},{864, 1136},{864, 1152},{880, 1152},{864, 1152},{848, 1152},{848, 1136},{832, 1136},{816, 1136},{800, 1136},{800, 1120},{784, 1120},{768, 1120},{752, 1120},{736, 1120},{736, 1104},{720, 1104},{704, 1104},{688, 1104},{672, 1104},{656, 1088},{640, 1088}
,{624, 1088},{608, 1088},{592, 1088},{576, 1088},{576, 1072},{560, 1072},{544, 1072},{528, 1072},{512, 1072},{496, 1072},{480, 1072},{464, 1056},{448, 1056},{432, 1056},{416, 1056},{400, 1056},{384, 1056},{368, 1056},{352, 1056},{336, 1040},{320, 1040},{304, 1040}
,{288, 1040},{272, 1040},{272, 1024},{256, 1024},{240, 1024},{224, 1024},{208, 1024},{192, 1024},{192, 1008},{176, 1008},{160, 1008},{144, 1008},{128, 1008},{128, 992}}

S1 = CS_MoveCenter(Shape1078,0,0)
CSPlot(S1,P1,0,"Location 7",nil,1,32,P1) -- CSPlot으로 활용
S2 = CS_MoveCenter(ShapeC080,0,0) -- CAPlot으로 활용
CAPlot(S2,P2,1,"Location 19",nil,1,32,{1,0,0,0,1,0},nil,P1,nil,{KillUnit(1,P2)},1)
EndCtrig()

------------------------------------------------------------------------------------------

595

------------------------------------------------------------------------------------------

『 P. 썸네일 편집기 사용방법 』

------------------------------------------------------------------------------------------

｡˙+ﾟCS_Minimap v4.5 ｡+.ﾟ

썸네일 편집기 (CS_Minimap.exe) 사용법
썸네일 편집기는 맵의 미리보기 창에 입력된 사진을 유닛 데이터로 바꿔서 삽입함
썸네일 편집기 사용방법 (https://cafe.naver.com/marineraise/18399) :

1. 폴더 안에 CS_Minimap 파일과 맵, 사진 파일을 모두 넣는다
2. 포토샵으로 썸네일로 적용할 이미지를 불러온다 (여기선 1.jpg를 사용함)

3. 이미지 - 이미지크기 (Alt+Ctrl+I)를 눌러서 이미지 크기를 맵에 맞게 변경해준다. (1.scx 맵 크기는 256x256)
596

------------------------------------------------------------------------------------------

『 P. 썸네일 편집기 사용방법 』

-----------------------------------------------------------------------------------------※ 이미지 사이즈 규칙
1) 미니맵 크기 (맵의 가로크기와 세로크기 중 큰 것)를 확인한다
ex) 112 x 128 → 미니맵 크기 = 128
256 x 64 → 미니맵 크기 = 256
192 x 192 → 미니맵 크기 = 192

(미니맵 크기가 64 96 128 192 256중 하나가 아닐 경우 비정상 맵크기로 썸네일 사용불가)

2) 미니맵 크기가 64일 경우 썸네일 이미지 크기는 맵의 크기의 2배다
ex) 32 x 64 → 이미지 크기 = 64 x 128
64 x 12 → 이미지 크기 = 128 x 24
64 x 64 → 이미지 크기 = 128 x 128
3) 미니맵 크기가 96, 128일 경우 썸네일 이미지 크기는 맵의 크기의 1배다
ex) 112 x 128 → 이미지 크기 = 112 x 128
96 x 96 → 이미지 크기 = 96 x 96
4) 미니맵 크기가 192, 256일 경우 썸네일 이미지 크기는 맵의 크기의 1/2배다
ex) 256 x 256 → 이미지 크기 = 128 x 128
128 x 192 → 이미지 크기 = 64 x 96

4. 이미지 사이즈를 변경한 뒤 네비게이터 왼쪽 아래의 배율을 늘려서 이미지를 확대한다

597

------------------------------------------------------------------------------------------

『 P. 썸네일 편집기 사용방법 』

------------------------------------------------------------------------------------------

5. 이미지를 인덱스 색상에 맞게 적절하게 편집한 뒤 인덱스 컬러 (P13.ACT)를 씌운다.
(예시에서는 레벨 - 색조/채도 변화 - 부분 선택후 명도/대비 변화를 주었음)

6. 완성된 썸네일용 이미지를 다른이름으로 저장하고 확장자를 .BMP로 선택한다
(예시에서는 1.bmp로 저장함)
BMP 옵션창에서는 파일형식 Windows / 깊게 8비트 / 압축 및 행 순서 뒤집기는
체크 해제된 상태로 확인을 누른다.

598

------------------------------------------------------------------------------------------

『 P. 썸네일 편집기 사용방법 』

------------------------------------------------------------------------------------------

7. 썸네일을 삽입할 맵을 exe위로 드래그 앤 드롭 시킨다.
이후 드로잉모드에서 1(고화질) 입력후 엔터, 삽입할 이미지 파일이름을 입력후 엔터한다.

599

------------------------------------------------------------------------------------------

『 P. 썸네일 편집기 사용방법 』

-----------------------------------------------------------------------------------------8. 밝은 하늘색 색상 (미니맵에서 미네랄 또는 가스 표시 색상)을 그릴 때
사용할 가스통 유닛의 플레이어를 입력 (1 ~ 12중 입력,
썸네일을 삽입하는 맵에 해당 컬러가 있을 경우 시작시 그림 위치에 가스통이 그려지므로
반드시 맵 시작시 해당플레이어의 가스통을 지우는 트리거가 필요함)
9. 이미지가 잘리는 모서리의 방향을 설정 (1~4)
1(↘)선택시 ↘방향으로 모서리 일부가 잘림 (미니맵크기 64,96,128,192,256 1칸씩)
2(↙)선택시 ↙방향으로 모서리 일부가 잘림
(미니맵크기 64,96,128 : 왼쪽 3칸, 아래 1칸 / 192,256 1칸씩)
3(↗)선택시 ↗방향으로 모서리 일부가 잘림
(미니맵크기 64,96,128 : 오른쪽 1칸, 위쪽 3칸 / 192,256 1칸씩)
4(↖)선택시 ↖방향으로 모서리 일부가 잘림 (미니맵크기 64,96,128 : 3칸 / 192,256 3칸씩)
10. 다른색과 만나는 경계선에서 생성되는 그림자의 방향을 설정 (1~2)후 엔터

11. 그림자 제거 옵션을 선택 (1~3)
1) 그림자 완전 제거 : 그림을 유지하는 선에서 최대한 생성되는 그림자를 제거하는 옵션입니다

2) 그림자 마스크 적용 : 사용자가 원하는 부분만 그림자를 제거하는 옵션입니다
(부록A에서 설명함)
3) 그림자 제거 안함 : 생성되는 그림자를 건드리지 않습니다
12. 스타팅 복구 선택 (0 입력시 복구함)
: 복구를 선택하지 않을경우 사용자가 맵에 깔아둔 스타팅과 다른 위치에서 시작할 수 있습니다.

(센터뷰등 액션 필요, 복구 선택시 복구된 스타팅 위치가 썸네일 그림 위에 찍힘)
13. 추가로 삽입할 이미지가 없으면 0을 입력해 종료

600

------------------------------------------------------------------------------------------

『 P. 썸네일 편집기 사용방법 』

------------------------------------------------------------------------------------------

14. 입력한 맵 이름_out.scx로 썸네일이 삽입된 맵이 출력됨
(해당 맵을 EUDEditor로 추가로 컴파일하거나 비유디 맵의 경우 맵폴더에 넣어서 바로 실행 가능)

15. 맵에 썸네일이 적용된 모습 (맵 실행후 썸네일은 사라짐)
※ 해당 예제에서 사용된 이미지 파일은 CS_Example 폴더의 P-1.bmp 참고

601

------------------------------------------------------------------------------------------

『 P. 썸네일 편집기 사용방법 』

-----------------------------------------------------------------------------------------부록 A : 그림자 마스크 적용법

A-1. 그림자 마스크용 이미지를 생성하기위해 썸네일용 이미지와 동일한 크기로 이미지를 생성한다.

(파일 - 새로만들기 (Ctrl + N)으로 빈 이미지 생성, 배경 내용은 흰색을 선택)

A-2. 흰색 배경에 그림자를 남길 부분에 검정색을 칠해준다. (예시에서는 선택도구 - 칠을 사용함)

602

------------------------------------------------------------------------------------------

『 P. 썸네일 편집기 사용방법 』

------------------------------------------------------------------------------------------

A-3. 그림자 마스크 이미지에 인덱스 컬러 (P2.ACT)를 씌운다
A-4. 완성된 그림자 마스크 이미지를 다른이름으로 저장한뒤 확장자를 .BMP로 선택한다.
(BMP 옵션창에서는 파일형식 Windows / 깊게 8비트 / 압축 및 행 순서 뒤집기는
체크 해제된 상태로 확인을 누른다)

603

------------------------------------------------------------------------------------------

『 P. 썸네일 편집기 사용방법 』

------------------------------------------------------------------------------------------

A-5. 위에서 7번(썸네일 삽입할 맵을 드래그 앤 드롭)부터 순서대로 진행하되,
그림자 제거 옵션에서 2를 입력한다
A-6. 만든 그림자 마스크 이미지 파일의 이름을 입력한다 (예시에서는 1`.bmp)
A-7. 위에서 12번(스타팅 복구 옵션 선택)부터 순서대로 진행해서
썸네일이 적용된 맵을 맵폴더에 넣는다.

A-8. 그림자 마스크가 적용된 모습
(↖↘쪽만 그림자가 남는것을 확인할 수 있다)
※ 해당 예제에서 사용된 이미지 파일은
CS_Example 폴더의 P-2.bmp 참고

604

------------------------------------------------------------------------------------------

『 P. 썸네일 편집기 사용방법 』

-----------------------------------------------------------------------------------------부록 B : 검정색 사용법 (Black.png & P16.ACT)

B-1. 검정색 포함 이미지를 생성하기위해 썸네일용 이미지와 동일한 크기로 이미지를 생성한다

(파일 - 새로만들기 (Ctrl + N)으로 빈 이미지 생성, 배경 내용은 흰색을 선택)
(편집할 이미지를 불러와도 됨)

B-2. Black.png를 열어서 규칙에 맞게 검정(검정 세로선), 50%회색 (검정 가로선),
자주(검정 꼭짓점)을 칠한다.
(예시에서는 맵크기 256x256, 이미지가 잘리는 모서리 방향 ↘, 그림자 생성 방향 →을 선택함)
605

------------------------------------------------------------------------------------------

『 P. 썸네일 편집기 사용방법 』

------------------------------------------------------------------------------------------

검정색 (세로 검정색 - 표에서 검정색 타일에 해당)

50% 회색 (가로 검정색 - 표에서 회색 타일에 해당)

자주색 (#FF00FF : 꼭짓점 검정색 - 표애서 자주색 타일에 해당 (빨간색 타일이 자동으로 칠해짐))
606

------------------------------------------------------------------------------------------

『 P. 썸네일 편집기 사용방법 』

------------------------------------------------------------------------------------------

B-4. 이미지를 검정색 규칙에 맞게 적절하게 편집한 후 인덱스 컬러(P16.ACT)를 씌운다
B-5. 완성된 썸네일용 이미지를 다른이름으로 저장하고 확장자를 .BMP로 선택한다

(예시에서는 -1.bmp로 저장함)
BMP 옵션창에서는 파일형식 Windows / 깊게 8비트 / 압축 및 행 순서 뒤집기는
체크 해제된 상태로 확인을 누른다

607

------------------------------------------------------------------------------------------

『 P. 썸네일 편집기 사용방법 』

------------------------------------------------------------------------------------------

B-6. 위에서 7번(썸네일 삽입할 맵을 드래그 앤 드롭)부터 순서대로 진행하되,
검정색 작성 규칙에 선택했던 것과 동일한 모서리의 방향과 그림자의 방향을 선택한다
(예시에서는 ↘-→)

B-7. 검정색이 포함된 썸네일이 적용된 모습
※ 해당 예제에서 사용된 이미지 파일은 CS_Example 폴더의 P-3.bmp 참고

608

------------------------------------------------------------------------------------------

『 P. 썸네일 편집기 사용방법 』

-----------------------------------------------------------------------------------------부록 C : 투명색 사용법

C-1. 편집할 이미지를 불러옵니다 (예시에서는 위의 1.bmp를 불러옴)
C-2. 이미지 - 모드 - 색상표에서
인덱스 컬러 팔레트를 불러온 뒤
2번째줄 첫번째 컬러를 클릭해
#00FF00를 넣고 확인을 눌러
팔레트 17번째 색에 연두색을
추가한다.
(연두색이 아니더라도
기존 색상과 구분되는 컬러면 가능함)
(이제부터 17번째색인 연두색으로
색칠된 부분은 모두 투명으로 처리됨)

609

------------------------------------------------------------------------------------------

『 P. 썸네일 편집기 사용방법 』

------------------------------------------------------------------------------------------

C-3. 투명으로 칠하고 싶은 부분을 연두색으로 칠한다
C-4. 완성된 썸네일용 이미지를 다른이름으로 저장하고 확장자를 .BMP로 선택한다
(예시에서는 ~1.bmp로 저장함)
BMP 옵션창에서는 파일형식 Windows / 깊게 8비트 / 압축 및 행 순서 뒤집기는
체크 해제된 상태로 확인을 누른다

610

------------------------------------------------------------------------------------------

『 P. 썸네일 편집기 사용방법 』

------------------------------------------------------------------------------------------

C-5. 위에서 7번(썸네일 삽입할 맵을 드래그 앤 드롭)부터 순서대로 진행한다

C-6. 투명색이 포함된 썸네일이 적용된 모습 (투명색을 적용한 부분에는 맵 지형이 보인다)
※ 주의) 투명색 사용시 모서리방향과 그림자 방향에 따라서 투명색과 일반색의 경계부분에
일반색이 덧칠되는 방향이 결정됩니다 (예시에서는 ↘-→를 적용함)
※ 해당 예제에서 사용된 이미지 파일은 CS_Example 폴더의 P-4.bmp 참고

611

------------------------------------------------------------------------------------------

『 Q. 사진 변환기 사용방법 』

------------------------------------------------------------------------------------------

｡˙+ﾟCS_Photo v1.0 ｡+.ﾟ

사진변환기 (CS_Photo.exe) 사용법
사진변환기는 입력된 사진을 설정된 밝기 값에 맞춰 도형데이터로 변환함
사진변환기 사용방법 :
1. 도형 데이터로 변환할 사진을 포토샵으로 열어 편집한다. (이미지-모드-RGB색상 체크)
2. 편집 후 파일형식 .BMP → 24비트로 CS_Photo.exe가 있는 폴더에 저장한다.
3. 이미지 변환 모드에서 1입력후 엔터
4. 변환할 사진 파일의 이름을 입력후 엔터
5. 밝기 필터 허용값(0~255중 입력) 입력후 엔터
※ 밝기 필터 허용값은 해당 픽셀의 (R+G+B)/3 ≥ 허용값인 픽셀만 도형 데이터로 포함시킴
※ (입력한 사진 이름) : Total (도형 데이터의 점 수) Units Converted 형식으로 출력됨
6. 계속 사진을 Shape데이터로 변환할 경우 변환할 사진 파일의 이름을 입력후 엔터,
아닐경우 0을 입력후 엔터
7. (입력한 사진 이름)_out.txt에 변환된 Shape 데이터가 저장됨

※ (입력한 사진 이름)_preview.bmp로 해당 도형데이터 출력시의 모양을 미리 볼 수 있음
(흰색점이 출력시 찍히는 점, 검은색이 찍히지 않는 점)
8. 변환된 Shape데이터를 그대로 복사해서 코드에 붙여넣은 후 해당 도형데이터를 사용
※ 도형데이터는 사진파일의 맨 왼쪽위 꼭짓점을 (0,0) 원점으로 좌표값을 저장함
※ 점과 점 사이의 거리는 가로 세로 모두 1px로 저장됨

※ CS_Photo.exe 사용시 포토샵이 필요함 (버전 상관X) / Ex) [예제 Q-1] 참고
------------------------------------------------------------------------------------------------

※ 사진변환기 (CS_Photo.exe)의 2번째 이미지 변환모드(CGRP)는 CtrigAsm 29단원을 참고
612

------------------------------------------------------------------------------------------

『 Q. 사진 변환기 사용방법 』

-----------------------------------------------------------------------------------------[예제 Q-1] (CS_Photo-1 예제) 사진 파일 도형 데이터 출력 예제
(CB Paint 예제맵을 사용함, CS_Example 폴더 안의 Q-1.bmp를 CS_Photo.exe에 삽입)

SetForces({P1},{P2},{},{},{P1,P2})
SetFixedPlayer(P1)
StartCtrig(1,P1,0,1,맵 파일의 절대 경로 입력)
CJump(AllPlayers,0)
Include_CtrigPlib(360,"Switch 1")
CJumpEnd(AllPlayers,0)
NoAirCollisionX(P1)
DoActions(P1,{SetMemoryX(0x581D74,SetTo,0x75750000,0xFFFF0000)
,SetMemory(0x581D78,SetTo,0x75757575),SetMemoryX(0x581DD4,SetTo,0x750000,0xFF0000)})

-- Q-1_out.txt의 내용을 그대로 붙여넣음
Q1 = {944,{45, 7},{46, 7},{47, 7},{16, 8},{17, 8},{21, 8},{43, 8},{44, 8},{46, 8},{47, 8},{48, 8},{49, 8},{50, 8},{15, 9},{16, 9},{19, 9},{21, 9},{22, 9},{27, 9},{28, 9},{29, 9},{30, 9},{31, 9},{32, 9},{33, 9},{34, 9},{35, 9},{36, 9},{42, 9},{45, 9},{46, 9},{47, 9},{48, 9},{49, 9},{50, 9},{15, 10},{18, 10},
{19, 10},{20, 10},{22, 10},{23, 10},{24, 10},{25, 10},{26, 10},{27, 10},{28, 10},{30, 10},{31, 10},{32, 10},{33, 10},{34, 10},{35, 10},{36, 10},{37, 10},{40, 10},{41, 10},{42, 10},{43, 10},{44, 10},{45, 10},{46, 10},{47, 10},{50, 10},{15, 11},{18, 11},{19, 11},{20, 11},{21, 11},{22, 11},{23, 11},
{24, 11},{29, 11},{30, 11},{31, 11},{33, 11},{34, 11},{35, 11},{36, 11},{37, 11},{38, 11},{39, 11},{40, 11},{42, 11},{43, 11},{44, 11},{45, 11},{46, 11},{47, 11},{48, 11},{50, 11},{15, 12},{17, 12},{18, 12},{19, 12},{20, 12},{21, 12},{22, 12},{23, 12},{25, 12},{26, 12},{27, 12},{28, 12},{29, 12},
{30, 12},{33, 12},{35, 12},{36, 12},{37, 12},{38, 12},{42, 12},{43, 12},{44, 12},{45, 12},{46, 12},{47, 12},{48, 12},{51, 12},{14, 13},{15, 13},{18, 13},{19, 13},{20, 13},{21, 13},{22, 13},{23, 13},{24, 13},{25, 13},{32, 13},{33, 13},{41, 13},{42, 13},{43, 13},{44, 13},{45, 13},{46, 13},{47, 13},
{48, 13},{50, 13},{15, 14},{18, 14},{19, 14},{20, 14},{21, 14},{22, 14},{23, 14},{24, 14},{25, 14},{29, 14},{31, 14},{32, 14},{33, 14},{34, 14},{35, 14},{36, 14},{39, 14},{40, 14},{43, 14},{44, 14},{45, 14},{46, 14},{47, 14},{48, 14},{49, 14},{50, 14},{15, 15},{16, 15},{18, 15},{19, 15},{20, 15},
{21, 15},{22, 15},{24, 15},{25, 15},{26, 15},{27, 15},{28, 15},{29, 15},{31, 15},{32, 15},{33, 15},{36, 15},{37, 15},{40, 15},{44, 15},{45, 15},{46, 15},{47, 15},{48, 15},{49, 15},{50, 15},{16, 16},{19, 16},{20, 16},{21, 16},{22, 16},{25, 16},{26, 16},{27, 16},{31, 16},{32, 16},{33, 16},{34, 16},
{35, 16},{40, 16},{41, 16},{44, 16},{45, 16},{46, 16},{47, 16},{48, 16},{49, 16},{16, 17},{17, 17},{18, 17},{19, 17},{20, 17},{21, 17},{24, 17},{25, 17},{28, 17},{29, 17},{30, 17},{31, 17},{33, 17},{34, 17},{35, 17},{36, 17},{37, 17},{40, 17},{41, 17},{42, 17},{43, 17},{47, 17},{48, 17},{49, 17},
{17, 18},{18, 18},{19, 18},{22, 18},{23, 18},{24, 18},{25, 18},{27, 18},{28, 18},{29, 18},{33, 18},{36, 18},{37, 18},{41, 18},{43, 18},{44, 18},{48, 18},{49, 18},{50, 18},{16, 19},{17, 19},{18, 19},{21, 19},{22, 19},{24, 19},{31, 19},{32, 19},{33, 19},{34, 19},{41, 19},{42, 19},{44, 19},{45, 19},
{49, 19},{50, 19},{15, 20},{16, 20},{17, 20},{20, 20},{21, 20},{23, 20},{28, 20},{29, 20},{30, 20},{31, 20},{33, 20},{34, 20},{35, 20},{38, 20},{42, 20},{43, 20},{45, 20},{50, 20},{51, 20},{15, 21},{16, 21},{19, 21},{20, 21},{22, 21},{23, 21},{26, 21},{27, 21},{28, 21},{31, 21},{33, 21},{34, 21},
{37, 21},{38, 21},{39, 21},{42, 21},{43, 21},{46, 21},{47, 21},{51, 21},{15, 22},{18, 22},{19, 22},{22, 22},{23, 22},{26, 22},{30, 22},{31, 22},{32, 22},{33, 22},{34, 22},{35, 22},{37, 22},{41, 22},{42, 22},{45, 22},{47, 22},{48, 22},{51, 22},{52, 22},{14, 23},{15, 23},{18, 23},{19, 23},{23, 23},
{24, 23},{25, 23},{29, 23},{30, 23},{31, 23},{34, 23},{35, 23},{38, 23},{39, 23},{40, 23},{41, 23},{42, 23},{45, 23},{47, 23},{48, 23},{52, 23},{14, 24},{17, 24},{18, 24},{20, 24},{22, 24},{23, 24},{25, 24},{26, 24},{27, 24},{29, 24},{30, 24},{35, 24},{38, 24},{42, 24},{43, 24},{45, 24},{46, 24},
{48, 24},{17, 25},{19, 25},{20, 25},{22, 25},{23, 25},{41, 25},{42, 25},{43, 25},{45, 25},{46, 25},{48, 25},{49, 25},{16, 26},{17, 26},{19, 26},{20, 26},{22, 26},{24, 26},{25, 26},{26, 26},{27, 26},{37, 26},{38, 26},{39, 26},{40, 26},{41, 26},{43, 26},{46, 26},{48, 26},{49, 26},{53, 26},{54, 26},
{16, 27},{17, 27},{19, 27},{22, 27},{23, 27},{24, 27},{25, 27},{26, 27},{27, 27},{37, 27},{38, 27},{39, 27},{40, 27},{41, 27},{42, 27},{43, 27},{46, 27},{49, 27},{54, 27},{13, 28},{16, 28},{19, 28},{22, 28},{24, 28},{25, 28},{26, 28},{27, 28},{28, 28},{36, 28},{37, 28},{38, 28},{39, 28},{40, 28},
{41, 28},{43, 28},{46, 28},{49, 28},{54, 28},{55, 28},{12, 29},{13, 29},{16, 29},{19, 29},{22, 29},{25, 29},{27, 29},{28, 29},{36, 29},{37, 29},{40, 29},{43, 29},{46, 29},{49, 29},{52, 29},{55, 29},{12, 30},{15, 30},{16, 30},{19, 30},{23, 30},{25, 30},{28, 30},{36, 30},{42, 30},{46, 30},{49, 30},
{50, 30},{52, 30},{55, 30},{12, 31},{15, 31},{16, 31},{19, 31},{23, 31},{28, 31},{36, 31},{41, 31},{42, 31},{46, 31},{49, 31},{52, 31},{55, 31},{12, 32},{15, 32},{16, 32},{19, 32},{20, 32},{24, 32},{28, 32},{40, 32},{41, 32},{45, 32},{46, 32},{49, 32},{52, 32},{55, 32},{12, 33},{13, 33},{15, 33},
{16, 33},{17, 33},{19, 33},{20, 33},{21, 33},{22, 33},{23, 33},{24, 33},{25, 33},{39, 33},{42, 33},{44, 33},{45, 33},{46, 33},{48, 33},{49, 33},{52, 33},{53, 33},{55, 33},{56, 33},{12, 34},{16, 34},{17, 34},{19, 34},{20, 34},{21, 34},{22, 34},{25, 34},{40, 34},{41, 34},{43, 34},{44, 34},{45, 34},
{46, 34},{48, 34},{49, 34},{52, 34},{53, 34},{55, 34},{56, 34},{11, 35},{12, 35},{16, 35},{17, 35},{18, 35},{20, 35},{21, 35},{23, 35},{24, 35},{28, 35},{29, 35},{35, 35},{36, 35},{41, 35},{42, 35},{45, 35},{47, 35},{48, 35},{49, 35},{52, 35},{53, 35},{56, 35},{11, 36},{12, 36},{16, 36},{17, 36},
{18, 36},{21, 36},{22, 36},{23, 36},{28, 36},{36, 36},{42, 36},{44, 36},{47, 36},{48, 36},{49, 36},{52, 36},{56, 36},{11, 37},{12, 37},{13, 37},{16, 37},{17, 37},{18, 37},{19, 37},{22, 37},{28, 37},{43, 37},{44, 37},{45, 37},{46, 37},{47, 37},{48, 37},{49, 37},{52, 37},{56, 37},{11, 38},{12, 38},
{13, 38},{17, 38},{18, 38},{19, 38},{21, 38},{22, 38},{43, 38},{44, 38},{45, 38},{46, 38},{47, 38},{48, 38},{52, 38},{53, 38},{56, 38},{57, 38},{10, 39},{11, 39},{12, 39},{13, 39},{17, 39},{18, 39},{19, 39},{20, 39},{21, 39},{22, 39},{23, 39},{25, 39},{28, 39},{29, 39},{35, 39},{36, 39},{39, 39},
{42, 39},{43, 39},{44, 39},{46, 39},{47, 39},{52, 39},{55, 39},{56, 39},{57, 39},{9, 40},{10, 40},{11, 40},{12, 40},{13, 40},{18, 40},{19, 40},{20, 40},{22, 40},{23, 40},{26, 40},{29, 40},{30, 40},{31, 40},{32, 40},{34, 40},{35, 40},{39, 40},{40, 40},{42, 40},{43, 40},{46, 40},{51, 40},{52, 40},
{55, 40},{56, 40},{57, 40},{8, 41},{9, 41},{13, 41},{14, 41},{19, 41},{20, 41},{22, 41},{23, 41},{25, 41},{26, 41},{30, 41},{31, 41},{34, 41},{42, 41},{43, 41},{51, 41},{52, 41},{55, 41},{56, 41},{57, 41},{7, 42},{8, 42},{13, 42},{14, 42},{15, 42},{16, 42},{23, 42},{24, 42},{25, 42},{26, 42},{31, 42},
{32, 42},{33, 42},{37, 42},{38, 42},{39, 42},{42, 42},{43, 42},{49, 42},{50, 42},{51, 42},{55, 42},{56, 42},{57, 42},{5, 43},{6, 43},{7, 43},{14, 43},{15, 43},{16, 43},{17, 43},{18, 43},{19, 43},{23, 43},{24, 43},{27, 43},{28, 43},{29, 43},{32, 43},{36, 43},{37, 43},{38, 43},{40, 43},{41, 43},
{42, 43},{48, 43},{49, 43},{50, 43},{54, 43},{55, 43},{56, 43},{57, 43},{58, 43},{4, 44},{5, 44},{15, 44},{16, 44},{17, 44},{18, 44},{19, 44},{20, 44},{24, 44},{25, 44},{26, 44},{27, 44},{28, 44},{29, 44},{30, 44},{31, 44},{32, 44},{33, 44},{34, 44},{35, 44},{37, 44},{38, 44},{39, 44},{40, 44},
{41, 44},{42, 44},{45, 44},{46, 44},{47, 44},{48, 44},{49, 44},{54, 44},{55, 44},{56, 44},{58, 44},{59, 44},{3, 45},{4, 45},{16, 45},{17, 45},{18, 45},{19, 45},{20, 45},{21, 45},{24, 45},{25, 45},{26, 45},{27, 45},{28, 45},{31, 45},{32, 45},{33, 45},{34, 45},{36, 45},{37, 45},{38, 45},{39, 45},
{40, 45},{41, 45},{42, 45},{43, 45},{44, 45},{45, 45},{46, 45},{47, 45},{48, 45},{53, 45},{54, 45},{55, 45},{56, 45},{59, 45},{15, 46},{16, 46},{17, 46},{19, 46},{20, 46},{21, 46},{22, 46},{23, 46},{24, 46},{25, 46},{26, 46},{38, 46},{39, 46},{40, 46},{41, 46},{42, 46},{43, 46},{44, 46},{45, 46},
{46, 46},{52, 46},{53, 46},{54, 46},{55, 46},{58, 46},{59, 46},{15, 47},{20, 47},{21, 47},{22, 47},{23, 47},{24, 47},{25, 47},{26, 47},{27, 47},{38, 47},{39, 47},{40, 47},{41, 47},{42, 47},{43, 47},{44, 47},{45, 47},{51, 47},{52, 47},{53, 47},{54, 47},{55, 47},{58, 47},{59, 47},{60, 47},{22, 48},
{23, 48},{24, 48},{25, 48},{26, 48},{27, 48},{28, 48},{37, 48},{38, 48},{39, 48},{40, 48},{41, 48},{42, 48},{43, 48},{44, 48},{50, 48},{51, 48},{52, 48},{53, 48},{54, 48},{57, 48},{58, 48},{59, 48},{60, 48},{23, 49},{24, 49},{25, 49},{26, 49},{27, 49},{28, 49},{29, 49},{30, 49},{35, 49},{36, 49},
{37, 49},{38, 49},{39, 49},{41, 49},{42, 49},{50, 49},{51, 49},{52, 49},{53, 49},{57, 49},{59, 49},{60, 49},{24, 50},{25, 50},{26, 50},{29, 50},{30, 50},{31, 50},{32, 50},{33, 50},{34, 50},{35, 50},{36, 50},{37, 50},{49, 50},{50, 50},{51, 50},{52, 50},{56, 50},{25, 51},{26, 51},{34, 51},{35, 51},
{36, 51},{49, 51},{50, 51},{51, 51},{26, 52},{27, 52},{48, 52},{49, 52},{27, 53},{28, 53},{47, 53},{48, 53},{28, 54},{46, 54},{47, 54}}

S1 = CS_MoveCenter(Q1,0,0)
S1 = CS_RatioXY(S1,64,64)
CSPlot(S1,P1,0,"Location 13",nil,1,32,P1) -- CSPlot으로 활용
TriggerX(P1,ElapsedTime(Exactly,10),KillUnit(0,P1))
Delay = CreateVar(P1)
function funcXY(X,Y)
return {math.abs(X+Y)+math.abs(X-Y)}
end
S2, TS2 = CS_TSortXY(S1,nil,48,0,"funcXY",0,1) -- CBPlot으로 활용
CBPlot(S2,TS2,P1,1,"Location 13",nil,1,32,{1,0,3,0,1,0},nil,nil,P1
,{ElapsedTime(AtLeast,11),NVar(Delay,Exactly,0)},nil,{SetNVar(Delay,SetTo,24)})
TriggerX(P1,NVar(Delay,Exactly,1),KillUnit(1,P1),{Preserved})
DoActionsX(P1,SetNVar(Delay,Subtract,1))
EndCtrig()
------------------------------------------------------------------------------------------

613

------------------------------------------------------------------------------------------

『 R. Visual Studio 연계법 』

------------------------------------------------------------------------------------------

｡˙+ﾟVisual Studio Code｡+.ﾟ

Visual Studio Code 연계방법
VSCode로 코드를 편집함으로써 하이라이터, 자동완성, 파일분할, 코드저장 등을 사용 가능함

1. VSCode를 설치한다. (https://code.visualstudio.com 에서 download를 클릭)

2. 보기 - 확장을 눌러 확장 마켓플레이스를 연 후 lua를 검색한 뒤
맨 위의 Lua (sumneko)를 클릭해서 루아 확장프로그램을 설치한다.
614

------------------------------------------------------------------------------------------

『 R. Visual Studio 연계법 』

------------------------------------------------------------------------------------------

3. 설치된 루아 확장 프로그램에서 톱니바퀴 아이콘을 누른 후 확장설정을 클릭한다.

4. 루아 확장 프로그램 설정에서 아래의 4-1, 4-2, 4-3, 4-4, 4-5 항목을 설정한다.

4-1. View String Max 수치를 충분히 늘린다. (어셈블러 수치만큼 늘려도 됨)

615

------------------------------------------------------------------------------------------

『 R. Visual Studio 연계법 』

------------------------------------------------------------------------------------------

4-2. Max Preload, Preload File Size를 각각 충분히 늘린다.
(어셈블러 파일 사이즈만큼 늘려도 됨)

4-3. Library에 항목추가 버튼을 눌러
1. SCMdraft 설치경로 → lua폴더의 주소
2. CtrigAsm v5.4에 있는 BaseScript 폴더의 주소를 추가한다. (다른곳에 옮기기 가능)
(BaseScript폴더를 lua폴더 내부에 복사하면 안됨, SCMdraft 폴더에 복사하는 것을 권장함)

※ 폴더의 주소는 윈도우 탐색기의 주소부분을 클릭 후 드래그해서 복사하면 됨

616

------------------------------------------------------------------------------------------

『 R. Visual Studio 연계법 』

------------------------------------------------------------------------------------------

4-4. 왼쪽 하단의 톱니바퀴 버튼을 누르고 설정을 클릭한다.

상단의 설정 검색칸에 encodin을 입력한 후 Files: Encoding에서 Korean (EUC-KR)을
선택한다. (기본 언어 인코딩 옵션을 cp949로 변경함)
※ 주의 : 이 설정을 적용하지 않는 경우 VSCode에 작성하는 모든 스트링은
utf8형식으로 인코딩 되며, 스트링 관련 함수 사용시 제대로 작동이 안될 수 있음
(어셈블러에서 스트링 인코딩은 Cp949를 기준으로 함)
※ 주의 : 메모장 등의 다른 프로그램으로 Main.lua나 분할된 코드를 작성하는 경우
해당 편집 프로그램의 인코딩타입이 cp949가 아닌경우 VSCode에 불러왔을때
한글이나 특수문자 등이 깨진상태로 표시될 수도 있음 (VSCode에서 편집을 권장함)

617

------------------------------------------------------------------------------------------

『 R. Visual Studio 연계법 』

------------------------------------------------------------------------------------------

4-5 (선택). Call Snippet에서 옵션을 Replace로 변경한다.
※ Replace로 변경할 경우 함수의 인자가 위 사진처럼 인자 : any로 자동 생성됨
5. LoaderX.lua를 SCMDraft 설치 폴더에 복사한다.
6. 원하는 곳에 맵의 코드를 저장할 폴더를 생성하고 그 폴더 안에 Main.lua 파일을 생성한다.

(Main.lua에 해당 맵의 트리거 영역에 넣을 코드를 작성하면 됨)
7. 파일 - 작업영역에 폴더 추가를 누른 후 불러올 맵의 코드가 들어있는 폴더를 선택

8. 왼쪽 맨 위의 아이콘 (탐색기)를 누르면 현재 로드된 작업영역이 표시됨
(여기서 Main.lua를 클릭해서 오른쪽 편집창에 Main.lua를 불러올 수 있음)
※ Main.lua 작성시 SCMdraft의 lua폴더 내부에 있는 플러그인 파일이나
맵 코드 폴더 내부에 있는 lua파일 내부에 있는 함수와 변수들은 모두 자동완성됨

618

------------------------------------------------------------------------------------------

『 R. Visual Studio 연계법 』

-----------------------------------------------------------------------------------------9. Main.lua를 넣을 맵을 열어 Tep v2.0 맨 위에 다음 코드를 붙여넣는다.
(Curdir : Scmdraft2 설치 폴더의 경로에서 \를 \\로 바꾼 뒤 주소 입력칸에 붙여넣는다,
Subdir : Main.lua가 있는 폴더의 경로에서 \를 \\로 바꾼 뒤 주소 입력칸에 붙여넣는다)

Curdir="SCMDraft 설치경로 (\를 \\로 바꿔야함)"
Subdir="Main.lua 폴더경로 (\를 \\로 바꿔야함)"
Dofile(Curdir.."/LoaderX.lua") Dofile(Subdir.."/Main.lua")
10. 파일 - 작업영역을 다른이름으로 저장을 눌러 현재까지의 작업 영역을 저장한다.
※ 여기까지 모두 진행했다면, 맵의 트리거를 수정할 때 Main.lua를 VSCode에서 편집 후
Main.lua파일을 저장하고, Tep 2.0에서 컴파일만 시키면 되게끔 설정되어 있을 것이다.
----------------------------------------------------------------------------------------------------부록A : 코드 파일 분할법 (Main.lua 분할 작성방법)
A-1. Main.lua가 있는 폴더에 (원하는 파일명).lua로 서브 코드 파일을 만든다.
(여기서는 Sub.lua로 만들었다고 가정)
A-2. Sub.lua에 Main.lua에서 분할할 코드를 복사하고
맨 위에 function (분할된 코드를 불러올 함수명)()
맨 아래에 end를 입력 후 저장한다.
Ex) function Sub1() (분할된 코드 내용) end 형식으로 Sub.lua저장
※ 분할된 코드는 항상 함수 형태로 저장되어야 하며,
Main.lua에서 해당 함수를 사용 함으로써 분할된 해당 코드를 그 자리에 불러옴
A-3. 분할된 코드를 불러올 위치에 A-2에서 만들었던 함수를 사용한다.
Ex) Main.lua의 Sub.lua를 불러올 위치에서 Sub1()을 입력
A-4. Tep 2.0에서 컴파일시 성공적으로 분할된 코드까지 포함해서 컴파일 완료됨
※ 이렇게 만들어진 분할 코드들과 Main.lua는 서로 같은 자동완성 라이브러리를 공유함
(Main.lua에서 만들어진 함수와 변수 → Sub.lua에서 자동완성됨,
Sub.lua에서 만들어진 함수와 변수 → Main.lua에서 자동완성됨)
※ 코드 파일 분할시 분할된 코드파일은 반드시 적용할 맵 코드 폴더에 저장해야함
619
-----------------------------------------------------------------------------------------------------

------------------------------------------------------------------------------------------

『 R. Visual Studio 연계법 』

-----------------------------------------------------------------------------------------부록B : 작업 영역에 다중 맵 파일 코드 로드 방법
B-1. 원하는 곳에 다른 맵의 코드를 저장할 폴더를 생성하고 그 폴더 안에 Main.lua 파일을 생성한다.

B-2. 파일 - 작업영역에 폴더추가를 눌러 B-1에서 만든 폴더를 선택한다.
B-3. VSCode의 탐색기에서 해당 폴더의 코드를 눌러 코드를 편집한다.
※ 서로 다른 맵 폴더의 코드끼리는 해당 코드에서 정의한 함수나 변수들이
서로 등록되지 않으며, 자동완성에도 포함되지 않음
B-4. VS연계법 설명서 9번부터 반복한다.
----------------------------------------------------------------------------------------------------부록C : Tep v2.0 트리거 개수 제한 해제법 (Loader2X.lua 사용방법)
VS연계법 설명서 9번에서 다음코드를 Tep v2.0에 대신 붙여넣는다.
Curdir="Scmdraft 설치경로(\를 \\로 바꿔야함)"
Subdir="Main.lua 폴더경로 (\를 \\로 바꿔야함)"
Mapdir="맵파일 경로(\를 \\로 바꿔야함)".."\\".."맵파일 이름(.scx 제외)"
__StringArray = {} __UPUSCheckArray = {}

__TRIGChkptr = io.open(Mapdir.."__TRIG.chk", "wb")
Dofile(Curdir.."/Loader2X.lua") Dofile(Subdir.."/Main.lua")
__PopStringArray()
io.close(__TRIGchkptr)
사용방법은 Loader2.lua와 모두 동일하며, STRCtrig와 euddraft 0.9.5.3이상 버전을 사용해야함

-----------------------------------------------------------------------------------------------------

620

