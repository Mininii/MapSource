P1=0
P2=1
P3=2
P4=3
P5=4
P6=5
P7=6
P8=7
P9=8
P10=9
P11=10
P12=11

CSetTo = 10
CAdd = 11
CSubtract = 12
AtLeast = 0
AtMost = 1
Exactly = 10
SetTo = 7
Add = 8
Subtract = 9

Above = 2
Below = 3
NotSame = 9

-- STR(X) ptr 고정 0x191943c8 --
-- TBL ptr 고정 0x19184660 --

CtrigInitArr = {}
for i = 1, 8 do
	CtrigInitArr[i] = {}
end

CJumpArr = {}
CJumpEndArr = {}
NJumpArr = {}
NJumpEndArr = {}
CIfArr = {}
CIfPArr = {}
CIfptr = 0
NIfArr = {}
NIfPArr = {}
NIfptr = 0
CWhileArr = {}
CWhilePArr = {}
CWhileptr = 0
NWhileArr = {}
NWhilePArr = {}
NWhileptr = 0
DWhileArr = {}
DWhilePArr = {}
DWhileptr = 0
CForArr = {}
CForPArr = {}
CForStep = {}
CForptr = 0
NIfXArr = {}
NIfXPArr = {}
NIfXptr = 0
CIfXArr = {}
CIfXPArr = {}
CIfXptr = 0
CWhileXArr = {}
CWhileXPArr = {}
CWhileXptr = 0
NWhileXArr = {}
NWhileXPArr = {}
NWhileXptr = 0
SLoopNArr = {}
SLoopNPArr = {}
SLoopNptr = 0
SLoopNVArr = {}
SLoopNCount = 0
IndexAlloc = 0xC000 -- 0xC000 ~ 0xEFFF : If, While / 0xA000 ~ 0xBFFF : Jump
FuncAlloc = 0x1D000 -- 0x1D000 ~ 0x1FFFF : CMul, CDiv, CMod / CtrigFunc
VarXAlloc = 0xFE00 --  0xFE00 ~ 0xFFEF : Temp CVariable Alloc 
MAXVAlloc = 0xFE00
VarXReleaseLock = 0

WarXAlloc = 0xFC00 --  0xFC00 ~ 0xFDEF : Temp CWariable Alloc 
MAXWAlloc = 0xFC00

SVarXOrig = {0xF400,0xF480,0xF500,0xF580,0xF600,0xF680,0xF700,0xF780,0xF800,0xF880,0xF900,0xF980,0xFA00,0xFA80,0xFB00,0xFB80} 
SVarXAlloc = {0xF400,0xF480,0xF500,0xF580,0xF600,0xF680,0xF700,0xF780,0xF800,0xF880,0xF900,0xF980,0xFA00,0xFA80,0xFB00,0xFB80} --  0xF400 ~ 0xFBFF : Temp CSVariable Alloc[1~16] 
MAXSVAlloc = {0xF400,0xF480,0xF500,0xF580,0xF600,0xF680,0xF700,0xF780,0xF800,0xF880,0xF900,0xF980,0xFA00,0xFA80,0xFB00,0xFB80}

LabelArr = {}

CRet = {0xFFF1,0xFFF2,0xFFF3,0xFFF4,0xFFF5,0xFFF6,0xFFF7,0xFFF8,0xFFF9,0xFFFA}
NRet = {0xFFE1,0xFFE2,0xFFE3,0xFFE4,0xFFE5,0xFFE6,0xFFE7,0xFFE8,0xFFE9,0xFFEA,0xFFEB,0xFFEC,0xFFED,0xFFEE,0xFFEF,0xFFF0}
WRet = {0xFDF0,0xFDF1,0xFDF2,0xFDF3,0xFDF4,0xFDF5,0xFDF6,0xFDF7,0xFDF8,0xFDF9,0xFDFA,0xFDFB,0xFDFC,0xFDFD,0xFDFE,0xFDFF}
SRet = {{0xF47C,0xF47D,0xF47E,0xF47F},{0xF4FC,0xF4FD,0xF4FE,0xF4FF},{0xF57C,0xF57D,0xF57E,0xF57F},{0xF5FC,0xF5FD,0xF5FE,0xF5FF},
		{0xF67C,0xF67D,0xF67E,0xF67F},{0xF6FC,0xF6FD,0xF6FE,0xF6FF},{0xF77C,0xF77D,0xF77E,0xF77F},{0xF7FC,0xF7FD,0xF7FE,0xF7FF},
		{0xF87C,0xF87D,0xF87E,0xF87F},{0xF8FC,0xF8FD,0xF8FE,0xF8FF},{0xF97C,0xF97D,0xF97E,0xF97F},{0xF9FC,0xF9FD,0xF9FE,0xF9FF},
		{0xFA7C,0xFA7D,0xFA7E,0xFA7F},{0xFAFC,0xFAFD,0xFAFE,0xFAFF},{0xFB7C,0xFB7D,0xFB7E,0xFB7F},{0xFBFC,0xFBFD,0xFBFE,0xFBFF}}
ForwardPoint = {}

PushTrigArr = {}
PushTrigStack = 0
PushCondArr = {}
PushCondStack = {}
PushActArr = {}
PushActStack = {}
CondStackCount = 0
StackArrptr = 0
CondLineArr = {}
ActLineArr = {}

FlagAlloc = 0 -- 0xFFF1 ~ 0xFFFA 의 CDeaths Code (0x0000FFF1 ~ 0x01DFFFFA)

EUDORPlayer = 0
EUDORFlag = 0

TTFCodeArr = {}
TTModeArr = {}
TTPushTrigArr = {}
TTPushCondArr = {}

TTPopTrigLock = 0
TPopTrigLock = 0

ORPushCondArr = {}
ORFCodeArr = {}
ORPopTrigLock = 0

_TPushCondArr = {}
_TFCodeArr = {}
_TPopTrigLock = 0
_TPushVarXAlloc = {}
_TPopPlayerIDArr = {}

STPushTrigArr = {}
STPopTrigLock = 0
RecoverCpValue = "X"
MoveCpValue = 0
CCArr = {}
CCPArr = {}
CCptr = 0

CForce1 = {0,0,0,0,0,0,0,0}
CForce2 = {0,0,0,0,0,0,0,0}
CForce3 = {0,0,0,0,0,0,0,0}
CForce4 = {0,0,0,0,0,0,0,0}
CAllPlayers = {0,0,0,0,0,0,0,0}
Force5 = "Force5"
EveryPlayers = "EveryPlayers"

VoidAreaOffset = 0x58F500
VoidAreaAlloc = 0x58F500-4
StringKeyArr = {}
DetectRecoverCp = 0

CreateVarInitIndex = 0x18000
CreateVarXAlloc = 0x18000-1
CreateMaxVAlloc = 0x19FFF 
CreateVarPArr = {}

CreateCCodeVarXAlloc = 0x19F00
CreateNCodeVarXAlloc = 0x19A00
CreateCCodeAlloc = 0
CreateNCodeAlloc = 0

-- 맵 정보 입력 관련 함수 ---------------------------------------------------------------

function SetFixedPlayer(PlayerID)
	FixPlayer = PlayerID
end

function SetForces(defForce1,defForce2,defForce3,defForce4,defAllPlayers)
	for k, P in pairs(defForce1) do
		CForce1[P+1] = 1
	end

	for k, P in pairs(defForce2) do
		CForce2[P+1] = 1
	end

	for k, P in pairs(defForce3) do
		CForce3[P+1] = 1
	end

	for k, P in pairs(defForce4) do
		CForce4[P+1] = 1
	end

	for k, P in pairs(defAllPlayers) do
		CAllPlayers[P+1] = 1
	end
end

function PlayerConvert(PlayerID)
	local Temp = {}
	if type(PlayerID) == "number" or PlayerID == Force1 or PlayerID == Force2 or PlayerID == Force3 or PlayerID == Force4 or PlayerID == AllPlayers then
		PlayerID = {PlayerID}
	end
	
	local Input = {0,0,0,0,0,0,0,0}

	for k, P in pairs(PlayerID) do
		if P == Force1 then
			for i, v in pairs(CForce1) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == Force2 then
			for i, v in pairs(CForce2) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == Force3 then
			for i, v in pairs(CForce3) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == Force4 then
			for i, v in pairs(CForce4) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == AllPlayers then
			for i, v in pairs(CAllPlayers) do
				if v == 1 then
					Input[i] = 1
				end
			end
		else 
			Input[P+1] = 1
		end
	end

	for i = 1, 8 do
		if Input[i] == 1 then
			table.insert(Temp,i-1)
		end
	end

	return Temp
end

function PlayerConvertX(PlayerID)
	local Temp = {}
	if type(PlayerID) == "number" or PlayerID == Force1 or PlayerID == Force2 or PlayerID == Force3 or PlayerID == Force4 or PlayerID == AllPlayers then
		PlayerID = {PlayerID}
	end
	if PlayerID == Force5 then
		PlayerID = {P9,P10,P11,P12}
	end
	if PlayerID == EveryPlayers then
		PlayerID = {AllPlayers,P9,P10,P11,P12}
	end
 	
	local Input = {0,0,0,0,0,0,0,0,0,0,0,0}

	for k, P in pairs(PlayerID) do
		if P == Force1 then
			for i, v in pairs(CForce1) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == Force2 then
			for i, v in pairs(CForce2) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == Force3 then
			for i, v in pairs(CForce3) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == Force4 then
			for i, v in pairs(CForce4) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == AllPlayers then
			for i, v in pairs(CAllPlayers) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == Force5 then
			Input[9] = 1
			Input[10] = 1
			Input[11] = 1
			Input[12] = 1
		elseif P == EveryPlayers then
			for i, v in pairs(CAllPlayers) do
				if v == 1 then
					Input[i] = 1
				end
			end
			Input[9] = 1
			Input[10] = 1
			Input[11] = 1
			Input[12] = 1
		else 
			Input[P+1] = 1
		end
	end

	for i = 1, 8 do
		if Input[i] == 1 then
			table.insert(Temp,i-1)
		end
	end
	for i = 9, 12 do
		if Input[i] == 1 then
			table.insert(Temp,i-9+128)
		end
	end

	return Temp
end

-- CtrigAsm 표준 환경 설치 함수 ---------------------------------------------------------

function StartCtrig()
	Trigger {
		players = {AllPlayers},
		conditions = {
			Label(0xFFFB);
		},
		actions = {
			SetNext(0xFFFB,0xFFFC);
		},
	}
	for j = 1, 16 do
		for i = 1, 4 do
			CSVariable(AllPlayers,SRet[j][i],j)
		end
	end
	for i = 0, 15 do -- WRet
		CWariable(AllPlayers,0xFDF0 + i)
	end
	for i = 1, 16 do -- NRet
		CVariable(AllPlayers,0xFFE0 + i)
	end
	for i = 1, 10 do -- CRet
		CVariable(AllPlayers,0xFFF0 + i)
	end
	Trigger {
		players = {AllPlayers},
		conditions = {
			Label(0xFFFC);
		},
		actions = {
			SetNext(0xFFFC,0xFFFD);
		},
	}
end

function EndCtrig()
	Trigger {
		players = {AllPlayers},
		conditions = { 
			Label(0xFFFD);
		},
		actions = {
		},
	}
	InitCtrig()
	Trigger {
		players = {AllPlayers},
		conditions = {
			Label(0xFFFE);
		},
		actions = {
			SetNext(0xFFFC,0xFFFC,1);
			SetNext(0xFFFD,0xFFFE);
			SetNext(0xFFFE,0xFFFF);
		},
	}
	for i = CreateVarInitIndex, CreateVarXAlloc do
		local k = i - CreateVarInitIndex+1
		if CreateVarPArr[k][1] == "V" then
			 CVariable(CreateVarPArr[k][2],i)
		elseif CreateVarPArr[k][1] == "V2" then
			if type(CreateVarPArr[k][5]) == "table" then
				CVariable3(CreateVarPArr[k][2],i,CreateVarPArr[k][3],CreateVarPArr[k][4],CreateVarPArr[k][5][1],CreateVarPArr[k][5][2],CreateVarPArr[k][5][3],CreateVarPArr[k][5][4],CreateVarPArr[k][5][5],CreateVarPArr[k][6])
			else
			CVariable2(CreateVarPArr[k][2],i,CreateVarPArr[k][3],CreateVarPArr[k][4],CreateVarPArr[k][5],CreateVarPArr[k][6])
			end
		elseif CreateVarPArr[k][1] == "W" then
			CWariable(CreateVarPArr[k][2],i)
		elseif CreateVarPArr[k][1] == "W2" then
			CWariable2(CreateVarPArr[k][2],i,CreateVarPArr[k][3],CreateVarPArr[k][4],CreateVarPArr[k][5],CreateVarPArr[k][6])
		elseif CreateVarPArr[k][1] == "SV" then
			CSVariable(CreateVarPArr[k][2],i,CreateVarPArr[k][3])
		elseif CreateVarPArr[k][1] == "SV2" then
			CSVariable2(CreateVarPArr[k][2],i,CreateVarPArr[k][3],CreateVarPArr[k][4],CreateVarPArr[k][5],CreateVarPArr[k][6],CreateVarPArr[k][7])
		elseif CreateVarPArr[k][1] == "VA" then
			Trigger {
				players = {ParsePlayer(CreateVarPArr[k][2])},
				conditions = {
					Label(i);
				},
				actions = {
					SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
			for i = 2, CreateVarPArr[k][3] do 
				Trigger {
					players = {ParsePlayer(CreateVarPArr[k][2])},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
						Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
					},
					flag = {Preserved}
				}
			end
		elseif CreateVarPArr[k][1] == "WA" then
			Trigger {
				players = {ParsePlayer(CreateVarPArr[k][2])},
				conditions = {
					Label(i);
				},
				actions = {
					SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
					Disabled(SetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)); -- Cp Add (Must be Preserved)
					SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
			for i = 2, CreateVarPArr[k][3] do 
				Trigger {
					players = {ParsePlayer(CreateVarPArr[k][2])},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
						Disabled(SetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)); -- Cp Add (Must be Preserved)
						SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
						Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
					},
					flag = {Preserved}
				}
			end
		elseif CreateVarPArr[k][1] == "SVA" then
			if CreateVarPArr[k][4] <= 0 or CreateVarPArr[k][4] >= 17 then
				SVariable_InputData_Error()
			end
			local Box = {}
			for i = 2, CreateVarPArr[k][4] do
				table.insert(Box,Disabled(SetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)))
				table.insert(Box,SetDeathsX(0,SetTo,0,0,0xFFFFFFFF))
			end
			Trigger {
				players = {ParsePlayer(CreateVarPArr[k][2])},
				conditions = {
					Label(i);
				},
				actions = {
					SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); 
					Box,
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
			for i = 2, CreateVarPArr[k][3] do 
				Trigger {
					players = {ParsePlayer(CreateVarPArr[k][2])},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); 
						Box,
						Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
					},
					flag = {Preserved}
				}
			end
		elseif CreateVarPArr[k][1] == "A" then
			local TNum = CreateVarPArr[k][3]/602
			if  CreateVarPArr[k][3]%602 ~= 0 then
				TNum = TNum + 1
			end
			Trigger {
				players = {ParsePlayer(CreateVarPArr[k][2])},
				conditions = {
					Label(i);
				},
				flag = {Preserved}
			}
			for i = 2, TNum do 
				Trigger {
					players = {ParsePlayer(CreateVarPArr[k][2])},
					flag = {Preserved}
				}
			end
		elseif CreateVarPArr[k][1] == "LA" then
			local TNum = math.ceil(CreateVarPArr[k][3]/151)
			Trigger {
				players = {ParsePlayer(CreateVarPArr[k][2])},
				conditions = {
					Label(i);
				},
				flag = {Preserved}
			}
			for i = 2, TNum do 
				Trigger {
					players = {ParsePlayer(CreateVarPArr[k][2])},
					flag = {Preserved}
				}
			end
		end
	end
	local CcodeVarX = math.ceil(CreateCCodeAlloc/480)
	for i = 1, CcodeVarX do 
		CVariable(AllPlayers,i+CreateCCodeVarXAlloc-1)
	end
	local NcodeVarX = math.ceil(CreateNCodeAlloc/60)
	for i = 1, NcodeVarX do 
		CVariable(FixPlayer,i+CreateNCodeVarXAlloc-1)
	end
	for i = 0xFC00, MAXWAlloc do
		CWariable(AllPlayers,i)
	end
	for i = 0xFE00, MAXVAlloc do
		CVariable(AllPlayers,i)
	end
	for j = 1, 16 do
		for i = SVarXOrig[j], MAXSVAlloc[j] do
			CSVariable(AllPlayers,i,j)
		end
	end
	local StringAct = {}
	for k, v in pairs (StringKeyArr) do
		table.insert(StringAct,Disabled(DisplayText(v,4)))
	end
	DoActions2(FixPlayer,{StringAct})
	Trigger { 
		players = {AllPlayers},
		conditions = {
			Label(0xFFFF);
		},
	}
	AllocCheck()
	CAPlotAllocCheck()
end

-- 기본 내장 조건/액션 (.py) ------------------------------------------------------------

function Label(Index)
	if Index == nil then
		Index = 0
	end
	local Label = Condition(0,0,Index,0,Exactly,0xFE,0,0x2) -- flag : 조건/액션 - 0x2 = Disabled
	if Index >= 1 then
		table.insert(LabelArr,Index)
	end
	return Label
end

function CtrigX(Player,Index,Address,Next,Type,Value,Mask)

	if Player == "X" then 
		Player = nil
	end
	if Index == "X" then 
		Index = nil
	end
	if Next == "X" then 
		Next = nil
	end
	if Mask == "X" then 
		Mask = nil
	end

	local Pflag
	if Player == nil then
		Pflag = 0
	else
		if Player >= 0 and Player <= 7 then
			Pflag = Player + 1
		else
			Pflag = 0
		end
	end

	local Mflag
	if Mask == nil then
		Mflag = 0
		Mask = 0
	else
		--Mflag = 32 (Rflag)
		Mflag = 0x80
	end

	local Nflag
	if Next == 0 or Next == nil then
		Nflag = 0
	elseif Next == 1 then 
		Nflag = 16
	else
		Nflag = 0
		Address = Address + 0x970*Next
	end

	local Cflag
	if Index == nil then
		Index = 0
		Cflag = 64
	else
		Cflag = 0
	end

	local Xflag = 0
	if Index >= 0x10000 then
		Index = Index - 0x10000
		Xflag = 128
	end

	local Rflag
	Rflag = Pflag + Nflag + Cflag + Xflag

	local ExCtrigX = Condition(Mask,Address/4,Value,Index,Type,0xFF,Rflag,0x10+Mflag) -- #DefCond
	return ExCtrigX
end

function SetCtrigX(Player1,Index1,Address1,Next1,Type,Player2,Index2,Address2,EPD2,Next2,Mask)

	if Player1 == "X" then 
		Player1 = nil
	end
	if Index1 == "X" then 
		Index1 = nil
	end
	if Next1 == "X" then 
		Next1 = nil
	end
	if Player2 == "X" then 
		Player2 = nil
	end
	if Index2 == "X" then 
		Index2 = nil
	end
	if Next2 == "X" then 
		Next2 = nil
	end
	if EPD2 == "X" then
		EPD2 = nil
	end
	if Mask == "X" then 
		Mask = nil
	end

	local Pflag1
	if Player1 == nil then
		Pflag1 = 0
	else
		if Player1 >= 0 and Player1 <= 7 then
			Pflag1 = Player1 + 1
		else
			Pflag1 = 0
		end
	end

	local Nflag1
	if Next1 == 0 or Next1 == nil then
		Nflag1 = 0
	elseif Next1 == 1 then 
		Nflag1 = 16
	else
		Nflag1 = 0
		Address1 = Address1 + 0x970*Next1
	end

	local Cflag1
	if Index1 == nil then
		Index1 = 0
		Cflag1 = 32
	else
		Cflag1 = 0
	end

	local Xflag1 = 0
	if Index1 >= 0x10000 then
		Index1 = Index1 - 0x10000
		Xflag1 = 64
	end

	local Pflag2
	if Player2 == nil then
		Pflag2 = 0
	else
		if Player2 >= 0 and Player2 <= 7 then
			Pflag2 = Player2 + 1
		else
			Pflag2 = 0
		end
	end

	local Nflag2
	if Next2 == 0 or Next2 == nil then
		Nflag2 = 0
	elseif Next2 == 1 then 
		Nflag2 = 16
	else
		Nflag2 = 0
		Address2 = Address2 + 0x970*Next2
	end

	local Mflag2
	if Mask == nil then
		Mflag2 = 0
		Mask = 0
	else
		--Mflag2 = 64 (Rflag2)
		Mflag2 = 0x80
	end

	local Addr2
	if EPD2 == 0 or EPD2 == nil then
		Addr2 = Address2
		Eflag2 = 0
	else
		Addr2 = Address2/4
		Eflag2 = 32
	end

	local Cflag2
	if Index2 == nil then
		Index2 = 0
		Cflag2 = 128
	else
		Cflag2 = 0
	end

	local Xflag2 = 0
	if Index2 >= 0x10000 then
		Index2 = Index2 - 0x10000
		Xflag2 = 128
	end

	local Rflag1
	Rflag1 = Pflag1 + Nflag1 + Cflag1 + Xflag1 + Xflag2
	local Rflag2
	Rflag2 = Pflag2 + Nflag2 + Eflag2 + Cflag2

	local ExSetCtrigX = Action(Mask,Index1,Rflag1,Rflag2,Address1/4,Addr2,Index2,0x5,Type,0x14+Mflag2) -- #DefAct (PauseGame = 0x5)
	return ExSetCtrigX
end

function SetCtrig1X(Player1,Index1,Address1,Next1,Type,Value,Mask)
	if Player1 == "X" then 
		Player1 = nil
	end
	if Index1 == "X" then 
		Index1 = nil
	end
	if Next1 == "X" then 
		Next1 = nil
	end
	if Mask == "X" then 
		Mask = nil
	end

	local Pflag1
	if Player1 == nil then
		Pflag1 = 0
	else
		if Player1 >= 0 and Player1 <= 7 then
			Pflag1 = Player1 + 1
		else
			Pflag1 = 0
		end
	end

	local Nflag1
	if Next1 == 0 or Next1 == nil then
		Nflag1 = 0
	elseif Next1 == 1 then 
		Nflag1 = 16
	else
		Nflag1 = 0
		Address1 = Address1 + 0x970*Next1
	end

	local Cflag1
	if Index1 == nil then
		Index1 = 0
		Cflag1 = 32
	else
		Cflag1 = 0
	end

	local Xflag1 = 0
	if Index1 >= 0x10000 then
		Index1 = Index1 - 0x10000
		Xflag1 = 64
	end

	local Rflag1
	Rflag1 = Pflag1 + Nflag1 + Cflag1 + Xflag1

	local Mflag2
	if Mask == nil then
		Mflag2 = 0
		Mask = 0
	else
		--Mflag2 = 64 (Rflag2)
		Mflag2 = 0x80
	end

	local ExSetCtrig1X = Action(Mask,Index1,Rflag1,0,Address1/4,Value,0,0x5,Type,0x14+Mflag2) -- (PauseGame = 0x5)
	return ExSetCtrig1X
end

function SetCtrig2X(Offset,Type,Player2,Index2,Address2,EPD2,Next2,Mask)
	if Player2 == "X" then 
		Player2 = nil
	end
	if Index2 == "X" then 
		Index2 = nil
	end
	if Next2 == "X" then 
		Next2 = nil
	end
	if EPD2 == "X" then
		EPD2 = nil
	end
	if Mask == "X" then 
		Mask = nil
	end

	local Pflag2
	if Player2 == nil then
		Pflag2 = 0
	else
		if Player2 >= 0 and Player2 <= 7 then
			Pflag2 = Player2 + 1
		else
			Pflag2 = 0
		end
	end

	local Nflag2
	if Next2 == 0 or Next2 == nil then
		Nflag2 = 0
	elseif Next2 == 1 then 
		Nflag2 = 16
	else
		Nflag2 = 0
		Address2 = Address2 + 0x970*Next2
	end

	local Mflag2
	if Mask == nil then
		Mflag2 = 0
		Mask = 0
	else
		--Mflag2 = 64 (Rflag2)
		Mflag2 = 0x80
	end

	local Addr2
	if EPD2 == 0 or EPD2 == nil then
		Addr2 = Address2
		Eflag2 = 0
	else
		Addr2 = Address2/4
		Eflag2 = 32
	end

	local Cflag2
	if Index2 == nil then
		Index2 = 0
		Cflag2 = 128
	else
		Cflag2 = 0
	end

	local Xflag2 = 0
	if Index2 >= 0x10000 then
		Index2 = Index2 - 0x10000
		Xflag2 = 128
	end

	local Rflag1
	Rflag1 = Xflag2
	local Rflag2
	Rflag2 = Pflag2 + Nflag2 + Eflag2 + Cflag2

	local Offset2
	if Offset == "Cp" then
		Offset2 = 13
	else
		Offset2 = EPD(Offset)
	end

	local ExSetCtrig2X = Action(Mask,0,Rflag1,Rflag2,Offset2,Addr2,Index2,0x5,Type,0x14+Mflag2) -- (PauseGame = 0x5)
	return ExSetCtrig2X
end

-- 오류 체크 기본 함수 ------------------------------------------------------------------

function ErrorCheck() -- Ctrig 문법 오류 점검 함수
	--AllocCheck() 기본적용됨
	LabelCheck()
	ControlCheck()
end

function AllocCheck()
	if IndexAlloc >= 0xF000 then
		IndexAllocation_Overflow()
	end
	if FuncAlloc >= 0x20000 then
		FuncAllocation_Overflow()
	end
	if FlagAlloc >= 12480 then
		FlagAllocation_Overflow()
	end
	if MAXVAlloc >= 0xFFE0 then
		VarXAllocation_Overflow()
	end
	if MAXWAlloc >= 0xFDF0 then
		WarXAllocation_Overflow()
	end
	for j = 1, 16 do
		if MAXSVAlloc[j] >= SVarXOrig[j] + 0x7C then
			SVarXAllocation_Overflow()
		end
	end
end

function LabelCheck() -- Label 중복 체크
	local C
	for i,key in pairs(LabelArr) do
		C = 0
		for j,v in pairs(LabelArr) do
			if v == key then
				C = C + 1
			end
		end
		if C >= 2 then
			if LabelArr[i] < 0xA000 or LabelArr[i] >= 0xC000 then
				_G["Label_duplicated! Current Label : 0x"..string.format("%X",LabelArr[i])]() -- push error msg
			else
				_G["sIndex_duplicated! Current sIndex : 0x"..string.format("%X",LabelArr[i]%0x1000)]() -- push error msg
			end
		end
		if key == 0xFFE0 then
			Prohibited_Label()
		end
	end
end

function ControlCheck() -- 제어문 입력 오류 체크
	for i, key in pairs(CJumpArr) do
		local X = nil
		for k, v in pairs(CJumpEndArr) do
			if v == key then
				X = 1
			end
		end
		if X == nil then
			CJumppair_missing()
		end
	end
	for i, key in pairs(NJumpArr) do
		local X = nil
		for k, v in pairs(NJumpEndArr) do
			if v == key then
				X = 1
			end
		end
		if X == nil then
			NJumppair_missing()
		end
	end

	for k, v in pairs(CIfArr) do
		if v ~= nil then
			CIfpair_missing()
		end
	end
	for k, v in pairs(NIfArr) do
		if v ~= nil then
			NIfpair_missing()
		end
	end
	for k, v in pairs(CWhileArr) do
		if v ~= nil then
			CWhilepair_missing()
		end
	end
	for k, v in pairs(NWhileArr) do
		if v ~= nil then
			NWhilepair_missing()
		end
	end
	for k, v in pairs(DWhileArr) do
		if v ~= nil then
			DoWhilepair_missing()
		end
	end
	for k, v in pairs(CForArr) do
		if v ~= nil then
			CForpair_missing()
		end
	end
	for k, v in pairs(CIfXArr) do
		if v ~= nil then
			CIfXpair_missing()
		end
	end
	for k, v in pairs(NIfXArr) do
		if v ~= nil then
			NIfXpair_missing()
		end
	end
	for k, v in pairs(CWhileXArr) do
		if v ~= nil then
			CWhileXpair_missing()
		end
	end
	for k, v in pairs(NWhileXArr) do
		if v ~= nil then
			NWhileXpair_missing()
		end
	end
	for k, v in pairs(SLoopNArr) do
		if v ~= nil then
			SLoopNpair_missing()
		end
	end
end

-- 표준 입출력 및 변환 함수 -------------------------------------------------------------

function CAddr(Section,Line,Next) -- Convert (Data -> Mem_Address)
	if Line == "X" or Line == nil then
		Line = 1
	end
	Line = Line - 1
	local Offset

	if Section == "Prev" then
		Offset = 0
	end
	if Section == "Next" then
		Offset = 0x4
	end
	if Section == "Internal" then
		Offset = 0x948
	end

	if Section == "CMask" then
		Offset = 0x0
		Offset = Offset + 0x14 * Line + 0x8
	end
	if Section == "CEPD" then
		Offset = 0x4
		Offset = Offset + 0x14 * Line + 0x8
	end
	if Section == "CType" then
		Offset = 0xC
		Offset = Offset + 0x14 * Line + 0x8
	end
	if Section == "CValue" then
		Offset = 0x8
		Offset = Offset + 0x14 * Line + 0x8
	end
	if Section == "CFlag" then
		Offset = 0x10
		Offset = Offset + 0x14 * Line + 0x8
	end

	if Section == "Mask" then
		Offset = 0x0
		Offset = Offset + 0x20 * Line + 0x148
	end
	if Section == "Str" then
		Offset = 0x4
		Offset = Offset + 0x20 * Line + 0x148
	end
	if Section == "Wav" then
		Offset = 0x8
		Offset = Offset + 0x20 * Line + 0x148
	end
	if Section == "Time" then
		Offset = 0xC
		Offset = Offset + 0x20 * Line + 0x148
	end
	if Section == "EPD" then
		Offset = 0x10
		Offset = Offset + 0x20 * Line + 0x148
	end
	if Section == "Type" then
		Offset = 0x18
		Offset = Offset + 0x20 * Line + 0x148
	end
	if Section == "Value" then
		Offset = 0x14
		Offset = Offset + 0x20 * Line + 0x148
	end
	if Section == "Flag" then
		Offset = 0x1C
		Offset = Offset + 0x20 * Line + 0x148
	end

	if Next == nil or Next == "X" then
		Next = 0
	end

	local CAddress = Next * 0x970 + Offset
	return CAddress
end

function DtoA(Player,UnitId) -- Convert(Deaths -> OffSet)
 	local DtoA = 0x58A364 + 0x30 * ParseUnit(UnitId) + 0x4 * Player
 	return DtoA
end 

-- CIf : 2 / NIf : 3 / CWhile : 3 / NWhile : 4 / DoWhile : 2 / CFor : 4 / CIfX : 1* / NIfX : 1*
function Forward(Move) -- Return(Struct_Index)
	if Move == nil then
		Move = 0
	end
	local Forward = IndexAlloc + Move
	return Forward
end

function Struct(Type,Number) -- Convert(Data -> Forward_Move)
	local Struct
	if Type == "CIfX" or Type == "NIfX" then
		Struct = Number	* 2	
	elseif Type == "CIf" or Type == "DoWhile" then
		Struct = Number * 2
	elseif Type == "CWhile" or Type == "NIf" then
		Struct = Number * 3
	elseif Type == "NWhile" or Type == "CFor" then
		Struct = Number * 4
	end
	return Struct
end

function Ccode(Index,Line) -- Convert(Data -> N/CDeaths_Code)
	local Ccode = Line*0x100000 + Index
	return Ccode
end

-- "X" -> nil
-- Number -> Return(Constant Data) --
-- "Cp" -> Return(CurrentPlayer Data)

function V(Index,Player,Next) -- Return(Variable Data)
	if Player == nil then
		Player = "X"
	end
	return {Player,Index,Next,"V"}
end

function Vi(Index,Deviation,Player,Next) -- Return(Variable Data+) : T,TT Cond/Act 전용 / SetRecoverCp / Arr,VArr
	if Deviation == "X" or Deviation == nil then
		Deviation = 0
	end
	if Player == nil then
		Player = "X"
	end
	return {Player,Index,Next,"V",Deviation}
end

function W(Index,Player,Next) -- Return(Wariable Data)
	if Player == nil then
		Player = "X"
	end
	return {Player,Index,Next,"W"}
end

function Wi(Index,Deviation,Player,Next) -- Return(Wariable Data+) : T,TT Cond/Act 전용 
	if Deviation == "X" or Deviation == nil then
		Deviation = 0
	end
	if Player == nil then
		Player = "X"
	end
	return {Player,Index,Next,"W",Deviation}
end

function SV(SVariable,Line,Player,Next) -- Return(SVariable Data)
	if SVariable[1] ~= "S" then
		SV_InputData_Error()
	end
	if Player == nil then
		Player = "X"
	end
	return {Player,SVariable[2],Next,"SV",SVariable[3],Line}
end

function X(Lua_Variable) -- Convert(Lua_Var -> Return(Variable Data))
	return {Lua_Variable[1],Lua_Variable[2],Lua_Variable[3],"V"}
end

function Mem(Player,Index,Address,Next,EPDflag) -- Return(Ctrig Memory Data)
	if Player == nil then
		Player = "X"
	end
	if EPDflag == "X" or EPDflag == nil or EPDflag == 0 then
		EPDflag = nil
	else
		EPDflag = 1
	end

	if Address == "X" or Address == nil then
		Address = 0
	end
	return {Player,Index,Address,Next,EPDflag}
end

function _Mem(Variable,Address,Next,EPDflag) -- Convert(Variable Data -> Ctrig Memory Data)
	if Variable[3] == nil then
		Variable[3] = 0
	end
	if EPDflag == "X" or EPDflag == nil or EPDflag == 0 then
		EPDflag = nil
	else
		EPDflag = 1
	end
	if Variable[4] ~= "V" then
		_Mem_InputData_Error()
	end
	if Address == "X" or Address == nil then
		Address = 0x15C
	end
	if Next == "X" or Next == nil then
		Next = 0
	end
	return {Variable[1],Variable[2],Address,Variable[3]+Next,EPDflag}
end

function LMem(Player,Index,Address,Next,EPDflag) -- Return(Ctrig Memory Data)

	if Player == nil then
		Player = {"X","X"}
	elseif type(Player) ~= "table" then
		Player = {Player,Player}
	end
	if EPDflag == "X" or EPDflag == nil or EPDflag == 0 then
		EPDflag = nil
	else
		EPDflag = 1
	end
	if type(Index) ~= "table" then
		Index = {Index,Index}
	end
	if type(Next) ~= "table" then
		Next = {Next,Next}
	end
	if type(Address) ~= "table" then
		Address = {Address,Address}
	end
	if Address[1] == "X" or Address[1] == nil then
		Address[1] = 0
	end
	if Address[2] == "X" or Address[2] == nil then
		Address[2] = 0
	end
	return {{Player[1],Index[1],Address[1],Next[1],EPDflag},{Player[2],Index[2],Address[2],Next[2],EPDflag}}
end

function _LMem(Wariable,Address,Next,EPDflag) -- Convert(Wariable Data -> Ctrig Memory Data)
	local Check 
	if Wariable[3] == nil then
		Wariable[3] = 0
	end
	if EPDflag == "X" or EPDflag == nil or EPDflag == 0 then
		EPDflag = nil
	else
		EPDflag = 1
	end
	if Wariable[4] ~= "W" then
		_LMem_InputData_Error()
	end
	if Address == "X" or Address == nil then
		Address = {0x15C,0x19C}
	elseif type(Address) == "number" then
		Check = 0
	elseif type(Address) == "table" and type(Address[2]) == "table" then
		Check = 1
	end
	if Next == "X" or Next == nil then
		Next = 0
	end
	if Check == 0 then
		return {Wariable[1],Wariable[2],Address,Wariable[3]+Next,EPDflag}
	elseif Check == 1 then
		return {{Wariable[1],Wariable[2],Address[1],Wariable[3]+Next,EPDflag},{Wariable[1],Wariable[2],Address[1]+Address[2][1],Wariable[3]+Next,EPDflag}}
	else 
		return {{Wariable[1],Wariable[2],Address[1],Wariable[3]+Next,EPDflag},{Wariable[1],Wariable[2],Address[2],Wariable[3]+Next,EPDflag}}
	end
end

function _SMem(SVData,Address,Next,EPDflag) -- Convert(SVData -> Ctrig Memory Data)
	local Box = {}
	local Check
	local Line = SVData[6]
	local Number = SVData[5]
	if Next == nil or "X" then
		Next = 0
	end
	if Line == "X" then
		Line = nil
	end
	if SVData[3] == nil then
		SVData[3] = 0
	end
	if EPDflag == "X" or EPDflag == nil or EPDflag == 0 then
		EPDflag = nil
	else
		EPDflag = 1
	end
	if SVData[4] ~= "SV" then
		_SMem_InputData_Error()
	end
	if Address == "X" or Address == nil then
		Check = 1
		if type(Line) == "number" then
			Box = {SVData[1],SVData[2],0x15C+0x40*(Line-1),SVData[3]+Next,EPDflag}
		elseif Line == nil then
			for i = 1, Number do
				table.insert(Box,{SVData[1],SVData[2],0x15C+0x40*(i-1),SVData[3]+Next,EPDflag})
			end
		else
			for k, v in pairs(Line) do
				table.insert(Box,{SVData[1],SVData[2],0x15C+0x40*(v-1),SVData[3]+Next,EPDflag})
			end
		end
	elseif type(Address) == "number" then
		Check = 0
		if type(Line) == "number" then
			if Address >= 0x148 and Address <= 0x164 then
				Address = Address + (Line-1)*0x40
			end
		end
	elseif type(Address) == "table" and type(Address[2]) == "table" then
		Check = 1
		local Distance = Address[2][1]
		if type(Line) == "number" then
				Box = {SVData[1],SVData[2],Address[1]+Distance*(Line-1),SVData[3]+Next,EPDflag}
		elseif Line == nil then
			for i = 1, Number do
				table.insert(Box,{SVData[1],SVData[2],Address[1]+Distance*(i-1),SVData[3]+Next,EPDflag})
			end
		else
			for k, v in pairs(Line) do
				table.insert(Box,{SVData[1],SVData[2],Address[1]+Distance*(v-1),SVData[3]+Next,EPDflag})
			end
		end
	end
	
	if Check == 0 then
		return {SVData[1],SVData[2],Address,SVData[3]+Next,EPDflag}
	elseif Check == 1 then
		return Box
	end
end

function Arr(Array,Index,Player) -- 1, V, _Mov(VArr()) 사용
	if type(Player) == "table" then
		Arr_InputData_Error()
	end
	if Player == nil then
		Player = "X"
	else
		Array[1] = Player
	end

	if type(Index) == "number" then
		return {Player,Array[2],(Index+(math.floor(Index/602))*2)*4,0}
	elseif Index[4] == "V" then
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"A",Array}

		if Index[5] == nil then
			Index[5]= 0
		end

		table.insert(STPushTrigArr,{"ConvertArr",{"X",Temp,0,"V"},Index})

		VarXAlloc = VarXAlloc + 1
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TempData
	else
		Arr_InputData_Error()
	end
end

function ArrX(Array,Index,Player) -- 1, V, _Mov(VArr()) 사용
	if type(Player) == "table" then
		ArrX_InputData_Error()
	end
	if Player == nil then
		Player = "X"
	else
		Array[1] = Player
	end

	if type(Index) == "number" then
		return {Player,Array[2],(Index+(math.floor(Index/602))*2)*4,0}
	elseif Index[4] == "V" then
		return {Index[1],Index[2],Index[3],"A",Array}
	else
		ArrX_InputData_Error()
	end
end

function ConvertArr(PlayerID,Dest,Source) -- V << (i+D)/301 -> V SetTo 0 0x1 -> V += Arr
	-- Dest = TempV, Source = Index, Operand = Arr / V << V 전용
	STPopTrigArr(PlayerID)
	if Source[4] == "VA" or Dest[4] == "VA" then
		ConvertArr_InputData_Error()
	end

	if Source[5] == nil then
		Source[5] = 0
	end
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(0);
		},
		actions = {
			SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0);
			SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Source[5]);
			SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
			SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
			SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
			CallLabelAlways(Source[1],Source[2],Source[3]);
		},
		flag = {Preserved}
	}

	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(FuncAlloc);
			CtrigX("X",CRet[1],0x15C,0,AtMost,601);
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+1,0,0,0);
		},
		flag = {Preserved}
	}

	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(0);
			--CtrigX("X",CRet[1],0x15C,0,AtLeast,602);
			CtrigX("X",CRet[1],0x15C,0,AtMost,1203); 
		},
		actions = {
			SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,2);
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+1,0,0,0);
		},
		flag = {Preserved}
	}

	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(0);
			--CtrigX("X",CRet[1],0x15C,0,AtLeast,1204);
			CtrigX("X",CRet[1],0x15C,0,AtMost,1805); 
		},
		actions = {
			SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,4);
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+1,0,0,0);
		},
		flag = {Preserved}
	}

	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(0);
			--CtrigX("X",CRet[1],0x15C,0,AtLeast,1806);
			CtrigX("X",CRet[1],0x15C,0,AtMost,2407); 
		},
		actions = {
			SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,6);
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+1,0,0,0);
		},
		flag = {Preserved}
	}

	for i = 22, 0, -1 do
		local CBit = 2^i
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,602*CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,602*CBit);
					SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,2*CBit);
				},
				flag = {Preserved}
			}
	end

	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(FuncAlloc+1);
		},
		actions = {
			SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0,0,1);
			SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0,0,2);
			SetCtrigX("X",FuncAlloc,0x4,2,SetTo,"X",FuncAlloc,0,0,3);
			SetCtrigX("X",FuncAlloc,0x4,3,SetTo,"X",FuncAlloc,0,0,4);
			SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[5]);
			SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
			SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
			SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
			CallLabelAlways(Source[1],Source[2],Source[3]);
		},
		flag = {Preserved}
	}
	FuncAlloc = FuncAlloc + 2
end

function LArr(LArray,Index,Player) -- 1, V, _Mov(VArr()) 사용 : Output Mem, {Mem,Mem+1}, A, {A,A}, LA[V], LA[W] 
	local Mode = 0
	if #LArray == 1 then
		Mode = 8
		LArray = LArray[1]
	end
	if #LArray == 2 then
		if LArray[2] == 0 then
			Mode = 0
			LArray = LArray[1]
		elseif LArray[2] == 1 then
			Mode = 1
			LArray = LArray[1]
		elseif LArray[2] == 8 then
			Mode = 8
			LArray = LArray[1]
		else
			LArr_Mode_Error()
		end
	end

	if type(Player) == "table" then
		LArr_InputData_Error()
	end

	if Player == nil then
		Player = "X"
	else
		LArray[1] = Player
	end

	if Mode == 8 then -- Mode 8bytes
		if type(Index) == "number" then -- {Mem,Mem}
			return {{Player,LArray[2],math.floor(Index)*0x10,0},{Player,LArray[2],math.floor(Index)*0x10+0x4,0}}
		elseif Index[4] == "V" then -- LA[V]
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"LA_V",LArray}

			if Index[5] == nil then
				Index[5]= 0
			end

			table.insert(STPushTrigArr,{"ConvertLArr",{"X",Temp,0,"V"},Index,Mode})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			return TempData
		elseif Index[4] == "W" then -- LA[W]
			local Temp = WarXAlloc
			local TempData = {"X",Temp,0,"LA_W",LArray}

			if Index[5] == nil then
				Index[5]= 0
			end

			table.insert(STPushTrigArr,{"ConvertLArr",{"X",Temp,0,"W"},Index,Mode})

			WarXAlloc = WarXAlloc + 1
			if WarXAlloc > MAXWAlloc then
				MAXWAlloc = WarXAlloc
			end
			return TempData
 		else
			LArr_InputData_Error()
		end
	else -- Mode 4bytes (0/1)
		if type(Index) == "number" then -- Mem
			if Mode == 0 then
				return {Player,LArray[2],math.floor(Index)*0x10,0}
			elseif Mode == 1 then
				return {Player,LArray[2],math.floor(Index)*0x10+0x4,0}
			end
		elseif Index[4] == "V" then -- A
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"A",LArray}

			if Index[5] == nil then
				Index[5]= 0
			end

			table.insert(STPushTrigArr,{"ConvertLArr",{"X",Temp,0,"V"},Index,Mode})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			return TempData
		else
			LArr_InputData_Error()
		end
	end
end

function LArrX(LArray,Index,Player) -- 1, V, _Mov(VArr()) 사용
	local Mode = 0
	if #LArray == 1 then
		Mode = 8
		LArray = LArray[1]
	end
	if #LArray == 2 then
		if LArray[2] == 0 then
			Mode = 0
			LArray = LArray[1]
		elseif LArray[2] == 1 then
			Mode = 1
			LArray = LArray[1]
		elseif LArray[2] == 8 then
			Mode = 8
			LArray = LArray[1]
		else
			LArrX_Mode_Error()
		end
	end

	if type(Player) == "table" then
		LArrX_InputData_Error()
	end

	if Player == nil then
		Player = "X"
	else
		LArray[1] = Player
	end

	if Mode == 8 then -- Mode 8bytes
		if type(Index) == "number" then -- {Mem,Mem}
			return {{Player,LArray[2],math.floor(Index)*0x10,0},{Player,LArray[2],math.floor(Index)*0x10+0x4,0}}
		elseif Index[4] == "V" then -- LA[V]
			if Index[5] == nil then
				LArray[3] = 0
			else 
				LArray[3] = Index[5]*0x10
			end
			return {Index[1],Index[2],Index[3],"LA_V",LArray}
		elseif Index[4] == "W" then -- LA[W]
			if Index[5] == nil then
				LArray[3] = 0
			else 
				LArray[3] = Index[5]*0x10
			end
			return {Index[1],Index[2],Index[3],"LA_W",LArray}
		else
			LArr_InputData_Error()
		end
	else -- Mode 4bytes (0/1)
		if type(Index) == "number" then -- Mem
			if Mode == 0 then
				return {Player,LArray[2],math.floor(Index)*0x10,0}
			elseif Mode == 1 then
				return {Player,LArray[2],math.floor(Index)*0x10+0x4,0}
			end
		elseif Index[4] == "V" then -- A
			if Index[5] == nil then
				LArray[3] = 0
			else 
				LArray[3] = Index[5]*0x10
			end
			if Mode == 0 then
				return {Index[1],Index[2],Index[3],"A",LArray}
			elseif Mode == 1 then
				LArray[3] = LArray[3] + 0x4
				return {Index[1],Index[2],Index[3],"A",LArray}
			end
		else
			LArrX_InputData_Error()
		end
	end
end

function ConvertLArr(PlayerID,Dest,Source,Mode) -- V << (i+D)/301 -> V SetTo 0 0x1 -> V += Arr
	-- Dest = TempV, Source = Index, Operand = Arr / V << V 전용
	STPopTrigArr(PlayerID)
	if not((Dest[4] == "V" and Source[4] == "V") or (Dest[4] == "W" and Source[4] == "W")) then
		ConvertLArr_InputData_Error()
	end

	if Source[5] == nil then
		Source[5] = 0
	end

	if Mode == 0 or Mode == 1 then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
				SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
				SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
				SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
				SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}
		if Mode == 0 then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[5]*4);
				},
				flag = {Preserved}
			}
		elseif Mode == 1 then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[5]*4+1);
				},
				flag = {Preserved}
			}
		end
	elseif Mode == 8 then
		if Dest[4] == "V" then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
					SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
					SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
					SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[5]*4);
				},
				flag = {Preserved}
			}
		elseif Dest[4] == "W" then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
					SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
					SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
					SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
					SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[5]*4);
					SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],Add,Source[5]*4);
				},
				flag = {Preserved}
			}
		end
	else
		ConvertLArr_InputData_Error()
	end
end

function GetVArray(Header,Size)
	return {"X",Header[2],0,"V",0,Size}
end

function VArr(VArray,Index,Player) -- 1, V, _Mov(VArr()) 사용
	if type(Player) == "table" then
		VArr_InputData_Error()
	end
	if Player == nil then
		Player = "X"
	else
		VArray[1] = Player
	end
	
	if type(Index) == "number" then
		return {Player,VArray[2],Index,"V"}
	elseif Index[4] == "V" then
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"VA",VArray,0,"X",Temp+1,0}

		if Index[5] == nil then
			Index[5] = 0
		end
		
		table.insert(STPushTrigArr,{"ConvertVArr",{"X",Temp,0,"V"},{"X",Temp+1,0,"V"},Index,VArray[6]}) 

		VarXAlloc = VarXAlloc + 2
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TempData
	else
		VArr_InputData_Error()
	end
end

function VArrX(VArray,Index,Index4,Player) -- 1, V, _Mov(VArr()) 사용
	if type(Player) == "table" then
		VArrX_InputData_Error()
	end
	if Player == nil then
		Player = "X"
	else
		VArray[1] = Player
	end

	if type(Index) == "number" then
		return {Player,VArray[2],Index,"V"}
	elseif Index[4] == "V" and Index4[4] == "V" then
		if Index[5] == nil then
			Index[5] = 0
		end
		return {Index[1],Index[2],Index[3],"VA",VArray,Index[5]*604,Index4[1],Index4[2],Index4[3]}
	else
		VArrX_InputData_Error()
	end
end

function ConvertVArr(PlayerID,Dest,Dest4,Source,Size) -- V << (i+D) * 604 -> V += Arr
	-- Dest = TempV, Source = Index, Operand = Arr / V << V 전용
	STPopTrigArr(PlayerID)
	if Source[4] == "VA" or Dest[4] == "VA" or Dest4[4] == "VA" then
		ConvertVArr_InputData_Error()
	end

	if Source[5] == nil then
		Source[5] = 0
	end

	if Size == nil then
		Size = 4095
	end

	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(0);
		},
		actions = {
			SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5]*604);
			SetCtrig1X(Dest4[1],Dest4[2],0x15C,Dest4[3],SetTo,Source[5]*2416);
		},
		flag = {Preserved}
	}

	for i = 0, 11 do
		local CBit = 2^i
		if Size >= CBit then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,CBit,CBit);
				},
				actions = {
					SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit*604);
					SetCtrig1X(Dest4[1],Dest4[2],0x15C,Dest4[3],Add,CBit*2416);
				},
				flag = {Preserved}
			}
		end
	end
end

function GetSVArray(Header,Size)
	return {"X",Header[2],0,"SA",Header[3],Size}
end

function SVArr(SVArray,Index,Line,Player) -- 1, V, _Mov(VArr()) 사용
	if SVArray[4] ~= "SA" then 
		SVArr_InputData_Error()
	end
	if type(Player) == "table" then
		SVArr_InputData_Error()
	end
	if Player == nil then
		Player = "X"
	else
		SVArray[1] = Player
	end
	
	if type(Index) == "number" then
		return {Player,SVArray[2],Index,"SV",SVArray[5],Line}
	elseif Index[4] == "V" then -- SV[V] 만 허용
		local SVArrayX = {SVArray[1],SVArray[2],SVArray[3],SVArray[4],SVArray[5],SVArray[6],Line}
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"SVA",SVArrayX,0,"X",Temp+1,0} -- << {"X",Index,0,"SA",Number,Size,Line}

		if Index[5] == nil then
			Index[5] = 0
		end
		
		table.insert(STPushTrigArr,{"ConvertSVArr",{"X",Temp,0,"V"},{"X",Temp+1,0,"V"},Index,SVArray[6]}) 

		VarXAlloc = VarXAlloc + 2
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TempData
	else
		SVArr_InputData_Error()
	end
end

function SVArrX(SVArray,Index,Index4,Line,Player) -- 1, V, _Mov(VArr()) 사용
	if SVArray[4] ~= "SA" then 
		SVArr_InputData_Error()
	end
	if type(Player) == "table" then
		SVArrX_InputData_Error()
	end
	if Player == nil then
		Player = "X"
	else
		SVArray[1] = Player
	end

	if type(Index) == "number" then
		return {Player,SVArray[2],Index,"SV",SVArray[5],Line}
	elseif Index[4] == "V" and Index4[4] == "V" then
		local SVArrayX = {SVArray[1],SVArray[2],SVArray[3],SVArray[4],SVArray[5],SVArray[6],Line}
		if Index[5] == nil then
			Index[5] = 0
		end
		return {Index[1],Index[2],Index[3],"SVA",SVArrayX,Index[5]*604,Index4[1],Index4[2],Index4[3]}
	else
		SVArrX_InputData_Error()
	end
end

function ConvertSVArr(PlayerID,Dest,Dest4,Source,Size) -- V << (i+D) * 604 -> V += Arr
	-- Dest = TempV, Source = Index, Operand = Arr / V << V 전용
	STPopTrigArr(PlayerID)
	if Source[4] == "VA" or Dest[4] == "VA" or Dest4[4] == "VA" then
		ConvertSVArr_InputData_Error()
	end

	if Source[5] == nil then
		Source[5] = 0
	end

	if Size == nil then
		Size = 4095
	end

	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(0);
		},
		actions = {
			SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5]*604);
			SetCtrig1X(Dest4[1],Dest4[2],0x15C,Dest4[3],SetTo,Source[5]*2416);
		},
		flag = {Preserved}
	}

	for i = 0, 11 do
		local CBit = 2^i
		if Size >= CBit then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,CBit,CBit);
				},
				actions = {
					SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit*604);
					SetCtrig1X(Dest4[1],Dest4[2],0x15C,Dest4[3],Add,CBit*2416);
				},
				flag = {Preserved}
			}
		end
	end
end

function GetWArray(Header,Size)
	return {"X",Header[2],0,"W",0,Size}
end

function WArr(WArray,Index,Player) -- 1, W, _Mov(WArr()) 사용 : Output = W/WA[V]/WA[W]
	if type(Player) == "table" then
		WArr_InputData_Error()
	end
	if Player == nil then
		Player = "X"
	else
		WArray[1] = Player
	end
	
	if type(Index) == "number" then
		return {Player,WArray[2],Index,"W"}
	elseif Index[4] == "V" then
		local Temp = WarXAlloc
		local TempData = {"X",Temp,0,"WA",WArray,0,"X",Temp+1,0}

		if Index[5] == nil then
			Index[5] = 0
		end
		
		table.insert(STPushTrigArr,{"ConvertWArr",{"X",Temp,0,"W"},{"X",Temp+1,0,"W"},Index,WArray[6]}) 

		WarXAlloc = WarXAlloc + 2
		if WarXAlloc > MAXWAlloc then
			MAXWAlloc = WarXAlloc
		end
		return TempData
	elseif Index[4] == "W" then
		local Temp = WarXAlloc
		local TempData = {"X",Temp,0,"WA",WArray,0,"X",Temp+1,0}

		if Index[5] == nil then
			Index[5] = 0
		end
		
		table.insert(STPushTrigArr,{"ConvertWArr",{"X",Temp,0,"W"},{"X",Temp+1,0,"W"},Index,WArray[6]}) 

		WarXAlloc = WarXAlloc + 2
		if WarXAlloc > MAXWAlloc then
			MAXWAlloc = WarXAlloc
		end
		return TempData
	else
		WArr_InputData_Error()
	end
end

function WArrX(WArray,Index,Index4,Player) -- 1, V, _Mov(VArr()) 사용
	if type(Player) == "table" then
		WArrX_InputData_Error()
	end
	if Player == nil then
		Player = "X"
	else
		WArray[1] = Player
	end

	if type(Index) == "number" then
		return {Player,WArray[2],Index,"W"}
	elseif Index[4] == "W" and Index4[4] == "W" then
		if Index[5] == nil then
			Index[5] = 0
		end
		return {Index[1],Index[2],Index[3],"WA",WArray,Index[5]*604,Index4[1],Index4[2],Index4[3]}
	else
		WArrX_InputData_Error()
	end
end

function ConvertWArr(PlayerID,Dest,Dest4,Source,Size) -- V << (i+D) * 604 -> V += Arr
	-- Dest = TempV, Source = Index, Operand = Arr / V << V 전용
	STPopTrigArr(PlayerID)
	if Source[4] ~= "W" and Source[4] ~= "V" then
		ConvertWArr_InputData_Error()
	end
	if Dest[4] ~= "W" or Dest4[4] ~= "W" then
		ConvertWArr_InputData_Error()
	end

	if Source[5] == nil then
		Source[5] = 0
	end

	if Size == nil then
		Size = 4095
	end

	if Source[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5]*604);
				SetCtrig1X(Dest4[1],Dest4[2],0x15C,Dest4[3],SetTo,Source[5]*2416);
				SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5]*604);
				SetCtrig1X(Dest4[1],Dest4[2],0x19C,Dest4[3],SetTo,Source[5]*2416);
			},
			flag = {Preserved}
		}

		for i = 0, 11 do
			local CBit = 2^i
			if Size >= CBit then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,CBit,CBit);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit*604);
						SetCtrig1X(Dest4[1],Dest4[2],0x15C,Dest4[3],Add,CBit*2416);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],Add,CBit*604);
						SetCtrig1X(Dest4[1],Dest4[2],0x19C,Dest4[3],Add,CBit*2416);
					},
					flag = {Preserved}
				}
			end
		end
	elseif Source[4] == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5]*604);
				SetCtrig1X(Dest4[1],Dest4[2],0x15C,Dest4[3],SetTo,Source[5]*2416);
				SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5]*604);
				SetCtrig1X(Dest4[1],Dest4[2],0x19C,Dest4[3],SetTo,Source[5]*2416);
			},
			flag = {Preserved}
		}

		for i = 0, 11 do
			local CBit = 2^i
			if Size >= CBit then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,CBit,CBit); -- Index W = {index,index} 
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit*604);
						SetCtrig1X(Dest4[1],Dest4[2],0x15C,Dest4[3],Add,CBit*2416);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],Add,CBit*604);
						SetCtrig1X(Dest4[1],Dest4[2],0x19C,Dest4[3],Add,CBit*2416);
					},
					flag = {Preserved}
				}
			end
		end
	end
end

function MovX(PlayerID,Dest,Source,Mode,Mask,Clear) -- V << VA / VA,A << V (Value) / 내부함수 (사용 권장X)
	--STPopTrigArr(PlayerID)
	if Mode == "X" or Mode == nil then
		Mode = SetTo
	end
	if Mask == "X" or Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local Mask2 = Mask
	if Clear == 1 then
		Mask2 = 0xFFFFFFFF
	end

	local Box0 = {}
	if Dest[4] == "V" and Source[4] == "VA" then -- Mov V, VA / {Index[1],Index[2],Index[3],"VA",VArray(VAPlayer,VAIndex,0),Index[5]}
		if Clear == 1 then
			table.insert(Box0,SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0,Mask2))
		end

		Trigger {--(CPRead)로 값 출력
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					Box0,
					SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

					SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
					SetMemory(0x6509B0,Add,Source[6]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
					CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);

				},
				flag = {Preserved}
			}

		RecoverCp(PlayerID)

		-- Ctrig->Ctrig->Ctrig Version : Cp사용 X
		--[[
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x158,3,SetTo,Source[5][1],Source[5][2],0x158,1,Source[5][3]); 
					SetCtrigX("X","X",0x17C,3,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrigX("X","X",0x198,3,SetTo,Source[5][1],Source[5][2],0x4,1,Source[5][3]); 
					SetCtrig1X("X","X",0x158,3,Add,Source[6]);
					SetCtrig1X("X","X",0x17C,3,Add,Source[6]*4);
					SetCtrig1X("X","X",0x198,3,Add,Source[6]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x158,1,3); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x198,1,2); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x17C,1,1); 
					CallLabelAlways(Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0,0,Source[3]);
					SetCtrig2X(0,SetTo,"X","X",0,0,1); -- SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}
			]]--
	elseif type(Dest[4]) ~= "string" and Source[4] == "VA" then -- Mov Mem, VA / {Index[1],Index[2],Index[3],"VA",VArray(VAPlayer,VAIndex,0),Index[5]}
		Trigger {--(CPRead)로 값 출력
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

					SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
					SetMemory(0x6509B0,Add,Source[6]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
					CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);

				},
				flag = {Preserved}
			}

		RecoverCp(PlayerID)
	elseif Dest[4] == "VA" and Source[4] == "V" then -- Mov VA, V 
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],Add,Dest[6]);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
					CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	elseif Dest[4] == "A" and Source[4] == "V" then -- Mov A, V 
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
					CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	else
		MovX_InputData_Error()
	end
end

--[[
function MovY(PlayerID,Dest,Source,Mode,Mask) -- 상수,V << VA / 내부함수 (사용 권장X) CPRead 미사용 버젼
	--STPopTrigArr(PlayerID)
	if Mode == "X" or Mode == nil then
		Mode = SetTo
	end
	if Mask == "X" or Mask == nil then
		Mask = 0xFFFFFFFF
	end
	if type(Dest) == "number" and Source[4] == "VA" then -- Mov Offset, VA 
		-- Ctrig->Ctrig->Ctrig Version : Cp사용 X

		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x158,5,SetTo,Source[5][1],Source[5][2],0x158,1,Source[5][3]); 
					SetCtrigX("X","X",0x17C,5,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrigX("X","X",0x198,5,SetTo,Source[5][1],Source[5][2],0x4,1,Source[5][3]); 
					SetCtrigX("X","X",0x1B8,5,SetTo,Source[5][1],Source[5][2],0x148,1,Source[5][3]); 
					SetCtrigX("X","X",0x1D8,5,SetTo,Source[5][1],Source[5][2],0x160,1,Source[5][3]); 
					SetCtrig1X("X","X",0x158,5,Add,Source[6]);
					SetCtrig1X("X","X",0x17C,5,Add,Source[6]*4);
					SetCtrig1X("X","X",0x198,5,Add,Source[6]);
					SetCtrig1X("X","X",0x1B8,5,Add,Source[6]);
					SetCtrig1X("X","X",0x1D8,5,Add,Source[6]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x158,1,5); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x198,1,4); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x1B8,1,3); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x1D8,1,2); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x17C,1,1); 
					CallLabelAlways(Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetDeaths(0,SetTo,EPD(Dest),0);	-- SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(Dest));
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0,0,Source[3]);
					SetCtrig2X(0,SetTo,"X","X",0,0,1); -- SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0,0,1);
					SetDeaths(0,SetTo,Mask,0); -- SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
					SetDeathsX(0,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
				},
				flag = {Preserved}
			}
	elseif Dest[4] == "V" and Source[4] == "VA" then -- Mov V, VA / MovY(PlayerID,{"X",Temp,0,"V"},{"X",Temp,0,"VA",VArray,0,"X",Temp+1,0})
		-- Ctrig->Ctrig->Ctrig Version : Cp사용 X

		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x158,5,SetTo,Source[5][1],Source[5][2],0x158,1,Source[5][3]); 
					SetCtrigX("X","X",0x17C,5,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrigX("X","X",0x198,5,SetTo,Source[5][1],Source[5][2],0x4,1,Source[5][3]); 
					SetCtrigX("X","X",0x1B8,5,SetTo,Source[5][1],Source[5][2],0x148,1,Source[5][3]); 
					SetCtrigX("X","X",0x1D8,5,SetTo,Source[5][1],Source[5][2],0x160,1,Source[5][3]); 
					SetCtrig1X("X","X",0x158,5,Add,Source[6]);
					SetCtrig1X("X","X",0x17C,5,Add,Source[6]*4);
					SetCtrig1X("X","X",0x198,5,Add,Source[6]);
					SetCtrig1X("X","X",0x1B8,5,Add,Source[6]);
					SetCtrig1X("X","X",0x1D8,5,Add,Source[6]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x158,1,5); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x198,1,4); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x1B8,1,3); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x1D8,1,2); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x17C,1,1); 
					CallLabelAlways(Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0,0,Source[3]);
					SetCtrig2X(0,SetTo,"X","X",0,0,1); -- SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0,0,1);
					SetDeaths(0,SetTo,Mask,0); -- SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
					SetDeathsX(0,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
				},
				flag = {Preserved}
			}
	else
		MovY_InputData_Error()
	end
end
]]-- 
function MovY(PlayerID,Dest,Source,Type,Mask) -- 상수 Mem V VA A << W 전용 내부함수
	--STPopTrigArr(PlayerID)

	if type(Type[1]) == "number" or Type[1] == "Mem" or Type[1] == "V" then
		if type(Type[2]) == "number" or Type[2] == "Mem" or Type[2] == "V" then
			local Box = {}

			for i = 1, 2 do
				if type(Type[i]) == "number" then
					table.insert(Box,SetCtrig1X(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,EPD(Dest[i])))
				elseif Type[i] == "Mem" then
					table.insert(Box,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][1],Dest[i][2],Dest[i][3],1,Dest[i][4]))
				elseif Type[i] == "V" then
					if Clear == 1 then
						table.insert(Box,SetCtrig1X(Dest[i][1],Dest[i][2],0x15C,Dest[i][3],SetTo,0))
					end
					table.insert(Box,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][1],Dest[i][2],0x15C,1,Dest[i][3]))
				end
			end

			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					Box,
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
		elseif Type[2] == "VA" or Type[2] == "A" then
			local Box = {}
			for i = 1, 1 do
				if type(Type[i]) == "number" then
					table.insert(Box,SetCtrig1X(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,EPD(Dest[i])))
				elseif Type[i] == "Mem" then
					table.insert(Box,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][1],Dest[i][2],Dest[i][3],1,Dest[i][4]))
				elseif Type[i] == "V" then
					if Clear == 1 then
						table.insert(Box,SetCtrig1X(Dest[i][1],Dest[i][2],0x15C,Dest[i][3],SetTo,0))
					end
					table.insert(Box,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][1],Dest[i][2],0x15C,1,Dest[i][3]))
				end
			end

			local Box2 = {}
			for i = 2, 2 do
				if Type[i] == "VA" then
					table.insert(Box2,SetCtrigX(Dest[i][1],Dest[i][2],0x158,Dest[i][3],SetTo,Source[1],Source[2],0x158+0x40*(i-1),1,Source[3]))
					table.insert(Box2,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][5][1],Dest[i][5][2],0x15C,1,Dest[i][5][3]))
					table.insert(Box2,SetCtrig1X(Source[1],Source[2],0x158+0x40*(i-1),Source[3],Add,Dest[i][6]))
				elseif Type[i] == "A" then
					table.insert(Box2,SetCtrigX(Dest[i][1],Dest[i][2],0x158,Dest[i][3],SetTo,Source[1],Source[2],0x158+0x40*(i-1),1,Source[3]))
					table.insert(Box2,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][5][1],Dest[i][5][2],Dest[i][5][3],1,0))
				end
			end

			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					Box,
					SetCtrig1X(Dest[2][1],Dest[2][2],0x148,Dest[2][3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[2][1],Dest[2][2],0x160,Dest[2][3],SetTo,Add*16777216,0xFF000000);
					Box2,
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways2(Dest[2][1],Dest[2][2],Dest[2][3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
		end
	elseif Type[1] == "VA" or Type[1] == "A" then
		if type(Type[2]) == "number" or Type[2] == "Mem" or Type[2] == "V" then
			local Box = {}
			for i = 2, 2 do
				if type(Type[i]) == "number" then
					table.insert(Box,SetCtrig1X(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,EPD(Dest[i])))
				elseif Type[i] == "Mem" then
					table.insert(Box,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][1],Dest[i][2],Dest[i][3],1,Dest[i][4]))
				elseif Type[i] == "V" then
					if Clear == 1 then
						table.insert(Box,SetCtrig1X(Dest[i][1],Dest[i][2],0x15C,Dest[i][3],SetTo,0))
					end
					table.insert(Box,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][1],Dest[i][2],0x15C,1,Dest[i][3]))
				end
			end

			local Box2 = {}
			for i = 1, 1 do
				if Type[i] == "VA" then
					table.insert(Box2,SetCtrigX(Dest[i][1],Dest[i][2],0x158,Dest[i][3],SetTo,Source[1],Source[2],0x158+0x40*(i-1),1,Source[3]))
					table.insert(Box2,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][5][1],Dest[i][5][2],0x15C,1,Dest[i][5][3]))
					table.insert(Box2,SetCtrig1X(Source[1],Source[2],0x158+0x40*(i-1),Source[3],Add,Dest[i][6]))
				elseif Type[i] == "A" then
					table.insert(Box2,SetCtrigX(Dest[i][1],Dest[i][2],0x158,Dest[i][3],SetTo,Source[1],Source[2],0x158+0x40*(i-1),1,Source[3]))
					table.insert(Box2,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][5][1],Dest[i][5][2],Dest[i][5][3],1,0))
				end
			end

			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					Box,
					SetCtrig1X(Dest[1][1],Dest[1][2],0x148,Dest[1][3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1][1],Dest[1][2],0x160,Dest[1][3],SetTo,Add*16777216,0xFF000000);
					Box2,
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways2(Dest[1][1],Dest[1][2],Dest[1][3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
		elseif Type[2] == "VA" or Type[2] == "A" then
			local Box2 = {}
			for i = 1, 2 do
				if Type[i] == "VA" then
					table.insert(Box2,SetCtrigX(Dest[i][1],Dest[i][2],0x158,Dest[i][3],SetTo,Source[1],Source[2],0x158+0x40*(i-1),1,Source[3]))
					table.insert(Box2,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][5][1],Dest[i][5][2],0x15C,1,Dest[i][5][3]))
					table.insert(Box2,SetCtrig1X(Source[1],Source[2],0x158+0x40*(i-1),Source[3],Add,Dest[i][6]))
				elseif Type[i] == "A" then
					table.insert(Box2,SetCtrigX(Dest[i][1],Dest[i][2],0x158,Dest[i][3],SetTo,Source[1],Source[2],0x158+0x40*(i-1),1,Source[3]))
					table.insert(Box2,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][5][1],Dest[i][5][2],Dest[i][5][3],1,0))
				end
			end

			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Dest[1][1],Dest[1][2],0x148,Dest[1][3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1][1],Dest[1][2],0x160,Dest[1][3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Dest[2][1],Dest[2][2],0x148,Dest[2][3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[2][1],Dest[2][2],0x160,Dest[2][3],SetTo,Add*16777216,0xFF000000);
					Box2,
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways3(Dest[1][1],Dest[1][2],Dest[1][3],Dest[2][1],Dest[2][2],Dest[2][3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
		end
	end
end

function MovZ(PlayerID,Dest,Source,Address) -- V << LA_EPD, VA_EPD, A_EPD / W << WA_EPD, LA_EPD / 내부함수 (사용 권장X)
	--STPopTrigArr(PlayerID)
	if Address == nil then
		Address = 0
	end
	if Dest[4] == "V" and Source[4] == "VA" then -- Mov V, VA_EPD / {Index[1],Index[2],Index[3],"VA",VArray(VAPlayer,VAIndex,0),Index[5]}
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address,1,Source[5][3]); 
					SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	elseif Dest[4] == "V" and Source[4] == "A" then -- Mov V, A_EPD / {Index[1],Index[2],Index[3],"A",Array(APlayer,AIndex,0)}
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	elseif Dest[4] == "W" and Source[4] == "WA" then -- Mov W, WA_EPD / {Index[1],Index[2],Index[3],"WA",WArray(WAPlayer,WAIndex,0)}
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address,1,Source[5][3]); 
					SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5][1],Source[5][2],Address,1,Source[5][3]); 
					SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]);
					SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],Add,Source[6]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
					SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	elseif Dest[4] == "V" and Source[4] == "LA_V" then -- Mov V, LA_EPD (2번 사용 필요)/ {Index[1],Index[2],Index[3],"LA",WArray(LAPlayer,LAIndex,0)}
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	elseif Dest[4] == "W" and Source[4] == "LA_V" then -- Mov W, LA_EPD / {Index[1],Index[2],Index[3],"LA",WArray(LAPlayer,LAIndex,0)}
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3]+0x4,1,0); 
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	elseif Dest[4] == "W" and Source[4] == "LA_W" then -- Mov W, LA_EPD / {Index[1],Index[2],Index[3],"LA",LArray(LAPlayer,LAIndex,0)}
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
					SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3]+0x4,1,0); 
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
					SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	elseif #Dest == 2 and Dest[1][4] == "V" and Dest[2][4] == "V" and Source[4] == "LA_V" then
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1][1],Dest[1][2],0x15C,Dest[1][3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1][1],Dest[1][2],0x15C,1,Dest[1][3]); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[2][1],Dest[2][2],0x15C,Dest[2][3],SetTo,Source[5][1],Source[5][2],Source[5][3]+0x4,1,0); 
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[2][1],Dest[2][2],0x15C,1,Dest[2][3]); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	elseif #Dest == 2 and Dest[1][4] == "V" and Dest[2][4] == "V" and Source[4] == "LA_W" then
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1][1],Dest[1][2],0x15C,Dest[1][3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
					SetCtrigX(Dest[2][1],Dest[2][2],0x15C,Dest[2][3],SetTo,Source[5][1],Source[5][2],Source[5][3]+0x4,1,0); 
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1][1],Dest[1][2],0x15C,1,Dest[1][3]); 
					SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[2][1],Dest[2][2],0x15C,1,Dest[2][3]); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	else
		MovZ_InputData_Error()
	end
end

function TMem(PlayerID,Dest,Source,Address,Next,OffsetFlag) -- V << V_EPD/Offset, Mem_EPD/Offset, A_EPD/Offset, VA_EPD/Offset, WA_EPD/Offset, LA_EPD/Offset, W_EPD/Offset
	STPopTrigArr(PlayerID)
	if OffsetFlag == "X" or OffsetFlag == nil then
		OffsetFlag = 0
	end
	if Address == "X" or Address == nil then
		Address = 0x15C
	end
	if Next == "X" or Next == nil then
		Next = 0
	end

	if Dest[4] == "V" then
		if Source[4] == "V" then
			if Source[3] == nil or Source[3] == "X" then
				Source[3] = 0 
			end
			if OffsetFlag == 0 then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Address,1,Source[3]+Next); 
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Address,0,Source[3]+Next); 
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "W" then
			if Source[3] == nil or Source[3] == "X" then
				Source[3] = 0 
			end
			if OffsetFlag == 0 then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Address,1,Source[3]+Next); 
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Address,0,Source[3]+Next); 
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "A" then
			if OffsetFlag == 0 then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0);
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1452249);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
						SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
						SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "VA" then
			if OffsetFlag == 0 then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address,1,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address,0,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]*4);
						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						CallLabelAlways(Source[7],Source[8],Source[9]);
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "WA" then 
			if OffsetFlag == 0 then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address,1,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,0); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address,0,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]*4);
						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrig1X(Source[7],Source[8],0x158,Source[9],SetTo,0); 
						CallLabelAlways(Source[7],Source[8],Source[9]);
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "LA_V" then
			if OffsetFlag == 0 then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0);
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1452249);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
						SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
						SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "LA_W" then
			if OffsetFlag == 0 then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1452249);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
						SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
						SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
			end
		else
			if OffsetFlag == 0 then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Source[3],1,Source[4]); 
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Source[3],0,Source[4]); 
					},
					flag = {Preserved}
				}
			end
		end
	else
		_TMem_InputData_Error()
	end
end

function TLMem(PlayerID,Dest,Source,Address,Next,OffsetFlag) -- W << V_EPD/Offset, Mem_EPD/Offset, A_EPD/Offset, VA_EPD/Offset, WA_EPD/Offset, LA_EPD/Offset, W_EPD/Offset
	STPopTrigArr(PlayerID)
	if OffsetFlag == "X" or OffsetFlag == nil then
		OffsetFlag = 0
	end
	local AddressN
	if Address == "X" or Address == nil then
		Address = {0x15C,0x15C}
		AddressN = 1
	end
	if Next == "X" or Next == nil then
		Next = 0
	end

	if Dest[4] == "W" then
		if Source[4] == "V" then
			if Source[3] == nil or Source[3] == "X" then
				Source[3] = 0 
			end
			if OffsetFlag == 0 then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Address[1],1,Source[3]+Next); 
						SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[1],Source[2],Address[2],1,Source[3]+Next); 
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Address[1],0,Source[3]+Next); 
						SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[1],Source[2],Address[2],0,Source[3]+Next); 
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "W" then
			if AddressN == 1 then
				Address[2] = 0x19C
			end
			if Source[3] == nil or Source[3] == "X" then
				Source[3] = 0 
			end
			if OffsetFlag == 0 then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Address[1],1,Source[3]+Next); 
						SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[1],Source[2],Address[2],1,Source[3]+Next); 
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Address[1],0,Source[3]+Next); 
						SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[1],Source[2],Address[2],0,Source[3]+Next); 
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "A" then
			if OffsetFlag == 0 then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0);
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1452249);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x198,Dest[3],SetTo,0); 
						SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
						SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
						SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "VA" then
			if OffsetFlag == 0 then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address[1],1,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5][1],Source[5][2],Address[2],1,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],Add,Source[6]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address[1],0,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]*4);
						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						CallLabelAlways(Source[7],Source[8],Source[9]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5][1],Source[5][2],Address[2],0,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],Add,Source[6]*4);
						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						CallLabelAlways(Source[7],Source[8],Source[9]);
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "WA" then 
			if AddressN == 1 then
				Address[2] = 0x19C
			end
			if OffsetFlag == 0 then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address[1],1,Source[5][3]+Next); 
						SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5][1],Source[5][2],Address[2],1,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],Add,Source[6]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address[1],0,Source[5][3]+Next); 
						SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5][1],Source[5][2],Address[2],0,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]*4);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],Add,Source[6]*4);
						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x188,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[7],Source[8],0x1A0,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrigX(Source[7],Source[8],0x198,Source[9],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						CallLabelAlways(Source[7],Source[8],Source[9]);
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "LA_V" then
			if OffsetFlag == 0 then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,1);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x198,Dest[3],SetTo,0); 
						SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
						SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
						SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,1);
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1452249);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x198,Dest[3],SetTo,0); 
						SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
						SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
						SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "LA_W" then
			if OffsetFlag == 0 then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
						SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3]+0x4,1,0); 
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
						SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3]+0x4,1,0); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1452249);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],Add,1452249);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
						SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
						SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
			end
		else
			if #Source == 2 then
				if OffsetFlag == 0 then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1][1],Source[1][2],Source[1][3],1,Source[1][4]); 
							SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[2][1],Source[2][2],Source[2][3],1,Source[2][4]); 
						},
						flag = {Preserved}
					}
				else
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1][1],Source[1][2],Source[1][3],0,Source[1][4]); 
							SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[2][1],Source[2][2],Source[2][3],0,Source[2][4]); 
						},
						flag = {Preserved}
					}
				end
			else
				if OffsetFlag == 0 then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Source[3],1,Source[4]); 
							SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[1],Source[2],Source[3],1,Source[4]); 
						},
						flag = {Preserved}
					}
				else
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Source[3],0,Source[4]); 
							SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[1],Source[2],Source[3],0,Source[4]); 
						},
						flag = {Preserved}
					}
				end
			end
		end
	else
		_TLMem_InputData_Error()
	end
end

function CMovX(PlayerID,Dest,Source,Mode,Mask,Deviation,Clear) -- V << VA / VA,A << V (Value)
	STPopTrigArr(PlayerID)
	if Deviation == "X" or Deviation == nil then
		Deviation = 0
	end
	if Mode == "X" or Mode == nil then
		Mode = SetTo
	end
	if Mask == "X" or Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local Mask2 = Mask
	if Clear == 1 then
		Mask2 = 0xFFFFFFFF
	end

	if type(Dest) == "number" and Source[4] == "VA" then -- Mov V, VA / {Index[1],Index[2],Index[3],"VA",VArray(VAPlayer,VAIndex,0),Index[5]}
		Trigger {--(CPRead)로 값 출력
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
					SetMemoryX(Dest,SetTo,Deviation,Mask);

					SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
					SetMemory(0x6509B0,Add,Source[6]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
					CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetDeaths(CurrentPlayer,SetTo,EPD(Dest),0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);

				},
				flag = {Preserved}
			}

		RecoverCp(PlayerID)
	elseif type(Dest[4]) ~= "string" and Source[4] == "VA" then -- Mov Mem, VA / {Index[1],Index[2],Index[3],"VA",VArray(VAPlayer,VAIndex,0),Index[5]}
		Trigger {--(CPRead)로 값 출력
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
					SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation,Mask);

					SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
					SetMemory(0x6509B0,Add,Source[6]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
					CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);

				},
				flag = {Preserved}
			}

		RecoverCp(PlayerID)
	elseif Dest[4] == "V" and Source[4] == "VA" then -- Mov V, VA / {Index[1],Index[2],Index[3],"VA",VArray(VAPlayer,VAIndex,0),Index[5]}
		Trigger {--(CPRead)로 값 출력
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
					SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2);

					SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
					SetMemory(0x6509B0,Add,Source[6]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
					CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);

				},
				flag = {Preserved}
			}

		RecoverCp(PlayerID)
	elseif Dest[4] == "VA" then -- Mov VA, V 
		if type(Source) == "number" then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x158,1,SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
					SetCtrig1X("X","X",0x158,1,Add,Dest[6]);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
					CallLabelAlways(Dest[1],Dest[2],Dest[3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetMemoryX(0,SetTo,Source,Mask); 
				},
				flag = {Preserved}
			}
		elseif Source[4] == "V" then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],Add,Dest[6]);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,Deviation);
					CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,-Deviation);
				},
				flag = {Preserved}
			}
		elseif Source[4] == "VA" then
			Trigger {--(CPRead)로 값 출력
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1);

						SetCtrigX("X","X",0x19C,1,SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
						SetCtrig1X("X","X",0x19C,1,Add,Dest[6]);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x19C,1,1);
						CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}

			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148)/4);
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x15C-0x160)/4);
						SetDeaths(CurrentPlayer,Add,Deviation,0); 
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeaths(CurrentPlayer,Add,-Deviation,0); 
					},
					flag = {Preserved}
				}

			RecoverCp(PlayerID)
		end
	elseif Dest[4] == "A" then -- Mov A, V 
		if type(Source) == "number" then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x158,1,SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1); 
					CallLabelAlways(Dest[1],Dest[2],Dest[3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetMemoryX(0,Mode,Source,Mask); 
				},
				flag = {Preserved}
			}
		elseif Source[4] == "V" then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,Deviation);
					CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,-Deviation);
				},
				flag = {Preserved}
			}
		elseif Source[4] == "VA" then
			Trigger {--(CPRead)로 값 출력
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1);

						SetCtrigX("X","X",0x19C,1,SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x19C,1,1);
						CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}

			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148)/4);
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x15C-0x160)/4);
						SetDeaths(CurrentPlayer,Add,Deviation,0); 
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeaths(CurrentPlayer,Add,-Deviation,0); 
					},
					flag = {Preserved}
				}

			RecoverCp(PlayerID)
		end
	else
		CMovX_InputData_Error()
	end
end

-- CurrentPlayer 관련 함수 / CunitCtrig -------------------------------------------------------------

function RecoverCp(PlayerID)
	if DetectRecoverCp == 1 then
		_G["\n- RecoverCp() Detected! -\n"]() 
	end
	if RecoverCpValue == "X" then	
		PlayerID = PlayerConvert(PlayerID)
		for k, P in pairs(PlayerID) do
			Trigger {
				players = {P},
				conditions = {
					Label(0);
				},
				actions = {
					SetMemory(0x6509B0,SetTo,P);
				},
				flag = {Preserved}
			}	
		end
	elseif type(RecoverCpValue) == "number" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetMemory(0x6509B0,SetTo,RecoverCpValue);
				},
				flag = {Preserved}
			}	
	elseif RecoverCpValue[4] == "V" then -- 변수입력 Vi 가능
		if RecoverCpValue[5] == nil then
			RecoverCpValue[5] = 0
		end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetMemory(0x6509B0,SetTo,RecoverCpValue[5]);
					SetCtrig1X(RecoverCpValue[1],RecoverCpValue[2],0x158,RecoverCpValue[3],SetTo,EPD(0x6509B0));
					SetCtrig1X(RecoverCpValue[1],RecoverCpValue[2],0x148,RecoverCpValue[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(RecoverCpValue[1],RecoverCpValue[2],0x160,RecoverCpValue[3],SetTo,Add*16777216,0xFF000000);
					CallLabelAlways(RecoverCpValue[1],RecoverCpValue[2],RecoverCpValue[3]);
				},
				flag = {Preserved}
			}	
	end
end

function SetRecoverCp(Cp)
	if Cp == nil then
		Cp = "X"
	end
	RecoverCpValue = Cp
end

function MoveCp(Type,Value)
	local CpValue
	local CpRet
	if Type == nil then
		CpRet = MoveCpValue
	else
		if Type == Add then
			CpValue = Value/4
			MoveCpValue = MoveCpValue + Value
			CpRet = SetMemory(0x6509B0,Add,CpValue)
		elseif Type == Subtract then
			CpValue = (0-Value)/4
			MoveCpValue = MoveCpValue - Value
			CpRet = SetMemory(0x6509B0,Add,CpValue)
		elseif Type == SetTo then
			CpValue = (Value-MoveCpValue)/4
			MoveCpValue = Value
			CpRet = SetMemory(0x6509B0,Add,CpValue)
		elseif Type == "X" or Type == "Clear" then
			if Value == nil then
				Value = 0
			end
			MoveCpValue = Value
			CpRet = nil
		end
	end
	return CpRet
end

function SaveCp(PlayerID,Output,OffsetOutput)
	if OffsetOutput == "X" then
		OffsetOutput = nil
	end
	if Output == "X" then
		Output = nil
	end

	local CPRead1 = {}
	if Output[4] == "V" then
		table.insert(CPRead1,SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,0))
	elseif Output[4] == "VA" then
		SaveCp_InputData_Error() 
	end
	if OffsetOutput ~= nil then
		if OffsetOutput[4] == "V" then
			table.insert(CPRead1,SetCtrig1X(OffsetOutput[1],OffsetOutput[2],0x15C,OffsetOutput[3],SetTo,0x58A364))
		elseif OffsetOutput[4] == "VA" then
			SaveCp_InputData_Error() 
		end
	end
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = { 
			Label(0);
		},
		actions = {
			CPRead1,
		},
		flag = {Preserved}
		
	}
	for i = 0, 31 do
		local CPRead2 = {}
		local CBit = 2^i
		if Output[4] == "V" then
			table.insert(CPRead2,SetCtrig1X(Output[1],Output[2],0x15C,Output[3],Add,CBit)) 
		elseif Output[4] == "VA" then
			SaveCp_InputData_Error() 
		end
		if OffsetOutput ~= nil then
			if OffsetOutput[4] == "V" and i <= 29 then
				table.insert(CPRead2,SetCtrig1X(OffsetOutput[1],OffsetOutput[2],0x15C,OffsetOutput[3],Add,CBit*4))
			elseif OffsetOutput[4] == "VA" then
				SaveCp_InputData_Error() 
			end
		end
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			   	MemoryX(0x6509B0,Exactly,CBit,CBit);
			},
			actions = {
				CPRead2,
			},
			flag = {Preserved}
		}
	end
end

function LoadCp(PlayerID,Cp)
	SetRecoverCp(Cp)
	RecoverCp(PlayerID)
end

function LoadCpX(PlayerID,Cp)
	local TempCp = RecoverCpValue
	SetRecoverCp(Cp)
	RecoverCp(PlayerID)
	SetRecoverCp(TempCp)
end

function CunitCtrig_Part1(PlayerID,Actions)
	Trigger { -- Cunit Ctrig Start
		players = {ParsePlayer(PlayerID)},
		conditions = { 
			Label(0);
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+2,0,0,1); 
		},
		flag = {Preserved}
	}	
	Trigger { -- Cunit Calc Selector
		players = {ParsePlayer(PlayerID)},
		conditions = { 
			Label(FuncAlloc);
		},
		actions = {
			SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- RecoverNext
			Actions,
		},
		flag = {Preserved}
	}	
	PlayerID = PlayerConvert(PlayerID)
	table.insert(CCArr, FuncAlloc)
	table.insert(CCPArr, PlayerID)
	CCptr = CCptr + 1
	FuncAlloc = FuncAlloc + 3
end
-- NJump Trig 삽입 부분 (조건만족시 Jump)
function CunitCtrig_Part2()
	PlayerID = CCPArr[CCptr]
	PlayerID = PlayerConvert(PlayerID)
	for k, P in pairs(PlayerID) do
		Trigger { -- Cunit Calc Last
			players = {P},
			conditions = { 
				Label(CCArr[CCptr]+1);
			},
		   	actions = {
				SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- RecoverNext
				SetMemory(0x6509B0,SetTo,P); -- 루프를 돌릴 플레이어 값으로 맞추기 ( P1 = 0, P2 = 1, ... , P8 = 7 )
			},
			flag = {Preserved}
		}	
	end
end
-- Cunit 연산 트리거 삽입 부분 (Break/Clear로 Return)
function CunitCtrig_Part3(Conditions,Actions)
	PlayerID = CCPArr[CCptr]
	Trigger { -- Cunit Calc Start
		players = {ParsePlayer(PlayerID)},
		conditions = { 
			Label(CCArr[CCptr]+2);
		},
		flag = {Preserved}
	}	

	for i = 0 , 1699 do
		MoveCpValue = 0
		Trigger { -- Cunit Calc Main
			players = {ParsePlayer(PlayerID)},
			conditions = { 
				Label(0);
				Conditions,
			},
			actions = { 
				SetCtrigX("X","X",0x4,0,SetTo,"X",CCArr[CCptr],0,0,0);
				SetCtrigX("X",CCArr[CCptr]+1,0x4,0,SetTo,"X","X",0,0,1);
				SetCtrigX("X",CCArr[CCptr],0x158,0,SetTo,"X","X",0x4,1,0);
				SetCtrigX("X",CCArr[CCptr],0x15C,0,SetTo,"X","X",0,0,1);
				SetMemory(0x6509B0,SetTo,161741 - 84 * i);
				Actions,
				},
			flag = {Preserved}
		}	
	end
	table.remove(CCArr,CCptr)
	table.remove(CCPArr,CCptr)
	CCptr = CCptr - 1
end

function CunitCtrig_Part3X()
	MoveCpValue = 0
	PlayerID = CCPArr[CCptr]
	Trigger { -- Cunit Calc Start
		players = {ParsePlayer(PlayerID)},
		conditions = { 
			Label(CCArr[CCptr]+2);
		},
		flag = {Preserved}
	}	
end

function CunitCtrig_Part4X(LoopIndex,Conditions,Actions)
	MoveCpValue = 0
	Trigger { -- Cunit Calc Main
		players = {ParsePlayer(PlayerID)},
		conditions = { 
			Label(0);
			Conditions,
		},
		actions = { 
			SetCtrigX("X","X",0x4,0,SetTo,"X",CCArr[CCptr],0,0,0);
			SetCtrigX("X",CCArr[CCptr]+1,0x4,0,SetTo,"X","X",0,0,1);
			SetCtrigX("X",CCArr[CCptr],0x158,0,SetTo,"X","X",0x4,1,0);
			SetCtrigX("X",CCArr[CCptr],0x15C,0,SetTo,"X","X",0,0,1);
			SetMemory(0x6509B0,SetTo,161741 - 84 * LoopIndex);
			Actions,
			},
		flag = {Preserved}
	}		
end

function CunitCtrig_End()
	table.remove(CCArr,CCptr)
	table.remove(CCPArr,CCptr)
	CCptr = CCptr - 1
end
	
function ClearCalc()
	PlayerID = CCPArr[CCptr]
	Trigger { -- Cunit Calc End
		players = {ParsePlayer(PlayerID)},
		conditions = { 
			Label(0);
		}, 
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",CCArr[CCptr]+1,0,0,0);
		},
		flag = {Preserved}
	}	
end

function BreakCalc(Conditions,Actions)	
	PlayerID = CCPArr[CCptr]
	STPopTrigArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,3)

	Trigger { -- Cunit Calc Break
		players = {ParsePlayer(PlayerID)},
		conditions = { 
			Label(0);
			Conditions,
		}, 
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",CCArr[CCptr]+1,0,0,0);
			SetCtrigX("X",CCArr[CCptr]+1,0x158,0,SetTo,"X","X",0x4,1,0);
			SetCtrigX("X",CCArr[CCptr]+1,0x15C,0,SetTo,"X","X",0,0,1);
			Actions,
		},
		flag = {Preserved}
	}	
end

-- 변수/배열 선언/호출 함수 -----------------------------------------------------------------

function CVariable(Player,Index)
	Trigger {
				players = {ParsePlayer(Player)},
				conditions = {
					Label(Index);
				},
				actions = {
					SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
end

function CVariable2(Player,Index,Offset,Type,Value,Mask)
	if Offset == "X" then 
		Offset = nil
	end
	if Type == "X" then 
		Type = nil
	end
	if Mask == "X" then 
		Mask = nil
	end
	if Value == "X" then 
		Value = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	if Offset == nil then
		Offset = 0x58A364
	end
	if Type == nil then
		Type = SetTo
	end
	if Value == nil then
		Value = 0
	end
	Trigger {
				players = {ParsePlayer(Player)},
				conditions = {
					Label(Index);
				},
				actions = {
					SetDeathsX(EPD(Offset),Type,Value,0,Mask); -- Full Variable
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
end




function CVariable3(Player,Index,Offset,Type,Player2,Index2,Address2,EPD2,Next2,Mask)
	if Offset == "X" then 
		Offset = nil
	end
	if Type == "X" then 
		Type = nil
	end
	if Mask == "X" then 
		Mask = nil
	end


	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	if Offset == nil then
		Offset = 0x58A364
	end
	if Type == nil then
		Type = SetTo
	end
	Trigger {
				players = {ParsePlayer(Player)},
				conditions = {
					Label(Index);
				},
				actions = {
					SetCtrig2X(Offset,Type,Player2,Index2,Address2,EPD2,Next2,Mask); -- Input Value Ctirg Offset 
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
end




function CWariable(Player,Index)
	Trigger {
				players = {ParsePlayer(Player)},
				conditions = {
					Label(Index);
				},
				actions = {
					SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable Lower 32
					Disabled(FSetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)); -- Cp Add (Must be Preserved)
					SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable Upper 32
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
end

function CWariable2(Player,Index,Offset,Type,Value,Mask)
	if Offset == "X" then 
		Offset = nil
	end
	if Type == "X" then 
		Type = nil
	end
	if Mask == "X" then 
		Mask = nil
	end
	if Value == "X" then 
		Value = nil
	end

	if type(Offset) == "number" then
		Offset = {Offset,Offset+4}
	elseif type(Offset) == "table" and type(Offset[2]) == "table" then
		Offset = {Offset[1],Offset[1]+Offset[2][1]}
	elseif type(Offset) == "string" then
		Offset = I64(Offset)
	end
	if type(Type) == "number" then
		Type = {Type,Type}
	elseif type(Type) == "string" then
		Type = I64(Type)
	end
	if type(Value) == "number" then -- Type == "table" 일 경우 그대로 삽입
		Value = {Value,0} -- 32Bit Number
	elseif type(Value) == "string" then
		Value = I64(Value)
	end
	if type(Mask) == "number" then
		Mask = {Mask,Mask}
	elseif type(Mask) == "string" then
		Mask = I64(Mask)
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	end
	if Offset == nil then
		Offset = {0x58A364,0x58A364}
	end
	if Type == nil then
		Type = {SetTo,SetTo}
	end
	if Value == nil then 
		Value = {0,0}
	end

	Trigger {
				players = {ParsePlayer(Player)},
				conditions = {
					Label(Index);
				},
				actions = {
					SetDeathsX(EPD(Offset[1]),Type[1],Value[1],0,Mask[1]); -- Full Variable
					Disabled(FSetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)); -- Cp Add (Must be Preserved)
					SetDeathsX(EPD(Offset[2]),Type[2],Value[2],0,Mask[2]); -- Full Variable
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
end

function CSVariable(Player,Index,Number)
	if Number <= 0 or Number >= 17 then
		CSVariable_InputData_Error()
	end
	local Box = {}
	for i = 2, Number do
		table.insert(Box,Disabled(FSetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)))
		table.insert(Box,SetDeathsX(0,SetTo,0,0,0xFFFFFFFF))
	end
	Trigger {
				players = {ParsePlayer(Player)},
				conditions = {
					Label(Index);
				},
				actions = {
					SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable Lower 32
					Box,
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
	return {"S",Index,Number}
end

function CSVariable2(Player,Index,Number,Offset,Type,Value,Mask)
	if Number <= 0 or Number >= 17 then
		CSVariable_InputData_Error()
	end
	local Box = {}

	if Offset == "X" then 
		Offset = nil
	end
	if Type == "X" then 
		Type = nil
	end
	if Mask == "X" then 
		Mask = nil
	end
	if Value == "X" then 
		Value = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	if Offset == nil then
		Offset = 0x58A364
	end
	if Type == nil then
		Type = SetTo
	end
	if Value == nil then 
		Value = 0
	end

	local OffsetN = 0x58A364
	local TypeN = SetTo
	local ValueN = 0
	local MaskN = 0xFFFFFFFF
	local OffsetT,TypeT,ValueT,MaskT
	if type(Offset) == "number" then
		OffsetN = Offset
	end
	if type(Type) == "number" then
		TypeN = Type
	end
	if type(Value) == "number" then 
		ValueN = Value
	end
	if type(Mask) == "number" then
		MaskN = Mask
	end
	
	for i = 2, Number do
		if type(Offset) == "table" and Offset ~= nil then
			OffsetT = Offset[i]
		else
			OffsetT = OffsetN
		end
		if type(Type) == "table" and Type ~= nil then
			TypeT = Type[i]
		else
			TypeT = TypeN
		end
		if type(Value) == "table" and Value ~= nil then
			ValueT = Value[i]
		else
			ValueT = ValueN
		end
		if type(Mask) == "table" and Mask ~= nil then
			MaskT = Mask[i]
		else
			MaskT = MaskN
		end
		table.insert(Box,Disabled(FSetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)))
		table.insert(Box,SetDeathsX(EPD(OffsetT),TypeT,ValueT,0,MaskT))
	end
	if type(Offset) == "table" and Offset ~= nil then
		OffsetT = Offset[1]
	else
		OffsetT = OffsetN
	end
	if type(Type) == "table" and Type ~= nil then
		TypeT = Type[1]
	else
		TypeT = TypeN
	end
	if type(Value) == "table" and Value ~= nil then
		ValueT = Value[1]
	else
		ValueT = ValueN
	end
	if type(Mask) == "table" and Mask ~= nil then
		MaskT = Mask[1]
	else
		MaskT = MaskN
	end
	Trigger {
				players = {ParsePlayer(Player)},
				conditions = {
					Label(Index);
				},
				actions = {
					SetDeathsX(EPD(OffsetT),TypeT,ValueT,0,MaskT); -- Full Variable
					Box,
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
	return {"S",Index,Number}
end

function CallLabel1(Player,Index,Next)
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrigX(Player,Index,0x178,Next,SetTo,"X","X",0x4,1,0))
	table.insert(X,SetCtrigX(Player,Index,0x17C,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrig1X(Player,Index,0x184,Next,SetTo,0x0,0x2))
	return X
end

function CallLabel2(Player,Index,Next)
	local X = {}
	table.insert(X,SetCtrig1X(Player,Index,0x184,Next,SetTo,0x2,0x2))
	return X
end

function CallLabelAlways(Player,Index,Next)
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,"X","X",0,0,1))
	return X
end

function CallLabelAlways2(Player,Index,Next,Player2,Index2,Next2)
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,Player2,Index2,0,0,Next2))
	table.insert(X,SetCtrigX(Player2,Index2,0x4,Next2,SetTo,"X","X",0,0,1))
	return X
end

function CallLabelAlways3(Player,Index,Next,Player2,Index2,Next2,Player3,Index3,Next3)
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,Player2,Index2,0,0,Next2))
	table.insert(X,SetCtrigX(Player2,Index2,0x4,Next2,SetTo,Player3,Index3,0,0,Next3))
	table.insert(X,SetCtrigX(Player3,Index3,0x4,Next3,SetTo,"X","X",0,0,1))
	return X
end

function CallLabelAlways4(Player,Index,Next,Player2,Index2,Next2,Player3,Index3,Next3,Player4,Index4,Next4)
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,Player2,Index2,0,0,Next2))
	table.insert(X,SetCtrigX(Player2,Index2,0x4,Next2,SetTo,Player3,Index3,0,0,Next3))
	table.insert(X,SetCtrigX(Player3,Index3,0x4,Next3,SetTo,Player4,Index4,0,0,Next4))
	table.insert(X,SetCtrigX(Player4,Index4,0x4,Next4,SetTo,"X","X",0,0,1))
	return X
end

function CallLabel1X(Variable)
	local Player = Variable[1]
	local Index = Variable[2]
	local Next = Variable[3]
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrigX(Player,Index,0x178,Next,SetTo,"X","X",0x4,1,0))
	table.insert(X,SetCtrigX(Player,Index,0x17C,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrig1X(Player,Index,0x184,Next,SetTo,0x0,0x2))
	return X
end

function CallLabel2X(Variable)
	local Player = Variable[1]
	local Index = Variable[2]
	local Next = Variable[3]
	local X = {}
	table.insert(X,SetCtrig1X(Player,Index,0x184,Next,SetTo,0x2,0x2))
	return X
end

function CallLabelAlwaysX(Variable)
	local Player = Variable[1]
	local Index = Variable[2]
	local Next = Variable[3]
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,"X","X",0,0,1))
	return X
end

function CallLabelAlways2X(Variable,Variable2)
	local Player = Variable[1]
	local Index = Variable[2]
	local Next = Variable[3]
	local Player2 = Variable2[1]
	local Index2 = Variable2[2]
	local Next2 = Variable2[3]
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,Player2,Index2,0,0,Next2))
	table.insert(X,SetCtrigX(Player2,Index2,0x4,Next2,SetTo,"X","X",0,0,1))
	return X
end

function CallLabelAlways3X(Variable,Variable2,Variable3)
	local Player = Variable[1]
	local Index = Variable[2]
	local Next = Variable[3]
	local Player2 = Variable2[1]
	local Index2 = Variable2[2]
	local Next2 = Variable2[3]
	local Player3 = Variable3[1]
	local Index3 = Variable3[2]
	local Next3 = Variable3[3]
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,Player2,Index2,0,0,Next2))
	table.insert(X,SetCtrigX(Player2,Index2,0x4,Next2,SetTo,Player3,Index3,0,0,Next3))
	table.insert(X,SetCtrigX(Player3,Index3,0x4,Next3,SetTo,"X","X",0,0,1))
	return X
end

function CallLabelAlways4X(Variable,Variable2,Variable3,Variable4)
	local Player = Variable[1]
	local Index = Variable[2]
	local Next = Variable[3]
	local Player2 = Variable2[1]
	local Index2 = Variable2[2]
	local Next2 = Variable2[3]
	local Player3 = Variable3[1]
	local Index3 = Variable3[2]
	local Next3 = Variable3[3]
	local Player4 = Variable4[1]
	local Index4 = Variable4[2]
	local Next4 = Variable4[3]
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,Player2,Index2,0,0,Next2))
	table.insert(X,SetCtrigX(Player2,Index2,0x4,Next2,SetTo,Player3,Index3,0,0,Next3))
	table.insert(X,SetCtrigX(Player3,Index3,0x4,Next3,SetTo,Player4,Index4,0,0,Next4))
	table.insert(X,SetCtrigX(Player4,Index4,0x4,Next4,SetTo,"X","X",0,0,1))
	return X
end

function CallLabelAlwaysN(...)
	local X = {}
	local arg = table.pack(...)

	if arg.n == 1 then
		table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,arg[1][1],arg[1][2],0,0,arg[1][3]))
		table.insert(X,SetCtrigX(arg[1][1],arg[1][2],0x4,arg[1][3],SetTo,"X","X",0,0,1))
	else
		for k = 1, arg.n do
			if k == 1 then
				table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,arg[k][1],arg[k][2],0,0,arg[k][3]))
			elseif k == arg.n then
				table.insert(X,SetCtrigX(arg[k-1][1],arg[k-1][2],0x4,arg[k-1][3],SetTo,arg[k][1],arg[k][2],0,0,arg[k][3]))
				table.insert(X,SetCtrigX(arg[k][1],arg[k][2],0x4,arg[k][3],SetTo,"X","X",0,0,1))
			else
				table.insert(X,SetCtrigX(arg[k-1][1],arg[k-1][2],0x4,arg[k-1][3],SetTo,arg[k][1],arg[k][2],0,0,arg[k][3]))
			end
		end
	end
	return X
end

function CallVariable(PlayerID,Player,Index,Next,Conditions,Actions)
		if Next == nil then
			Next = 0
		end
		if Conditions == nil or Conditions == "X" then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabelAlways(Player,Index,Next);
					Actions,
				},
				flag = {Preserved}
			}
		else
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					Conditions,
				},
				actions = {
					CallLabel1(Player,Index,Next);
					Actions,
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabel2(Player,Index,Next);
				},
				flag = {Preserved}
			}
		end
end

function CallVariableX(PlayerID,Variable,Conditions,Actions)
		local Player = Variable[1]
		local Index = Variable[2]
		local Next = Variable[3]
		if Next == nil then
			Next = 0
		end
		if Conditions == nil or Conditions == "X" then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabelAlways(Player,Index,Next);
					Actions,
				},
				flag = {Preserved}
			}
		else
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					Conditions,
				},
				actions = {
					CallLabel1(Player,Index,Next);
					Actions,
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabel2(Player,Index,Next);
				},
				flag = {Preserved}
			}
		end
end

function LCallLabel1(Player,Index,Next)
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrigX(Player,Index,0x1B8,Next,SetTo,"X","X",0x4,1,0))
	table.insert(X,SetCtrigX(Player,Index,0x1BC,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrig1X(Player,Index,0x1C4,Next,SetTo,0x0,0x2))
	return X
end

function LCallLabel2(Player,Index,Next)
	local X = {}
	table.insert(X,SetCtrig1X(Player,Index,0x1C4,Next,SetTo,0x2,0x2))
	return X
end

function LCallLabel1X(Wariable)
	local Player = Wariable[1]
	local Index = Wariable[2]
	local Next = Wariable[3]
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrigX(Player,Index,0x1B8,Next,SetTo,"X","X",0x4,1,0))
	table.insert(X,SetCtrigX(Player,Index,0x1BC,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrig1X(Player,Index,0x1C4,Next,SetTo,0x0,0x2))
	return X
end

function LCallLabel2X(Wariable)
	local Player = Wariable[1]
	local Index = Wariable[2]
	local Next = Wariable[3]
	local X = {}
	table.insert(X,SetCtrig1X(Player,Index,0x1C4,Next,SetTo,0x2,0x2))
	return X
end

function CallWariable(PlayerID,Player,Index,Next,Conditions,Actions)
		if Next == nil then
			Next = 0
		end
		if Conditions == nil or Conditions == "X" then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabelAlways(Player,Index,Next);
					Actions,
				},
				flag = {Preserved}
			}
		else
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					Conditions,
				},
				actions = {
					LCallLabel1(Player,Index,Next);
					Actions,
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					LCallLabel2(Player,Index,Next);
				},
				flag = {Preserved}
			}
		end
end

function CallWariableX(PlayerID,Wariable,Conditions,Actions)
		local Player = Wariable[1]
		local Index = Wariable[2]
		local Next = Wariable[3]
		if Next == nil then
			Next = 0
		end
		if Conditions == nil or Conditions == "X" then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabelAlways(Player,Index,Next);
					Actions,
				},
				flag = {Preserved}
			}
		else
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					Conditions,
				},
				actions = {
					LCallLabel1(Player,Index,Next);
					Actions,
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					LCallLabel2(Player,Index,Next);
				},
				flag = {Preserved}
			}
		end
end

function SCallLabel1(Player,SVariable,Next)
	if SVariable[1] ~= "S" then
		SCallLabel_InputData_Error()
	end
	local Index = SVariable[2]
	local Distance = 0x40*(SVariable[3]-1)
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrigX(Player,Index,0x178+Distance,Next,SetTo,"X","X",0x4,1,0))
	table.insert(X,SetCtrigX(Player,Index,0x17C+Distance,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrig1X(Player,Index,0x184+Distance,Next,SetTo,0x0,0x2))
	return X
end

function SCallLabel2(Player,SVariable,Next)
	if SVariable[1] ~= "S" then
		SCallLabel_InputData_Error()
	end
	local Index = SVariable[2]
	local Distance = 0x40*(SVariable[3]-1)
	local X = {}
	table.insert(X,SetCtrig1X(Player,Index,0x184+Distance,Next,SetTo,0x2,0x2))
	return X
end

function SCallLabel1X(SVData)
	if SVData[4] ~= "SV" then
		SCallLabelX_InputData_Error()
	end
	local Player = SVData[1]
	local Index = SVData[2]
	local Next = SVData[3]
	local Distance = 0x40*(SVData[5]-1)
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrigX(Player,Index,0x178+Distance,Next,SetTo,"X","X",0x4,1,0))
	table.insert(X,SetCtrigX(Player,Index,0x17C+Distance,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrig1X(Player,Index,0x184+Distance,Next,SetTo,0x0,0x2))
	return X
end

function SCallLabel2X(SVData)
	if SVData[4] ~= "SV" then
		SCallLabelX_InputData_Error()
	end
	local Player = SVData[1]
	local Index = SVData[2]
	local Next = SVData[3]
	local Distance = 0x40*(SVData[5]-1)
	local X = {}
	table.insert(X,SetCtrig1X(Player,Index,0x184+Distance,Next,SetTo,0x2,0x2))
	return X
end

function CallSVariable(PlayerID,Player,SVariable,Next,Conditions,Actions)
		if SVariable[1] ~= "S" then
			CallSVariable_InputData_Error()
		end

		if Next == nil then
			Next = 0
		end
		if Conditions == nil or Conditions == "X" then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabelAlways(Player,SVariable[2],Next);
					Actions,
				},
				flag = {Preserved}
			}
		else
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					Conditions,
				},
				actions = {
					SCallLabel1(Player,SVariable,Next);
					Actions,
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SCallLabel2(Player,SVariable,Next);
				},
				flag = {Preserved}
			}
		end
end

function CallSVariableX(PlayerID,SVData,Conditions,Actions)
		if SVData[4] ~= "SV" then
			CallSVariableX_InputData_Error()
		end
		local Player = SVData[1]
		local Index = SVData[2]
		local Next = SVData[3]

		if Next == nil then
			Next = 0
		end
		if Conditions == nil or Conditions == "X" then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabelAlways(Player,Index,Next);
					Actions,
				},
				flag = {Preserved}
			}
		else
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					Conditions,
				},
				actions = {
					SCallLabel1X(SVData);
					Actions,
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SCallLabel2X(SVData);
				},
				flag = {Preserved}
			}
		end
end

function CDb(PlayerID,ByteSize)
	if bit32.band(ByteSize, 0xFFFFFFFF) >= 0x1000000 or ByteSize == 0 then
		Db_Size_Overflow()
	end
	return CArray(PlayerID,ByteSize/4)
end

function CArray(PlayerID,Size)
	if bit32.band(Size, 0xFFFFFFFF) >= 4096*602 or Size == 0 then
		Array_Size_Overflow()
	end

	local TNum = Size/602
	if Size%602 ~= 0 then
		TNum = TNum + 1
	end
	local Arrindex = FuncAlloc

	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(Arrindex);
		},
		flag = {Preserved}
	}

	for i = 2, TNum do 
		Trigger {
			players = {ParsePlayer(PlayerID)},
			flag = {Preserved}
		}
	end

	FuncAlloc = FuncAlloc + 1
	return {"X",Arrindex,0,0}
end

function LDb(PlayerID,ByteSize)
	if bit32.band(ByteSize, 0xFFFFFFFF) >= 0x400000 or ByteSize == 0 then
		LDb_Size_Overflow()
	end
	return LArray(PlayerID,ByteSize/4)
end

function LArray(PlayerID,Size)
	if bit32.band(Size, 0xFFFFFFFF) >= 4096*151 or Size == 0 then
		LArray_Size_Overflow()
	end

	local TNum = math.ceil(Size/151)
	local Arrindex = FuncAlloc

	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(Arrindex);
		},
		flag = {Preserved}
	}

	for i = 2, TNum do 
		Trigger {
			players = {ParsePlayer(PlayerID)},
			flag = {Preserved}
		}
	end

	FuncAlloc = FuncAlloc + 1
	return {"X",Arrindex,0,0}
end

function CVArray(PlayerID,Size)
	if bit32.band(Size, 0xFFFFFFFF) >= 4096 or Size == 0 then
		VArray_Size_Overflow()
	end

	local VArrindex = FuncAlloc

	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(VArrindex);
		},
		actions = {
			SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
			Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
		},
		flag = {Preserved}
	}

	for i = 2, Size do 
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
				Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
			},
			flag = {Preserved}
		}
	end

	FuncAlloc = FuncAlloc + 1
	return {"X",VArrindex,0,"V",0,Size}
end

function CWArray(PlayerID,Size)
	if bit32.band(Size, 0xFFFFFFFF) >= 4096 or Size == 0 then
		WArray_Size_Overflow()
	end

	local WArrindex = FuncAlloc

	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(WArrindex);
		},
		actions = {
			SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
			Disabled(FSetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)); -- Cp Add (Must be Preserved)
			SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
			Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
		},
		flag = {Preserved}
	}

	for i = 2, Size do 
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
				Disabled(FSetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)); -- Cp Add (Must be Preserved)
				SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
				Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
			},
			flag = {Preserved}
		}
	end

	FuncAlloc = FuncAlloc + 1
	return {"X",WArrindex,0,"W",0,Size}
end

function SVArray(PlayerID,Size,Number)
	if Number <= 0 or Number >= 17 then
		SVariable_InputData_Error()
	end
	if bit32.band(Size, 0xFFFFFFFF) >= 4096 or Size == 0 then
		SVArray_Size_Overflow()
	end

	local SVArrindex = FuncAlloc
	local Box = {}
	for i = 2, Number do
		table.insert(Box,Disabled(FSetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)))
		table.insert(Box,SetDeathsX(0,SetTo,0,0,0xFFFFFFFF))
	end
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(SVArrindex);
		},
		actions = {
			SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable Lower 32
			Box,
			Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
		},
		flag = {Preserved}
	}
	for i = 2, Size do 
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable Lower 32
				Box,
				Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
			},
			flag = {Preserved}
		}
	end

	FuncAlloc = FuncAlloc + 1
	return {"X",SVArrindex,0,"SA",Number,Size}
end
-- DoActions류 함수 -------------------------------------------------------------------

function DoActions(PlayerID,Actions,flag)
	local X = {}
	if flag == nil then
		table.insert(X,PreserveTrigger())
	end
	Trigger {
		players = {ParsePlayer(PlayerID)},
		actions = {
			Actions,
			X,
		},
	}
end

function DoActions2(PlayerID,Actions,flag)
	local k = 1
	local Size = #Actions

	local Y = {}
	if flag == nil then
		table.insert(Y,PreserveTrigger())
	end

	while k <= Size do
		if Size - k + 1 >= 63 then
			local X = {}
			for i = 0, 62 do
				table.insert(X, Actions[k])
				k = k + 1
			end
			Trigger {
					players = {ParsePlayer(PlayerID)},
					actions = {
						X,
						Y,
					},
				}
		else
			local X = {}
			repeat
				table.insert(X, Actions[k])
				k = k + 1
			until k == Size + 1
			Trigger {
					players = {ParsePlayer(PlayerID)},
					actions = {
						X,
						Y,
					},
				}
		end
	end
end

function DoActionsX(PlayerID,Actions,flag,Index)
	if Index == nil then
		Index = 0
	end
	local X = {}
	if flag == nil then
		table.insert(X,PreserveTrigger())
	end
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(Index);
		},
		actions = {
			Actions,
			X,
		},
	}
end

function DoActions2X(PlayerID,Actions,flag)
	local k = 1
	local Size = #Actions

	local Y = {}
	if flag == nil then
		table.insert(Y,PreserveTrigger())
	end

	while k <= Size do
		if Size - k + 1 >= 63 then
			local X = {}
			for i = 0, 62 do
				table.insert(X, Actions[k])
				k = k + 1
			end
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						X,
						Y,
					},
				}
		else
			local X = {}
			repeat
				table.insert(X, Actions[k])
				k = k + 1
			until k == Size + 1
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						X,
						Y,
					},
				}
		end
	end
end

function TriggerX(Player, Conditions, Actions, Flags, Index)
	if Index == nil then
		Index = 0
	end
	Trigger {
				players = {ParsePlayer(Player)},
				conditions = {
					Label(Index);
					Conditions,
				},
				actions = {
					Actions,
				},
				flag = {
					Flags,
				}
			}
end

function Trigger2(Player, Conditions, Actions, Flags)
	local k = 1
	local Size = #Actions

	while k <= Size do
		if Size - k + 1 >= 64 then
			local X = {}
			for i = 0, 63 do
				table.insert(X, Actions[k])
				k = k + 1
			end
			Trigger {
					players = {ParsePlayer(Player)},
					conditions = {
						Conditions,
					},
					actions = {
						X,
					},
					flag = {
						Flags,
					}
				}
		else
			local X = {}
			repeat
				table.insert(X, Actions[k])
				k = k + 1
			until k == Size + 1
			Trigger {
					players = {ParsePlayer(Player)},
					conditions = {
						Conditions,
					},
					actions = {
						X,
					},
					flag = {
						Flags,
					}
				}
		end
	end
end

function Trigger2X(Player, Conditions, Actions, Flags)
	local k = 1
	local Size = #Actions

	while k <= Size do
		if Size - k + 1 >= 64 then
			local X = {}
			for i = 0, 63 do
				table.insert(X, Actions[k])
				k = k + 1
			end
			Trigger {
					players = {ParsePlayer(Player)},
					conditions = {
						Label(0);
						Conditions,
					},
					actions = {
						X,
					},
					flag = {
						Flags,
					}
				}
		else
			local X = {}
			repeat
				table.insert(X, Actions[k])
				k = k + 1
			until k == Size + 1
			Trigger {
					players = {ParsePlayer(Player)},
					conditions = {
						Label(0);
						Conditions,
					},
					actions = {
						X,
					},
					flag = {
						Flags,
					}
				}
		end
	end
end

-- Ctrig 구조체 트리거 (T,TT 삽입 가능) --

function CDoActions(PlayerID,Actions,flag,Index)
	if Index == nil then
		Index = 0
	end
	STPopTrigArr(PlayerID)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID)

	local X = {}
	if flag == nil then
		table.insert(X,PreserveTrigger())
	end
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(Index);
		},
		actions = {
			Actions,
			X,
		},
	}
end

function CTrigger(PlayerID, Conditions, Actions, Flags, Index)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID)

	if Flags == 1 then
		Flags = {Preserved}
	end
	if Index == nil or Index == "X" then
		Index = 0 
	end

	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(Index);
					Conditions,
				},
				actions = {
					Actions,
				},
				flag = {
					Flags,
				}
			}
		
end

-- Ctrig 파생 액션들 -------------------------------------------------------------------

function SetNext(Index1,Index2,Next)
	if Next == nil then
		Next = 0
	end
	local SetNext = SetCtrigX(nil,Index1,0x4,0,SetTo,nil,Index2,0x0,0,Next);
	return SetNext
end

function SetCJump(sIndex,Status,NewDest)
	local SetCJump 
	if NewDest == nil or NewDest == "X" then
		if Status == 1 or Status == "On" then
			SetCJump = SetNext(sIndex+0xA000,sIndex+0xB000,0)
		else
			SetCJump = SetNext(sIndex+0xA000,sIndex+0xA000,1)
		end
	else
		SetCJump = SetNext(sIndex+0xA000,NewDest,0)
	end
	return SetCJump
end

function VariableX(Player,Index,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local VariableX = CtrigX(Player,Index,Addr,0,Type,Value,Mask)
	return VariableX
end

function SetVariableX(Player,Index,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local SetVariableX = SetCtrig1X(Player,Index,Addr,0,Type,Value,Mask)
	return SetVariableX
end

function Variable(Variable,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local VariableX = CtrigX(Variable[1],Variable[2],Addr,Variable[3],Type,Value,Mask)
	return VariableX
end

function SetVariable(Variable,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local SetVariableX = SetCtrig1X(Variable[1],Variable[2],Addr,Variable[3],Type,Value,Mask)
	return SetVariableX
end

function VArrayX(VArray,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if VArray[4] ~= "V" then
		VArrayX_InputData_Error()
	end

	local VArrayX = CtrigX(VArray[1],VArray[2],Addr,VArray[3],Type,Value,Mask)
	return VArrayX
end

function SetVArrayX(VArray,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if VArray[4] ~= "V" then
		SetVArrayX_InputData_Error()
	end

	local SetVArrayX = SetCtrig1X(VArray[1],VArray[2],Addr,VArray[3],Type,Value,Mask)
	return SetVArrayX
end

function WariableX(Player,Index,Section,Type,Value,Mask)
	local Check
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD" then
		Addr = 0x158
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value+1}
		elseif type(Value) == "table" and type(Value[2]) == "table" then
			Value = {Value[1],Value[1]+Value[2][1]}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Type" then
		Addr = 0x160
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF000000,0xFF000000}
		end
	elseif Section == "Value" then
		Addr = 0x15C
		Check = 1
		if type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Mask" then
		Addr = 0x148
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Flag" then
		Addr = 0x164
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF,0xFF}
		end
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		if Check == 1 then
			Mask = {0xFFFFFFFF,0xFFFFFFFF}
		else
			Mask = 0xFFFFFFFF
		end
	end

	local WariableX
	if Check ==  1 then
		WariableX = {CtrigX(Player,Index,Addr,0,Type,Value[1],Mask[1]),CtrigX(Player,Index,Addr+0x40,0,Type,Value[2],Mask[2])}
	else
		WariableX = {CtrigX(Player,Index,Addr,0,Type,Value,Mask)}
	end
	return WariableX
end

function SetWariableX(Player,Index,Section,Type,Value,Mask)
	local Check
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD" then
		Addr = 0x158
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value+1}
		elseif type(Value) == "table" and type(Value[2]) == "table" then
			Value = {Value[1],Value[1]+Value[2][1]}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Type" then
		Addr = 0x160
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF000000,0xFF000000}
		end
	elseif Section == "Value" then
		Addr = 0x15C
		Check = 1
		if type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Mask" then
		Addr = 0x148
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Flag" then
		Addr = 0x164
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF,0xFF}
		end
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		if Check == 1 then
			Mask = {0xFFFFFFFF,0xFFFFFFFF}
		else
			Mask = 0xFFFFFFFF
		end
	end

	local SetWariableX
	if Check ==  1 then
		SetWariableX = {SetCtrig1X(Player,Index,Addr,0,Type,Value[1],Mask[1]),SetCtrig1X(Player,Index,Addr+0x40,0,Type,Value[2],Mask[2])}
	else
		SetWariableX = {SetCtrig1X(Player,Index,Addr,0,Type,Value,Mask)}
	end
	return SetWariableX
end

function Wariable(Wariable,Section,Type,Value,Mask)
	local Check
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD" then
		Addr = 0x158
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value+1}
		elseif type(Value) == "table" and type(Value[2]) == "table" then
			Value = {Value[1],Value[1]+Value[2][1]}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Type" then
		Addr = 0x160
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF000000,0xFF000000}
		end
	elseif Section == "Value" then
		Addr = 0x15C
		Check = 1
		if type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Mask" then
		Addr = 0x148
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Flag" then
		Addr = 0x164
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF,0xFF}
		end
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		if Check == 1 then
			Mask = {0xFFFFFFFF,0xFFFFFFFF}
		else
			Mask = 0xFFFFFFFF
		end
	end

	local WariableX
	if Check ==  1 then
		WariableX = {CtrigX(Wariable[1],Wariable[2],Addr,Wariable[3],Type,Value[1],Mask[1]),CtrigX(Wariable[1],Wariable[2],Addr+0x40,Wariable[3],Type,Value[2],Mask[2])}
	else
		WariableX = {CtrigX(Wariable[1],Wariable[2],Addr,Wariable[3],Type,Value,Mask)}
	end
	return WariableX
end

function SetWariable(Wariable,Section,Type,Value,Mask)
	local Check
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD" then
		Addr = 0x158
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value+1}
		elseif type(Value) == "table" and type(Value[2]) == "table" then
			Value = {Value[1],Value[1]+Value[2][1]}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Type" then
		Addr = 0x160
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF000000,0xFF000000}
		end
	elseif Section == "Value" then
		Addr = 0x15C
		Check = 1
		if type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Mask" then
		Addr = 0x148
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Flag" then
		Addr = 0x164
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF,0xFF}
		end
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		if Check == 1 then
			Mask = {0xFFFFFFFF,0xFFFFFFFF}
		else
			Mask = 0xFFFFFFFF
		end
	end

	local SetWariableX
	if Check ==  1 then
		SetWariableX = {SetCtrig1X(Wariable[1],Wariable[2],Addr,Wariable[3],Type,Value[1],Mask[1]),SetCtrig1X(Wariable[1],Wariable[2],Addr+0x40,Wariable[3],Type,Value[2],Mask[2])}
	else
		SetWariableX = {SetCtrig1X(Wariable[1],Wariable[2],Addr,Wariable[3],Type,Value,Mask)}
	end
	return SetWariableX
end

function WArrayX(WArray,Section,Type,Value,Mask)
	local Check
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD" then
		Addr = 0x158
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value+1}
		elseif type(Value) == "table" and type(Value[2]) == "table" then
			Value = {Value[1],Value[1]+Value[2][1]}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Type" then
		Addr = 0x160
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF000000,0xFF000000}
		end
	elseif Section == "Value" then
		Addr = 0x15C
		Check = 1
		if type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Mask" then
		Addr = 0x148
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Flag" then
		Addr = 0x164
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF,0xFF}
		end
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		if Check == 1 then
			Mask = {0xFFFFFFFF,0xFFFFFFFF}
		else
			Mask = 0xFFFFFFFF
		end
	end

	if WArray[4] ~= "W" then
		WArrayX_InputData_Error()
	end

	local WArrayX
	if Check ==  1 then
		WArrayX = {CtrigX(WArray[1],WArray[2],Addr,WArray[3],Type,Value[1],Mask[1]),CtrigX(WArray[1],WArray[2],Addr+0x40,WArray[3],Type,Value[2],Mask[2])}
	else
		WArrayX = {CtrigX(WArray[1],WArray[2],Addr,WArray[3],Type,Value,Mask)}
	end
	return WArrayX
end

function SetWArrayX(WArray,Section,Type,Value,Mask)
	local Check
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD" then
		Addr = 0x158
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value+1}
		elseif type(Value) == "table" and type(Value[2]) == "table" then
			Value = {Value[1],Value[1]+Value[2][1]}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Type" then
		Addr = 0x160
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF000000,0xFF000000}
		end
	elseif Section == "Value" then
		Addr = 0x15C
		Check = 1
		if type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Mask" then
		Addr = 0x148
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Flag" then
		Addr = 0x164
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF,0xFF}
		end
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		if Check == 1 then
			Mask = {0xFFFFFFFF,0xFFFFFFFF}
		else
			Mask = 0xFFFFFFFF
		end
	end

	if WArray[4] ~= "W" then
		SetWArrayX_InputData_Error()
	end

	local SetWArrayX
	if Check ==  1 then
		SetWArrayX = {SetCtrig1X(WArray[1],WArray[2],Addr,WArray[3],Type,Value[1],Mask[1]),SetCtrig1X(WArray[1],WArray[2],Addr+0x40,WArray[3],Type,Value[2],Mask[2])}
	else
		SetWArrayX = {SetCtrig1X(WArray[1],WArray[2],Addr,WArray[3],Type,Value,Mask)}
	end
	return SetWArrayX
end

function SVariableX(Player,SVariable,Line,Section,Type,Value,Mask)
	if SVariable[1] ~= "S" then
		SVariableX_InputData_Error()
	end
	if Line <= 0 or Line >= 17 then
		SVariableX_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local SVariableX = CtrigX(Player,SVariable[2],Addr,0,Type,Value,Mask)
	return SVariableX
end

function SetSVariableX(Player,SVariable,Line,Section,Type,Value,Mask)
	if SVariable[1] ~= "S" then
		SetSVariableX_InputData_Error()
	end
	if Line <= 0 or Line >= 17 then
		SVariableX_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local SetSVariableX = SetCtrig1X(Player,SVariable[2],Addr,0,Type,Value,Mask)
	return SetSVariableX
end

function SVariable(SVData,Section,Type,Value,Mask)
	local Line = SVData[6]
	if SVData[4] ~= "SV" then
		SVariable_InputData_Error()
	end
	if Line <= 0 or Line >= 17 then
		SVariable_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local SVariable = CtrigX(SVData[1],SVData[2],Addr,SVData[3],Type,Value,Mask)
	return SVariable
end

function SetSVariable(SVData,Section,Type,Value,Mask)
	local Line = SVData[6]
	if SVData[4] ~= "SV" then
		SVariable_InputData_Error()
	end
	if Line <= 0 or Line >= 17 then
		SVariable_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local SetSVariable = SetCtrig1X(SVData[1],SVData[2],Addr,SVData[3],Type,Value,Mask)
	return SetSVariable
end

function SVArrayX(SVArray,Section,Type,Value,Mask)
	local Line = SVArray[6]
	if SVArray[4] ~= "SV" then
		SVArrayX_InputData_Error()
	end
	if Line <= 0 or Line >= 17 then
		SVArrayX_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local SVArrayX = CtrigX(SVArray[1],SVArray[2],Addr,SVArray[3],Type,Value,Mask)
	return SVArrayX
end

function SetSVArrayX(SVArray,Section,Type,Value,Mask)
	local Line = SVArray[6]
	if SVArray[4] ~= "SV" then
		SetSVArrayX_InputData_Error()
	end
	if Line <= 0 or Line >= 17 then
		SetSVArrayX_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local SetSVArrayX = SetCtrig1X(SVArray[1],SVArray[2],Addr,SVArray[3],Type,Value,Mask)
	return SetSVArrayX
end

function MemX(Mem,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if type(Mem[4]) == "string" then
		MemX_InputData_Error()
	end

	local MemX = CtrigX(Mem[1],Mem[2],Mem[3],Mem[4],Type,Value,Mask)
	return MemX
end

function SetMemX(Mem1,Type,Mem2,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local SetMemX
	if type(Mem1) == "table" and type(Mem2) == "number" then
		SetMemX = SetCtrig1X(Mem1[1],Mem1[2],Mem1[3],Mem1[4],Type,Mem2,Mask)
	elseif type(Mem1) == "number" and type(Mem2) == "table" then
		SetMemX = SetCtrig2X(Mem1,Type,Mem2[1],Mem2[2],Mem2[3],Mem2[5],Mem2[4],Mask)
	elseif type(Mem1) == "table" and type(Mem2) == "table" then
		SetMemX = SetCtrigX(Mem1[1],Mem1[2],Mem1[3],Mem1[4],Type,Mem2[1],Mem2[2],Mem2[3],Mem2[5],Mem2[4],Mask)
	else
		SetMemX_InputData_Error()
	end
	
	return SetMemX
end

function LMemX(LMem,Type,Value,Mask)
	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	end

	if type(LMem[4]) == "string" then
		LMemX_InputData_Error()
	end

	if type(Type) == "number" then
		Type = {Type,Type}
	end
	if type(Value) == "number" then
		Value = {Value,Value}
	elseif type(Value) == "string" then
		Value = I64(Value)
	end
	if type(Mask) == "number" then
		Mask = {Mask,Mask}
	elseif type(Mask) == "string" then
		Mask = I64(Mask)
	end

	local LMemX = {CtrigX(LMem[1][1],LMem[1][2],LMem[1][3],LMem[1][4],Type[1],Value[1],Mask[1]),CtrigX(LMem[2][1],LMem[2][2],LMem[2][3],LMem[2][4],Type[2],Value[2],Mask[2])}
	return LMemX
end

function SetLMemX(LMem1,Type,LMem2,Mask)
	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	end

	local SetLMemX
	if type(Type) == "number" then
		Type = {Type,Type}
	end
	if type(Mask) == "number" then
		Mask = {Mask,Mask}
	elseif type(Mask) == "string" then
		Mask = I64(Mask)
	end

	if type(LMem1) == "string" then
		LMem1 = I64(LMem1)
	end
	if type(LMem2) == "string" then
		LMem2 = I64(LMem2)
	end
	if type(LMem1) == "number" then
		LMem1 = {LMem1,LMem1+0x4}
	end
	if type(LMem2) == "number" then
		LMem2 = {LMem2,LMem2}
	end

	if (type(LMem1[1]) == "table" and type(LMem1[2]) == "table") and (type(LMem2[1]) == "number" and type(LMem2[2]) == "number") then
		SetLMemX = {SetCtrig1X(LMem1[1][1],LMem1[1][2],LMem1[1][3],LMem1[1][4],Type[1],LMem2[1],Mask[1]),SetCtrig1X(LMem1[2][1],LMem1[2][2],LMem1[2][3],LMem1[2][4],Type[2],LMem2[2],Mask[2])}
	elseif (type(LMem1[1]) == "number" and type(LMem1[2]) == "number") and (type(LMem2[1]) == "table" and type(LMem2[2]) == "table") then
		SetLMemX = {SetCtrig2X(LMem1[1],Type[1],LMem2[1][1],LMem2[1][2],LMem2[1][3],LMem2[1][5],LMem2[1][4],Mask[1]),SetCtrig2X(LMem1[2],Type[2],LMem2[2][1],LMem2[2][2],LMem2[2][3],LMem2[2][5],LMem2[2][4],Mask[2])}
	elseif (type(LMem1[1]) == "table" and type(LMem1[2]) == "table") and (type(LMem2[1]) == "table" and type(LMem2[2]) == "table") then
		SetLMemX = {SetCtrigX(LMem1[1][1],LMem1[1][2],LMem1[1][3],LMem1[1][4],Type[1],LMem2[1][1],LMem2[1][2],LMem2[1][3],LMem2[1][5],LMem2[1][4],Mask[1]),SetCtrigX(LMem1[2][1],LMem1[2][2],LMem1[2][3],LMem1[2][4],Type[2],LMem2[2][1],LMem2[2][2],LMem2[2][3],LMem2[2][5],LMem2[2][4],Mask[2])}
	else
		SetLMemX_InputData_Error()
	end

	return SetLMemX
end

function CVar(Player,Index,Type,Value,Mask)
	return VariableX(Player,Index,"Value",Type,Value,Mask)
end

function SetCVar(Player,Index,Type,Value,Mask)
	return SetVariableX(Player,Index,"Value",Type,Value,Mask)
end

function NVar(Variable,Type,Value,Mask)
	return VariableX(Variable[1],Variable[2],"Value",Type,Value,Mask)
end

function SetNVar(Variable,Type,Value,Mask)
	return SetVariableX(Variable[1],Variable[2],"Value",Type,Value,Mask)
end

function CVAar(VArray,Type,Value,Mask)
	return VArrayX(VArray,"Value",Type,Value,Mask)
end

function SetCVAar(VArray,Type,Value,Mask)
	return SetVArrayX(VArray,"Value",Type,Value,Mask)
end

function CWar(Player,Index,Type,Value,Mask)
	if type(Value) == "number" then
		return WariableX(Player,Index,"Value1",Type,Value,Mask)
	elseif type(Value) == "table" and Value[2] == nil then
		return WariableX(Player,Index,"Value2",Type,Value[1],Mask)
	else
		return WariableX(Player,Index,"Value",Type,Value,Mask)
	end
end

function SetCWar(Player,Index,Type,Value,Mask)
	if type(Value) == "number" then
		return SetWariableX(Player,Index,"Value1",Type,Value,Mask)
	elseif type(Value) == "table" and Value[2] == nil then
		return SetWariableX(Player,Index,"Value2",Type,Value[1],Mask)
	else
		return SetWariableX(Player,Index,"Value",Type,Value,Mask)
	end
end

function NWar(Wariable,Type,Value,Mask)
	if type(Value) == "number" then
		return WariableX(Wariable[1],Wariable[2],"Value1",Type,Value,Mask)
	elseif type(Value) == "table" and Value[2] == nil then
		return WariableX(Wariable[1],Wariable[2],"Value2",Type,Value[1],Mask)
	else
		return WariableX(Wariable[1],Wariable[2],"Value",Type,Value,Mask)
	end
end

function SetNWar(Wariable,Type,Value,Mask)
	if type(Value) == "number" then
		return SetWariableX(Wariable[1],Wariable[2],"Value1",Type,Value,Mask)
	elseif type(Value) == "table" and Value[2] == nil then
		return SetWariableX(Wariable[1],Wariable[2],"Value2",Type,Value[1],Mask)
	else
		return SetWariableX(Wariable[1],Wariable[2],"Value",Type,Value,Mask)
	end
end

function CWAar(WArray,Type,Value,Mask)
	if type(Value) == "number" then
		return WArrayX(WArray,"Value1",Type,Value,Mask)
	elseif type(Value) == "table" and Value[2] == nil then
		return WArrayX(WArray,"Value2",Type,Value[1],Mask)
	else
		return WArrayX(WArray,"Value",Type,Value,Mask)
	end
end

function SetCWAar(WArray,Type,Value,Mask)
	if type(Value) == "number" then
		return SetWArrayX(WArray,"Value1",Type,Value,Mask)
	elseif type(Value) == "table" and Value[2] == nil then
		return SetWArrayX(WArray,"Value2",Type,Value[1],Mask)
	else
		return SetWArrayX(WArray,"Value",Type,Value,Mask)
	end
end

function CSVar(Player,SVariable,Line,Type,Value,Mask)
	return SVariableX(Player,SVariable,Line,"Value",Type,Value,Mask)
end

function SetCSVar(Player,SVariable,Line,Type,Value,Mask)
	return SetSVariableX(Player,SVariable,Line,"Value",Type,Value,Mask)
end

function NSVar(SVData,Type,Value,Mask)
	return SVariable(SVData,"Value",Type,Value,Mask)
end

function SetNSVar(SVData,Type,Value,Mask)
	return SetSVariable(SVData,"Value",Type,Value,Mask)
end

function CSVAar(SVArray,Type,Value,Mask)
	return SVArrayX(SVArray,"Value",Type,Value,Mask)
end

function SetCSVAar(SVArray,Type,Value,Mask)
	return SetSVArrayX(SVArray,"Value",Type,Value,Mask)
end

-- 확장 데스값 --

function _Ccode(Player,Code,EPDflag) -- Convert(CDeaths Data -> Ctrig Mem Data)
	if EPDflag == "X" or EPDflag == nil or EPDflag == 0 then
		EPDflag = nil
	else
		EPDflag = 1
	end
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)
	return {Player,Index,0x1C8+0x4*Line,0,EPDflag}
end

function _Ncode(Player,Code,EPDflag) -- Convert(NDeaths Data -> Ctrig Mem Data)
	if EPDflag == "X" or EPDflag == nil or EPDflag == 0 then
		EPDflag = nil
	else
		EPDflag = 1
	end
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)
	return {FixPlayer,Index,0x1C8+0x20*Line+0x4*Player,0,EPDflag}
end

function CDeathsX(Player,Type,Value,Code,Mask)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 480 or Line < 0 then
		CDeathX_LineOverflow()
	end
	local CDeathsX = CtrigX(Player,Index,0x1C8+0x4*Line,0,Type,Value,Mask)
	return CDeathsX
end

function CDeaths(Player,Type,Value,Code)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 480 or Line < 0 then
		CDeath_LineOverflow()
	end
	local CDeaths = CtrigX(Player,Index,0x1C8+0x4*Line,0,Type,Value)
	return CDeaths
end

function SetCDeathsX(Player,Type,Value,Code,Mask)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 480 or Line < 0 then
		SetCDeathsX_LineOverflow()
	end
	local SetCDeathsX = SetCtrig1X(Player,Index,0x1C8+0x4*Line,0,Type,Value,Mask)
	return SetCDeathsX
end

function SetCDeaths(Player,Type,Value,Code)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 480 or Line < 0 then
		SetCDeaths_LineOverflow()
	end
	local SetCDeaths = SetCtrig1X(Player,Index,0x1C8+0x4*Line,0,Type,Value)
	return SetCDeaths
end

function NDeathsX(Player,Type,Value,Code,Mask)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 60 or Line < 0 then
		NDeathX_LineOverflow()
	end
	local NDeathsX = CtrigX(FixPlayer,Index,0x1C8+0x20*Line+0x4*Player,0,Type,Value,Mask)
	return NDeathsX
end

function NDeaths(Player,Type,Value,Code)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 60 or Line < 0 then
		NDeath_LineOverflow()
	end
	local NDeaths = CtrigX(FixPlayer,Index,0x1C8+0x20*Line+0x4*Player,0,Type,Value)
	return NDeaths
end

function SetNDeathsX(Player,Type,Value,Code,Mask)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 60 or Line < 0 then
		SetNDeathsX_LineOverflow()
	end
	local SetNDeathsX = SetCtrig1X(FixPlayer,Index,0x1C8+0x20*Line+0x4*Player,0,Type,Value,Mask)
	return SetNDeathsX
end

function SetNDeaths(Player,Type,Value,Code)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 60 or Line < 0 then
		SetNDeaths_LineOverflow()
	end
	local SetNDeaths = SetCtrig1X(FixPlayer,Index,0x1C8+0x20*Line+0x4*Player,0,Type,Value)
	return SetNDeaths
end

-- 데이터 읽기 관련 함수 (Read) ---------------------------------------------------------

function SafeReadX(PlayerID,Input,Output,Mask,EPDRead) -- CRead 1 -> N 
	if type(Input) == "table" then
		if Input[4] == "VA" or Input[4] == "A" then
			SafeReadX_InputData_Error()
		end
	end
	if type(Output) == "number" then
		Output = {Output}
	end

	if Mask == "X" or Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if EPDRead == "X" then
		EPDRead = nil
	end
	if EPDRead == nil then
		local EPDArr = {} 

		for k, v in pairs(Output) do
			if type(v) == "table" then
				if v[4] == "VA" or v[4] == "A" then
					SafeReadX_InputData_Error()
				end
			end
			if type(v) == "number" then 
				table.insert(EPDArr,SetMemoryX(v,SetTo,0,Mask))
			elseif v == "Cp" then
				table.insert(EPDArr,SetDeathsX(CurrentPlayer,SetTo,0,0,Mask))
			elseif v[4] == "V" then				
				table.insert(EPDArr,SetCtrig1X(v[1],v[2],0x15C,v[3],SetTo,0,Mask))
			else
				table.insert(EPDArr,SetCtrig1X(v[1],v[2],v[3],v[4],SetTo,0,Mask))
			end
		end
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
		   		 Label(0);
			},
			actions = {
				EPDArr,
			},
			flag = {Preserved}
		}

		for i = 0, 31 do
			local CBit = bit32.band(Mask, 2^i)
			if CBit == 2^i then
				local InputArr = {}
				local OutputArr = {}

				if type(Input) == "number" then 
					InputArr = {MemoryX(Input,Exactly,CBit,CBit)}
				elseif Input == "Cp" then
					InputArr = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
				elseif Input[4] == "V" then
					InputArr = {CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,CBit,CBit)}
				else
					InputArr = {CtrigX(Input[1],Input[2],Input[3],Input[4],Exactly,CBit,CBit)}
				end

				for k, v in pairs(Output) do
					if type(v) == "table" then
						if v[4] == "VA" or v[4] == "A" then
							SafeReadX_InputData_Error()
						end
					end
					if type(v) == "number" then 
						table.insert(OutputArr,SetMemoryX(v,SetTo,CBit,CBit))
					elseif v == "Cp" then
						table.insert(OutputArr,SetDeathsX(CurrentPlayer,SetTo,CBit,0,CBit))
					elseif v[4] == "V" then
						table.insert(OutputArr,SetCtrig1X(v[1],v[2],0x15C,v[3],SetTo,CBit,CBit))
					else
						table.insert(OutputArr,SetCtrig1X(v[1],v[2],v[3],v[4],SetTo,CBit,CBit))
					end
				end

				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
				   		 Label(0);
						 InputArr,
					},
					actions = {
						OutputArr,
					},
					flag = {Preserved}
				}
			end
		end
	else
		local EPDArr = {} 

		for k, v in pairs(Output) do
			if type(v) == "table" then
				if v[4] == "VA" or v[4] == "A" then
					SafeReadX_InputData_Error()
				end
			end
			if type(v) == "number" then 
				table.insert(EPDArr,SetMemory(v,SetTo,-1452249))
			elseif v == "Cp" then
				table.insert(EPDArr,SetDeaths(CurrentPlayer,SetTo,-1452249,0))
			elseif v[4] == "V" then				
				table.insert(EPDArr,SetCtrig1X(v[1],v[2],0x15C,v[3],SetTo,-1452249))
			else
				table.insert(EPDArr,SetCtrig1X(v[1],v[2],v[3],v[4],SetTo,-1452249))
			end
		end
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
		   		 Label(0);
			},
			actions = {
				EPDArr,
			},
			flag = {Preserved}
		}

		for i = 2, 31 do
			local CBit = bit32.band(Mask, 2^i)
			if CBit == 2^i then
				
				local InputArr = {}
				local OutputArr = {}
				local EBit = CBit / 4

				if type(Input) == "number" then 
					InputArr = {MemoryX(Input,Exactly,CBit,CBit)}
				elseif Input == "Cp" then
					InputArr = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
				elseif Input[4] == "V" then
					InputArr = {CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,CBit,CBit)}
				else
					InputArr = {CtrigX(Input[1],Input[2],Input[3],Input[4],Exactly,CBit,CBit)}
				end

				for k, v in pairs(Output) do
					if type(v) == "table" then
						if v[4] == "VA" or v[4] == "A" then
							SafeReadX_InputData_Error()
						end
					end
					if type(v) == "number" then 
						table.insert(OutputArr,SetMemory(v,Add,EBit))
					elseif v == "Cp" then
						table.insert(OutputArr,SetDeaths(CurrentPlayer,Add,EBit,0))
					elseif v[4] == "V" then
						table.insert(OutputArr,SetCtrig1X(v[1],v[2],0x15C,v[3],Add,EBit))
					else
						table.insert(OutputArr,SetCtrig1X(v[1],v[2],v[3],v[4],Add,EBit))
					end
				end

				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
				   		 Label(0);
						 InputArr,
					},
					actions = {
						OutputArr,
					},
					flag = {Preserved}
				}
			end
		end
	end
end

function UnitReadX(PlayerID,Player,UnitId,Loc,Output) -- Binary Bring/Command Read
	if type(Output) == "table" then
		if Output[4] == "VA" or Output[4] == "A" then
			UnitReadX_InputData_Error()
		end
	end
	if Output == nil or Output == "X" then
		Output = V(CRet[1],"X",0)
	end
	if Loc == "X" then
		Loc = nil
	end

	local UnitArr1 = {}

	local j = 1
	for i = 10, 0, -1 do
		table.insert(UnitArr1,SetCtrig1X("X","X",0x24,j,SetTo,2^i))
		j = j + 1
	end
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(0);
		},
		actions = {
			SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,0);
			UnitArr1,
		},
		flag = {Preserved}
	}

	for i = 10, 0, -1 do
		local CBit = 2^i

		local UnitArr2 = {}
		if Loc == nil then
			table.insert(UnitArr2,Command(Player,AtLeast,2^i,UnitId))
		else 
			table.insert(UnitArr2,Bring(Player,AtLeast,2^i,UnitId,Loc))
		end

		local UnitArr3 = {}
		for j = 1, i do
			table.insert(UnitArr3,SetCtrig1X("X","X",0x24,j,Add,2^i))
		end

		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				UnitArr2,
			},
			actions = {
				SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,2^i,2^i);
				UnitArr3,
			},
			flag = {Preserved}
		}

	end
	return Output
end

function ConvertReadX(PlayerID,Input,Output,Multiplier,Mask,UseCycle) -- 메모리 * 상수 or 메모리 / 상수(2의 제곱수)
	if type(Input) == "table" then
		if Input[4] == "VA" or Input[4] == "A" then
			ConvertReadX_InputData_Error()
		end
	end
	if type(Output) == "number" then
		Output = {Output}
	end

	if Mask == "X" or Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if UseCycle == "X" or UseCycle == nil then
		UseCycle = 0
	end

	local ClearArr = {} 

	for k, v in pairs(Output) do
		if type(v) == "table" then
			if v[4] == "VA" or v[4] == "A" then
				ConvertReadX_InputData_Error()
			end
		end
		if type(v) == "number" then 
			table.insert(ClearArr,SetMemory(v,SetTo,0))
		elseif v == "Cp" then
			table.insert(ClearArr,SetDeaths(CurrentPlayer,SetTo,0,0))
		elseif v[4] == "V" then				
			table.insert(ClearArr,SetCtrig1X(v[1],v[2],0x15C,v[3],SetTo,0))
		else
			table.insert(ClearArr,SetCtrig1X(v[1],v[2],v[3],v[4],SetTo,0))
		end
	end
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
	   		 Label(0);
		},
		actions = {
			ClearArr,
		},
		flag = {Preserved}
	}

	local  Check = 0
	for i = 0, 31 do
		local CBit = bit32.band(Mask, 2^i)
		if CBit == 2^i then
			local InputArr = {}
			local OutputArr = {}
			local MBit = CBit * Multiplier

			if type(Input) == "number" then 
				InputArr = {MemoryX(Input,Exactly,CBit,CBit)}
			elseif Input == "Cp" then
				InputArr = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
			elseif Input[4] == "V" then
				InputArr = {CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,CBit,CBit)}
			else
				InputArr = {CtrigX(Input[1],Input[2],Input[3],Input[4],Exactly,CBit,CBit)}
			end

			for k, v in pairs(Output) do
				if type(v) == "table" then
					if v[4] == "VA" or v[4] == "A" then
						ConvertReadX_InputData_Error()
					end
				end
				if type(v) == "number" then 
					table.insert(OutputArr,SetMemory(v,Add,MBit))
				elseif v == "Cp" then
					table.insert(OutputArr,SetDeaths(CurrentPlayer,Add,MBit,0))
				elseif v[4] == "V" then
					table.insert(OutputArr,SetCtrig1X(v[1],v[2],0x15C,v[3],Add,MBit))
				else
					table.insert(OutputArr,SetCtrig1X(v[1],v[2],v[3],v[4],Add,MBit))
				end
			end
			if Check == 0 then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
				   		 Label(0);
						 InputArr,
					},
					actions = {
						OutputArr,
					},
					flag = {Preserved}
				}
			end
			if bit32.band(CBit*Multiplier,0xFFFFFFFF) >= 0x80000000 and UseCycle == 0 then
				Check = 1
			end
		end
	end
end

-- 제어문 (if,Jump,While) 관련 함수 ----------------------------------------------------

function SLoopN(PlayerID,Repeat,Conditions,Actions,InitActions,Single) -- 초소형 반복문 Next 변경 + Db 삽입방식 (CStruct)
	if Single == nil or Single == 0 or Single == "X" then
		if type(Repeat) == "number" then
			STPopTrigArr(PlayerID)
			ORPopCondArr(PlayerID)
			TTPopTrigArr(PlayerID)
			Conditions = PopCondArr(Conditions)
			InitActions = PopActArr(InitActions)
			PopTrigArr(PlayerID,2)

			if Repeat < 0 or Repeat > 500000 then
				SLoopN_InputError()
			end
			local Size = math.ceil(Repeat/151) -- N = 151*TRIG
			Trigger {
				players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(IndexAlloc);
						Conditions,
					},
					actions = {
						SetCtrigX("X",IndexAlloc+1,0x4,0,SetTo,"X",IndexAlloc+1,0,0,1); -- Make Loop Action A->A1
						SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+1,0x0,0,0); -- Connect Next
						InitActions,
					},
					flag = {Preserved}
				}

			for i = 1, Size do
				Trigger {
					players = {ParsePlayer(PlayerID)},
					flag = {Preserved}
				}
			end

			Trigger {
				players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(IndexAlloc+1);
					},
					actions = {
						SetCtrigX("X","X",0x4-0x10*Repeat,0,SetTo,"X",IndexAlloc+2,0,0,0); -- Timer Action & Exit TRIG
						SetCtrig1X("X","X",0x158,0,Add,4); -- Run Tick
						Actions, -- Wait 금지
						},
						flag = {Preserved}
					}

			PlayerID = PlayerConvert(PlayerID)
			table.insert(SLoopNArr, IndexAlloc)
			table.insert(SLoopNPArr, PlayerID)
			table.insert(SLoopNVArr, Repeat)
			SLoopNptr = SLoopNptr + 1
			SLoopNCount = SLoopNCount + 1
			IndexAlloc = IndexAlloc + 0x3
		elseif Repeat[1][4] == "V" then
			STPopTrigArr(PlayerID)
			ORPopCondArr(PlayerID)
			TTPopTrigArr(PlayerID)
			Conditions = PopCondArr(Conditions)
			InitActions = PopActArr(InitActions)
			PopTrigArr(PlayerID,7,2)

			local min, max, RepeatMax
			RepeatMax = Repeat[2]
			local Size = math.ceil(RepeatMax/151) -- N = 151*TRIG
			local Deviation = Repeat[1][5]
			if Deviation == "X" or Deviation == nil then
				Deviation = 0
			end
			if Deviation >= 0 then
				min = 0
			else
				min = -Deviation
			end
			if Deviation >= RepeatMax then
				max = 0
			else
				max = RepeatMax-Deviation
			end
			if RepeatMax < 0 or RepeatMax > 500000 then
				SLoopN_InputError()
			end
			
			Trigger {
				players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(IndexAlloc);
						NVar(Repeat[1],AtLeast,min*4,0xFFFFFFFC);
						NVar(Repeat[1],AtMost,max*4,0xFFFFFFFC);
						Conditions,
					},
					actions = {
						SetCtrigX("X",IndexAlloc,0x4,0,SetTo,Repeat[1][1],Repeat[1][2],0,0,Repeat[1][3]);  -- Connect Next
						SetCtrigX(Repeat[1][1],Repeat[1][2],0x4,Repeat[1][3],SetTo,"X",IndexAlloc+1,0,0,0); -- Connect Next
						SetCtrigX("X",IndexAlloc+1,0x4,0,SetTo,"X",IndexAlloc+1,0,0,1); -- Make Loop Action A->A1
						SetCtrigX(Repeat[1][1],Repeat[1][2],0x158,Repeat[1][3],SetTo,"X",IndexAlloc+1,0x158,1,0);
						SetCtrig1X(Repeat[1][1],Repeat[1][2],0x160,Repeat[1][3],SetTo,Subtract*16777216,0xFF000000);
						SetCtrig1X(Repeat[1][1],Repeat[1][2],0x148,Repeat[1][3],SetTo,0xFFFFFFFC);
						SetCtrigX("X",IndexAlloc+1,0x158,0,SetTo,"X",IndexAlloc+1,0x4-0x10*Deviation,1,0); -- Reset Timer
						InitActions,
					},
					flag = {Preserved}
				}

			for i = 1, Size do
				Trigger {
					players = {ParsePlayer(PlayerID)},
					flag = {Preserved}
				}
			end

			Trigger {
				players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(IndexAlloc+1);
					},
					actions = {
						SetCtrig2X(0,SetTo,"X",IndexAlloc+2,0,0,0); -- Timer Action & Exit TRIG
						SetCtrig1X("X","X",0x158,0,Add,4); -- Run Tick
						Actions, -- Wait 금지
						},
						flag = {Preserved}
					}
			PlayerID = PlayerConvert(PlayerID)
			table.insert(SLoopNArr, IndexAlloc)
			table.insert(SLoopNPArr, PlayerID)
			table.insert(SLoopNVArr, Repeat)
			SLoopNptr = SLoopNptr + 1
			SLoopNCount = SLoopNCount + 1
			IndexAlloc = IndexAlloc + 0x3
		else
			SLoopN_InputError()
		end
	else
		if type(Repeat) == "number" then
			STPopTrigArr(PlayerID)
			ORPopCondArr(PlayerID)
			TTPopTrigArr(PlayerID)
			Conditions = PopCondArr(Conditions)
			InitActions = PopActArr(InitActions)
			PopTrigArr(PlayerID,2)

			if Repeat <= 0 or Repeat > 500000 then
				SLoopN_InputError()
			end
			local Size = math.ceil((Repeat-1)/151) -- N = 151*TRIG
			Trigger {
				players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(IndexAlloc);
						Conditions,
					},
					actions = {
						SetCtrigX("X",IndexAlloc+1,0x4,0,SetTo,"X",IndexAlloc+1,0,0,0); -- Make Loop Action A->A
						SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+1,0x0,0,0); -- Connect Next
						InitActions,
					},
					flag = {Preserved}
				}

			for i = 1, Size do
				Trigger {
					players = {ParsePlayer(PlayerID)},
					flag = {Preserved}
				}
			end

			Trigger {
				players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(IndexAlloc+1);
					},
					actions = {
						SetCtrigX("X","X",0x4-0x10*(Repeat-1),0,SetTo,"X",IndexAlloc+2,0,0,0); -- Timer Action & Exit TRIG
						SetCtrig1X("X","X",0x158,0,Add,4); -- Run Tick
						Actions, -- Wait 금지
						},
						flag = {Preserved}
					}
			local EndActions = {}
			if type(Single) == "table" then
				EndActions = Single
			end
			Trigger {
				players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(IndexAlloc+2);
					},
					actions = {
						SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1); -- Reset Next
						SetCtrigX("X",IndexAlloc+1,0x158,0,SetTo,"X",IndexAlloc+1,0x4-0x10*(Repeat-1),1,0); -- Reset Timer
						EndActions,
						},
						flag = {Preserved}
					}
			PlayerID = PlayerConvert(PlayerID)
			for k, P in pairs(PlayerID) do
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1))
			end
			IndexAlloc = IndexAlloc + 0x3
		elseif Repeat[1][4] == "V" then
			STPopTrigArr(PlayerID)
			ORPopCondArr(PlayerID)
			TTPopTrigArr(PlayerID)
			Conditions = PopCondArr(Conditions)
			InitActions = PopActArr(InitActions)
			PopTrigArr(PlayerID,7,2)

			local min, max, RepeatMax
			RepeatMax = Repeat[2]
			local Size = math.ceil((RepeatMax-1)/151) -- N = 151*TRIG
			local Deviation = Repeat[1][5]
			if Deviation == "X" or Deviation == nil then
				Deviation = 0
			end
			if Deviation >= 1 then
				min = 0
			else
				min = 1-Deviation
			end
			if Deviation >= RepeatMax then
				max = 0
			else
				max = RepeatMax-Deviation
			end
			if RepeatMax <= 0 or RepeatMax > 500000 then
				SLoopN_InputError()
			end
			
			Trigger {
				players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(IndexAlloc);
						NVar(Repeat[1],AtLeast,min*4,0xFFFFFFFC);
						NVar(Repeat[1],AtMost,max*4,0xFFFFFFFC);
						Conditions,
					},
					actions = {
						SetCtrigX("X",IndexAlloc,0x4,0,SetTo,Repeat[1][1],Repeat[1][2],0,0,Repeat[1][3]);  -- Connect Next
						SetCtrigX(Repeat[1][1],Repeat[1][2],0x4,Repeat[1][3],SetTo,"X",IndexAlloc+1,0,0,0); -- Connect Next
						SetCtrigX("X",IndexAlloc+1,0x4,0,SetTo,"X",IndexAlloc+1,0,0,0); -- Make Loop Action A->A
						SetCtrigX(Repeat[1][1],Repeat[1][2],0x158,Repeat[1][3],SetTo,"X",IndexAlloc+1,0x158,1,0);
						SetCtrig1X(Repeat[1][1],Repeat[1][2],0x160,Repeat[1][3],SetTo,Subtract*16777216,0xFF000000);
						SetCtrig1X(Repeat[1][1],Repeat[1][2],0x148,Repeat[1][3],SetTo,0xFFFFFFFC);
						SetCtrigX("X",IndexAlloc+1,0x158,0,SetTo,"X",IndexAlloc+1,0x14-0x10*Deviation,1,0); -- Reset Timer
						InitActions,
					},
					flag = {Preserved}
				}

			for i = 1, Size do
				Trigger {
					players = {ParsePlayer(PlayerID)},
					flag = {Preserved}
				}
			end

			Trigger {
				players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(IndexAlloc+1);
					},
					actions = {
						SetCtrig2X(0,SetTo,"X",IndexAlloc+2,0,0,0); -- Timer Action & Exit TRIG
						SetCtrig1X("X","X",0x158,0,Add,4); -- Run Tick
						Actions, -- Wait 금지
						},
						flag = {Preserved}
					}
			local EndActions = {}
			if type(Single) == "table" then
				EndActions = Single
			end
			Trigger {
				players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(IndexAlloc+2);
					},
					actions = {
						SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1); -- Reset Next
						EndActions,
						},
						flag = {Preserved}
					}
			PlayerID = PlayerConvert(PlayerID)
			for k, P in pairs(PlayerID) do
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1))
			end
			IndexAlloc = IndexAlloc + 0x3
		else
			SLoopN_InputError()
		end
	end
end

function SLoopNEnd(Actions)
	if SLoopNCount <= 0 then
		SLoopNpair_Error()
	end
	if type(SLoopNVArr[SLoopNptr]) == "number" then		
		local Index = SLoopNArr[SLoopNptr] + 2
		local PlayerID = SLoopNPArr[SLoopNptr]
		local Repeat = SLoopNVArr[SLoopNptr]
		table.remove(SLoopNArr,SLoopNptr)
		table.remove(SLoopNPArr,SLoopNptr)
		table.remove(SLoopNVArr,SLoopNptr)
		SLoopNptr = SLoopNptr - 1
		SLoopNCount = SLoopNCount - 1

		Trigger {
			players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(Index);
				},
				actions = {
					SetCtrigX("X",Index-2,0x4,0,SetTo,"X",Index,0x0,0,1); -- Reset Next
					SetCtrigX("X",Index-1,0x158,0,SetTo,"X",Index-1,0x4-0x10*Repeat,1,0); -- Reset Timer
					Actions,
					},
					flag = {Preserved}
				}

		for k, P in pairs(PlayerID) do
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x4,0,SetTo,"X",Index,0x0,0,1))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x4,-1,SetTo,"X",Index-1,0x0,0,0))
		end
		IndexAlloc = IndexAlloc + 0x1
	else
		local Index = SLoopNArr[SLoopNptr] + 2
		local PlayerID = SLoopNPArr[SLoopNptr]
		local Repeat = SLoopNVArr[SLoopNptr]
		table.remove(SLoopNArr,SLoopNptr)
		table.remove(SLoopNPArr,SLoopNptr)
		table.remove(SLoopNVArr,SLoopNptr)
		SLoopNptr = SLoopNptr - 1
		SLoopNCount = SLoopNCount - 1

		Trigger {
			players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(Index);
				},
				actions = {
					SetCtrigX("X",Index-2,0x4,0,SetTo,"X",Index,0x0,0,1); -- Reset Next
					Actions,
					},
					flag = {Preserved}
				}

		for k, P in pairs(PlayerID) do
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x4,0,SetTo,"X",Index,0x0,0,1))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x4,-1,SetTo,"X",Index-1,0x0,0,0))
		end
		IndexAlloc = IndexAlloc + 0x1
	end
end

function CJump(PlayerID,sIndex)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(sIndex+0xA000);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1],SetNext(sIndex+0xA000,sIndex+0xB000))
	end
	table.insert(CJumpArr,sIndex)
end

function CJumpEnd(PlayerID,sIndex)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(sIndex+0xB000);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	table.insert(CJumpEndArr,sIndex)
end

function NJump(PlayerID,sIndex,Conditions,Actions)
	STPopTrigArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(sIndex+0xA000);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",sIndex+0xA000,0x158,0,SetTo,"X",sIndex+0xA000,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",sIndex+0xA000,0x15C,0,SetTo,"X",sIndex+0xB000,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",sIndex+0xB000,0x158,0,SetTo,"X",sIndex+0xA000,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",sIndex+0xB000,0x15C,0,SetTo,"X",sIndex+0xA000,0x0,0,1))
	end
	table.insert(NJumpArr,sIndex)
end
function NJumpEnd(PlayerID,sIndex,Actions_Always)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(sIndex+0xB000);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions_Always,
			PreserveTrigger();
		},
	}
	table.insert(NJumpEndArr,sIndex)
end

function CJumpX(PlayerID,sIndex)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(0);
		},
		actions = {
			SetNext("X",sIndex+0xB000);
	   		PreserveTrigger();
		},
	}
	table.insert(CJumpArr,sIndex)
end

function CJumpXEnd(PlayerID,sIndex)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(sIndex+0xB000);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	table.insert(CJumpEndArr,sIndex)
end

function NJumpX(PlayerID,sIndex,Conditions,Actions)
	STPopTrigArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(0);
			Conditions,
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",sIndex+0xB000,0x0,0,0);
			SetCtrigX("X",sIndex+0xB000,0x158,0,SetTo,"X","X",0x4,1,0);
			SetCtrigX("X",sIndex+0xB000,0x15C,0,SetTo,"X","X",0x0,0,1);
			SetCtrig1X("X",sIndex+0xB000,0x2C,0,SetTo,0x0200,0x0200);
			Actions,
	   		PreserveTrigger();
		},
	}
	table.insert(NJumpArr,sIndex)
end
function NJumpXEnd(PlayerID,sIndex,Actions)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(sIndex+0xB000);
			Never();
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			SetCtrig1X("X",sIndex+0xB000,0x2C,0,SetTo,0x0000,0x0200);
			Actions,
			PreserveTrigger();
		},
	}
	table.insert(NJumpEndArr,sIndex)
end

function CIfOnce(PlayerID, Conditions, Actions) -- 1번만 실행
	STPopTrigArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(CIfArr, IndexAlloc)
	table.insert(CIfPArr, PlayerID)
	CIfptr = CIfptr + 1
	IndexAlloc = IndexAlloc + 0x2
end

function CIf(PlayerID, Conditions, Actions)
	STPopTrigArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(CIfArr, IndexAlloc)
	table.insert(CIfPArr, PlayerID)
	CIfptr = CIfptr + 1
	IndexAlloc = IndexAlloc + 0x2
end

function CIfEnd(Actions_Always)
	local Index
	Index = CIfArr[CIfptr] + 1
	local PlayerID
	PlayerID = CIfPArr[CIfptr]
	table.remove(CIfArr,CIfptr)
	table.remove(CIfPArr,CIfptr)
	CIfptr = CIfptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x4,0,SetTo,"X",Index,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x158,0,SetTo,"X",Index-1,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x15C,0,SetTo,"X",Index-1,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x158,0,SetTo,"X",Index-1,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x15C,0,SetTo,"X",Index,0x0,0,0))
	end
	
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(Index);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions_Always,
			PreserveTrigger();
		},
	}
end

function NIf(PlayerID, Conditions, Actions)
	STPopTrigArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(NIfArr, IndexAlloc)
	table.insert(NIfPArr, PlayerID)
	NIfptr = NIfptr + 1
	IndexAlloc = IndexAlloc + 0x3
end

function NIfEnd()
	local Index
	Index = NIfArr[NIfptr] + 2
	local PlayerID
	PlayerID = NIfPArr[NIfptr]
	table.remove(NIfArr,NIfptr)
	table.remove(NIfPArr,NIfptr)
	NIfptr = NIfptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x4,0,SetTo,"X",Index,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x158,0,SetTo,"X",Index-2,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x15C,0,SetTo,"X",Index-1,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x158,0,SetTo,"X",Index-2,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x15C,0,SetTo,"X",Index,0x0,0,0))
	end
	
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(Index);
		},
		actions = {
			PreserveTrigger();
		},
	}
end

function CWhile(PlayerID, Conditions, Actions)
	STPopTrigArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(CWhileArr, IndexAlloc)
	table.insert(CWhilePArr, PlayerID)
	CWhileptr = CWhileptr + 1
	IndexAlloc = IndexAlloc + 0x3
end

function CLoop(PlayerID,Repeat,Conditions,Actions)
	DoActionsX(PlayerID,SetCDeaths("X",SetTo,0,Ccode(IndexAlloc+1,0)))
	STPopTrigArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,2,1)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc);
			CDeaths("X",AtMost,Repeat-1,Ccode(IndexAlloc+1,0));
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			SetCDeaths("X",Add,1,Ccode(IndexAlloc+1,0));
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(CWhileArr, IndexAlloc)
	table.insert(CWhilePArr, PlayerID)
	CWhileptr = CWhileptr + 1
	IndexAlloc = IndexAlloc + 0x3
end

function CWhileEnd(Actions)
	local Index
	Index = CWhileArr[CWhileptr] + 2
	local PlayerID
	PlayerID = CWhilePArr[CWhileptr]
	table.remove(CWhileArr,CWhileptr)
	table.remove(CWhilePArr,CWhileptr)
	CWhileptr = CWhileptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x4,0,SetTo,"X",Index-2,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x4,0,SetTo,"X",Index,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x158,0,SetTo,"X",Index-2,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x15C,0,SetTo,"X",Index-1,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x158,0,SetTo,"X",Index-2,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x15C,0,SetTo,"X",Index-1,0x0,0,0))
	end
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(Index);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
			PreserveTrigger();
		},
	}
end

function CWhileX(PlayerID, Conditions, Actions)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc);
			Never();
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	STPopTrigArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+1);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+2);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(CWhileXArr, IndexAlloc)
	table.insert(CWhileXPArr, PlayerID)
	CWhileXptr = CWhileXptr + 1
	IndexAlloc = IndexAlloc + 0x4
end

function CLoopX(PlayerID,Repeat,Conditions,Actions)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc);
		},
		actions = {
			SetCDeaths("X",SetTo,0,Ccode(IndexAlloc+2,0));
	   		PreserveTrigger();
		},
	}
	STPopTrigArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,2,1)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+1);
			CDeaths("X",AtMost,Repeat-1,Ccode(IndexAlloc+2,0));
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			SetCDeaths("X",Add,1,Ccode(IndexAlloc+2,0));
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+2);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(CWhileXArr, IndexAlloc)
	table.insert(CWhileXPArr, PlayerID)
	CWhileXptr = CWhileXptr + 1
	IndexAlloc = IndexAlloc + 0x4
end

function CWhileXEnd(Actions)
	local Index
	Index = CWhileXArr[CWhileXptr] + 3
	local PlayerID
	PlayerID = CWhileXPArr[CWhileXptr]
	table.remove(CWhileXArr,CWhileXptr)
	table.remove(CWhileXPArr,CWhileXptr)
	CWhileXptr = CWhileXptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x4,0,SetTo,"X",Index-3,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x4,0,SetTo,"X",Index,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x158,0,SetTo,"X",Index-2,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x15C,0,SetTo,"X",Index-1,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x158,0,SetTo,"X",Index-2,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x15C,0,SetTo,"X",Index-1,0x0,0,0))
	end
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(Index);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
			PreserveTrigger();
		},
	}
end

function NWhile(PlayerID, Conditions, Actions)
	STPopTrigArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+2);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(NWhileArr, IndexAlloc)
	table.insert(NWhilePArr, PlayerID)
	NWhileptr = NWhileptr + 1
	IndexAlloc = IndexAlloc + 0x4
end

function NLoop(PlayerID,Repeat,Conditions,Actions)
	DoActionsX(PlayerID,SetCDeaths("X",SetTo,0,Ccode(IndexAlloc+1,0)))
	STPopTrigArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,2,1)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc);
			CDeaths("X",AtMost,Repeat-1,Ccode(IndexAlloc+1,0));
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			SetCDeaths("X",Add,1,Ccode(IndexAlloc+1,0));
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+2);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(NWhileArr, IndexAlloc)
	table.insert(NWhilePArr, PlayerID)
	NWhileptr = NWhileptr + 1
	IndexAlloc = IndexAlloc + 0x4
end

function NWhileEnd(Actions)
	local Index
	Index = NWhileArr[NWhileptr] + 3
	local PlayerID
	PlayerID = NWhilePArr[NWhileptr]
	table.remove(NWhileArr,NWhileptr)
	table.remove(NWhilePArr,NWhileptr)
	NWhileptr = NWhileptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x4,0,SetTo,"X",Index-3,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x4,0,SetTo,"X",Index,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-3,0x158,0,SetTo,"X",Index-3,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-3,0x15C,0,SetTo,"X",Index-1,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x158,0,SetTo,"X",Index-3,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x15C,0,SetTo,"X",Index-2,0x0,0,0))
	end
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(Index);
		},
		actions = {
			Actions,
			PreserveTrigger();
		},
	}
end

function NWhileX(PlayerID, Conditions, Actions)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc);
			Never();
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	STPopTrigArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+1);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+2);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+3);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(NWhileXArr, IndexAlloc)
	table.insert(NWhileXPArr, PlayerID)
	NWhileXptr = NWhileXptr + 1
	IndexAlloc = IndexAlloc + 0x5
end

function NLoopX(PlayerID,Repeat,Conditions,Actions)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc);
		},
		actions = {
			SetCDeaths("X",SetTo,0,Ccode(IndexAlloc+2,0));
	   		PreserveTrigger();
		},
	}
	STPopTrigArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,2,1)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+1);
			CDeaths("X",AtMost,Repeat-1,Ccode(IndexAlloc+2,0));
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			SetCDeaths("X",Add,1,Ccode(IndexAlloc+2,0));
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+2);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+3);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(NWhileXArr, IndexAlloc)
	table.insert(NWhileXPArr, PlayerID)
	NWhileXptr = NWhileXptr + 1
	IndexAlloc = IndexAlloc + 0x5
end

function NWhileXEnd(Actions)
	local Index
	Index = NWhileXArr[NWhileXptr] + 4
	local PlayerID
	PlayerID = NWhileXPArr[NWhileXptr]
	table.remove(NWhileXArr,NWhileXptr)
	table.remove(NWhileXPArr,NWhileXptr)
	NWhileXptr = NWhileXptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x4,0,SetTo,"X",Index-4,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x4,0,SetTo,"X",Index,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-3,0x158,0,SetTo,"X",Index-3,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-3,0x15C,0,SetTo,"X",Index-1,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x158,0,SetTo,"X",Index-3,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x15C,0,SetTo,"X",Index-2,0x0,0,0))
	end
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(Index);
		},
		actions = {
			Actions,
			PreserveTrigger();
		},
	}
end

function DoWhile(PlayerID, Actions_Always)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions_Always,
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(DWhileArr, IndexAlloc)
	table.insert(DWhilePArr, PlayerID)
	DWhileptr = DWhileptr + 1
	IndexAlloc = IndexAlloc + 0x2
end

function DoWhileEnd(Loop_Conditions, Actions)
	local Index
	Index = DWhileArr[DWhileptr] + 1
	local PlayerID
	PlayerID = DWhilePArr[DWhileptr]
	table.remove(DWhileArr,DWhileptr)
	table.remove(DWhilePArr,DWhileptr)
	DWhileptr = DWhileptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x158,0,SetTo,"X",Index,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x15C,0,SetTo,"X",Index,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x158,0,SetTo,"X",Index,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x15C,0,SetTo,"X",Index-1,0x0,0,0))
	end
	STPopTrigArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Loop_Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(Index);
			Loop_Conditions,
		},
		actions = {
		SetDeaths(0,SetTo,0,0);
			Actions,
			PreserveTrigger();
		},
	}
end

function CFor(PlayerID,Init,End,Step,Actions) -- DoWhile x CJump
	DoActionsX(PlayerID,SetVariableX("X",IndexAlloc+1,"Value",SetTo,Init)) -- Calc Init
	STPopTrigArr(PlayerID)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1,1)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc);
			VariableX("X",IndexAlloc+1,"Value",Exactly,End); -- Calc Last
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	CVariable(ParsePlayer(PlayerID),IndexAlloc+1)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+2);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(CForArr, IndexAlloc)
	table.insert(CForPArr, PlayerID)
	table.insert(CForStep, Step)
	CForptr = CForptr + 1
	IndexAlloc = IndexAlloc + 0x4
end

function CForEnd(Actions)
	local Index
	Index = CForArr[CForptr] + 3
	local PlayerID
	PlayerID = CForPArr[CForptr]
	local Step
	Step = CForStep[CForptr]
	table.remove(CForArr,CForptr)
	table.remove(CForPArr,CForptr)
	table.remove(CForStep,CForptr)
	CForptr = CForptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-3,0x4,0,SetTo,"X",Index-1,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x4,0,SetTo,"X",Index,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x4,0,SetTo,"X",Index-3,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-3,0x158,0,SetTo,"X",Index-3,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-3,0x15C,0,SetTo,"X",Index-1,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x158,0,SetTo,"X",Index-3,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x15C,0,SetTo,"X",Index-1,0x0,0,1))
	end
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(Index);
		},
		actions = {
			SetVariableX("X",Index-2,"Value",Add,Step);
			Actions,
			PreserveTrigger();
		},
	}
end

function CForVariable(NestingLevel)
	if NestingLevel == nil or NestingLevel == "X" then
		NestingLevel = CForptr
	end
	local CForLabel = CForArr[NestingLevel] + 1
	return {"X",CForLabel,0,"V"}
end

function NIfX(PlayerID, Conditions, Actions)
	STPopTrigArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(0);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
	   		PreserveTrigger();
		},
	}
	local X = {}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(X, IndexAlloc)
	table.insert(NIfXArr, X)
	table.insert(NIfXPArr, PlayerID)
	NIfXptr = NIfXptr + 1
	IndexAlloc = IndexAlloc + 0x2
end

function NElseIfX(Conditions, Actions)
	local PlayerID
	PlayerID = NIfXPArr[NIfXptr]
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(0);
		},
		flag = {Preserved}
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc);
		},
		flag = {Preserved}
	}
	STPopTrigArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+1);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(0);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
	   		PreserveTrigger();
		},
	}
	table.insert(NIfXArr[NIfXptr],IndexAlloc+1)
	IndexAlloc = IndexAlloc + 0x2
end

function NElseX(Actions)
	local PlayerID
	PlayerID = NIfXPArr[NIfXptr]
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(0);
		},
		flag = {Preserved}
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc);
		},
		flag = {Preserved}
	}
	STPopTrigArr(PlayerID)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(0);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
	   		PreserveTrigger();
		},
	}
	table.insert(NIfXArr[NIfXptr],IndexAlloc+1)
	IndexAlloc = IndexAlloc + 0x2
end

function NIfXEnd()
	local PlayerID
	PlayerID = NIfXPArr[NIfXptr]
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(0);
		},
		flag = {Preserved}
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc);
		},
		flag = {Preserved}
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
			PreserveTrigger();
		},
	}
	table.insert(NIfXArr[NIfXptr],IndexAlloc+1)
	IndexAlloc = IndexAlloc + 0x2

	for k, P in pairs(PlayerID) do
		local Size = 0
		for i, index in pairs(NIfXArr[NIfXptr]) do
			Size = Size + 1
		end
		for i = 1, Size-1 do
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",NIfXArr[NIfXptr][i],0x4,0,SetTo,"X",NIfXArr[NIfXptr][i+1]-1,0x0,0,0))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",NIfXArr[NIfXptr][i+1]-1,0x4,-1,SetTo,"X",IndexAlloc-1,0x0,0,0))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",NIfXArr[NIfXptr][i],0x158,0,SetTo,"X",NIfXArr[NIfXptr][i],0x4,1,0))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",NIfXArr[NIfXptr][i],0x15C,0,SetTo,"X",NIfXArr[NIfXptr][i],0x0,0,1))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",NIfXArr[NIfXptr][i],0x158,1,SetTo,"X",NIfXArr[NIfXptr][i],0x4,1,0))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",NIfXArr[NIfXptr][i],0x15C,1,SetTo,"X",NIfXArr[NIfXptr][i+1]-1,0x0,0,0))
		end
	end

	table.remove(NIfXArr,NIfXptr)
	table.remove(NIfXPArr,NIfXptr)
	NIfXptr = NIfXptr - 1
end

function CIfX(PlayerID, Conditions, Actions)
	STPopTrigArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,3)

	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			SetDeaths(0,SetTo,0,0);
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	local X = {}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(X, IndexAlloc)
	table.insert(CIfXArr, X)
	table.insert(CIfXPArr, PlayerID)
	CIfXptr = CIfXptr + 1
	IndexAlloc = IndexAlloc + 0x2
end

function CElseIfX(Conditions, Actions)
	local PlayerID
	PlayerID = CIfXPArr[CIfXptr]
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(0);
		},
		flag = {Preserved}
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc);
		},
		flag = {Preserved}
	}
	STPopTrigArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,3)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+1);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			SetDeaths(0,SetTo,0,0);
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	table.insert(CIfXArr[CIfXptr],IndexAlloc+1)
	IndexAlloc = IndexAlloc + 0x2
end

function CElseX(Actions)
	local PlayerID
	PlayerID = CIfXPArr[CIfXptr]
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(0);
		},
		flag = {Preserved}
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc);
		},
		flag = {Preserved}
	}
	STPopTrigArr(PlayerID)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,3)
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			SetDeaths(0,SetTo,0,0);
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	table.insert(CIfXArr[CIfXptr],IndexAlloc+1)
	IndexAlloc = IndexAlloc + 0x2
end

function CIfXEnd()
	local PlayerID
	PlayerID = CIfXPArr[CIfXptr]
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(0);
		},
		flag = {Preserved}
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc);
		},
		flag = {Preserved}
	}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			PreserveTrigger();
		},
	}
	table.insert(CIfXArr[CIfXptr],IndexAlloc+1)
	IndexAlloc = IndexAlloc + 0x2

	for k, P in pairs(PlayerID) do
		local Size = 0
		for i, index in pairs(CIfXArr[CIfXptr]) do
			Size = Size + 1
		end
		for i = 1, Size-1 do
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",CIfXArr[CIfXptr][i],0x4,0,SetTo,"X",CIfXArr[CIfXptr][i+1]-1,0x0,0,0))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",CIfXArr[CIfXptr][i+1]-1,0x4,-1,SetTo,"X",IndexAlloc-1,0x0,0,0))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",CIfXArr[CIfXptr][i],0x158,0,SetTo,"X",CIfXArr[CIfXptr][i],0x4,1,0))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",CIfXArr[CIfXptr][i],0x15C,0,SetTo,"X",CIfXArr[CIfXptr][i],0x0,0,1))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",CIfXArr[CIfXptr][i],0x178,0,SetTo,"X",IndexAlloc-1,0x158,1,0))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",CIfXArr[CIfXptr][i],0x17C,0,SetTo,"X",CIfXArr[CIfXptr][i],0x4,1,0))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",CIfXArr[CIfXptr][i],0x198,0,SetTo,"X",IndexAlloc-1,0x15C,1,0))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",CIfXArr[CIfXptr][i],0x19C,0,SetTo,"X",CIfXArr[CIfXptr][i+1]-1,0x0,0,0))
		end
	end

	table.remove(CIfXArr,CIfXptr)
	table.remove(CIfXPArr,CIfXptr)
	CIfXptr = CIfXptr - 1
end

-- 변수 삽입형 조건/액션 (T) ------------------------------------------------------------

function TCDeathsX(Player,Type,Value,Code,Mask)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 480 or Line < 0 then
		TCDeathX_LineOverflow()
	end
	local TCDeathsX = TCtrigX(Player,Index,0x1C8+0x4*Line,0,Type,Value,Mask)
	return TCDeathsX
end

function TCDeaths(Player,Type,Value,Code)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 480 or Line < 0 then
		TCDeath_LineOverflow()
	end
	local TCDeaths = TCtrigX(Player,Index,0x1C8+0x4*Line,0,Type,Value)
	return TCDeaths
end

function TSetCDeathsX(Player,Type,Value,Code,Mask)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 480 or Line < 0 then
		TSetCDeathsX_LineOverflow()
	end
	local TSetCDeathsX = TSetCtrig1X(Player,Index,0x1C8+0x4*Line,0,Type,Value,Mask)
	return TSetCDeathsX
end

function TSetCDeaths(Player,Type,Value,Code)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 480 or Line < 0 then
		TSetCDeaths_LineOverflow()
	end
	local TSetCDeaths = TSetCtrig1X(Player,Index,0x1C8+0x4*Line,0,Type,Value)
	return TSetCDeaths
end

function TNDeathsX(Player,Type,Value,Code,Mask)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 60 or Line < 0 then
		TNDeathX_LineOverflow()
	end
	local TNDeathsX = TCtrigX(FixPlayer,Index,0x1C8+0x20*Line+0x4*Player,0,Type,Value,Mask)
	return TNDeathsX
end

function TNDeaths(Player,Type,Value,Code)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 60 or Line < 0 then
		TNDeath_LineOverflow()
	end
	local TNDeaths = TCtrigX(FixPlayer,Index,0x1C8+0x20*Line+0x4*Player,0,Type,Value)
	return TNDeaths
end

function TSetNDeathsX(Player,Type,Value,Code,Mask)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 60 or Line < 0 then
		TSetNDeathsX_LineOverflow()
	end
	local TSetNDeathsX = TSetCtrig1X(FixPlayer,Index,0x1C8+0x20*Line+0x4*Player,0,Type,Value,Mask)
	return TSetNDeathsX
end

function TSetNDeaths(Player,Type,Value,Code)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 60 or Line < 0 then
		TSetNDeaths_LineOverflow()
	end
	local TSetNDeaths = TSetCtrig1X(FixPlayer,Index,0x1C8+0x20*Line+0x4*Player,0,Type,Value)
	return TSetNDeaths
end

function TVariableX(Player,Index,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TVariableX = TCtrigX(Player,Index,Addr,0,Type,Value,Mask)
	return TVariableX
end

function TSetVariableX(Player,Index,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TSetVariableX = TSetCtrig1X(Player,Index,Addr,0,Type,Value,Mask)
	return TSetVariableX
end

function TVariable(Variable,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TVariableX = TCtrigX(Variable[1],Variable[2],Addr,Variable[3],Type,Value,Mask)
	return TVariableX
end

function TSetVariable(Variable,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TSetVariableX = TSetCtrig1X(Variable[1],Variable[2],Addr,Variable[3],Type,Value,Mask)
	return TSetVariableX
end

function TVArrayX(VArray,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if VArray[4] ~= "V" then
		TVArrayX_InputData_Error()
	end

	local TVArrayX = TCtrigX(VArray[1],VArray[2],Addr,VArray[3],Type,Value,Mask)
	return TVArrayX
end

function TSetVArrayX(VArray,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if VArray[4] ~= "V" then
		TSetVArrayX_InputData_Error()
	end

	local TSetVArrayX = TSetCtrig1X(VArray[1],VArray[2],Addr,VArray[3],Type,Value,Mask)
	return TSetVArrayX
end

function TSVariableX(Player,SVariable,Line,Section,Type,Value,Mask)
	if SVariable[1] ~= "S" then
		SVariableX_InputData_Error()
	end
	if Line <= 0 or Line >= 17 then
		SVariableX_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TSVariableX = TCtrigX(Player,SVariable[2],Addr,0,Type,Value,Mask)
	return TSVariableX
end

function TSetSVariableX(Player,SVariable,Line,Section,Type,Value,Mask)
	if SVariable[1] ~= "S" then
		SetSVariableX_InputData_Error()
	end
	if Line <= 0 or Line >= 17 then
		SVariableX_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TSetSVariableX = TSetCtrig1X(Player,SVariable[2],Addr,0,Type,Value,Mask)
	return TSetSVariableX
end

function TSVariable(SVData,Section,Type,Value,Mask)
	local Line = SVData[6]
	if SVData[4] ~= "SV" then
		SVariable_InputData_Error()
	end
	if Line <= 0 or Line >= 17 then
		SVariable_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TSVariable = TCtrigX(SVData[1],SVData[2],Addr,SVData[3],Type,Value,Mask)
	return TSVariable
end

function TSetSVariable(SVData,Section,Type,Value,Mask)
	local Line = SVData[6]
	if SVData[4] ~= "SV" then
		SVariable_InputData_Error()
	end
	if Line <= 0 or Line >= 17 then
		SVariable_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TSetSVariable = TSetCtrig1X(SVData[1],SVData[2],Addr,SVData[3],Type,Value,Mask)
	return TSetSVariable
end

function TSVArrayX(SVArray,Section,Type,Value,Mask)
	local Line = SVArray[6]
	if SVArray[4] ~= "SV" then
		SVArrayX_InputData_Error()
	end
	if Line <= 0 or Line >= 17 then
		SVArrayX_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TSVArrayX = TCtrigX(SVArray[1],SVArray[2],Addr,SVArray[3],Type,Value,Mask)
	return TSVArrayX
end

function TSetSVArrayX(SVArray,Section,Type,Value,Mask)
	local Line = SVArray[6]
	if SVArray[4] ~= "SV" then
		SetSVArrayX_InputData_Error()
	end
	if Line <= 0 or Line >= 17 then
		SetSVArrayX_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TSetSVArrayX = TSetCtrig1X(SVArray[1],SVArray[2],Addr,SVArray[3],Type,Value,Mask)
	return TSetSVArrayX
end

function TCVar(Player,Index,Type,Value,Mask)
	return TVariableX(Player,Index,"Value",Type,Value,Mask)
end

function TSetCVar(Player,Index,Type,Value,Mask)
	return TSetVariableX(Player,Index,"Value",Type,Value,Mask)
end

function TNVar(Variable,Type,Value,Mask)
	return TVariableX(Variable[1],Variable[2],"Value",Type,Value,Mask)
end

function TSetNVar(Variable,Type,Value,Mask)
	return TSetVariableX(Variable[1],Variable[2],"Value",Type,Value,Mask)
end

function TCVAar(VArray,Type,Value,Mask)
	return TVArrayX(VArray,"Value",Type,Value,Mask)
end

function TSetCVAar(VArray,Type,Value,Mask)
	return TSetVArrayX(VArray,"Value",Type,Value,Mask)
end

function TCSVar(Player,SVariable,Line,Type,Value,Mask)
	return TSVariableX(Player,SVariable,Line,"Value",Type,Value,Mask)
end

function TSetCSVar(Player,SVariable,Line,Type,Value,Mask)
	return TSetSVariableX(Player,SVariable,Line,"Value",Type,Value,Mask)
end

function TNSVar(SVData,Type,Value,Mask)
	return TSVariable(SVData,"Value",Type,Value,Mask)
end

function TSetNSVar(SVData,Type,Value,Mask)
	return TSetSVariable(SVData,"Value",Type,Value,Mask)
end

function TCSVAar(SVArray,Type,Value,Mask)
	return TSVArrayX(SVArray,"Value",Type,Value,Mask)
end

function TSetCSVAar(SVArray,Type,Value,Mask)
	return TSetSVArrayX(SVArray,"Value",Type,Value,Mask)
end

function TSetCtrigX(Player1,Index1,Address1,Next1,Type,Player2,Index2,Address2,EPD2,Next2,Mask)
	return TSetMemoryX(Mem(Player1,Index1,Address1,Next1),Type,Mem(Player2,Index2,Address2,Next2,EPD2),Mask)
end

function TSetCtrig2X(Offset,Type,Player2,Index2,Address2,EPD2,Next2,Mask)
	return TSetMemoryX(Offset,Type,Mem(Player2,Index2,Address2,Next2,EPD2),Mask)
end

function TSetCtrig1X(Player1,Index1,Address1,Next1,Type,Value,Mask)
	return TSetMemoryX(Mem(Player1,Index1,Address1,Next1),Type,Value,Mask)
end

function TCtrigX(Player,Index,Address,Next,Type,Value,Mask)
	return TMemoryX(Mem(Player,Index,Address,Next),Type,Value,Mask)
end

function TDeaths(Player,Type,Value,UnitId)
	local PushLine = 0
	local TypeNum = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
					SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0xC,1,0),
					SetCtrig1X("X","X",0xC,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		else
			TypeNum = TypeNum + 1
		end	
	end

	local TDeaths
	if TypeNum == 0 then
		TDeaths = Deaths(Player,Type,Value,UnitId)
	elseif TypeNum == 1 then
		TDeaths = CtrigX(Player[1],Player[2],Player[3],Player[4],Type,Value) -- UnitId 무시
	end 
	table.insert(PushCondArr,TDeaths)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TSetDeaths(Player,Type,Value,UnitId)
	local PushLine = 0
	local TypeNum = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		else
			TypeNum = TypeNum + 2
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		else
			TypeNum = TypeNum + 1
		end
	end

	local TSetDeaths
	if TypeNum == 0 then
		TSetDeaths = SetDeaths(Player,Type,Value,UnitId)
	elseif TypeNum == 1 then
		TSetDeaths = SetCtrig1X(Player[1],Player[2],Player[3],Player[4],Type,Value)
	elseif TypeNum == 2 then
		TSetDeaths = SetCtrig2X(Player,Type,Value[1],Value[2],Value[3],EPD2,Value[4])
	elseif TypeNum == 3 then
		TSetDeaths = SetCtrigX(Player[1],Player[2],Player[3],Player[4],Type,Value[1],Value[2],Value[3],Value[5],Value[4])
	end 
	table.insert(PushActArr,TSetDeaths)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TDeathsX(Player,Type,Value,UnitId,Mask)
	local PushLine = 0
	local TypeNum = 0
	if type(Mask) == "table" then
		if Mask[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Mask})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Mask = TempData
		end

		if Mask[4] == "V" then
			if Mask[5] == nil then
				Mask[5] = 0
			end
			local X = {CallLabelAlways(Mask[1],Mask[2],Mask[3]),
					SetCtrig1X(Mask[1],Mask[2],0x148,Mask[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Mask[1],Mask[2],0x160,Mask[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Mask[1],Mask[2],0x158,Mask[3],SetTo,"X","X",0x8,1,0),
					SetCtrig1X("X","X",0x8,0,SetTo,Mask[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Mask = 0
			PushLine = PushLine + 1
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
					SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0xC,1,0),
					SetCtrig1X("X","X",0xC,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		else
			TypeNum = TypeNum + 1
		end	
	end

	local TDeathsX
	if TypeNum == 0  then
		TDeathsX = DeathsX(Player,Type,Value,UnitId,Mask)
	elseif TypeNum == 1 then
		TDeathsX = CtrigX(Player[1],Player[2],Player[3],Player[4],Type,Value,Mask) -- UnitId 무시
	end 
	table.insert(PushCondArr,TDeathsX)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TSetDeathsX(Player,Type,Value,UnitId,Mask)
	local PushLine = 0
	local TypeNum = 0
	if type(Mask) == "table" then
		if Mask[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Mask})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Mask = TempData
		end

		if Mask[4] == "V" then
			if Mask[5] == nil then
				Mask[5] = 0
			end
			local X = {CallLabelAlways(Mask[1],Mask[2],Mask[3]),
					SetCtrig1X(Mask[1],Mask[2],0x148,Mask[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Mask[1],Mask[2],0x160,Mask[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Mask[1],Mask[2],0x158,Mask[3],SetTo,"X","X",0x128,1,0),
					SetCtrig1X("X","X",0x128,0,SetTo,Mask[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Mask = 0
			PushLine = PushLine + 1
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		else
			TypeNum = TypeNum + 2
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		else
			TypeNum = TypeNum + 1
		end
	end

	local TSetDeathsX
	if TypeNum == 0 then
		TSetDeathsX = SetDeathsX(Player,Type,Value,UnitId,Mask)
	elseif TypeNum == 1 then
		TSetDeathsX = SetCtrig1X(Player[1],Player[2],Player[3],Player[4],Type,Value,Mask)
	elseif TypeNum == 2 then
		TSetDeathsX = SetCtrig2X(Player,Type,Value[1],Value[2],Value[3],Value[5],Value[4],Mask)
	elseif TypeNum == 3 then
		TSetDeathsX = SetCtrigX(Player[1],Player[2],Player[3],Player[4],Type,Value[1],Value[2],Value[3],Value[5],Value[4],Mask)
	end 
	table.insert(PushActArr,TSetDeathsX)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TMemory(Offset,Type,Value)
	local PushLine = 0
	local TypeNum = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			if type(Value[5]) == "number" then
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
						SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Value = 0
				PushLine = PushLine + 1
			else
				if Value[5][5] == nil then
					Value[5][5] = 0
				end
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
						SetCtrigX("X","X",0x10,0,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Value = 0
				PushLine = PushLine + 1
			end
		end
	end

	if type(Offset) == "table" then
		if Offset[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Offset})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Offset = TempData
		end

		if Offset[4] == "V" then
			if Offset[5] == nil then
				Offset[5] = 0
			end
			if type(Offset[5]) == "number" then
				local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
						SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0xC,1,0),
						SetCtrig1X("X","X",0xC,0,SetTo,Offset[5])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Offset = 0x58A364
				PushLine = PushLine + 1
			else
				local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
						SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0xC,1,0),
						SetCtrigX("X","X",0xC,0,SetTo,Offset[5][1],Offset[5][2],Offset[5][3],1,Offset[5][4])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Offset = 0x58A364
				PushLine = PushLine + 1
			end
		else
			TypeNum = TypeNum + 1
		end	
	end

	local TMemory
	if TypeNum == 0 then
		TMemory = FMemory(Offset,Type,Value)
	elseif TypeNum == 1 then
		TMemory = CtrigX(Offset[1],Offset[2],Offset[3],Offset[4],Type,Value)
	end 
	table.insert(PushCondArr,TMemory)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TSetMemory(Offset,Type,Value)
	local PushLine = 0
	local TypeNum = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			if type(Value[5]) == "number" then
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
						SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
				
				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Value = 0
				PushLine = PushLine + 1
			else
				if Value[5][5] == nil then
					Value[5][5] = 0
				end
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
						SetCtrigX("X","X",0x13C,0,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4])}
				
				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Value = 0
				PushLine = PushLine + 1
			end
		else
			TypeNum = TypeNum + 2
		end
	end

	if type(Offset) == "table" then
		if Offset[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Offset})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Offset = TempData
		end

		if Offset[4] == "V" then
			if Offset[5] == nil then
				Offset[5] = 0
			end
			if type(Offset[5]) == "number" then
				local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
						SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x138,1,0),
						SetCtrig1X("X","X",0x138,0,SetTo,Offset[5])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Offset = 0x58A364
				PushLine = PushLine + 1
			else
				local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
						SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x138,1,0),
						SetCtrigX("X","X",0x138,0,SetTo,Offset[5][1],Offset[5][2],Offset[5][3],1,Offset[5][4])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Offset = 0x58A364
				PushLine = PushLine + 1
			end
		else
			TypeNum = TypeNum + 1
		end
	end

	local TSetMemory 
	if TypeNum == 0 then
		TSetMemory = FSetMemory(Offset,Type,Value)
	elseif TypeNum == 1 then
		TSetMemory = SetCtrig1X(Offset[1],Offset[2],Offset[3],Offset[4],Type,Value)
	elseif TypeNum == 2 then
		TSetMemory = SetCtrig2X(Offset,Type,Value[1],Value[2],Value[3],Value[5],Value[4])
	elseif TypeNum == 3 then
		TSetMemory = SetCtrigX(Offset[1],Offset[2],Offset[3],Offset[4],Type,Value[1],Value[2],Value[3],Value[5],Value[4])
	end 
	table.insert(PushActArr,TSetMemory)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TMemoryX(Offset,Type,Value,Mask)
	local PushLine = 0
	local TypeNum = 0
	if type(Mask) == "table" then
		if Mask[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Mask})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Mask = TempData
		end

		if Mask[4] == "V" then
			if Mask[5] == nil then
				Mask[5] = 0
			end
			local X = {CallLabelAlways(Mask[1],Mask[2],Mask[3]),
					SetCtrig1X(Mask[1],Mask[2],0x148,Mask[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Mask[1],Mask[2],0x160,Mask[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Mask[1],Mask[2],0x158,Mask[3],SetTo,"X","X",0x8,1,0),
					SetCtrig1X("X","X",0x8,0,SetTo,Mask[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Mask = 0
			PushLine = PushLine + 1
		else
			TMemoryX_InputData_Error()
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			if type(Value[5]) == "number" then
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
						SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Value = 0
				PushLine = PushLine + 1
			else
				if Value[5][5] == nil then
					Value[5][5] = 0
				end
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
						SetCtrigX("X","X",0x10,0,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Value = 0
				PushLine = PushLine + 1
			end
		else
			TMemoryX_InputData_Error()
		end
	end

	if type(Offset) == "table" then
		if Offset[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Offset})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Offset = TempData
		end

		if Offset[4] == "V" then
			if Offset[5] == nil then
				Offset[5] = 0
			end
			if type(Offset[5]) == "number" then
				local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
						SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0xC,1,0),
						SetCtrig1X("X","X",0xC,0,SetTo,Offset[5])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Offset = 0x58A364
				PushLine = PushLine + 1
			else
				local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
						SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0xC,1,0),
						SetCtrigX("X","X",0xC,0,SetTo,Offset[5][1],Offset[5][2],Offset[5][3],1,Offset[5][4])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Offset = 0x58A364
				PushLine = PushLine + 1
			end
		else -- Mem
			TypeNum = TypeNum + 1
		end	
	end

	local TMemoryX 
	if TypeNum == 0 then
		TMemoryX = FMemoryX(Offset,Type,Value,Mask)
	elseif TypeNum == 1 then
		TMemoryX = CtrigX(Offset[1],Offset[2],Offset[3],Offset[4],Type,Value,Mask)
	end 
	table.insert(PushCondArr,TMemoryX)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TSetMemoryX(Offset,Type,Value,Mask)
	local PushLine = 0
	local TypeNum = 0
	if type(Mask) == "table" then
		if Mask[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Mask})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Mask = TempData
		end

		if Mask[4] == "V" then
			if Mask[5] == nil then
				Mask[5] = 0
			end
			local X = {CallLabelAlways(Mask[1],Mask[2],Mask[3]),
					SetCtrig1X(Mask[1],Mask[2],0x148,Mask[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Mask[1],Mask[2],0x160,Mask[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Mask[1],Mask[2],0x158,Mask[3],SetTo,"X","X",0x128,1,0),
					SetCtrig1X("X","X",0x128,0,SetTo,Mask[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Mask = 0
			PushLine = PushLine + 1
		else
			TSetMemoryX_InputData_Error()
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			if type(Value[5]) == "number" then
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
						SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
				
				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Value = 0
				PushLine = PushLine + 1
			else
				if Value[5][5] == nil then
					Value[5][5] = 0
				end
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
						SetCtrigX("X","X",0x13C,0,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4])}
				
				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Value = 0
				PushLine = PushLine + 1
			end
		else
			TypeNum = TypeNum + 2
		end
	end

	if type(Offset) == "table" then
		if Offset[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Offset})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Offset = TempData
		end

		if Offset[4] == "V" then
			if Offset[5] == nil then
				Offset[5] = 0
			end
			if type(Offset[5]) == "number" then
				local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
						SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x138,1,0),
						SetCtrig1X("X","X",0x138,0,SetTo,Offset[5])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Offset = 0x58A364
				PushLine = PushLine + 1
			else
				local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
						SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x138,1,0),
						SetCtrigX("X","X",0x138,0,SetTo,Offset[5][1],Offset[5][2],Offset[5][3],1,Offset[5][4])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Offset = 0x58A364
				PushLine = PushLine + 1
			end
		else
			TypeNum = TypeNum + 1
		end
	end

	local TSetMemoryX
	if TypeNum == 0 then
		TSetMemoryX = FSetMemoryX(Offset,Type,Value,Mask)
	elseif TypeNum == 1 then
		TSetMemoryX = SetCtrig1X(Offset[1],Offset[2],Offset[3],Offset[4],Type,Value,Mask)
	elseif TypeNum == 2 then
		TSetMemoryX = SetCtrig2X(Offset,Type,Value[1],Value[2],Value[3],Value[5],Value[4],Mask)
	elseif TypeNum == 3 then
		TSetMemoryX = SetCtrigX(Offset[1],Offset[2],Offset[3],Offset[4],Type,Value[1],Value[2],Value[3],Value[5],Value[4],Mask)
	end 
	table.insert(PushActArr,TSetMemoryX)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TCommand(Player,Type,Value,UnitId)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x14,1,0),
					SetCtrig1X("X","X",0x14,0,SetTo,UnitId[5],0xFFFF)}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
					SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0xC,1,0),
					SetCtrig1X("X","X",0xC,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end	
	end

	local TCommand = Command(Player,Type,Value,UnitId)
	table.insert(PushCondArr,TCommand)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TBring(Player,Type,Value,UnitId,Location)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x14,1,0),
					SetCtrig1X("X","X",0x14,0,SetTo,UnitId[5],0xFFFF)}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
					SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0xC,1,0),
					SetCtrig1X("X","X",0xC,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end	
	end

	local TBring = Bring(Player,Type,Value,UnitId,Location)
	table.insert(PushCondArr,TBring)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TAccumulate(Player,Type,Value,ResourceType)
	local PushLine = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
					SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0xC,1,0),
					SetCtrig1X("X","X",0xC,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end	
	end

	local TAccumulate = Accumulate(Player,Type,Value,ResourceType)
	table.insert(PushCondArr,TAccumulate)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TCountdownTimer(Type,Value)
	local PushLine = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
					SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	local TCountdownTimer = CountdownTimer(Type,Value)
	table.insert(PushCondArr,TCountdownTimer)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TElapsedTime(Type,Value)
	local PushLine = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
					SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	local TElapsedTime = ElapsedTime(Type,Value)
	table.insert(PushCondArr,TElapsedTime)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TKills(Player,Type,Value,UnitId)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x14,1,0),
					SetCtrig1X("X","X",0x14,0,SetTo,UnitId[5],0xFFFF)}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
					SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0xC,1,0),
					SetCtrig1X("X","X",0xC,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end	
	end

	local TKills = Kills(Player,Type,Value,UnitId)
	table.insert(PushCondArr,TKills)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TScore(Player,ScoreType,Type,Value)
	local PushLine = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
					SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0xC,1,0),
					SetCtrig1X("X","X",0xC,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end	
	end

	local TScore = Score(Player,ScoreType,Type,Value)
	table.insert(PushCondArr,TScore)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TOpponents(Player,Type,Value)
	local PushLine = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
					SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0xC,1,0),
					SetCtrig1X("X","X",0xC,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end	
	end

	local TOpponents = Opponents(Player,Type,Value)
	table.insert(PushCondArr,TOpponents)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TCreateUnit(Amount,UnitId,Location,Player)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Amount) == "table" then
		if Amount[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Amount})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Amount = TempData
		end

		if Amount[4] == "V" then
			if Amount[5] == nil then
				Amount[5] = 0
			end
			local X = {CallLabelAlways(Amount[1],Amount[2],Amount[3]),
					SetCtrig1X(Amount[1],Amount[2],0x148,Amount[3],SetTo,0xFF000000),
					SetCtrig1X(Amount[1],Amount[2],0x160,Amount[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Amount[1],Amount[2],0x158,Amount[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,Amount[5]*0x01000000,0xFF000000)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Amount = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TCreateUnit = CreateUnit(Amount,UnitId,Location,Player)
	table.insert(PushActArr,TCreateUnit)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TCreateUnitWithProperties(Amount,UnitId,Location,Player,Property)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Amount) == "table" then
		if Amount[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Amount})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Amount = TempData
		end

		if Amount[4] == "V" then
			if Amount[5] == nil then
				Amount[5] = 0
			end
			local X = {CallLabelAlways(Amount[1],Amount[2],Amount[3]),
					SetCtrig1X(Amount[1],Amount[2],0x148,Amount[3],SetTo,0xFF000000),
					SetCtrig1X(Amount[1],Amount[2],0x160,Amount[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Amount[1],Amount[2],0x158,Amount[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,Amount[5]*0x01000000,0xFF000000)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Amount = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TCreateUnitWithProperties = CreateUnitWithProperties(Amount,UnitId,Location,Player,Property)
	table.insert(PushActArr,TCreateUnitWithProperties)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TKillUnit(UnitId,Player)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TKillUnit = KillUnit(UnitId,Player)
	table.insert(PushActArr,TKillUnit)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end


function TKillUnitAt(Amount,UnitId,Location,Player)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Amount) == "table" then
		if Amount[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Amount})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Amount = TempData
		end

		if Amount[4] == "V" then
			if Amount[5] == nil then
				Amount[5] = 0
			end
			local X = {CallLabelAlways(Amount[1],Amount[2],Amount[3]),
					SetCtrig1X(Amount[1],Amount[2],0x148,Amount[3],SetTo,0xFF000000),
					SetCtrig1X(Amount[1],Amount[2],0x160,Amount[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Amount[1],Amount[2],0x158,Amount[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,Amount[5]*0x01000000,0xFF000000)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Amount = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TKillUnitAt = KillUnitAt(Amount,UnitId,Location,Player)
	table.insert(PushActArr,TKillUnitAt)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end


function TRemoveUnit(UnitId,Player)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TRemoveUnit = RemoveUnit(UnitId,Player)
	table.insert(PushActArr,TRemoveUnit)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TRemoveUnitAt(Amount,UnitId,Location,Player)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Amount) == "table" then
		if Amount[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Amount})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Amount = TempData
		end

		if Amount[4] == "V" then
			if Amount[5] == nil then
				Amount[5] = 0
			end
			local X = {CallLabelAlways(Amount[1],Amount[2],Amount[3]),
					SetCtrig1X(Amount[1],Amount[2],0x148,Amount[3],SetTo,0xFF000000),
					SetCtrig1X(Amount[1],Amount[2],0x160,Amount[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Amount[1],Amount[2],0x158,Amount[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,Amount[5]*0x01000000,0xFF000000)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Amount = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TRemoveUnitAt = RemoveUnitAt(Amount,UnitId,Location,Player)
	table.insert(PushActArr,TRemoveUnitAt)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TGiveUnits(Amount,UnitId,Player,Location,NewPlayer)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Amount) == "table" then
		if Amount[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Amount})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Amount = TempData
		end

		if Amount[4] == "V" then
			if Amount[5] == nil then
				Amount[5] = 0
			end
			local X = {CallLabelAlways(Amount[1],Amount[2],Amount[3]),
					SetCtrig1X(Amount[1],Amount[2],0x148,Amount[3],SetTo,0xFF000000),
					SetCtrig1X(Amount[1],Amount[2],0x160,Amount[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Amount[1],Amount[2],0x158,Amount[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,Amount[5]*0x01000000,0xFF000000)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Amount = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end
	
	if type(NewPlayer) == "table" and NewPlayer[1] ~= nil then
		if NewPlayer[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,NewPlayer})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			NewPlayer = TempData
		end

		if NewPlayer[4] == "V" then
			if NewPlayer[5] == nil then
				NewPlayer[5] = 0
			end
			local X = {CallLabelAlways(NewPlayer[1],NewPlayer[2],NewPlayer[3]),
					SetCtrig1X(NewPlayer[1],NewPlayer[2],0x148,NewPlayer[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(NewPlayer[1],NewPlayer[2],0x160,NewPlayer[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(NewPlayer[1],NewPlayer[2],0x158,NewPlayer[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,NewPlayer[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			NewPlayer = 0
			PushLine = PushLine + 1
		end
	end

	local TGiveUnits = GiveUnits(Amount,UnitId,Player,Location,NewPlayer)
	table.insert(PushActArr,TGiveUnits)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TMoveUnit(Amount,UnitId,Player,StartLocation,DestLocation)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Amount) == "table" then
		if Amount[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Amount})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Amount = TempData
		end

		if Amount[4] == "V" then
			if Amount[5] == nil then
				Amount[5] = 0
			end
			local X = {CallLabelAlways(Amount[1],Amount[2],Amount[3]),
					SetCtrig1X(Amount[1],Amount[2],0x148,Amount[3],SetTo,0xFF000000),
					SetCtrig1X(Amount[1],Amount[2],0x160,Amount[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Amount[1],Amount[2],0x158,Amount[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,Amount[5]*0x01000000,0xFF000000)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Amount = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end
	
	local TMoveUnit = MoveUnit(Amount,UnitId,Player,StartLocation,DestLocation)
	table.insert(PushActArr,TMoveUnit)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TMoveLocation(Location,UnitId,Player,DestLocation)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end
	
	local TMoveLocation = MoveLocation(Location,UnitId,Player,DestLocation)
	table.insert(PushActArr,TMoveLocation)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TOrder(UnitId,Player,StartLocation,OrderType,DestLocation)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end
	
	local TOrder = Order(UnitId,Player,StartLocation,OrderType,DestLocation)
	table.insert(PushActArr,TOrder)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TModifyUnitEnergy(Amount,UnitId,Player,Location,Value)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Amount) == "table" then
		if Amount[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Amount})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Amount = TempData
		end

		if Amount[4] == "V" then
			if Amount[5] == nil then
				Amount[5] = 0
			end
			local X = {CallLabelAlways(Amount[1],Amount[2],Amount[3]),
					SetCtrig1X(Amount[1],Amount[2],0x148,Amount[3],SetTo,0xFF000000),
					SetCtrig1X(Amount[1],Amount[2],0x160,Amount[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Amount[1],Amount[2],0x158,Amount[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,Amount[5]*0x01000000,0xFF000000)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Amount = 0
			PushLine = PushLine + 1
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TModifyUnitEnergy = ModifyUnitEnergy(Amount,UnitId,Player,Location,Value)
	table.insert(PushActArr,TModifyUnitEnergy)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TModifyUnitHangarCount(Value,Amount,UnitId,Player,Location)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Amount) == "table" then
		if Amount[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Amount})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Amount = TempData
		end

		if Amount[4] == "V" then
			if Amount[5] == nil then
				Amount[5] = 0
			end
			local X = {CallLabelAlways(Amount[1],Amount[2],Amount[3]),
					SetCtrig1X(Amount[1],Amount[2],0x148,Amount[3],SetTo,0xFF000000),
					SetCtrig1X(Amount[1],Amount[2],0x160,Amount[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Amount[1],Amount[2],0x158,Amount[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,Amount[5]*0x01000000,0xFF000000)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Amount = 0
			PushLine = PushLine + 1
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TModifyUnitHangarCount = ModifyUnitHangarCount(Value,Amount,UnitId,Player,Location)
	table.insert(PushActArr,TModifyUnitHangarCount)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TModifyUnitHitPoints(Amount,UnitId,Player,Location,Value)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Amount) == "table" then
		if Amount[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Amount})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Amount = TempData
		end

		if Amount[4] == "V" then
			if Amount[5] == nil then
				Amount[5] = 0
			end
			local X = {CallLabelAlways(Amount[1],Amount[2],Amount[3]),
					SetCtrig1X(Amount[1],Amount[2],0x148,Amount[3],SetTo,0xFF000000),
					SetCtrig1X(Amount[1],Amount[2],0x160,Amount[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Amount[1],Amount[2],0x158,Amount[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,Amount[5]*0x01000000,0xFF000000)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Amount = 0
			PushLine = PushLine + 1
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TModifyUnitHitPoints = ModifyUnitHitPoints(Amount,UnitId,Player,Location,Value)
	table.insert(PushActArr,TModifyUnitHitPoints)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TModifyUnitResourceAmount(Amount,Player,Location,Value)
	local PushLine = 0

	if type(Amount) == "table" then
		if Amount[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Amount})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Amount = TempData
		end

		if Amount[4] == "V" then
			if Amount[5] == nil then
				Amount[5] = 0
			end
			local X = {CallLabelAlways(Amount[1],Amount[2],Amount[3]),
					SetCtrig1X(Amount[1],Amount[2],0x148,Amount[3],SetTo,0xFF000000),
					SetCtrig1X(Amount[1],Amount[2],0x160,Amount[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Amount[1],Amount[2],0x158,Amount[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,Amount[5]*0x01000000,0xFF000000)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Amount = 0
			PushLine = PushLine + 1
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TModifyUnitResourceAmount = ModifyUnitResourceAmount(Amount,Player,Location,Value)
	table.insert(PushActArr,TModifyUnitResourceAmount)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TModifyUnitShields(Amount,UnitId,Player,Location,Value)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Amount) == "table" then
		if Amount[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Amount})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Amount = TempData
		end

		if Amount[4] == "V" then
			if Amount[5] == nil then
				Amount[5] = 0
			end
			local X = {CallLabelAlways(Amount[1],Amount[2],Amount[3]),
					SetCtrig1X(Amount[1],Amount[2],0x148,Amount[3],SetTo,0xFF000000),
					SetCtrig1X(Amount[1],Amount[2],0x160,Amount[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Amount[1],Amount[2],0x158,Amount[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,Amount[5]*0x01000000,0xFF000000)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Amount = 0
			PushLine = PushLine + 1
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TModifyUnitShields = ModifyUnitShields(Amount,UnitId,Player,Location,Value)
	table.insert(PushActArr,TModifyUnitShields)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TSetCountdownTimer(Type,Time)
	local PushLine = 0

	if type(Time) == "table" then
		if Time[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Time})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Time = TempData
		end

		if Time[4] == "V" then
			if Time[5] == nil then
				Time[5] = 0
			end
			local X = {CallLabelAlways(Time[1],Time[2],Time[3]),
					SetCtrig1X(Time[1],Time[2],0x148,Time[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Time[1],Time[2],0x160,Time[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Time[1],Time[2],0x158,Time[3],SetTo,"X","X",0x134,1,0),
					SetCtrig1X("X","X",0x134,0,SetTo,Time[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Time = 0
			PushLine = PushLine + 1
		end
	end

	local TSetCountdownTimer = SetCountdownTimer(Type,Time)
	table.insert(PushActArr,TSetCountdownTimer)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TSetResources(Player,Type,Value,ResourceType)
	local PushLine = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TSetResources = SetResources(Player,Type,Value,ResourceType)
	table.insert(PushActArr,TSetResources)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TSetScore(Player,Type,Value,ScoreType)
	local PushLine = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TSetScore = SetScore(Player,Type,Value,ScoreType)
	table.insert(PushActArr,TSetScore)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TWait(Time)
	local PushLine = 0

	if type(Time) == "table" then
		if Time[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Time})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Time = TempData
		end

		if Time[4] == "V" then
			if Time[5] == nil then
				Time[5] = 0
			end
			local X = {CallLabelAlways(Time[1],Time[2],Time[3]),
					SetCtrig1X(Time[1],Time[2],0x148,Time[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Time[1],Time[2],0x160,Time[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Time[1],Time[2],0x158,Time[3],SetTo,"X","X",0x134,1,0),
					SetCtrig1X("X","X",0x134,0,SetTo,Time[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Time = 0
			PushLine = PushLine + 1
		end
	end

	local TWait = Wait(Time)
	table.insert(PushActArr,TWait)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TSetDoodadState(State,UnitId,Player,Location)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TSetDoodadState = SetDoodadState(State,UnitId,Player,Location)
	table.insert(PushActArr,TSetDoodadState)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TSetInvincibility(State,UnitId,Player,Location)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TSetInvincibility = SetInvincibility(State,UnitId,Player,Location)
	table.insert(PushActArr,TSetInvincibility)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TSetAllianceStatus(Player,Status)
	local PushLine = 0

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TSetAllianceStatus = SetAllianceStatus(Player,Status)
	table.insert(PushActArr,TSetAllianceStatus)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

-- 특수 조건 관련 조건/함수 (EUD/TT) --------------------------------------------------------

function EUDORInit(PlayerID) -- Flag1 = CORInit(P1) -> CORCond(Flag1) -- 구 함수 / 실질 사용X
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)

	EUDORPlayer = PlayerID
	EUDORFlag = FCode
	DoActionsX(PlayerID,SetCDeaths("X",SetTo,0,FCode))

	FlagAlloc = FlagAlloc + 1
	return FIndex
end

function EUDOR(AND_Conditions) -- {{<-And->}<-Or->{<-And->}<-Or->{<-And->}} -- 구 함수 / 실질 사용X
	CTrigger({EUDORPlayer},AND_Conditions,{SetCDeaths("X",SetTo,1,EUDORFlag)},{Preserved})
end

function EUDCond(FlagID) -- 구 함수 / 실질 사용X
	return CDeaths("X",Exactly,1,FlagIndex(FlagID))
end

function EUDCompare(PlayerID,Mode,TargetCond)  -- 구 함수 / 실질 사용X

	local FIndex
	if Mode == ">" or Mode == Above then
		FIndex = EUDAbove(PlayerID,TargetCond)
	elseif Mode == "<" or Mode == Below then
		FIndex = EUDBelow(PlayerID,TargetCond)
	elseif Mode == "!=" or Mode == NotSame then
		FIndex = EUDNotSame(PlayerID,TargetCond)
	else
		EUDCompare_TypeError()
	end
	return FIndex
end

function EUDNotSame(PlayerID,TargetCond) -- 구 함수 / 실질 사용X
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)

	DoActionsX(PlayerID,{SetCDeaths("X",SetTo,1,FCode),SetCtrig1X("X","X",0x28,PushTrigStack+1,SetTo,Exactly*65536,0xFF0000)})
	CTrigger(PlayerID,{TargetCond},{SetCDeaths("X",SetTo,0,FCode)},{Preserved})

	FlagAlloc = FlagAlloc + 1
	return FIndex
end

function EUDAbove(PlayerID,TargetCond) -- 구 함수 / 실질 사용X
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)

	DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode),
						SetCtrigX("X","X",0x4,PushTrigStack+1,SetTo,"X","X",0x0,0,PushTrigStack+2),
						SetCtrig1X("X","X",0x15C,PushTrigStack+1,SetTo,1),
						SetCtrig1X("X","X",0x28,PushTrigStack+1,SetTo,AtLeast*65536,0xFF0000)})
	CTrigger(PlayerID,{TargetCond},{SetCDeaths("X",SetTo,1,FCode)},{Preserved})
	DoActionsX(PlayerID,{SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1),
						SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1),
						SetCtrig1X("X","X",0x15C,-1,SetTo,0),
						SetCtrig1X("X","X",0x28,-1,SetTo,Exactly*65536,0xFF0000)})

	FlagAlloc = FlagAlloc + 1
	return FIndex
end

function EUDBelow(PlayerID,TargetCond) -- 구 함수 / 실질 사용X
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)

	DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode),
						SetCtrigX("X","X",0x4,PushTrigStack+1,SetTo,"X","X",0x0,0,PushTrigStack+2),
						SetCtrig1X("X","X",0x15C,PushTrigStack+1,SetTo,1),
						SetCtrig1X("X","X",0x28,PushTrigStack+1,SetTo,AtMost*65536,0xFF0000)})
	CTrigger(PlayerID,{TargetCond},{SetCDeaths("X",SetTo,1,FCode)},{Preserved})
	DoActionsX(PlayerID,{SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1),
						SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1),
						SetCtrig1X("X","X",0x15C,-1,SetTo,0),
						SetCtrig1X("X","X",0x28,-1,SetTo,Exactly*65536,0xFF0000)})

	FlagAlloc = FlagAlloc + 1
	return FIndex
end

function TTOR(OR_Conditions) -- 구버젼 호환용 함수
	VarXReleaseLock = 1
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)

	if type(OR_Conditions) ~= "table" then
		TTOR_InputData_Error()
	end 

	table.insert(ORPushCondArr,OR_Conditions)
	table.insert(ORFCodeArr,FCode)

	FlagAlloc = FlagAlloc + 1
	local TTOR = CDeaths("X",Exactly,1,FCode)
	return TTOR
end

function TTAND(AND_Conditions) -- 구버젼 호환용 함수
	if type(AND_Conditions) ~= "table" then
		TTAND_InputData_Error()
	end 
	local TTAND = {"AND"}
	table.insert(TTAND,AND_Conditions)
	return TTAND
end
------------------------------------------
function _TOR(...)
	local arg = table.pack(...)
	if arg.n < 2 then
		_TOr_InputData_Error()
	end 
	local TOr = {"OR"}
	for k = 1, arg.n do
		table.insert(TOr,arg[k])
	end
	return TOr
end

function _TAND(...) 
	local arg = table.pack(...)
	if arg.n < 2 then
		_TAnd_InputData_Error()
	end 
	local TAnd = {"AND"}
	for k = 1, arg.n do
		table.insert(TAnd,arg[k])
	end
	return TAnd
end

function _TNOT(...)
	local arg = table.pack(...)
	if arg.n ~= 1 then
		_TNot_InputData_Error()
	end
	local TNot = {"NOT"}
	table.insert(TNot,arg[1])
	return TNot
end

function _TC(...) -- Convert
	local TCond = {"X"}
	local arg = table.pack(...)
	table.insert(TCond,arg)
	return TCond
end

function _TB(...) -- Bind (MAX 16)
	local arg = table.pack(...)
	if arg.n > 16 or arg.n < 2 then
		_TBind_InputData_Error()
	end
	local TBind = {"B"}
	for k = 1, arg.n do
		table.insert(TBind,arg[k])
	end
	return TBind
end

function _TP(...) -- _TPack : _TAnd + Input Arr
	VarXReleaseLock = 2
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)

	local arg = table.pack(...)
	if arg.n < 1 then
		_TPack_InputData_Error()
	end

	_TPushCondArr = {}
	_TFCodeArr = {}
	_TPushVarXAlloc = {}
	table.insert(_TPushVarXAlloc,VarXAlloc)
	table.insert(_TPushVarXAlloc,WarXAlloc)
	table.insert(_TPushVarXAlloc,{})
	for i = 1, 16 do
		table.insert(_TPushVarXAlloc[3],SVarXAlloc[i])
	end
	table.insert(_TPushCondArr,arg)
	table.insert(_TFCodeArr,FCode)

	FlagAlloc = FlagAlloc + 1
	local _TTCond = CDeaths("X",Exactly,arg.n,FCode)
	return _TTCond
end

----------------------------------------------------

function _TMemoryX(Offset,Type,Value,Mask)
	return {"T","TMemoryX",Offset,Type,Value,Mask}
end

function _TMemory(Offset,Type,Value)
	return {"T","TMemory",Offset,Type,Value}
end

function _TCVar(Player,Index,Type,Value,Mask)
	return {"T","TCVar",Player,Index,Type,Value,Mask}
end

function _TNVar(Variable,Type,Value,Mask)
	return {"T","TCVar",Variable[1],Variable[2],Type,Value,Mask}
end

function _TCVAar(VArray,Type,Value,Mask)
	return {"T","TCVAar",VArray,Type,Value,Mask}
end

function _TVariableX(Player,Index,Section,Type,Value,Mask)
	return {"T","TVariableX",Player,Index,Section,Type,Value,Mask}
end

function _TVariable(Variable,Section,Type,Value,Mask)
	return {"T","TVariable",Variable,Section,Type,Value,Mask}
end

function _TVArrayX(VArray,Section,Type,Value,Mask)
	return {"T","TVArrayX",VArray,Section,Type,Value,Mask}
end

function _TNDeathsX(Player,Type,Value,Code,Mask)
	return {"T","TNDeathsX",Player,Type,Value,Code,Mask}
end

function _TNDeaths(Player,Type,Value,Code)
	return {"T","TNDeaths",Player,Type,Value,Code}
end

function _TCDeathsX(Player,Type,Value,Code,Mask)
	return {"T","TCDeathsX",Player,Type,Value,Code,Mask}
end

function _TCDeaths(Player,Type,Value,Code)
	return {"T","TCDeaths",Player,Type,Value,Code}
end

function _TCtrigX(Player,Index,Address,Next,Type,Value,Mask)
	return {"T","TCtrigX",Player,Index,Address,Next,Type,Value,Mask}
end

function _TDeaths(Player,Type,Value,UnitId)
	return {"T","TDeaths",Player,Type,Value,UnitId}
end

function _TDeathsX(Player,Type,Value,UnitId,Mask)
	return {"T","TDeathsX",Player,Type,Value,UnitId,Mask}
end

function _TCommand(Player,Type,Value,UnitId)
	return {"T","TCommand",Player,Type,Value,UnitId}
end

function _TBring(Player,Type,Value,UnitId,Location)
	return {"T","TBring",Player,Type,Value,UnitId,Location}
end

function _TAccumulate(Player,Type,Value,ResourceType)
	return {"T","TAccumulate",Player,Type,Value,ResourceType}
end

function _TCountdownTimer(Type,Value)
	return {"T","TCountdownTimer",Type,Value}
end

function _TElapsedTime(Type,Value)
	return {"T","TElapsedTime",Type,Value}
end

function _TKills(Player,Type,Value,UnitId)
	return {"T","TKills",Player,Type,Value,UnitId}
end

function _TScore(Player,ScoreType,Type,Value)
	return {"T","TScore",Player,ScoreType,Type,Value}
end

function _TOpponents(Player,Type,Value)
	return {"T","TOpponents",Player,Type,Value}
end

function _TTbytecmp(Dest,SourceVA,Size,Distance)
	return {"TT","TTbytecmp",Dest,SourceVA,Size,Distance}
end

function _TTbytecmpX(Dest,DestX,SourceVA,Size,Distance)
	return {"TT","TTbytecmpX",Dest,DestX,SourceVA,Size,Distance}
end

function _TTLMemoryX(Offset,Type,Value,Mask)
	return {"TT","TTLMemoryX",Offset,Type,Value,Mask}
end

function _TTLMemory(Offset,Type,Value)
	return {"TT","TTLMemory",Offset,Type,Value}
end

function _TTMemoryX(Offset,Type,Value,Mask)
	return {"TT","TTMemoryX",Offset,Type,Value,Mask}
end

function _TTMemory(Offset,Type,Value)
	return {"TT","TTMemory",Offset,Type,Value}
end

function _TTCVar(Player,Index,Type,Value,Mask)
	return {"TT","TTCVar",Player,Index,Type,Value,Mask}
end

function _TTNVar(Variable,Type,Value,Mask)
	return {"TT","TTCVar",Variable[1],Variable[2],Type,Value,Mask}
end

function _TTCVAar(VArray,Type,Value,Mask)
	return {"TT","TTCVAar",VArray,Type,Value,Mask}
end

function _TTVariableX(Player,Index,Section,Type,Value,Mask)
	return {"TT","TTVariableX",Player,Index,Section,Type,Value,Mask}
end

function _TTVariable(Variable,Section,Type,Value,Mask)
	return {"TT","TTVariable",Variable,Section,Type,Value,Mask}
end

function _TTVArrayX(VArray,Section,Type,Value,Mask)
	return {"TT","TTVArrayX",VArray,Section,Type,Value,Mask}
end

function _TTNDeathsX(Player,Type,Value,Code,Mask)
	return {"TT","TTNDeathsX",Player,Type,Value,Code,Mask}
end

function _TTNDeaths(Player,Type,Value,Code)
	return {"TT","TTNDeaths",Player,Type,Value,Code}
end

function _TTCDeathsX(Player,Type,Value,Code,Mask)
	return {"TT","TTCDeathsX",Player,Type,Value,Code,Mask}
end

function _TTCDeaths(Player,Type,Value,Code)
	return {"TT","TTCDeaths",Player,Type,Value,Code}
end

function _TTCtrigX(Player,Index,Address,Next,Type,Value,Mask)
	return {"TT","TTCtrigX",Player,Index,Address,Next,Type,Value,Mask}
end

function _TTDeaths(Player,Type,Value,UnitId)
	return {"TT","TTDeaths",Player,Type,Value,UnitId}
end

function _TTDeathsX(Player,Type,Value,UnitId,Mask)
	return {"TT","TTDeathsX",Player,Type,Value,UnitId,Mask}
end

function _TTCommand(Player,Type,Value,UnitId)
	return {"TT","TTCommand",Player,Type,Value,UnitId}
end

function _TTBring(Player,Type,Value,UnitId,Location)
	return {"TT","TTBring",Player,Type,Value,UnitId,Location}
end

function _TTAccumulate(Player,Type,Value,ResourceType)
	return {"TT","TTAccumulate",Player,Type,Value,ResourceType}
end

function _TTCountdownTimer(Type,Value)
	return {"TT","TTCountdownTimer",Type,Value}
end

function _TTElapsedTime(Type,Value)
	return {"TT","TTElapsedTime",Type,Value}
end

function _TTKills(Player,Type,Value,UnitId)
	return {"TT","TTKills",Player,Type,Value,UnitId}
end

function _TTScore(Player,ScoreType,Type,Value)
	return {"TT","TTScore",Player,ScoreType,Type,Value}
end

function _TTOpponents(Player,Type,Value)
	return {"TT","TTOpponents",Player,Type,Value}
end

function _TTWariableX(Player,Index,Section,Type,Value,Mask)
	return {"TT","TTWariableX",Player,Index,Section,Type,Value,Mask}
end
function _TTWariable(Wariable,Section,Type,Value,Mask)
	return {"TT","TTWariable",Wariable,Section,Type,Value,Mask}
end
function _TTWArrayX(WArray,Section,Type,Value,Mask)
	return {"TT","TTWArrayX",WArray,Section,Type,Value,Mask}
end
function _TTCWar(Player,Index,Type,Value,Mask)
	return {"TT","TTCWar",Player,Index,Type,Value,Mask}
end
function _TTNWar(Wariable,Type,Value,Mask)
	return {"TT","TTNWar",Wariable,Type,Value,Mask}
end
function _TTCWAar(WArray,Type,Value,Mask)
	return {"TT","TTCWar",WArray,Type,Value,Mask}
end
function _TWariableX(Player,Index,Section,Type,Value,Mask)
	return {"T","TWariableX",Player,Index,Section,Type,Value,Mask}
end
function _TWariable(Wariable,Section,Type,Value,Mask)
	return {"T","TWariable",Wariable,Section,Type,Value,Mask}
end
function _TWArrayX(WArray,Section,Type,Value,Mask)
	return {"T","TWArrayX",WArray,Section,Type,Value,Mask}
end
function _TCWar(Player,Index,Type,Value,Mask)
	return {"T","TCWar",Player,Index,Type,Value,Mask}
end
function _TNWar(Wariable,Type,Value,Mask)
	return {"T","TNWar",Wariable,Type,Value,Mask}
end
function _TCWAar(WArray,Type,Value,Mask)
	return {"T","TCWAar",WArray,Type,Value,Mask}
end

function _TSVariableX(Player,SVariable,Line,Section,Type,Value,Mask)
	return {"T","TSVariableX",Player,SVariable,Line,Section,Type,Value,Mask}
end
function _TSVariable(SVData,Section,Type,Value,Mask)
	return {"T","TSVariable",SVData,Section,Type,Value,Mask}
end
function _TSVArrayX(SVArray,Section,Type,Value,Mask)
	return {"T","TSVArrayX",SVArray,Section,Type,Value,Mask}
end
function _TCSVar(Player,SVariable,Line,Type,Value,Mask)
	return {"T","TCSVar",Player,SVariable,Line,Type,Value,Mask}
end
function _TNSVar(SVData,Type,Value,Mask)
	return {"T","TNSVar",SVData,Type,Value,Mask}
end
function _TCSVAar(SVArray,Type,Value,Mask)
	return {"T","TCSVAar",SVArray,Type,Value,Mask}
end

function _TTCSVar(Player,SVariable,Line,Type,Value,Mask)
	return {"TT","TTCSVar",Player,SVariable,Line,Type,Value,Mask}
end
function _TTNSVar(SVData,Type,Value,Mask)
	return {"TT","TTNSVar",SVData,Type,Value,Mask}
end
function _TTCSVAar(SVArray,Type,Value,Mask)
	return {"TT","TTCSVAar",SVArray,Type,Value,Mask}
end
function _TTSVariableX(Player,SVariable,Line,Section,Type,Value,Mask)
	return {"TT","TTSVariableX",Player,SVariable,Line,Section,Type,Value,Mask}
end
function _TTSVariable(SVData,Section,Type,Value,Mask)
	return {"TT","TTSVariable",SVData,Section,Type,Value,Mask}
end
function _TTSVArrayX(SVArray,Section,Type,Value,Mask)
	return {"TT","TTSVArrayX",SVArray,Section,Type,Value,Mask}
end


-----------------------------------------------------------------

function TWariableX(Player,Index,Section,Type,Value,Mask)
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local TWariableX
	TWariableX = TCtrigX(Player,Index,Addr,0,Type,Value,Mask)
	return TWariableX
end

function TSetWariableX(Player,Index,Section,Type,Value,Mask)
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local TSetWariableX
	TSetWariableX = TSetCtrig1X(Player,Index,Addr,0,Type,Value,Mask)
	return TSetWariableX
end

function TWariable(Wariable,Section,Type,Value,Mask)
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local TWariableX
	TWariableX = TCtrigX(Wariable[1],Wariable[2],Addr,Wariable[3],Type,Value,Mask)
	return TWariableX
end

function TSetWariable(Wariable,Section,Type,Value,Mask)
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local TSetWariableX
	TSetWariableX = TSetCtrig1X(Wariable[1],Wariable[2],Addr,Wariable[3],Type,Value,Mask)
	return TSetWariableX
end

function TWArrayX(WArray,Section,Type,Value,Mask)
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if WArray[4] ~= "W" then
		TWArrayX_InputData_Error()
	end

	local TWArrayX
	TWArrayX = TCtrigX(WArray[1],WArray[2],Addr,WArray[3],Type,Value,Mask)
	return TWArrayX
end

function TSetWArrayX(WArray,Section,Type,Value,Mask)
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if WArray[4] ~= "W" then
		TSetWArrayX_InputData_Error()
	end

	local TSetWArrayX
	TSetWArrayX = TSetCtrig1X(WArray[1],WArray[2],Addr,WArray[3],Type,Value,Mask)
	return TSetWArrayX
end

function TCWar(Player,Index,Type,Value,Mask)
	if type(Value) == "table" and #Value == 1 then
		return TWariableX(Player,Index,"Value2",Type,Value[1],Mask)
	else
		return TWariableX(Player,Index,"Value1",Type,Value,Mask)
	end
end

function TSetCWar(Player,Index,Type,Value,Mask)
	if type(Value) == "table" and #Value == 1 then
		return TSetWariableX(Player,Index,"Value2",Type,Value[1],Mask)
	else
		return TSetWariableX(Player,Index,"Value1",Type,Value,Mask)
	end
end

function TNWar(Wariable,Type,Value,Mask)
	if type(Value) == "table" and #Value == 1 then
		return TWariableX(Wariable[1],Wariable[2],"Value2",Type,Value[1],Mask)
	else
		return TWariableX(Wariable[1],Wariable[2],"Value1",Type,Value,Mask)
	end
end

function TSetNWar(Wariable,Type,Value,Mask)
	if type(Value) == "table" and #Value == 1 then
		return TSetWariableX(Wariable[1],Wariable[2],"Value2",Type,Value[1],Mask)
	else
		return TSetWariableX(Wariable[1],Wariable[2],"Value1",Type,Value,Mask)
	end
end

function TCWAar(WArray,Type,Value,Mask)
	if type(Value) == "table" and #Value == 1 then
		return TWArrayX(WArray,"Value2",Type,Value[1],Mask)
	else
		return TWArrayX(WArray,"Value1",Type,Value,Mask)
	end
end

function TSetCWAar(WArray,Type,Value,Mask)
	if type(Value) == "table" and #Value == 1 then
		return TSetWArrayX(WArray,"Value2",Type,Value[1],Mask)
	else
		return TSetWArrayX(WArray,"Value1",Type,Value,Mask)
	end
end

function TTbytecmp(Dest,SourceVA,Size,Distance)
	local Mode = 9
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)

	local Pack = {"bytecmp"}
	table.insert(Pack,Dest)
	table.insert(Pack,SourceVA)
	table.insert(Pack,Size)
	table.insert(Pack,Distance)

	table.insert(TTPushTrigArr,{})
	table.insert(TTPushCondArr,Pack)
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTbytecmp = CDeaths("X",Exactly,1,FCode)
	return TTbytecmp
end

function TTbytecmpX(Dest,DestX,SourceVA,Size,Distance)
	local Mode = 9
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)

	local Pack = {"bytecmpX"}
	table.insert(Pack,Dest)
	table.insert(Pack,DestX)
	table.insert(Pack,SourceVA)
	table.insert(Pack,Size)
	table.insert(Pack,Distance)

	table.insert(TTPushTrigArr,{})
	table.insert(TTPushCondArr,Pack)
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTbytecmpX = CDeaths("X",Exactly,1,FCode)
	return TTbytecmpX
end

function TTWariableX(Player,Index,Section,Type,Value,Mask)
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = {0xFF000000,0xFF000000}
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = {0xFF,0xFF}
		end
	end

	local TTWariableX
	TTWariableX = {TTLMemoryX({{Player,Index,Addr,0},{Player,Index,Addr+0x40,0}},Type,Value,Mask)}
	return TTWariableX
end

function TTWariable(Wariable,Section,Type,Value,Mask)
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = {0xFF000000,0xFF000000}
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = {0xFF,0xFF}
		end
	end

	local TTWariable
	TTWariable = {TTLMemoryX({{Wariable[1],Wariable[2],Addr,Wariable[3]},{Wariable[1],Wariable[2],Addr+0x40,Wariable[3]}},Type,Value,Mask)}
	return TTWariable
end

function TTWArrayX(WArray,Section,Type,Value,Mask)
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = {0xFF000000,0xFF000000}
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = {0xFF,0xFF}
		end
	end

	if WArray[4] ~= "W" then
		TTWArrayX_InputData_Error()
	end

	local TTWArrayX
	TTWArrayX = {TTLMemoryX({{WArray[1],WArray[2],Addr,WArray[3]},{WArray[1],WArray[2],Addr+0x40,WArray[3]}},Type,Value,Mask)}
	return TTWArrayX
end

function TTCSVar(Player,SVariable,Line,Type,Value,Mask)
	return TTSVariableX(Player,SVariable,Line,"Value",Type,Value,Mask)
end

function TTNSVar(SVData,Type,Value,Mask)
	return TTSVariable(SVData,"Value",Type,Value,Mask)
end

function TTCSVAar(SVArray,Type,Value,Mask)
	return TTSVArrayX(SVArray,"Value",Type,Value,Mask)
end

function TTCWar(Player,Index,Type,Value,Mask)
	return TTWariableX(Player,Index,"Value",Type,Value,Mask)
end

function TTNWar(Wariable,Type,Value,Mask)
	return TTWariableX(Wariable[1],Wariable[2],"Value",Type,Value,Mask)
end

function TTCWAar(WArray,Type,Value,Mask)
	return TTWArrayX(WArray,"Value",Type,Value,Mask)
end

function TTCVar(Player,Index,Type,Value,Mask)
	return TTVariableX(Player,Index,"Value",Type,Value,Mask)
end

function TTNVar(Variable,Type,Value,Mask)
	return TTVariableX(Variable[1],Variable[2],"Value",Type,Value,Mask)
end

function TTCVAar(VArray,Type,Value,Mask)
	return TTVArrayX(VArray,"Value",Type,Value,Mask)
end

function TTSVariableX(Player,SVariable,Line,Section,Type,Value,Mask)
	if SVariable[1] ~= "S" then
		SVariableX_InputData_Error()
	end
	if Line <= 0 or Line >= 17 then
		SVariableX_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TTSVariableX = TTCtrigX(Player,SVariable[2],Addr,0,Type,Value,Mask)
	return TTSVariableX
end

function TTSVariable(SVData,Section,Type,Value,Mask)
	local Line = SVData[6]
	if SVData[4] ~= "SV" then
		SVariable_InputData_Error()
	end
	if Line <= 0 or Line >= 17 then
		SVariable_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TTSVariableX = TTCtrigX(SVData[1],SVData[2],Addr,SVData[3],Type,Value,Mask)
	return TTSVariableX
end

function TTSVArrayX(SVArray,Section,Type,Value,Mask)
	local Line = SVArray[6]
	if SVArray[4] ~= "SV" then
		SVArrayX_InputData_Error()
	end
	if Line <= 0 or Line >= 17 then
		SVArrayX_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TTSVArrayX = TTCtrigX(SVArray[1],SVArray[2],Addr,SVArray[3],Type,Value,Mask)
	return TTSVArrayX
end

function TTVariableX(Player,Index,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TTVariableX = TTCtrigX(Player,Index,Addr,0,Type,Value,Mask)
	return TTVariableX
end

function TTVariable(Variable,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TTVariableX = TTCtrigX(Variable[1],Variable[2],Addr,Variable[3],Type,Value,Mask)
	return TTVariableX
end

function TTVArrayX(VArray,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if VArray[4] ~= "V" then
		TTVArrayX_InputData_Error()
	end

	local TTVArrayX = TTCtrigX(VArray[1],VArray[2],Addr,VArray[3],Type,Value,Mask)
	return TTVArrayX
end

function TTNDeathsX(Player,Type,Value,Code,Mask)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 60 or Line < 0 then
		TTNDeathX_LineOverflow()
	end
	local TTNDeathsX = TTCtrigX(FixPlayer,Index,0x1C8+0x20*Line+0x4*Player,0,Type,Value,Mask)
	return TTNDeathsX
end

function TTNDeaths(Player,Type,Value,Code)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 60 or Line < 0 then
		TTNDeath_LineOverflow()
	end
	local TTNDeaths = TTCtrigX(FixPlayer,Index,0x1C8+0x20*Line+0x4*Player,0,Type,Value)
	return TTNDeaths
end

function TTCDeathsX(Player,Type,Value,Code,Mask)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 480 or Line < 0 then
		TTCDeathX_LineOverflow()
	end
	local TTCDeathsX = TTCtrigX(Player,Index,0x1C8+0x4*Line,0,Type,Value,Mask)
	return TTCDeathsX
end

function TTCDeaths(Player,Type,Value,Code)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 480 or Line < 0 then
		TTCDeath_LineOverflow()
	end
	local TTCDeaths = TTCtrigX(Player,Index,0x1C8+0x4*Line,0,Type,Value)
	return TTCDeaths
end

function TTCtrigX(Player,Index,Address,Next,Type,Value,Mask)	
	return TTMemoryX(Mem(Player,Index,Address,Next),Type,Value,Mask)
end

function TTDeaths(Player,Type,Value,UnitId)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	else
		TTDeaths_TypeError()
	end
	local TypeNum = 0
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0
	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
					SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
			Z = Z + 1
			table.insert(Y,X)
			Value = 0
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x20,1,0),
					SetCtrig1X("X","X",0x20,0,SetTo,Player[5])}
			Z = Z + 1
			table.insert(Y,X)
			Player = 0
		else
			TypeNum = 1
		end
	end

	local TTDeaths2
	if TypeNum == 0 then
		TTDeaths2 = Deaths(Player,Exactly,Value,UnitId)
	elseif TypeNum == 1 then
		TTDeaths2 = CtrigX(Player[1],Player[2],Player[3],Player[4],Exactly,Value)
	end 
	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,TTDeaths2)
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTDeaths = CDeaths("X",Exactly,1,FCode)
	return TTDeaths
end

function TTDeathsX(Player,Type,Value,UnitId,Mask)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	else
		TTDeathsX_TypeError()
	end
	local TypeNum = 0
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0
	if type(Mask) == "table" then
		if Mask[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Mask})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Mask = TempData
		end

		if Mask[4] == "V" then
			if Mask[5] == nil then
				Mask[5] = 0
			end
			local X = {CallLabelAlways(Mask[1],Mask[2],Mask[3]),
					SetCtrig1X(Mask[1],Mask[2],0x148,Mask[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Mask[1],Mask[2],0x160,Mask[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Mask[1],Mask[2],0x158,Mask[3],SetTo,"X","X",0x1C,1,0),
					SetCtrig1X("X","X",0x1C,0,SetTo,Mask[5])}
			Z = Z + 1
			table.insert(Y,X)
			Mask = 0
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
					SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
			Z = Z + 1
			table.insert(Y,X)
			Value = 0
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x20,1,0),
					SetCtrig1X("X","X",0x20,0,SetTo,Player[5])}
			Z = Z + 1
			table.insert(Y,X)
			Player = 0
		else
			TypeNum = 1
		end
	end

	local TTDeaths2X
	if TypeNum == 0 then
		TTDeaths2X = DeathsX(Player,Exactly,Value,UnitId,Mask)
	elseif TypeNum == 1 then
		TTDeaths2X = CtrigX(Player[1],Player[2],Player[3],Player[4],Exactly,Value,Mask)
	end 
	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,TTDeaths2X)
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTDeathsX = CDeaths("X",Exactly,1,FCode)
	return TTDeathsX
end

function TTMemory(Offset,Type,Value)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	else
		TTMemory_TypeError()
	end
	local TypeNum = 0
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			if type(Value[5]) == "number" then
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
						SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
				Z = Z + 1
				table.insert(Y,X)
				Value = 0
			else
				if Value[5][5] == nil then
					Value[5][5] = 0
				end
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
						SetCtrigX("X","X",0x24,0,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4])}
				Z = Z + 1
				table.insert(Y,X)
				Value = 0
			end
		end
	end

	if type(Offset) == "table" then
		if Offset[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Offset})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Offset = TempData
		end

		if Offset[4] == "V" then
			if Offset[5] == nil then
				Offset[5] = 0
			end
			if type(Offset[5]) == "number" then
				local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
						SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x20,1,0),
						SetCtrig1X("X","X",0x20,0,SetTo,Offset[5])}
				Z = Z + 1
				table.insert(Y,X)
				Offset = 0x58A364
			else
				local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
						SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x20,1,0),
						SetCtrigX("X","X",0x20,0,SetTo,Offset[5][1],Offset[5][2],Offset[5][3],1,Offset[5][4])}
				Z = Z + 1
				table.insert(Y,X)
				Offset = 0x58A364
			end
		else
			TypeNum = 1
		end
	end

	local TTMemory2
	if TypeNum == 0 then
		TTMemory2 = FMemory(Offset,Exactly,Value)
	elseif TypeNum == 1 then
		TTMemory2 = CtrigX(Offset[1],Offset[2],Offset[3],Offset[4],Exactly,Value)
	end 
	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,TTMemory2)
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTMemory = CDeaths("X",Exactly,1,FCode)
	return TTMemory
end

function TTMemoryX(Offset,Type,Value,Mask)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	else
		TTMemoryX_TypeError()
	end
	local TypeNum = 0
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0
	if type(Mask) == "table" then
		if Mask[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Mask})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Mask = TempData
		end

		if Mask[4] == "V" then
			if Mask[5] == nil then
				Mask[5] = 0
			end
			local X = {CallLabelAlways(Mask[1],Mask[2],Mask[3]),
					SetCtrig1X(Mask[1],Mask[2],0x148,Mask[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Mask[1],Mask[2],0x160,Mask[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Mask[1],Mask[2],0x158,Mask[3],SetTo,"X","X",0x1C,1,0),
					SetCtrig1X("X","X",0x1C,0,SetTo,Mask[5])}
			Z = Z + 1
			table.insert(Y,X)
			Mask = 0
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			if type(Value[5]) == "number" then
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
						SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
				Z = Z + 1
				table.insert(Y,X)
				Value = 0
			else
				if Value[5][5] == nil then
					Value[5][5] = 0
				end
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
						SetCtrigX("X","X",0x24,0,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4])}
				Z = Z + 1
				table.insert(Y,X)
				Value = 0
			end
		end
	end

	if type(Offset) == "table" then
		if Offset[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Offset})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Offset = TempData
		end

		if Offset[4] == "V" then
			if Offset[5] == nil then
				Offset[5] = 0
			end
			if type(Offset[5]) == "number" then
				local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
						SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x20,1,0),
						SetCtrig1X("X","X",0x20,0,SetTo,Offset[5])}
				Z = Z + 1
				table.insert(Y,X)
				Offset = 0x58A364
			else
				local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
						SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x20,1,0),
						SetCtrigX("X","X",0x20,0,SetTo,Offset[5][1],Offset[5][2],Offset[5][3],1,Offset[5][4])}
				Z = Z + 1
				table.insert(Y,X)
				Offset = 0x58A364
			end
		else
			TypeNum = 1
		end
	end

	local TTMemory2X
	if TypeNum == 0 then
		TTMemory2X = FMemoryX(Offset,Exactly,Value,Mask)
	elseif TypeNum == 1 then
		TTMemory2X = CtrigX(Offset[1],Offset[2],Offset[3],Offset[4],Exactly,Value,Mask)
	end 
	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,TTMemory2X)
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTMemoryX = CDeaths("X",Exactly,1,FCode)
	return TTMemoryX
end

function TTLMemory(Offset,Type,Value) -- {V,V} / {V,4} / {4,V} -> Cast 사용
	return TTLMemoryX(Offset,Type,Value,0xFFFFFFFF)
end	
function TTLMemoryX(Offset,Type,Value,Mask) -- {V,V} / {V,4} / {4,V} -> Cast 사용
	local Mode
	if Type == ">" or Type == Above then
		Mode = 8
	elseif Type == "<" or Type == Below then
		Mode = 6
	elseif Type == "!=" or Type == NotSame then
		Mode = 4
	elseif Type == "==" or Type == Exactly then
		Mode = 3
	elseif Type == ">=" or Type == AtLeast then
		Mode = 5
	elseif Type == "<=" or Type == AtMost then
		Mode = 7
	else
		TTLMemoryX_Type_Error()
	end

	local TypeNum = 0
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0

	if Mask == "X" or Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "number" then
		Mask = {Mask,Mask}
	elseif type(Mask) == "string" then
		Mask = I64(Mask)
	elseif type(Mask) == "table" and #Mask > 2 then
		if Mask[4] == "WA" then
			local Temp = WarXAlloc
			local TempData = {"X",Temp,0,"W"}

			table.insert(STPushTrigArr,{"MovW",TempData,Mask})

			WarXAlloc = WarXAlloc + 1
			if WarXAlloc > MAXWAlloc then
				MAXWAlloc = WarXAlloc
			end
			Mask = TempData
		end

		if Mask[4] == "W" then
			if Mask[5] == nil then
				Mask[5] = {0,0}
			else
				Mask[5] = I64(Mask[5])
			end
			local X = {CallLabelAlways(Mask[1],Mask[2],Mask[3]),
					SetCtrig1X(Mask[1],Mask[2],0x148,Mask[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Mask[1],Mask[2],0x188,Mask[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Mask[1],Mask[2],0x160,Mask[3],SetTo,Add*16777216,0xFF000000),
					SetCtrig1X(Mask[1],Mask[2],0x1A0,Mask[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Mask[1],Mask[2],0x158,Mask[3],SetTo,"X","X",0x1C+0x14,1,0),
					SetCtrigX(Mask[1],Mask[2],0x198,Mask[3],SetTo,"X","X",0x1C,1,0),
					SetCtrig1X("X","X",0x1C+0x14,0,SetTo,Mask[5][1]),
					SetCtrig1X("X","X",0x1C,0,SetTo,Mask[5][2])}
			Z = Z + 1
			table.insert(Y,X)
			Mask = {0,0}
		end
	end

	if type(Value) == "string" then
		Value = I64(Value)
	elseif type(Value) == "table" and #Value > 2 then
		if Value[4] == "WA" then
			local Temp = WarXAlloc
			local TempData = {"X",Temp,0,"W"}

			table.insert(STPushTrigArr,{"MovW",TempData,Value})

			WarXAlloc = WarXAlloc + 1
			if WarXAlloc > MAXWAlloc then
				MAXWAlloc = WarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "W" then
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x188,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrig1X(Value[1],Value[2],0x1A0,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24+0x14,1,0),
					SetCtrigX(Value[1],Value[2],0x198,Value[3],SetTo,"X","X",0x24,1,0)}

			if Value[5] == nil then
				Value[5] = {0,0}
				table.insert(X,SetCtrig1X("X","X",0x24+0x14,0,SetTo,Value[5][1]))
				table.insert(X,SetCtrig1X("X","X",0x24,0,SetTo,Value[5][2]))
			elseif type(Value[5]) == "string" then
				Value[5] = I64(Value[5])
				table.insert(X,SetCtrig1X("X","X",0x24+0x14,0,SetTo,Value[5][1]))
				table.insert(X,SetCtrig1X("X","X",0x24,0,SetTo,Value[5][2]))
			else
				if type(Value[5][1]) == "number" then
					table.insert(X,SetCtrig1X("X","X",0x24+0x14,0,SetTo,Value[5][1]))
				else
					table.insert(X,SetCtrigX("X","X",0x24+0x14,0,SetTo,Value[5][1][1],Value[5][1][2],Value[5][1][3],1,Value[5][1][4]))
				end
				if type(Value[5][2]) == "number" then
					table.insert(X,SetCtrig1X("X","X",0x24,0,SetTo,Value[5][2]))
				else
					table.insert(X,SetCtrigX("X","X",0x24,0,SetTo,Value[5][2][1],Value[5][2][2],Value[5][2][3],1,Value[5][2][4]))
				end
			end

			Z = Z + 1
			table.insert(Y,X)
			Value = {0,0}
		end
	end

	if type(Offset) == "number" then
		Offset = {Offset,Offset+0x4}
		TypeNum = 0
	elseif type(Offset) == "string" then
		Offset = I64(Offset)
		TypeNum = 0
	elseif type(Offset) == "table" and #Offset == 2 then
		if type(Offset[1]) == "number" and type(Offset[2]) == "number" then
			TypeNum = 0
		elseif type(Offset[1]) == "number" and type(Offset[2]) == "table" and #Offset[2] == 1 then
			Offset = {Offset[1],Offset[1]+Offset[2][1]}
			TypeNum = 0
		elseif type(Offset[1]) == "number" and type(Offset[2]) == "table" then
			TypeNum = 1
		elseif type(Offset[1]) == "table" and type(Offset[2]) == "number"then
			TypeNum = 2
		elseif type(Offset[1]) == "table" and type(Offset[2]) == "table" and #Offset[2] == 1 then
			TypeNum = 3
			local TempX = {Offset[1][1],Offset[1][2],Offset[1][3]+Offset[2][1],Offset[1][4]}
			Offset[2] = TempX
		elseif type(Offset[1]) == "table" and type(Offset[2]) == "table" then
			TypeNum = 3
		end
	elseif type(Offset) == "table" then
		if Offset[4] == "WA" then
			local Temp = WarXAlloc
			local TempData = {"X",Temp,0,"W"}

			table.insert(STPushTrigArr,{"MovW",TempData,Offset})

			WarXAlloc = WarXAlloc + 1
			if WarXAlloc > MAXWAlloc then
				MAXWAlloc = WarXAlloc
			end
			Offset = TempData
		end

		if Offset[4] == "W" then
			local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
					SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Offset[1],Offset[2],0x188,Offset[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
					SetCtrig1X(Offset[1],Offset[2],0x1A0,Offset[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x20+0x14,1,0),
					SetCtrigX(Offset[1],Offset[2],0x198,Offset[3],SetTo,"X","X",0x20,1,0)}

			if Offset[5] == nil then
				Offset[5] = {0,0}
				table.insert(X,SetCtrig1X("X","X",0x20+0x14,0,SetTo,Offset[5][1]))
				table.insert(X,SetCtrig1X("X","X",0x20,0,SetTo,Offset[5][2]))
			elseif type(Offset[5]) == "string" then
				Offset[5] = I64(Offset[5])
				table.insert(X,SetCtrig1X("X","X",0x20+0x14,0,SetTo,Offset[5][1]))	
				table.insert(X,SetCtrig1X("X","X",0x20,0,SetTo,Offset[5][2]))
			else
				if type(Offset[5][1]) == "number" then
					table.insert(X,SetCtrig1X("X","X",0x20+0x14,0,SetTo,Offset[5][1]))
				else
					table.insert(X,SetCtrigX("X","X",0x20+0x14,0,SetTo,Offset[5][1][1],Offset[5][1][2],Offset[5][1][3],1,Offset[5][1][4]))
				end
				if type(Offset[5][2]) == "number" then
					table.insert(X,SetCtrig1X("X","X",0x20,0,SetTo,Offset[5][2]))
				else
					table.insert(X,SetCtrigX("X","X",0x20,0,SetTo,Offset[5][2][1],Offset[5][2][2],Offset[5][2][3],1,Offset[5][2][4]))
				end
			end
			
			Z = Z + 1
			table.insert(Y,X)
			Offset = {0x58A364,0x58A364}
			TypeNum = 0
		end
	end

	local TTLMemoryX
	if TypeNum == 0 then
		TTLMemoryX = {FMemoryX(Offset[2],Exactly,Value[2],Mask[2]),FMemoryX(Offset[1],Exactly,Value[1],Mask[1])}
	elseif TypeNum == 1 then
		TTLMemoryX = {CtrigX(Offset[2][1],Offset[2][2],Offset[2][3],Offset[2][4],Exactly,Value[2],Mask[2]),FMemoryX(Offset[1],Exactly,Value[1],Mask[1])}
	elseif TypeNum == 2 then
		TTLMemoryX = {FMemoryX(Offset[2],Exactly,Value[2],Mask[2]),CtrigX(Offset[1][1],Offset[1][2],Offset[1][3],Offset[1][4],Exactly,Value[1],Mask[1])}
	elseif TypeNum == 3 then
		TTLMemoryX = {CtrigX(Offset[2][1],Offset[2][2],Offset[2][3],Offset[2][4],Exactly,Value[2],Mask[2]),CtrigX(Offset[1][1],Offset[1][2],Offset[1][3],Offset[1][4],Exactly,Value[1],Mask[1])}
	end 
	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,TTLMemoryX)
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTWemoryX = CDeaths("X",Exactly,1,FCode)
	return TTWemoryX
end

function TTCommand(Player,Type,Value,UnitId)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	else
		TTCommandX_TypeError()
	end

	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x28,1,0),
					SetCtrig1X("X","X",0x28,0,SetTo,UnitId[5],0xFFFF)}
			Z = Z + 1
			table.insert(Y,X)
			UnitId = 0
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
					SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
			Z = Z + 1
			table.insert(Y,X)
			Value = 0
		end
	end

	if type(Player) == "table" and Player ~= CurrentPlayer then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x20,1,0),
					SetCtrig1X("X","X",0x20,0,SetTo,Player[5])}
			Z = Z + 1
			table.insert(Y,X)
			Player = 0
		end
	end

	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,Command(Player,Exactly,Value,UnitId))
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTCommandX = CDeaths("X",Exactly,1,FCode)
	return TTCommandX
end

function TTBring(Player,Type,Value,UnitId,Location)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	else
		TTBringX_TypeError()
	end

	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x28,1,0),
					SetCtrig1X("X","X",0x28,0,SetTo,UnitId[5],0xFFFF)}
			Z = Z + 1
			table.insert(Y,X)
			UnitId = 0
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
					SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
			Z = Z + 1
			table.insert(Y,X)
			Value = 0
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x20,1,0),
					SetCtrig1X("X","X",0x20,0,SetTo,Player[5])}
			Z = Z + 1
			table.insert(Y,X)
			Player = 0
		end
	end

	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,Bring(Player,Exactly,Value,UnitId,Location))
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTBringX = CDeaths("X",Exactly,1,FCode)
	return TTBringX
end

function TTAccumulate(Player,Type,Value,ResourceType)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	else
		TTAccumulateX_TypeError()
	end

	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
					SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
			Z = Z + 1
			table.insert(Y,X)
			Value = 0
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x20,1,0),
					SetCtrig1X("X","X",0x20,0,SetTo,Player[5])}
			Z = Z + 1
			table.insert(Y,X)
			Player = 0
		end
	end

	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,Accumulate(Player,Exactly,Value,ResourceType))
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTAccumulateX = CDeaths("X",Exactly,1,FCode)
	return TTAccumulateX
end

function TTCountdownTimer(Type,Value)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	else
		TTCountdownTimerX_TypeError()
	end

	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
					SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
			Z = Z + 1
			table.insert(Y,X)
			Value = 0
		end
	end

	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,CountdownTimer(Exactly,Value))
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTCountdownTimerX = CDeaths("X",Exactly,1,FCode)
	return TTCountdownTimerX
end

function TTElapsedTime(Type,Value)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	else
		TTElapsedTimeX_TypeError()
	end

	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
					SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
			Z = Z + 1
			table.insert(Y,X)
			Value = 0
		end
	end

	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,ElapsedTime(Exactly,Value))
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTElapsedTimeX = CDeaths("X",Exactly,1,FCode)
	return TTElapsedTimeX
end

function TTKills(Player,Type,Value,UnitId)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	else
		TTKillsX_TypeError()
	end

	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x28,1,0),
					SetCtrig1X("X","X",0x28,0,SetTo,UnitId[5],0xFFFF)}
			Z = Z + 1
			table.insert(Y,X)
			UnitId = 0
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
					SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
			Z = Z + 1
			table.insert(Y,X)
			Value = 0
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x20,1,0),
					SetCtrig1X("X","X",0x20,0,SetTo,Player[5])}
			Z = Z + 1
			table.insert(Y,X)
			Player = 0
		end
	end

	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,Kills(Player,Exactly,Value,UnitId))
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTKillsX = CDeaths("X",Exactly,1,FCode)
	return TTKillsX
end

function TTScore(Player,ScoreType,Type,Value)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	else
		TTScoreX_TypeError()
	end

	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
					SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
			Z = Z + 1
			table.insert(Y,X)
			Value = 0
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x20,1,0),
					SetCtrig1X("X","X",0x20,0,SetTo,Player[5])}
			Z = Z + 1
			table.insert(Y,X)
			Player = 0
		end
	end

	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,Score(Player,ScoreType,Exactly,Value))
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTScoreX = CDeaths("X",Exactly,1,FCode)
	return TTScoreX
end

function TTOpponents(Player,Type,Value)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	else
		TTOpponentsX_TypeError()
	end

	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
					SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
			Z = Z + 1
			table.insert(Y,X)
			Value = 0
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x20,1,0),
					SetCtrig1X("X","X",0x20,0,SetTo,Player[5])}
			Z = Z + 1
			table.insert(Y,X)
			Player = 0
		end
	end

	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,Opponents(Player,Exactly,Value))
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTOpponentsX = CDeaths("X",Exactly,1,FCode)
	return TTOpponentsX
end

-- 매크로 함수형 최종 연산 함수(C) ------------------------------------------------------

function CRead(PlayerID,Dest,Source,Deviation,Mask,EPDRead,Clear) -- f_maskread
	STPopTrigArr(PlayerID)
	if EPDRead == "X" then
		EPDRead = nil
	end
	if Mask == "X" then
		Mask = nil
	end
	if Deviation == "X" then
		Deviation = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	if Deviation == nil then
		Deviation = 0
	end

	local Mask2 = Mask
	if Clear == 1 then
		Mask2 = 0xFFFFFFFF
	end

	Recover = 0
	CRead1 = {}
	CRead2 = {}
	CRead3 = {}

	if type(Source) == "table" and Source[4] == "VA" then
		local TempRet = {"X",CRet[7],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	end
	if type(Source) == "table" and Source[4] == "A" then
		local TempRet = {"X",CRet[7],0,"V"}
		MovZ(PlayerID,TempRet,Source)
		Source = TempRet
	end
	local PDest
	if type(Dest) == "table" and Dest[4] == "VA" then
		PDest = Dest
		Dest = {"X",CRet[8],0,"V"}
	end
	if type(Dest) == "table" and Dest[4] == "A" then
		PDest = Dest
		Dest = {"X",CRet[8],0,"V"}
	end

	if EPDRead == nil then
		if type(Dest) == "number" then 
			if type(Source) == "number" then -- Read 0x58A364, 0x58A368 : 0x58A364 << 0x58A368 + D
					CRead1 = {SetMemoryX(Dest,SetTo,Deviation,Mask)}
			elseif Source == "Cp" then -- Read 0x58A364, Cp : 0x58A364 << Cp + D
					CRead1 = {SetMemoryX(Dest,SetTo,Deviation,Mask)}
			elseif Source[4] == "V" then -- Read 0x58A364, X : 0x58A364 << EPD(X) + D (CPRead)
					CRead1 = {SetMemoryX(Dest,SetTo,Deviation,Mask)}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,SetTo,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0));
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
					Recover = 1
			else -- Read 0x58A364, Mem : 0x58A364 << Mem + D
					CRead1 = {SetMemoryX(Dest,SetTo,Deviation,Mask)}
			end
		elseif Dest == "Cp" then
			if type(Source) == "number" then -- Read Cp, 0x58A368 : Cp << 0x58A368 + D
					CRead1 = {SetDeathsX(CurrentPlayer,SetTo,Deviation,0,Mask)}
			elseif Source == "Cp" then -- Read Cp, Cp : Cp << Cp + D / Cp중복
				CRead_InputData_Error()
			elseif Source[4] == "V" then -- Read Cp, X : Cp << EPD(X) + D (CPRead) / Cp중복
				CRead_InputData_Error()
			else -- Read Cp, Mem : Cp << Mem + D
					CRead1 = {SetDeathsX(CurrentPlayer,SetTo,Deviation,0,Mask)}
			end
		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- Read X, 0x58A364 : X << 0x58A364 + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2)}
			elseif Source == "Cp" then  -- Read X, Cp : X << Cp + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2)}
			elseif Source[4] == "V" then -- Read X, Y : X << EPD(Y) + D (CPRead)
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2)}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,SetTo,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0));
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
					Recover = 1
			else -- Read X, Mem : X << Mem + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2)}
			end
		else 
			if type(Source) == "number" then -- Read Mem, 0x58A364 : Mem << 0x58A364 + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation,Mask)}
			elseif Source == "Cp" then -- Read Mem, Cp : Mem << Cp + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation,Mask)}
			elseif Source[4] == "V" then -- Read Mem, X : Mem << EPD(X) + D (CPRead)
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation,Mask)}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,SetTo,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0));
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
					Recover = 1
			else -- Read Mem1, Mem2 : Mem1 << Mem2 + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation,Mask)}
			end
		end

		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				CRead1,
			},
			flag = {Preserved}
		}
		for i = 0, 31 do
			local CBit = bit32.band(Mask, 2^i)
			if type(Dest) == "number" then 
				if type(Source) == "number" then -- Read 0x58A364, 0x58A368 : 0x58A364 << 0x58A368 + D
						CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
						CRead3 = {SetMemory(Dest,Add,CBit)}
				elseif Source == "Cp" then -- Read 0x58A364, Cp : 0x58A364 << Cp + D
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetMemory(Dest,Add,CBit)}
				elseif Source[4] == "V" then -- Read 0x58A364, X : 0x58A364 << EPD(X) + D (CPRead)
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetMemory(Dest,Add,CBit)}
						Recover = 1
				else -- Read 0x58A364, Mem : 0x58A364 << Mem + D
						CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
						CRead3 = {SetMemory(Dest,Add,CBit)}
				end
			elseif Dest == "Cp" then
				if type(Source) == "number" then -- Read Cp, 0x58A368 : Cp << 0x58A368 + D
						CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
						CRead3 = {SetDeaths(CurrentPlayer,Add,CBit,0)}
				elseif Source == "Cp" then -- Read Cp, Cp : Cp << Cp + D / Cp중복
					CRead_InputData_Error()
				elseif Source[4] == "V" then -- Read Cp, X : Cp << EPD(X) + D (CPRead) / Cp중복
					CRead_InputData_Error()
				else -- Read Cp, Mem : Cp << Mem + D
						CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
						CRead3 = {SetDeaths(CurrentPlayer,Add,CBit,0)}
				end
			elseif Dest[4] == "V" then
				if type(Source) == "number" then -- Read X, 0x58A364 : X << 0x58A364 + D
						CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit)}
				elseif Source == "Cp" then  -- Read X, Cp : X << Cp + D
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit)}
				elseif Source[4] == "V" then -- Read X, Y : X << EPD(Y) + D (CPRead)
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit)}
						Recover = 1
				else -- Read X, Mem : X << Mem + D
						CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit)}
				end
			else 
				if type(Source) == "number" then -- Read Mem, 0x58A364 : Mem << 0x58A364 + D
						CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit)}
				elseif Source == "Cp" then -- Read Mem, Cp : Mem << Cp + D
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit)}
				elseif Source[4] == "V" then -- Read Mem, X : Mem << EPD(X) + D (CPRead)
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit)}
						Recover = 1
				else -- Read Mem1, Mem2 : Mem1 << Mem2 + D
						CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit)}
				end
			end
			if CBit == 2^i then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					   	CRead2,
					},
					actions = {
						CRead3,
					},
					flag = {Preserved}
				}
			end
		end
	else
		if type(Dest) == "number" then 
			if type(Source) == "number" then -- Read 0x58A364, 0x58A368 : 0x58A364 << 0x58A368 + D
					CRead1 = {SetMemory(Dest,SetTo,-1452249)}
			elseif Source == "Cp" then -- Read 0x58A364, Cp : 0x58A364 << Cp + D
					CRead1 = {SetMemory(Dest,SetTo,-1452249)}
			elseif Source[4] == "V" then -- Read 0x58A364, X : 0x58A364 << EPD(X) + D (CPRead)
					CRead1 = {SetMemoryX(Dest,SetTo,-1452249)}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,SetTo,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0));
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
					Recover = 1
			else -- Read 0x58A364, Mem : 0x58A364 << Mem + D
					CRead1 = {SetMemory(Dest,SetTo,-1452249)}
			end
		elseif Dest == "Cp" then
			if type(Source) == "number" then -- Read Cp, 0x58A368 : Cp << 0x58A368 + D
					CRead1 = {SetDeaths(CurrentPlayer,SetTo,-1452249,0)}
			elseif Source == "Cp" then -- Read Cp, Cp : Cp << Cp + D / Cp중복
				CRead_InputData_Error()
			elseif Source[4] == "V" then -- Read Cp, X : Cp << EPD(X) + D (CPRead) / Cp중복
				CRead_InputData_Error()
			else -- Read Cp, Mem : Cp << Mem + D
					CRead1 = {SetDeaths(CurrentPlayer,SetTo,-1452249,0)}
			end
		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- Read X, 0x58A364 : X << 0x58A364 + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,-1452249)}
			elseif Source == "Cp" then  -- Read X, Cp : X << Cp + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,-1452249)}
			elseif Source[4] == "V" then -- Read X, Y : X << EPD(Y) + D (CPRead)
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,-1452249)}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,SetTo,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0));
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
					Recover = 1
			else -- Read X, Mem : X << Mem + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,-1452249)}
			end
		else 
			if type(Source) == "number" then -- Read Mem, 0x58A364 : Mem << 0x58A364 + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,-1452249)}
			elseif Source == "Cp" then -- Read Mem, Cp : Mem << Cp + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,-1452249)}
			elseif Source[4] == "V" then -- Read Mem, X : Mem << EPD(X) + D (CPRead)
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,-1452249)}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,SetTo,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0));
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
					Recover = 1
			else -- Read Mem1, Mem2 : Mem1 << Mem2 + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,-1452249)}
			end
		end
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				CRead1,
			},
			flag = {Preserved}
		}
		for i = 2, 31 do
			local CBit = bit32.band(Mask, 2^i)
			if type(Dest) == "number" then 
				if type(Source) == "number" then -- Read 0x58A364, 0x58A368 : 0x58A364 << 0x58A368 + D
						CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
						CRead3 = {SetMemory(Dest,Add,CBit/4)}
				elseif Source == "Cp" then -- Read 0x58A364, Cp : 0x58A364 << Cp + D
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetMemory(Dest,Add,CBit/4)}
				elseif Source[4] == "V" then -- Read 0x58A364, X : 0x58A364 << EPD(X) + D (CPRead)
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetMemory(Dest,Add,CBit/4)}
						Recover = 1
				else -- Read 0x58A364, Mem : 0x58A364 << Mem + D
						CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
						CRead3 = {SetMemory(Dest,Add,CBit/4)}
				end
			elseif Dest == "Cp" then
				if type(Source) == "number" then -- Read Cp, 0x58A368 : Cp << 0x58A368 + D
						CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
						CRead3 = {SetDeaths(CurrentPlayer,Add,CBit/4,0)}
				elseif Source == "Cp" then -- Read Cp, Cp : Cp << Cp + D / Cp중복
					CRead_InputData_Error()
				elseif Source[4] == "V" then -- Read Cp, X : Cp << EPD(X) + D (CPRead) / Cp중복
					CRead_InputData_Error()
				else -- Read Cp, Mem : Cp << Mem + D
						CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
						CRead3 = {SetDeaths(CurrentPlayer,Add,CBit/4,0)}
				end
			elseif Dest[4] == "V" then
				if type(Source) == "number" then -- Read X, 0x58A364 : X << 0x58A364 + D
						CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit/4)}
				elseif Source == "Cp" then  -- Read X, Cp : X << Cp + D
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit/4)}
				elseif Source[4] == "V" then -- Read X, Y : X << EPD(Y) + D (CPRead)
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit/4)}
						Recover = 1
				else -- Read X, Mem : X << Mem + D
						CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit/4)}
				end
			else 
				if type(Source) == "number" then -- Read Mem, 0x58A364 : Mem << 0x58A364 + D
						CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit/4)}
				elseif Source == "Cp" then -- Read Mem, Cp : Mem << Cp + D
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit/4)}
				elseif Source[4] == "V" then -- Read Mem, X : Mem << EPD(X) + D (CPRead)
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit/4)}
						Recover = 1
				else -- Read Mem1, Mem2 : Mem1 << Mem2 + D
						CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit/4)}
				end
			end
			if CBit == 2^i then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					   	CRead2,
					},
					actions = {
						CRead3,
					},
					flag = {Preserved}
				}
			end
		end
	end

	if Recover == 1 then
		RecoverCp(PlayerID)
	end

	if PDest ~= nil then
		MovX(PlayerID,PDest,Dest)
	end
end

function CReadX(PlayerID,Dest,Source,Deviation,Mask,Multiplier,Clear) -- f_ConvertRead
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end
	if Deviation == "X" then
		Deviation = nil
	end
	if Multiplier == "X" then
		Multiplier = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	if Deviation == nil then
		Deviation = 0
	end
	if Multiplier == nil then
		Multiplier = 1
	end

	local Mask2 = Mask
	if Clear == 1 then
		Mask2 = 0xFFFFFFFF
	end

	Recover = 0
	CRead1 = {}
	CRead2 = {}
	CRead3 = {}

	if type(Source) == "table" and Source[4] == "VA" then
		local TempRet = {"X",CRet[7],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	end
	if type(Source) == "table" and Source[4] == "A" then
		local TempRet = {"X",CRet[7],0,"V"}
		MovZ(PlayerID,TempRet,Source)
		Source = TempRet
	end
	local PDest
	if type(Dest) == "table" and Dest[4] == "VA" then
		PDest = Dest
		Dest = {"X",CRet[8],0,"V"}
	end
	if type(Dest) == "table" and Dest[4] == "A" then
		PDest = Dest
		Dest = {"X",CRet[8],0,"V"}
	end

	if type(Dest) == "number" then 
		if type(Source) == "number" then -- Read 0x58A364, 0x58A368 : 0x58A364 << 0x58A368 + D
				CRead1 = {SetMemoryX(Dest,SetTo,Deviation,Mask)}
		elseif Source == "Cp" then -- Read 0x58A364, Cp : 0x58A364 << Cp + D
				CRead1 = {SetMemoryX(Dest,SetTo,Deviation,Mask)}
		elseif Source[4] == "V" then -- Read 0x58A364, X : 0x58A364 << EPD(X) + D (CPRead)
				CRead1 = {SetMemoryX(Dest,SetTo,Deviation,Mask)}
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,SetTo,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0));
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				Recover = 1
		else -- Read 0x58A364, Mem : 0x58A364 << Mem + D
				CRead1 = {SetMemoryX(Dest,SetTo,Deviation,Mask)}
		end
	elseif Dest == "Cp" then
		if type(Source) == "number" then -- Read Cp, 0x58A368 : Cp << 0x58A368 + D
				CRead1 = {SetDeathsX(CurrentPlayer,SetTo,Deviation,0,Mask)}
		elseif Source == "Cp" then -- Read Cp, Cp : Cp << Cp + D / Cp중복
			CRead_InputData_Error()
		elseif Source[4] == "V" then -- Read Cp, X : Cp << EPD(X) + D (CPRead) / Cp중복
			CRead_InputData_Error()
		else -- Read Cp, Mem : Cp << Mem + D
				CRead1 = {SetDeathsX(CurrentPlayer,SetTo,Deviation,0,Mask)}
		end
	elseif Dest[4] == "V" then
		if type(Source) == "number" then -- Read X, 0x58A364 : X << 0x58A364 + D
				CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2)}
		elseif Source == "Cp" then  -- Read X, Cp : X << Cp + D
				CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2)}
		elseif Source[4] == "V" then -- Read X, Y : X << EPD(Y) + D (CPRead)
				CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2)}
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,SetTo,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0));
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				Recover = 1
		else -- Read X, Mem : X << Mem + D
				CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2)}
		end
	else 
		if type(Source) == "number" then -- Read Mem, 0x58A364 : Mem << 0x58A364 + D
				CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation,Mask)}
		elseif Source == "Cp" then -- Read Mem, Cp : Mem << Cp + D
				CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation,Mask)}
		elseif Source[4] == "V" then -- Read Mem, X : Mem << EPD(X) + D (CPRead)
				CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation,Mask)}
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,SetTo,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0));
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				Recover = 1
		else -- Read Mem1, Mem2 : Mem1 << Mem2 + D
				CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation,Mask)}
		end
	end

	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(0);
		},
		actions = {
			CRead1,
		},
		flag = {Preserved}
	}
	local Check = 0
	for i = 0, 31 do
		local CBit = bit32.band(Mask, 2^i)
		if type(Dest) == "number" then 
			if type(Source) == "number" then -- Read 0x58A364, 0x58A368 : 0x58A364 << 0x58A368 + D
					CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
					CRead3 = {SetMemory(Dest,Add,CBit*Multiplier)}
			elseif Source == "Cp" then -- Read 0x58A364, Cp : 0x58A364 << Cp + D
					CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
					CRead3 = {SetMemory(Dest,Add,CBit*Multiplier)}
			elseif Source[4] == "V" then -- Read 0x58A364, X : 0x58A364 << EPD(X) + D (CPRead)
					CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
					CRead3 = {SetMemory(Dest,Add,CBit*Multiplier)}
					Recover = 1
			else -- Read 0x58A364, Mem : 0x58A364 << Mem + D
					CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
					CRead3 = {SetMemory(Dest,Add,CBit*Multiplier)}
			end
		elseif Dest == "Cp" then
			if type(Source) == "number" then -- Read Cp, 0x58A368 : Cp << 0x58A368 + D
					CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
					CRead3 = {SetDeaths(CurrentPlayer,Add,CBit*Multiplier,0)}
			elseif Source == "Cp" then -- Read Cp, Cp : Cp << Cp + D / Cp중복
				CRead_InputData_Error()
			elseif Source[4] == "V" then -- Read Cp, X : Cp << EPD(X) + D (CPRead) / Cp중복
				CRead_InputData_Error()
			else -- Read Cp, Mem : Cp << Mem + D
					CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
					CRead3 = {SetDeaths(CurrentPlayer,Add,CBit*Multiplier,0)}
			end
		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- Read X, 0x58A364 : X << 0x58A364 + D
					CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
					CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit*Multiplier)}
			elseif Source == "Cp" then  -- Read X, Cp : X << Cp + D
					CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
					CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit*Multiplier)}
			elseif Source[4] == "V" then -- Read X, Y : X << EPD(Y) + D (CPRead)
					CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
					CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit*Multiplier)}
					Recover = 1
			else -- Read X, Mem : X << Mem + D
					CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
					CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit*Multiplier)}
			end
		else 
			if type(Source) == "number" then -- Read Mem, 0x58A364 : Mem << 0x58A364 + D
					CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
					CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit*Multiplier)}
			elseif Source == "Cp" then -- Read Mem, Cp : Mem << Cp + D
					CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
					CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit*Multiplier)}
			elseif Source[4] == "V" then -- Read Mem, X : Mem << EPD(X) + D (CPRead)
					CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
					CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit*Multiplier)}
					Recover = 1
			else -- Read Mem1, Mem2 : Mem1 << Mem2 + D
					CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
					CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit*Multiplier)}
			end
		end
		if CBit == 2^i and CBit*Multiplier >= 1 and Check == 0 then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				   	CRead2,
				},
				actions = {
					CRead3,
				},
				flag = {Preserved}
			}
		end
		if bit32.band(CBit*Multiplier,0xFFFFFFFF) >= 0x80000000 then
			Check = 1
		end
	end

	if Recover == 1 then
		RecoverCp(PlayerID)
	end

	if PDest ~= nil then
		MovX(PlayerID,PDest,Dest)
	end
end

function CMov(PlayerID,Dest,Source,Deviation,Mask,Clear) -- <<
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end
	if Deviation == "X" then
		Deviation = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	if Deviation == nil then
		Deviation = 0
	end

	local Mask2 = Mask
	if Clear == 1 then
		Mask2 = 0xFFFFFFFF
	end

	if type(Source) == "table" and Source[4] == "VA" then
		local TempRet = {"X",CRet[7],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	end
	if type(Source) == "table" and Source[4] == "A" then
		CMov_InputData_Error()
	end
	local PDest
	if type(Dest) == "table" and Dest[4] == "VA" then
		PDest = Dest
		Dest = {"X",CRet[8],0,"V"}
	end
	if type(Dest) == "table" and Dest[4] == "A" then
		PDest = Dest
		Dest = {"X",CRet[8],0,"V"}
	end

	if type(Dest) == "number" then -- Mov 0x58A364, 1 : 0x58A364 << 1
		if type(Source) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetMemoryX(Dest,SetTo,Source,Mask);
					},
					flag = {Preserved}
				}
		elseif Source[4] == "V" then -- Mov 0x58A364, X : 0x58A364 << X + D
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetMemoryX(Dest,SetTo,Deviation,Mask);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(Dest));
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
		else
			CMov_InputData_Error()
		end
	elseif Dest == "Cp" then
		if type(Source) == "number" then -- Mov Cp, 1 : Cp << 1
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeathsX(CurrentPlayer,SetTo,Source,0,Mask);
					},
					flag = {Preserved}
				}
		elseif Source[4] == "V" then -- Mov Cp, X : Cp << X + D
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeathsX(CurrentPlayer,SetTo,Deviation,0,Mask);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,13);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
		else
			CMov_InputData_Error()
		end
	elseif Dest[4] == "V" then
		if type(Source) == "number" then -- Mov X, 1 : X << 1
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source,Mask2);
					},
					flag = {Preserved}
				}
		elseif Source[4] == "V" then -- Mov X, Y : X << Y + D
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
		else
			CMov_InputData_Error()
		end

	else 
		if type(Source) == "number" then -- Mov Mem 1 : Mem << 1
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Source,Mask);
					},
					flag = {Preserved}
				}
		elseif Source[4] == "V" then -- Mov Mem, X : Mem << X + D
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation,Mask);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask),
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
		else
			CMov_InputData_Error()
		end

	end

	if PDest ~= nil then
		MovX(PlayerID,PDest,Dest)
	end
end

function CWrite(PlayerID,Dest,Source,Deviation,Mask) -- << (CRead 대응)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end
	if Deviation == "X" then
		Deviation = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	if Deviation == nil then
		Deviation = 0
	end

	if type(Source) == "table" and Source[4] == "VA" then
		local TempRet = {"X",CRet[7],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	end
	local PDest
	if type(Dest) == "table" and Dest[4] == "VA" then
		local TempRet = {"X",CRet[8],0,"V"}
		MovX(PlayerID,TempRet,Dest)
		Dest = TempRet
	end
	
	if Dest[4] == "V" then
		if Dest[5] == nil then
			Dest[5] = 0
		end
		if type(Source) == "number" then -- Write X, 1 : EPD(X) << 1
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x158,1,SetTo,Dest[5]);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						FSetMemoryX(0,SetTo,Source,Mask);
					},
					flag = {Preserved}
				}
		elseif Source[4] == "V" then -- Write X, Y : EPD(X) << Y + D
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x15C,1,SetTo,Deviation);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x15C,1,1);
						SetCtrig1X("X","X",0x158,1,SetTo,Dest[5]);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
						CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						FSetMemoryX(0,SetTo,0,Mask);
					},
					flag = {Preserved}
				}
		else
			CWrite_InputData_Error()
		end
	else
		CWrite_InputData_Error()
	end
end

function ClShift(PlayerID,Dest,Source,Operand,Mask) -- << (x2)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if Operand == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			ClShift_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			ClShift_InputData_Error()
		end
		if type(Dest) == "number" then 
			ClShift_InputData_Error()
		elseif Dest == "Cp" then
			ClShift_InputData_Error()
		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- And X, 1 : X <<= 1 (max 31)
				if Source >= 32 or Source <= 0 then
					Source = math.abs(Source % 32)
				end
				if Source ~= 0 then
					local Repeat = Source
					Trigger {
						players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x4,1,SetTo,"X","X",0,0,1); -- Make Loop Action A->A
								SetCtrigX("X","X",0x158,1,SetTo,"X","X",0x164+0x20*Repeat,1,1); -- Reset Timer
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x1BC,1,1);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
								SetCtrigX("X","X",0x1B8,1,SetTo,"X","X",0x1BC,1,1);
								SetCtrig1X("X","X",0x1A8,1,SetTo,0xFFFFFFFF);
								SetCtrig1X("X","X",0x1C0,1,SetTo,Add*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
							},
							flag = {Preserved}
						}
					Trigger {
						players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X","X",0x164+0x20*Repeat,0,SetTo,0x0,0x2); -- Timer Action
								Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1)); -- Exit Action
								SetCtrig1X("X","X",0x158,0,Subtract,8); -- Run Tick
								SetMemoryX(0,SetTo,0,0xFFFFFFFF); -- Temp Variable
								},
								flag = {Preserved}
							}
					Trigger {
						players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X","X",0x184,-1,SetTo,0x2,0x2); -- Reset Flag
								SetCtrigX("X","X",0x1B8,-1,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X","X",0x1A8,-1,SetTo,Mask);
								SetCtrig1X("X","X",0x1C0,-1,SetTo,SetTo*16777216,0xFF000000);
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1);
								SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1);
								},
								flag = {Preserved}
							}
				end
			elseif Source[4] == "V" then -- And X, Y : X <<= Y
				Trigger {
					players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
							CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,0,0x1F);
						},
						actions = {
							SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,4);
						},
						flag = {Preserved}
					}
				Trigger {
					players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x178,1,SetTo,"X","X",0x1A0+0x20*1,1,1); -- Reset Timer
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0x1F);
							SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
							SetCtrigX("X",CRet[1],0x158,0,SetTo,"X","X",0x178,1,1);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);

							SetCtrigX("X","X",0x4,1,SetTo,"X","X",0,0,1); -- Make Loop Action A->A
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x15C,1,1);
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X","X",0x158,1,SetTo,"X","X",0x15C,1,1);
							SetCtrig1X("X","X",0x148,1,SetTo,0xFFFFFFFF);
							SetCtrig1X("X","X",0x160,1,SetTo,Add*16777216,0xFF000000);
							CallLabelAlways3(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3],"X",CRet[1],0);
						},
						flag = {Preserved}
					}
				Trigger {
					players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemoryX(0,SetTo,0,0xFFFFFFFF); -- Temp Variable
							SetCtrig1X("X","X",0x1A0+0x20*1,0,SetTo,0x0,0x2); -- Timer Action
							SetCtrig1X("X","X",0x158+0x20*1,0,Subtract,1); -- Run Tick
							Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1)); -- Exit Action
							},
							flag = {Preserved}
						}
				Trigger {
					players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x158+0x20*1,-1,Add,32); -- Reset Flag
							SetCtrig1X("X","X",0x1A4+0x20*1,-1,SetTo,0x2,0x2); -- Reset Flag
							SetCtrigX("X","X",0x158,-1,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X("X","X",0x148,-1,SetTo,Mask);
							SetCtrig1X("X","X",0x160,-1,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1);
							SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,2);
							},
							flag = {Preserved}
						}
				Trigger {
					players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x4,-4,SetTo,"X","X",0x0,0,-3);
						},
							flag = {Preserved}
						}	
			else
				ClShift_InputData_Error()
			end
		else 
			ClShift_InputData_Error()
		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Operand) == "table" and Operand[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Operand)
			Operand = TempRet
		end
		if type(Operand) == "table" and Operand[4] == "A" then
			ClShift_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			ClShift_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			ClShift_InputData_Error()
		end

		if type(Source) == "number" then -- And V, 0x58A364, 1 : V << 0x58A364 & 1 / Read필요
			if type(Operand) == "number" then
				ClShift_InputData_Error()
			elseif Operand[4] == "V" then -- And V, 0x58A364, X : V << 0x58A364 & X / Read필요
				ClShift_InputData_Error()
			else
				ClShift_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Operand) == "number" then -- And V, Cp, 1 : V << Cp & 1 / Read필요 
				ClShift_InputData_Error()
			elseif Operand[4] == "V" then -- And V, Cp, X : V << Cp & X / Read필요 
				ClShift_InputData_Error()
			else
				ClShift_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Operand) == "number" then -- And V, X, 1 : V << (X << 1)
				if Operand >= 32 or Operand <= 0 then
					Operand = math.abs(Operand % 32)
				end
				if Operand ~= 0 then
					local Repeat = Operand
					Trigger {
						players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x4,1,SetTo,"X","X",0,0,1); -- Make Loop Action A->A
								SetCtrigX("X","X",0x158,1,SetTo,"X","X",0x164+0x20*Repeat,1,1); -- Reset Timer
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x1BC,1,1);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								SetCtrigX("X","X",0x1B8,1,SetTo,"X","X",0x1BC,1,1);
								SetCtrig1X("X","X",0x1A8,1,SetTo,0xFFFFFFFF);
								SetCtrig1X("X","X",0x1C0,1,SetTo,Add*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
							},
							flag = {Preserved}
						}
					Trigger {
						players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X","X",0x164+0x20*Repeat,0,SetTo,0x0,0x2); -- Timer Action
								Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1)); -- Exit Action
								SetCtrig1X("X","X",0x158,0,Subtract,8); -- Run Tick
								SetMemoryX(0,SetTo,0,0xFFFFFFFF); -- Temp Variable
								},
								flag = {Preserved}
							}
					Trigger {
						players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X","X",0x184,-1,SetTo,0x2,0x2); -- Reset Flag
								SetCtrigX("X","X",0x1B8,-1,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X","X",0x1A8,-1,SetTo,Mask);
								SetCtrig1X("X","X",0x1C0,-1,SetTo,SetTo*16777216,0xFF000000);
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1);
								SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1);
								},
								flag = {Preserved}
							}
				end
			elseif Operand[4] == "V" then -- And V, X, Y : V << (X << Y)
				Trigger {
					players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
							CtrigX(Operand[1],Operand[2],0x15C,Operand[3],Exactly,0,0x1F);
						},
						actions = {
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
							SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0x0,0,4);
						},
						flag = {Preserved}
					}
				Trigger {
					players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x178,1,SetTo,"X","X",0x1A0+0x20*1,1,1); -- Reset Timer
							SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0x1F);
							SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
							SetCtrigX("X",CRet[1],0x158,0,SetTo,"X","X",0x178,1,1);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);

							SetCtrigX("X","X",0x4,1,SetTo,"X","X",0,0,1); -- Make Loop Action A->A
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x15C,1,1);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X","X",0x158,1,SetTo,"X","X",0x15C,1,1);
							SetCtrig1X("X","X",0x148,1,SetTo,0xFFFFFFFF);
							SetCtrig1X("X","X",0x160,1,SetTo,Add*16777216,0xFF000000);
							CallLabelAlways3(Source[1],Source[2],Source[3],Operand[1],Operand[2],Operand[3],"X",CRet[1],0);
						},
						flag = {Preserved}
					}
				Trigger {
					players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemoryX(0,SetTo,0,0xFFFFFFFF); -- Temp Variable
							SetCtrig1X("X","X",0x1A0+0x20*1,0,SetTo,0x0,0x2); -- Timer Action
							SetCtrig1X("X","X",0x158+0x20*1,0,Subtract,1); -- Run Tick
							Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1)); -- Exit Action
							},
							flag = {Preserved}
						}
				Trigger {
					players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x158+0x20*1,-1,Add,32); -- Reset Flag
							SetCtrig1X("X","X",0x1A4+0x20*1,-1,SetTo,0x2,0x2); -- Reset Flag
							SetCtrigX("X","X",0x158,-1,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X("X","X",0x148,-1,SetTo,Mask);
							SetCtrig1X("X","X",0x160,-1,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1);
							SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,2);
							},
							flag = {Preserved}
						}
				Trigger {
					players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x4,-4,SetTo,"X","X",0x0,0,-3);
						},
							flag = {Preserved}
						}	
			else
				ClShift_InputData_Error()
			end
		else 
			if type(Operand) == "number" then -- And V, Mem, 1 : V << Mem & 1 / Read필요
				ClShift_InputData_Error()
			elseif Operand[4] == "V" then -- And V, Mem, X : V << Mem & X / Read필요
				ClShift_InputData_Error()
			else
				ClShift_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		ClShift_InputData_Error()
	end
end

function CAdd(PlayerID,Dest,Source,Operand,Mask) -- +
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if Operand == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CAdd_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end

		if type(Dest) == "number" then -- Add 0x58A364, 1 : 0x58A364 += 1
			if type(Source) == "number" then
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(Dest,Add,Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- Add 0x58A364, X : 0x58A364 += X
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(Dest));
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
			else
				CAdd_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- Add Cp, 1 : Cp += 1
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetDeaths(CurrentPlayer,Add,Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- Add Cp, X : Cp += X
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,13);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
			else
				CAdd_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- Add X, 1 : X += 1
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- Add X, Y : X += Y
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
			else
				CAdd_InputData_Error()
			end

		else 
			if type(Source) == "number" then -- Add Mem, 1 : Mem += 1
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- Add Mem, X : Mem += X
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
			else
				CAdd_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Operand) == "table" and Operand[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Operand)
			Operand = TempRet
		end
		if type(Operand) == "table" and Operand[4] == "A" then
			CAdd_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CAdd_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end

		if type(Source) == "number" then -- Add V, 0x58A364, 1 : V << 0x58A364 + 1 / Read필요
			if type(Operand) == "number" then
				CAdd_InputData_Error()
			elseif Operand[4] == "V" then -- Add V, 0x58A364, X : V << 0x58A364 + X / Read필요
				CAdd_InputData_Error()
			else
				CAdd_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Operand) == "number" then -- Add V, Cp, 1 : V << Cp + 1 / Read필요 
				CAdd_InputData_Error()
			elseif Operand[4] == "V" then -- Add V, Cp, X : V << Cp + X / Read필요 
				CAdd_InputData_Error()
			else
				CAdd_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Operand) == "number" then -- Add V, X, 1 : V << X + 1
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Operand,Mask);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			elseif Operand[4] == "V" then -- Add V, X, Y : V << X + Y
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,Mask);
						SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,Add*16777216,0xFF000000);
						CallLabelAlways(Operand[1],Operand[2],Operand[3]);
					},
					flag = {Preserved}
				}
			else
				CAdd_InputData_Error()
			end

		else 
			if type(Operand) == "number" then -- Add V, Mem, 1 : V << Mem + 1 / Read필요
				CAdd_InputData_Error()
			elseif Operand[4] == "V" then -- Add V, Mem, X : V << Mem + X / Read필요
				CAdd_InputData_Error()
			else
				CAdd_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CAdd_InputData_Error()
	end
end

function CSub(PlayerID,Dest,Source,Operand,Mask) -- - (1 - 2 = 0)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if Operand == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CSub_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "number" then -- Sub 0x58A364, 1 : 0x58A364 -= 1
			if type(Source) == "number" then
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(Dest,Subtract,Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- Sub 0x58A364, X : 0x58A364 -= X
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(Dest));
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
			else
				CSub_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- Sub Cp, 1 : Cp -= 1
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetDeaths(CurrentPlayer,Subtract,Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- Sub Cp, X : Cp -= X
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,13);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
			else
				CSub_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- Sub X, 1 : X -= 1
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Subtract,Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- Sub X, Y : X -= Y
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
			else
				CSub_InputData_Error()
			end

		else 
			if type(Source) == "number" then -- Sub Mem, 1 : Mem -= 1
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Subtract,Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- Sub Mem, X : Mem -= X
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
			else
				CSub_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Operand) == "table" and Operand[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Operand)
			Operand = TempRet
		end
		if type(Operand) == "table" and Operand[4] == "A" then
			CSub_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CSub_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end

		if type(Source) == "number" then -- Sub V, 0x58A364, 1 : V << 0x58A364 - 1 / Read필요
			if type(Operand) == "number" then
				CSub_InputData_Error()
			elseif Operand[4] == "V" then -- Sub V, 0x58A364, X : V << 0x58A364 - X / Read필요
				CSub_InputData_Error()
			else
				CSub_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Operand) == "number" then -- Sub V, Cp, 1 : V << Cp - 1 / Read필요 
				CSub_InputData_Error()
			elseif Operand[4] == "V" then -- Sub V, Cp, X : V << Cp - X / Read필요 
				CSub_InputData_Error()
			else
				CSub_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Operand) == "number" then -- Sub V, X, 1 : V << X - 1
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Subtract,Operand,Mask);
					},
					flag = {Preserved}
				}
			elseif Operand[4] == "V" then -- Sub V, X, Y : V << X - Y
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,Mask);
						SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways(Operand[1],Operand[2],Operand[3]);
					},
					flag = {Preserved}
				}
			else
				CSub_InputData_Error()
			end

		else 
			if type(Operand) == "number" then -- Sub V, Mem, 1 : V << Mem - 1 / Read필요
				CSub_InputData_Error()
			elseif Operand[4] == "V" then -- Sub V, Mem, X : V << Mem - X / Read필요
				CSub_InputData_Error()
			else
				CSub_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CSub_InputData_Error()
	end
end

function CiSub(PlayerID,Dest,Source,Operand,Mask) -- - (1 - 2 = -1)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if Operand == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CiSub_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "number" then -- iSub 0x58A364, 1 : 0x58A364 -= 1
			if type(Source) == "number" then
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(Dest,Add,0-Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- iSub 0x58A364, X : 0x58A364 -= X
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(Dest));
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
			else
				CiSub_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- iSub Cp, 1 : Cp -= 1
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetDeaths(CurrentPlayer,Add,0-Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- iSub Cp, X : Cp -= X
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrig1X("X",CRet[1],0x158,0,SetTo,13);
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
			else
				CiSub_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- iSub X, 1 : X -= 1
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,0-Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- iSub X, Y : X -= Y
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
			else
				CiSub_InputData_Error()
			end

		else 
			if type(Source) == "number" then -- iSub Mem, 1 : Mem -= 1
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,0-Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- iSub Mem, X : Mem -= X
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
			else
				CiSub_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Operand) == "table" and Operand[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Operand)
			Operand = TempRet
		end
		if type(Operand) == "table" and Operand[4] == "A" then
			CiSub_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CiSub_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Source) == "number" then -- iSub V, 0x58A364, 1 : V << 0x58A364 - 1 / Read필요
			if type(Operand) == "number" then
				CiSub_InputData_Error()
			elseif Operand[4] == "V" then -- iSub V, 0x58A364, X : V << 0x58A364 - X / Read필요
				CiSub_InputData_Error()
			else
				CiSub_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Operand) == "number" then -- iSub V, Cp, 1 : V << Cp - 1 / Read필요 
				CiSub_InputData_Error()
			elseif Operand[4] == "V" then -- iSub V, Cp, X : V << Cp - X / Read필요 
				CiSub_InputData_Error()
			else
				CiSub_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Operand) == "number" then -- iSub V, X, 1 : V << X - 1
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,0-Operand,Mask);
					},
					flag = {Preserved}
				}
			elseif Operand[4] == "V" then -- iSub V, X, Y : V << X - Y
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways(Operand[1],Operand[2],Operand[3]);
					},
					flag = {Preserved}
				}
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,Mask);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
			else
				CiSub_InputData_Error()
			end

		else 
			if type(Operand) == "number" then -- iSub V, Mem, 1 : V << Mem - 1 / Read필요
				CiSub_InputData_Error()
			elseif Operand[4] == "V" then -- iSub V, Mem, X : V << Mem - X / Read필요
				CiSub_InputData_Error()
			else
				CiSub_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CiSub_InputData_Error()
	end
end

function CNeg(PlayerID,Dest,Source,Mask) -- x-1
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if Source == nil then
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
			MovX(PlayerID,Dest,PDest)
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CNeg_InputData_Error()
		end
		if type(Dest) == "number" then -- Neg 0x58A364 / Read필요
			CNeg_InputData_Error()
		elseif Dest == "Cp" then -- Neg Cp / Read필요
			CNeg_InputData_Error()
		elseif Dest[4] == "V" then -- Neg X : X << -X
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Subtract*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[1],0x15C,1,0);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
		else -- Neg Mem / Read필요
			CNeg_InputData_Error()
		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CNeg_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "number" then
			CNeg_InputData_Error()
		elseif Dest == "Cp" then
			CNeg_InputData_Error()
		elseif Dest[4] == "V" then
			if type(Source) == "number" then
				CNeg_InputData_Error()
			elseif Source[4] == "V" then -- Neg V, X : V << -X
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,Mask);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
			else
				CNeg_InputData_Error()
			end
		else
			CNeg_InputData_Error()
		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CNeg_InputData_Error()
	end
end

--[[ 구 CMul 함수
function CMul(PlayerID,Dest,Source,Multiplier,Mask,BitLimit) -- *, Y만 Limit bit 제한 (메모리에 )
	STPopTrigArr(PlayerID)

	if Multiplier == "X" then
		Multiplier = nil
	end

	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local  Bit = 0
	if BitLimit == nil or BitLimit == "X" then
		Bit = 31
	else
		while 2^Bit <= BitLimit and Bit <= 31 do
			Bit = Bit + 1
		end
		Bit = Bit - 1
	end

	local MulArr1 = {}
	local MulArr2 = {}
	local MulArr3 = {}
	local MulType = 0
	local MulType2 = 0
	local MulType3 = 0
	if Multiplier == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CMul_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CMul_InputData_Error()
		end
		if type(Dest) == "number" then -- Mul 0x58A364, 1 : 0x58A364 *= 1
			if type(Source) == "number" then
				MulType2 = 1
			elseif Source[4] == "V" then -- Mul 0x58A364, X : 0x58A364 *= X / Read필요
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- Mul Cp, 1 : Cp *= 1
				MulType2 = 2
			elseif Source[4] == "V" then -- Mul Cp, X : Cp *= X / Read필요
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- Mul X, 1 : X *= 1
				MulType2 = 3
			elseif Source[4] == "Cp" then -- Mul X, Cp : X *= Cp
				MulType = 1
				MulType3 = 1
			elseif Source[4] == "V" then -- Mul X, Y : X *= Y
				MulType = 1
				MulType3 = 2
			else -- Mul X, Mem : X *= Mem
				MulType = 1
				MulType3 = 3
			end

		else 
			if type(Source) == "number" then -- Mul Mem, 1 : Mem *= 1
				MulType2 = 4
			elseif Source[4] == "V" then -- Add Mem, X : Mem *= X / Read필요
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		end

		if type(Source) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
					},
					flag = {Preserved}
				}
			local Block = 0
			for i = 0, Bit do
				local CBit = 2^i
				if MulType2 == 1 then
					MulArr1 = {MemoryX(Dest,Exactly,CBit,CBit)}
				elseif MulType2 == 2 then
					MulArr1 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
				elseif MulType2 == 3 then
					MulArr1 = {CtrigX(Dest[1],Dest[2],0x15C,Dest[3],Exactly,CBit,CBit)}
				elseif MulType2 == 4 then
					MulArr1 = {CtrigX(Dest[1],Dest[2],Dest[3],Dest[4],Exactly,CBit,CBit)}
				end
				if Block == 0 then
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								MulArr1,
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x15C,0,Add,Source*CBit);
							},
							flag = {Preserved}
						}
				end
				if  bit32.band(Source*CBit,0xFFFFFFFF) >= 0x80000000 then
					Block = 0 -- 나눗셈 : Block 필요 / 곱셈 : Block 불필요
				end
			end
			if MulType2 == 1 then
				MulArr2 = {SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(Dest))}
			elseif MulType2 == 2 then
				MulArr2 = {SetCtrig1X("X",CRet[1],0x158,0,SetTo,13)}
			elseif MulType2 == 3 then
				MulArr2 = {SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3])}
			elseif MulType2 == 4 then
				MulArr2 = {SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4])}
			end
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						MulArr2,
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
		end
		if MulType == 1 then
			if Dest == Source then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[3],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Source = {"X",CRet[3],0,"V"}
			end

			Trigger { 
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
						SetCtrigX("X",FuncAlloc,0x19C,1,SetTo,"X",FuncAlloc,0x0,0,2);
					},
					flag = {Preserved}
				}

			local ClearValue = {}
			for i = 0, Bit do
				table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,(Bit+3)+i,SetTo,0))
			end

			Trigger { 
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(FuncAlloc);
					},
					actions = {
						ClearValue,
					},
					flag = {Preserved}
				}

			Trigger { -- local Var1 (1)
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X("X",FuncAlloc,0x19C,1,Add,0x970);
						SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,2);
					},
					flag = {Preserved}
				}

			for i = 0, Bit do
				Trigger { -- (2 ~ Bit+2)
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc,0x15C,1,(Bit+3)+i);
						SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
					},
					flag = {Preserved}
				}
			end

			PlayerID = PlayerConvert(PlayerID)
			for k, P in pairs(PlayerID) do
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,2))
				for i = 1, (Bit+2) do
					table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",CRet[1],0x0,0,0))
				end
			end

			for i = 0, Bit do
				local CBit = 2^i

				if MulType3 == 1 then
					MulArr3 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
				elseif MulType3 == 2 then
					MulArr3 = {CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,CBit,CBit)}
				elseif MulType3 == 3 then
					MulArr3 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
				end

				Trigger { -- (Bit+3 ~ 2*Bit+3)
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						MulArr3,
					},
					actions = {
						SetCtrig1X("X",CRet[2],0x15C,0,Add,0);
					},
					flag = {Preserved}
				}
			end

			Trigger { -- 2*Bit + 4
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}

			FuncAlloc = FuncAlloc + 1
		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Multiplier) == "table" and Multiplier[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Multiplier)
			Multiplier = TempRet
		end
		if type(Multiplier) == "table" and Multiplier[4] == "A" then
			CMul_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CMul_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CMul_InputData_Error()
		end
		if type(Source) == "number" then -- Mul V, 0x58A364, 1 : V << 0x58A364 * 1 / Read필요
			if type(Multiplier) == "number" then
				CMul_InputData_Error()
			elseif Multiplier[4] == "V" then -- Mul V, 0x58A364, X : V << 0x58A364 * X / Read필요
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Multiplier) == "number" then -- Mul V, Cp, 1 : V << Cp * 1 / Read필요 
				CMul_InputData_Error()
			elseif Multiplier[4] == "V" then -- Mul V, Cp, X : V << Cp * X / Read필요 
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Multiplier) == "number" then -- Mul V, X, 1 : V << X * 1
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
					},
					flag = {Preserved}
				}
				local Block = 0
				for i = 0, Bit do
					local CBit = 2^i
					if Block == 0 then
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
									CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,CBit,CBit);
								},
								actions = {
									SetCtrig1X("X",CRet[1],0x15C,0,Add,Multiplier*CBit);
								},
								flag = {Preserved}
							}
					end
					if  bit32.band(Multiplier*CBit,0xFFFFFFFF) >= 0x80000000 then
						Block = 0 -- 나눗셈 : Block 필요 / 곱셈 : Block 불필요
					end
				end
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}

			elseif Multiplier == "Cp" then -- Mul V, X, Cp : V << X * Cp
				MulType = 1
				MulType3 = 1
			elseif Multiplier[4] == "V" then -- Mul V, X, Y : V << X * Y
				MulType = 1
				MulType3 = 2
			else -- Mul V, X, Mem : V << X * Mem
				MulType = 1
				MulType3 = 3
			end
			if MulType == 1 then
				if Source == Multiplier then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[3],0x15C,1,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
					Source = {"X",CRet[3],0,"V"}
				end

				Trigger { 
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways(Source[1],Source[2],Source[3]);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
							SetCtrigX("X",FuncAlloc,0x19C,1,SetTo,"X",FuncAlloc,0x0,0,2);
						},
						flag = {Preserved}
					}

				local ClearValue = {}
				for i = 0, Bit do
					table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,(Bit+3)+i,SetTo,0))
				end

				Trigger { 
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(FuncAlloc);
						},
						actions = {
							ClearValue,
						},
						flag = {Preserved}
					}

				Trigger { -- local Var1 (1)
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X("X",FuncAlloc,0x19C,1,Add,0x970);
							SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,2);
						},
						flag = {Preserved}
					}

				for i = 0, Bit do
					Trigger { -- (2 ~ Bit+2)
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc,0x15C,1,(Bit+3)+i);
							SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
						},
						flag = {Preserved}
					}
				end

				PlayerID = PlayerConvert(PlayerID)
				for k, P in pairs(PlayerID) do
					table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,2))
					for i = 1, (Bit+2) do
						table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",CRet[1],0x0,0,0))
					end
				end

				for i = 0, Bit do
					local CBit = 2^i

					if MulType3 == 1 then
						MulArr3 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
					elseif MulType3 == 2 then
						MulArr3 = {CtrigX(Multiplier[1],Multiplier[2],0x15C,Multiplier[3],Exactly,CBit,CBit)}
					elseif MulType3 == 3 then
						MulArr3 = {CtrigX(Multiplier[1],Multiplier[2],Multiplier[3],Multiplier[4],Exactly,CBit,CBit)}
					end

					Trigger { -- (Bit+3 ~ 2*Bit+3)
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
							MulArr3,
						},
						actions = {
							SetCtrig1X("X",CRet[2],0x15C,0,Add,0);
						},
						flag = {Preserved}
					}
				end

				Trigger { -- 2*Bit + 4
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}

				FuncAlloc = FuncAlloc + 1
			end
		else 
			if type(Multiplier) == "number" then -- Mul V, Mem, 1 : V << Mem * 1 / Read필요
				CMul_InputData_Error()
			elseif Multiplier[4] == "V" then -- Mul V, Mem, X : V << Mem * X / Read필요
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CMul_InputData_Error()
	end
end
]]--

function CMul(PlayerID,Dest,Source,Multiplier,Mask,BitLimit) -- *, Y만 Limit bit 제한 (메모리에 )
	STPopTrigArr(PlayerID)

	if Multiplier == "X" then
		Multiplier = nil
	end

	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local  Bit = 0
	if BitLimit == nil or BitLimit == "X" then
		Bit = 31
	else
		while 2^Bit <= BitLimit and Bit <= 31 do
			Bit = Bit + 1
		end
		Bit = Bit - 1
	end

	local MulArr1 = {}
	local MulArr2 = {}
	local MulArr3 = {}
	local MulType = 0
	local MulType2 = 0
	local MulType3 = 0
	if Multiplier == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CMul_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CMul_InputData_Error()
		end
		if type(Dest) == "number" then -- Mul 0x58A364, 1 : 0x58A364 *= 1
			if type(Source) == "number" then
				MulType2 = 1
			elseif Source[4] == "V" then -- Mul 0x58A364, X : 0x58A364 *= X / Read필요
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- Mul Cp, 1 : Cp *= 1
				MulType2 = 2
			elseif Source[4] == "V" then -- Mul Cp, X : Cp *= X / Read필요
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- Mul X, 1 : X *= 1
				MulType2 = 3
			elseif Source[4] == "Cp" then -- Mul X, Cp : X *= Cp
				MulType = 1
				MulType3 = 1
			elseif Source[4] == "V" then -- Mul X, Y : X *= Y
				MulType = 1
				MulType3 = 2
			else -- Mul X, Mem : X *= Mem
				MulType = 1
				MulType3 = 3
			end

		else 
			if type(Source) == "number" then -- Mul Mem, 1 : Mem *= 1
				MulType2 = 4
			elseif Source[4] == "V" then -- Add Mem, X : Mem *= X / Read필요
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		end

		if type(Source) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
					},
					flag = {Preserved}
				}
			local Block = 0
			for i = 0, Bit do
				local CBit = 2^i
				if MulType2 == 1 then
					MulArr1 = {MemoryX(Dest,Exactly,CBit,CBit)}
				elseif MulType2 == 2 then
					MulArr1 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
				elseif MulType2 == 3 then
					MulArr1 = {CtrigX(Dest[1],Dest[2],0x15C,Dest[3],Exactly,CBit,CBit)}
				elseif MulType2 == 4 then
					MulArr1 = {CtrigX(Dest[1],Dest[2],Dest[3],Dest[4],Exactly,CBit,CBit)}
				end
				if Block == 0 then
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								MulArr1,
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x15C,0,Add,Source*CBit);
							},
							flag = {Preserved}
						}
				end
				if  bit32.band(Source*CBit,0xFFFFFFFF) >= 0x80000000 then
					Block = 0 -- 나눗셈 : Block 필요 / 곱셈 : Block 불필요
				end
			end
			if MulType2 == 1 then
				MulArr2 = {SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(Dest))}
			elseif MulType2 == 2 then
				MulArr2 = {SetCtrig1X("X",CRet[1],0x158,0,SetTo,13)}
			elseif MulType2 == 3 then
				MulArr2 = {SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3])}
			elseif MulType2 == 4 then
				MulArr2 = {SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4])}
			end
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						MulArr2,
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
		end
		if MulType == 1 then
			if Dest == Source then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
				Dest = {"X",CRet[1],0,"V"}
			end

			local ClearValue = {}
			for i = 0, Bit do
				table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,2+i,SetTo,0)) --2~Bit+2
			end
			local Repeat = Bit*2
			Trigger {  -- 0
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(FuncAlloc);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FuncAlloc,0x15C+0x20*5,1,1);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
						ClearValue,
						SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0,0,1); -- Make Loop Action A->A
						SetCtrigX("X",FuncAlloc,0x158+0x20*6,1,SetTo,"X",FuncAlloc,0x1A4+0x20*6+0x4*Repeat,1,1); -- Reset Timer
						SetCtrig1X("X",FuncAlloc,0x1A4+0x20*6,1,SetTo,0x2,0x2); -- Reset Flag
						SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x15C,1,2);
						SetCtrig1X("X",FuncAlloc,0x164,1,SetTo,0x0,0x2);
						SetCtrig1X("X",FuncAlloc,0x184,1,SetTo,0x2,0x2);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}

			Trigger { -- local Var1 (1)
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x158+0x20*5,0,SetTo,"X",FuncAlloc,0x15C,1,2); -- Switch Action (Default = On)
						Disabled(SetCtrigX("X","X",0x158+0x20*5,0,SetTo,"X","X",0x15C+0x20*5,1,0)), -- Switch Action (Default = Off)
						SetCtrig1X("X","X",0x164,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
						SetCtrig1X("X","X",0x184,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
						SetCtrig1X("X","X",0x15C,0,Add,0x970/8);
						SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
						SetCtrig1X("X","X",0x1A4+0x20*6+0x4*Repeat,0,SetTo,0x0,0x2); -- Timer Action
						SetCtrig1X("X","X",0x158+0x20*6,0,Subtract,1); -- Run Tick
						Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1)); -- Exit Action
					},
					flag = {Preserved}
				}

			for i = 0, Bit do
				local CBit = 2^i

				if MulType3 == 1 then
					MulArr3 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
				elseif MulType3 == 2 then
					MulArr3 = {CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,CBit,CBit)}
				elseif MulType3 == 3 then
					MulArr3 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
				end

				Trigger { -- (+2 ~ Bit+2)
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						MulArr3,
					},
					actions = {
						SetCtrig1X("X",CRet[2],0x15C,0,Add,0);
					},
					flag = {Preserved}
				}
			end

			Trigger { -- Bit + 3
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}

			FuncAlloc = FuncAlloc + 1
		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Multiplier) == "table" and Multiplier[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Multiplier)
			Multiplier = TempRet
		end
		if type(Multiplier) == "table" and Multiplier[4] == "A" then
			CMul_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CMul_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CMul_InputData_Error()
		end
		if type(Source) == "number" then -- Mul V, 0x58A364, 1 : V << 0x58A364 * 1 / Read필요
			if type(Multiplier) == "number" then
				CMul_InputData_Error()
			elseif Multiplier[4] == "V" then -- Mul V, 0x58A364, X : V << 0x58A364 * X / Read필요
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Multiplier) == "number" then -- Mul V, Cp, 1 : V << Cp * 1 / Read필요 
				CMul_InputData_Error()
			elseif Multiplier[4] == "V" then -- Mul V, Cp, X : V << Cp * X / Read필요 
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Multiplier) == "number" then -- Mul V, X, 1 : V << X * 1
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
					},
					flag = {Preserved}
				}
				local Block = 0
				for i = 0, Bit do
					local CBit = 2^i
					if Block == 0 then
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
									CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,CBit,CBit);
								},
								actions = {
									SetCtrig1X("X",CRet[1],0x15C,0,Add,Multiplier*CBit);
								},
								flag = {Preserved}
							}
					end
					if  bit32.band(Multiplier*CBit,0xFFFFFFFF) >= 0x80000000 then
						Block = 0 -- 나눗셈 : Block 필요 / 곱셈 : Block 불필요
					end
				end
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}

			elseif Multiplier == "Cp" then -- Mul V, X, Cp : V << X * Cp
				MulType = 1
				MulType3 = 1
			elseif Multiplier[4] == "V" then -- Mul V, X, Y : V << X * Y
				MulType = 1
				MulType3 = 2
			else -- Mul V, X, Mem : V << X * Mem
				MulType = 1
				MulType3 = 3
			end
			if MulType == 1 then
				if Source == Multiplier then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
					Source = {"X",CRet[1],0,"V"}
				end

				local ClearValue = {}
				for i = 0, Bit do
					table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,2+i,SetTo,0)) --2~Bit+2
				end
				local Repeat = Bit*2
				Trigger {  -- 0
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(FuncAlloc);
						},
						actions = {
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x15C+0x20*5,1,1);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
							ClearValue,
							SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0,0,1); -- Make Loop Action A->A
							SetCtrigX("X",FuncAlloc,0x158+0x20*6,1,SetTo,"X",FuncAlloc,0x1A4+0x20*6+0x4*Repeat,1,1); -- Reset Timer
							SetCtrig1X("X",FuncAlloc,0x1A4+0x20*6,1,SetTo,0x2,0x2); -- Reset Flag
							SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x15C,1,2);
							SetCtrig1X("X",FuncAlloc,0x164,1,SetTo,0x0,0x2);
							SetCtrig1X("X",FuncAlloc,0x184,1,SetTo,0x2,0x2);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}

				Trigger { -- local Var1 (1)
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x158+0x20*5,0,SetTo,"X",FuncAlloc,0x15C,1,2); -- Switch Action (Default = On)
							Disabled(SetCtrigX("X","X",0x158+0x20*5,0,SetTo,"X","X",0x15C+0x20*5,1,0)), -- Switch Action (Default = Off)
							SetCtrig1X("X","X",0x164,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
							SetCtrig1X("X","X",0x184,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
							SetCtrig1X("X","X",0x15C,0,Add,0x970/8);
							SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
							SetCtrig1X("X","X",0x1A4+0x20*6+0x4*Repeat,0,SetTo,0x0,0x2); -- Timer Action
							SetCtrig1X("X","X",0x158+0x20*6,0,Subtract,1); -- Run Tick
							Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1)); -- Exit Action
						},
						flag = {Preserved}
					}

				for i = 0, Bit do
					local CBit = 2^i

					if MulType3 == 1 then
						MulArr3 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
					elseif MulType3 == 2 then
						MulArr3 = {CtrigX(Multiplier[1],Multiplier[2],0x15C,Multiplier[3],Exactly,CBit,CBit)}
					elseif MulType3 == 3 then
						MulArr3 = {CtrigX(Multiplier[1],Multiplier[2],Multiplier[3],Multiplier[4],Exactly,CBit,CBit)}
					end

					Trigger { -- (+2 ~ Bit+2)
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
							MulArr3,
						},
						actions = {
							SetCtrig1X("X",CRet[2],0x15C,0,Add,0);
						},
						flag = {Preserved}
					}
				end

				Trigger { -- Bit + 3
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}

				FuncAlloc = FuncAlloc + 1
			end
		else 
			if type(Multiplier) == "number" then -- Mul V, Mem, 1 : V << Mem * 1 / Read필요
				CMul_InputData_Error()
			elseif Multiplier[4] == "V" then -- Mul V, Mem, X : V << Mem * X / Read필요
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CMul_InputData_Error()
	end
end

function CDiv(PlayerID,Dest,Source,Divisor,Mask,BitLimit) -- /, X,Y 둘다 Limit bit 제한, 
	STPopTrigArr(PlayerID)

	if Divisor == "X" then
		Divisor = nil
	end

	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local  Bit = 0
	if BitLimit == nil or BitLimit == "X" then
		Bit = 31
	else
		while 2^Bit <= BitLimit and Bit <= 31 do
			Bit = Bit + 1
		end
		Bit = Bit - 1
	end
	
	if Divisor == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CDiv_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CDiv_InputData_Error()
		end

		if type(Dest) == "number" then -- Div 0x58A364, 1 : 0x58A364 /= 1 / Read필요
			if type(Source) == "number" then
				CDiv_InputData_Error()
			elseif Source[4] == "V" then -- Div 0x58A364, X : 0x58A364 /= X / Read필요
				CDiv_InputData_Error()
			else
				CDiv_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- Div Cp, 1 : Cp /= 1 / Read필요
				CDiv_InputData_Error()
			elseif Source[4] == "V" then -- Div Cp, X : Cp /= X / Read필요
				CDiv_InputData_Error()
			else
				CDiv_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- Div X, 1 : X /= 1
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
				local Block = 0
				for i = 0, Bit do
					local CBit = 2^i
					if  bit32.band(Source*CBit,0xFFFFFFFF) >= 0x80000000 then
						Block = i
						break
					end
				end
				for i = Block, 0, -1 do
					local CBit = 2^i
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
									CtrigX("X",CRet[2],0x15C,0,AtLeast,Source*CBit);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Subtract,Source*CBit);
									SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
								},
								flag = {Preserved}
							}
				end
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- Div X, Y : X /= Y
				if BitLimit ~= nil and BitLimit ~= "X" then
					Trigger { -- Y -> CRet[1] Act#1 (-3)
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}

					Trigger { -- Y -> CRet[1] Act#2 (-2)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x17C,1,0);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
							},
							flag = {Preserved}
						}

					
					Trigger { -- X -> CRet[2] (-1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
							},
							flag = {Preserved}
						}

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,(Bit+4)+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,(Bit+4)+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}


					Trigger { -- local Var2 (1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (2)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",CRet[1],0x17C,1,0);
								SetCtrig1X("X",FuncAlloc,0x1BC,2,Add,0x970);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						Trigger { -- (3 ~ Bit+3)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc,0x24,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",FuncAlloc,0x15C,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4-i);
							},
							flag = {Preserved}
						}
					end

					PlayerID = PlayerConvert(PlayerID)
					for k, P in pairs(PlayerID) do
						table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,3)) --> Create Local Var
						for i = 2, (Bit+3) do
							table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",CRet[1],0x0,0,0)) -- -> VarX
						end
					end

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (Bit+4 ~ 2*Bit+4)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[3],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- 2*Bit + 5
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[3],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[3],0);
							},
							flag = {Preserved}
						}

					FuncAlloc = FuncAlloc + 1
				else
					Bit = 31
					local ClearValue = {}
					for i = 0, 7 do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end
					local ClearValue2 = {}
					for i = 8, Bit do
						table.insert(ClearValue2,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue2,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end
					
					Trigger { --  (-2) /0 처리
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,0x0);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+4);
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF); -- 몫
							},
							flag = {Preserved}
						}

					Trigger { --  (-1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								ClearValue,
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x4,2,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,2,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
								SetCtrig1X("X",FuncAlloc,0x15C,2,Add,0x970/2);
								CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
								SetCtrig1X("X",FuncAlloc,0x164,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x1A4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x1C4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x164+0x20*12,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184+0x20*12,1,SetTo,0x2,0x2);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x24,1,Bit+3);
								SetCtrigX("X",FuncAlloc,0x17C,1,SetTo,"X",FuncAlloc,0x15C,1,Bit+3);
							},
							flag = {Preserved}
						}

					Trigger { -- Clear Value 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue2,
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
								CallLabelAlways(Source[1],Source[2],Source[3]);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X",FuncAlloc,0x24,1,Bit+3); -- Switch Action (Default = On)
								SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X",FuncAlloc,0x15C,1,Bit+3); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X","X",0x15C+0x20*10,1,0)), -- Switch Action (Default = Off)
								Disabled(SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X","X",0x17C+0x20*10,1,0)), -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1A4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1C4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,0,Subtract,0x970/8);
								SetCtrig1X("X","X",0x17C,0,Subtract,0x970/8);
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,0)); -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,1,Subtract,0x970/2);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var2 (2)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",FuncAlloc,0x15C+0x20*10,1,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (3 ~ Bit+3)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- Bit + 4
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,-2,SetTo,"X",FuncAlloc,0x0,0,-1);
								SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[1],0);
							},
							flag = {Preserved}
						}
					FuncAlloc = FuncAlloc + 1
				end
			else
				CDiv_InputData_Error()
			end

		else 
			if type(Source) == "number" then -- Div Mem, 1 : Mem /= 1 / Read필요
				CDiv_InputData_Error()
			elseif Source[4] == "V" then -- Add Mem, X : Mem /= X / Read필요
				CDiv_InputData_Error()
			else
				CDiv_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Divisor) == "table" and Divisor[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Divisor)
			Divisor = TempRet
		end
		if type(Divisor) == "table" and Divisor[4] == "A" then
			CDiv_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CDiv_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CDiv_InputData_Error()
		end
		if type(Source) == "number" then -- Div V, 0x58A364, 1 : V << 0x58A364 / 1 / Read필요
			if type(Divisor) == "number" then
				CDiv_InputData_Error()
			elseif Divisor[4] == "V" then -- Div V, 0x58A364, X : V << 0x58A364 / X / Read필요
				CDiv_InputData_Error()
			else
				CDiv_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Divisor) == "number" then -- Div V, Cp, 1 : V << Cp / 1 / Read필요 
				CDiv_InputData_Error()
			elseif Divisor[4] == "V" then -- Div V, Cp, X : V << Cp / X / Read필요 
				CDiv_InputData_Error()
			else
				CDiv_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Divisor) == "number" then -- Div V, X, 1 : V << X / 1
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				local Block = 0
				for i = 0, Bit do
					local CBit = 2^i
					if  bit32.band(Divisor*CBit,0xFFFFFFFF) >= 0x80000000 then
						Block = i
						break
					end
				end
				for i = Block, 0, -1 do
					local CBit = 2^i
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
									CtrigX("X",CRet[2],0x15C,0,AtLeast,Divisor*CBit);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Subtract,Divisor*CBit);
									SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
								},
								flag = {Preserved}
							}
				end
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
			elseif Divisor[4] == "V" then -- Div V, X, Y : V << X / Y
				if BitLimit ~= nil and BitLimit ~= "X" then
					Trigger { -- Y -> CRet[1] Act#1 (-3)
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
						},
						flag = {Preserved}
					}

					Trigger { -- Y -> CRet[1] Act#2 (-2)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x17C,1,0);
								CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
							},
							flag = {Preserved}
						}

					
					Trigger { -- X -> CRet[2] (-1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
							},
							flag = {Preserved}
						}

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,(Bit+4)+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,(Bit+4)+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}


					Trigger { -- local Var2 (1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (2)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",CRet[1],0x17C,1,0);
								SetCtrig1X("X",FuncAlloc,0x1BC,2,Add,0x970);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						Trigger { -- (3 ~ Bit+3)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc,0x24,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",FuncAlloc,0x15C,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4-i);
							},
							flag = {Preserved}
						}
					end

					PlayerID = PlayerConvert(PlayerID)
					for k, P in pairs(PlayerID) do
						table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,3)) --> Create Local Var
						for i = 2, (Bit+3) do
							table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",CRet[1],0x0,0,0)) -- -> VarX
						end
					end

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (Bit+4 ~ 2*Bit+4)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[3],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- 2*Bit + 5
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[3],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[3],0);
							},
							flag = {Preserved}
						}

					FuncAlloc = FuncAlloc + 1
				else
					Bit = 31
					local ClearValue = {}
					for i = 0, 7 do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end
					local ClearValue2 = {}
					for i = 8, Bit do
						table.insert(ClearValue2,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue2,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end
					
					Trigger { --  (-2) /0 처리
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],Exactly,0x0);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+4);
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF); -- 몫
							},
							flag = {Preserved}
						}

					Trigger { --  (-1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								ClearValue,
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
								SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x4,2,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,2,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
								SetCtrig1X("X",FuncAlloc,0x15C,2,Add,0x970/2);
								CallLabelAlways2(Source[1],Source[2],Source[3],Divisor[1],Divisor[2],Divisor[3]);
								SetCtrig1X("X",FuncAlloc,0x164,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x1A4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x1C4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x164+0x20*12,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184+0x20*12,1,SetTo,0x2,0x2);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x24,1,Bit+3);
								SetCtrigX("X",FuncAlloc,0x17C,1,SetTo,"X",FuncAlloc,0x15C,1,Bit+3);
							},
							flag = {Preserved}
						}

					Trigger { -- Clear Value 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue2,
								SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
								CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X",FuncAlloc,0x24,1,Bit+3); -- Switch Action (Default = On)
								SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X",FuncAlloc,0x15C,1,Bit+3); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X","X",0x15C+0x20*10,1,0)), -- Switch Action (Default = Off)
								Disabled(SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X","X",0x17C+0x20*10,1,0)), -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1A4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1C4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,0,Subtract,0x970/8);
								SetCtrig1X("X","X",0x17C,0,Subtract,0x970/8);
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,0)); -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,1,Subtract,0x970/2);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var2 (2)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",FuncAlloc,0x15C+0x20*10,1,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (3 ~ Bit+3)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- Bit + 4
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,-2,SetTo,"X",FuncAlloc,0x0,0,-1);
								SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[1],0);
							},
							flag = {Preserved}
						}
					FuncAlloc = FuncAlloc + 1
				end
			else
				CDiv_InputData_Error()
			end

		else 
			if type(Divisor) == "number" then -- Div V, Mem, 1 : V << Mem v1 / Read필요
				CDiv_InputData_Error()
			elseif Divisor[4] == "V" then -- Div V, Mem, X : V << Mem / X / Read필요
				CDiv_InputData_Error()
			else
				CDiv_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CDiv_InputData_Error()
	end
end

function CMod(PlayerID,Dest,Source,Divisor,Mask,BitLimit) -- %, X,Y 둘다 Limit bit 제한
	STPopTrigArr(PlayerID)

	if Divisor == "X" then
		Divisor = nil
	end

	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local  Bit = 0
	if BitLimit == nil or BitLimit == "X" then
		Bit = 31
	else
		while 2^Bit <= BitLimit and Bit <= 31 do
			Bit = Bit + 1
		end
		Bit = Bit - 1
	end
	
	if Divisor == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CMod_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CMod_InputData_Error()
		end
		if type(Dest) == "number" then -- Mod 0x58A364, 1 : 0x58A364 %= 1 / Read필요
			if type(Source) == "number" then
				CMod_InputData_Error()
			elseif Source[4] == "V" then -- Mod 0x58A364, X : 0x58A364 %= X / Read필요
				CMod_InputData_Error()
			else
				CMod_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- Mod Cp, 1 : Cp %= 1 / Read필요
				CMod_InputData_Error()
			elseif Source[4] == "V" then -- Mod Cp, X : Cp %= X / Read필요
				CMod_InputData_Error()
			else
				CMod_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- Mod X, 1 : X %= 1
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
				local Block = 0
				for i = 0, Bit do
					local CBit = 2^i
					if  bit32.band(Source*CBit,0xFFFFFFFF) >= 0x80000000 then
						Block = i
						break
					end
				end
				for i = Block, 0, -1 do
					local CBit = 2^i
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
									CtrigX("X",CRet[2],0x15C,0,AtLeast,Source*CBit);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Subtract,Source*CBit);
									SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
								},
								flag = {Preserved}
							}
				end
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}

			elseif Source[4] == "V" then -- Mod X, Y : X %= Y
				if BitLimit ~= nil and BitLimit ~= "X" then
					Trigger { -- Y -> CRet[1] Act#1 (-3)
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}

					Trigger { -- Y -> CRet[1] Act#2 (-2)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x17C,1,0);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
							},
							flag = {Preserved}
						}

					
					Trigger { -- X -> CRet[2] (-1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
							},
							flag = {Preserved}
						}

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,(Bit+4)+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,(Bit+4)+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}


					Trigger { -- local Var2 (1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (2)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",CRet[1],0x17C,1,0);
								SetCtrig1X("X",FuncAlloc,0x1BC,2,Add,0x970);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						Trigger { -- (3 ~ Bit+3)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc,0x24,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",FuncAlloc,0x15C,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4-i);
							},
							flag = {Preserved}
						}
					end

					PlayerID = PlayerConvert(PlayerID)
					for k, P in pairs(PlayerID) do
						table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,3)) --> Create Local Var
						for i = 2, (Bit+3) do
							table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",CRet[1],0x0,0,0)) -- -> VarX
						end
					end

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (Bit+4 ~ 2*Bit+4)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[3],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- 2*Bit + 5
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}


					FuncAlloc = FuncAlloc + 1
				else
					Bit = 31
					local ClearValue = {}
					for i = 0, 7 do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end
					local ClearValue2 = {}
					for i = 8, Bit do
						table.insert(ClearValue2,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue2,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end
					
					Trigger { --  (-2)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								ClearValue,
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x4,2,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,2,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
								SetCtrig1X("X",FuncAlloc,0x15C,2,Add,0x970/2);
								CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
								SetCtrig1X("X",FuncAlloc,0x164,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x1A4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x1C4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x164+0x20*12,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184+0x20*12,1,SetTo,0x2,0x2);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x24,1,Bit+3);
								SetCtrigX("X",FuncAlloc,0x17C,1,SetTo,"X",FuncAlloc,0x15C,1,Bit+3);
							},
							flag = {Preserved}
						}

					Trigger { --  (-1) /0 처리
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,0x0);
							},
							actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { -- Clear Value 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue2,
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
								CallLabelAlways(Source[1],Source[2],Source[3]);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X",FuncAlloc,0x24,1,Bit+3); -- Switch Action (Default = On)
								SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X",FuncAlloc,0x15C,1,Bit+3); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X","X",0x15C+0x20*10,1,0)), -- Switch Action (Default = Off)
								Disabled(SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X","X",0x17C+0x20*10,1,0)), -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1A4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1C4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,0,Subtract,0x970/8);
								SetCtrig1X("X","X",0x17C,0,Subtract,0x970/8);
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,0)); -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,1,Subtract,0x970/2);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var2 (2)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",FuncAlloc,0x15C+0x20*10,1,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (3 ~ Bit+3)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- Bit + 4
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,-1,SetTo,"X",FuncAlloc,0x0,0,0);
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}
					FuncAlloc = FuncAlloc + 1
				end
			else
				CMod_InputData_Error()
			end

		else 
			if type(Source) == "number" then -- Mod Mem, 1 : Mem %= 1 / Read필요
				CMod_InputData_Error()
			elseif Source[4] == "V" then -- Add Mem, X : Mem %= X / Read필요
				CMod_InputData_Error()
			else
				CMod_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Divisor) == "table" and Divisor[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Divisor)
			Divisor = TempRet
		end
		if type(Divisor) == "table" and Divisor[4] == "A" then
			CMod_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CMod_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CMod_InputData_Error()
		end
		if type(Source) == "number" then -- Mod V, 0x58A364, 1 : V << 0x58A364 % 1 / Read필요
			if type(Divisor) == "number" then
				CMod_InputData_Error()
			elseif Divisor[4] == "V" then -- Mod V, 0x58A364, X : V << 0x58A364 % X / Read필요
				CMod_InputData_Error()
			else
				CMod_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Divisor) == "number" then -- Mod V, Cp, 1 : V << Cp % 1 / Read필요 
				CMod_InputData_Error()
			elseif Divisor[4] == "V" then -- Mod V, Cp, X : V << Cp % X / Read필요 
				CMod_InputData_Error()
			else
				CMod_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Divisor) == "number" then -- Mod V, X, 1 : V << X % 1
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				local Block = 0
				for i = 0, Bit do
					local CBit = 2^i
					if  bit32.band(Divisor*CBit,0xFFFFFFFF) >= 0x80000000 then
						Block = i
						break
					end
				end
				for i = Block, 0, -1 do
					local CBit = 2^i
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
									CtrigX("X",CRet[2],0x15C,0,AtLeast,Divisor*CBit);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Subtract,Divisor*CBit);
									SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
								},
								flag = {Preserved}
							}
				end
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}


			elseif Divisor[4] == "V" then -- Mod V, X, Y : V << X % Y
				if BitLimit ~= nil and BitLimit ~= "X" then
					Trigger { -- Y -> CRet[1] Act#1 (-3)
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
						},
						flag = {Preserved}
					}

					Trigger { -- Y -> CRet[1] Act#2 (-2)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x17C,1,0);
								CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
							},
							flag = {Preserved}
						}

					
					Trigger { -- X -> CRet[2] (-1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
							},
							flag = {Preserved}
						}

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,(Bit+4)+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,(Bit+4)+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}


					Trigger { -- local Var2 (1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (2)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",CRet[1],0x17C,1,0);
								SetCtrig1X("X",FuncAlloc,0x1BC,2,Add,0x970);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						Trigger { -- (3 ~ Bit+3)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc,0x24,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",FuncAlloc,0x15C,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4-i);
							},
							flag = {Preserved}
						}
					end

					PlayerID = PlayerConvert(PlayerID)
					for k, P in pairs(PlayerID) do
						table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,3)) --> Create Local Var
						for i = 2, (Bit+3) do
							table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",CRet[1],0x0,0,0)) -- -> VarX
						end
					end

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (Bit+4 ~ 2*Bit+4)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[3],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- 2*Bit + 5
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}

					FuncAlloc = FuncAlloc + 1
				else
					Bit = 31
					local ClearValue = {}
					for i = 0, 7 do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end
					local ClearValue2 = {}
					for i = 8, Bit do
						table.insert(ClearValue2,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue2,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end
					
					Trigger { --  (-2)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								ClearValue,
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
								SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x4,2,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,2,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
								SetCtrig1X("X",FuncAlloc,0x15C,2,Add,0x970/2);
								CallLabelAlways2(Source[1],Source[2],Source[3],Divisor[1],Divisor[2],Divisor[3]);
								SetCtrig1X("X",FuncAlloc,0x164,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x1A4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x1C4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x164+0x20*12,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184+0x20*12,1,SetTo,0x2,0x2);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x24,1,Bit+3);
								SetCtrigX("X",FuncAlloc,0x17C,1,SetTo,"X",FuncAlloc,0x15C,1,Bit+3);
							},
							flag = {Preserved}
						}

					Trigger { --  (-1) /0 처리
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],Exactly,0x0);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { -- Clear Value 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue2,
								SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
								CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X",FuncAlloc,0x24,1,Bit+3); -- Switch Action (Default = On)
								SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X",FuncAlloc,0x15C,1,Bit+3); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X","X",0x15C+0x20*10,1,0)), -- Switch Action (Default = Off)
								Disabled(SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X","X",0x17C+0x20*10,1,0)), -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1A4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1C4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,0,Subtract,0x970/8);
								SetCtrig1X("X","X",0x17C,0,Subtract,0x970/8);
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,0)); -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,1,Subtract,0x970/2);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var2 (2)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",FuncAlloc,0x15C+0x20*10,1,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (3 ~ Bit+3)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- Bit + 4
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,-1,SetTo,"X",FuncAlloc,0x0,0,0);
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}
					FuncAlloc = FuncAlloc + 1
				end
			else
				CMod_InputData_Error()
			end
		else 
			if type(Divisor) == "number" then -- Mod V, Mem, 1 : V << Mem % 1 / Read필요
				CMod_InputData_Error()
			elseif Divisor[4] == "V" then -- Mod V, Mem, X : V << Mem % X / Read필요
				CMod_InputData_Error()
			else
				CMod_InputData_Error()
			end
		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CMod_InputData_Error()
	end
end

function CiDiv(PlayerID,Dest,Source,Divisor,Mask,BitLimit) -- CDiv의 Signed 연산 | 10/-3 = -3 / -10/3 = -3 / -10/-3 = 3
	STPopTrigArr(PlayerID)

	if Divisor == "X" then
		Divisor = nil
	end

	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local  Bit = 0
	if BitLimit == nil or BitLimit == "X" then
		Bit = 31
	else
		while 2^Bit <= BitLimit and Bit <= 31 do
			Bit = Bit + 1
		end
		Bit = Bit - 1
	end
	
	if Divisor == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CiDiv_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CiDiv_InputData_Error()
		end
		if type(Dest) == "number" then -- iDiv 0x58A364, 1 : 0x58A364 /= 1 / Read필요
			if type(Source) == "number" then
				CiDiv_InputData_Error()
			elseif Source[4] == "V" then -- iDiv 0x58A364, X : 0x58A364 /= X / Read필요
				CiDiv_InputData_Error()
			else
				CiDiv_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- iDiv Cp, 1 : Cp /= 1 / Read필요
				CiDiv_InputData_Error()
			elseif Source[4] == "V" then -- iDiv Cp, X : Cp /= X / Read필요
				CiDiv_InputData_Error()
			else
				CiDiv_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- iDiv X, 1 : X /= 1
				CIfX(PlayerID,CtrigX(Dest[1],Dest[2],0x15C,Dest[3],AtLeast,0x80000000))
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
							},
							flag = {Preserved}
						}
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
							},
							flag = {Preserved}
						}
				CElseX()
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
							},
							flag = {Preserved}
						}
				CIfXEnd()

				if bit32.band(Source,0xFFFFFFFF) >= 0x80000000 then
					Source = 0 - Source
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,Add,1); -- Sflag
							},
							flag = {Preserved}
						}
				end
			
				local Block = 0
				for i = 0, Bit do
					local CBit = 2^i
					if  bit32.band(Source*CBit,0xFFFFFFFF) >= 0x80000000 then
						Block = i
						break
					end
				end
				for i = Block, 0, -1 do
					local CBit = 2^i
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
									CtrigX("X",CRet[2],0x15C,0,AtLeast,Source*CBit);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Subtract,Source*CBit);
									SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
								},
								flag = {Preserved}
							}
				end
				CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF,Mask);
								SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[1],0);
							},
							flag = {Preserved}
						}
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
				CElseX()
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[1],0);
							},
							flag = {Preserved}
						}
				CIfXEnd()
			elseif Source[4] == "V" then -- iDiv X, Y : X /= Y
				if BitLimit ~= nil and BitLimit ~= "X" then
					CIfX(PlayerID,CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000))
						Trigger { -- Y -> CRet[1] Act#1 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
									SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0xFFFFFFFF);
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
									SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}

						Trigger { -- Y -> CRet[1] Act#2 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x17C,1,0);
									CallLabelAlways(Source[1],Source[2],Source[3]);
									SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
									SetCtrig1X("X",CRet[1],0x17C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { -- Y -> CRet[1] Act#1 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
									SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}

						Trigger { -- Y -> CRet[1] Act#2 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x17C,1,0);
									CallLabelAlways(Source[1],Source[2],Source[3]);
									SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					CIfX(PlayerID,CtrigX(Dest[1],Dest[2],0x15C,Dest[3],AtLeast,0x80000000))
						Trigger { -- X -> CRet[2] (-2)
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,Add,1); -- Sflag
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
								},
								flag = {Preserved}
							}
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { -- X -> CRet[2] (-1)
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
								},
								flag = {Preserved}
							}
					CIfXEnd()

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,(Bit+4)+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,(Bit+4)+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}


					Trigger { -- local Var2 (1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (2)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",CRet[1],0x17C,1,0);
								SetCtrig1X("X",FuncAlloc,0x1BC,2,Add,0x970);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						Trigger { -- (3 ~ Bit+3)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc,0x24,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",FuncAlloc,0x15C,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4-i);
							},
							flag = {Preserved}
						}
					end

					PlayerID = PlayerConvert(PlayerID)
					for k, P in pairs(PlayerID) do
						table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,3)) --> Create Local Var
						for i = 2, (Bit+3) do
							table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",CRet[1],0x0,0,0)) -- -> VarX
						end
					end

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (Bit+4 ~ 2*Bit+4)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[3],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[3],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[3],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[3],0);
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF);
							},
							flag = {Preserved}
						}
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
						Trigger { -- X(<0)/0 -> 0x80000000
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
									CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,0x0);
								},
								actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0x80000000);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[3],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[3],0);
							},
							flag = {Preserved}
						}
						Trigger { -- X(>=0)/0 -> 0x7FFFFFFF
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
									CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,0x0);
								},
								actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0x7FFFFFFF);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					FuncAlloc = FuncAlloc + 1
				else
					Bit = 31
					CIfX(PlayerID,CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000))
						Trigger { 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
									SetCtrig1X("X",FuncAlloc,0x15C+0x20*10,1,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",FuncAlloc,0x17C+0x20*10,1,SetTo,0xFFFFFFFF);
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
									SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}

						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",FuncAlloc,0x15C+0x20*10,1,Add,1);
									SetCtrig1X("X",FuncAlloc,0x17C+0x20*10,1,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
									SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}

						Trigger { 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					CIfX(PlayerID,CtrigX(Dest[1],Dest[2],0x15C,Dest[3],AtLeast,0x80000000))
						Trigger { 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,Add,1); -- Sflag
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
								},
								flag = {Preserved}
							}
					CIfXEnd()
					
					Trigger { --  (-2) /0 처리
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,0x0);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { --  (-1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x4,2,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,2,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
								SetCtrig1X("X",FuncAlloc,0x15C,2,Add,0x970/2);
								SetCtrig1X("X",FuncAlloc,0x164,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x1A4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x1C4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x164+0x20*12,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184+0x20*12,1,SetTo,0x2,0x2);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x24,1,Bit+3);
								SetCtrigX("X",FuncAlloc,0x17C,1,SetTo,"X",FuncAlloc,0x15C,1,Bit+3);
							},
							flag = {Preserved}
						}

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X",FuncAlloc,0x24,1,Bit+3); -- Switch Action (Default = On)
								SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X",FuncAlloc,0x15C,1,Bit+3); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X","X",0x15C+0x20*10,1,0)), -- Switch Action (Default = Off)
								Disabled(SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X","X",0x17C+0x20*10,1,0)), -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1A4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1C4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,0,Subtract,0x970/8);
								SetCtrig1X("X","X",0x17C,0,Subtract,0x970/8);
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,0)); -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,1,Subtract,0x970/2);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var2 (2)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",FuncAlloc,0x15C+0x20*10,1,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (3 ~ Bit+3)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- Bit + 4
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,-2,SetTo,"X",FuncAlloc,0x0,0,-1);
							},
							flag = {Preserved}
						}

					CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[1],0);
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF);
							},
							flag = {Preserved}
						}
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
						Trigger { -- X(<0)/0 -> 0x80000000
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
									CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,0x0);
								},
								actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0x80000000);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[1],0);
							},
							flag = {Preserved}
						}
						Trigger { -- X(>=0)/0 -> 0x7FFFFFFF
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
									CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,0x0);
								},
								actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0x7FFFFFFF);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					FuncAlloc = FuncAlloc + 1
				end
			else
				CiDiv_InputData_Error()
			end

		else 
			if type(Source) == "number" then -- iDiv Mem, 1 : Mem /= 1 / Read필요
				CiDiv_InputData_Error()
			elseif Source[4] == "V" then -- Add Mem, X : Mem /= X / Read필요
				CiDiv_InputData_Error()
			else
				CiDiv_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Divisor) == "table" and Divisor[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Divisor)
			Divisor = TempRet
		end
		if type(Divisor) == "table" and Divisor[4] == "A" then
			CiDiv_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CiDiv_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CiDiv_InputData_Error()
		end
		if type(Source) == "number" then -- iDiv V, 0x58A364, 1 : V << 0x58A364 / 1 / Read필요
			if type(Divisor) == "number" then
				CiDiv_InputData_Error()
			elseif Divisor[4] == "V" then -- iDiv V, 0x58A364, X : V << 0x58A364 / X / Read필요
				CiDiv_InputData_Error()
			else
				CiDiv_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Divisor) == "number" then -- iDiv V, Cp, 1 : V << Cp / 1 / Read필요 
				CiDiv_InputData_Error()
			elseif Divisor[4] == "V" then -- iDiv V, Cp, X : V << Cp / X / Read필요 
				CiDiv_InputData_Error()
			else
				CiDiv_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Divisor) == "number" then -- iDiv V, X, 1 : V << X / 1
				CIfX(PlayerID,CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000))
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
							},
							flag = {Preserved}
						}
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
							},
							flag = {Preserved}
						}
				CElseX()
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
							},
							flag = {Preserved}
						}
				CIfXEnd()

				if bit32.band(Divisor,0xFFFFFFFF) >= 0x80000000 then
					Divisor = 0 - Divisor
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,Add,1); -- Sflag
							},
							flag = {Preserved}
						}
				end
				local Block = 0
				for i = 0, Bit do
					local CBit = 2^i
					if  bit32.band(Divisor*CBit,0xFFFFFFFF) >= 0x80000000 then
						Block = i
						break
					end
				end
				for i = Block, 0, -1 do
					local CBit = 2^i
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
									CtrigX("X",CRet[2],0x15C,0,AtLeast,Divisor*CBit);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Subtract,Divisor*CBit);
									SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
								},
								flag = {Preserved}
							}
				end
				CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF,Mask);
								SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[1],0);
							},
							flag = {Preserved}
						}
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
				CElseX()
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[1],0);
							},
							flag = {Preserved}
						}
				CIfXEnd()
			elseif Divisor[4] == "V" then -- iDiv V, X, Y : V << X / Y
				if BitLimit ~= nil and BitLimit ~= "X" then
					CIfX(PlayerID,CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],AtLeast,0x80000000))
						Trigger { -- Y -> CRet[1] Act#1 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
									SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0xFFFFFFFF);
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x15C,1,0);
									SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,Subtract*16777216,0xFF000000);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}

						Trigger { -- Y -> CRet[1] Act#2 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x17C,1,0);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
									SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
									SetCtrig1X("X",CRet[1],0x17C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { -- Y -> CRet[1] Act#1 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x15C,1,0);
									SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}

						Trigger { -- Y -> CRet[1] Act#2 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x17C,1,0);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
									SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					CIfX(PlayerID,CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000))
						Trigger { -- X -> CRet[2] (-2)
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,Add,1); -- Sflag
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
								},
								flag = {Preserved}
							}
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { -- X -> CRet[2] (-1)
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
								},
								flag = {Preserved}
							}
					CIfXEnd()

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,(Bit+4)+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,(Bit+4)+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}


					Trigger { -- local Var2 (1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (2)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",CRet[1],0x17C,1,0);
								SetCtrig1X("X",FuncAlloc,0x1BC,2,Add,0x970);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						Trigger { -- (3 ~ Bit+3)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc,0x24,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",FuncAlloc,0x15C,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4-i);
							},
							flag = {Preserved}
						}
					end

					PlayerID = PlayerConvert(PlayerID)
					for k, P in pairs(PlayerID) do
						table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,3)) --> Create Local Var
						for i = 2, (Bit+3) do
							table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",CRet[1],0x0,0,0)) -- -> VarX
						end
					end

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (Bit+4 ~ 2*Bit+4)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[3],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[3],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[3],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[3],0);
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF);
							},
							flag = {Preserved}
						}
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
					Trigger { -- X(<0)/0 -> 0x80000000
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
									CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],Exactly,0x0);
								},
								actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0x80000000);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[3],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[3],0);
							},
							flag = {Preserved}
						}
						Trigger { -- X(>=0)/0 -> 0x7FFFFFFF
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
									CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],Exactly,0x0);
								},
								actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0x7FFFFFFF);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					FuncAlloc = FuncAlloc + 1
				else
					Bit = 31
					CIfX(PlayerID,CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],AtLeast,0x80000000))
						Trigger { 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
									SetCtrig1X("X",FuncAlloc,0x15C+0x20*10,1,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",FuncAlloc,0x17C+0x20*10,1,SetTo,0xFFFFFFFF);
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
									SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,Subtract*16777216,0xFF000000);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}

						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",FuncAlloc,0x15C+0x20*10,1,Add,1);
									SetCtrig1X("X",FuncAlloc,0x17C+0x20*10,1,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
									SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}

						Trigger { 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					CIfX(PlayerID,CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000))
						Trigger { 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,Add,1); -- Sflag
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}
					CIfXEnd()
					
					Trigger { --  (-2) /0 처리
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],Exactly,0x0);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { --  (-1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x4,2,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,2,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
								SetCtrig1X("X",FuncAlloc,0x15C,2,Add,0x970/2);
								SetCtrig1X("X",FuncAlloc,0x164,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x1A4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x1C4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x164+0x20*12,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184+0x20*12,1,SetTo,0x2,0x2);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x24,1,Bit+3);
								SetCtrigX("X",FuncAlloc,0x17C,1,SetTo,"X",FuncAlloc,0x15C,1,Bit+3);
							},
							flag = {Preserved}
						}

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X",FuncAlloc,0x24,1,Bit+3); -- Switch Action (Default = On)
								SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X",FuncAlloc,0x15C,1,Bit+3); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X","X",0x15C+0x20*10,1,0)), -- Switch Action (Default = Off)
								Disabled(SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X","X",0x17C+0x20*10,1,0)), -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1A4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1C4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,0,Subtract,0x970/8);
								SetCtrig1X("X","X",0x17C,0,Subtract,0x970/8);
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,0)); -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,1,Subtract,0x970/2);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var2 (2)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",FuncAlloc,0x15C+0x20*10,1,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (3 ~ Bit+3)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- Bit + 4
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,-2,SetTo,"X",FuncAlloc,0x0,0,-1);
							},
							flag = {Preserved}
						}

					CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[1],0);
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF);
							},
							flag = {Preserved}
						}
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
						Trigger { -- X(<0)/0 -> 0x80000000
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
									CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],Exactly,0x0);
								},
								actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0x80000000);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[1],0);
							},
							flag = {Preserved}
						}
						Trigger { -- X(>=0)/0 -> 0x7FFFFFFF
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
									CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],Exactly,0x0);
								},
								actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0x7FFFFFFF);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					FuncAlloc = FuncAlloc + 1
				end
			else
				CiDiv_InputData_Error()
			end

		else 
			if type(Divisor) == "number" then -- iDiv V, Mem, 1 : V << Mem v1 / Read필요
				CiDiv_InputData_Error()
			elseif Divisor[4] == "V" then -- iDiv V, Mem, X : V << Mem / X / Read필요
				CiDiv_InputData_Error()
			else
				CiDiv_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CiDiv_InputData_Error()
	end
end

function CiMod(PlayerID,Dest,Source,Divisor,Mask,BitLimit) -- CMod의 Signed 연산 | 10%-3 = 1 / -10%3 = -1 / -10%-3 = -1 (C++방식)
	STPopTrigArr(PlayerID)

	if Divisor == "X" then
		Divisor = nil
	end

	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local  Bit = 0
	if BitLimit == nil or BitLimit == "X" then
		Bit = 31
	else
		while 2^Bit <= BitLimit and Bit <= 31 do
			Bit = Bit + 1
		end
		Bit = Bit - 1
	end
	
	if Divisor == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CiMod_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CiMod_InputData_Error()
		end
		if type(Dest) == "number" then -- iMod 0x58A364, 1 : 0x58A364 %= 1 / Read필요
			if type(Source) == "number" then
				CiMod_InputData_Error()
			elseif Source[4] == "V" then -- iMod 0x58A364, X : 0x58A364 %= X / Read필요
				CiMod_InputData_Error()
			else
				CiMod_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- iMod Cp, 1 : Cp %= 1 / Read필요
				CiMod_InputData_Error()
			elseif Source[4] == "V" then -- iMod Cp, X : Cp %= X / Read필요
				CiMod_InputData_Error()
			else
				CiMod_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- iMod X, 1 : X %= 1
				CIfX(PlayerID,CtrigX(Dest[1],Dest[2],0x15C,Dest[3],AtLeast,0x80000000))
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
							},
							flag = {Preserved}
						}
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
							},
							flag = {Preserved}
						}
				CElseX()
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
							},
							flag = {Preserved}
						}
				CIfXEnd()

				if bit32.band(Source,0xFFFFFFFF) >= 0x80000000 then
					Source = 0 - Source
				end
				
				local Block = 0
				for i = 0, Bit do
					local CBit = 2^i
					if  bit32.band(Source*CBit,0xFFFFFFFF) >= 0x80000000 then
						Block = i
						break
					end
				end
				for i = Block, 0, -1 do
					local CBit = 2^i
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
									CtrigX("X",CRet[2],0x15C,0,AtLeast,Source*CBit);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Subtract,Source*CBit);
									SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
								},
								flag = {Preserved}
							}
				end
				CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF,Mask);
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
				CElseX()
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}
				CIfXEnd()

			elseif Source[4] == "V" then -- iMod X, Y : X %= Y
				if BitLimit ~= nil and BitLimit ~= "X" then
					CIfX(PlayerID,CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000))
						Trigger { -- Y -> CRet[1] Act#1 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0xFFFFFFFF);
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
									SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}

						Trigger { -- Y -> CRet[1] Act#2 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x17C,1,0);
									CallLabelAlways(Source[1],Source[2],Source[3]);
									SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
									SetCtrig1X("X",CRet[1],0x17C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { -- Y -> CRet[1] Act#1 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
									SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}

						Trigger { -- Y -> CRet[1] Act#2 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x17C,1,0);
									CallLabelAlways(Source[1],Source[2],Source[3]);
									SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					CIfX(PlayerID,CtrigX(Dest[1],Dest[2],0x15C,Dest[3],AtLeast,0x80000000))
						Trigger { -- X -> CRet[2] (-2)
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
								},
								flag = {Preserved}
							}
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { -- X -> CRet[2] (-1)
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
								},
								flag = {Preserved}
							}
					CIfXEnd()

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,(Bit+4)+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,(Bit+4)+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}


					Trigger { -- local Var2 (1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (2)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",CRet[1],0x17C,1,0);
								SetCtrig1X("X",FuncAlloc,0x1BC,2,Add,0x970);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						Trigger { -- (3 ~ Bit+3)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc,0x24,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",FuncAlloc,0x15C,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4-i);
							},
							flag = {Preserved}
						}
					end

					PlayerID = PlayerConvert(PlayerID)
					for k, P in pairs(PlayerID) do
						table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,3)) --> Create Local Var
						for i = 2, (Bit+3) do
							table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",CRet[1],0x0,0,0)) -- -> VarX
						end
					end

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (Bit+4 ~ 2*Bit+4)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[3],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF);
							},
							flag = {Preserved}
						}
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
					CElseX()
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}
					CIfXEnd()

					FuncAlloc = FuncAlloc + 1
				else
					Bit = 31
					CIfX(PlayerID,CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000))
						Trigger { 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",FuncAlloc,0x15C+0x20*10,1,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",FuncAlloc,0x17C+0x20*10,1,SetTo,0xFFFFFFFF);
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
									SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}

						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",FuncAlloc,0x15C+0x20*10,1,Add,1);
									SetCtrig1X("X",FuncAlloc,0x17C+0x20*10,1,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
									SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}

						Trigger { 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					CIfX(PlayerID,{CtrigX(Dest[1],Dest[2],0x15C,Dest[3],AtLeast,0x80000000),CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x1)})
						Trigger { 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
								},
								flag = {Preserved}
							}
					CIfXEnd()
					
					Trigger { --  (-2) /0 처리
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,0x0);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { --  (-1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x4,2,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,2,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
								SetCtrig1X("X",FuncAlloc,0x15C,2,Add,0x970/2);
								SetCtrig1X("X",FuncAlloc,0x164,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x1A4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x1C4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x164+0x20*12,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184+0x20*12,1,SetTo,0x2,0x2);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x24,1,Bit+3);
								SetCtrigX("X",FuncAlloc,0x17C,1,SetTo,"X",FuncAlloc,0x15C,1,Bit+3);
							},
							flag = {Preserved}
						}

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X",FuncAlloc,0x24,1,Bit+3); -- Switch Action (Default = On)
								SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X",FuncAlloc,0x15C,1,Bit+3); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X","X",0x15C+0x20*10,1,0)), -- Switch Action (Default = Off)
								Disabled(SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X","X",0x17C+0x20*10,1,0)), -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1A4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1C4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,0,Subtract,0x970/8);
								SetCtrig1X("X","X",0x17C,0,Subtract,0x970/8);
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,0)); -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,1,Subtract,0x970/2);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var2 (2)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",FuncAlloc,0x15C+0x20*10,1,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (3 ~ Bit+3)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- Bit + 4
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,-2,SetTo,"X",FuncAlloc,0x0,0,-1);
							},
							flag = {Preserved}
						}

					CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF);
							},
							flag = {Preserved}
						}
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
					CElseX()
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}
					CIfXEnd()

					FuncAlloc = FuncAlloc + 1
				end
			else
				CiMod_InputData_Error()
			end

		else 
			if type(Source) == "number" then -- iMod Mem, 1 : Mem %= 1 / Read필요
				CiMod_InputData_Error()
			elseif Source[4] == "V" then -- Add Mem, X : Mem %= X / Read필요
				CiMod_InputData_Error()
			else
				CiMod_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Divisor) == "table" and Divisor[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Divisor)
			Divisor = TempRet
		end
		if type(Divisor) == "table" and Divisor[4] == "A" then
			CiMod_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CiMod_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CiMod_InputData_Error()
		end
		if type(Source) == "number" then -- iMod V, 0x58A364, 1 : V << 0x58A364 % 1 / Read필요
			if type(Divisor) == "number" then
				CiMod_InputData_Error()
			elseif Divisor[4] == "V" then -- iMod V, 0x58A364, X : V << 0x58A364 % X / Read필요
				CiMod_InputData_Error()
			else
				CiMod_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Divisor) == "number" then -- iMod V, Cp, 1 : V << Cp % 1 / Read필요 
				CiMod_InputData_Error()
			elseif Divisor[4] == "V" then -- iMod V, Cp, X : V << Cp % X / Read필요 
				CiMod_InputData_Error()
			else
				CiMod_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Divisor) == "number" then -- iMod V, X, 1 : V << X % 1
				CIfX(PlayerID,CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000))
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
							},
							flag = {Preserved}
						}
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
							},
							flag = {Preserved}
						}
				CElseX()
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
							},
							flag = {Preserved}
						}
				CIfXEnd()

				if bit32.band(Divisor,0xFFFFFFFF) >= 0x80000000 then
					Divisor = 0 - Divisor
				end
				local Block = 0
				for i = 0, Bit do
					local CBit = 2^i
					if  bit32.band(Divisor*CBit,0xFFFFFFFF) >= 0x80000000 then
						Block = i
						break
					end
				end
				for i = Block, 0, -1 do
					local CBit = 2^i
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
									CtrigX("X",CRet[2],0x15C,0,AtLeast,Divisor*CBit);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Subtract,Divisor*CBit);
									SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
								},
								flag = {Preserved}
							}
				end
				CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF,Mask);
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
				CElseX()
					Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}
				CIfXEnd()

			elseif Divisor[4] == "V" then -- iMod V, X, Y : V << X % Y
				if BitLimit ~= nil and BitLimit ~= "X" then
					CIfX(PlayerID,CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],AtLeast,0x80000000))
						Trigger { -- Y -> CRet[1] Act#1 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0xFFFFFFFF);
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x15C,1,0);
									SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,Subtract*16777216,0xFF000000);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}

						Trigger { -- Y -> CRet[1] Act#2 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x17C,1,0);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
									SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
									SetCtrig1X("X",CRet[1],0x17C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { -- Y -> CRet[1] Act#1 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x15C,1,0);
									SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}

						Trigger { -- Y -> CRet[1] Act#2 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x17C,1,0);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
									SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					CIfX(PlayerID,CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000))
						Trigger { -- X -> CRet[2] (-2)
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
								},
								flag = {Preserved}
							}
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { -- X -> CRet[2] (-1)
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
								},
								flag = {Preserved}
							}
					CIfXEnd()

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,(Bit+4)+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,(Bit+4)+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}


					Trigger { -- local Var2 (1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (2)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",CRet[1],0x17C,1,0);
								SetCtrig1X("X",FuncAlloc,0x1BC,2,Add,0x970);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						Trigger { -- (3 ~ Bit+3)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc,0x24,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",FuncAlloc,0x15C,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4-i);
							},
							flag = {Preserved}
						}
					end

					PlayerID = PlayerConvert(PlayerID)
					for k, P in pairs(PlayerID) do
						table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,3)) --> Create Local Var
						for i = 2, (Bit+3) do
							table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",CRet[1],0x0,0,0)) -- -> VarX
						end
					end

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (Bit+4 ~ 2*Bit+4)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[3],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF);
							},
							flag = {Preserved}
						}
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
					CElseX()
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}
					CIfXEnd()

					FuncAlloc = FuncAlloc + 1
				else
					Bit = 31
					CIfX(PlayerID,CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],AtLeast,0x80000000))
						Trigger { 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",FuncAlloc,0x15C+0x20*10,1,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",FuncAlloc,0x17C+0x20*10,1,SetTo,0xFFFFFFFF);
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
									SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,Subtract*16777216,0xFF000000);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}

						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",FuncAlloc,0x15C+0x20*10,1,Add,1);
									SetCtrig1X("X",FuncAlloc,0x17C+0x20*10,1,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
									SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}

						Trigger { 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					CIfX(PlayerID,{CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000),CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],AtLeast,1)})
						Trigger { 
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger {
								players = {ParsePlayer(PlayerID)},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}
					CIfXEnd()
					
					Trigger { --  (-2) /0 처리
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],Exactly,0x0);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { --  (-1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x4,2,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,2,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
								SetCtrig1X("X",FuncAlloc,0x15C,2,Add,0x970/2);
								SetCtrig1X("X",FuncAlloc,0x164,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x1A4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x1C4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x164+0x20*12,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184+0x20*12,1,SetTo,0x2,0x2);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x24,1,Bit+3);
								SetCtrigX("X",FuncAlloc,0x17C,1,SetTo,"X",FuncAlloc,0x15C,1,Bit+3);
							},
							flag = {Preserved}
						}

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (1)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X",FuncAlloc,0x24,1,Bit+3); -- Switch Action (Default = On)
								SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X",FuncAlloc,0x15C,1,Bit+3); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X","X",0x15C+0x20*10,1,0)), -- Switch Action (Default = Off)
								Disabled(SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X","X",0x17C+0x20*10,1,0)), -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1A4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1C4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,0,Subtract,0x970/8);
								SetCtrig1X("X","X",0x17C,0,Subtract,0x970/8);
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,0)); -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,1,Subtract,0x970/2);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var2 (2)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",FuncAlloc,0x15C+0x20*10,1,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (3 ~ Bit+3)
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- Bit + 4
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,-2,SetTo,"X",FuncAlloc,0x0,0,-1);
							},
							flag = {Preserved}
						}

					CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF);
							},
							flag = {Preserved}
						}
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
					CElseX()
						Trigger { 
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}
					CIfXEnd()

					FuncAlloc = FuncAlloc + 1
				end
			else
				CiMod_InputData_Error()
			end

		else 
			if type(Divisor) == "number" then -- iMod V, Mem, 1 : V << Mem % 1 / Read필요
				CiMod_InputData_Error()
			elseif Divisor[4] == "V" then -- iMod V, Mem, X : V << Mem % X / Read필요
				CiMod_InputData_Error()
			else
				CiMod_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CiMod_InputData_Error()
	end
end

function CNot(PlayerID,Dest,Source,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if Source == nil then
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
			MovX(PlayerID,Dest,PDest)
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CNot_InputData_Error()
		end

		if type(Dest) == "number" then -- Not 0x58A364 / Read필요
			CNot_InputData_Error()
		elseif Dest == "Cp" then -- Not Cp / Read필요
			CNot_InputData_Error()
		elseif Dest[4] == "V" then -- Not X : X << ~X
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Subtract*16777216,0xFF000000);
					SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);

					SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);

					CallLabelAlways2(Dest[1],Dest[2],Dest[3],"X",CRet[1],0);
				},
				flag = {Preserved}
			}
		else -- Neg Mem / Read필요
			CNot_InputData_Error()
		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CNot_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CNot_InputData_Error()
		end
		if type(Dest) == "number" then
			CNot_InputData_Error()
		elseif Dest == "Cp" then
			CNot_InputData_Error()
		elseif Dest[4] == "V" then
			if type(Source) == "number" then
				CNot_InputData_Error()
			elseif Source[4] == "V" then -- Not V, X : V << ~X
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Mask);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				CNot_InputData_Error()
			end
		else
			CNot_InputData_Error()
		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CNot_InputData_Error()
	end
end

function COr(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if Operand == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			COr_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			COr_InputData_Error()
		end
		if type(Dest) == "number" then -- Or 0x58A364, 1 : 0x58A364 |= 1
			if type(Source) == "number" then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetMemoryX(Dest,SetTo,0xFFFFFFFF,Source);
					},
					flag = {Preserved}
				}
			elseif Source[4] == "V" then -- Or 0x58A364, X : 0x58A364 |= X
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x148,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(Dest));

						CallLabelAlways2(Source[1],Source[2],Source[3],"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				COr_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- Or Cp, 1 : Cp |= 1
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeathsX(CurrentPlayer,SetTo,0xFFFFFFFF,0,Source);
					},
					flag = {Preserved}
				}
			elseif Source[4] == "V" then -- Or Cp, X : Cp |= X
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x148,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",CRet[1],0x158,0,SetTo,13);

						CallLabelAlways2(Source[1],Source[2],Source[3],"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				COr_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- Or X, 1 : X |= 1
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF,Source);
					},
					flag = {Preserved}
				}
			elseif Source[4] == "V" then -- Or X, Y : X |= Y
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x148,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);

						CallLabelAlways2(Source[1],Source[2],Source[3],"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				COr_InputData_Error()
			end

		else 
			if type(Source) == "number" then -- Or Mem, 1 : Mem |= 1
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,0xFFFFFFFF,Source);
					},
					flag = {Preserved}
				}
			elseif Source[4] == "V" then -- Or Mem, X : Mem |= X
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x148,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);

						CallLabelAlways2(Source[1],Source[2],Source[3],"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				COr_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Operand) == "table" and Operand[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Operand)
			Operand = TempRet
		end
		if type(Operand) == "table" and Operand[4] == "A" then
			COr_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			COr_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			COr_InputData_Error()
		end

		if type(Source) == "number" then -- Or V, 0x58A364, 1 : V << 0x58A364 | 1 / Read필요
			if type(Operand) == "number" then
				COr_InputData_Error()
			elseif Operand[4] == "V" then -- Or V, 0x58A364, X : V << 0x58A364 | X / Read필요
				COr_InputData_Error()
			else
				COr_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Operand) == "number" then -- Or V, Cp, 1 : V << Cp | 1 / Read필요 
				COr_InputData_Error()
			elseif Operand[4] == "V" then -- Or V, Cp, X : V << Cp | X / Read필요 
				COr_InputData_Error()
			else
				COr_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Operand) == "number" then -- Or V, X, 1 : V << X | 1
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF,Operand);
					},
					flag = {Preserved}
				}
			elseif Operand[4] == "V" then -- Or V, X, Y : V << X | Y
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",CRet[1],0x148,1,0);
						SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);

						CallLabelAlways3(Source[1],Source[2],Source[3],Operand[1],Operand[2],Operand[3],"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				COr_InputData_Error()
			end

		else 
			if type(Operand) == "number" then -- Or V, Mem, 1 : V << Mem | 1 / Read필요
				COr_InputData_Error()
			elseif Operand[4] == "V" then -- Or V, Mem, X : V << Mem | X / Read필요
				COr_InputData_Error()
			else
				COr_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		COr_InputData_Error()
	end
end

function CAnd(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if Operand == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CAnd_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CAnd_InputData_Error()
		end
		if type(Dest) == "number" then -- And 0x58A364, 1 : 0x58A364 &= 1
			if type(Source) == "number" then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetMemoryX(Dest,SetTo,0,(0xFFFFFFFF-Source));
					},
					flag = {Preserved}
				}
			elseif Source[4] == "V" then -- And 0x58A364, X : 0x58A364 &= X
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x148,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);

						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(Dest));

						CallLabelAlways2(Source[1],Source[2],Source[3],"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				CAnd_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- And Cp, 1 : Cp &= 1
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeathsX(CurrentPlayer,SetTo,0,0,(0xFFFFFFFF-Source));
					},
					flag = {Preserved}
				}
			elseif Source[4] == "V" then -- And Cp, X : Cp &= X
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x148,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);

						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",CRet[1],0x158,0,SetTo,13);

						CallLabelAlways2(Source[1],Source[2],Source[3],"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				CAnd_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- And X, 1 : X &= 1
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0,(0xFFFFFFFF-Source));
					},
					flag = {Preserved}
				}
			elseif Source[4] == "V" then -- And X, Y : X &= Y
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x148,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);

						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);

						CallLabelAlways2(Source[1],Source[2],Source[3],"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				CAnd_InputData_Error()
			end

		else 
			if type(Source) == "number" then -- And Mem, 1 : Mem &= 1
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,0,(0xFFFFFFFF-Source));
					},
					flag = {Preserved}
				}
			elseif Source[4] == "V" then -- And Mem, X : Mem &= X
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x148,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);

						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);

						CallLabelAlways2(Source[1],Source[2],Source[3],"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				CAnd_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Operand) == "table" and Operand[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Operand)
			Operand = TempRet
		end
		if type(Operand) == "table" and Operand[4] == "A" then
			CAnd_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CAnd_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CAnd_InputData_Error()
		end

		if type(Source) == "number" then -- And V, 0x58A364, 1 : V << 0x58A364 & 1 / Read필요
			if type(Operand) == "number" then
				CAnd_InputData_Error()
			elseif Operand[4] == "V" then -- And V, 0x58A364, X : V << 0x58A364 & X / Read필요
				CAnd_InputData_Error()
			else
				CAnd_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Operand) == "number" then -- And V, Cp, 1 : V << Cp & 1 / Read필요 
				CAnd_InputData_Error()
			elseif Operand[4] == "V" then -- And V, Cp, X : V << Cp & X / Read필요 
				CAnd_InputData_Error()
			else
				CAnd_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Operand) == "number" then -- And V, X, 1 : V << X & 1
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0,(0xFFFFFFFF-Operand));
					},
					flag = {Preserved}
				}
			elseif Operand[4] == "V" then -- And V, X, Y : V << X & Y
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",CRet[1],0x148,1,0);
						SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,Subtract*16777216,0xFF000000);

						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);

						CallLabelAlways3(Source[1],Source[2],Source[3],Operand[1],Operand[2],Operand[3],"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				CAnd_InputData_Error()
			end

		else 
			if type(Operand) == "number" then -- And V, Mem, 1 : V << Mem & 1 / Read필요
				CAnd_InputData_Error()
			elseif Operand[4] == "V" then -- And V, Mem, X : V << Mem & X / Read필요
				CAnd_InputData_Error()
			else
				CAnd_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CAnd_InputData_Error()
	end
end

function CXor(PlayerID,Dest,Source,Operand,Mask)
		STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if Operand == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CXor_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CXor_InputData_Error()
		end
		if type(Dest) == "number" then -- Xor 0x58A364, 1 : 0x58A364 ^= 1 / Read필요
			if type(Source) == "number" then
				CXor_InputData_Error()
			elseif Source[4] == "V" then -- Xor 0x58A364, X : 0x58A364 ^= X / Read필요
				CXor_InputData_Error()
			else
				CXor_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- Xor Cp, 1 : Cp ^= 1 / Read필요
				CXor_InputData_Error()
			elseif Source[4] == "V" then -- Xor Cp, X : Cp ^= X / Read필요
				CXor_InputData_Error()
			else
				CXor_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- Xor X, 1 : X ^= 1
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF,Source);
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0,(0xFFFFFFFF-Source));
						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
			elseif Source[4] == "V" then -- Xor X, Y : X ^= Y
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x148,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);

						CallLabelAlways3(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3],"X",CRet[2],0);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x148,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);

						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
						SetCtrigX("X",CRet[2],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);

						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);

						CallLabelAlways3(Source[1],Source[2],Source[3],"X",CRet[2],0,"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				CXor_InputData_Error()
			end

		else 
			if type(Source) == "number" then -- Xor Mem, 1 : Mem ^= 1 / Read필요
				CXor_InputData_Error()
			elseif Source[4] == "V" then -- Xor Mem, X : Mem ^= X / Read필요
				CXor_InputData_Error()
			else
				CXor_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Operand) == "table" and Operand[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Operand)
			Operand = TempRet
		end
		if type(Operand) == "table" and Operand[4] == "A" then
			CXor_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CXor_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CXor_InputData_Error()
		end
		if type(Source) == "number" then -- Xor V, 0x58A364, 1 : V << 0x58A364 ^ 1 / Read필요
			if type(Operand) == "number" then
				CXor_InputData_Error()
			elseif Operand[4] == "V" then -- Xor V, 0x58A364, X : V << 0x58A364 ^ X / Read필요
				CXor_InputData_Error()
			else
				CXor_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Operand) == "number" then -- Xor V, Cp, 1 : V << Cp ^ 1 / Read필요 
				CXor_InputData_Error()
			elseif Operand[4] == "V" then -- Xor V, Cp, X : V << Cp ^ X / Read필요 
				CXor_InputData_Error()
			else
				CXor_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Operand) == "number" then -- Xor V, X, 1 : V << X ^ 1
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF,Operand);
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0,(0xFFFFFFFF-Operand));
						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,Mask);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
			elseif Operand[4] == "V" then -- Xor V, X, Y : V << X ^ Y
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",CRet[2],0x148,1,0);
						SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);

						CallLabelAlways3(Source[1],Source[2],Source[3],Operand[1],Operand[2],Operand[3],"X",CRet[2],0);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",CRet[2],0x148,1,0);
						SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,Subtract*16777216,0xFF000000);

						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
						SetCtrigX("X",CRet[2],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);

						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,Mask);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);

						CallLabelAlways3(Operand[1],Operand[2],Operand[3],"X",CRet[2],0,"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				CXor_InputData_Error()
			end
		else 
			if type(Operand) == "number" then -- Xor V, Mem, 1 : V << Mem ^ 1 / Read필요
				CXor_InputData_Error()
			elseif Operand[4] == "V" then -- Xor V, Mem, X : V << Mem ^ X / Read필요
				CXor_InputData_Error()
			else
				CXor_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CXor_InputData_Error()
	end
end		


-- 함수 호출형 함수 정의 선언 (Include) -------------------------------------------------

function Include_CtrigPlib(Cycle,SeedSwitch,Flag,PlayerID)
	Include_DataTransfer(Flag,PlayerID)
	Include_ArithMetic(PlayerID)
	Include_MatheMatics(Cycle,PlayerID)
	Include_MiscFunctions(SeedSwitch,PlayerID)
end

FReadCall1 = 0
FEPDCall1 = 0
FReadCall2 = 0
FEPDCall2 = 0
FMEM = {}
FMEMCall0 = 0
FMEMCall1 = 0
FMEMCall2 = 0
FMEME = {}
FMEMECall1 = 0
FMEMECall2 = 0
FReadXCall0 = 0
FReadXCall1 = 0
FReadXCall2 = 0
FReadXCall3 = 0
FReadXCall4 = 0
FReadXCall5 = 0
FReadXCall6 = 0
FReadXCall7 = 0
FMOVE = {}
FMOVECall0 = 0
FMOVECall1 = 0
FMOVECall2 = 0
FCONV = {}
FCONVCall0 = 0
FCONVCall1 = 0
FCONVCall2 = 0
FBYTE = {}
FBYTECall0 = 0
FBYTECall1 = 0
FBYTECall2 = 0
FCOND = {}
FCONDCall0 = 0
FCONDCall1 = 0
FCONDCall2 = 0
FCONDCall3 = 0
FMOVEArr = {}
FMEMEArr = {}
FMEMArr1 = {}
FMEMArr2 = {}
FCONVArr = {}
FBYTEArr = {}
FCONDArr = {}
function Include_DataTransfer(Flag,PlayerID) -- f_Read / f_EPD / f_Memcpy
-- f_Read - Ret[1] : Input EPD / Ret[2] = Output / Ret[3] = EPD(Output)
	local IncludePlayer
	if PlayerID == nil then
		IncludePlayer = AllPlayers
	else
		IncludePlayer = ParsePlayer(PlayerID)
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
				SetCtrig1X("X",CRet[3],0x15C,0,SetTo,-1452249);
				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}
	

	for i = 0, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,Add,CBit);
				SetCtrig1X("X",CRet[3],0x15C,0,Add,CBit/4);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	FReadCall1 = FuncAlloc
	FReadCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_ReadX - Ret[1] : Input EPD / Ret[2] = Output / Ret[3] = EPD(Output)

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}
	Trigger { -- 1
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
			},
			flag = {Preserved}
		}

	FReadXCall0 = FuncAlloc
	FuncAlloc = FuncAlloc + 1
	local XLabel

-- *16777216 (0 -> 3)
	for i = 0, 7 do
		if i == 0  then
			XLabel = FuncAlloc
		else
			XLabel = 0
		end
		local CBit = 2^i
		Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(XLabel);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,Add,CBit*16777216);
				},
				flag = {Preserved}
			}
	end
	FReadXCall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

-- *65536 (01 -> 23)
	for i = 0, 15 do
		if i == 0  then
			XLabel = FuncAlloc
		else
			XLabel = 0
		end
		local CBit = 2^i
		Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(XLabel);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,Add,CBit*65536);
				},
				flag = {Preserved}
			}
	end
	FReadXCall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

-- *256 (012 -> 123)
	for i = 0, 23 do
		if i == 0  then
			XLabel = FuncAlloc
		else
			XLabel = 0
		end
		local CBit = 2^i
		Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(XLabel);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,Add,CBit*256);
				},
				flag = {Preserved}
			}
	end
	FReadXCall3 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

-- 1 (0123 -> 0123)
	for i = 0, 31 do
		if i == 0  then
			XLabel = FuncAlloc
		else
			XLabel = 0
		end
		local CBit = 2^i
		Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(XLabel);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,Add,CBit);
				},
				flag = {Preserved}
			}
	end
	FReadXCall4 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

-- /256 (123 -> 012)
	for i = 8, 31 do
		if i == 8  then
			XLabel = FuncAlloc
		else
			XLabel = 0
		end
		local CBit = 2^i
		Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(XLabel);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,Add,CBit/256);
				},
				flag = {Preserved}
			}
	end
	FReadXCall5 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

-- /65536 (23 -> 01)
	for i = 16, 31 do
		if i == 16  then
			XLabel = FuncAlloc
		else
			XLabel = 0
		end
		local CBit = 2^i
		Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(XLabel);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,Add,CBit/65536);
				},
				flag = {Preserved}
			}
	end
	FReadXCall6 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

-- /16777216 (3 -> 0)
	for i = 24, 31 do
		if i == 24  then
			XLabel = FuncAlloc
		else
			XLabel = 0
		end
		local CBit = 2^i
		Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(XLabel);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,Add,CBit/16777216);
				},
				flag = {Preserved}
			}
	end
	FReadXCall7 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

-- f_EPD - Ret[1] : Input X / Ret[2] = Output | Output = EPD(X)

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,SetTo,-1452249);
			},
			flag = {Preserved}
		}

	for i = 2, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	CtrigX("X",CRet[1],0x15C,0,Exactly,CBit,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[2],0x15C,0,Add,CBit/4);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	FEPDCall1 =	FuncAlloc
	FEPDCall2 =	FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_Movcpy(EPD) - Ret[1] : Input Dest / Ret[2] : Source Offset / Ret[3] = Size / Ret[4] << Init Mask

	for i = 0, 3 do
		CVariable(IncludePlayer,FuncAlloc+i)
		table.insert(FMOVE,FuncAlloc+i)
	end
	FuncAlloc = FuncAlloc + 4

	Trigger {
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc);
		},
		flag = {Preserved}
	}
	FMOVECall0 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

	CDiv(IncludePlayer,V(FMOVE[1]),4) 
	CMov(IncludePlayer,V(FMOVE[4]),V(CRet[2]))

	Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FMOVE[4],Exactly,0);
				},
				actions = {
					SetCVar("X",FMOVE[4],SetTo,0xFFFFFFFF);
					SetCVar("X",FMOVE[1],Add,0-1452249);
				},
				flag = {Preserved}
			}
	Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FMOVE[4],Exactly,1);
				},
				actions = {
					SetCVar("X",FMOVE[4],SetTo,0xFFFFFF00);
					SetCVar("X",FMOVE[1],Add,0-1452249);
				},
				flag = {Preserved}
			}
	Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FMOVE[4],Exactly,2);
				},
				actions = {
					SetCVar("X",FMOVE[4],SetTo,0xFFFF0000);
					SetCVar("X",FMOVE[1],Add,0-1452249);
				},
				flag = {Preserved}
			}
	Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FMOVE[4],Exactly,3);
				},
				actions = {
					SetCVar("X",FMOVE[4],SetTo,0xFF000000);
					SetCVar("X",FMOVE[1],Add,0-1452249);
				},
				flag = {Preserved}
			}

	Trigger {
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc);
		},
		flag = {Preserved}
	}
	FMOVECall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1


	CIfX(IncludePlayer,CVar("X",FMOVE[3],AtLeast,4),SetCVar("X",FMOVE[3],Subtract,4))

		Trigger {--(CPRead)로 값 출력 (A)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[2],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FMOVE[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FMOVE[2],0x158,0,SetTo,"X",FuncAlloc,0x15C,1,0); 
					CallLabelAlways("X",FMOVE[2],0);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {IncludePlayer},
				conditions = { -- (B)
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FMOVE[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FMOVE[1],0x158,0,SetTo,"X",FuncAlloc,0x19C,1,0); 
					CallLabelAlways("X",FMOVE[1],0);
				},
				flag = {Preserved}
			}


		Trigger {
				players = {IncludePlayer},
				conditions = { -- (C)
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[4],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FMOVE[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FMOVE[4],0x158,0,SetTo,"X",FuncAlloc,0x21C,1,0); 
					CallLabelAlways("X",FMOVE[4],0);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]); 0x0 (A)
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrig1X(VA[1],VA[2],0x158,VA[3],SetTo,EPD(Dest)); EPD 0x158 (B)
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1); EPD 0x4
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,0,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,InitMask); EPD 0x148 (C)
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000); EPD 0x160
					SetMemory(0x6509B0,Add,(0x0-0x160)/4);
					SetMemory(0x6509B0,Add,(0x970)/4);
					SetCVar("X",FMOVE[2],Add,0x970);
					SetCVar("X",FMOVE[1],Add,1);
				},
				flag = {Preserved}
			}
	CIfXEnd()
	table.insert(FMOVEArr,{FuncAlloc,0x15C+0x20*12})
	FuncAlloc = FuncAlloc + 1

	Trigger {--(CPRead)로 값 출력 (A)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[2],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FMOVE[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FMOVE[2],0x158,0,SetTo,"X",FuncAlloc,0x15C,1,0); 
					CallLabelAlways("X",FMOVE[2],0);
				},
				flag = {Preserved}
			}

	Trigger {
				players = {IncludePlayer},
				conditions = { -- (B)
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FMOVE[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FMOVE[1],0x158,0,SetTo,"X",FuncAlloc,0x19C,1,0); 
					CallLabelAlways("X",FMOVE[1],0);
				},
				flag = {Preserved}
			}

	CWhile(IncludePlayer,CVar("X",FMOVE[3],AtLeast,4),SetCVar("X",FMOVE[3],Subtract,4))
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]); 0x0 (A)
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrig1X(VA[1],VA[2],0x158,VA[3],SetTo,EPD(Dest)); EPD 0x158 (B)
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1); EPD 0x4
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,0xFFFFFFFF,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF); EPD 0x148 
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000); EPD 0x160
					SetMemory(0x6509B0,Add,(0x0-0x160)/4);
					SetMemory(0x6509B0,Add,(0x970)/4);
					SetCVar("X",FMOVE[2],Add,0x970);
					SetCtrig1X("X",FuncAlloc,0x15C,0,Add,0x970);
					SetCVar("X",FMOVE[1],Add,1);
					SetCtrig1X("X",FuncAlloc,0x19C,0,Add,1);
				},
				flag = {Preserved}
			}
		table.insert(FMOVEArr,{FuncAlloc,0x15C+0x20*13})
	CWhileEnd()
	FuncAlloc = FuncAlloc + 1

	CIfX(IncludePlayer,CVar("X",FMOVE[3],Exactly,3))
		Trigger {--(CPRead)로 값 출력 (A)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[2],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FMOVE[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FMOVE[2],0x158,0,SetTo,"X",FuncAlloc,0x15C,1,0); 
					CallLabelAlways("X",FMOVE[2],0);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {IncludePlayer},
				conditions = { -- (B)
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FMOVE[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FMOVE[1],0x158,0,SetTo,"X",FuncAlloc,0x19C,1,0); 
					CallLabelAlways("X",FMOVE[1],0);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]); 0x0 (A)
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrig1X(VA[1],VA[2],0x158,VA[3],SetTo,EPD(Dest)); EPD 0x158 (B)
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1); EPD 0x4
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,0x00FFFFFF,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,InitMask); EPD 0x148 (C)
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000); EPD 0x160
					SetMemory(0x6509B0,Add,(0x0-0x160)/4);
				},
				flag = {Preserved}
			}
		FuncAlloc = FuncAlloc + 1
	CElseIfX(CVar("X",FMOVE[3],Exactly,2))
		Trigger {--(CPRead)로 값 출력 (A)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[2],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FMOVE[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FMOVE[2],0x158,0,SetTo,"X",FuncAlloc,0x15C,1,0); 
					CallLabelAlways("X",FMOVE[2],0);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {IncludePlayer},
				conditions = { -- (B)
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FMOVE[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FMOVE[1],0x158,0,SetTo,"X",FuncAlloc,0x19C,1,0); 
					CallLabelAlways("X",FMOVE[1],0);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]); 0x0 (A)
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrig1X(VA[1],VA[2],0x158,VA[3],SetTo,EPD(Dest)); EPD 0x158 (B)
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1); EPD 0x4
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,0x0000FFFF,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,InitMask); EPD 0x148 (C)
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000); EPD 0x160
					SetMemory(0x6509B0,Add,(0x0-0x160)/4);
				},
				flag = {Preserved}
			}
		FuncAlloc = FuncAlloc + 1
	CElseIfX(CVar("X",FMOVE[3],Exactly,1))
		Trigger {--(CPRead)로 값 출력 (A)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[2],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FMOVE[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FMOVE[2],0x158,0,SetTo,"X",FuncAlloc,0x15C,1,0); 
					CallLabelAlways("X",FMOVE[2],0);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {IncludePlayer},
				conditions = { -- (B)
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FMOVE[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FMOVE[1],0x158,0,SetTo,"X",FuncAlloc,0x19C,1,0); 
					CallLabelAlways("X",FMOVE[1],0);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]); 0x0 (A)
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrig1X(VA[1],VA[2],0x158,VA[3],SetTo,EPD(Dest)); EPD 0x158 (B)
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1); EPD 0x4
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,0x000000FF,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,InitMask); EPD 0x148 (C)
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000); EPD 0x160
					SetMemory(0x6509B0,Add,(0x0-0x160)/4);
				},
				flag = {Preserved}
			}
		FuncAlloc = FuncAlloc + 1
	CIfXEnd()

	Trigger {
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc);
		},
		flag = {Preserved}
	}
	FMOVECall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1


-- f_MemcpyEPD - Ret[1] : Input Dest / Ret[2] = Source / Ret[3] = Size / Ret[4] = VAflag

	for i = 0, 3 do
		CVariable(IncludePlayer,FuncAlloc+i)
		table.insert(FMEME,FuncAlloc+i)
	end
	FuncAlloc = FuncAlloc + 4

	Trigger {
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc);
		},
		flag = {Preserved}
	}
	FMEMECall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

	CWhile(IncludePlayer, CVar("X",FMEME[3],AtLeast,4),SetCVar("X",FMEME[3],Subtract,4))
		CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEME[1]),SetTo,_ReadX(V(FMEME[2]),0xFFFFFFFF,1),0xFFFFFFFF)},{Preserved})

		Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEME[2],Add,1),SetCVar("X",FMEME[1],Add,1)},flag = {Preserved}}
		table.insert(FMEMEArr,{FuncAlloc,0x15C+0x20*0})
		table.insert(FMEMEArr,{FuncAlloc,0x15C+0x20*1})
		FuncAlloc = FuncAlloc + 1
	CWhileEnd()
	CIfX(IncludePlayer,CVar("X",FMEME[3],Exactly,3))
		CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEME[1]),SetTo,_ReadX(V(FMEME[2]),0x00FFFFFF,1),0x00FFFFFF)},{Preserved})
	CElseIfX(CVar("X",FMEME[3],Exactly,2))
		CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEME[1]),SetTo,_ReadX(V(FMEME[2]),0x0000FFFF,1),0x0000FFFF)},{Preserved})
	CElseIfX(CVar("X",FMEME[3],Exactly,1))
		CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEME[1]),SetTo,_ReadX(V(FMEME[2]),0x000000FF,1),0x000000FF)},{Preserved})
	CIfXEnd()

	Trigger {
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc);
		},
		flag = {Preserved}
	}
	FMEMECall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

-- 	f_byteConvert - [1~4] : DestVA / [5] : Source / [6] : Size / [7] : SourceX
		for i = 0, 6 do
			CVariable(IncludePlayer,FuncAlloc+i)
			table.insert(FCONV,FuncAlloc+i)
		end
		FuncAlloc = FuncAlloc + 7

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				flag = {Preserved}
			}
		FCONVCall0 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

		CMod(IncludePlayer,V(FCONV[7]),V(FCONV[5]),4)
		CMov(IncludePlayer,V(FCONV[5]),V(CRet[1]))
		CiSub(IncludePlayer,V(FCONV[5]),1452249)

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				flag = {Preserved}
			}
		FCONVCall1 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

		CIfX(IncludePlayer,CVar("X",FCONV[7],AtLeast,4))
			CMod(IncludePlayer,V(FCONV[7]),4)
			CAdd(IncludePlayer,V(FCONV[5]),V(CRet[1]))
		CIfXEnd()

		CMov(IncludePlayer,0x6509B0,V(FCONV[5]))

		Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",FCONV[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FCONV[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",FCONV[1],0x158,0,SetTo,"X",FuncAlloc+20,0x158+0x20*0,1,0);
						SetCtrig1X("X",FCONV[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FCONV[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",FCONV[2],0x158,0,SetTo,"X",FuncAlloc+20,0x158+0x20*1,1,0);
						SetCtrig1X("X",FCONV[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FCONV[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",FCONV[3],0x158,0,SetTo,"X",FuncAlloc+20,0x158+0x20*2,1,0);
						SetCtrig1X("X",FCONV[4],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FCONV[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",FCONV[4],0x158,0,SetTo,"X",FuncAlloc+20,0x158+0x20*3,1,0);
						CallLabelAlways4("X",FCONV[1],0,"X",FCONV[2],0,"X",FCONV[3],0,"X",FCONV[4],0);

						SetCtrig1X("X",FuncAlloc+20,0x148+0x20*0,0,SetTo,0xFFFFFFFF); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+20,0x148+0x20*1,0,SetTo,0xFFFFFF00); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+20,0x148+0x20*2,0,SetTo,0xFFFF0000); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+20,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FuncAlloc+20,0x148+0x20*4,0,SetTo,0x000000FF); -- [2+1],[9]
						SetCtrig1X("X",FuncAlloc+20,0x148+0x20*5,0,SetTo,0x0000FFFF); -- [3+1],[10]
						SetCtrig1X("X",FuncAlloc+20,0x148+0x20*6,0,SetTo,0x00FFFFFF); -- [4+1],[11]
					},
					flag = {Preserved}
				}
		Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",FCONV[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FCONV[2],0x160,0,SetTo,Add*16777216,0xFF000000);
						SetCtrigX("X",FCONV[2],0x158,0,SetTo,"X",FuncAlloc+20,0x158+0x20*4,1,0);
						SetCtrig1X("X",FCONV[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FCONV[3],0x160,0,SetTo,Add*16777216,0xFF000000);
						SetCtrigX("X",FCONV[3],0x158,0,SetTo,"X",FuncAlloc+20,0x158+0x20*5,1,0);
						SetCtrig1X("X",FCONV[4],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FCONV[4],0x160,0,SetTo,Add*16777216,0xFF000000);
						SetCtrigX("X",FCONV[4],0x158,0,SetTo,"X",FuncAlloc+20,0x158+0x20*6,1,0);
						SetCtrig1X("X",FuncAlloc+20,0x158+0x20*4,0,SetTo,0x970);
						SetCtrig1X("X",FuncAlloc+20,0x158+0x20*5,0,SetTo,0x970);
						SetCtrig1X("X",FuncAlloc+20,0x158+0x20*6,0,SetTo,0x970);
						CallLabelAlways3("X",FCONV[2],0,"X",FCONV[3],0,"X",FCONV[4],0);

						SetCtrigX("X","X",0x4,1,SetTo,"X","X",0,0,2);
						SetCtrigX("X","X",0x4,2,SetTo,"X","X",0,0,3);
						SetCtrigX("X","X",0x4,3,SetTo,"X","X",0,0,4);
						SetCtrigX("X","X",0x4,4,SetTo,"X","X",0,0,5);
						SetCtrig1X("X",FuncAlloc+20,0x15C+0x20*0,0,SetTo,0); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+20,0x15C+0x20*1,0,SetTo,0); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+20,0x15C+0x20*2,0,SetTo,0); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+20,0x15C+0x20*3,0,SetTo,0); -- [4],[11]
						SetCtrig1X("X",FuncAlloc+20,0x15C+0x20*4,0,SetTo,0); -- [2+1],[9]
						SetCtrig1X("X",FuncAlloc+20,0x15C+0x20*5,0,SetTo,0); -- [3+1],[10]
						SetCtrig1X("X",FuncAlloc+20,0x15C+0x20*6,0,SetTo,0); -- [4+1],[11]
					},
					flag = {Preserved}
				}

		Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
						CVar("X",FCONV[7],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,0);
						SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
						SetCtrigX("X",FuncAlloc+1,0x4,0,SetTo,"X",FuncAlloc+1,0x0,0,1);
						SetCtrigX("X",FuncAlloc+2,0x4,0,SetTo,"X",FuncAlloc+2,0x0,0,1);
						SetCtrigX("X",FuncAlloc+3,0x4,0,SetTo,"X",FuncAlloc+3,0x0,0,1);
						SetCtrigX("X",FuncAlloc+4,0x4,0,SetTo,"X",FuncAlloc+4,0x0,0,1);
						SetCtrigX("X",FuncAlloc+20,0x4,0,SetTo,"X",FuncAlloc,0x0,0,0);
						SetCtrigX("X",FuncAlloc+5,0x4,-1,SetTo,"X",FuncAlloc+20,0x0,0,0);
					},
					flag = {Preserved}
				}
		Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
						CVar("X",FCONV[7],Exactly,1);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+5,0x0,0,0);
						SetCtrigX("X",FuncAlloc+5,0x4,0,SetTo,"X",FuncAlloc+5,0x0,0,1);
						SetCtrigX("X",FuncAlloc+6,0x4,0,SetTo,"X",FuncAlloc+6,0x0,0,1);
						SetCtrigX("X",FuncAlloc+7,0x4,0,SetTo,"X",FuncAlloc+7,0x0,0,1);
						SetCtrigX("X",FuncAlloc+8,0x4,0,SetTo,"X",FuncAlloc+8,0x0,0,1);
						SetCtrigX("X",FuncAlloc+9,0x4,0,SetTo,"X",FuncAlloc+9,0x0,0,1);
						SetCtrigX("X",FuncAlloc+20,0x4,0,SetTo,"X",FuncAlloc+5,0x0,0,0);
						SetCtrigX("X",FuncAlloc+10,0x4,-1,SetTo,"X",FuncAlloc+20,0x0,0,0);
					},
					flag = {Preserved}
				}
		Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
						CVar("X",FCONV[7],Exactly,2);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+10,0x0,0,0);
						SetCtrigX("X",FuncAlloc+10,0x4,0,SetTo,"X",FuncAlloc+10,0x0,0,1);
						SetCtrigX("X",FuncAlloc+11,0x4,0,SetTo,"X",FuncAlloc+11,0x0,0,1);
						SetCtrigX("X",FuncAlloc+12,0x4,0,SetTo,"X",FuncAlloc+12,0x0,0,1);
						SetCtrigX("X",FuncAlloc+13,0x4,0,SetTo,"X",FuncAlloc+13,0x0,0,1);
						SetCtrigX("X",FuncAlloc+14,0x4,0,SetTo,"X",FuncAlloc+14,0x0,0,1);
						SetCtrigX("X",FuncAlloc+20,0x4,0,SetTo,"X",FuncAlloc+10,0x0,0,0);
						SetCtrigX("X",FuncAlloc+15,0x4,-1,SetTo,"X",FuncAlloc+20,0x0,0,0);
					},
					flag = {Preserved}
				}
		Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
						CVar("X",FCONV[7],Exactly,3);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+15,0x0,0,0);
						SetCtrigX("X",FuncAlloc+15,0x4,0,SetTo,"X",FuncAlloc+15,0x0,0,1);
						SetCtrigX("X",FuncAlloc+16,0x4,0,SetTo,"X",FuncAlloc+16,0x0,0,1);
						SetCtrigX("X",FuncAlloc+17,0x4,0,SetTo,"X",FuncAlloc+17,0x0,0,1);
						SetCtrigX("X",FuncAlloc+18,0x4,0,SetTo,"X",FuncAlloc+18,0x0,0,1);
						SetCtrigX("X",FuncAlloc+19,0x4,0,SetTo,"X",FuncAlloc+19,0x0,0,1);
						SetCtrigX("X",FuncAlloc+20,0x4,0,SetTo,"X",FuncAlloc+15,0x0,0,0);
						SetCtrigX("X",FuncAlloc+20,0x4,-1,SetTo,"X",FuncAlloc+20,0x0,0,0);
					},
					flag = {Preserved}
				}

		-------------------------------------------------
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+20,0x0,0,0);
						SetCtrigX("X",FuncAlloc+20,0x4,0,SetTo,"X",FuncAlloc+21,0x0,0,0);
						SetCtrig1X("X",FuncAlloc+20,0x148+0x20*0,0,SetTo,0x00000000); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+20,0x148+0x20*1,0,SetTo,0x00000000); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+20,0x148+0x20*2,0,SetTo,0x00000000); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+20,0x148+0x20*3,0,SetTo,0x00000000); -- [4],[11]
						SetCtrig1X("X",FuncAlloc+20,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FuncAlloc+20,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FuncAlloc+20,0x148+0x20*6,0,SetTo,0x00000000); -- [4+1],[11]
					},
					flag = {Preserved}
				}
			
			for i = 7, 0, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+20,0x15C+0x20*0,0,Add,CBit*1); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+20,0x15C+0x20*1,0,Add,CBit*256); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+20,0x15C+0x20*2,0,Add,CBit*65536); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+20,0x15C+0x20*3,0,Add,CBit*16777216); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			FuncAlloc = FuncAlloc+1
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+19,0x0,0,0);
						SetCtrigX("X",FuncAlloc+19,0x4,0,SetTo,"X",FuncAlloc+20,0x0,0,0);
						SetCtrig1X("X",FuncAlloc+19,0x148+0x20*0,0,SetTo,0x000000FF); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+19,0x148+0x20*1,0,SetTo,0x0000FF00); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+19,0x148+0x20*2,0,SetTo,0x00FF0000); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+19,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FuncAlloc+19,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FuncAlloc+19,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FuncAlloc+19,0x148+0x20*6,0,SetTo,0x00000000); -- [4+1],[11]
					},
					flag = {Preserved}
				}

			for i = 15, 8, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+19,0x15C+0x20*0,0,Add,CBit*1); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+19,0x15C+0x20*1,0,Add,CBit*256); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+19,0x15C+0x20*2,0,Add,CBit*65536); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+19,0x15C+0x20*6,0,Add,CBit/256); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			FuncAlloc = FuncAlloc+1

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+18,0x0,0,0);
						SetCtrigX("X",FuncAlloc+18,0x4,0,SetTo,"X",FuncAlloc+19,0x0,0,0);
						SetCtrig1X("X",FuncAlloc+18,0x148+0x20*0,0,SetTo,0x0000FFFF); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+18,0x148+0x20*1,0,SetTo,0x00FFFF00); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+18,0x148+0x20*2,0,SetTo,0xFFFF0000); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+18,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FuncAlloc+18,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FuncAlloc+18,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FuncAlloc+18,0x148+0x20*6,0,SetTo,0x000000FF); -- [4+1],[11]
					},
					flag = {Preserved}
				}

			for i = 23, 16, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+18,0x15C+0x20*0,0,Add,CBit*1); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+18,0x15C+0x20*1,0,Add,CBit*256); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+18,0x15C+0x20*5,0,Add,CBit/65536); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+18,0x15C+0x20*6,0,Add,CBit/256); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			FuncAlloc = FuncAlloc+1

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+17,0x0,0,0);
						SetCtrigX("X",FuncAlloc+17,0x4,0,SetTo,"X",FuncAlloc+18,0x0,0,0);
						SetCtrig1X("X",FuncAlloc+17,0x148+0x20*0,0,SetTo,0x00FFFFFF); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+17,0x148+0x20*1,0,SetTo,0xFFFFFF00); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+17,0x148+0x20*2,0,SetTo,0xFFFF0000); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+17,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FuncAlloc+17,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FuncAlloc+17,0x148+0x20*5,0,SetTo,0x000000FF); -- [3+1],[10]
						SetCtrig1X("X",FuncAlloc+17,0x148+0x20*6,0,SetTo,0x0000FFFF); -- [4+1],[11]
					},
					flag = {Preserved}
				}

			for i = 31, 24, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+17,0x15C+0x20*0,0,Add,CBit*1); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+17,0x15C+0x20*4,0,Add,CBit/16777216); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+17,0x15C+0x20*5,0,Add,CBit/65536); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+17,0x15C+0x20*6,0,Add,CBit/256); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			FuncAlloc = FuncAlloc+1
			
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
					},
					actions = {
						SetMemory(0x6509B0,Add,1);
						SetCVar("X",FCONV[6],Subtract,1);
					},
					flag = {Preserved}
				}
			table.insert(FCONVArr,{FuncAlloc,0x15C})
			FuncAlloc = FuncAlloc+1

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+15,0x0,0,0);
						SetCtrigX("X",FuncAlloc+15,0x4,0,SetTo,"X",FuncAlloc+16,0x0,0,0);
						SetCtrig1X("X",FuncAlloc+15,0x148+0x20*0,0,SetTo,0x00000000); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+15,0x148+0x20*1,0,SetTo,0x00000000); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+15,0x148+0x20*2,0,SetTo,0x00000000); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+15,0x148+0x20*3,0,SetTo,0x00000000); -- [4],[11]
						SetCtrig1X("X",FuncAlloc+15,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FuncAlloc+15,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FuncAlloc+15,0x148+0x20*6,0,SetTo,0x00000000); -- [4+1],[11]
					},
					flag = {Preserved}
				}

			for i = 15, 8, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+15,0x15C+0x20*0,0,Add,CBit/256); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+15,0x15C+0x20*1,0,Add,CBit*1); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+15,0x15C+0x20*2,0,Add,CBit*256); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+15,0x15C+0x20*3,0,Add,CBit*65536); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			FuncAlloc = FuncAlloc+1
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+14,0x0,0,0);
						SetCtrigX("X",FuncAlloc+14,0x4,0,SetTo,"X",FuncAlloc+15,0x0,0,0);
						SetCtrig1X("X",FuncAlloc+14,0x148+0x20*0,0,SetTo,0x000000FF); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+14,0x148+0x20*1,0,SetTo,0x0000FF00); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+14,0x148+0x20*2,0,SetTo,0x00FF0000); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+14,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FuncAlloc+14,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FuncAlloc+14,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FuncAlloc+14,0x148+0x20*6,0,SetTo,0x00000000); -- [4+1],[11]

					},
					flag = {Preserved}
				}

			for i = 23, 16, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+14,0x15C+0x20*0,0,Add,CBit/256); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+14,0x15C+0x20*1,0,Add,CBit*1); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+14,0x15C+0x20*2,0,Add,CBit*256); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+14,0x15C+0x20*6,0,Add,CBit/65536); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			FuncAlloc = FuncAlloc+1

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+13,0x0,0,0);
						SetCtrigX("X",FuncAlloc+13,0x4,0,SetTo,"X",FuncAlloc+14,0x0,0,0);
						SetCtrig1X("X",FuncAlloc+13,0x148+0x20*0,0,SetTo,0x0000FFFF); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+13,0x148+0x20*1,0,SetTo,0x00FFFF00); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+13,0x148+0x20*2,0,SetTo,0xFFFF0000); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+13,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FuncAlloc+13,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FuncAlloc+13,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FuncAlloc+13,0x148+0x20*6,0,SetTo,0x000000FF); -- [4+1],[11]
					},
					flag = {Preserved}
				}

			for i = 31, 24, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+13,0x15C+0x20*0,0,Add,CBit/256); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+13,0x15C+0x20*1,0,Add,CBit*1); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+13,0x15C+0x20*5,0,Add,CBit/16777216); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+13,0x15C+0x20*6,0,Add,CBit/65536); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			FuncAlloc = FuncAlloc+1

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+12,0x0,0,0);
						SetCtrigX("X",FuncAlloc+12,0x4,0,SetTo,"X",FuncAlloc+13,0x0,0,0);
						SetCtrig1X("X",FuncAlloc+12,0x148+0x20*0,0,SetTo,0x00FFFFFF); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+12,0x148+0x20*1,0,SetTo,0xFFFFFF00); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+12,0x148+0x20*2,0,SetTo,0xFFFF0000); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+12,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FuncAlloc+12,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FuncAlloc+12,0x148+0x20*5,0,SetTo,0x000000FF); -- [3+1],[10]
						SetCtrig1X("X",FuncAlloc+12,0x148+0x20*6,0,SetTo,0x0000FFFF); -- [4+1],[11]
					},
					flag = {Preserved}
				}
			FuncAlloc = FuncAlloc+1
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
					},
					actions = {
						SetMemory(0x6509B0,Add,1);
					},
					flag = {Preserved}
				}
			table.insert(FCONVArr,{FuncAlloc,0x15C})
			FuncAlloc = FuncAlloc+1

			for i = 7, 0, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+10,0x15C+0x20*0,0,Add,CBit*16777216); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+10,0x15C+0x20*4,0,Add,CBit*1); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+10,0x15C+0x20*5,0,Add,CBit*256); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+10,0x15C+0x20*6,0,Add,CBit*65536); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCVar("X",FCONV[6],Subtract,1);
					},
					flag = {Preserved}
				}



			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+10,0x0,0,0);
						SetCtrigX("X",FuncAlloc+10,0x4,0,SetTo,"X",FuncAlloc+11,0x0,0,0);
						SetCtrig1X("X",FuncAlloc+10,0x148+0x20*0,0,SetTo,0x00000000); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+10,0x148+0x20*1,0,SetTo,0x00000000); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+10,0x148+0x20*2,0,SetTo,0x00000000); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+10,0x148+0x20*3,0,SetTo,0x00000000); -- [4],[11]
						SetCtrig1X("X",FuncAlloc+10,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FuncAlloc+10,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FuncAlloc+10,0x148+0x20*6,0,SetTo,0x00000000); -- [4+1],[11]
					},
					flag = {Preserved}
				}

			for i = 23, 16, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+10,0x15C+0x20*0,0,Add,CBit/65536); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+10,0x15C+0x20*1,0,Add,CBit/256); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+10,0x15C+0x20*2,0,Add,CBit*1); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+10,0x15C+0x20*3,0,Add,CBit*256); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			FuncAlloc = FuncAlloc+1
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+9,0x0,0,0);
						SetCtrigX("X",FuncAlloc+9,0x4,0,SetTo,"X",FuncAlloc+10,0x0,0,0);
						SetCtrig1X("X",FuncAlloc+9,0x148+0x20*0,0,SetTo,0x000000FF); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+9,0x148+0x20*1,0,SetTo,0x0000FF00); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+9,0x148+0x20*2,0,SetTo,0x00FF0000); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+9,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FuncAlloc+9,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FuncAlloc+9,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FuncAlloc+9,0x148+0x20*6,0,SetTo,0x00000000); -- [4+1],[11]

					},
					flag = {Preserved}
				}

			for i = 31, 24, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+9,0x15C+0x20*0,0,Add,CBit/65536); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+9,0x15C+0x20*1,0,Add,CBit/256); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+9,0x15C+0x20*2,0,Add,CBit*1); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+9,0x15C+0x20*6,0,Add,CBit/16777216); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			FuncAlloc = FuncAlloc+1

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+7,0x0,0,0);
						SetCtrigX("X",FuncAlloc+8,0x4,0,SetTo,"X",FuncAlloc+8,0x0,0,0);
						SetCtrig1X("X",FuncAlloc+8,0x148+0x20*0,0,SetTo,0x0000FFFF); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+8,0x148+0x20*1,0,SetTo,0x00FFFF00); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+8,0x148+0x20*2,0,SetTo,0xFFFF0000); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+8,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FuncAlloc+8,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FuncAlloc+8,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FuncAlloc+8,0x148+0x20*6,0,SetTo,0x000000FF); -- [4+1],[11]
					},
					flag = {Preserved}
				}
			FuncAlloc = FuncAlloc+1

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
					},
					actions = {
						SetMemory(0x6509B0,Add,1);
					},
					flag = {Preserved}
				}
			table.insert(FCONVArr,{FuncAlloc,0x15C})
			FuncAlloc = FuncAlloc+1

			for i = 7, 0, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+6,0x15C+0x20*0,0,Add,CBit*65536); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+6,0x15C+0x20*1,0,Add,CBit*16777216); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+6,0x15C+0x20*5,0,Add,CBit*1); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+6,0x15C+0x20*6,0,Add,CBit*256); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+6,0x0,0,0);
						SetCtrigX("X",FuncAlloc+6,0x4,0,SetTo,"X",FuncAlloc+7,0x0,0,0);
						SetCtrig1X("X",FuncAlloc+6,0x148+0x20*0,0,SetTo,0x00FFFFFF); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+6,0x148+0x20*1,0,SetTo,0xFFFFFF00); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+6,0x148+0x20*2,0,SetTo,0xFFFF0000); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+6,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FuncAlloc+6,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FuncAlloc+6,0x148+0x20*5,0,SetTo,0x000000FF); -- [3+1],[10]
						SetCtrig1X("X",FuncAlloc+6,0x148+0x20*6,0,SetTo,0x0000FFFF); -- [4+1],[11]
					},
					flag = {Preserved}
				}

			for i = 15, 8, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+6,0x15C+0x20*0,0,Add,CBit*65536); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+6,0x15C+0x20*4,0,Add,CBit/256); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+6,0x15C+0x20*5,0,Add,CBit*1); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+6,0x15C+0x20*6,0,Add,CBit*256); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			FuncAlloc = FuncAlloc+1
			
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCVar("X",FCONV[6],Subtract,1);
					},
					flag = {Preserved}
				}



			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+5,0x0,0,0);
						SetCtrigX("X",FuncAlloc+5,0x4,0,SetTo,"X",FuncAlloc+6,0x0,0,0);
						SetCtrig1X("X",FuncAlloc+5,0x148+0x20*0,0,SetTo,0x00000000); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+5,0x148+0x20*1,0,SetTo,0x00000000); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+5,0x148+0x20*2,0,SetTo,0x00000000); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+5,0x148+0x20*3,0,SetTo,0x00000000); -- [4],[11]
						SetCtrig1X("X",FuncAlloc+5,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FuncAlloc+5,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FuncAlloc+5,0x148+0x20*6,0,SetTo,0x00000000); -- [4+1],[11]
					},
					flag = {Preserved}
				}

			for i = 31, 24, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+5,0x15C+0x20*0,0,Add,CBit/16777216); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+5,0x15C+0x20*1,0,Add,CBit/65536); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+5,0x15C+0x20*2,0,Add,CBit/256); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+5,0x15C+0x20*3,0,Add,CBit*1); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			FuncAlloc = FuncAlloc+1

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+3,0x0,0,0);
						SetCtrigX("X",FuncAlloc+4,0x4,0,SetTo,"X",FuncAlloc+4,0x0,0,0);
						SetCtrig1X("X",FuncAlloc+4,0x148+0x20*0,0,SetTo,0x000000FF); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+4,0x148+0x20*1,0,SetTo,0x0000FF00); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+4,0x148+0x20*2,0,SetTo,0x00FF0000); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+4,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FuncAlloc+4,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FuncAlloc+4,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FuncAlloc+4,0x148+0x20*6,0,SetTo,0x00000000); -- [4+1],[11]

					},
					flag = {Preserved}
				}
			FuncAlloc = FuncAlloc+1

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
					},
					actions = {
						SetMemory(0x6509B0,Add,1);
					},
					flag = {Preserved}
				}
			table.insert(FCONVArr,{FuncAlloc,0x15C})
			FuncAlloc = FuncAlloc+1

			for i = 7, 0, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+2,0x15C+0x20*0,0,Add,CBit*256); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+2,0x15C+0x20*1,0,Add,CBit*65536); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+2,0x15C+0x20*2,0,Add,CBit*16777216); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+2,0x15C+0x20*6,0,Add,CBit*1); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+2,0x0,0,0);
						SetCtrigX("X",FuncAlloc+2,0x4,0,SetTo,"X",FuncAlloc+3,0x0,0,0);
						SetCtrig1X("X",FuncAlloc+2,0x148+0x20*0,0,SetTo,0x0000FFFF); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+2,0x148+0x20*1,0,SetTo,0x00FFFF00); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+2,0x148+0x20*2,0,SetTo,0xFFFF0000); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+2,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FuncAlloc+2,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FuncAlloc+2,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FuncAlloc+2,0x148+0x20*6,0,SetTo,0x000000FF); -- [4+1],[11]
					},
					flag = {Preserved}
				}

			for i = 15, 8, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+2,0x15C+0x20*0,0,Add,CBit*256); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+2,0x15C+0x20*1,0,Add,CBit*65536); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+2,0x15C+0x20*5,0,Add,CBit/256); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+2,0x15C+0x20*6,0,Add,CBit*1); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			FuncAlloc = FuncAlloc+1

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+1,0x0,0,0);
						SetCtrigX("X",FuncAlloc+1,0x4,0,SetTo,"X",FuncAlloc+2,0x0,0,0);
						SetCtrig1X("X",FuncAlloc+1,0x148+0x20*0,0,SetTo,0x00FFFFFF); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+1,0x148+0x20*1,0,SetTo,0xFFFFFF00); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+1,0x148+0x20*2,0,SetTo,0xFFFF0000); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+1,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FuncAlloc+1,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FuncAlloc+1,0x148+0x20*5,0,SetTo,0x000000FF); -- [3+1],[10]
						SetCtrig1X("X",FuncAlloc+1,0x148+0x20*6,0,SetTo,0x0000FFFF); -- [4+1],[11]
					},
					flag = {Preserved}
				}

			for i = 23, 16, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+1,0x15C+0x20*0,0,Add,CBit*256); -- [1],[8]
						SetCtrig1X("X",FuncAlloc+1,0x15C+0x20*4,0,Add,CBit/65536); -- [2],[9]
						SetCtrig1X("X",FuncAlloc+1,0x15C+0x20*5,0,Add,CBit/256); -- [3],[10]
						SetCtrig1X("X",FuncAlloc+1,0x15C+0x20*6,0,Add,CBit*1); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			FuncAlloc = FuncAlloc+1
			
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCVar("X",FCONV[6],Subtract,1);
					},
					flag = {Preserved}
				}

			Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
					},
					actions = {
						SetMemoryX(0,SetTo,0,0xFFFFFFFF); -- [1],[8]
						SetMemoryX(0,SetTo,0,0xFFFFFF00); -- [2],[9]
						SetMemoryX(0,SetTo,0,0xFFFF0000); -- [3],[10]
						SetMemoryX(0,SetTo,0,0xFF000000); -- [4],[11]
						SetMemoryX(0,SetTo,0,0x000000FF); -- [2+1],[9]
						SetMemoryX(0,SetTo,0,0x0000FFFF); -- [3+1],[10]
						SetMemoryX(0,SetTo,0,0x00FFFFFF); -- [4+1],[11]
						SetCtrig1X("X","X",0x158+0x20*0,0,Add,0x970);
						SetCtrig1X("X","X",0x158+0x20*1,0,Add,0x970);
						SetCtrig1X("X","X",0x158+0x20*2,0,Add,0x970);
						SetCtrig1X("X","X",0x158+0x20*3,0,Add,0x970);
						SetCtrig1X("X","X",0x158+0x20*4,0,Add,0x970);
						SetCtrig1X("X","X",0x158+0x20*5,0,Add,0x970);
						SetCtrig1X("X","X",0x158+0x20*6,0,Add,0x970);
						SetCtrig1X("X","X",0x15C+0x20*0,0,SetTo,0);
						SetCtrig1X("X","X",0x15C+0x20*1,0,SetTo,0);
						SetCtrig1X("X","X",0x15C+0x20*2,0,SetTo,0);
						SetCtrig1X("X","X",0x15C+0x20*3,0,SetTo,0);
						SetCtrig1X("X","X",0x15C+0x20*4,0,SetTo,0);
						SetCtrig1X("X","X",0x15C+0x20*5,0,SetTo,0);
						SetCtrig1X("X","X",0x15C+0x20*6,0,SetTo,0);
					},
					flag = {Preserved}
				}

			FuncAlloc = FuncAlloc + 1
			
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				flag = {Preserved}
			}
		FCONVCall2 = FuncAlloc
		FuncAlloc = FuncAlloc + 1


--[[		for i = 0, 4 do
			CVariable(IncludePlayer,FuncAlloc+i)
			table.insert(FCONV,FuncAlloc+i)
		end
		FuncAlloc = FuncAlloc + 5

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				flag = {Preserved}
			}
		FCONVCall0 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

		CMod(IncludePlayer,V(FCONV[4]),V(FCONV[2]),4)
		CMov(IncludePlayer,V(FCONV[2]),V(CRet[1]))
		CiSub(IncludePlayer,V(FCONV[2]),1452249)

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				flag = {Preserved}
			}
		FCONVCall1 =	FuncAlloc
		FuncAlloc = FuncAlloc + 1

		CIfX(IncludePlayer,CVar("X",FCONV[4],AtLeast,4))
			CMod(IncludePlayer,V(FCONV[4]),4)
			CAdd(IncludePlayer,V(FCONV[2]),V(CRet[1]))
		CIfXEnd()

		CMov(IncludePlayer,0x6509B0,V(FCONV[2]))

		CIf(IncludePlayer,{CVar("X",FCONV[3],AtLeast,1),CVar("X",FCONV[4],Exactly,1)},{SetCVar("X",FCONV[3],Subtract,1),SetCVar("X",FCONV[5],SetTo,0)}) -- +1 -> +2
			for i = 15, 8, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",FCONV[5],Add,(CBit/256)*0x01010101);
					},
					flag = {Preserved}
				}
			end
			CWrite(IncludePlayer,V(FCONV[1]),V(FCONV[5]))

			DoActionsX(IncludePlayer,{SetCVar("X",FCONV[1],Add,0x970/4),SetCVar("X",FCONV[4],SetTo,2)})
		CIfEnd()
 
		CIf(IncludePlayer,{CVar("X",FCONV[3],AtLeast,1),CVar("X",FCONV[4],Exactly,2)},{SetCVar("X",FCONV[3],Subtract,1),SetCVar("X",FCONV[5],SetTo,0)}) -- +2 -> +3
			for i = 23, 16, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",FCONV[5],Add,(CBit/65536)*0x01010101);
					},
					flag = {Preserved}
				}
			end
			CWrite(IncludePlayer,V(FCONV[1]),V(FCONV[5]))

			DoActionsX(IncludePlayer,{SetCVar("X",FCONV[1],Add,0x970/4),SetCVar("X",FCONV[4],SetTo,3)})
		CIfEnd()

		CIf(IncludePlayer,{CVar("X",FCONV[3],AtLeast,1),CVar("X",FCONV[4],Exactly,3)},{SetCVar("X",FCONV[3],Subtract,1),SetCVar("X",FCONV[5],SetTo,0)}) -- +3 -> +0
			for i = 31, 24, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",FCONV[5],Add,(CBit/16777216)*0x01010101);
					},
					flag = {Preserved}
				}
			end
			CWrite(IncludePlayer,V(FCONV[1]),V(FCONV[5]))

			DoActionsX(IncludePlayer,{SetCVar("X",FCONV[1],Add,0x970/4),SetCVar("X",FCONV[4],SetTo,0)})
			Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
					},
					actions = {
						SetMemory(0x6509B0,Add,1);
					},
					flag = {Preserved}
				}
			table.insert(FCONVArr,{FuncAlloc,0x15C})
			FuncAlloc = FuncAlloc + 1
		CIfEnd()

		CWhile(IncludePlayer,{CVar("X",FCONV[3],AtLeast,4)},{SetCVar("X",FCONV[3],Subtract,4),SetCVar("X",FCONV[5],SetTo,0)}) -- x4
			for i = 7, 0, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",FCONV[5],Add,(CBit)*0x01010101);
					},
					flag = {Preserved}
				}
			end
			CWrite(IncludePlayer,V(FCONV[1]),V(FCONV[5]))

			DoActionsX(IncludePlayer,{SetCVar("X",FCONV[1],Add,0x970/4),SetCVar("X",FCONV[5],SetTo,0)})

			for i = 15, 8, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",FCONV[5],Add,(CBit/256)*0x01010101);
					},
					flag = {Preserved}
				}
			end
			CWrite(IncludePlayer,V(FCONV[1]),V(FCONV[5]))

			DoActionsX(IncludePlayer,{SetCVar("X",FCONV[1],Add,0x970/4),SetCVar("X",FCONV[5],SetTo,0)})

			for i = 23, 16, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",FCONV[5],Add,(CBit/65536)*0x01010101);
					},
					flag = {Preserved}
				}
			end
			CWrite(IncludePlayer,V(FCONV[1]),V(FCONV[5]))

			DoActionsX(IncludePlayer,{SetCVar("X",FCONV[1],Add,0x970/4),SetCVar("X",FCONV[5],SetTo,0)})

			for i = 31, 24, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",FCONV[5],Add,(CBit/16777216)*0x01010101);
					},
					flag = {Preserved}
				}
			end
			CWrite(IncludePlayer,V(FCONV[1]),V(FCONV[5]))

			DoActionsX(IncludePlayer,{SetCVar("X",FCONV[1],Add,0x970/4),SetCVar("X",FCONV[5],SetTo,0)})

			Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc);
					},
					actions = {
						SetMemory(0x6509B0,Add,1);
					},
					flag = {Preserved}
				}
			table.insert(FCONVArr,{FuncAlloc,0x15C})
			FuncAlloc = FuncAlloc + 1
		CWhileEnd()

		CIf(IncludePlayer,{CVar("X",FCONV[3],AtLeast,1),CVar("X",FCONV[4],Exactly,0)},{SetCVar("X",FCONV[3],Subtract,1),SetCVar("X",FCONV[5],SetTo,0)}) -- +0 -> +1
			for i = 0, 7, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",FCONV[5],Add,(CBit)*0x01010101);
					},
					flag = {Preserved}
				}
			end
			CWrite(IncludePlayer,V(FCONV[1]),V(FCONV[5]))

			DoActionsX(IncludePlayer,{SetCVar("X",FCONV[1],Add,0x970/4),SetCVar("X",FCONV[4],SetTo,1)})
		CIfEnd()

		CIf(IncludePlayer,{CVar("X",FCONV[3],AtLeast,1),CVar("X",FCONV[4],Exactly,1)},{SetCVar("X",FCONV[3],Subtract,1),SetCVar("X",FCONV[5],SetTo,0)}) -- +1 -> +2
			for i = 15, 8, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",FCONV[5],Add,(CBit/256)*0x01010101);
					},
					flag = {Preserved}
				}
			end
			CWrite(IncludePlayer,V(FCONV[1]),V(FCONV[5]))

			DoActionsX(IncludePlayer,{SetCVar("X",FCONV[1],Add,0x970/4),SetCVar("X",FCONV[4],SetTo,2)})
		CIfEnd()
 
		CIf(IncludePlayer,{CVar("X",FCONV[3],AtLeast,1),CVar("X",FCONV[4],Exactly,2)},{SetCVar("X",FCONV[3],Subtract,1),SetCVar("X",FCONV[5],SetTo,0)}) -- +2 -> +3
			for i = 23, 16, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",FCONV[5],Add,(CBit/65536)*0x01010101);
					},
					flag = {Preserved}
				}
			end
			CWrite(IncludePlayer,V(FCONV[1]),V(FCONV[5]))

			DoActionsX(IncludePlayer,{SetCVar("X",FCONV[1],Add,0x970/4),SetCVar("X",FCONV[4],SetTo,3)})
		CIfEnd()

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				flag = {Preserved}
			}
		FCONVCall2 = FuncAlloc
		FuncAlloc = FuncAlloc + 1
]]--

-- 	f_byteCpy - [1] : SourceVA Offset / [2] : Dest / [3] : Size / [4] : DestX
		for i = 0, 3 do
			CVariable(IncludePlayer,FuncAlloc+i)
			table.insert(FBYTE,FuncAlloc+i)
		end
		FuncAlloc = FuncAlloc + 4

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				flag = {Preserved}
			}
		FBYTECall0 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

		CMod(IncludePlayer,V(FBYTE[4]),V(FBYTE[2]),4)
		CMov(IncludePlayer,V(FBYTE[2]),V(CRet[1]))
		CiSub(IncludePlayer,V(FBYTE[2]),1452249)

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				flag = {Preserved}
			}
		FBYTECall1 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

		CIfX(IncludePlayer,CVar("X",FBYTE[4],AtLeast,4))
			CMod(IncludePlayer,V(FBYTE[4]),4)
			CAdd(IncludePlayer,V(FBYTE[2]),V(CRet[1]))
		CIfXEnd()


		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2);
					SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,3);
					SetCtrigX("X","X",0x4,3,SetTo,"X","X",0x0,0,4);
					SetCtrigX("X","X",0x4,4,SetTo,"X","X",0x0,0,5);
					SetCtrig1X("X",FBYTE[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FBYTE[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X("X",FBYTE[2],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FBYTE[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X("X",FuncAlloc,0x15C+0x20*6,0,SetTo,0x00000000);
					SetCtrig1X("X",FuncAlloc+2,0x15C+0x20*6,0,SetTo,0x00000000);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FBYTE[4],Exactly,0,0x3);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FBYTE[4],Exactly,1,0x3);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,-4);
					SetMemory(0x6509B0,Add,0x970/4);
					SetCVar("X",FBYTE[1],Add,0x970);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FBYTE[4],Exactly,2,0x3);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,-3);
					SetMemory(0x6509B0,Add,0x970/2);
					SetCVar("X",FBYTE[1],Add,0x970*2);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FBYTE[4],Exactly,3,0x3);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,-2);
					SetMemory(0x6509B0,Add,3*0x970/4);
					SetCVar("X",FBYTE[1],Add,0x970*3);
				},
				flag = {Preserved}
			}


  			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FBYTE[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FBYTE[3],Subtract,1);
					SetCtrig1X("X",FuncAlloc,0x15C+0x20*6,0,SetTo,0xFF00,0xFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FBYTE[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FBYTE[3],Subtract,1);
					SetCtrig1X("X",FuncAlloc,0x15C+0x20*6,0,SetTo,0xFF0000,0xFF0000);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FBYTE[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FBYTE[3],Subtract,1);
					SetCtrig1X("X",FuncAlloc,0x15C+0x20*6,0,SetTo,0xFF000000,0xFF000000);
				},
				flag = {Preserved}
			}

			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FBYTE[1],0x158,0,SetTo,"X","X",0x15C+0x20*0,1,1); 
					SetCtrigX("X",FBYTE[2],0x158,0,SetTo,"X","X",0x15C+0x20*4,1,1); 
					CallLabelAlways2("X",FBYTE[1],0,"X",FBYTE[2],0);
				},
				flag = {Preserved}
			}

			Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				actions = {
					SetCtrig1X("X",FuncAlloc,0x4,0,SetTo,0); -- next offset
					SetMemory(0x6509B0,Add,(0x4-0x0)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- next epd
					SetMemory(0x6509B0,Add,(0x158-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,0,0); -- epd
					SetMemory(0x6509B0,Add,(0x148-0x158)/4);
					SetDeaths(CurrentPlayer,SetTo,0x00000000,0); -- Mask
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- type 
					SetMemory(0x6509B0,Add,(0x0-0x160)/4);
					SetCVar("X",FBYTE[2],Add,1);
					SetCVar("X",FBYTE[1],Add,0x970*4);
					SetMemory(0x6509B0,Add,0x970);
				},
				flag = {Preserved}
			}

			table.insert(FBYTEArr,{FuncAlloc,0x15C+0x20*10})
			FuncAlloc = FuncAlloc+1

			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FBYTE[1],0x158,0,SetTo,"X",FuncAlloc,0x15C+0x20*0,1,0); 
					SetCtrigX("X",FBYTE[2],0x158,0,SetTo,"X",FuncAlloc,0x15C+0x20*4,1,0); 
					CallLabelAlways2("X",FBYTE[1],0,"X",FBYTE[2],0);
				},
				flag = {Preserved}
			}

  		CWhile(IncludePlayer,{CVar("X",FBYTE[3],AtLeast,4)},{SetCVar("X",FBYTE[3],Subtract,4)})

			Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				actions = {
					SetCtrig1X("X",FuncAlloc,0x4,0,SetTo,0); -- next offset
					SetMemory(0x6509B0,Add,(0x4-0x0)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- next epd
					SetMemory(0x6509B0,Add,(0x158-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,0,0); -- epd
					SetMemory(0x6509B0,Add,(0x148-0x158)/4);
					SetDeaths(CurrentPlayer,SetTo,0xFFFFFFFF,0); -- Mask
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- type 
					SetMemory(0x6509B0,Add,(0x0-0x160)/4);
					SetCVar("X",FBYTE[2],Add,1);
					SetCVar("X",FBYTE[1],Add,0x970*4);
					SetMemory(0x6509B0,Add,0x970);
					SetCtrig1X("X","X",0x15C+0x20*0,0,Add,0x970*4);
					SetCtrig1X("X","X",0x15C+0x20*4,0,Add,1);
				},
				flag = {Preserved}
			}

			table.insert(FBYTEArr,{FuncAlloc,0x15C+0x20*10})
			table.insert(FBYTEArr,{FuncAlloc,0x15C+0x20*14})
			FuncAlloc = FuncAlloc+1

		CWhileEnd()

  			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FBYTE[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FBYTE[3],Subtract,1);
					SetCtrig1X("X",FuncAlloc,0x15C+0x20*6,0,SetTo,0xFF,0xFF);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FBYTE[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FBYTE[3],Subtract,1);
					SetCtrig1X("X",FuncAlloc,0x15C+0x20*6,0,SetTo,0xFF00,0xFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FBYTE[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FBYTE[3],Subtract,1);
					SetCtrig1X("X",FuncAlloc,0x15C+0x20*6,0,SetTo,0xFF0000,0xFF0000);
				},
				flag = {Preserved}
			}

			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FBYTE[1],0x158,0,SetTo,"X",FuncAlloc,0x15C+0x20*0,1,0); 
					SetCtrigX("X",FBYTE[2],0x158,0,SetTo,"X",FuncAlloc,0x15C+0x20*4,1,0); 
					CallLabelAlways2("X",FBYTE[1],0,"X",FBYTE[2],0);
				},
				flag = {Preserved}
			}

			Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				actions = {
					SetCtrig1X("X",FuncAlloc,0x4,0,SetTo,0); -- next offset
					SetMemory(0x6509B0,Add,(0x4-0x0)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- next epd
					SetMemory(0x6509B0,Add,(0x158-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,0,0); -- epd
					SetMemory(0x6509B0,Add,(0x148-0x158)/4);
					SetDeaths(CurrentPlayer,SetTo,0x00000000,0); -- Mask
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- type 
					SetMemory(0x6509B0,Add,(0x0-0x160)/4);
				},
				flag = {Preserved}
			}
			FuncAlloc = FuncAlloc+1


		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				flag = {Preserved}
			}
		FBYTECall2 = FuncAlloc
		FuncAlloc = FuncAlloc + 1


-- 	f_bytecmp - [1] : SourceVA Offset / [2] : Dest / [3] : Size / [4] : DestX
		for i = 0, 3 do
			CVariable(IncludePlayer,FuncAlloc+i)
			table.insert(FCOND,FuncAlloc+i)
		end
		FuncAlloc = FuncAlloc + 4

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				flag = {Preserved}
			}
		FCONDCall0 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

		CMod(IncludePlayer,V(FCOND[4]),V(FCOND[2]),4)
		CMov(IncludePlayer,V(FCOND[2]),V(CRet[1]))
		CiSub(IncludePlayer,V(FCOND[2]),1452249)

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				flag = {Preserved}
			}
		FCONDCall1 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

		CIfX(IncludePlayer,CVar("X",FCOND[4],AtLeast,4))
			CMod(IncludePlayer,V(FCOND[4]),4)
			CAdd(IncludePlayer,V(FCOND[2]),V(CRet[1]))
		CIfXEnd()


		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2);
					SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,3);
					SetCtrigX("X","X",0x4,3,SetTo,"X","X",0x0,0,4);
					SetCtrigX("X","X",0x4,4,SetTo,"X","X",0x0,0,5);
					SetCtrig1X("X",FCOND[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FCOND[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X("X",FCOND[2],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FCOND[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X("X",FuncAlloc,0x15C+0x20*6,-1,SetTo,0x00000000);
					SetCtrig1X("X",FuncAlloc+2,0x15C+0x20*6,-1,SetTo,0x00000000);
					SetCtrig1X("X",FuncAlloc,0x1C,0,SetTo,0x00000000);
					SetCtrig1X("X",FuncAlloc+2,0x1C,0,SetTo,0x00000000);
					SetCtrig1X("X",FuncAlloc,0x24,0,SetTo,0x00000000);
					SetCtrig1X("X",FuncAlloc+2,0x24,0,SetTo,0x00000000);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCOND[4],Exactly,0,0x3);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCOND[4],Exactly,1,0x3);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,-5);
					SetMemory(0x6509B0,Add,0x970/4);
					SetCVar("X",FCOND[1],Add,0x970);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCOND[4],Exactly,2,0x3);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,-4);
					SetMemory(0x6509B0,Add,0x970/2);
					SetCVar("X",FCOND[1],Add,0x970*2);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCOND[4],Exactly,3,0x3);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,-3);
					SetMemory(0x6509B0,Add,3*0x970/4);
					SetCVar("X",FCOND[1],Add,0x970*3);
				},
				flag = {Preserved}
			}


  			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCOND[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FCOND[3],Subtract,1);
					SetCtrig1X("X",FuncAlloc,0x15C+0x20*6,-1,SetTo,0xFF00,0xFF00);
					SetCtrig1X("X",FuncAlloc,0x1C,0,SetTo,0xFF00,0xFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCOND[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FCOND[3],Subtract,1);
					SetCtrig1X("X",FuncAlloc,0x15C+0x20*6,-1,SetTo,0xFF0000,0xFF0000);
					SetCtrig1X("X",FuncAlloc,0x1C,0,SetTo,0xFF0000,0xFF0000);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCOND[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FCOND[3],Subtract,1);
					SetCtrig1X("X",FuncAlloc,0x15C+0x20*6,-1,SetTo,0xFF000000,0xFF000000);
					SetCtrig1X("X",FuncAlloc,0x1C,0,SetTo,0xFF000000,0xFF000000);
				},
				flag = {Preserved}
			}

			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FCOND[1],0x158,0,SetTo,"X","X",0x15C+0x20*0,1,1); 
					SetCtrigX("X",FCOND[2],0x158,0,SetTo,"X","X",0x20,1,2); 
					CallLabelAlways2("X",FCOND[1],0,"X",FCOND[2],0);
				},
				flag = {Preserved}
			}

			Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- next offset
					SetMemory(0x6509B0,Add,(0x4-0x0)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- next epd
					SetMemory(0x6509B0,Add,(0x158-0x4)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0x24,1,1); -- epd
					SetMemory(0x6509B0,Add,(0x148-0x158)/4);
					SetDeaths(CurrentPlayer,SetTo,0x00000000,0); -- Mask
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- type 
					SetMemory(0x6509B0,Add,(0x0-0x160)/4);
					SetCVar("X",FCOND[1],Add,0x970*4);
					SetMemory(0x6509B0,Add,0x970);
					SetCtrigX("X","X",0x4,1,SetTo,"X",FuncAlloc+4,0x0,0,0); 
				},
				flag = {Preserved}
			}

			Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
					MemoryX(0,Exactly,0,0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1);
					SetCVar("X",FCOND[2],Add,1);
				},
				flag = {Preserved}
			}

			table.insert(FCONDArr,{FuncAlloc,0x15C+0x20*1})
			FuncAlloc = FuncAlloc+1


			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FCOND[1],0x158,0,SetTo,"X",FuncAlloc,0x15C+0x20*0,1,-1); 
					SetCtrigX("X",FCOND[2],0x158,0,SetTo,"X",FuncAlloc,0x20,1,0); 
					CallLabelAlways2("X",FCOND[1],0,"X",FCOND[2],0);
				},
				flag = {Preserved}
			}

  		NWhile(IncludePlayer,{CVar("X",FCOND[3],AtLeast,4)},{SetCVar("X",FCOND[3],Subtract,4)})

			Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- next offset
					SetMemory(0x6509B0,Add,(0x4-0x0)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- next epd
					SetMemory(0x6509B0,Add,(0x158-0x4)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0x24,1,1); -- epd
					SetMemory(0x6509B0,Add,(0x148-0x158)/4);
					SetDeaths(CurrentPlayer,SetTo,0xFFFFFFFF,0); -- Mask
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- type 
					SetMemory(0x6509B0,Add,(0x0-0x160)/4);
					SetCVar("X",FCOND[1],Add,0x970*4);
					SetMemory(0x6509B0,Add,0x970);
					SetCtrig1X("X","X",0x15C+0x20*0,0,Add,0x970*4);
					SetCtrigX("X","X",0x4,1,SetTo,"X",FuncAlloc+3,0x0,0,0); 
				},
				flag = {Preserved}
			}

			Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
					MemoryX(0,Exactly,0,0xFFFFFFFF);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1);
					SetCtrig1X("X","X",0x20,0,Add,1);
					SetCVar("X",FCOND[2],Add,1);
				},
				flag = {Preserved}
			}

			table.insert(FCONDArr,{FuncAlloc,0x15C+0x20*1})
			table.insert(FCONDArr,{FuncAlloc,0x15C+0x20*2})
			FuncAlloc = FuncAlloc+1

		NWhileEnd()

			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCOND[3],Exactly,0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+1,0x0,0,0);
				},
				flag = {Preserved}
			}

  			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCOND[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FCOND[3],Subtract,1);
					SetCtrig1X("X",FuncAlloc,0x15C+0x20*6,-1,SetTo,0xFF,0xFF);
					SetCtrig1X("X",FuncAlloc,0x1C,0,SetTo,0xFF,0xFF);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCOND[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FCOND[3],Subtract,1);
					SetCtrig1X("X",FuncAlloc,0x15C+0x20*6,-1,SetTo,0xFF00,0xFF00);
					SetCtrig1X("X",FuncAlloc,0x1C,0,SetTo,0xFF00,0xFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCOND[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FCOND[3],Subtract,1);
					SetCtrig1X("X",FuncAlloc,0x15C+0x20*6,-1,SetTo,0xFF0000,0xFF0000);
					SetCtrig1X("X",FuncAlloc,0x1C,0,SetTo,0xFF0000,0xFF0000);
				},
				flag = {Preserved}
			}

			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FCOND[1],0x158,0,SetTo,"X",FuncAlloc,0x15C+0x20*0,1,-1); 
					SetCtrigX("X",FCOND[2],0x158,0,SetTo,"X",FuncAlloc,0x20,1,0);
					CallLabelAlways2("X",FCOND[1],0,"X",FCOND[2],0);
				},
				flag = {Preserved}
			}

			Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- next offset
					SetMemory(0x6509B0,Add,(0x4-0x0)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- next epd
					SetMemory(0x6509B0,Add,(0x158-0x4)/4);
					SetCtrig2X("Cp",SetTo,"X",FuncAlloc,0x24,1,0); -- epd
					SetMemory(0x6509B0,Add,(0x148-0x158)/4);
					SetDeaths(CurrentPlayer,SetTo,0x00000000,0); -- Mask
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- type 
					SetMemory(0x6509B0,Add,(0x0-0x160)/4);
					SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc+2,0x0,0,0); 
				},
				flag = {Preserved}
			}

			Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
					MemoryX(0,Exactly,0,0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}
			FuncAlloc = FuncAlloc+1

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				actions = {
					SetCtrigX("X","X",0x4,-7,SetTo,"X","X",0x0,0,-6);
				},
				flag = {Preserved}
			}
		FCONDCall2 = FuncAlloc
		FuncAlloc = FuncAlloc + 1


		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				flag = {Preserved}
			}
		FCONDCall3 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

	if Flag ~= nil and Flag ~= "X" then
-- f_Memcpy - Ret[1] : Input Dest / Ret[2] = Source / Ret[3] = DestX / Ret[4] = SourceX / Ret[5] = Size
		for i = 0, 5 do
			CVariable(IncludePlayer,FuncAlloc+i)
			table.insert(FMEM,FuncAlloc+i)
		end
		FuncAlloc = FuncAlloc + 6

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				flag = {Preserved}
			}
		FMEMCall0 =	FuncAlloc
		FuncAlloc = FuncAlloc + 1

		
		CIfX(IncludePlayer,CVar("X",FMEM[6],Exactly,0))
			CMod(IncludePlayer,V(FMEM[3]),V(FMEM[1]),4)
			CMov(IncludePlayer,V(FMEM[1]),V(CRet[1]))
			CiSub(IncludePlayer,V(FMEM[1]),1452249)
		CIfXEnd()
		CMod(IncludePlayer,V(FMEM[4]),V(FMEM[2]),4)
		CMov(IncludePlayer,V(FMEM[2]),V(CRet[1]))
		CiSub(IncludePlayer,V(FMEM[2]),1452249)

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				flag = {Preserved}
			}
		FMEMCall1 =	FuncAlloc
		FuncAlloc = FuncAlloc + 1

		CIfX(IncludePlayer,CVar("X",FMEM[3],AtLeast,4))
			CMod(IncludePlayer,V(FMEM[3]),4)
			CAdd(IncludePlayer,V(FMEM[1]),V(CRet[1]))
		CIfXEnd()

		CIfX(IncludePlayer,CVar("X",FMEM[4],AtLeast,4))
			CMod(IncludePlayer,V(FMEM[4]),4)
			CAdd(IncludePlayer,V(FMEM[2]),V(CRet[1]))
		CIfXEnd()

		CIfX(IncludePlayer,CVar("X",FMEM[3],Exactly,0))
			CIfX(IncludePlayer,CVar("X",FMEM[4],Exactly,0))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFFFFFF,1),0xFFFFFFFF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1),SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*1})
					FuncAlloc = FuncAlloc + 1
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFFFF,1),0x00FFFFFF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,1),0x0000FFFF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,1),0x000000FF)},{Preserved})
				CIfXEnd()
			CElseIfX(CVar("X",FMEM[4],Exactly,1))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFFFF00,1/256),0x00FFFFFF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF,16777216),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFFFF00,1/256),0x00FFFFFF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFF00,1/256),0x0000FFFF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FF00,1/256),0x000000FF)},{Preserved})
				CIfXEnd()
			CElseIfX(CVar("X",FMEM[4],Exactly,2))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1/65536),0x0000FFFF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,65536),0xFFFF0000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1/65536),0x0000FFFF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,65536),0x00FF00000)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1/65536),0x0000FFFF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FF0000,1/65536),0x000000FF)},{Preserved})
				CIfXEnd()
			CElseX()
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/16777216),0x000000FF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFFFF,256),0xFFFFFF00)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/16777216),0x000000FF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,256),0x00FFFF000)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/16777216),0x000000FF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,256),0x0000FF000)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/16777216),0x000000FF)},{Preserved})
				CIfXEnd()
			CIfXEnd()
		CElseIfX(CVar("X",FMEM[3],Exactly,1))
			CIfX(IncludePlayer,CVar("X",FMEM[4],Exactly,0))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFFFF,256),0xFFFFFF00)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/16777216),0x000000FF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFFFF,256),0xFFFFFF00)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,256),0x00FFFF00)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,256),0x0000FF00)},{Preserved})
				CIfXEnd()
			CElseIfX(CVar("X",FMEM[4],Exactly,1))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFFFF00,1),0xFFFFFF00)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1),SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*1})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,1),0x000000FF)},{Preserved})
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFFFF00,1),0xFFFFFF00)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFF00,1),0x00FFFF00)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FF00,1),0x0000FF00)},{Preserved})
				CIfXEnd()
			CElseIfX(CVar("X",FMEM[4],Exactly,2))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1/256),0x00FFFF00)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,16777216),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FF00,1/256),0x000000FF)},{Preserved})
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1/256),0x00FFFF00)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,16777216),0xFF000000)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1/256),0x00FFFF00)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FF0000,1/256),0x0000FF00)},{Preserved})
				CIfXEnd()
			CElseX()
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/65536),0x0000FF00)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,65536),0xFFFF0000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FF0000,1/65536),0x000000FF)},{Preserved})
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/65536),0x0000FF00)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,65536),0xFFFF0000)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/65536),0x0000FF00)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,65536),0x00FF0000)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/65536),0x0000FF00)},{Preserved})
				CIfXEnd()
			CIfXEnd()
		CElseIfX(CVar("X",FMEM[3],Exactly,2))
			CIfX(IncludePlayer,CVar("X",FMEM[4],Exactly,0))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,65536),0xFFFF0000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1/65536),0x0000FFFF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,65536),0xFFFF0000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FF0000,1/65536),0x000000FF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,65536),0xFFFF0000)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,65536),0x00FF0000)},{Preserved})
				CIfXEnd()
			CElseIfX(CVar("X",FMEM[4],Exactly,1))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFF00,256),0xFFFF0000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/16777216),0x000000FF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,256),0x0000FF00)},{Preserved})
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFF00,256),0xFFFF0000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/16777216),0x000000FF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFF00,256),0xFFFF0000)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FF00,256),0x00FF0000)},{Preserved})
				CIfXEnd()
			CElseIfX(CVar("X",FMEM[4],Exactly,2))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1),0xFFFF0000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1),SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*1})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,1),0x0000FFFF)},{Preserved})
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1),0xFFFF0000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,1),0x000000FF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1),0xFFFF0000)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FF0000,1),0x00FF0000)},{Preserved})
				CIfXEnd()
			CElseX()
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/256),0x00FF0000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,16777216),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFF00,1/256),0x0000FFFF)},{Preserved})
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/256),0x00FF0000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,16777216),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FF00,1/256),0x000000FF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/256),0x00FF0000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,16777216),0xFF000000)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/256),0x00FF0000)},{Preserved})
				CIfXEnd()
			CIfXEnd()
		CElseX()
			CIfX(IncludePlayer,CVar("X",FMEM[4],Exactly,0))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,16777216),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFFFF00,1/256),0x00FFFFFF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,16777216),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFF00,1/256),0x0000FFFF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,16777216),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FF00,1/256),0x000000FF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,16777216),0xFF000000)},{Preserved})
				CIfXEnd()
			CElseIfX(CVar("X",FMEM[4],Exactly,1))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FF00,65536),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1/65536),0x0000FFFF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,65536),0x00FF0000)},{Preserved})
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FF00,65536),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1/65536),0x0000FFFF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FF00,65536),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FF0000,1/65536),0x000000FF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FF00,65536),0xFF000000)},{Preserved})
				CIfXEnd()
			CElseIfX(CVar("X",FMEM[4],Exactly,2))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FF0000,256),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/16777216),0x000000FF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,256),0x00FFFF00)},{Preserved})
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FF0000,256),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/16777216),0x000000FF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,256),0x0000FF00)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FF0000,256),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/16777216),0x000000FF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FF0000,256),0xFF000000)},{Preserved})
				CIfXEnd()
			CElseX()
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFFFF,1),0x00FFFFFF)},{Preserved})
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,1),0x0000FFFF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc);},actions = {SetCVar("X",FMEM[2],Add,1),SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*1})
					FuncAlloc = FuncAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,1),0x000000FF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1),0xFF000000)},{Preserved})
				CIfXEnd()
			CIfXEnd()
		CIfXEnd()

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				flag = {Preserved}
			}
		FMEMCall2 =	FuncAlloc
		FuncAlloc = FuncAlloc + 1
	end
end

FiMULCall1 = 0
FiMULCall2 = 0
FMULCall0 = 0
FMULCall1 = 0
FMULCall2 = 0
FDIVCall1 = 0
FDIVCall2 = 0
FDIVCall3 = 0
FMODCall1 = 0
FMODCall2 = 0
FMODCall3 = 0
FIDIVCall1 = 0
FIDIVCall2 = 0
FIDIVCall3 = 0
FIMODCall1 = 0
FIMODCall2 = 0
FIMODCall3 = 0
FABSCall1 = 0
FABSCall2 = 0
function Include_ArithMetic(PlayerID) -- f_Mul f_Div f_iDiv f_Mod f_iMod f_Abs
	local IncludePlayer
	if PlayerID == nil then
		IncludePlayer = AllPlayers
	else
		IncludePlayer = ParsePlayer(PlayerID)
	end

-- f_MulXX / f_iMulXX - FuncAlloc+2 : Input X / Ret[2] : Input Y / Ret[3] : Output | Ouput = X * Y (f_Mul 최적화 버젼)

	Trigger {
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc+3);
		},
		flag = {Preserved}
	}

	CIfX(IncludePlayer,CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000))
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[4],0x15C,0,SetTo,1); -- Sflag
						SetCtrig1X("X",CRet[1],0x15C,0,Add,-1);
						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
	CElseX()
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[4],0x15C,0,SetTo,0); -- Sflag
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
	CIfXEnd()

	Trigger {
		players = {IncludePlayer},
		conditions = { -- Ret = 0
			Label(FuncAlloc);
		},
		actions = {
			SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0);
			SetCtrig1X("X",FuncAlloc+2,0x184+0x20*3,0,SetTo,0x2,0x2); -- Reset Flag
			SetCtrigX("X",FuncAlloc+2,0x158,0,SetTo,"X",FuncAlloc+2,0x15C,1,0); 
			SetCtrigX("X",FuncAlloc+2,0x17C,0,SetTo,"X",FuncAlloc+2,0,0,2);
			SetCtrig1X("X",FuncAlloc+2,0x160+0x20*6,0,SetTo,0x0,0xFF0000);
		},
		flag = {Preserved}
	}

	for i = 31, 0, -1 do
		local CBit = 2^i
		Trigger { -- 1 ~ 32
			players = {IncludePlayer},
			conditions = { -- X Max Bit Check
				Label(0);
				CtrigX("X",CRet[2],0x15C,0,AtLeast,CBit);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+2,0,0,1); -- Jump Calc
				SetCtrigX("X",FuncAlloc+1,0x158,0,SetTo,"X","X",0x4,1,0); -- RecoverNext
				SetCtrigX("X",FuncAlloc+1,0x15C,0,SetTo,"X","X",0,0,1); -- RecoverNext
				SetCtrigX("X",FuncAlloc+2,0x158+0x20*3,0,SetTo,"X",FuncAlloc+2,0x164+0x20*4+0x20*i,1,0);
			},
			flag = {Preserved}
		}
	end
	Trigger { -- 0
			players = {IncludePlayer},
			conditions = { -- X Max Bit Check
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+1,0,0,0); -- Jump Calc
				SetCtrigX("X",FuncAlloc+1,0x158,0,SetTo,"X","X",0x4,1,0); -- RecoverNext
				SetCtrigX("X",FuncAlloc+1,0x15C,0,SetTo,"X","X",0,0,1); -- RecoverNext
			},
			flag = {Preserved}
		}

	Trigger { -- LoopX 
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+2);
			},
			actions = {
				SetMemoryX(0,Add,0,0xFFFFFFFF); -- Inline Variable X
				SetCtrig1X("X","X",0x4,0,SetTo,0);
				SetCtrig1X("X","X",0x17C,0,Add,0x970);
				SetDeathsX(0,SetTo,0x0,0,0x2); -- Timer Action
				Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+1,0,0,0)); -- Exit Action
				SetCtrig1X("X","X",0x158+0x20*3,0,Subtract,8); -- Run Tick
				-----------------------------------------------------------
				SetCtrigX("X",FuncAlloc+2,0x158,0,SetTo,"X",FuncAlloc+2,0x15C,1,0); -- X_epd -> X
				SetCtrig1X("X",FuncAlloc+2,0x164+0x20*1,0,SetTo,0,0x2); -- enable 
				SetCtrig1X("X",FuncAlloc+2,0x164+0x20*2,0,SetTo,0,0x2); -- enable 
				SetCtrig1X("X",FuncAlloc+2,0x160+0x20*6,0,SetTo,0x000000,0xFF0000);

			},
			flag = {Preserved}
		}

	for i = 0, 31 do
		local CBit = 2^i
		Trigger { -- 1 ~ 32
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CtrigX("X",CRet[2],0x15C,0,Exactly,CBit,CBit);
			},
			actions = {
				SetCtrigX("X",FuncAlloc+2,0x158,0,SetTo,"X",CRet[3],0x15C,1,0); -- X_epd -> Ret
				SetCtrig1X("X",FuncAlloc+2,0x164+0x20*1,0,SetTo,0x2,0x2); -- disable
				SetCtrig1X("X",FuncAlloc+2,0x164+0x20*2,0,SetTo,0x2,0x2); -- disable
				SetCtrig1X("X",FuncAlloc+2,0x160+0x20*6,0,SetTo,0x2D0000,0xFF0000);
				SetCtrigX("X",FuncAlloc+2,0x4,0,SetTo,"X",FuncAlloc+2,0x0,0,0);
				SetCtrig1X("X",FuncAlloc+2,0x158+0x20*3,0,Add,0x20/4);
			},
			flag = {Preserved}
		}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
				SetDeaths(0,SetTo,0,0); -- RecoverNext
			},
			flag = {Preserved}
		}


	CIfX(IncludePlayer,CtrigX("X",CRet[4],0x15C,0,Exactly,1))
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[3],0x15C,0,Add,-1);
						SetCtrig1X("X",CRet[4],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[3],0x158,0,SetTo,"X",CRet[4],0x15C,1,0);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
	CElseX()
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[3],0x158,0,SetTo,"X",CRet[4],0x15C,1,0);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
	CIfXEnd()

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+4);
			},
			flag = {Preserved}
		}

	local PlayerID = IncludePlayer
	PlayerID = PlayerConvert(PlayerID)
	for k, P in pairs(PlayerID) do
		for i = 1, 32 do
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc+2,0x4,i,SetTo,"X",FuncAlloc+2,0x0,0,0))
		end
	end


FMULCall0 = FuncAlloc+2
FMULCall1 = FuncAlloc
FMULCall2 = FuncAlloc+1
FiMULCall1 = FuncAlloc+3
FiMULCall2 = FuncAlloc+4
FuncAlloc = FuncAlloc+5
--------------------------------------------------------------------------------------------------------------------
--f_DivX/iDivX/ModX/iModX - Ret[2] : Input X / Ret[1] : Input Y / Ret[3],[2],[5] : Output | Ouput = X / Y (f_Div 최적화 버젼)
--------------------- f_iDiv-------------------------------------------------------
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- FIDIV1
				},
				flag = {Preserved}
			}
		CIfX(IncludePlayer,CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000))
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[4],0x15C,0,SetTo,1); -- Sflag
						SetCtrig1X("X",CRet[1],0x15C,0,Add,-1);
						SetCtrig1X("X",FuncAlloc+5,0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+5,0x15C,1,0);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+5,0x17C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+5,0x17C,1,0);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
		CElseX()
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[4],0x15C,0,SetTo,0); -- Sflag
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+5,0x15C,1,0);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+5,0x17C,1,0);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()

		CIfX(IncludePlayer,CtrigX("X",CRet[5],0x15C,0,AtLeast,0x80000000))
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[4],0x15C,0,Add,1); -- Sflag
						SetCtrig1X("X",CRet[5],0x15C,0,Add,-1);
						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[5],0x158,0,SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X("X",CRet[5],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[5],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",CRet[5],0);
					},
					flag = {Preserved}
				}
		CElseX()
			Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[5],0x158,0,SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X("X",CRet[5],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[5],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- FIDIV1
					CtrigX("X",CRet[1],0x15C,0,AtLeast,1);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+4,0x0,0,0); -- goto Div Calc Start
					SetCtrigX("X",FuncAlloc+6,0x4,0,SetTo,"X",FuncAlloc+11,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+6,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FuncAlloc+6,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- FIDIV1
					CtrigX("X",CRet[4],0x15C,0,Exactly,0,0x1);
				},
				actions = {
					SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0x7FFFFFFF); 
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- FIDIV1
					CtrigX("X",CRet[4],0x15C,0,Exactly,1,0x1);
				},
				actions = {
					SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0x80000000); 
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- /0
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+12,0x0,0,0); -- 분기점 -> End
				},
				flag = {Preserved}
			}
	FIDIVCall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1
--------------------- f_iMod-------------------------------------------------------

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- FIMOD1
				},
				flag = {Preserved}
			}

		CIfX(IncludePlayer,CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000))
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,Add,-1);
						SetCtrig1X("X",FuncAlloc+4,0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+4,0x15C,1,0);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+4,0x17C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+4,0x17C,1,0);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
		CElseX()
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+4,0x15C,1,0);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+4,0x17C,1,0);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()

		CIfX(IncludePlayer,CtrigX("X",CRet[5],0x15C,0,AtLeast,0x80000000))
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[4],0x15C,0,SetTo,1); -- Sflag
						SetCtrig1X("X",CRet[5],0x15C,0,Add,-1);
						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[5],0x158,0,SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X("X",CRet[5],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[5],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",CRet[5],0);
					},
					flag = {Preserved}
				}
		CElseX()
			Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[4],0x15C,0,SetTo,0); -- Sflag
						SetCtrigX("X",CRet[5],0x158,0,SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X("X",CRet[5],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[5],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,1);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+3,0x0,0,0); -- goto Mod Calc Start
					SetCtrigX("X",FuncAlloc+5,0x4,0,SetTo,"X",FuncAlloc+8,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+5,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FuncAlloc+5,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}
		Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
						CtrigX("X",CRet[4],0x15C,0,Exactly,1,0x1);
					},
					actions = {
						SetCtrig1X("X",CRet[5],0x15C,0,Add,1);
					},
					flag = {Preserved}
				}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- /0
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+9,0x0,0,0); -- 분기점 -> End
				},
				flag = {Preserved}
			}

	FIMODCall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

--------------------- f_Div-------------------------------------------------------
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- FDIV1
				},
				actions = {
					SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+3,0x15C,1,0);
					SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[1],0);
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,1);
				},
				actions = {
					SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+3,0x17C,1,0);
					SetCtrigX("X","X",0x4,0,SetTo,"X",CRet[1],0x0,0,0);
					SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc+2,0x0,0,0); -- goto Div Calc Start
					SetCtrigX("X",FuncAlloc+4,0x4,0,SetTo,"X",FuncAlloc+6,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+4,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FuncAlloc+4,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- /0
				},
				actions = {
					SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0xFFFFFFFF);
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+6,0x0,0,0); -- 분기점 -> End
				},
				flag = {Preserved}
			}

	FDIVCall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

--------------------- f_Mod-------------------------------------------------------
	Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- FMOD1
				},
				actions = {
					SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+2,0x15C,1,0);
					SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[1],0);
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,1);
				},
				actions = {
					SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+2,0x17C,1,0);
					SetCtrigX("X","X",0x4,0,SetTo,"X",CRet[1],0x0,0,0);
					SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc+1,0x0,0,0); -- goto Mod Calc Start
					SetCtrigX("X",FuncAlloc+3,0x4,0,SetTo,"X",FuncAlloc+4,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+3,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FuncAlloc+3,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- /0
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+4,0x0,0,0); -- 분기점 -> End
				},
				flag = {Preserved}
			}

	FMODCall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

-------------------------------------------------------------------------------------------------------

		local ClearNext = {}
		for i = 1, 32 do
			table.insert(ClearNext,SetCtrigX("X",FuncAlloc+1,0x4,i,SetTo,"X",FuncAlloc+1,0,0,i+32)) -- B -> BF
		end

		Trigger { -- Clear Value
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				actions = {
					ClearNext,
					SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0);
					SetCtrigX("X",FuncAlloc+1,0x15C+0x20*2,0,SetTo,"X",FuncAlloc+1,0,0,1); -- X -> B+1
					SetCtrigX("X",FuncAlloc+1,0x158,0,SetTo,"X",FuncAlloc+1,0x15C,1,0); -- X_epd -> X
					SetCtrigX("X",FuncAlloc+1,0x178,0,SetTo,"X",FuncAlloc+1,0x17C,1,0); -- X_epd -> X
				},
				flag = {Preserved}
			}
	
		FuncAlloc = FuncAlloc + 1

		local ClearRet = {}
		for i = 0, 31 do
			table.insert(ClearRet,SetCtrig1X("X",FuncAlloc,0x24,65+i,SetTo,0))
			table.insert(ClearRet,SetCtrig1X("X",FuncAlloc,0x15C,65+i,SetTo,0))
		end

		Trigger { -- Clear Ret (-1)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					ClearRet,
				},
				flag = {Preserved}
			}

		Trigger { -- X (0)
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				actions = {
					SetMemoryX(0,Add,0,0xFFFFFFFF); -- 0x24
					SetMemoryX(0,Add,0,0xFFFFFFFF); -- 0x15C
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,1); -- X -> B+1
					--------------------------------
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,0); -- X -> X
					SetCtrigX("X",FuncAlloc,0x158,0,SetTo,"X",FuncAlloc,0x15C,1,0); -- X_epd -> X
					SetCtrigX("X",FuncAlloc,0x178,0,SetTo,"X",FuncAlloc,0x17C,1,0); -- X_epd -> X
					SetCtrig1X("X",FuncAlloc,0x15C+0x20*2,0,Add,0x970); -- X -> B+1 + i
					SetCtrig1X("X",FuncAlloc,0x160+0x20*3,0,SetTo,0x000000,0xFF0000); -- Close
				},
				flag = {Preserved}
			}

		for i = 0, 31 do
			Trigger { -- B (1~32)
					players = {IncludePlayer},
					conditions = {
						Label(0);
						CtrigX("X",FuncAlloc,0x15C,0,AtMost,0x7FFFFFFF);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,0); -- B -> X
						SetCtrigX("X",FuncAlloc,0x158,0,SetTo,"X",FuncAlloc,0x24,1,96-i); -- X_epd -> Ret
						SetCtrigX("X",FuncAlloc,0x178,0,SetTo,"X",FuncAlloc,0x15C,1,96-i); -- X_epd -> Ret
						SetCtrig1X("X",FuncAlloc,0x160+0x20*3,0,SetTo,0x2D0000,0xFF0000); -- Open
					},
					flag = {Preserved}
				}
		end

		for i = 0, 31 do
			Trigger { -- BF (33~64)
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",FuncAlloc,0x15C+0x20*2,0,SetTo,"X",FuncAlloc,0,0,96-i); -- X -> Ret
						SetCtrigX("X",FuncAlloc,0x158,0,SetTo,"X",FuncAlloc,0x24,1,96-i); -- X_epd -> Ret
						SetCtrigX("X",FuncAlloc,0x178,0,SetTo,"X",FuncAlloc,0x15C,1,96-i); -- X_epd -> Ret
					},
					flag = {Preserved}
				}
		end

		for i = 0, 31 do
			local CBit = 2^(31-i) -- 역행 2^31 -> 2^0
			Trigger { -- Ret (65~96)
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",CRet[2],0x15C,0,AtLeast,0); -- CRet[2] AtLeast X*2^i
				},
				actions = {
					SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0); -- CRet[2] Subtract X*2^i
					SetCtrig1X("X",CRet[3],0x15C,0,Add,CBit); -- CRet[3] Add 2^i
				},
				flag = {Preserved}
			}
		end

		local PlayerID = IncludePlayer
		PlayerID = PlayerConvert(PlayerID)
		for k, P in pairs(PlayerID) do
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,-1,SetTo,"X",FuncAlloc,0x0,0,1)) -- Clear -> B1
			for i = 1, 32 do
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i+32,SetTo,"X",FuncAlloc,0x0,0,0)) -- BF -> X
			end
		end

	FuncAlloc = FuncAlloc + 1

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- 분기점
				},
				actions = {
					SetMemory(0,SetTo,0);
				},
				flag = {Preserved}
			}
	FuncAlloc = FuncAlloc + 1
--------------------- f_Mod End-------------------------------------------------------
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- f_Mod End
				},
				flag = {Preserved}
			}
	FMODCall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1
--------------------- f_Div End-------------------------------------------------------
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- f_Div End
				},
				flag = {Preserved}
			}
	FDIVCall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

--------------------- f_iMod End-------------------------------------------------------
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- IMod End Start
				},
				flag = {Preserved}
			}

		CIfX(IncludePlayer,CtrigX("X",CRet[4],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[2],0x15C,0,Add,-1);
						SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[2],0x158,0,SetTo,"X",CRet[5],0x15C,1,0);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		CElseX()
			Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,"X",CRet[5],0x15C,1,0);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()
	
	FuncAlloc = FuncAlloc + 1

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- Exit Func
				},
				flag = {Preserved}
			}

	FIMODCall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

--------------------- f_iDiv End-------------------------------------------------------

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- IDiv End Start
				},
				flag = {Preserved}
			}

		CIfX(IncludePlayer,CtrigX("X",CRet[4],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[3],0x15C,0,Add,-1);
						SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[3],0x158,0,SetTo,"X",CRet[5],0x15C,1,0);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		CElseX()
			Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[3],0x158,0,SetTo,"X",CRet[5],0x15C,1,0);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()
	
	FuncAlloc = FuncAlloc + 1

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- Exit Func
				},
				flag = {Preserved}
			}

	FIDIVCall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1
------------------------------------------------------------------------------------------

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- Exit Func
				},
				flag = {Preserved}
			}

		CIfX(IncludePlayer,CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000))
			Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Add,-1);
					SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
					SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[2],0x15C,1,0);
					SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
					CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
		CElseX()
			Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[2],0x15C,1,0);
					SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc+1); -- Exit Func
				},
				flag = {Preserved}
			}

	FABSCall1 = FuncAlloc
	FABSCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

end


FSQRTCall1 = 0
FSQRTCall2 = 0
FSQRT = {}
FLENGCall1 = 0
FLENGCall2 = 0
FLENG = {}
FATANCall1 = 0
FATANCall2 = 0
FATAN = {}
FLOG2Call1 = 0
FLOG2Call2 = 0
FLOG2 = {}
function Include_MatheMatics(Cycle,PlayerID) -- f_Sqrt / f_Lengthdir / f_Atan2 / f_log2 | Cycle = 2*pi, 4의 배수여야함
-- f_Sqrt - Ret[1] : Input Value / Ret[2] = Output | Ret = √X 
	local IncludePlayer
	if PlayerID == nil then
		IncludePlayer = AllPlayers
	else
		IncludePlayer = ParsePlayer(PlayerID)
	end

	CVariable(IncludePlayer,FuncAlloc) -- Local Variable
	CVariable(IncludePlayer,FuncAlloc+1)
	FSQRT = {FuncAlloc,FuncAlloc+1}
	FuncAlloc = FuncAlloc + 2

	Trigger {
		players = {IncludePlayer},
		conditions = { -- X == 0
			Label(FuncAlloc);
			CtrigX("X",FSQRT[1],0x15C,0,Exactly,0);
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+1,0,0,0); -- Skip Calc
			SetCtrig1X("X",FSQRT[2],0x15C,0,SetTo,0);
		},
		flag = {Preserved}
	}

	for i = 15, 0, -1 do
		local CBit = 2^i
		Trigger { -- 1 ~ 16
			players = {IncludePlayer},
			conditions = { -- X Max Bit Check
				Label(0);
				CtrigX("X",FSQRT[1],0x15C,0,AtLeast,CBit^2);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,17+2*(15-i)); -- Jump Calc
				SetCtrig1X("X",FSQRT[2],0x15C,0,SetTo,0);	
			},
			flag = {Preserved}
		}
	end

	for i = 15, 0, -1 do -- 17 ~ 47
		local CBit = 2^i
		Trigger { -- 17, 19, ~ 47
			players = {IncludePlayer},
			conditions = { -- X^2 Binary Search
				Label(0);
				CtrigX("X",FSQRT[1],0x15C,0,AtLeast,CBit^2);
			},
			actions = {
				SetCtrig1X("X",FSQRT[2],0x15C,0,Add,CBit);
			},
			flag = {Preserved}
		}
		if i >= 1 then
			Trigger { -- 18, 20, ~ 46
				players = {IncludePlayer},
				conditions = { -- Go X^2
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[3],0x15C,0,SetTo,CBit/2); -- Add CBit
					SetCtrig1X("X",CRet[4],0x15C,0,SetTo,CBit/2);
					SetCtrigX("X",FuncAlloc+3,0x4,1,SetTo,"X","X",0,0,1);
					SetCtrigX("X",FuncAlloc+3,0x15C,0,SetTo,"X","X",0x24,1,1);	
				},
				flag = {Preserved}
			}
		end
	end

	local PlayerID = IncludePlayer
	PlayerID = PlayerConvert(PlayerID)
	for k, P in pairs(PlayerID) do
		for i = 18, 46, 2 do
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",FuncAlloc+1,0x0,0,1)) -- -> X*X
		end
	end

	ClearJump1 = {}
	for i = 0, 16 do 
		table.insert(ClearJump1,SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",FuncAlloc,0,0,i+1))
	end
	for i = 17, 47, 2 do 
		table.insert(ClearJump1,SetCtrig1X("X",FuncAlloc,0x24,i,SetTo, 2^(47-i) ))
	end

	Trigger {
		players = {IncludePlayer},
		conditions = { -- Init Calc
			Label(FuncAlloc+1);
		},
		actions = {
			ClearJump1,
		},
		flag = {Preserved}
	}
	FSQRTCall1 = FuncAlloc
	FSQRTCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

	Trigger { -- +1
		players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FSQRT[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",FSQRT[2],0x160,0,SetTo,Add*16777216,0xFF000000);
				SetCtrigX("X",FSQRT[2],0x158,0,SetTo,"X",CRet[3],0x15C,1,0);
				CallLabelAlways("X",FSQRT[2],0);
			},
			flag = {Preserved}
		}
	Trigger { -- +2
		players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FSQRT[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",FSQRT[2],0x160,0,SetTo,Add*16777216,0xFF000000);
				SetCtrigX("X",FSQRT[2],0x158,0,SetTo,"X",CRet[4],0x15C,1,0);
				CallLabelAlways("X",FSQRT[2],0);
			},
			flag = {Preserved}
		}

	CMul(IncludePlayer,V(CRet[3]),V(CRet[4]),"X","X",0xFFFF)-- FuncAlloc + 1

	Trigger { 
		players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrigX("X",CRet[3],0x158,0,SetTo,"X",FSQRTCall1,0x24,1,17);
				SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[3],0);
			},
			flag = {Preserved}
		}
	Trigger { 
		players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			flag = {Preserved}
		}
	FuncAlloc = FuncAlloc + 1

-- f_Lengthdir - Ret[1] : Input R  Ret[2] = Θ | Ret[3] = RCosΘ  Ret[4] = RSinΘ
	if Cycle == "X" or Cycle == nil then
		Cycle = 360
	end
	local Range = Cycle/4

	for i = 0, Range do
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc+i);
				},
				actions = {
					SetDeathsX(0,SetTo,0x10000*math.sin(math.rad(i*90/Range)),0,0xFFFFFFFF); -- Full Variable
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
	end
	FLENGVA = GetVArray(V(FuncAlloc))
	FuncAlloc = FuncAlloc + Range + 1
	for i = 0, 7 do
		CVariable(IncludePlayer,FuncAlloc+i) -- Local Variable
		table.insert(FLENG,FuncAlloc+i)
	end
	FuncAlloc = FuncAlloc + 8

	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc);
		},
		flag = {Preserved}
	}

 	CIfX(IncludePlayer,CVar("X",FLENG[2],AtLeast,Cycle))
		CiMod(IncludePlayer,V(FLENG[2]),Cycle)
	CIfXEnd()

	CIfX(IncludePlayer,CVar("X",FLENG[2],AtLeast,0x80000000))
		CAdd(IncludePlayer,V(FLENG[2]),Cycle)
	CIfXEnd()

	-- FLENG[5] = Cos Signflag / FLENG[6] = Sin Signflag / FLENG[7] = Cos VAindex / FLENG[8] = Sin VAindex
	CIfX(IncludePlayer,CVar("X",FLENG[2],AtMost,Range-1)) 
		DoActionsX(IncludePlayer,{SetCVar("X",FLENG[5],SetTo,0),SetCVar("X",FLENG[6],SetTo,0)})
		CMov(IncludePlayer,V(FLENG[8]),V(FLENG[2])) -- Sin.i << i
		CMov(IncludePlayer,V(FLENG[7]),Range)
		CSub(IncludePlayer,V(FLENG[7]),V(FLENG[2])) -- Cos.i << pi/2 - i
	CElseIfX(CVar("X",FLENG[2],AtMost,Range*2-1))
		DoActionsX(IncludePlayer,{SetCVar("X",FLENG[5],SetTo,1),SetCVar("X",FLENG[6],SetTo,0)})
		CMov(IncludePlayer,V(FLENG[8]),Range*2) -- Sin.i << pi - i
		CSub(IncludePlayer,V(FLENG[8]),V(FLENG[2]))
		CMov(IncludePlayer,V(FLENG[7]),V(FLENG[2])) -- Cos.i << i - pi/2
		CSub(IncludePlayer,V(FLENG[7]),Range)
	CElseIfX(CVar("X",FLENG[2],AtMost,Range*3-1))
		DoActionsX(IncludePlayer,{SetCVar("X",FLENG[5],SetTo,1),SetCVar("X",FLENG[6],SetTo,1)})
		CMov(IncludePlayer,V(FLENG[8]),V(FLENG[2])) -- Sin.i << i - pi
		CSub(IncludePlayer,V(FLENG[8]),Range*2)
		CMov(IncludePlayer,V(FLENG[7]),Range*3) -- Cos.i << 3pi/2 - i
		CSub(IncludePlayer,V(FLENG[7]),V(FLENG[2]))
	CElseX()
		DoActionsX(IncludePlayer,{SetCVar("X",FLENG[5],SetTo,0),SetCVar("X",FLENG[6],SetTo,1)})
		CMov(IncludePlayer,V(FLENG[8]),Range*4)
		CSub(IncludePlayer,V(FLENG[8]),V(FLENG[2])) -- Sin.i << 2pi - i
		CMov(IncludePlayer,V(FLENG[7]),V(FLENG[2]))
		CSub(IncludePlayer,V(FLENG[7]),Range*3) -- Cos.i << i - 3pi/2
	CIfXEnd()

	CMov(IncludePlayer,V(FLENG[4]),VArr(FLENGVA,V(FLENG[8])))
	CMov(IncludePlayer,V(FLENG[3]),VArr(FLENGVA,V(FLENG[7])))

	f_Mul(IncludePlayer,V(FLENG[4]),V(FLENG[1]))
	f_Mul(IncludePlayer,V(FLENG[3]),V(FLENG[1]))

	CiDiv(IncludePlayer,V(FLENG[4]),0x10000)
	CiDiv(IncludePlayer,V(FLENG[3]),0x10000)

	CIfX(IncludePlayer,CVar("X",FLENG[5],Exactly,1))
		CNeg(IncludePlayer,V(FLENG[3]))
	CIfXEnd()

	CIfX(IncludePlayer,CVar("X",FLENG[6],Exactly,1))
		CNeg(IncludePlayer,V(FLENG[4]))
	CIfXEnd()

	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc+1);
		},
		flag = {Preserved}
	}

	FLENGCall1 = FuncAlloc
	FLENGCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_Atan2 - Ret[1] : Input Y  Ret[2] = X | Ret[3] = Θ  
	for i = 0, 3 do
		CVariable(IncludePlayer,FuncAlloc+i) -- Local Variable
		table.insert(FATAN,FuncAlloc+i)
	end
	FuncAlloc = FuncAlloc + 4

	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc);
		},
		flag = {Preserved}
	}
	FATANCall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

	CIfX(IncludePlayer,CVar("X",FATAN[1],AtLeast,0x80000000)) 
		CIfX(IncludePlayer,CVar("X",FATAN[2],AtLeast,0x80000000)) -- 3사분면
			DoActionsX(IncludePlayer,{SetCVar("X",FATAN[4],SetTo,3)}) -- Θ + pi
			CNeg(IncludePlayer,V(FATAN[1]))
			CNeg(IncludePlayer,V(FATAN[2]))
		CElseX() -- 4사분면
			DoActionsX(IncludePlayer,{SetCVar("X",FATAN[4],SetTo,4)}) -- 2pi - Θ
			CNeg(IncludePlayer,V(FATAN[1]))
		CIfXEnd()
	CElseX()
		CIfX(IncludePlayer,CVar("X",FATAN[2],AtLeast,0x80000000)) -- 2사분면
			DoActionsX(IncludePlayer,{SetCVar("X",FATAN[4],SetTo,2)}) -- pi - Θ
			CNeg(IncludePlayer,V(FATAN[2]))
		CElseX() -- 1사분면
			DoActionsX(IncludePlayer,{SetCVar("X",FATAN[4],SetTo,1)}) -- Θ
		CIfXEnd()
	CIfXEnd()

	CMul(IncludePlayer,V(FATAN[1]),0x10000,"X","X",0xFFFFF)

	f_Div(IncludePlayer,V(FATAN[1]),V(FATAN[2]))

	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(0);
			CVar("X",FATAN[1],AtMost,0x10000*math.tan(math.rad(1*90/8)));
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,1);
			SetCtrigX("X",FuncAlloc+1,0x178,0,SetTo,"X","X",0x4,1,0);
			SetCtrigX("X",FuncAlloc+1,0x17C,0,SetTo,"X","X",0,0,1);
		},
		flag = {Preserved}
	}
	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(0);
			CVar("X",FATAN[1],AtMost,0x10000*math.tan(math.rad(2*90/8)));
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,math.floor(Range/8));
			SetCtrigX("X",FuncAlloc+1,0x178,0,SetTo,"X","X",0x4,1,0);
			SetCtrigX("X",FuncAlloc+1,0x17C,0,SetTo,"X","X",0,0,1);
		},
		flag = {Preserved}
	}
	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(0);
			CVar("X",FATAN[1],AtMost,0x10000*math.tan(math.rad(3*90/8)));
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,math.floor(2*Range/8));
			SetCtrigX("X",FuncAlloc+1,0x178,0,SetTo,"X","X",0x4,1,0);
			SetCtrigX("X",FuncAlloc+1,0x17C,0,SetTo,"X","X",0,0,1);
		},
		flag = {Preserved}
	}
	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(0);
			CVar("X",FATAN[1],AtMost,0x10000*math.tan(math.rad(4*90/8)));
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,math.floor(3*Range/8));
			SetCtrigX("X",FuncAlloc+1,0x178,0,SetTo,"X","X",0x4,1,0);
			SetCtrigX("X",FuncAlloc+1,0x17C,0,SetTo,"X","X",0,0,1);
		},
		flag = {Preserved}
	}
	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(0);
			CVar("X",FATAN[1],AtMost,0x10000*math.tan(math.rad(5*90/8)));
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,math.floor(4*Range/8));
			SetCtrigX("X",FuncAlloc+1,0x178,0,SetTo,"X","X",0x4,1,0);
			SetCtrigX("X",FuncAlloc+1,0x17C,0,SetTo,"X","X",0,0,1);
		},
		flag = {Preserved}
	}
	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(0);
			CVar("X",FATAN[1],AtMost,0x10000*math.tan(math.rad(6*90/8)));
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,math.floor(5*Range/8));
			SetCtrigX("X",FuncAlloc+1,0x178,0,SetTo,"X","X",0x4,1,0);
			SetCtrigX("X",FuncAlloc+1,0x17C,0,SetTo,"X","X",0,0,1);
		},
		flag = {Preserved}
	}
	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(0);
			CVar("X",FATAN[1],AtMost,0x10000*math.tan(math.rad(7*90/8)));
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,math.floor(6*Range/8));
			SetCtrigX("X",FuncAlloc+1,0x178,0,SetTo,"X","X",0x4,1,0);
			SetCtrigX("X",FuncAlloc+1,0x17C,0,SetTo,"X","X",0,0,1);
		},
		flag = {Preserved}
	}
	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(0);
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,math.floor(7*Range/8));
			SetCtrigX("X",FuncAlloc+1,0x178,0,SetTo,"X","X",0x4,1,0);
			SetCtrigX("X",FuncAlloc+1,0x17C,0,SetTo,"X","X",0,0,1);
		},
		flag = {Preserved}
	}
	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc);
		},
		flag = {Preserved}
	}
	FuncAlloc = FuncAlloc + 1
	for i = 0, Range-1 do
		Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CVar("X",FATAN[1],AtMost,0x10000*math.tan(math.rad(i*90/Range)));
			},
			actions = {
				SetCVar("X",FATAN[3],SetTo,i);
				SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,0);
				SetCtrigX("X",FuncAlloc,0x158,0,SetTo,"X","X",0x4,1,0);
				SetCtrigX("X",FuncAlloc,0x15C,0,SetTo,"X","X",0,0,1);
			},
			flag = {Preserved}
		}
	end
		Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCVar("X",FATAN[3],SetTo,Range);
				SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,0);
				SetCtrigX("X",FuncAlloc,0x158,0,SetTo,"X","X",0x4,1,0);
				SetCtrigX("X",FuncAlloc,0x15C,0,SetTo,"X","X",0,0,1);
			},
			flag = {Preserved}
		}

	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			SetDeaths(0,SetTo,0,0);
		},
		flag = {Preserved}
	}
	FuncAlloc = FuncAlloc + 1

	CIfX(IncludePlayer,CVar("X",FATAN[4],Exactly,2))
		CMov(IncludePlayer,V(FATAN[3]),_Sub(_Mov(Range*2),V(FATAN[3])))
	CElseIfX(CVar("X",FATAN[4],Exactly,3))
		CAdd(IncludePlayer,V(FATAN[3]),Range*2)
	CElseIfX(CVar("X",FATAN[4],Exactly,4))
		CMov(IncludePlayer,V(FATAN[3]),_Sub(_Mov(Range*4),V(FATAN[3])))
	CIfXEnd()

	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc);
		},
		flag = {Preserved}
	}

	FATANCall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

	-- f_Log2 - Ret[1] : Input Value / Ret[2] = Output | Ret = log2(X) 

	CVariable(IncludePlayer,FuncAlloc) -- Local Variable
	CVariable(IncludePlayer,FuncAlloc+1)
	FLOG2 = {FuncAlloc,FuncAlloc+1}
	FuncAlloc = FuncAlloc + 2

	Trigger {
		players = {IncludePlayer},
		conditions = { -- Init Calc
			Label(FuncAlloc);
			CtrigX("X",FLOG2[1],0x15C,0,Exactly,0);
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+1,0,0,0); -- Skip Calc
			SetCtrigX("X",FuncAlloc+1,0x158,0,SetTo,"X","X",0x4,1,0); -- RecoverNext
			SetCtrigX("X",FuncAlloc+1,0x15C,0,SetTo,"X","X",0,0,1);
			SetCtrig1X("X",FLOG2[2],0x15C,0,SetTo,0x80000000);
		},
		flag = {Preserved}
	}

	Trigger {
		players = {IncludePlayer},
		conditions = {
			Label(0);
			CtrigX("X",FLOG2[1],0x15C,0,Exactly,1);
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+1,0,0,0); -- Skip Calc
			SetCtrigX("X",FuncAlloc+1,0x158,0,SetTo,"X","X",0x4,1,0); -- RecoverNext
			SetCtrigX("X",FuncAlloc+1,0x15C,0,SetTo,"X","X",0,0,1);
			SetCtrig1X("X",FLOG2[2],0x15C,0,SetTo,0);
		},
		flag = {Preserved}
	}

	for i = 2, 31 do
		Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CtrigX("X",FLOG2[1],0x15C,0,AtMost,2^i-1);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+1,0,0,0); -- Skip Calc
				SetCtrigX("X",FuncAlloc+1,0x158,0,SetTo,"X","X",0x4,1,0); -- RecoverNext
				SetCtrigX("X",FuncAlloc+1,0x15C,0,SetTo,"X","X",0,0,1);
				SetCtrig1X("X",FLOG2[2],0x15C,0,SetTo,i-1);
			},
			flag = {Preserved}
		}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FLOG2[2],0x15C,0,SetTo,31);
			},
			flag = {Preserved}
		}

	Trigger {
		players = {IncludePlayer},
		conditions = { -- End Calc
			Label(FuncAlloc+1);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
		},
		flag = {Preserved}
	}
	FLOG2Call1 = FuncAlloc
	FLOG2Call2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2
end

FRAND = 0
FRANDCall1 = 0
FRANDCall2 = 0
FPSTR = {}
FPSTRCall0 = 0
FPSTRCall1 = 0
FPSTRCall2 = 0
FPSTRX = {}
FPSTRXCall1 = 0
FPSTRXCall2 = 0
FPTBL = {}
FPTBLCall0 = 0
FPTBLCall1 = 0
FPTBLCall2 = 0

function Include_MiscFunctions(SeedSwitch,PlayerID) -- f_Rand 
-- f_Rand - Ret[1] : Output  
	local IncludePlayer
	if PlayerID == nil then
		IncludePlayer = AllPlayers
	else
		IncludePlayer = ParsePlayer(PlayerID)
	end
	if SeedSwitch == "X" or nil then
		Need_SeedSwitch_Error()
	end

	CVariable(IncludePlayer,FuncAlloc)
	FRAND = FuncAlloc
	FuncAlloc = FuncAlloc + 1

	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetSwitch(SeedSwitch,Random);
				SetCVar("X",FRAND,SetTo,0);
			},
			flag = {Preserved}
		}
	for i = 31, 0, -1 do
		Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(0);
				Switch(SeedSwitch,Set);
			},
			actions = {
				SetCVar("X",FRAND,Add,2^i);
			},
			flag = {Preserved}
		}
		if i ~= 0 then
			Trigger { 
				players = {IncludePlayer},
				actions = {
					SetSwitch(SeedSwitch,Random);
				},
				flag = {Preserved}
			}
		end
	end
	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			flag = {Preserved}
		}

	FRANDCall1 = FuncAlloc
	FRANDCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_GetStrptr - Ret[1] : StringId  Ret[2] = Type | Ret[3] = Strptr  
	for i = 0, 2 do
		CVariable(IncludePlayer,FuncAlloc+i) -- Local Variable
		table.insert(FPSTR,FuncAlloc+i)
	end
	FuncAlloc = FuncAlloc + 3

	Trigger {
				players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc+2);
					},
					actions = {
						SetCtrig1X("X",FPSTR[1],0x15C,0,SetTo,0);
					},
					flag = {Preserved}
				}

	for i = 0, 14 do
		local CBit = 2^i
			Trigger {
					players = {IncludePlayer},
						conditions = {
							Label(0);
						   	CtrigX("X",FPSTR[2],0x15C,0,AtLeast,CBit*2);
						},
						actions = {
							SetCtrig1X("X",FPSTR[2],0x15C,0,Subtract,CBit*2);
							SetCtrig1X("X",FPSTR[1],0x15C,0,Add,CBit);
						},
						flag = {Preserved}
					}
	end

	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCVar("X",FPSTR[3],SetTo,0x191943C8);
				SetMemory(0x6509B0,SetTo,EPD(0x191943C8));
				SetCtrig1X("X",FPSTR[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",FPSTR[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",FPSTR[1],0x160,0,SetTo,Add*16777216,0xFF000000);
				CallLabelAlways("X",FPSTR[1],0);
			},
			flag = {Preserved}
		}

	CIfX(IncludePlayer,CVar("X",FPSTR[2],Exactly,0)) -- 0x0000FFFF
		for i = 0, 15 do
			local CBit = 2^i
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FPSTR[3],0x15C,0,Add,CBit);
					},
					flag = {Preserved}
				}
		end
	CElseX()
		for i = 16, 31 do
			local CBit = 2^i
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FPSTR[3],0x15C,0,Add,CBit/65536);
					},
					flag = {Preserved}
				}
		end
	CIfXEnd()

	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			flag = {Preserved}
		}

	FPSTRCall1 = FuncAlloc
	FPSTRCall2 = FuncAlloc+1
	FPSTRCall0 = FuncAlloc+2
	FuncAlloc = FuncAlloc + 3
-- f_GetStrXptr - Ret[1] : StringId | Ret[2] = Strptr  
	for i = 0, 1 do
		CVariable(IncludePlayer,FuncAlloc+i) -- Local Variable
		table.insert(FPSTRX,FuncAlloc+i)
	end
	FuncAlloc = FuncAlloc + 2

	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCVar("X",FPSTRX[2],SetTo,0x191943C8);
				SetMemory(0x6509B0,SetTo,EPD(0x191943C8));
				SetCtrig1X("X",FPSTRX[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",FPSTRX[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",FPSTRX[1],0x160,0,SetTo,Add*16777216,0xFF000000);
				CallLabelAlways("X",FPSTRX[1],0);
			},
			flag = {Preserved}
		}

	for i = 0, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",FPSTRX[2],0x15C,0,Add,CBit);
				},
				flag = {Preserved}
			}
	end

	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			flag = {Preserved}
		}

	FPSTRXCall1 = FuncAlloc
	FPSTRXCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2
-- f_GetTblptr - Ret[1] : Tbl Index  Ret[2] = Type | Ret[3] = Tblptr  
	for i = 0, 2 do
		CVariable(IncludePlayer,FuncAlloc+i) -- Local Variable
		table.insert(FPTBL,FuncAlloc+i)
	end
	FuncAlloc = FuncAlloc + 3

	Trigger {
				players = {IncludePlayer},
					conditions = {
						Label(FuncAlloc+2);
					},
					actions = {
						SetCtrig1X("X",FPTBL[1],0x15C,0,SetTo,0);
					},
					flag = {Preserved}
				}

	for i = 0, 14 do
		local CBit = 2^i
			Trigger {
					players = {IncludePlayer},
						conditions = {
							Label(0);
						   	CtrigX("X",FPTBL[2],0x15C,0,AtLeast,CBit*2);
						},
						actions = {
							SetCtrig1X("X",FPTBL[2],0x15C,0,Subtract,CBit*2);
							SetCtrig1X("X",FPTBL[1],0x15C,0,Add,CBit);
						},
						flag = {Preserved}
					}
	end

	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCVar("X",FPTBL[3],SetTo,0x19184660);
				SetMemory(0x6509B0,SetTo,EPD(0x19184660));
				SetCtrig1X("X",FPTBL[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",FPTBL[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",FPTBL[1],0x160,0,SetTo,Add*16777216,0xFF000000);
				CallLabelAlways("X",FPTBL[1],0);
			},
			flag = {Preserved}
		}

	CIfX(IncludePlayer,CVar("X",FPTBL[2],Exactly,0)) -- 0x0000FFFF
		for i = 0, 15 do
			local CBit = 2^i
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FPTBL[3],0x15C,0,Add,CBit);
					},
					flag = {Preserved}
				}
		end
	CElseX()
		for i = 16, 31 do
			local CBit = 2^i
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FPTBL[3],0x15C,0,Add,CBit/65536);
					},
					flag = {Preserved}
				}
		end
	CIfXEnd()

	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			flag = {Preserved}
		}

	FPTBLCall1 = FuncAlloc
	FPTBLCall2 = FuncAlloc+1
	FPTBLCall0 = FuncAlloc+2
	FuncAlloc = FuncAlloc + 3
end

-- 함수 호출형 최종 연산 함수 (f_) ------------------------------------------------------

function f_Movcpy(PlayerID,Dest,SourceVA,Size,Distance) -- VA index = 상수 (CPRead)
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << Dest / CRet[2] << VAOffset / CRet[3] << Size (Offset)

	if type(Dest) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMOVE[1],0x15C,0,SetTo,Dest);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then
		local TempRet = {"X",FMOVE[1],0,"V"}
		MovX(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "A" then
		local TempRet = {"X",FMOVE[1],0,"V"}
		TMem(PlayerID,TempRet,Dest,nil,nil,1)
		Dest = TempRet
	elseif Dest[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FMOVE[1],0x15C,1,0);
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Dest[1],Dest[2],Dest[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMOVE[1],0x15C,0,SetTo,Dest[1],Dest[2],Dest[3],0,Dest[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMOVE[3],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FMOVE[3],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FMOVE[3],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if SourceVA[4] == "V" then -- ※ MovX는 CPRead방식으로 Cp값 변경하므로 Cp값 자체를 전달하는 SourceVA인자는 맨 밑에 있어야함
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig2X(0x6509B0,SetTo,SourceVA[1],SourceVA[2],0,1,SourceVA[3]); -- VArray Header +0x0
				SetCtrigX("X",FMOVE[2],0x15C,0,SetTo,SourceVA[1],SourceVA[2],0,0,SourceVA[3]);
			},
			flag = {Preserved}
		}
	elseif SourceVA[4] == "VA" then
		local TempRet = {"X",FMOVE[2],0,"V"}
		TMem(PlayerID,TempRet,SourceVA,0,0,1)
		Trigger {--(CPRead)로 값 출력
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0x6509B0,SetTo,SourceVA[5][1],SourceVA[5][2],0,1,SourceVA[5][3]); 
					SetMemory(0x6509B0,Add,SourceVA[6]);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x148,SourceVA[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x160,SourceVA[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x158,SourceVA[3],SetTo,EPD(0x6509B0)); 
					CallLabelAlways(SourceVA[1],SourceVA[2],SourceVA[3]);
				},
				flag = {Preserved}
		}
	end

	if Distance == nil then
		Distance = 1
	end
	-- Call f_Movcpy
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FMOVECall0,0x0,0,0);
					SetCtrigX("X",FMOVECall2,0x4,0,SetTo,"X","X",0x0,0,1);
					SetCtrig1X("X",FMOVEArr[1][1],FMOVEArr[1][2],0,SetTo,Distance);
					SetCtrig1X("X",FMOVEArr[2][1],FMOVEArr[2][2],0,SetTo,Distance);
				},
				flag = {Preserved}
			}
	if FMOVECall1 == 0 then
		Need_Include_DataTransfer()
	end

	RecoverCp(PlayerID)
end

function f_MovcpyEPD(PlayerID,Dest,SourceVA,Size,InitBytes,Distance) -- VA index = 상수 (CPRead)
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << Dest / CRet[2] << VAOffset / CRet[3] << Size (EPD)

	local InitMask
	if InitBytes == "X" or InitBytes == nil then
		InitBytes = 0
	end
	if InitBytes == 0 then 
		InitMask = 0xFFFFFFFF
	elseif InitBytes == 1 then
		InitMask = 0xFFFFFF00
	elseif InitBytes == 2 then
		InitMask = 0xFFFF0000
	elseif InitBytes == 3 then
		InitMask = 0xFF000000
	else
		f_MovcpyEPD_InputData_Error()
	end

	if type(Dest) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMOVE[1],0x15C,0,SetTo,Dest);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then
		local TempRet = {"X",FMOVE[1],0,"V"}
		MovX(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "A" then
		local TempRet = {"X",FMOVE[1],0,"V"}
		MovZ(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FMOVE[1],0x15C,1,0);
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Dest[1],Dest[2],Dest[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMOVE[1],0x15C,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMOVE[3],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FMOVE[3],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FMOVE[3],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if SourceVA[4] == "V" then -- ※ MovX는 CPRead방식으로 Cp값 변경하므로 Cp값 자체를 전달하는 SourceVA인자는 맨 밑에 있어야함
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig2X(0x6509B0,SetTo,SourceVA[1],SourceVA[2],0,1,SourceVA[3]); -- VArray Header +0x0
				SetCtrigX("X",FMOVE[2],0x15C,0,SetTo,SourceVA[1],SourceVA[2],0,0,SourceVA[3]);
				SetCtrig1X("X",FMOVE[4],0x15C,0,SetTo,InitMask);
			},
			flag = {Preserved}
		}
	elseif SourceVA[4] == "VA" then
		local TempRet = {"X",FMOVE[2],0,"V"}
		TMem(PlayerID,TempRet,SourceVA,0,0,1)
		Trigger {--(CPRead)로 값 출력
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[4],0x15C,0,SetTo,InitMask);
					SetCtrig2X(0x6509B0,SetTo,SourceVA[5][1],SourceVA[5][2],0,1,SourceVA[5][3]); 
					SetMemory(0x6509B0,Add,SourceVA[6]);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x148,SourceVA[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x160,SourceVA[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x158,SourceVA[3],SetTo,EPD(0x6509B0)); 
					CallLabelAlways(SourceVA[1],SourceVA[2],SourceVA[3]);
				},
				flag = {Preserved}
		}
	end

	if Distance == nil then
		Distance = 1
	end
	-- Call f_MovcpyEPD
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FMOVECall1,0x0,0,0);
					SetCtrigX("X",FMOVECall2,0x4,0,SetTo,"X","X",0x0,0,1);
					SetCtrig1X("X",FMOVEArr[1][1],FMOVEArr[1][2],0,SetTo,Distance);
					SetCtrig1X("X",FMOVEArr[2][1],FMOVEArr[2][2],0,SetTo,Distance);
				},
				flag = {Preserved}
			}
	if FMOVECall1 == 0 then
		Need_Include_DataTransfer()
	end

	RecoverCp(PlayerID)
end

function f_ReadcpyEPD(PlayerID,DestVA,Source,Size,Distance)
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << DestVA / CRet[2] << Source / CRet[3] << Size (EPD)
		
	if DestVA[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEME[1],0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]);
			},
			flag = {Preserved}
		}
	elseif DestVA[4] == "VA" then
		local TempRet = {"X",FMEME[1],0,"V"}
		MovZ(PlayerID,TempRet,DestVA,0x15C)
		DestVA = TempRet
	end

	if type(Source) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEME[2],0x15C,0,SetTo,Source);
			},
			flag = {Preserved}
		}
	elseif Source[4] == "VA" then
		local TempRet = {"X",FMEME[2],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "A" then
		local TempRet = {"X",FMEME[2],0,"V"}
		MovZ(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FMEME[2],0x15C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEME[2],0x15C,0,SetTo,Source[1],Source[2],Source[3],1,Source[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEME[3],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FMEME[3],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FMEME[3],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if Distance == nil then
		Distance = 1
	end
	-- Call f_MemcpyEPD
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FMEMECall1,0x0,0,0);
					SetCtrigX("X",FMEMECall2,0x4,0,SetTo,"X","X",0x0,0,1);
					SetCtrig1X("X",FMEMEArr[1][1],FMEMEArr[1][2],0,SetTo,Distance);
					SetCtrig1X("X",FMEMEArr[2][1],FMEMEArr[2][2],0,SetTo,604);
				},
				flag = {Preserved}
			}
	if FMEMECall1 == 0 then
		Need_Include_DataTransfer()
	end
end

function f_MemcpyEPD(PlayerID,Dest,Source,Size,DestDistance,SourceDistance) 
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << Dest / CRet[2] << Source / CRet[3] << Size (EPD)
	if type(Dest) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEME[1],0x15C,0,SetTo,Dest);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then
		local TempRet = {"X",FMEME[1],0,"V"}
		MovX(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "A" then
		local TempRet = {"X",FMEME[1],0,"V"}
		MovZ(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FMEME[1],0x15C,1,0);
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Dest[1],Dest[2],Dest[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEME[1],0x15C,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Source) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEME[2],0x15C,0,SetTo,Source);
			},
			flag = {Preserved}
		}
	elseif Source[4] == "VA" then
		local TempRet = {"X",FMEME[2],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "A" then
		local TempRet = {"X",FMEME[2],0,"V"}
		MovZ(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FMEME[2],0x15C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEME[2],0x15C,0,SetTo,Source[1],Source[2],Source[3],1,Source[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEME[3],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FMEME[3],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FMEME[3],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if DestDistance == nil then
		DestDistance = 1
	end
	if SourceDistance == nil then
		SourceDistance = 1
	end
	-- Call f_MemcpyEPD
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FMEMECall1,0x0,0,0);
					SetCtrigX("X",FMEMECall2,0x4,0,SetTo,"X","X",0x0,0,1);
					SetCtrig1X("X",FMEMEArr[1][1],FMEMEArr[1][2],0,SetTo,SourceDistance);
					SetCtrig1X("X",FMEMEArr[2][1],FMEMEArr[2][2],0,SetTo,DestDistance);
				},
				flag = {Preserved}
			}
	if FMEMECall1 == 0 then
		Need_Include_DataTransfer()
	end
end
--[[
function CbyteConvert(PlayerID,DestVA,Source) 
	STPopTrigArr(PlayerID)

	if DestVA[4] == "V" then
		local Temp = {}
		for k, v in pairs(Source) do
			table.insert(Temp,SetCtrig1X(DestVA[1],DestVA[2],0x15C,DestVA[3]+k-1,SetTo,v*0x01010101))
		end
		DoActions2X(PlayerID,Temp)
	elseif DestVA[4] == "VA" then
		local k = 1
		local Size = #Source

		while k <= Size do
			if Size - k + 1 >= 63 then
				local X = {}
				for i = 0, 62 do
					table.insert(X,TSetMemory(Vi(DestVA[2],{DestVA[5][1],DestVA[5][2],0x15C,DestVA[5][3]+k-1},DestVA[1],DestVA[3]),SetTo,Source[k]*0x01010101))
					k = k + 1
				end
				CDoActions(PlayerID,X)
			else
				local X = {}
				repeat
					table.insert(X,TSetMemory(Vi(DestVA[2],{DestVA[5][1],DestVA[5][2],0x15C,DestVA[5][3]+k-1},DestVA[1],DestVA[3]),SetTo,Source[k]*0x01010101))
					k = k + 1
				until k == Size + 1
				CDoActions(PlayerID,X)
			end
		end
	end
end
]]--
function CbyteConvert(PlayerID,DestVA,Source) 
	STPopTrigArr(PlayerID)

	if DestVA[4] == "V" then
		local Size = #Source
		local Temp = {{},{0},{0},{0}}
		local R
		for i = 1, Size do
			local t = (i-1)%4
			local u = math.floor((i-1)/4)+1
			local v = u+1
			if t == 0 then
				table.insert(Temp[1],0)
				Temp[1][u] = Temp[1][u] + Source[i]
				Temp[2][u] = Temp[2][u] + Source[i]*256
				Temp[3][u] = Temp[3][u] + Source[i]*65536
				Temp[4][u] = Temp[4][u] + Source[i]*16777216
			elseif t == 1 then
				if Temp[1][u] == nil then
					PushValueMsg(i)
				end
				table.insert(Temp[4],0)
				Temp[1][u] = Temp[1][u] + Source[i]*256
				Temp[2][u] = Temp[2][u] + Source[i]*65536
				Temp[3][u] = Temp[3][u] + Source[i]*16777216
				Temp[4][v] = Temp[4][v] + Source[i]
			elseif t == 2 then
				table.insert(Temp[3],0)
				Temp[1][u] = Temp[1][u] + Source[i]*65536
				Temp[2][u] = Temp[2][u] + Source[i]*16777216
				Temp[3][v] = Temp[3][v] + Source[i]
				Temp[4][v] = Temp[4][v] + Source[i]*256
			elseif t == 3 then
				table.insert(Temp[2],0)
				Temp[1][u] = Temp[1][u] + Source[i]*16777216
				Temp[2][v] = Temp[2][v] + Source[i]
				Temp[3][v] = Temp[3][v] + Source[i]*256
				Temp[4][v] = Temp[4][v] + Source[i]*65536
			end
			R = t
		end
		if R == 1 then
			table.insert(Temp[1],0)
			table.insert(Temp[2],0)
			table.insert(Temp[3],0)
		elseif R == 2 then
			table.insert(Temp[1],0)
			table.insert(Temp[2],0)
		elseif R == 3 then
			table.insert(Temp[1],0)
		end
		local n = #Temp[1]

		local X = {}
		for j = 1, n do
			for i = 1, 4 do
				table.insert(X,SetCtrig1X(DestVA[1],DestVA[2],0x15C,DestVA[3]+(j-1)*4+(i-1),SetTo,Temp[i][j]))
			end
		end

		DoActions2X(PlayerID,X)
	elseif DestVA[4] == "VA" then
		local Size = #Source
		local Temp = {{},{0},{0},{0}}
		local R
		for i = 1, Size do
			local t = (i-1)%4
			local u = math.floor((i-1)/4)+1
			local v = u+1
			if t == 0 then
				table.insert(Temp[1],0)
				Temp[1][u] = Temp[1][u] + Source[i]
				Temp[2][u] = Temp[2][u] + Source[i]*256
				Temp[3][u] = Temp[3][u] + Source[i]*65536
				Temp[4][u] = Temp[4][u] + Source[i]*16777216
			elseif t == 1 then
				table.insert(Temp[4],0)
				Temp[1][u] = Temp[1][u] + Source[i]*256
				Temp[2][u] = Temp[2][u] + Source[i]*65536
				Temp[3][u] = Temp[3][u] + Source[i]*16777216
				Temp[4][v] = Temp[4][v] + Source[i]
			elseif t == 2 then
				table.insert(Temp[3],0)
				Temp[1][u] = Temp[1][u] + Source[i]*65536
				Temp[2][u] = Temp[2][u] + Source[i]*16777216
				Temp[3][v] = Temp[3][v] + Source[i]
				Temp[4][v] = Temp[4][v] + Source[i]*256
			elseif t == 3 then
				table.insert(Temp[2],0)
				Temp[1][u] = Temp[1][u] + Source[i]*16777216
				Temp[2][v] = Temp[2][v] + Source[i]
				Temp[3][v] = Temp[3][v] + Source[i]*256
				Temp[4][v] = Temp[4][v] + Source[i]*65536
			end
			R = t
		end
		if R == 1 then
			table.insert(Temp[1],0)
			table.insert(Temp[2],0)
			table.insert(Temp[3],0)
		elseif R == 2 then
			table.insert(Temp[1],0)
			table.insert(Temp[2],0)
		elseif R == 3 then
			table.insert(Temp[1],0)
		end
		local n = #Temp[1]

		local k = 1
		local Size = #Temp[1]*4
		while k <= Size do
			if Size - k + 1 >= 60 then
				local X = {}
				for j = 0, 14 do
					for i = 1, 4 do
						local l = math.floor((k-1)/4+1)
						table.insert(X,TSetMemory(Vi(DestVA[2],{DestVA[5][1],DestVA[5][2],0x15C,DestVA[5][3]+4*(l-1)+(i-1)},DestVA[1],DestVA[3]),SetTo,Temp[i][l]))
						k = k + 1
					end
				end
				CDoActions(PlayerID,X)
			else
				local X = {}
				repeat
					for i = 1, 4 do
						local l = math.floor((k-1)/4+1)
						table.insert(X,TSetMemory(Vi(DestVA[2],{DestVA[5][1],DestVA[5][2],0x15C,DestVA[5][3]+4*(l-1)+(i-1)},DestVA[1],DestVA[3]),SetTo,Temp[i][l]))
						k = k + 1
					end
				until k == Size + 1
				CDoActions(PlayerID,X)
			end
		end
	end
end

function f_byteConvert(PlayerID,DestVA,Source,Size,Distance) -- 1 -> 4
	-- DestVA << VArray / Source <<  Offset / Size << Offset / Distance
	STPopTrigArr(PlayerID)

	if DestVA[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FCONV[1],0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]);
				SetCtrigX("X",FCONV[2],0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]+1);
				SetCtrigX("X",FCONV[3],0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]+2);
				SetCtrigX("X",FCONV[4],0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]+3);
			},
			flag = {Preserved}
		}
	elseif DestVA[4] == "VA" then
		MovZ(PlayerID,{"X",FCONV[1],0,"V"},DestVA,0x15C)
		MovZ(PlayerID,{"X",FCONV[2],0,"V"},DestVA,0x15C)
		MovZ(PlayerID,{"X",FCONV[3],0,"V"},DestVA,0x15C)
		MovZ(PlayerID,{"X",FCONV[4],0,"V"},DestVA,0x15C)
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCONV[2],0x15C,0,Add,0x970/4);
				SetCtrig1X("X",FCONV[3],0x15C,0,Add,0x970/2);
				SetCtrig1X("X",FCONV[4],0x15C,0,Add,3*0x970/4);
			},
			flag = {Preserved}
		}
	end

	if type(Source) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCONV[5],0x15C,0,SetTo,Source);
			},
			flag = {Preserved}
		}
	elseif Source[4] == "VA" then
		local TempRet = {"X",FCONV[5],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FCONV[5],0x15C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FCONV[5],0x15C,0,SetTo,Source[1],Source[2],Source[3],0,Source[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCONV[6],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FCONV[6],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FCONV[6],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if Distance == nil then
		Distance = 1
	end
	-- Call f_ByteConvert
	local Temp = {}
	for k, v in pairs(FCONVArr) do
		table.insert(Temp,SetCtrig1X("X",v[1],v[2],0,SetTo,Distance))
	end
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVCall0,0x0,0,0);
					SetCtrigX("X",FCONVCall2,0x4,0,SetTo,"X","X",0x0,0,1);
					Temp,
				},
				flag = {Preserved}
			}
	if FCONVCall1 == 0 then
		Need_Include_DataTransfer()
	end

	RecoverCp(PlayerID)
end

function f_byteConvertX(PlayerID,DestVA,Source,SourceX,Size,Distance)
	-- DestVA << VArray / Source << epd, SourceX << D / Size << Offset / Distance
	STPopTrigArr(PlayerID)

	if DestVA[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FCONV[1],0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]);
				SetCtrigX("X",FCONV[2],0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]+1);
				SetCtrigX("X",FCONV[3],0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]+2);
				SetCtrigX("X",FCONV[4],0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]+3);
			},
			flag = {Preserved}
		}
	elseif DestVA[4] == "VA" then
		MovZ(PlayerID,{"X",FCONV[1],0,"V"},DestVA,0x15C)
		MovZ(PlayerID,{"X",FCONV[2],0,"V"},DestVA,0x15C)
		MovZ(PlayerID,{"X",FCONV[3],0,"V"},DestVA,0x15C)
		MovZ(PlayerID,{"X",FCONV[4],0,"V"},DestVA,0x15C)
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCONV[2],0x15C,0,Add,0x970/4);
				SetCtrig1X("X",FCONV[3],0x15C,0,Add,0x970/2);
				SetCtrig1X("X",FCONV[4],0x15C,0,Add,3*0x970/4);
			},
			flag = {Preserved}
		}
	end

	if type(Source) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCONV[5],0x15C,0,SetTo,Source);
			},
			flag = {Preserved}
		}
	elseif Source[4] == "VA" then
		local TempRet = {"X",FCONV[5],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FCONV[5],0x15C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FCONV[5],0x15C,0,SetTo,Source[1],Source[2],Source[3],0,Source[4]);
			},
			flag = {Preserved}
		}
	end

	if type(SourceX) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCONV[7],0x15C,0,SetTo,SourceX);
			},
			flag = {Preserved}
		}
	elseif SourceX[4] == "VA" then
		local TempRet = {"X",FCONV[7],0,"V"}
		MovX(PlayerID,TempRet,SourceX)
		SourceX = TempRet
	elseif SourceX[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(SourceX[1],SourceX[2],0x158,SourceX[3],SetTo,"X",FCONV[7],0x15C,1,0);
				SetCtrig1X(SourceX[1],SourceX[2],0x148,SourceX[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(SourceX[1],SourceX[2],0x160,SourceX[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(SourceX[1],SourceX[2],SourceX[3]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCONV[6],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FCONV[6],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FCONV[6],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if Distance == nil then
		Distance = 1
	end
	-- Call f_ByteConvert
	local Temp = {}
	for k, v in pairs(FCONVArr) do
		table.insert(Temp,SetCtrig1X("X",v[1],v[2],0,SetTo,Distance))
	end
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVCall1,0x0,0,0);
					SetCtrigX("X",FCONVCall2,0x4,0,SetTo,"X","X",0x0,0,1);
					Temp,
				},
				flag = {Preserved}
			}
	if FCONVCall1 == 0 then
		Need_Include_DataTransfer()
	end

	RecoverCp(PlayerID)
end

function f_bytecpy(PlayerID,Dest,SourceVA,Size,Distance) 
	-- SourceVA << VArray / Dest <<  Offset / Size << Offset / Distance
	STPopTrigArr(PlayerID)

	if SourceVA[4] == "V" then -- ※ MovX는 CPRead방식으로 Cp값 변경하므로 Cp값 자체를 전달하는 SourceVA인자는 맨 밑에 있어야함
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig2X(0x6509B0,SetTo,SourceVA[1],SourceVA[2],0,1,SourceVA[3]); -- VArray Header +0x0
				SetCtrigX("X",FBYTE[1],0x15C,0,SetTo,SourceVA[1],SourceVA[2],0,0,SourceVA[3]);
			},
			flag = {Preserved}
		}
	elseif SourceVA[4] == "VA" then
		local TempRet = {"X",FBYTE[1],0,"V"}
		TMem(PlayerID,TempRet,SourceVA,0,0,1)
		Trigger {--(CPRead)로 값 출력
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0x6509B0,SetTo,SourceVA[5][1],SourceVA[5][2],0,1,SourceVA[5][3]); 
					SetMemory(0x6509B0,Add,SourceVA[6]);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x148,SourceVA[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x160,SourceVA[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x158,SourceVA[3],SetTo,EPD(0x6509B0)); 
					CallLabelAlways(SourceVA[1],SourceVA[2],SourceVA[3]);
				},
				flag = {Preserved}
		}
	end


	if type(Dest) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FBYTE[2],0x15C,0,SetTo,Dest);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then
		local TempRet = {"X",FBYTE[2],0,"V"}
		MovX(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FBYTE[2],0x15C,1,0);
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Dest[1],Dest[2],Dest[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FBYTE[2],0x15C,0,SetTo,Dest[1],Dest[2],Dest[3],0,Dest[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FBYTE[3],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FBYTE[3],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FBYTE[3],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if Distance == nil then
		Distance = 1
	end
	-- Call f_Bytecpy
	local Temp = {}
	for k, v in pairs(FBYTEArr) do
		table.insert(Temp,SetCtrig1X("X",v[1],v[2],0,SetTo,Distance))
	end
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FBYTECall0,0x0,0,0);
					SetCtrigX("X",FBYTECall2,0x4,0,SetTo,"X","X",0x0,0,1);
					Temp,
				},
				flag = {Preserved}
			}
	if FBYTECall1 == 0 then
		Need_Include_DataTransfer()
	end

	RecoverCp(PlayerID)
end

function f_bytecpyX(PlayerID,Dest,DestX,SourceVA,Size,Distance)
	STPopTrigArr(PlayerID)

	if SourceVA[4] == "V" then -- ※ MovX는 CPRead방식으로 Cp값 변경하므로 Cp값 자체를 전달하는 SourceVA인자는 맨 밑에 있어야함
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig2X(0x6509B0,SetTo,SourceVA[1],SourceVA[2],0,1,SourceVA[3]); -- VArray Header +0x0
				SetCtrigX("X",FBYTE[1],0x15C,0,SetTo,SourceVA[1],SourceVA[2],0,0,SourceVA[3]);
			},
			flag = {Preserved}
		}
	elseif SourceVA[4] == "VA" then
		local TempRet = {"X",FBYTE[1],0,"V"}
		TMem(PlayerID,TempRet,SourceVA,0,0,1)
		Trigger {--(CPRead)로 값 출력
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0x6509B0,SetTo,SourceVA[5][1],SourceVA[5][2],0,1,SourceVA[5][3]); 
					SetMemory(0x6509B0,Add,SourceVA[6]);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x148,SourceVA[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x160,SourceVA[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x158,SourceVA[3],SetTo,EPD(0x6509B0)); 
					CallLabelAlways(SourceVA[1],SourceVA[2],SourceVA[3]);
				},
				flag = {Preserved}
		}
	end

	if type(Dest) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FBYTE[2],0x15C,0,SetTo,Dest);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then
		local TempRet = {"X",FBYTE[2],0,"V"}
		MovX(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FBYTE[2],0x15C,1,0);
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Dest[1],Dest[2],Dest[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FBYTE[2],0x15C,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
			},
			flag = {Preserved}
		}
	end

	if type(DestX) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FBYTE[4],0x15C,0,SetTo,DestX);
			},
			flag = {Preserved}
		}
	elseif DestX[4] == "VA" then
		local TempRet = {"X",FBYTE[4],0,"V"}
		MovX(PlayerID,TempRet,DestX)
		DestX = TempRet
	elseif DestX[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(DestX[1],DestX[2],0x158,DestX[3],SetTo,"X",FBYTE[4],0x15C,1,0);
				SetCtrig1X(DestX[1],DestX[2],0x148,DestX[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(DestX[1],DestX[2],0x160,DestX[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(DestX[1],DestX[2],DestX[3]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FBYTE[3],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FBYTE[3],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FBYTE[3],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if Distance == nil then
		Distance = 1
	end
	-- Call f_Bytecpy
	local Temp = {}
	for k, v in pairs(FBYTEArr) do
		table.insert(Temp,SetCtrig1X("X",v[1],v[2],0,SetTo,Distance))
	end
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FBYTECall1,0x0,0,0);
					SetCtrigX("X",FBYTECall2,0x4,0,SetTo,"X","X",0x0,0,1);
					Temp,
				},
				flag = {Preserved}
			}
	if FBYTECall1 == 0 then
		Need_Include_DataTransfer()
	end

	RecoverCp(PlayerID)
end

function f_bytecmp(PlayerID,CFlag,Dest,SourceVA,Size,Distance)
	-- SourceVA << VArray / Dest <<  Offset / Size << Offset / Distance
	STPopTrigArr(PlayerID)

	if SourceVA[4] == "V" then -- ※ MovX는 CPRead방식으로 Cp값 변경하므로 Cp값 자체를 전달하는 SourceVA인자는 맨 밑에 있어야함
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig2X(0x6509B0,SetTo,SourceVA[1],SourceVA[2],0,1,SourceVA[3]); -- VArray Header +0x0
				SetCtrigX("X",FCOND[1],0x15C,0,SetTo,SourceVA[1],SourceVA[2],0,0,SourceVA[3]);
			},
			flag = {Preserved}
		}
	elseif SourceVA[4] == "VA" then
		local TempRet = {"X",FCOND[1],0,"V"}
		TMem(PlayerID,TempRet,SourceVA,0,0,1)
		Trigger {--(CPRead)로 값 출력
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0x6509B0,SetTo,SourceVA[5][1],SourceVA[5][2],0,1,SourceVA[5][3]); 
					SetMemory(0x6509B0,Add,SourceVA[6]);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x148,SourceVA[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x160,SourceVA[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x158,SourceVA[3],SetTo,EPD(0x6509B0)); 
					CallLabelAlways(SourceVA[1],SourceVA[2],SourceVA[3]);
				},
				flag = {Preserved}
		}
	end


	if type(Dest) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCOND[2],0x15C,0,SetTo,Dest);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then
		local TempRet = {"X",FCOND[2],0,"V"}
		MovX(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FCOND[2],0x15C,1,0);
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Dest[1],Dest[2],Dest[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FCOND[2],0x15C,0,SetTo,Dest[1],Dest[2],Dest[3],0,Dest[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCOND[3],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FCOND[3],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FCOND[3],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	local Clear = {}
	if type(CFlag) == "table" then
		CFlag = CFlag[1]
	else
		table.insert(Clear,SetCDeaths("X",SetTo,0,CFlag))
	end

	if Distance == nil then
		Distance = 1
	end
	-- Call f_Bytecmp
	local Temp = {}
	for k, v in pairs(FCONDArr) do
		table.insert(Temp,SetCtrig1X("X",v[1],v[2],0,SetTo,Distance))
	end
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					Clear,					
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCONDCall0,0x0,0,0);
					SetCtrigX("X",FCONDCall2,0x4,0,SetTo,"X","X",0x0,0,1); -- True
					SetCtrigX("X",FCONDCall3,0x4,0,SetTo,"X","X",0x0,0,2); -- False
					Temp,
				},
				flag = {Preserved}
			}
	if FCONDCall1 == 0 then
		Need_Include_DataTransfer()
	end

	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCDeaths("X",SetTo,1,CFlag);
				},
				flag = {Preserved}
			}

	RecoverCp(PlayerID)
end

function f_bytecmpX(PlayerID,CFlag,Dest,DestX,SourceVA,Size,Distance)
	STPopTrigArr(PlayerID)

	if SourceVA[4] == "V" then -- ※ MovX는 CPRead방식으로 Cp값 변경하므로 Cp값 자체를 전달하는 SourceVA인자는 맨 밑에 있어야함
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig2X(0x6509B0,SetTo,SourceVA[1],SourceVA[2],0,1,SourceVA[3]); -- VArray Header +0x0
				SetCtrigX("X",FCOND[1],0x15C,0,SetTo,SourceVA[1],SourceVA[2],0,0,SourceVA[3]);
			},
			flag = {Preserved}
		}
	elseif SourceVA[4] == "VA" then
		local TempRet = {"X",FCOND[1],0,"V"}
		TMem(PlayerID,TempRet,SourceVA,0,0,1)
		Trigger {--(CPRead)로 값 출력
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0x6509B0,SetTo,SourceVA[5][1],SourceVA[5][2],0,1,SourceVA[5][3]); 
					SetMemory(0x6509B0,Add,SourceVA[6]);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x148,SourceVA[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x160,SourceVA[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x158,SourceVA[3],SetTo,EPD(0x6509B0)); 
					CallLabelAlways(SourceVA[1],SourceVA[2],SourceVA[3]);
				},
				flag = {Preserved}
		}
	end

	if type(Dest) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCOND[2],0x15C,0,SetTo,Dest);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then
		local TempRet = {"X",FCOND[2],0,"V"}
		MovX(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FCOND[2],0x15C,1,0);
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Dest[1],Dest[2],Dest[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FCOND[2],0x15C,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
			},
			flag = {Preserved}
		}
	end

	if type(DestX) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCOND[4],0x15C,0,SetTo,DestX);
			},
			flag = {Preserved}
		}
	elseif DestX[4] == "VA" then
		local TempRet = {"X",FCOND[4],0,"V"}
		MovX(PlayerID,TempRet,DestX)
		DestX = TempRet
	elseif DestX[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(DestX[1],DestX[2],0x158,DestX[3],SetTo,"X",FCOND[4],0x15C,1,0);
				SetCtrig1X(DestX[1],DestX[2],0x148,DestX[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(DestX[1],DestX[2],0x160,DestX[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(DestX[1],DestX[2],DestX[3]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCOND[3],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FCOND[3],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FCOND[3],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	local Clear = {}
	if type(CFlag) == "table" then
		CFlag = CFlag[1]
	else
		table.insert(Clear,SetCDeaths("X",SetTo,0,CFlag))
	end

	if Distance == nil then
		Distance = 1
	end
	-- Call f_Bytecpy
	local Temp = {}
	for k, v in pairs(FCONDArr) do
		table.insert(Temp,SetCtrig1X("X",v[1],v[2],0,SetTo,Distance))
	end
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					Clear,
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCONDCall1,0x0,0,0);
					SetCtrigX("X",FCONDCall2,0x4,0,SetTo,"X","X",0x0,0,1); -- True
					SetCtrigX("X",FCONDCall3,0x4,0,SetTo,"X","X",0x0,0,2); -- False
					Temp,
				},
				flag = {Preserved}
			}
	if FCONDCall1 == 0 then
		Need_Include_DataTransfer()
	end

	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCDeaths("X",SetTo,1,CFlag);
				},
				flag = {Preserved}
			}

	RecoverCp(PlayerID)
end

function f_Readcpy(PlayerID,DestVA,Source,Size,InitBytes,Distance) 
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << Dest / CRet[2] << Source / CRet[3] << Size (Offset)

	if InitBytes == nil or InitBytes == "X" then
		InitBytes = 0
	end
	if InitBytes >= 4 then
		f_Readcpy_InputData_Error()
	end
	if DestVA[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEM[1],0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]);
				SetCtrig1X("X",FMEM[3],0x15C,0,SetTo,InitBytes);
			},
			flag = {Preserved}
		}
	elseif DestVA[4] == "VA" then
		local TempRet = {"X",FMEM[1],0,"V"}
		MovZ(PlayerID,TempRet,DestVA,0x15C)
		DestVA = TempRet
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[3],0x15C,0,SetTo,InitBytes);
			},
			flag = {Preserved}
		}
	end

	if type(Source) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[2],0x15C,0,SetTo,Source);
			},
			flag = {Preserved}
		}
	elseif Source[4] == "VA" then
		local TempRet = {"X",FMEM[2],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "A" then
		local TempRet = {"X",FMEM[2],0,"V"}
		TMem(PlayerID,TempRet,Source,nil,nil,1)
		Source = TempRet
	elseif Source[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FMEM[2],0x15C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEM[2],0x15C,0,SetTo,Source[1],Source[2],Source[3],0,Source[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[5],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FMEM[5],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FMEM[5],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if Distance == nil then
		Distance = 1
	end
	-- Call f_Memcpy
	local Temp1 = {}
	for k, v in pairs(FMEMArr1) do
		table.insert(Temp1,SetCtrig1X("X",v[1],v[2],0,SetTo,604))
	end
	local Temp2 = {}
	for k, v in pairs(FMEMArr2) do
		table.insert(Temp2,SetCtrig1X("X",v[1],v[2],0,SetTo,Distance))
	end
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FMEMCall0,0x0,0,0);
					SetCtrigX("X",FMEMCall2,0x4,0,SetTo,"X","X",0x0,0,1);
					SetCtrig1X("X",FMEM[6],0x15C,0,SetTo,1);
					Temp1,
					Temp2,
				},
				flag = {Preserved}
			}
	if FMEMCall1 == 0 then
		Need_Include_DataTransferX()
	end
end

function f_ReadcpyX(PlayerID,DestVA,Source,SourceX,Size,InitBytes,Distance) 
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << Dest / CRet[2] << Source / CRet[3] << Size (Offset)
	if InitBytes == nil or InitBytes == "X" then
		InitBytes = 0
	end
	if InitBytes >= 4 then
		f_ReadcpyX_InputData_Error()
	end
	if DestVA[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEM[1],0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]);
				SetCtrig1X("X",FMEM[3],0x15C,0,SetTo,InitBytes);
			},
			flag = {Preserved}
		}
	elseif DestVA[4] == "VA" then
		local TempRet = {"X",FMEM[1],0,"V"}
		MovZ(PlayerID,TempRet,DestVA,0x15C)
		DestVA = TempRet
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[3],0x15C,0,SetTo,InitBytes);
			},
			flag = {Preserved}
		}
	end

	if type(Source) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[2],0x15C,0,SetTo,Source);
			},
			flag = {Preserved}
		}
	elseif Source[4] == "VA" then
		local TempRet = {"X",FMEM[2],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "A" then
		local TempRet = {"X",FMEM[2],0,"V"}
		MovZ(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FMEM[2],0x15C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEM[2],0x15C,0,SetTo,Source[1],Source[2],Source[3],1,Source[4]);
			},
			flag = {Preserved}
		}
	end

	if type(SourceX) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[4],0x15C,0,SetTo,SourceX);
			},
			flag = {Preserved}
		}
	elseif SourceX[4] == "VA" then
		local TempRet = {"X",FMEM[4],0,"V"}
		MovX(PlayerID,TempRet,SourceX)
		SourceX = TempRet
	elseif SourceX[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(SourceX[1],SourceX[2],0x158,SourceX[3],SetTo,"X",FMEM[4],0x15C,1,0);
				SetCtrig1X(SourceX[1],SourceX[2],0x148,SourceX[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(SourceX[1],SourceX[2],0x160,SourceX[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(SourceX[1],SourceX[2],SourceX[3]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[5],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FMEM[5],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FMEM[5],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if Distance == nil then
		Distance = 1
	end
	-- Call f_Memcpy
	local Temp1 = {}
	for k, v in pairs(FMEMArr1) do
		table.insert(Temp1,SetCtrig1X("X",v[1],v[2],0,SetTo,604))
	end
	local Temp2 = {}
	for k, v in pairs(FMEMArr2) do
		table.insert(Temp2,SetCtrig1X("X",v[1],v[2],0,SetTo,Distance))
	end
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FMEMCall1,0x0,0,0);
					SetCtrigX("X",FMEMCall2,0x4,0,SetTo,"X","X",0x0,0,1);
					SetCtrig1X("X",FMEM[6],0x15C,0,SetTo,1);
					Temp1,
					Temp2,
				},
				flag = {Preserved}
			}
	if FMEMCall1 == 0 then
		Need_Include_DataTransferX()
	end
end

function f_Memcpy(PlayerID,Dest,Source,Size,DestDistance,SourceDistance) 
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << Dest / CRet[2] << Source / CRet[3] << Size (Offset)
	if type(Dest) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[1],0x15C,0,SetTo,Dest);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then
		local TempRet = {"X",FMEM[1],0,"V"}
		MovX(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "A" then
		local TempRet = {"X",FMEM[1],0,"V"}
		TMem(PlayerID,TempRet,Dest,nil,nil,1)
		Dest = TempRet
	elseif Dest[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FMEM[1],0x15C,1,0);
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Dest[1],Dest[2],Dest[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEM[1],0x15C,0,SetTo,Dest[1],Dest[2],Dest[3],0,Dest[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Source) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[2],0x15C,0,SetTo,Source);
			},
			flag = {Preserved}
		}
	elseif Source[4] == "VA" then
		local TempRet = {"X",FMEM[2],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "A" then
		local TempRet = {"X",FMEM[2],0,"V"}
		TMem(PlayerID,TempRet,Source,nil,nil,1)
		Source = TempRet
	elseif Source[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FMEM[2],0x15C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEM[2],0x15C,0,SetTo,Source[1],Source[2],Source[3],0,Source[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[5],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FMEM[5],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FMEM[5],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if DestDistance == nil then
		DestDistance = 1
	end
	if SourceDistance == nil then
		SourceDistance = 1
	end
	-- Call f_Memcpy
	local Temp1 = {}
	for k, v in pairs(FMEMArr1) do
		table.insert(Temp1,SetCtrig1X("X",v[1],v[2],0,SetTo,DestDistance))
	end
	local Temp2 = {}
	for k, v in pairs(FMEMArr2) do
		table.insert(Temp2,SetCtrig1X("X",v[1],v[2],0,SetTo,SourceDistance))
	end
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FMEMCall0,0x0,0,0);
					SetCtrigX("X",FMEMCall2,0x4,0,SetTo,"X","X",0x0,0,1);
					SetCtrig1X("X",FMEM[6],0x15C,0,SetTo,0);
					Temp1,
					Temp2,
				},
				flag = {Preserved}
			}
	if FMEMCall1 == 0 then
		Need_Include_DataTransferX()
	end
end

function f_MemcpyX(PlayerID,Dest,DestX,Source,SourceX,Size,DestDistance,SourceDistance)
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << Dest / CRet[2] << Source / CRet[3] << Size (Offset)
	if type(Dest) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[1],0x15C,0,SetTo,Dest);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then
		local TempRet = {"X",FMEM[1],0,"V"}
		MovX(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "A" then
		local TempRet = {"X",FMEM[1],0,"V"}
		MovZ(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FMEM[1],0x15C,1,0);
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Dest[1],Dest[2],Dest[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEM[1],0x15C,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Source) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[2],0x15C,0,SetTo,Source);
			},
			flag = {Preserved}
		}
	elseif Source[4] == "VA" then
		local TempRet = {"X",FMEM[2],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "A" then
		local TempRet = {"X",FMEM[2],0,"V"}
		MovZ(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FMEM[2],0x15C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEM[2],0x15C,0,SetTo,Source[1],Source[2],Source[3],1,Source[4]);
			},
			flag = {Preserved}
		}
	end

	if type(DestX) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[3],0x15C,0,SetTo,DestX);
			},
			flag = {Preserved}
		}
	elseif DestX[4] == "VA" then
		local TempRet = {"X",FMEM[3],0,"V"}
		MovX(PlayerID,TempRet,DestX)
		DestX = TempRet
	elseif DestX[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(DestX[1],DestX[2],0x158,DestX[3],SetTo,"X",FMEM[3],0x15C,1,0);
				SetCtrig1X(DestX[1],DestX[2],0x148,DestX[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(DestX[1],DestX[2],0x160,DestX[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(DestX[1],DestX[2],DestX[3]);
			},
			flag = {Preserved}
		}
	end

	if type(SourceX) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[4],0x15C,0,SetTo,SourceX);
			},
			flag = {Preserved}
		}
	elseif SourceX[4] == "VA" then
		local TempRet = {"X",FMEM[4],0,"V"}
		MovX(PlayerID,TempRet,SourceX)
		SourceX = TempRet
	elseif SourceX[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(SourceX[1],SourceX[2],0x158,SourceX[3],SetTo,"X",FMEM[4],0x15C,1,0);
				SetCtrig1X(SourceX[1],SourceX[2],0x148,SourceX[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(SourceX[1],SourceX[2],0x160,SourceX[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(SourceX[1],SourceX[2],SourceX[3]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[5],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FMEM[5],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FMEM[5],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if DestDistance == nil then
		DestDistance = 1
	end
	if SourceDistance == nil then
		SourceDistance = 1
	end
	-- Call f_Memcpy
	local Temp1 = {}
	for k, v in pairs(FMEMArr1) do
		table.insert(Temp1,SetCtrig1X("X",v[1],v[2],0,SetTo,DestDistance))
	end
	local Temp2 = {}
	for k, v in pairs(FMEMArr2) do
		table.insert(Temp2,SetCtrig1X("X",v[1],v[2],0,SetTo,SourceDistance))
	end
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FMEMCall1,0x0,0,0);
					SetCtrigX("X",FMEMCall2,0x4,0,SetTo,"X","X",0x0,0,1);
					SetCtrig1X("X",FMEM[6],0x15C,0,SetTo,0);
					Temp1,
					Temp2,
				},
				flag = {Preserved}
			}
	if FMEMCall1 == 0 then
		Need_Include_DataTransferX()
	end
end

-- Include MiscFunc

function f_GetTblptr(PlayerID,Output,TBLIndex)
	STPopTrigArr(PlayerID)

	-- Input Data CRet[1],CRet[2] << TBL Index
	if type(TBLIndex) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FPTBL[1],0x15C,0,SetTo,TBLIndex/2);
				SetCtrig1X("X",FPTBL[2],0x15C,0,SetTo,TBLIndex%2);
			},
			flag = {Preserved}
		}

		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FPTBLCall1,0x0,0,0);
				SetCtrigX("X",FPTBLCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}
	else
		if TBLIndex[4] == "VA" then
			local TempRet = {"X",FPTBL[2],0,"V"}
			MovX(PlayerID,TempRet,TBLIndex,SetTo,0xFFFF)
			TBLIndex = TempRet
		elseif TBLIndex[4] == "V" then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(TBLIndex[1],TBLIndex[2],0x158,TBLIndex[3],SetTo,"X",FPTBL[2],0x15C,1,0);
					SetCtrig1X(TBLIndex[1],TBLIndex[2],0x148,TBLIndex[3],SetTo,0xFFFF);
					SetCtrig1X(TBLIndex[1],TBLIndex[2],0x160,TBLIndex[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(TBLIndex[1],TBLIndex[2],TBLIndex[3]);
				},
				flag = {Preserved}
			}
		end

		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FPTBLCall0,0x0,0,0);
				SetCtrigX("X",FPTBLCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}
	end
	
-- Call f_GetTBLptr
	if FPTBLCall1 == 0 then
		Need_Include_MiscFunc()
	end

	-- Output Data CRet[2] = Output 
	if type(Output) == "number" then
			Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",FPTBL[3],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",FPTBL[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FPTBL[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FPTBL[3],0);
						},
						flag = {Preserved}
					}
	else
		if Output[4] == "V" then
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FPTBL[3],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",FPTBL[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FPTBL[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FPTBL[3],0);
						},
						flag = {Preserved}
					}
		elseif Output[4] == "VA" then
				local TempRet = {"X",FPTBL[3],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,0xFFFFFFFF)
		elseif Output[4] == "A" then
				local TempRet = {"X",FPTBL[3],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FPTBL[3],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",FPTBL[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FPTBL[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FPTBL[3],0);
						},
						flag = {Preserved}
					}
		end
	end

	RecoverCp(PlayerID)
end

function f_GetStrXptr(PlayerID,Output,StringId)
	STPopTrigArr(PlayerID)
	local StringKey
	-- Input Data CRet[1] << StringId

	if type(StringId) == "number" or type(StringId) == "string" then
		StringKey = ParseString(StringId)
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				Disabled(DisplayText(StringKey,4));
				SetCtrig1X("X",FPSTRX[1],0x15C,0,SetTo,StringKey);
			},
			flag = {Preserved}
		}
	else
		if StringId[4] == "VA" then
			local TempRet = {"X",FPSTRX[1],0,"V"}
			MovX(PlayerID,TempRet,StringId)
			StringId = TempRet
		elseif StringId[4] == "V" then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(StringId[1],StringId[2],0x158,StringId[3],SetTo,"X",FPSTRX[1],0x15C,1,0);
					SetCtrig1X(StringId[1],StringId[2],0x148,StringId[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(StringId[1],StringId[2],0x160,StringId[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(StringId[1],StringId[2],StringId[3]);
				},
				flag = {Preserved}
			}
		end
	end

	
	
-- Call f_GetStrXptr
	if FPSTRXCall1 == 0 then
		Need_Include_MiscFunc()
	end

	Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FPSTRXCall1,0x0,0,0);
				SetCtrigX("X",FPSTRXCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}

	-- Output Data CRet[2] = Output 
	if type(Output) == "number" then
			Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",FPSTRX[2],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",FPSTRX[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FPSTRX[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FPSTRX[2],0);
						},
						flag = {Preserved}
					}
	else
		if Output[4] == "V" then
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FPSTRX[2],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",FPSTRX[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FPSTRX[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FPSTRX[2],0);
						},
						flag = {Preserved}
					}
		elseif Output[4] == "VA" then
				local TempRet = {"X",FPSTRX[2],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,0xFFFFFFFF)
		elseif Output[4] == "A" then
				local TempRet = {"X",FPSTRX[2],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FPSTRX[2],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",FPSTRX[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FPSTRX[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FPSTRX[2],0);
						},
						flag = {Preserved}
					}
		end
	end

	RecoverCp(PlayerID)
	return StringKey
end

function f_GetStrptr(PlayerID,Output,StringId)
	STPopTrigArr(PlayerID)
	local StringKey
	-- Input Data CRet[1],CRet[2] << StringId
	if type(StringId) == "number" or type(StringId) == "string" then
		StringKey = ParseString(StringId)
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					Disabled(DisplayText(StringKey,4));
					SetCtrig1X("X",FPSTR[1],0x15C,0,SetTo,StringKey/2);
					SetCtrig1X("X",FPSTR[2],0x15C,0,SetTo,StringKey%2);
				},
				flag = {Preserved}
			}
	
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FPSTRCall1,0x0,0,0);
				SetCtrigX("X",FPSTRCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}
	else
		if StringId[4] == "VA" then
			local TempRet = {"X",FPSTR[2],0,"V"}
			MovX(PlayerID,TempRet,StringId,SetTo,0xFFFF)
			StringId = TempRet
		elseif StringId[4] == "V" then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(StringId[1],StringId[2],0x158,StringId[3],SetTo,"X",FPSTR[2],0x15C,1,0);
					SetCtrig1X(StringId[1],StringId[2],0x148,StringId[3],SetTo,0xFFFF);
					SetCtrig1X(StringId[1],StringId[2],0x160,StringId[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(StringId[1],StringId[2],StringId[3]);
				},
				flag = {Preserved}
			}
		end

		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FPSTRCall0,0x0,0,0);
				SetCtrigX("X",FPSTRCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}
	end
	
-- Call f_GetStrptr
	if FPSTRCall1 == 0 then
		Need_Include_MiscFunc()
	end

	-- Output Data CRet[3] = Output 
	if type(Output) == "number" then
			Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",FPSTR[3],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",FPSTR[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FPSTR[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FPSTR[3],0);
						},
						flag = {Preserved}
					}
	else
		if Output[4] == "V" then
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FPSTR[3],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",FPSTR[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FPSTR[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FPSTR[3],0);
						},
						flag = {Preserved}
					}
		elseif Output[4] == "VA" then
				local TempRet = {"X",FPSTR[3],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,0xFFFFFFFF)
		elseif Output[4] == "A" then
				local TempRet = {"X",FPSTR[3],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FPSTR[3],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",FPSTR[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FPSTR[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FPSTR[3],0);
						},
						flag = {Preserved}
					}
		end
	end

	RecoverCp(PlayerID)
	return StringKey
end

function f_Rand(PlayerID,Dest,Mask)
	STPopTrigArr(PlayerID)
	if Mask == nil or "X" then
		Mask = 0xFFFFFFFF
	end

-- Call f_Rand
	if FRANDCall1 == 0 then
		Need_Include_MiscFunc()
	end

	Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FRANDCall1,0x0,0,0);
				SetCtrigX("X",FRANDCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}

-- Output Data CRet[1] = Output 
	if type(Dest) == "number" then
			Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",FRAND,0x158,0,SetTo,EPD(Dest));
						SetCtrig1X("X",FRAND,0x148,0,SetTo,Mask);
						SetCtrig1X("X",FRAND,0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FRAND,0);
						},
						flag = {Preserved}
					}
	else
		if Dest[4] == "V" then
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FRAND,0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",FRAND,0x148,0,SetTo,Mask);
						SetCtrig1X("X",FRAND,0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FRAND,0);
						},
						flag = {Preserved}
					}
		elseif Dest[4] == "VA" then
				local TempRet = {"X",FRAND,0,"V"}
				MovX(PlayerID,Dest,TempRet,SetTo,Mask)
		elseif Dest[4] == "A" then
				local TempRet = {"X",FRAND,0,"V"}
				MovX(PlayerID,Dest,TempRet,SetTo,Mask)
		else
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FRAND,0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
						SetCtrig1X("X",FRAND,0x148,0,SetTo,Mask);
						SetCtrig1X("X",FRAND,0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FRAND,0);
						},
						flag = {Preserved}
					}
		end
	end
end

-- Include MatheMatics

function f_Log2(PlayerID,Dest,Source)
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << X 
	if type(Source) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",FLOG2[1],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
	else
		if Source[4] == "VA" then
			local TempRet = {"X",FLOG2[1],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		elseif Source[4] == "V" then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FLOG2[1],0x15C,1,0);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
		end
	end

-- Call f_Log2
	if FLOG2Call1 == 0 then
		Need_Include_MatheMatics()
	end
	Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FLOG2Call1,0x0,0,0);
				SetCtrigX("X",FLOG2Call2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}

-- Output Data CRet[2] = Output 
	if type(Dest) == "number" then
			Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",FLOG2[2],0x158,0,SetTo,EPD(Dest));
						SetCtrig1X("X",FLOG2[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLOG2[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FLOG2[2],0);
						},
						flag = {Preserved}
					}
	else
		if Dest[4] == "V" then
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FLOG2[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",FLOG2[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLOG2[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FLOG2[2],0);
						},
						flag = {Preserved}
					}
		elseif Dest[4] == "VA" then
				local TempRet = {"X",FLOG2[2],0,"V"}
				MovX(PlayerID,Dest,TempRet,SetTo,0xFFFFFFFF)
		elseif Dest[4] == "A" then
				local TempRet = {"X",FLOG2[2],0,"V"}
				MovX(PlayerID,Dest,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FLOG2[2],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
						SetCtrig1X("X",FLOG2[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLOG2[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FLOG2[2],0);
						},
						flag = {Preserved}
					}
		end
	end
end

function f_Atan2(PlayerID,DeltaY,DeltaX,AngleOutput) -- 0xFFFF8000 <= X, Y <= 0x7FFF (-32768~+32767)
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << DeltaY
	if type(DeltaY) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FATAN[1],0x15C,0,SetTo,DeltaY);
			},
			flag = {Preserved}
		}
	elseif DeltaY[4] == "VA" then
		local TempRet = {"X",FATAN[1],0,"V"}
		MovX(PlayerID,TempRet,DeltaY)
		DeltaY = TempRet
	elseif DeltaY[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(DeltaY[1],DeltaY[2],0x158,DeltaY[3],SetTo,"X",FATAN[1],0x15C,1,0);
				SetCtrig1X(DeltaY[1],DeltaY[2],0x148,DeltaY[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(DeltaY[1],DeltaY[2],0x160,DeltaY[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(DeltaY[1],DeltaY[2],DeltaY[3]);
			},
			flag = {Preserved}
		}
	end

	-- Input Data CRet[2] << DeltaX 
	if type(DeltaX) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FATAN[2],0x15C,0,SetTo,DeltaX);
			},
			flag = {Preserved}
		}
	elseif DeltaX[4] == "VA" then
		local TempRet = {"X",FATAN[2],0,"V"}
		MovX(PlayerID,TempRet,DeltaX)
		DeltaX = TempRet
	elseif DeltaX[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(DeltaX[1],DeltaX[2],0x158,DeltaX[3],SetTo,"X",FATAN[2],0x15C,1,0);
				SetCtrig1X(DeltaX[1],DeltaX[2],0x148,DeltaX[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(DeltaX[1],DeltaX[2],0x160,DeltaX[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(DeltaX[1],DeltaX[2],DeltaX[3]);
			},
			flag = {Preserved}
		}
	end

-- Call f_Atan2
	if FATANCall1 == 0 then
		Need_Include_MatheMatics()
	end
	Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FATANCall1,0x0,0,0);
				SetCtrigX("X",FATANCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}

-- Output Data CRet[3] = AngleOutput 
	if type(AngleOutput) == "number" then
			Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",FATAN[3],0x158,0,SetTo,EPD(AngleOutput));
						SetCtrig1X("X",FATAN[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FATAN[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FATAN[3],0);
						},
						flag = {Preserved}
					}
	else
		if AngleOutput[4] == "V" then
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FATAN[3],0x158,0,SetTo,AngleOutput[1],AngleOutput[2],0x15C,1,AngleOutput[3]);
						SetCtrig1X("X",FATAN[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FATAN[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FATAN[3],0);
						},
						flag = {Preserved}
					}
		elseif AngleOutput[4] == "VA" then
				local TempRet = {"X",FATAN[3],0,"V"}
				MovX(PlayerID,AngleOutput,TempRet,SetTo,0xFFFFFFFF)
		elseif AngleOutput[4] == "A" then
				local TempRet = {"X",FATAN[3],0,"V"}
				MovX(PlayerID,AngleOutput,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FATAN[3],0x158,0,SetTo,AngleOutput[1],AngleOutput[2],AngleOutput[3],1,AngleOutput[4]);
						SetCtrig1X("X",FATAN[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FATAN[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FATAN[3],0);
						},
						flag = {Preserved}
					}
		end
	end
end

function f_Lengthdir(PlayerID,Radius,Angle,CosOutput,SinOutput) -- 0xFFFF8000 <= Radius <= 0x7FFF (-32768~+32767)
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << Radius 

	if type(Radius) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FLENG[1],0x15C,0,SetTo,Radius);
			},
			flag = {Preserved}
		}
	elseif Radius[4] == "VA" then
		local TempRet = {"X",FLENG[1],0,"V"}
		MovX(PlayerID,TempRet,Radius)
		Radius = TempRet
	elseif Radius[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Radius[1],Radius[2],0x158,Radius[3],SetTo,"X",FLENG[1],0x15C,1,0);
				SetCtrig1X(Radius[1],Radius[2],0x148,Radius[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Radius[1],Radius[2],0x160,Radius[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Radius[1],Radius[2],Radius[3]);
			},
			flag = {Preserved}
		}
	end
	-- Input Data CRet[2] << Angle 
	if type(Angle) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FLENG[2],0x15C,0,SetTo,Angle);
			},
			flag = {Preserved}
		}
	elseif Angle[4] == "VA" then
		local TempRet = {"X",FLENG[2],0,"V"}
		MovX(PlayerID,TempRet,Angle)
		Angle = TempRet
	elseif Angle[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Angle[1],Angle[2],0x158,Angle[3],SetTo,"X",FLENG[2],0x15C,1,0);
				SetCtrig1X(Angle[1],Angle[2],0x148,Angle[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Angle[1],Angle[2],0x160,Angle[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Angle[1],Angle[2],Angle[3]);
			},
			flag = {Preserved}
		}
	end

-- Call f_Lengthdir
	if FLENGCall1 == 0 then
		Need_Include_MatheMatics()
	end
	Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FLENGCall1,0x0,0,0);
				SetCtrigX("X",FLENGCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}

-- Output Data CRet[3] = CosOutput 
	if type(CosOutput) == "number" then
			Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",FLENG[3],0x158,0,SetTo,EPD(CosOutput));
						SetCtrig1X("X",FLENG[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLENG[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FLENG[3],0);
						},
						flag = {Preserved}
					}
	else
		if CosOutput[4] == "V" then
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FLENG[3],0x158,0,SetTo,CosOutput[1],CosOutput[2],0x15C,1,CosOutput[3]);
						SetCtrig1X("X",FLENG[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLENG[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FLENG[3],0);
						},
						flag = {Preserved}
					}
		elseif CosOutput[4] == "VA" then
				local TempRet = {"X",FLENG[3],0,"V"}
				MovX(PlayerID,CosOutput,TempRet,SetTo,0xFFFFFFFF)
		elseif CosOutput[4] == "A" then
				local TempRet = {"X",FLENG[3],0,"V"}
				MovX(PlayerID,CosOutput,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FLENG[3],0x158,0,SetTo,CosOutput[1],CosOutput[2],CosOutput[3],1,CosOutput[4]);
						SetCtrig1X("X",FLENG[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLENG[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FLENG[3],0);
						},
						flag = {Preserved}
					}
		end
	end
-- Output Data CRet[4] = SinOutput 
	if type(SinOutput) == "number" then
			Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",FLENG[4],0x158,0,SetTo,EPD(SinOutput));
						SetCtrig1X("X",FLENG[4],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLENG[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FLENG[4],0);
						},
						flag = {Preserved}
					}
	else
		if SinOutput[4] == "V" then
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FLENG[4],0x158,0,SetTo,SinOutput[1],SinOutput[2],0x15C,1,SinOutput[3]);
						SetCtrig1X("X",FLENG[4],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLENG[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FLENG[4],0);
						},
						flag = {Preserved}
					}
		elseif SinOutput[4] == "VA" then
				local TempRet = {"X",FLENG[4],0,"V"}
				MovX(PlayerID,SinOutput,TempRet,SetTo,0xFFFFFFFF)
		elseif SinOutput[4] == "A" then
				local TempRet = {"X",FLENG[4],0,"V"}
				MovX(PlayerID,SinOutput,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FLENG[4],0x158,0,SetTo,SinOutput[1],SinOutput[2],SinOutput[3],1,SinOutput[4]);
						SetCtrig1X("X",FLENG[4],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLENG[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FLENG[4],0);
						},
						flag = {Preserved}
					}
		end
	end
end

function f_Sqrt(PlayerID,Dest,Source)
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << X 

	if type(Source) == "number" then
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FSQRT[1],0x15C,0,SetTo,Source);
				},
				flag = {Preserved}
			}
	else
		if Source[4] == "VA" then
			local TempRet = {"X",FSQRT[1],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		elseif Source[4] == "V" then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FSQRT[1],0x15C,1,0);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
		end
	end

-- Call f_Sqrt
	if FSQRTCall1 == 0 then
		Need_Include_MatheMatics()
	end
	Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FSQRTCall1,0x0,0,0);
				SetCtrigX("X",FSQRTCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}

-- Output Data CRet[2] = Output 
	if type(Dest) == "number" then
			Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",FSQRT[2],0x158,0,SetTo,EPD(Dest));
						SetCtrig1X("X",FSQRT[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FSQRT[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FSQRT[2],0);
						},
						flag = {Preserved}
					}
	else
		if Dest[4] == "V" then
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FSQRT[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",FSQRT[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FSQRT[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FSQRT[2],0);
						},
						flag = {Preserved}
					}
		elseif Dest[4] == "VA" then
				local TempRet = {"X",FSQRT[2],0,"V"}
				MovX(PlayerID,Dest,TempRet,SetTo,0xFFFFFFFF)
		elseif Dest[4] == "A" then
				local TempRet = {"X",FSQRT[2],0,"V"}
				MovX(PlayerID,Dest,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FSQRT[2],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
						SetCtrig1X("X",FSQRT[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FSQRT[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FSQRT[2],0);
						},
						flag = {Preserved}
					}
		end
	end
end

-- Include DataTransfer

function f_EPD(PlayerID,Dest,Source)
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << X 

	if type(Source) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Source);
			},
			flag = {Preserved}
		}
	else
		if Source[4] == "VA" then
			local TempRet = {"X",CRet[1],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		elseif Source[4] == "V" then
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
		end
	end

-- Call f_EPD
	if FEPDCall1 == 0 then
		Need_Include_DataTransfer()
	end
	Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FEPDCall1,0x0,0,0);
				SetCtrigX("X",FEPDCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}

-- Output Data CRet[2] = Output
	if type(Dest) == "number" then
			Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(Dest));
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
	else
		if Dest[4] == "V" then
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
		elseif Dest[4] == "VA" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,Dest,TempRet,SetTo,0xFFFFFFFF)
		elseif Dest[4] == "A" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,Dest,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
		end
	end
end

function EPDX(Offset)
	return bit32.band(Offset,0x3)
end

function EPDF(Offset)
	return math.floor(EPD(Offset))
end

function FMemory(offset, comparison, number)
	return Deaths(EPDF(offset),comparison,number,0)
end
function FMemoryX(offset, comparison, number, mask)
	return DeathsX(EPDF(offset),comparison,number,0,mask)
end
function FSetMemory(offset, modtype, number)
	return SetDeaths(EPDF(offset),modtype,number,0)
end
function FSetMemoryX(offset, modtype, number, mask)
	return SetDeathsX(EPDF(offset),modtype,number,0,mask)
end

function SaveStrArr(Dest,StrArr,Distance)
	SaveAct = {}
	if type(Dest) == "number" then
		local Offset = Dest
		local Value = 0
		local t
		if Distance == nil then
			Distance = 4
		else
			Distance = Distance*4
		end
		for i = 1, #StrArr do
			t = i%4
			if t == 1 then
				Value = StrArr[i]
			elseif t == 2 then
				Value = Value + StrArr[i]*256
			elseif t == 3 then
				Value = Value + StrArr[i]*65536
			elseif t == 0 then
				Value = Value + StrArr[i]*16777216
				table.insert(SaveAct,FSetMemory(Offset,SetTo,Value))
				Offset = Offset+Distance
			end
		end	
		if t ~= 0 then
			table.insert(SaveAct,FSetMemory(Offset,SetTo,Value))
		end
	elseif Dest[4] == "V" then
		local Next = Dest[3]
		local Value = 0
		local t
		if Distance == nil then
			Distance = 1
		end
		for i = 1, #StrArr do
			t = i%4
			if t == 1 then
				Value = StrArr[i]
			elseif t == 2 then
				Value = Value + StrArr[i]*256
			elseif t == 3 then
				Value = Value + StrArr[i]*65536
			elseif t == 0 then
				Value = Value + StrArr[i]*16777216
				table.insert(SaveAct,SetCtrig1X(Dest[1],Dest[2],0x15C,Next,SetTo,Value))
				Next = Next+Distance
			end
		end	
		if t ~= 0 then
			table.insert(SaveAct,SetCtrig1X(Dest[1],Dest[2],0x15C,Next,SetTo,Value))
		end
	else
		local Offset = Dest[3]
		local Value = 0
		local t
		if Distance == nil then
			Distance = 4
		else
			Distance = Distance*4
		end
		for i = 1, #StrArr do
			t = i%4
			if t == 1 then
				Value = StrArr[i]
			elseif t == 2 then
				Value = Value + StrArr[i]*256
			elseif t == 3 then
				Value = Value + StrArr[i]*65536
			elseif t == 0 then
				Value = Value + StrArr[i]*16777216
				table.insert(SaveAct,SetCtrig1X(Dest[1],Dest[2],Offset,Dest[4],SetTo,Value))
				Offset = Offset+Distance
			end
		end	
		if t ~= 0 then
			table.insert(SaveAct,SetCtrig1X(Dest[1],Dest[2],Offset,Dest[4],SetTo,Value))
		end
	end

	return SaveAct
end

function f_EPDX(PlayerID,DestX,Source)
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << X 

	if type(Source) == "number" then
		if type(DestX) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(DestX,SetTo,0);
							SetMemoryX(DestX,SetTo,bit32.band(DestX,0x3),0x3);
						},
						flag = {Preserved}
					}
		elseif DestX[4] == "V" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(DestX[1],DestX[2],0x15C,DestX[3],SetTo,0);
							SetCtrig1X(DestX[1],DestX[2],0x15C,DestX[3],SetTo,bit32.band(DestX,0x3),0x3);
						},
						flag = {Preserved}
					}
		else
			Trigger {
					players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(DestX[1],DestX[2],DestX[3],DestX[4],SetTo,0);
							SetCtrig1X(DestX[1],DestX[2],DestX[3],DestX[4],SetTo,bit32.band(DestX,0x3),0x3);
						},
						flag = {Preserved}
					}
		end
	elseif Source[4] == "V" then
		if type(DestX) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(DestX,SetTo,0);
						},
						flag = {Preserved}
					}
			Trigger {
					players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
							CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,1,1);
						},
						actions = {
							SetMemoryX(DestX,SetTo,1,1);
						},
						flag = {Preserved}
					}
			Trigger {
					players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
							CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,2,2);
						},
						actions = {
							SetMemoryX(DestX,SetTo,2,2);
						},
						flag = {Preserved}
					}
		elseif DestX[4] == "V" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(DestX[1],DestX[2],0x15C,DestX[3],SetTo,0);
						},
						flag = {Preserved}
					}
			Trigger {
					players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
							CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,1,1);
						},
						actions = {
							SetCtrig1X(DestX[1],DestX[2],0x15C,DestX[3],SetTo,1,1);
						},
						flag = {Preserved}
					}
			Trigger {
					players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
							CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,2,2);
						},
						actions = {
							SetCtrig1X(DestX[1],DestX[2],0x15C,DestX[3],SetTo,2,2);
						},
						flag = {Preserved}
					}
		else
			Trigger {
					players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(DestX[1],DestX[2],DestX[3],DestX[4],SetTo,0);
						},
						flag = {Preserved}
					}
			Trigger {
					players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
							CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,1,1);
						},
						actions = {
							SetCtrig1X(DestX[1],DestX[2],DestX[3],DestX[4],SetTo,1,1);
						},
						flag = {Preserved}
					}
			Trigger {
					players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
							CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,2,2);
						},
						actions = {
							SetCtrig1X(DestX[1],DestX[2],DestX[3],DestX[4],SetTo,2,2);
						},
						flag = {Preserved}
					}
		end
	end
end

function f_Read(PlayerID,Input,Output,EPDOutput,Mask,Clear) -- (CPRead) 방식으로 읽음
	STPopTrigArr(PlayerID)
	if Mask == nil or Mask == "X" then
		Mask = 0xFFFFFFFF
	end
	if Output == "X" then
		Output = nil
	end
	if EPDOutput == "X" then
		EPDOutput = nil
	end

	-- Input Data CRet[1] << EPD 
	if type(Input) == "number" then
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,SetTo,EPD(Input));
				},
				flag = {Preserved}
			}
	elseif Input == "Cp" then
		f_Read_InputData_Error()
	elseif Input[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
				SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Input[1],Input[2],Input[3]);
			},
			flag = {Preserved}
		}
	elseif Input[4] == "VA" then
		local TempRet = {"X",CRet[1],0,"V"}
		MovX(PlayerID,TempRet,Input)
		Input = TempRet
	elseif Input[4] == "A" then
		local TempRet = {"X",CRet[1],0,"V"}
		MovZ(PlayerID,TempRet,Input)
		Input = TempRet
	else
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",CRet[1],0x15C,0,SetTo,Input[1],Input[2],Input[3],1,Input[4]);
			},
			flag = {Preserved}
		}
	end

	-- Call f_Read
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FReadCall1,0x0,0,0);
					SetCtrigX("X",FReadCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FReadCall1 == 0 then
		Need_Include_DataTransfer()
	end

	
	-- Output Data CRet[2] = Output
	if Output ~= nil then
		local ClearAct = {}
		if Clear == 1 then
			ClearAct = {SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,0)}
		end
		if type(Output) == "number" then
			Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
		else
			if Output[4] == "V" then
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						ClearAct,
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
			elseif Output[4] == "VA" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,Mask)
			elseif Output[4] == "A" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,Mask)
			else
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
			end
		end
	end
	
	-- Output Data CRet[3] = EPD(Output)
	if EPDOutput ~= nil then
		if type(EPDOutput) == "number" then
			Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",CRet[3],0x158,0,SetTo,EPD(EPDOutput));
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
						},
						flag = {Preserved}
					}
		else
			if EPDOutput[4] == "V" then
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[3],0x158,0,SetTo,EPDOutput[1],EPDOutput[2],0x15C,1,EPDOutput[3]);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
						},
						flag = {Preserved}
					}
			elseif EPDOutput[4] == "VA" then
				local TempRet = {"X",CRet[3],0,"V"}
				MovX(PlayerID,EPDOutput,TempRet)
			elseif EPDOutput[4] == "A" then
				local TempRet = {"X",CRet[3],0,"V"}
				MovX(PlayerID,EPDOutput,TempRet)
			else
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[3],0x158,0,SetTo,EPDOutput[1],EPDOutput[2],EPDOutput[3],1,EPDOutput[4]);
					SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
			end
		end
	end
	
	-- Option : RecoverCp
	RecoverCp(PlayerID)
end


function f_ReadX(PlayerID,Input,Output,Multiplier,Mask,Clear) -- (CPRead) 방식으로 읽음
	STPopTrigArr(PlayerID)
	if Mask == nil or Mask == "X" then
		Mask = 0xFFFFFFFF
	end
	if Output == "X" then
		Output = nil
	end

	-- Input Data CRet[1] << EPD 
	if type(Input) == "number" then
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,SetTo,EPD(Input));
				},
				flag = {Preserved}
			}
	elseif Input == "Cp" then
		f_Read_InputData_Error()
	elseif Input[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
				SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Input[1],Input[2],Input[3]);
			},
			flag = {Preserved}
		}
	elseif Input[4] == "VA" then
		local TempRet = {"X",CRet[1],0,"V"}
		MovX(PlayerID,TempRet,Input)
		Input = TempRet
	elseif Input[4] == "A" then
		local TempRet = {"X",CRet[1],0,"V"}
		MovZ(PlayerID,TempRet,Input)
		Input = TempRet
	else
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",CRet[1],0x15C,0,SetTo,Input[1],Input[2],Input[3],1,Input[4]);
			},
			flag = {Preserved}
		}
	end

	-- Call f_ReadX
	local NextAct = {}
	local NextAct2 = {}
	local Mask2
	if Multiplier == "X" or Multiplier == nil then
		f_ReadX_InputData_Error()
	elseif Multiplier == 16777216 or Multiplier == "+3" then
		table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall1,0x0,0,0))
		table.insert(NextAct,SetCtrigX("X",FReadXCall1,0x4,7,SetTo,"X","X",0x0,0,1))
		Mask2 = bit32.band(Mask*16777216, 0xFFFFFFFF) 
	elseif Multiplier == 65536 or Multiplier == "+2" then
		if bit32.band(Mask, 0xFFFF) == 0x00FF then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall2,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall2,0x4,7,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall2,0x4,7,SetTo,"X",FReadXCall2,0x0,0,7+1))
		elseif bit32.band(Mask, 0xFFFF) == 0xFF00 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall2,0x0,0,8))
			table.insert(NextAct,SetCtrigX("X",FReadXCall2,0x4,15,SetTo,"X","X",0x0,0,1))
		else -- bit32.band(Mask, 0xFFFF) == 0xFFFF
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall2,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall2,0x4,15,SetTo,"X","X",0x0,0,1))
		end
		Mask2 = bit32.band(Mask*65536, 0xFFFFFFFF) 
	elseif Multiplier == 256 or Multiplier == "+1" then
		if bit32.band(Mask, 0xFFFFFF) == 0x0000FF then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall3,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall3,0x4,7,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall3,0x4,7,SetTo,"X",FReadXCall3,0x0,0,7+1))
		elseif bit32.band(Mask, 0xFFFFFF) == 0x00FF00 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall3,0x0,0,8))
			table.insert(NextAct,SetCtrigX("X",FReadXCall3,0x4,15,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall3,0x4,15,SetTo,"X",FReadXCall3,0x0,0,15+1))
		elseif bit32.band(Mask, 0xFFFFFF) == 0xFF0000 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall3,0x0,0,16))
			table.insert(NextAct,SetCtrigX("X",FReadXCall3,0x4,23,SetTo,"X","X",0x0,0,1))
		elseif bit32.band(Mask, 0xFFFFFF) == 0x00FFFF then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall3,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall3,0x4,15,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall3,0x4,15,SetTo,"X",FReadXCall3,0x0,0,15+1))
		elseif bit32.band(Mask, 0xFFFFFF) == 0xFFFF00 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall3,0x0,0,8))
			table.insert(NextAct,SetCtrigX("X",FReadXCall3,0x4,23,SetTo,"X","X",0x0,0,1))
		elseif bit32.band(Mask, 0xFFFFFF) == 0xFF00FF then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall3,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall3,0x4,7,SetTo,"X",FReadXCall3,0x0,0,16))
			table.insert(NextAct,SetCtrigX("X",FReadXCall3,0x4,23,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall3,0x4,7,SetTo,"X",FReadXCall3,0x0,0,7+1))
		else -- bit32.band(Mask, 0xFFFFFF) == 0xFFFFFF
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall3,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall3,0x4,23,SetTo,"X","X",0x0,0,1))
		end
		Mask2 = bit32.band(Mask*256, 0xFFFFFFFF) 
	elseif Multiplier == 1 or Multiplier == "0" then
		if bit32.band(Mask, 0xFFFFFFFF) == 0x000000FF then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,7,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall4,0x4,7,SetTo,"X",FReadXCall4,0x0,0,7+1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0x0000FF00 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,8))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,15,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall4,0x4,15,SetTo,"X",FReadXCall4,0x0,0,15+1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0x00FF0000 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,16))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,23,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall4,0x4,23,SetTo,"X",FReadXCall4,0x0,0,23+1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0xFF000000 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,24))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,31,SetTo,"X","X",0x0,0,1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0x0000FFFF then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,15,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall4,0x4,15,SetTo,"X",FReadXCall4,0x0,0,15+1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0x00FFFF00 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,8))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,23,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall4,0x4,23,SetTo,"X",FReadXCall4,0x0,0,23+1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0xFFFF0000 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,16))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,31,SetTo,"X","X",0x0,0,1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0x00FFFFFF then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,23,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall4,0x4,23,SetTo,"X",FReadXCall4,0x0,0,23+1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0xFFFFFF00 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,8))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,31,SetTo,"X","X",0x0,0,1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0x00FF00FF then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,7,SetTo,"X",FReadXCall4,0x0,0,16))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,23,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall4,0x4,7,SetTo,"X",FReadXCall4,0x0,0,7+1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0xFF00FF00 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,8))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,15,SetTo,"X",FReadXCall4,0x0,0,24))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,31,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall4,0x4,15,SetTo,"X",FReadXCall4,0x0,0,15+1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0xFF0000FF then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,7,SetTo,"X",FReadXCall4,0x0,0,24))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,31,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall4,0x4,7,SetTo,"X",FReadXCall4,0x0,0,7+1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0xFF00FFFF then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,15,SetTo,"X",FReadXCall4,0x0,0,24))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,31,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall4,0x4,15,SetTo,"X",FReadXCall4,0x0,0,15+1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0xFFFF00FF then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,7,SetTo,"X",FReadXCall4,0x0,0,16))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,31,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall4,0x4,7,SetTo,"X",FReadXCall4,0x0,0,7+1))
		else -- bit32.band(Mask, 0xFFFFFFFF) == 0xFFFFFFFF
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,31,SetTo,"X","X",0x0,0,1))
		end
		Mask2 = bit32.band(Mask, 0xFFFFFFFF) 
	elseif Multiplier == 1/256 or Multiplier == "-1" then
		if bit32.band(Mask, 0xFFFFFF00) == 0x0000FF00 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall5,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall5,0x4,7,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall5,0x4,7,SetTo,"X",FReadXCall5,0x0,0,7+1))
		elseif bit32.band(Mask, 0xFFFFFF00) == 0x00FF0000 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall5,0x0,0,8))
			table.insert(NextAct,SetCtrigX("X",FReadXCall5,0x4,15,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall5,0x4,15,SetTo,"X",FReadXCall5,0x0,0,15+1))
		elseif bit32.band(Mask, 0xFFFFFF00) == 0xFF000000 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall5,0x0,0,16))
			table.insert(NextAct,SetCtrigX("X",FReadXCall5,0x4,23,SetTo,"X","X",0x0,0,1))
		elseif bit32.band(Mask, 0xFFFFFF00) == 0x00FFFF00 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall5,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall5,0x4,15,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall5,0x4,15,SetTo,"X",FReadXCall5,0x0,0,15+1))
		elseif bit32.band(Mask, 0xFFFFFF00) == 0xFFFF0000 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall5,0x0,0,8))
			table.insert(NextAct,SetCtrigX("X",FReadXCall5,0x4,23,SetTo,"X","X",0x0,0,1))
		elseif bit32.band(Mask, 0xFFFFFF00) == 0xFF00FF00 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall5,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall5,0x4,7,SetTo,"X",FReadXCall5,0x0,0,16))
			table.insert(NextAct,SetCtrigX("X",FReadXCall5,0x4,23,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall5,0x4,7,SetTo,"X",FReadXCall5,0x0,0,7+1))
		else -- bit32.band(Mask, 0xFFFFFF00) == 0xFFFFFF00
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall5,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall5,0x4,23,SetTo,"X","X",0x0,0,1))
		end
		Mask2 = bit32.band(Mask/256, 0xFFFFFFFF) 
	elseif Multiplier == 1/65536 or Multiplier == "-2" then
		if bit32.band(Mask, 0xFFFF0000) == 0x00FF0000 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall6,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall6,0x4,7,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall6,0x4,7,SetTo,"X",FReadXCall6,0x0,0,7+1))
		elseif bit32.band(Mask, 0xFFFF0000) == 0xFF000000 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall6,0x0,0,8))
			table.insert(NextAct,SetCtrigX("X",FReadXCall6,0x4,15,SetTo,"X","X",0x0,0,1))
		else -- bit32.band(Mask, 0xFFFF0000) == 0xFFFF0000
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall6,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall6,0x4,15,SetTo,"X","X",0x0,0,1))
		end
		Mask2 = bit32.band(Mask/65536, 0xFFFFFFFF) 
	elseif Multiplier == 1/16777216 or Multiplier == "-3" then
		table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall7,0x0,0,0))
		table.insert(NextAct,SetCtrigX("X",FReadXCall7,0x4,7,SetTo,"X","X",0x0,0,1))
		Mask2 = bit32.band(Mask/16777216, 0xFFFFFFFF) 
	else
		f_ReadX_InputData_Error()
	end

	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FReadXCall0,0x0,0,0);
					NextAct,
				},
				flag = {Preserved}
			}
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					NextAct2,
				},
				flag = {Preserved}
			}
	if FReadXCall0 == 0 then
		Need_Include_DataTransfer()
	end

	-- Output Data CRet[2] = Output
	local ClearAct = {}
	if Clear == 1 then
		ClearAct = {SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,0)}
	end
	if Output ~= nil then
		if type(Output) == "number" then
			Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask2);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
		else
			if Output[4] == "V" then
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						ClearAct,
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask2);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
			elseif Output[4] == "VA" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,Mask2)
			elseif Output[4] == "A" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,Mask2)
			else
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask2);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
			end
		end
	end
	

	-- Option : RecoverCp
	RecoverCp(PlayerID)
end

-- Include ArithMetic

function f_Abs(PlayerID,Dest,Source,Mask)
	STPopTrigArr(PlayerID)
	if Mask == nil or Mask == "X" then
		Mask = 0xFFFFFFFF
	end
	if Source == "X" then
		Source = nil
	end

	-- Input Data CRet[1] << X 
	local PDest = Dest
	if Source == nil then
		if Dest[4] == "VA" then
			local TempRet = {"X",CRet[1],0,"V"}
			MovX(PlayerID,TempRet,Dest)
			Dest = TempRet
		else
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Dest[1],Dest[2],Dest[3]);
				},
				flag = {Preserved}
			}
		end
	else
		if type(Source) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else
			if Source[4] == "VA" then
				local TempRet = {"X",CRet[1],0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
	end

	-- Call f_Abs
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FABSCall1,0x0,0,0);
					SetCtrigX("X",FABSCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FABSCall1 == 0 then
		Need_Include_ArithMetic()
	end

	-- Output Data CRet[2] = Output

	if type(PDest) == "number" then
		Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(PDest));
					SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
	else
		if PDest[4] == "V" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		elseif PDest[4] == "VA" then
			local TempRet = {"X",CRet[2],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		elseif PDest[4] == "A" then
			local TempRet = {"X",CRet[2],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
					SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		end
	end

end
function f_Mul(PlayerID,Dest,Source,Multiplier,Mask)
	STPopTrigArr(PlayerID)
	if Mask == nil or Mask == "X" then
		Mask = 0xFFFFFFFF
	end
	if Multiplier == "X" then
		Multiplier = nil
	end

	-- Input Data CRet[1] << X / CRet[2] << Y
		
	local PDest = Dest
	if Multiplier == nil then
		if Dest[4] == "VA" then
			local TempRet = {"X",FMULCall0,0,"V"}
			MovX(PlayerID,TempRet,Dest)
			Dest = TempRet
		else
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FMULCall0,0x15C,1,0);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Dest[1],Dest[2],Dest[3]);
				},
				flag = {Preserved}
			}
		end
		if type(Source) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else
			if Source[4] == "VA" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
	else
		if type(Source) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",FMULCall0,0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else	
			if Source[4] == "VA" then
				local TempRet = {"X",FMULCall0,0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FMULCall0,0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
		if type(Multiplier) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Multiplier);
					},
					flag = {Preserved}
				}
		else	
			if Multiplier[4] == "VA" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,TempRet,Multiplier)
				Multiplier = TempRet
			else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Multiplier[1],Multiplier[2],0x158,Multiplier[3],SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X(Multiplier[1],Multiplier[2],0x148,Multiplier[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Multiplier[1],Multiplier[2],0x160,Multiplier[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Multiplier[1],Multiplier[2],Multiplier[3]);
					},
					flag = {Preserved}
				}
			end
		end
	end

	-- Call f_Mul
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FMULCall1,0x0,0,0);
					SetCtrigX("X",FMULCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FMULCall1 == 0 then
		Need_Include_ArithMetic()
	end

	-- Output Data CRet[3] = Output

	if type(PDest) == "number" then
		Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrig1X("X",CRet[3],0x158,0,SetTo,EPD(PDest));
					SetCtrig1X("X",CRet[3],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
	else
		if PDest[4] == "V" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[3],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrig1X("X",CRet[3],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		elseif PDest[4] == "VA" then
			local TempRet = {"X",CRet[3],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		elseif PDest[4] == "A" then
			local TempRet = {"X",CRet[3],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[3],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
					SetCtrig1X("X",CRet[3],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		end
	end
end

function f_iMul(PlayerID,Dest,Source,Multiplier,Mask)
	STPopTrigArr(PlayerID)
	if Mask == nil or Mask == "X" then
		Mask = 0xFFFFFFFF
	end
	if Multiplier == "X" then
		Multiplier = nil
	end

	-- Input Data CRet[1] << X / CRet[2] << Y
		
	local PDest = Dest
	if Multiplier == nil then
		if Dest[4] == "VA" then
			local TempRet = {"X",FMulCall0,0,"V"}
			MovX(PlayerID,TempRet,Dest)
			Dest = TempRet
		else
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FMulCall0,0x15C,1,0);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Dest[1],Dest[2],Dest[3]);
				},
				flag = {Preserved}
			}
		end
		if type(Source) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else
			if Source[4] == "VA" then
				local TempRet = {"X",CRet[1],0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
	else
		if type(Source) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",FMulCall0,0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else	
			if Source[4] == "VA" then
				local TempRet = {"X",FMulCall0,0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FMulCall0,0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
		if type(Multiplier) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Multiplier);
					},
					flag = {Preserved}
				}
		else	
			if Multiplier[4] == "VA" then
				local TempRet = {"X",CRet[1],0,"V"}
				MovX(PlayerID,TempRet,Multiplier)
				Multiplier = TempRet
			else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Multiplier[1],Multiplier[2],0x158,Multiplier[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Multiplier[1],Multiplier[2],0x148,Multiplier[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Multiplier[1],Multiplier[2],0x160,Multiplier[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Multiplier[1],Multiplier[2],Multiplier[3]);
					},
					flag = {Preserved}
				}
			end
		end
	end

	-- Call f_iMul
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FiMulCall1,0x0,0,0);
					SetCtrigX("X",FiMulCall2,0x4,0,SetTo,"X","X",0x0,0,1);
					SetCtrigX("X",FMulCall2,0x4,0,SetTo,"X",FMulCall2,0x0,0,1);
				},
				flag = {Preserved}
			}
	if FiMulCall1 == 0 then
		Need_Include_ArithMetic()
	end

	-- Output Data CRet[3] = Output

	if type(PDest) == "number" then
		Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrig1X("X",CRet[4],0x158,0,SetTo,EPD(PDest));
					SetCtrig1X("X",CRet[4],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[4],0);
					},
					flag = {Preserved}
				}
	else
		if PDest[4] == "V" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[4],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrig1X("X",CRet[4],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[4],0);
					},
					flag = {Preserved}
				}
		elseif PDest[4] == "VA" then
			local TempRet = {"X",CRet[4],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		elseif PDest[4] == "A" then
			local TempRet = {"X",CRet[4],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[4],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
					SetCtrig1X("X",CRet[4],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[4],0);
					},
					flag = {Preserved}
				}
		end
	end
end

function f_Div(PlayerID,Dest,Source,Divisor,Mask)
	STPopTrigArr(PlayerID)
	if Mask == nil or Mask == "X" then
		Mask = 0xFFFFFFFF
	end
	if Divisor == "X" then
		Divisor = nil
	end

	-- Input Data CRet[1] << X / CRet[2] << Y

	local PDest = Dest
	if Divisor == nil then
		if Dest[4] == "VA" then
			local TempRet = {"X",CRet[2],0,"V"}
			MovX(PlayerID,TempRet,Dest)
			Dest = TempRet
		else
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Dest[1],Dest[2],Dest[3]);
				},
				flag = {Preserved}
			}
		end
		if type(Source) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else
			if Source[4] == "VA" then
				local TempRet = {"X",CRet[1],0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
	else
		if type(Source) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else
			if Source[4] == "VA" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
		if type(Divisor) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Divisor);
					},
					flag = {Preserved}
				}
		else
			if Divisor[4] == "VA" then
				local TempRet = {"X",CRet[1],0,"V"}
				MovX(PlayerID,TempRet,Divisor)
				Divisor = TempRet
			else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
					},
					flag = {Preserved}
				}
			end
		end
	end

	-- Call f_Div
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FDIVCall1,0x0,0,0);
					SetCtrigX("X",FDIVCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FDIVCall1 == 0 then
		Need_Include_ArithMetic()
	end

	-- Output Data CRet[3] = Output
	if type(PDest) == "number" then
		Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrig1X("X",CRet[3],0x158,0,SetTo,EPD(PDest));
					SetCtrig1X("X",CRet[3],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
	else
		if PDest[4] == "V" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[3],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrig1X("X",CRet[3],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		elseif PDest[4] == "VA" then
			local TempRet = {"X",CRet[3],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		elseif PDest[4] == "A" then
			local TempRet = {"X",CRet[3],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[3],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
					SetCtrig1X("X",CRet[3],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		end
	end
end

function f_Mod(PlayerID,Dest,Source,Divisor,Mask)
	STPopTrigArr(PlayerID)
	if Mask == nil or Mask == "X" then
		Mask = 0xFFFFFFFF
	end
	if Divisor == "X" then
		Divisor = nil
	end

	-- Input Data CRet[1] << X / CRet[2] << Y
	local PDest = Dest
	if Divisor == nil then
		if Dest[4] == "VA" then
			local TempRet = {"X",CRet[2],0,"V"}
			MovX(PlayerID,TempRet,Dest)
			Dest = TempRet
		else
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Dest[1],Dest[2],Dest[3]);
				},
				flag = {Preserved}
			}
		end
		if type(Source) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else
			if Source[4] == "VA" then
				local TempRet = {"X",CRet[1],0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
	else
		if type(Source) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else
			if Source[4] == "VA" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
		if type(Divisor) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Divisor);
					},
					flag = {Preserved}
				}
		else
			if Divisor[4] == "VA" then
				local TempRet = {"X",CRet[1],0,"V"}
				MovX(PlayerID,TempRet,Divisor)
				Divisor = TempRet
			else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
					},
					flag = {Preserved}
				}
			end
		end
	end

	-- Call f_Mod
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FMODCall1,0x0,0,0);
					SetCtrigX("X",FMODCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FMODCall1 == 0 then
		Need_Include_ArithMetic()
	end

	-- Output Data CRet[2] = Output
	if type(PDest) == "number" then
		Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(PDest));
					SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
	else
		if PDest[4] == "V" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		elseif PDest[4] == "VA" then
			local TempRet = {"X",CRet[2],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		elseif PDest[4] == "A" then
			local TempRet = {"X",CRet[2],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
					SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		end
	end
end

function f_iDiv(PlayerID,Dest,Source,Divisor,Mask)
	STPopTrigArr(PlayerID)
	if Mask == nil or Mask == "X" then
		Mask = 0xFFFFFFFF
	end
	if Divisor == "X" then
		Divisor = nil
	end

	-- Input Data CRet[1] << X / CRet[2] << Y

	local PDest = Dest
	if Divisor == nil then
		if Dest[4] == "VA" then
			local TempRet = {"X",CRet[5],0,"V"}
			MovX(PlayerID,TempRet,Dest)
			Dest = TempRet
		else
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[5],0x15C,1,0);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Dest[1],Dest[2],Dest[3]);
				},
				flag = {Preserved}
			}
		end
		if type(Source) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else
			if Source[4] == "VA" then
				local TempRet = {"X",CRet[1],0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
	else
		if type(Source) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[5],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else
			if Source[4] == "VA" then
				local TempRet = {"X",CRet[5],0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[5],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
		if type(Divisor) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Divisor);
					},
					flag = {Preserved}
				}
		else
			if Divisor[4] == "VA" then
				local TempRet = {"X",CRet[1],0,"V"}
				MovX(PlayerID,TempRet,Divisor)
				Divisor = TempRet
			else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
					},
					flag = {Preserved}
				}
			end
		end
	end

	-- Call f_iDiv
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FIDIVCall1,0x0,0,0);
					SetCtrigX("X",FIDIVCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FIDIVCall1 == 0 then
		Need_Include_ArithMetic()
	end

	-- Output Data CRet[3] = Output
	if type(PDest) == "number" then
		Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrig1X("X",CRet[5],0x158,0,SetTo,EPD(PDest));
					SetCtrig1X("X",CRet[5],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[5],0);
					},
					flag = {Preserved}
				}
	else
		if PDest[4] == "V" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[5],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrig1X("X",CRet[5],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[5],0);
					},
					flag = {Preserved}
				}
		elseif PDest[4] == "VA" then
			local TempRet = {"X",CRet[5],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		elseif PDest[4] == "A" then
			local TempRet = {"X",CRet[5],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[5],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
					SetCtrig1X("X",CRet[5],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[5],0);
					},
					flag = {Preserved}
				}
		end
	end
end

function f_iMod(PlayerID,Dest,Source,Divisor,Mask)
	STPopTrigArr(PlayerID)
	if Mask == nil or Mask == "X" then
		Mask = 0xFFFFFFFF
	end
	if Divisor == "X" then
		Divisor = nil
	end

	-- Input Data CRet[1] << X / CRet[2] << Y
	local PDest = Dest
	if Divisor == nil then
		if Dest[4] == "VA" then
			local TempRet = {"X",CRet[5],0,"V"}
			MovX(PlayerID,TempRet,Dest)
			Dest = TempRet
		else
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[5],0x15C,1,0);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Dest[1],Dest[2],Dest[3]);
				},
				flag = {Preserved}
			}
		end
		if type(Source) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else
			if Source[4] == "VA" then
				local TempRet = {"X",CRet[1],0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
	else
		if type(Source) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[5],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else
			if Source[4] == "VA" then
				local TempRet = {"X",CRet[5],0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[5],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
		if type(Divisor) == "number" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Divisor);
					},
					flag = {Preserved}
				}
		else
			if Divisor[4] == "VA" then
				local TempRet = {"X",CRet[1],0,"V"}
				MovX(PlayerID,TempRet,Divisor)
				Divisor = TempRet
			else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
					},
					flag = {Preserved}
				}
			end
		end
	end

	-- Call f_Div
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FIMODCall1,0x0,0,0);
					SetCtrigX("X",FIMODCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FIMODCall1 == 0 then
		Need_Include_ArithMetic()
	end

	-- Output Data CRet[2] = Output
	if type(PDest) == "number" then
		Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrig1X("X",CRet[5],0x158,0,SetTo,EPD(PDest));
					SetCtrig1X("X",CRet[5],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[5],0);
					},
					flag = {Preserved}
				}
	else
		if PDest[4] == "V" then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[5],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrig1X("X",CRet[5],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[5],0);
					},
					flag = {Preserved}
				}
		elseif PDest[4] == "VA" then
			local TempRet = {"X",CRet[5],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		elseif PDest[4] == "A" then
			local TempRet = {"X",CRet[5],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		else
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[5],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
					SetCtrig1X("X",CRet[5],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[5],0);
					},
					flag = {Preserved}
				}
		end
	end
end

-- 내부 트리거 생성 관련 함수 (직접 사용X) -----------------------------------------------

function _TPopCondArr(PlayerID)
	if _TPopTrigLock == 0 and _TPushCondArr[1] ~= nil then
		if ORPushCondArr[1] ~= nil then
			_TPopCondArr_InputData_Error()
		end
		_TPopTrigLock = 1
		local BackupArr = {PushCondArr,CondLineArr,PushActArr,ActLineArr,STPushTrigArr,PushTrigArr,PushTrigStack,TTPushTrigArr,TTPushCondArr,TTFCodeArr,TTModeArr}
		PushCondArr = {}
		CondLineArr = {}
		PushActArr = {}
		ActLineArr = {}
		STPushTrigArr = {}
		PushTrigArr = {}
		PushTrigStack = 0
		TTPushTrigArr = {}
		TTPushCondArr = {}
		TTFCodeArr = {}
		TTModeArr = {}

		local _TF = _TFCodeArr[1]
		_TPopPlayerIDArr = PlayerID
		DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,_TF)})
		for i = 1, #_TPushCondArr[1] do -- <<1>,<2>,...,<n>>
			_TPopTrig(_TF,_TPushCondArr[1][i]) -- Pop _TCond
		end

		PushCondArr = BackupArr[1]
		CondLineArr = BackupArr[2]
		PushActArr = BackupArr[3]
		ActLineArr = BackupArr[4]
		STPushTrigArr = BackupArr[5]
		PushTrigArr = BackupArr[6]
		PushTrigStack = BackupArr[7]
		TTPushTrigArr = BackupArr[8]
		TTPushCondArr = BackupArr[9]
		TTFCodeArr = BackupArr[10]
		TTModeArr = BackupArr[11]
		_TPushCondArr = {}
		_TFCodeArr = {}
		_TPopTrigLock = 0
		_TPushVarXAlloc = {}
		_TPopPlayerIDArr = {}

		VarXAlloc = 0xFE00
		WarXAlloc = 0xFC00
		for j = 1, 16 do
			SVarXAlloc[j] = SVarXOrig[j]
		end
		VarXReleaseLock = 0
	end
end

function _TPopTrig(Flag,_TCond,Type,Value)
	PlayerID = _TPopPlayerIDArr
	if Type == nil then
		Type = Add
	end
	if Value == nil then
		Value = 1
	end

	if _TCond[1] == "X" then
		TriggerX(PlayerID,{_TCond[2]},{SetCDeaths("X",Type,Value,Flag)},{Preserved})
	elseif _TCond[1] == "T" or _TCond[1] == "TT" then
		local TCond
		local TFunc = _TCond[2]
		table.remove(_TCond,2)
		table.remove(_TCond,1)
		TCond = _G[TFunc](table.unpack(_TCond))
		CTrigger(PlayerID,{TCond},{SetCDeaths("X",Type,Value,Flag)},{Preserved})
	elseif _TCond[1] == "B" then
		local TCond = {}
		for i = 2, #_TCond do
			table.insert(TCond,_TPopBind(_TCond[i]))
		end
		CTrigger(PlayerID,{TCond},{SetCDeaths("X",Type,Value,Flag)},{Preserved})
	elseif _TCond[1] == "NOT" then
		local NFlag = FlagIndex(FlagAlloc)
		FlagAlloc = FlagAlloc + 1
		DoActionsX(PlayerID,{SetCDeaths("X",SetTo,1,NFlag)})
		_TPopTrig(NFlag,_TCond[2],SetTo,0)
		CTrigger(PlayerID,{CDeaths("X",Exactly,1,NFlag)},{SetCDeaths("X",Type,Value,Flag)},{Preserved})
	elseif _TCond[1] == "OR" then
		local NFlag = FlagIndex(FlagAlloc)
		FlagAlloc = FlagAlloc + 1
		DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,NFlag)})
		for i = 2, #_TCond do
			_TPopTrig(NFlag,_TCond[i],SetTo,1)
		end		
		CTrigger(PlayerID,{CDeaths("X",Exactly,1,NFlag)},{SetCDeaths("X",Type,Value,Flag)},{Preserved})
	elseif _TCond[1] == "AND" then
		local NFlag = FlagIndex(FlagAlloc)
		FlagAlloc = FlagAlloc + 1
		DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,NFlag)})
		for i = 2, #_TCond do
			_TPopTrig(NFlag,_TCond[i])
		end		
		CTrigger(PlayerID,{CDeaths("X",Exactly,#_TCond-1,NFlag)},{SetCDeaths("X",Type,Value,Flag)},{Preserved})
	end
end

function _TPopBind(_TCond)
	if _TCond[1] == "X" then
		local TCond = _TCond[2]
		return TCond
	elseif _TCond[1] == "T" or _TCond[1] == "TT" then
		local TFunc = _TCond[2]
		table.remove(_TCond,2)
		table.remove(_TCond,1)
		local TCond = _G[TFunc](table.unpack(_TCond))
		return TCond
	elseif _TCond[1] == "B" then
		_TPopBind_InputData_Error()
	elseif _TCond[1] == "NOT" then
		local NFlag = FlagIndex(FlagAlloc)
		FlagAlloc = FlagAlloc + 1
		DoActionsX(PlayerID,{SetCDeaths("X",SetTo,1,NFlag)})
		_TPopTrig(NFlag,_TCond[2],SetTo,0)
		local TCond = CDeaths("X",Exactly,1,NFlag)
		return TCond
	elseif _TCond[1] == "OR" then
		local NFlag = FlagIndex(FlagAlloc)
		FlagAlloc = FlagAlloc + 1
		DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,NFlag)})
		for i = 2, #_TCond do
			_TPopTrig(NFlag,_TCond[i],SetTo,1)
		end		
		local TCond = CDeaths("X",Exactly,1,NFlag)
		return TCond
	elseif _TCond[1] == "AND" then
		local NFlag = FlagIndex(FlagAlloc)
		FlagAlloc = FlagAlloc + 1
		DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,NFlag)})
		for i = 2, #_TCond do
			_TPopTrig(NFlag,_TCond[i])
		end		
		local TCond = CDeaths("X",Exactly,#_TCond-1,NFlag)
		return TCond
	end
end


function ORPopCondArr(PlayerID) -- 구버젼 호환용 함수
	if ORPopTrigLock == 0 and ORPushCondArr[1] ~= nil then
		ORPopTrigLock = 1
		local TempArr = PushCondArr
		local TempArr2 = CondLineArr
		local TempArr3 = PushActArr
		local TempArr4 = ActLineArr
		local TempArr5 = STPushTrigArr
		local TempArr6 = PushTrigArr
		local TempArr7 = PushTrigStack
		local TTempArr = TTPushTrigArr
		local TTempArr2 = TTPushCondArr
		local TTempArr3 = TTFCodeArr
		local TTempArr4 = TTModeArr
		PushCondArr = {}
		CondLineArr = {}
		PushActArr = {}
		ActLineArr = {}
		STPushTrigArr = {}
		PushTrigArr = {}
		PushTrigStack = 0
		TTPushTrigArr = {}
		TTPushCondArr = {}
		TTFCodeArr = {}
		TTModeArr = {}

		for i, ORCond in pairs(ORPushCondArr) do
			DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,ORFCodeArr[i])})
			for k, v in pairs(ORCond) do
				if v[1] == "T" then -- T조건
					if v[2] == "TMemoryX" then
						CTrigger(PlayerID,{TMemoryX(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TMemory" then
						CTrigger(PlayerID,{TMemory(v[3],v[4],v[5])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TCVar" then
						CTrigger(PlayerID,{TCVar(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TCVAar" then
						CTrigger(PlayerID,{TCVAar(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TVariableX" then
						CTrigger(PlayerID,{TVariableX(v[3],v[4],v[5],v[6],v[7],v[8])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TVariable" then
						CTrigger(PlayerID,{TVariable(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TVArrayX" then
						CTrigger(PlayerID,{TVArrayX(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TNDeathsX" then
						CTrigger(PlayerID,{TNDeathsX(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TNDeaths" then
						CTrigger(PlayerID,{TNDeaths(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TCDeathsX" then
						CTrigger(PlayerID,{TCDeathsX(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TCDeaths" then
						CTrigger(PlayerID,{TCDeaths(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TCtrigX" then
						CTrigger(PlayerID,{TCtrigX(v[3],v[4],v[5],v[6],v[7],v[8],v[9])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TDeaths" then
						CTrigger(PlayerID,{TDeaths(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TDeathsX" then
						CTrigger(PlayerID,{TDeathsX(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TCommand" then
						CTrigger(PlayerID,{TCommand(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TBring" then
						CTrigger(PlayerID,{TBring(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TAccumulate" then
						CTrigger(PlayerID,{TAccumulate(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TCountdownTimer" then
						CTrigger(PlayerID,{TCountdownTimer(v[3],v[4])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TElapsedTime" then
						CTrigger(PlayerID,{TElapsedTime(v[3],v[4])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TKills" then
						CTrigger(PlayerID,{TKills(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TScore" then
						CTrigger(PlayerID,{TScore(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TOpponents" then
						CTrigger(PlayerID,{TOpponents(v[3],v[4],v[5])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TWariableX" then
						CTrigger(PlayerID,{TWariableX(v[3],v[4],v[5],v[6],v[7],v[8])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TWariable" then
						CTrigger(PlayerID,{TWariable(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TWArrayX" then
						CTrigger(PlayerID,{TWArrayX(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TCWar" then
						CTrigger(PlayerID,{TCWar(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TNWar" then
						CTrigger(PlayerID,{TNWar(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TCWAar" then
						CTrigger(PlayerID,{TCWAar(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					end
				elseif v[1] == "TT" then -- TT조건
					if v[2] == "TTMemoryX" then
						CTrigger(PlayerID,{TTMemoryX(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTMemory" then
						CTrigger(PlayerID,{TTMemory(v[3],v[4],v[5])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTLMemoryX" then
						CTrigger(PlayerID,{TTLMemoryX(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTLMemory" then
						CTrigger(PlayerID,{TTLMemory(v[3],v[4],v[5])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTCVar" then
						CTrigger(PlayerID,{TTCVar(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTCVAar" then
						CTrigger(PlayerID,{TTCVAar(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTVariableX" then
						CTrigger(PlayerID,{TTVariableX(v[3],v[4],v[5],v[6],v[7],v[8])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTVariable" then
						CTrigger(PlayerID,{TTVariable(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTVArrayX" then
						CTrigger(PlayerID,{TTVArrayX(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTNDeathsX" then
						CTrigger(PlayerID,{TTNDeathsX(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTNDeaths" then
						CTrigger(PlayerID,{TTNDeaths(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTCDeathsX" then
						CTrigger(PlayerID,{TTCDeathsX(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTCDeaths" then
						CTrigger(PlayerID,{TTCDeaths(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTCtrigX" then
						CTrigger(PlayerID,{TTCtrigX(v[3],v[4],v[5],v[6],v[7],v[8],v[9])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTDeaths" then
						CTrigger(PlayerID,{TTDeaths(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTDeathsX" then
						CTrigger(PlayerID,{TTDeathsX(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTCommand" then
						CTrigger(PlayerID,{TTCommand(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTBring" then
						CTrigger(PlayerID,{TTBring(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTAccumulate" then
						CTrigger(PlayerID,{TTAccumulate(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTCountdownTimer" then
						CTrigger(PlayerID,{TTCountdownTimer(v[3],v[4])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTElapsedTime" then
						CTrigger(PlayerID,{TTElapsedTime(v[3],v[4])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTKills" then
						CTrigger(PlayerID,{TTKills(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTScore" then
						CTrigger(PlayerID,{TTScore(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTOpponents" then
						CTrigger(PlayerID,{TTOpponents(v[3],v[4],v[5])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTWariableX" then
						CTrigger(PlayerID,{TTWariableX(v[3],v[4],v[5],v[6],v[7],v[8])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTWariable" then
						CTrigger(PlayerID,{TTWariable(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTWArrayX" then
						CTrigger(PlayerID,{TTWArrayX(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTCWar" then
						CTrigger(PlayerID,{TTCWar(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTNWar" then
						CTrigger(PlayerID,{TTNWar(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTCWAar" then
						CTrigger(PlayerID,{TTCWAar(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTbytecmp" then
						CTrigger(PlayerID,{TTbytecmp(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTbytecmpX" then
						CTrigger(PlayerID,{TTbytecmpX(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					end
				elseif v[1] == "AND" then -- AND조건
					local ANDCond = {}
					for p, q in pairs(v[2]) do
						if q[1] == "T" then -- T조건
							if q[2] == "TMemoryX" then
								table.insert(ANDCond,{TMemoryX(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TMemory" then
								table.insert(ANDCond,{TMemory(q[3],q[4],q[5])})
							elseif q[2] == "TCVar" then
								table.insert(ANDCond,{TCVar(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TCVAar" then
								table.insert(ANDCond,{TCVAar(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TVariableX" then
								table.insert(ANDCond,{TVariableX(q[3],q[4],q[5],q[6],q[7],q[8])})
							elseif q[2] == "TVariable" then
								table.insert(ANDCond,{TVariable(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TVArrayX" then
								table.insert(ANDCond,{TVArrayX(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TNDeathsX" then
								table.insert(ANDCond,{TNDeathsX(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TNDeaths" then
								table.insert(ANDCond,{TNDeaths(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TCDeathsX" then
								table.insert(ANDCond,{TCDeathsX(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TCDeaths" then
								table.insert(ANDCond,{TCDeaths(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TCtrigX" then
								table.insert(ANDCond,{TCtrigX(q[3],q[4],q[5],q[6],q[7],q[8],q[9])})
							elseif q[2] == "TDeaths" then
								table.insert(ANDCond,{TDeaths(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TDeathsX" then
								table.insert(ANDCond,{TDeathsX(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TCommand" then
								table.insert(ANDCond,{TCommand(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TBring" then
								table.insert(ANDCond,{TBring(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TAccumulate" then
								table.insert(ANDCond,{TAccumulate(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TCountdownTimer" then
								table.insert(ANDCond,{TCountdownTimer(q[3],q[4])})
							elseif q[2] == "TElapsedTime" then
								table.insert(ANDCond,{TElapsedTime(q[3],q[4])})
							elseif q[2] == "TKills" then
								table.insert(ANDCond,{TKills(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TScore" then
								table.insert(ANDCond,{TScore(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TOpponents" then
								table.insert(ANDCond,{TOpponents(q[3],q[4],q[5])})
							elseif q[2] == "TWariableX" then
								table.insert(ANDCond,{TWariableX(q[3],q[4],q[5],q[6],q[7],q[8])})
							elseif q[2] == "TWariable" then
								table.insert(ANDCond,{TWariable(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TWArrayX" then
								table.insert(ANDCond,{TWArrayX(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TCWar" then
								table.insert(ANDCond,{TCWar(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TNWar" then
								table.insert(ANDCond,{TNWar(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TCWAar" then
								table.insert(ANDCond,{TCWAar(q[3],q[4],q[5],q[6])})
							end
						elseif q[1] == "TT" then -- TT조건
							if q[2] == "TTMemoryX" then
								table.insert(ANDCond,{TTMemoryX(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTMemory" then
								table.insert(ANDCond,{TTMemory(q[3],q[4],q[5])})
							elseif q[2] == "TTLMemoryX" then
								table.insert(ANDCond,{TTLMemoryX(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTLMemory" then
								table.insert(ANDCond,{TTLMemory(q[3],q[4],q[5])})
							elseif q[2] == "TTCVar" then
								table.insert(ANDCond,{TTCVar(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TTCVAar" then
								table.insert(ANDCond,{TTCVAar(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTVariableX" then
								table.insert(ANDCond,{TTVariableX(q[3],q[4],q[5],q[6],q[7],q[8])})
							elseif q[2] == "TTVariable" then
								table.insert(ANDCond,{TTVariable(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TTVArrayX" then
								table.insert(ANDCond,{TTVArrayX(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TTNDeathsX" then
								table.insert(ANDCond,{TTNDeathsX(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TTNDeaths" then
								table.insert(ANDCond,{TTNDeaths(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTCDeathsX" then
								table.insert(ANDCond,{TTCDeathsX(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TTCDeaths" then
								table.insert(ANDCond,{TTCDeaths(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTCtrigX" then
								table.insert(ANDCond,{TTCtrigX(q[3],q[4],q[5],q[6],q[7],q[8],q[9])})
							elseif q[2] == "TTDeaths" then
								table.insert(ANDCond,{TTDeaths(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTDeathsX" then
								table.insert(ANDCond,{TTDeathsX(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TTCommand" then
								table.insert(ANDCond,{TTCommand(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTBring" then
								table.insert(ANDCond,{TTBring(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TTAccumulate" then
								table.insert(ANDCond,{TTAccumulate(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTCountdownTimer" then
								table.insert(ANDCond,{TTCountdownTimer(q[3],q[4])})
							elseif q[2] == "TTElapsedTime" then
								table.insert(ANDCond,{TTElapsedTime(q[3],q[4])})
							elseif q[2] == "TTKills" then
								table.insert(ANDCond,{TTKills(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTScore" then
								table.insert(ANDCond,{TTScore(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTOpponents" then
								table.insert(ANDCond,{TTOpponents(q[3],q[4],q[5])})
							elseif q[2] == "TTWariableX" then
								table.insert(ANDCond,{TTWariableX(q[3],q[4],q[5],q[6],q[7],q[8])})
							elseif q[2] == "TTWariable" then
								table.insert(ANDCond,{TTWariable(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TTWArrayX" then
								table.insert(ANDCond,{TTWArrayX(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TTCWar" then
								table.insert(ANDCond,{TTCWar(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TTNWar" then
								table.insert(ANDCond,{TTNWar(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTCWAar" then
								table.insert(ANDCond,{TTCWAar(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTbytecmp" then
								table.insert(ANDCond,{TTbytecmp(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTbytecmpX" then
								table.insert(ANDCond,{TTbytecmpX(q[3],q[4],q[5],q[6],q[7])})
							end
						else -- 일반 조건
							table.insert(ANDCond,{q})
						end
					end
					CTrigger(PlayerID,{ANDCond},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
				else -- 일반 조건
					CTrigger(PlayerID,{v},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
				end
			end
		end

		PushCondArr = TempArr
		CondLineArr = TempArr2
		PushActArr = TempArr3
		ActLineArr = TempArr4
		STPushTrigArr = TempArr5
		PushTrigArr = TempArr6
		PushTrigStack = TempArr7
		TTPushTrigArr = TTempArr
		TTPushCondArr = TTempArr2
		TTFCodeArr = TTempArr3
		TTModeArr = TTempArr4
		ORPushCondArr = {}
		ORFCodeArr = {}
		ORPopTrigLock = 0

		VarXAlloc = 0xFE00
		WarXAlloc = 0xFC00
		for j = 1, 16 do
			SVarXAlloc[j] = SVarXOrig[j]
		end
		VarXReleaseLock = 0
	end
end


function InitCtrig()
	for P = 1, 8 do

		local k = 1
		local Size = #CtrigInitArr[P]

		while k <= Size do
			if Size - k + 1 >= 64 then
				local X = {}
				for i = 0, 63 do
					table.insert(X, CtrigInitArr[P][k])
					k = k + 1
				end
				Trigger {
						players = {P-1},
						conditions = {
							Label(0);
						},
						actions = {
							X,
						},
					}
			else
				local X = {}
				repeat
					table.insert(X, CtrigInitArr[P][k])
					k = k + 1
				until k == Size + 1
				Trigger {
						players = {P-1},
						conditions = {
							Label(0);
						},
						actions = {
							X,
						},
					}
			end
		end
	end
end

function FlagIndex(FlagID)
	return (FlagID/480) + (FlagID%480)*0x100000 + 0x0000FFE1
end

function PopCondArr(Conditions)
	if TPopTrigLock == 0 then
		if Conditions ~= nil then
			StackArrptr = 0
			for i, Cond in pairs(Conditions) do
				if Cond == "TCond" then
					StackArrptr = StackArrptr + 1
					Conditions[i] = PushCondArr[StackArrptr]
					for k = 1, CondLineArr[StackArrptr] do
						table.insert(PushCondStack,i)
					end
				end
			end
			PushCondArr = {}
		end
	end
	return Conditions
end

function PopActArr(Actions)
	if TPopTrigLock == 0 then
		if Actions ~= nil then
			StackArrptr = 0
			for i, Act in pairs(Actions) do
				if Act == "TAct" then
					StackArrptr  = StackArrptr + 1
					Actions[i] = PushActArr[StackArrptr]
					for k = 1, ActLineArr[StackArrptr] do
						table.insert(PushActStack,i)
					end
				end
			end
			PushActArr = {}
		end
	end
	return Actions
end

function PopTrigArr(PlayerID,ActPushLine,CondPushLine)
	if TPopTrigLock == 0 then
		CondStackCount = 0
		for k, v in pairs(PushCondStack) do
			CondStackCount = CondStackCount + 1
		end

		for i, Act in pairs(PushTrigArr) do

			if CondPushLine == nil then
				CondPushLine = 0
			end
			if ActPushLine == nil then
				ActPushLine = 0
			end

			if Act[5][5] >= (0x128/4) then
				Act[4][6] = Act[4][6] + (ActPushLine + PushActStack[i-CondStackCount]) * (0x20/4)
				Act[5][5] = Act[5][5] + (ActPushLine + PushActStack[i-CondStackCount]) * (0x20/4)
			else 
				Act[4][6] = Act[4][6] + (CondPushLine + PushCondStack[i]) * (0x14/4)
				Act[5][5] = Act[5][5] + (CondPushLine + PushCondStack[i]) * (0x14/4)
			end

			Act[4][6] = Act[4][6] + (0x970/4) * PushTrigStack
			Act[5][5] = Act[5][5] + (0x970/4) * PushTrigStack

			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					Act,
				},
				flag = {Preserved}
			}

			PushTrigStack = PushTrigStack - 1
		end

		PushTrigArr = {}
		PushTrigStack = 0
		PushCondArr = {}
		PushCondStack = {}
		PushActArr = {}
		PushActStack = {}
		CondStackCount = 0
		StackArrptr = 0
		CondLineArr = {}
		ActLineArr = {}
	end
end


function TTPopTrigArr(PlayerID)

	if TTPopTrigLock == 0 then

		for i, TargetCond in pairs(TTPushCondArr) do
			local Size = 0
			if TTPushTrigArr[i] ~= nil then
				for k, v in pairs(TTPushTrigArr[i]) do
					Size = Size + 1
				end
			end
			local Stack = Size
			local FCode = TTFCodeArr[i]

			if TTModeArr[i] == 0 then
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,1,FCode),SetCtrig1X("X","X",0x28,Size+1,SetTo,Exactly*65536,0xFF0000)})

				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[4][6] = Act[4][6] + (0x970/4) * Stack
						Act[5][5] = Act[5][5] + (0x970/4) * Stack

						Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end

				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode);
					},
					flag = {Preserved}
				}
			elseif TTModeArr[i] == 1 then
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode),
							SetCtrigX("X","X",0x4,Size+1,SetTo,"X","X",0x0,0,Size+2),
							SetCtrig1X("X","X",0x15C,Size+1,SetTo,1),
							SetCtrig1X("X","X",0x28,Size+1,SetTo,AtLeast*65536,0xFF0000)})

				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[4][6] = Act[4][6] + (0x970/4) * Stack
						Act[5][5] = Act[5][5] + (0x970/4) * Stack

						Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}
				DoActionsX(PlayerID,{SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1),
									SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1),
									SetCtrig1X("X","X",0x15C,-1,SetTo,0),
									SetCtrig1X("X","X",0x28,-1,SetTo,Exactly*65536,0xFF0000)})
			elseif TTModeArr[i] == 2 then
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode),
							SetCtrigX("X","X",0x4,Size+1,SetTo,"X","X",0x0,0,Size+2),
							SetCtrig1X("X","X",0x15C,Size+1,SetTo,1),
							SetCtrig1X("X","X",0x28,Size+1,SetTo,AtMost*65536,0xFF0000)})

				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[4][6] = Act[4][6] + (0x970/4) * Stack
						Act[5][5] = Act[5][5] + (0x970/4) * Stack

						Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}
				DoActionsX(PlayerID,{SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1),
									SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1),
									SetCtrig1X("X","X",0x15C,-1,SetTo,0),
									SetCtrig1X("X","X",0x28,-1,SetTo,Exactly*65536,0xFF0000)})
			elseif TTModeArr[i] == 3 then -- LExactly
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode)})

				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[6][6] = Act[6][6] + (0x970/4) * Stack -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) * Stack -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) * Stack -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) * Stack -- EPD NEXT

						Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}

			elseif TTModeArr[i] == 4 then -- LNotSame
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,1,FCode)})

				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[6][6] = Act[6][6] + (0x970/4) * Stack -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) * Stack -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) * Stack -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) * Stack -- EPD NEXT

						Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode);
					},
					flag = {Preserved}
				}

			elseif TTModeArr[i] == 5 then -- LAtLeast
				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[6][6] = Act[6][6] + (0x970/4) * (2*Stack+1) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) * (2*Stack+1) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) * (2*Stack+1) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) * (2*Stack+1) -- EPD NEXT

						Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Act[6][6] = Act[6][6] + (0x970/4) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) -- EPD NEXT

						Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode),
					SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2),
					SetCtrig1X("X","X",0x28,1,SetTo,AtMost*65536,0xFF0000),
					SetCtrig1X("X","X",0x28+0x14,3,SetTo,AtLeast*65536,0xFF0000),
					SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,4),
				})

				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						TargetCond[1],
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCDeaths("X",SetTo,1,FCode);
						},
						flag = {Preserved}
					}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}

			elseif TTModeArr[i] == 6 then -- LBelow
				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[6][6] = Act[6][6] + (0x970/4) * (2*Stack+1) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) * (2*Stack+1) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) * (2*Stack+1) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) * (2*Stack+1) -- EPD NEXT

						Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Act[6][6] = Act[6][6] + (0x970/4) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) -- EPD NEXT

						Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,1,FCode),
					SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2),
					SetCtrig1X("X","X",0x28,1,SetTo,AtMost*65536,0xFF0000),
					SetCtrig1X("X","X",0x28+0x14,3,SetTo,AtLeast*65536,0xFF0000),
					SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,4),
				})

				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						TargetCond[1],
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCDeaths("X",SetTo,0,FCode);
						},
						flag = {Preserved}
					}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode);
					},
					flag = {Preserved}
				}

			elseif TTModeArr[i] == 7 then -- LAtMost
				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[6][6] = Act[6][6] + (0x970/4) * (2*Stack+1) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) * (2*Stack+1) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) * (2*Stack+1) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) * (2*Stack+1) -- EPD NEXT

						Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Act[6][6] = Act[6][6] + (0x970/4) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) -- EPD NEXT

						Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode),
					SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2),
					SetCtrig1X("X","X",0x28,1,SetTo,AtLeast*65536,0xFF0000),
					SetCtrig1X("X","X",0x28+0x14,3,SetTo,AtMost*65536,0xFF0000),
					SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,4),
				})

				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						TargetCond[1],
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCDeaths("X",SetTo,1,FCode);
						},
						flag = {Preserved}
					}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}

			elseif TTModeArr[i] == 8 then -- LAbove
				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[6][6] = Act[6][6] + (0x970/4) * (2*Stack+1) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) * (2*Stack+1) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) * (2*Stack+1) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) * (2*Stack+1) -- EPD NEXT

						Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Act[6][6] = Act[6][6] + (0x970/4) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) -- EPD NEXT

						Trigger {
							players = {ParsePlayer(PlayerID)},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,1,FCode),
					SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2),
					SetCtrig1X("X","X",0x28,1,SetTo,AtLeast*65536,0xFF0000),
					SetCtrig1X("X","X",0x28+0x14,3,SetTo,AtMost*65536,0xFF0000),
					SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,4),
				})

				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						TargetCond[1],
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCDeaths("X",SetTo,0,FCode);
						},
						flag = {Preserved}
					}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode);
					},
					flag = {Preserved}
				}

			elseif TTModeArr[i] == 9 then -- bytecmp(X)
				local STTemp = STPopTrigLock
				STPopTrigLock = 1
				if TargetCond[1] == "bytecmp" then
					 f_bytecmp(PlayerID,FCode,TargetCond[2],TargetCond[3],TargetCond[4],TargetCond[5])
				else
					 f_bytecmpX(PlayerID,FCode,TargetCond[2],TargetCond[3],TargetCond[4],TargetCond[5],TargetCond[6])
				end
				STPopTrigLock = STTemp
			end
		end
		TTFCodeArr = {}
		TTModeArr = {}
		TTPushTrigArr = {}
		TTPushCondArr = {}
	end
end

function STPopTrigArr(PlayerID)
	if STPopTrigLock == 0 and STPushTrigArr[1] ~= nil then
		STPopTrigLock = 1
		local _TPopTrigLockTemp = _TPopTrigLock
		local ORPopTrigLockTemp = ORPopTrigLock
		_TPopTrigLock = 1
		ORPopTrigLock = 1
		TTPopTrigLock = 1
		TPopTrigLock = 1
		--[[
		local VarXArr = {}
		for i = 0xFF00, VarXAlloc-1 do
			table.insert(VarXArr,SetCtrig1X("X",i,0x15C,0,SetTo,0))
		end
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				VarXArr,
			},
			flag = {Preserved}
		}

--[[ STPop Clear List
CMov
CMovX
CRead
CReadX
f_Read
f_ReadX

SCast
SMov
SMovX

f_Cast
LMov
LMovX
LRead
LReadX

MovX
MovW
MovS

Clear -> Mask2 = 0xFFFFFFFF
Set 0x15C -> Deviation (없을시 0), Mask2
Mov 0x15C -> Value, Mask
]]--
		for k, v in pairs(STPushTrigArr) do
			local Func = v[1]
			table.remove(v,1)
			_G[Func](PlayerID,table.unpack(v))
		end
		STPopTrigLock = 0
		_TPopTrigLock = _TPopTrigLockTemp
		ORPopTrigLock = ORPopTrigLockTemp
		TTPopTrigLock = 0
		TPopTrigLock = 0
	end
	STPushTrigArr = {}
	if VarXReleaseLock == 0 then
		VarXAlloc = 0xFE00
		WarXAlloc = 0xFC00
		for j = 1, 16 do
			SVarXAlloc[j] = SVarXOrig[j]
		end
	elseif VarXReleaseLock == 2 then
		VarXAlloc = _TPushVarXAlloc[1]
		WarXAlloc = _TPushVarXAlloc[2]
		for j = 1, 16 do
			SVarXAlloc[j] = _TPushVarXAlloc[3][j]
		end
	end
end

function _byteConvert(Source)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}
	local Size = #Source

	table.insert(STPushTrigArr,{"CbyteConvert",TempData,Source}) 

	VarXAlloc = VarXAlloc + 4*(math.ceil(Size/4)+1)
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _byteConvertF(Source,Size,Distance)
	if Source == nil then
		Source = "X"
	end
	if Size == nil then
		Size = "X"
	end
	if Distance == nil then
		Distance = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"f_byteConvert",TempData,Source,Size,Distance}) 

	if type(Size) ~= "number" then
		_byteConvertF_InputData_Error()
	end

	VarXAlloc = VarXAlloc + 4*(math.ceil(Size/4)+1)
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _byteConvertFX(Source,SourceX,Size,Distance)
	if Source == nil then
		Source = "X"
	end
	if SourceX == nil then
		SourceX = "X"
	end
	if Size == nil then
		Size = "X"
	end
	if Distance == nil then
		Distance = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"f_byteConvertX",TempData,Source,SourceX,Size,Distance}) 

	if type(Size) ~= "number" then
		_byteConvertFX_InputData_Error()
	end

	VarXAlloc = VarXAlloc + 4*(math.ceil(Size/4)+1)
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _MovS(Number,Source,Mode,Mask) -- SVA -> SV
	if Number == nil then
		Number = "X"
	end
	if Source == nil then
		Source = "X"
	end
	if Mode == nil then
		Mode = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Number < 1 or Number > 16 then
		_MovS_InputData_Error()
	end
	local Temp = SVarXAlloc[Number]
	local TempData = {"X",Temp,0,"SV",Number}

	table.insert(STPushTrigArr,{"MovS",TempData,Source,Mode,Mask,1})

	SVarXAlloc[Number] = SVarXAlloc[Number] + 1
	if SVarXAlloc[Number] > MAXSVAlloc[Number] then
		MAXSVAlloc[Number] = SVarXAlloc[Number]
	end
	return TempData
end

function _SMov(Number,Source,Mode,Deviation,Mask) -- _xN -> SV
	if Number == nil then
		Number = "X"
	end
	if Source == nil then
		Source = "X"
	end
	if Mode == nil then
		Mode = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Number < 1 or Number > 16 then
		_SMov_InputData_Error()
	end
	local Temp = SVarXAlloc[Number]
	local TempData = {"X",Temp,0,"SV",Number}

	table.insert(STPushTrigArr,{"SMov",TempData,Source,Mode,Deviation,Mask,1})

	SVarXAlloc[Number] = SVarXAlloc[Number] + 1
	if SVarXAlloc[Number] > MAXSVAlloc[Number] then
		MAXSVAlloc[Number] = SVarXAlloc[Number]
	end
	return TempData
end

function _SCopy(SVData,DestLine,SourceLine)-- SVData -> SVData
	if SVData == nil then
		SVData = "X"
	end
	if DestLine == nil then
		DestLine = "X"
	end
	if SourceLine == nil then
		SourceLine = "X"
	end
	table.insert(STPushTrigArr,{"SCopy",SVData,DestLine,SourceLine})
	return SVData
end

function _CastS(Number,Source,Deviation,Mask) -- V(A) -> SV
	if Number == nil then
		Number = "X"
	end
	if Source == nil then
		Source = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Number < 1 or Number > 16 or Source[4] == "SV" or Source[4] == "SVA" then
		_CastS_InputData_Error()
	end
	local Temp = SVarXAlloc[Number]
	local TempData = {"X",Temp,0,"SV",Number}

	table.insert(STPushTrigArr,{"SCast",TempData,Source,Deviation,Mask,1})

	SVarXAlloc[Number] = SVarXAlloc[Number] + 1
	if SVarXAlloc[Number] > MAXSVAlloc[Number] then
		MAXSVAlloc[Number] = SVarXAlloc[Number]
	end
	return TempData
end

function _SCast(Source,Deviation,Mask) -- SV(A) -> V
	if Source == nil then
		Source = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Source[4] == "V" or Source[4] == "VA" then
		_SCast_InputData_Error()
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"SCast",TempData,Source,Deviation,Mask,1})

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _TSMem(Source,Address,Next,OffsetFlag) -- SV(A)_EPD -> V
	if Source == nil then
		Source = "X"
	end
	if Address == nil then
		Address = "X"
	end
	if Next == nil then
		Next = "X"
	end
	if OffsetFlag == nil then
		OffsetFlag = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"TSMem",TempData,Source,Address,Next,OffsetFlag})

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

--------------------------------------------------------------------------------------

function _TLMem(Source,Address,Next,OffsetFlag)  
	if Source == nil then
		Source = "X"
	end
	if Address == nil then
		Address = "X"
	end
	if Next == nil then
		Next = "X"
	end
	if OffsetFlag == nil then
		OffsetFlag = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"TLMem",TempData,Source,Address,Next,OffsetFlag})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _Cast(Dest,Source,Deviation,Mask) -- W(A) -> V
	if Dest == nil then
		Dest = "X"
	end
	if Source == nil then
		Source = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Source[4] == "V" or Source[4] == "VA" then
		_Cast_InputData_Error()
	end

	if Dest ~= 0 and Dest ~= 1 then
		_Cast_InputData_Error()
	end

	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"f_Cast",{TempData,Dest},Source,Deviation,Mask,1})

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _CastW(Source,Deviation,Mask) -- V(A) -> W
	if Source == nil then
		Source = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Source[4] == "W" or Source[4] == "WA" then
		_CastW_InputData_Error()
	end

	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_Cast",TempData,Source,Deviation,Mask,1})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _iCast(Source) -- W(A) -> V
	if Source == nil then
		Source = "X"
	end
	if Source[4] == "V" or Source[4] == "VA" then
		_iCast_InputData_Error()
	end

	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"f_iCast",TempData,Source})

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _iCastW(Source) -- V(A) -> W
	if Source == nil then
		Source = "X"
	end
	if Source[4] == "W" or Source[4] == "WA" then
		_iCastW_InputData_Error()
	end

	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_iCast",TempData,Source})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LMovX(Source,Mode,Mask,Deviation) -- _x2 -> W
	if Source == nil then
		Source = "X"
	end
	if Mode == nil then
		Mode = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LMovX",TempData,Source,Mode,Mask,Deviation,1})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LMov(Source,Mask,Deviation) -- _x2 -> W
	if Source == nil then
		Source = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LMov",TempData,Source,Deviation,Mask,1})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LRead(Source,Mask) -- _x2 -> W
	if Source == nil then
		Source = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LRead",Source,TempData,Mask,1})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LReadX(Source,Multiplier,Mask) -- _x2 -> W
	if Source == nil then
		Source = "X"
	end
	if Multiplier == nil then
		Multiplier = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LReadX",Source,TempData,Multiplier,Mask,1})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LAdd(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LAdd",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LSub(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LSub",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LiSub(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LiSub",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LNeg(Source) 
	if Source == nil then
		Source = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LNeg",TempData,Source})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LAbs(Source) 
	if Source == nil then
		Source = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LAbs",TempData,Source})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LRand() 
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LRand",TempData})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LAnd(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LAnd",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LOr(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LOr",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LXor(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LXor",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LNot(Source) 
	if Source == nil then
		Source = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LNot",TempData,Source})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LlShift(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LlShift",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LMul(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LMul",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LiMul(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LiMul",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LDiv(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LDiv",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LiDiv(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LiDiv",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LMod(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LMod",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LiMod(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LiMod",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end
-- 중간 연산 함수(_) -------------------------------------------------------------------

function _TMem(Source,Address,Next,OffsetFlag)  
	if Source == nil then
		Source = "X"
	end
	if Address == nil then
		Address = "X"
	end
	if Next == nil then
		Next = "X"
	end
	if OffsetFlag == nil then
		OffsetFlag = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"TMem",TempData,Source,Address,Next,OffsetFlag})

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _MovX(Source,Mode,Mask,Deviation)
	if Source == nil then
		Source = "X"
	end
	if Mode == nil then
		Mode = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"CMovX",TempData,Source,Mode,Mask,Deviation,1})

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Mov(Source,Mask,Deviation)
	if Source == nil then
		Source = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		table.insert(STPushTrigArr,{"CMov",TempData,Source,Deviation,Mask,1}) -- A << 1
	elseif Source == "Cp" then
		Mov_InputData_Error()
	elseif Source[4] == "V" then
		table.insert(STPushTrigArr,{"CMov",TempData,Source,Deviation,Mask,1}) -- A << X
	elseif Source[4] == "VA" then
		table.insert(STPushTrigArr,{"CMov",TempData,Source,Deviation,Mask,1}) -- A << VA
	elseif Source[4] == "A" then
		Mov_InputData_Error()
	else
		Mov_InputData_Error()
	end

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Read(Source,Mask,Deviation)
	if Source == nil then
		Source = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"CRead",TempData,Source,Deviation,Mask,"X",1}) -- A << 0x58A364, Cp, EPD(X), Mem

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _ReadX(Source,Mask,Multiplier,Deviation)
	if Source == nil then
		Source = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Multiplier == nil then
		Multiplier = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"CReadX",TempData,Source,Deviation,Mask,Multiplier,1}) -- A << 0x58A364, Cp, EPD(X), Mem

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _EPDRead(Source)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"CRead",TempData,Source,"X","X",1}) -- A << EPD(0x58A364, Cp, EPD(X), Mem)

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _ReadF(Source,Mask)
	if Source == nil then
		Source = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"f_Read",Source,TempData,nil,Mask,1}) -- A << 0x58A364, Cp, EPD(X), Mem

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _ReadFX(Source,Mask,Multiplier)
	if Source == nil then
		Source = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Multiplier == nil then
		Multiplier = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"f_ReadX",Source,TempData,Multiplier,Mask,1}) -- A << 0x58A364, Cp, EPD(X), Mem

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _EPDReadF(Source)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"f_Read",Source,nil,TempData,0xFFFFFFFF,1})-- A << EPD(0x58A364, Cp, EPD(X), Mem)

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _EPD(Source)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		EPD_InputData_Error()
	elseif Source == "Cp" then
		EPD_InputData_Error()
	elseif Source[4] == "V" then
		table.insert(STPushTrigArr,{"f_EPD",TempData,Source}) -- A << EPD(V)
	elseif Source[4] == "VA" then
		table.insert(STPushTrigArr,{"f_EPD",TempData,Source}) -- A << EPD(VA) 
	elseif Source[4] == "A" then
		EPD_InputData_Error()
	else
		EPD_InputData_Error()
	end

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _EPDX(Source)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		EPD_InputData_Error()
	elseif Source == "Cp" then
		EPD_InputData_Error()
	elseif Source[4] == "V" then
		table.insert(STPushTrigArr,{"f_EPDX",TempData,Source}) -- A << EPD(V)
	elseif Source[4] == "VA" then
		table.insert(STPushTrigArr,{"f_EPDX",TempData,Source}) -- A << EPD(VA) 
	elseif Source[4] == "A" then
		EPD_InputData_Error()
	else
		EPD_InputData_Error()
	end

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Add(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Add_InputData_Error()
	elseif Source == "Cp" then
		Add_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CAdd",TempData,Source,Operand}) -- A << X + 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CAdd",TempData,Source,Operand}) -- A << X + Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CAdd",TempData,Source,Operand}) -- A << X + VA
		elseif Operand[4] == "A" then
			Add_InputData_Error()
		else
			Add_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CAdd",TempData,Source,Operand}) -- A << VA + 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CAdd",TempData,Source,Operand}) -- A << VA + Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CAdd",TempData,Source,Operand}) -- A << VA + VA
		elseif Operand[4] == "A" then
			Add_InputData_Error()
		else
			Add_InputData_Error()
		end
	elseif Source[4] == "A" then
		Add_InputData_Error()
	else
		Add_InputData_Error()
	end

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Sub(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Sub_InputData_Error()
	elseif Source == "Cp" then
		Sub_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CSub",TempData,Source,Operand}) -- A << X - 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CSub",TempData,Source,Operand}) -- A << X - Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CSub",TempData,Source,Operand}) -- A << X - VA
		elseif Operand[4] == "A" then
			Sub_InputData_Error()
		else
			Sub_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CSub",TempData,Source,Operand}) -- A << VA - 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CSub",TempData,Source,Operand}) -- A << VA - Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CSub",TempData,Source,Operand}) -- A << VA - VA
		elseif Operand[4] == "A" then
			Sub_InputData_Error()
		else
			Sub_InputData_Error()
		end
	else
		Sub_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _iSub(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		iSub_InputData_Error()
	elseif Source == "Cp" then
		iSub_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CiSub",TempData,Source,Operand}) -- A << X - 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CiSub",TempData,Source,Operand}) -- A << X - Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CiSub",TempData,Source,Operand}) -- A << X - VA
		elseif Operand[4] == "A" then
			iSub_InputData_Error()
		else
			iSub_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CiSub",TempData,Source,Operand}) -- A << VA - 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CiSub",TempData,Source,Operand}) -- A << VA - Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CiSub",TempData,Source,Operand}) -- A << VA - VA
		elseif Operand[4] == "A" then
			iSub_InputData_Error()
		else
			iSub_InputData_Error()
		end
	else
		iSub_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Neg(Source)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Neg_InputData_Error()
	elseif Source == "Cp" then
		Neg_InputData_Error()
	elseif Source[4] == "V" then
		table.insert(STPushTrigArr,{"CNeg",TempData,Source}) -- A << -X 
	elseif Source[4] == "VA" then
		table.insert(STPushTrigArr,{"CNeg",TempData,Source}) -- A << -VA 
	elseif Source[4] == "A" then
		Neg_InputData_Error()
	else
		Neg_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Mul(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Mul_InputData_Error()
	elseif Source == "Cp" then
		Mul_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CMul",TempData,Source,Operand}) -- A << X * 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_Mul",TempData,Source,Operand}) -- A << X * Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_Mul",TempData,Source,Operand}) -- A << X * VA
		elseif Operand[4] == "A" then
			Mul_InputData_Error()
		else
			Mul_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CMul",TempData,Source,Operand}) -- A << VA * 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_Mul",TempData,Source,Operand}) -- A << VA * Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_Mul",TempData,Source,Operand}) -- A << VA * VA
		elseif Operand[4] == "A" then
			Mul_InputData_Error()
		else
			Mul_InputData_Error()
		end
	else
		Mul_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _MulX(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		MulX_InputData_Error()
	elseif Source == "Cp" then
		MulX_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_Mul",TempData,Source,Operand}) -- A << X * 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CMul",TempData,Source,Operand}) -- A << X * Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CMul",TempData,Source,Operand}) -- A << X * VA
		elseif Operand[4] == "A" then
			MulX_InputData_Error()
		else
			MulX_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_Mul",TempData,Source,Operand}) -- A << VA * 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CMul",TempData,Source,Operand}) -- A << VA * Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CMul",TempData,Source,Operand}) -- A << VA * VA
		elseif Operand[4] == "A" then
			MulX_InputData_Error()
		else
			MulX_InputData_Error()
		end
	else
		MulX_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _iMul(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		iMul_InputData_Error()
	elseif Source == "Cp" then
		iMul_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_iMul",TempData,Source,Operand}) -- A << X * 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_iMul",TempData,Source,Operand}) -- A << X * Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_iMul",TempData,Source,Operand}) -- A << X * VA
		elseif Operand[4] == "A" then
			iMul_InputData_Error()
		else
			iMul_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_iMul",TempData,Source,Operand}) -- A << VA * 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_iMul",TempData,Source,Operand}) -- A << VA * Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_iMul",TempData,Source,Operand}) -- A << VA * VA
		elseif Operand[4] == "A" then
			iMul_InputData_Error()
		else
			iMul_InputData_Error()
		end
	else
		iMul_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Div(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Div_InputData_Error()
	elseif Source == "Cp" then
		Div_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CDiv",TempData,Source,Operand}) -- A << X / 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_Div",TempData,Source,Operand}) -- A << X / Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_Div",TempData,Source,Operand}) -- A << X / VA
		elseif Operand[4] == "A" then
			Div_InputData_Error()
		else
			Div_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CDiv",TempData,Source,Operand}) -- A << VA / 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_Div",TempData,Source,Operand}) -- A << VA / Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_Div",TempData,Source,Operand}) -- A << VA / VA
		elseif Operand[4] == "A" then
			Div_InputData_Error()
		else
			Div_InputData_Error()
		end
	else
		Div_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _iDiv(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		iDiv_InputData_Error()
	elseif Source == "Cp" then
		iDiv_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CiDiv",TempData,Source,Operand}) -- A << X / 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_iDiv",TempData,Source,Operand}) -- A << X / Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_iDiv",TempData,Source,Operand}) -- A << X / VA
		elseif Operand[4] == "A" then
			iDiv_InputData_Error()
		else
			iDiv_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CiDiv",TempData,Source,Operand}) -- A << VA / 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_iDiv",TempData,Source,Operand}) -- A << VA / Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_iDiv",TempData,Source,Operand}) -- A << VA / VA
		elseif Operand[4] == "A" then
			iDiv_InputData_Error()
		else
			iDiv_InputData_Error()
		end
	else
		iDiv_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Mod(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Mod_InputData_Error()
	elseif Source == "Cp" then
		Mod_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CMod",TempData,Source,Operand}) -- A << X % 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_Mod",TempData,Source,Operand}) -- A << X % Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_Mod",TempData,Source,Operand}) -- A << X % VA
		elseif Operand[4] == "A" then
			Mod_InputData_Error()
		else
			Mod_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CMod",TempData,Source,Operand}) -- A << VA % 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_Mod",TempData,Source,Operand}) -- A << VA % Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_Mod",TempData,Source,Operand}) -- A << VA % VA
		elseif Operand[4] == "A" then
			Mod_InputData_Error()
		else
			Mod_InputData_Error()
		end
	else
		Mod_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _iMod(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		iMod_InputData_Error()
	elseif Source == "Cp" then
		iMod_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CiMod",TempData,Source,Operand}) -- A << X % 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_iMod",TempData,Source,Operand}) -- A << X % Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_iMod",TempData,Source,Operand}) -- A << X % VA
		elseif Operand[4] == "A" then
			iMod_InputData_Error()
		else
			iMod_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CiMod",TempData,Source,Operand}) -- A << VA % 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_iMod",TempData,Source,Operand}) -- A << VA % Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_iMod",TempData,Source,Operand}) -- A << VA % VA
		elseif Operand[4] == "A" then
			iMod_InputData_Error()
		else
			iMod_InputData_Error()
		end
	else
		iMod_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _DivX(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		DivX_InputData_Error()
	elseif Source == "Cp" then
		DivX_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_Div",TempData,Source,Operand}) -- A << X / 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CDiv",TempData,Source,Operand}) -- A << X / Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CDiv",TempData,Source,Operand}) -- A << X / VA
		elseif Operand[4] == "A" then
			DivX_InputData_Error()
		else
			DivX_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_Div",TempData,Source,Operand}) -- A << VA / 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CDiv",TempData,Source,Operand}) -- A << VA / Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CDiv",TempData,Source,Operand}) -- A << VA / VA
		elseif Operand[4] == "A" then
			DivX_InputData_Error()
		else
			DivX_InputData_Error()
		end
	else
		DivX_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _iDivX(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		iDivX_InputData_Error()
	elseif Source == "Cp" then
		iDivX_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_iDiv",TempData,Source,Operand}) -- A << X / 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CiDiv",TempData,Source,Operand}) -- A << X / Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CiDiv",TempData,Source,Operand}) -- A << X / VA
		elseif Operand[4] == "A" then
			iDivX_InputData_Error()
		else
			iDivX_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_iDiv",TempData,Source,Operand}) -- A << VA / 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CiDiv",TempData,Source,Operand}) -- A << VA / Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CiDiv",TempData,Source,Operand}) -- A << VA / VA
		elseif Operand[4] == "A" then
			iDivX_InputData_Error()
		else
			iDivX_InputData_Error()
		end
	else
		iDivX_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _ModX(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		ModX_InputData_Error()
	elseif Source == "Cp" then
		ModX_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_Mod",TempData,Source,Operand}) -- A << X % 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CMod",TempData,Source,Operand}) -- A << X % Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CMod",TempData,Source,Operand}) -- A << X % VA
		elseif Operand[4] == "A" then
			ModX_InputData_Error()
		else
			ModX_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_Mod",TempData,Source,Operand}) -- A << VA % 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CMod",TempData,Source,Operand}) -- A << VA % Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CMod",TempData,Source,Operand}) -- A << VA % VA
		elseif Operand[4] == "A" then
			ModX_InputData_Error()
		else
			ModX_InputData_Error()
		end
	else
		ModX_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _iModX(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		iModX_InputData_Error()
	elseif Source == "Cp" then
		iModX_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_iMod",TempData,Source,Operand}) -- A << X % 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CiMod",TempData,Source,Operand}) -- A << X % Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CiMod",TempData,Source,Operand}) -- A << X % VA
		elseif Operand[4] == "A" then
			iModX_InputData_Error()
		else
			iModX_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_iMod",TempData,Source,Operand}) -- A << VA % 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CiMod",TempData,Source,Operand}) -- A << VA % Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CiMod",TempData,Source,Operand}) -- A << VA % VA
		elseif Operand[4] == "A" then
			iModX_InputData_Error()
		else
			iModX_InputData_Error()
		end
	else
		iModX_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Not(Source)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Not_InputData_Error()
	elseif Source == "Cp" then
		Not_InputData_Error()
	elseif Source[4] == "V" then
		table.insert(STPushTrigArr,{"CNot",TempData,Source}) -- A << ~X 
	elseif Source[4] == "VA" then
		table.insert(STPushTrigArr,{"CNot",TempData,Source}) -- A << ~VA
	elseif Source[4] == "A" then
		Not_InputData_Error()
	else
		Not_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Or(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Or_InputData_Error()
	elseif Source == "Cp" then
		Or_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"COr",TempData,Source,Operand}) -- A << X | 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"COr",TempData,Source,Operand}) -- A << X | Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"COr",TempData,Source,Operand}) -- A << X | VA
		elseif Operand[4] == "A" then
			Or_InputData_Error()
		else
			Or_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"COr",TempData,Source,Operand}) -- A << VA | 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"COr",TempData,Source,Operand}) -- A << VA | Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"COr",TempData,Source,Operand}) -- A << VA | VA
		elseif Operand[4] == "A" then
			Or_InputData_Error()
		else
			Or_InputData_Error()
		end
	else
		Or_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _lShift(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		lShift_InputData_Error()
	elseif Source == "Cp" then
		lShift_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"ClShift",TempData,Source,Operand}) -- A << X & 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"ClShift",TempData,Source,Operand}) -- A << X & Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"ClShift",TempData,Source,Operand}) -- A << X & VA
		elseif Operand[4] == "A" then
			lShift_InputData_Error()
		else
			lShift_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"ClShift",TempData,Source,Operand}) -- A << VA & 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"ClShift",TempData,Source,Operand}) -- A << VA & Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"ClShift",TempData,Source,Operand}) -- A << VA & VA
		elseif Operand[4] == "A" then
			lShift_InputData_Error()
		else
			lShift_InputData_Error()
		end
	else
		lShift_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _And(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		And_InputData_Error()
	elseif Source == "Cp" then
		And_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CAnd",TempData,Source,Operand}) -- A << X & 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CAnd",TempData,Source,Operand}) -- A << X & Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CAnd",TempData,Source,Operand}) -- A << X & VA
		elseif Operand[4] == "A" then
			And_InputData_Error()
		else
			And_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CAnd",TempData,Source,Operand}) -- A << VA & 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CAnd",TempData,Source,Operand}) -- A << VA & Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CAnd",TempData,Source,Operand}) -- A << VA & VA
		elseif Operand[4] == "A" then
			And_InputData_Error()
		else
			And_InputData_Error()
		end
	else
		And_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Xor(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Xor_InputData_Error()
	elseif Source == "Cp" then
		Xor_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CXor",TempData,Source,Operand}) -- A << X ^ 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CXor",TempData,Source,Operand}) -- A << X ^ Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CXor",TempData,Source,Operand}) -- A << X ^ VA
		elseif Operand[4] == "A" then
			Xor_InputData_Error()
		else
			Xor_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CXor",TempData,Source,Operand}) -- A << VA ^ 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CXor",TempData,Source,Operand}) -- A << VA ^ Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CXor",TempData,Source,Operand}) -- A << VA ^ VA
		elseif Operand[4] == "A" then
			Xor_InputData_Error()
		else
			Xor_InputData_Error()
		end
	else
		Xor_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Abs(Source)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Abs_InputData_Error()
	elseif Source == "Cp" then
		Abs_InputData_Error()
	elseif Source[4] == "V" then
		table.insert(STPushTrigArr,{"f_Abs",TempData,Source}) -- A << |X|
	elseif Source[4] == "VA" then
		table.insert(STPushTrigArr,{"f_Abs",TempData,Source}) -- A << |VA|
	elseif Source[4] == "A" then
		Abs_InputData_Error()
	else
		Abs_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Sqrt(Source)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Sqrt_InputData_Error()
	elseif Source == "Cp" then
		Sqrt_InputData_Error()
	elseif Source[4] == "V" then
		table.insert(STPushTrigArr,{"f_Sqrt",TempData,Source}) -- A << √X
	elseif Source[4] == "VA" then
		table.insert(STPushTrigArr,{"f_Sqrt",TempData,Source}) -- A << √VA
	elseif Source[4] == "A" then
		Sqrt_InputData_Error()
	else
		Sqrt_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Log2(Source)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Log2_InputData_Error()
	elseif Source == "Cp" then
		Log2_InputData_Error()
	elseif Source[4] == "V" then
		table.insert(STPushTrigArr,{"f_Log2",TempData,Source}) -- A << Log2(X)
	elseif Source[4] == "VA" then
		table.insert(STPushTrigArr,{"f_Log2",TempData,Source}) -- A << Log2(VA)
	elseif Source[4] == "A" then
		Log2_InputData_Error()
	else
		Log2_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Atan2(DeltaY,DeltaX)
	if DeltaY == nil then
		DeltaY = "X"
	end
	if DeltaX == nil then
		DeltaX = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if DeltaY[4] == "V" and DeltaX[4] == "V" then
		table.insert(STPushTrigArr,{"f_Atan2",DeltaY,DeltaX,TempData})
	elseif DeltaY[4] == "VA" and DeltaX[4] == "V" then
		table.insert(STPushTrigArr,{"f_Atan2",DeltaY,DeltaX,TempData})
	elseif DeltaY[4] == "V" and DeltaX[4] == "VA" then
		table.insert(STPushTrigArr,{"f_Atan2",DeltaY,DeltaX,TempData})
	elseif DeltaY[4] == "VA" and DeltaX[4] == "VA" then
		table.insert(STPushTrigArr,{"f_Atan2",DeltaY,DeltaX,TempData})
	else
		Atan2_InputData_Error()
	end

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Lengthdir(Radius,Angle)
	if Radius == nil then
		Radius = "X"
	end
	if Angle == nil then
		Angle = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}
	local CosTemp = {"X",Temp,0x15C,0}
	local SinTemp = {"X",Temp,0x19C,0}

	if Radius[4] == "V" and Angle[4] == "V" then
		table.insert(STPushTrigArr,{"f_Lengthdir",Radius,Angle,CosTemp,SinTemp})
	elseif Radius[4] == "VA" and Angle[4] == "V" then
		table.insert(STPushTrigArr,{"f_Lengthdir",Radius,Angle,CosTemp,SinTemp})
	elseif Radius[4] == "V" and Angle[4] == "VA" then
		table.insert(STPushTrigArr,{"f_Lengthdir",Radius,Angle,CosTemp,SinTemp})
	elseif Radius[4] == "VA" and Angle[4] == "VA" then
		table.insert(STPushTrigArr,{"f_Lengthdir",Radius,Angle,CosTemp,SinTemp})
	else
		Lengthdir_InputData_Error()
	end

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _Rand()
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"f_Rand",TempData}) 

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

-- Misc 기타 함수들 ---------------------------------------------------------------------------------------------

function DisplayTextX(Text,AlwaysDisplay) -- Action(0,ParseString(Text),0,0,0,0,0,0x9,0,AlwaysDisplay)
	if AlwaysDisplay == nil then
		AlwaysDisplay = 4
	end
	return {"DisplayText",Text,AlwaysDisplay}
end
function PlayWAVX(WAVName) 
	return {"PlayWAV",WAVName}
end
function SetMissionObjectivesX(Text) 
	return {"SetMissionObjectives",Text}
end
function TransmissionX(Unit,Where,WAVName,TimeModifier,Time,Text,AlwaysDisplay)
	if AlwaysDisplay == nil then
		AlwaysDisplay = 4
	end
	return {"Transmission",Unit,Where,WAVName,TimeModifier,Time,Text,AlwaysDisplay}
end
function LeaderBoardKillsX(Unit,Label)
	return {"LeaderBoardKills",Unit,Label}
end
function LeaderBoardScoreX(ScoreType,Label)
	return {"LeaderBoardScore",ScoreType,Label}
end
function LeaderBoardResourcesX(ResourceType,Label)
	return {"LeaderBoardResources",ResourceType,Label}
end
function LeaderBoardControlX(Unit,Label)
	return {"LeaderBoardControl",Unit,Label}
end
function LeaderBoardControlAtX(Unit,Location,Label)
	return {"LeaderBoardControlAt",Unit,Location,Label}
end
function LeaderBoardGoalScoreX(Goal,ScoreType,Label)
	return {"LeaderBoardGoalScore",Goal,ScoreType,Label}
end
function LeaderBoardGoalKillsX(Goal,Unit,Label)
	return {"LeaderBoardGoalKills",Goal,Unit,Label}
end
function LeaderBoardGoalResourcesX(Goal,ReesourceType,Label)
	return {"LeaderBoardGoalResources",Goal,ReesourceType,Label}
end
function LeaderBoardGoalControlX(Goal,Unit,Label)
	return {"LeaderBoardGoalControl",Goal,Unit,Label}
end
function LeaderBoardGoalControlAtX(Goal,Unit,Location,Label)
	return {"LeaderBoardGoalControlAt",Goal,Unit,Location,Label}
end

function CopyCpAction(CpActions,Player,CurrentCp)
	local Data = {}
	Player = PlayerConvertX(Player)
	for i = 1, #Player do
		table.insert(Data,SetMemory(0x6509B0, SetTo, Player[i]))
		for k, v in pairs(CpActions) do
			if type(v[1]) == "string" then
				local l = {}
				for j = 2, #v do
					if type(v[j]) == "table" then
						table.insert(l,v[j][i])	-- Player마다 다른 인자를 사용
					else
						table.insert(l,v[j])	
					end
				end
				local ret = _G[v[1]](table.unpack(l))
				table.insert(Data,ret)
			elseif v[8] == 4 or (v[8]>=7 and v[8]<=9) or (v[8]>=17 and v[8]<=21) or (v[8]>=33 and v[8]<=37) then
				CopyCpAction_InputError()
			else
				table.insert(Data,v)
			end
		end 
	end

	if CurrentCp ~= nil and CurrentCp ~= "X" then
		table.insert(Data,SetMemory(0x6509B0, SetTo, CurrentCp))
	end

	return Data
end

function CopyCpActionX(CpActions,Player,CurrentCp)
	local Data = {}
	Player = PlayerConvertX(Player)

	for i = 1, #Player do
		table.insert(Data,SetMemory(0x6509B0, SetTo, Player[i]))
		for k, v in pairs(CpActions) do
			if type(v[1]) == "string" then
				local l = {}
				for j = 2, #v do
					if type(v[j]) == "table" then
						if Player[i] <= 7 then
							table.insert(l,v[j][Player[i]+1])	
						else
							table.insert(l,v[j][Player[i]-119])	
						end
					else
						table.insert(l,v[j])	
					end
				end
				local ret = _G[v[1]](table.unpack(l))
				table.insert(Data,ret)
			elseif v[8] == 4 or (v[8]>=7 and v[8]<=9) or (v[8]>=17 and v[8]<=21) or (v[8]>=33 and v[8]<=37) then
				CopyCpAction_InputError()
			else
				table.insert(Data,v)
			end
		end 
	end

	if CurrentCp ~= nil and CurrentCp ~= "X" then
		table.insert(Data,SetMemory(0x6509B0, SetTo, CurrentCp))
	end

	return Data
end
function EUDTurbo(PlayerID)
	DoActions(PlayerID,SetMemory(0x6509A0,SetTo,0))
end

function _Void(Number)
	return VoidAreaOffset+Number*4
end
function Void(Number,Type,Value)
	return FMemory(VoidAreaOffset+Number*4,Type,Value)
end
function SetVoid(Number,Type,Value)
	return FSetMemory(VoidAreaOffset+Number*4,Type,Value)
end
function VoidX(Number,Type,Value,Mask)
	return FMemoryX(VoidAreaOffset+Number*4,Type,Value,Mask)
end
function SetVoidX(Number,Type,Value,Mask)
	return FSetMemoryX(VoidAreaOffset+Number*4,Type,Value,Mask)
end
function SetCp(Number)
	return SetMemory(0x6509B0,SetTo,Number)
end

function Loc(LocationId,Direction,Type,Value)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return FMemory(0x58DC60+LocationId*0x14+Direction,Type,Value)
end

function LocX(LocationId,Direction,Type,Value,Mask)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return FMemoryX(0x58DC60+LocationId*0x14+Direction,Type,Value,Mask)
end

function SetLoc(LocationId,Direction,Type,Value)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	elseif Direction == nil then
		return KillUnitAt(1,185,LocationId,P12)
	elseif type(Direction) == "table" then
		local A, B
		if Direction[1] == nil then
			A = 185
		else
			A = Direction[1]
		end
		if Direction[2] == nil then
			B = P12
		else
			B = Direction[2]
		end
		return KillUnitAt(1,A,LocationId,B)
	end
	return FSetMemory(0x58DC60+LocationId*0x14+Direction,Type,Value)
end

function SetLocX(LocationId,Direction,Type,Value,Mask)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	elseif Direction == nil then
		return KillUnitAt(1,185,LocationId,P12)
	elseif type(Direction) == "table" then
		local A, B
		if Direction[1] == nil then
			A = 185
		else
			A = Direction[1]
		end
		if Direction[2] == nil then
			B = P12
		else
			B = Direction[2]
		end
		return KillUnitAt(1,A,LocationId,B)
	end
	return FSetMemoryX(0x58DC60+LocationId*0x14+Direction,Type,Value,Mask)
end

function _TTLoc(LocationId,Direction,Type,Value)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return _TTMemory(0x58DC60+LocationId*0x14+Direction,Type,Value)
end

function _TTLocX(LocationId,Direction,Type,Value,Mask)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return _TTMemoryX(0x58DC60+LocationId*0x14+Direction,Type,Value,Mask)
end

function _TLoc(LocationId,Direction,Type,Value)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return _TMemory(0x58DC60+LocationId*0x14+Direction,Type,Value)
end

function _TLocX(LocationId,Direction,Type,Value,Mask)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return _TMemoryX(0x58DC60+LocationId*0x14+Direction,Type,Value,Mask)
end


function TTLoc(LocationId,Direction,Type,Value)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return TTMemory(0x58DC60+LocationId*0x14+Direction,Type,Value)
end

function TTLocX(LocationId,Direction,Type,Value,Mask)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return TTMemoryX(0x58DC60+LocationId*0x14+Direction,Type,Value,Mask)
end

function TLoc(LocationId,Direction,Type,Value)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return TMemory(0x58DC60+LocationId*0x14+Direction,Type,Value)
end

function TLocX(LocationId,Direction,Type,Value,Mask)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return TMemoryX(0x58DC60+LocationId*0x14+Direction,Type,Value,Mask)
end

function TSetLoc(LocationId,Direction,Type,Value)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return TSetMemory(0x58DC60+LocationId*0x14+Direction,Type,Value)
end

function TSetLocX(LocationId,Direction,Type,Value,Mask)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return TSetMemoryX(0x58DC60+LocationId*0x14+Direction,Type,Value,Mask)
end

function PlayerColor(Player,Type,Value)
	if Player >= 0 and Player <= 11 then
		return MemoryB(0x581D76+8*Player,Type,Value)
	else
		PlayerColor_InputData_Error()
	end
end

function SetPlayerColor(Player,Type,Value)
	if Player >= 0 and Player <= 11 then
		return SetMemoryB(0x581D76+8*Player,Type,Value)
	else
		SetPlayerColor_InputData_Error()
	end
end

function MinimapColor(Player,Type,Value)
	if Player >= 0 and Player <= 11 then
		return MemoryB(0x581DD6+Player,Type,Value)
	else
		MinimapColor_InputData_Error()
	end
end

function SetMinimapColor(Player,Type,Value)
	if Player >= 0 and Player <= 11 then
		return SetMemoryB(0x581DD6+Player,Type,Value)
	else
		SetMinimapColor_InputData_Error()
	end
end

function Speed(Type,Value)
	if Value == "#X0" then
		Value = 42
	elseif Value == "#X1" then
		Value = 36
	elseif Value == "#X2" then
		Value = 29
	elseif Value == "#X3" then
		Value = 21
	elseif Value == "#X4" then
		Value = 12
	elseif Value == "#X5" then
		Value = 1
	end
	return Memory(0x5124F0,Type,Value)
end

function SetSpeed(Type,Value)
	if Value == "#X0" then
		Value = 42
	elseif Value == "#X1" then
		Value = 36
	elseif Value == "#X2" then
		Value = 29
	elseif Value == "#X3" then
		Value = 21
	elseif Value == "#X4" then
		Value = 12
	elseif Value == "#X5" then
		Value = 1
	end
	return SetMemory(0x5124F0,Type,Value)
end

function LocalPlayerID(Player,Type)
	if Type == nil then
		Type = Exactly
	end
	if Player == "Ob1" then
		Player = 128
	elseif Player == "Ob2" then
		Player = 129
	elseif Player == "Ob3" then
		Player = 130
	elseif Player == "Ob4" then
		Player = 131
	end
	return Memory(0x512684,Type,Player)
end

function UnixTime(Type,Date) -- {year = , month = , day = , hour = , min = , sec = }
	return Memory(0x6D0F38,Type,os.time(Date))
end

function MemoryW(Offset,Type,Value)
	local ret = bit32.band(Offset, 0xFFFFFFFF)%4
	if ret == 0 then
		Mask = 0xFFFF
	elseif ret == 2 then
		Mask = 0xFFFF0000
		Value = Value * 0x10000
	else
		MemoryW_InputData_Error()
	end
	return FMemoryX(Offset-ret,Type,Value,Mask)
end

function SetMemoryW(Offset,Type,Value)
	local ret = bit32.band(Offset, 0xFFFFFFFF)%4
	if ret == 0 then
		Mask = 0xFFFF
	elseif ret == 2 then
		Mask = 0xFFFF0000
		Value = Value * 0x10000
	else
		SetMemoryW_InputData_Error()
	end
	return FSetMemoryX(Offset-ret,Type,Value,Mask)
end

function MemoryB(Offset,Type,Value)
	local ret = bit32.band(Offset, 0xFFFFFFFF)%4
	if ret == 0 then
		Mask = 0xFF
	elseif ret == 1 then
		Mask = 0xFF00
		Value = Value * 0x100
	elseif ret == 2 then
		Mask = 0xFF0000
		Value = Value * 0x10000
	elseif ret == 3 then
		Mask = 0xFF000000
		Value = Value * 0x1000000
	end
	return FMemoryX(Offset-ret,Type,Value,Mask)
end

function SetMemoryB(Offset,Type,Value)
	local ret = bit32.band(Offset, 0xFFFFFFFF)%4
	if ret == 0 then
		Mask = 0xFF
	elseif ret == 1 then
		Mask = 0xFF00
		Value = Value * 0x100
	elseif ret == 2 then
		Mask = 0xFF0000
		Value = Value * 0x10000
	elseif ret == 3 then
		Mask = 0xFF000000
		Value = Value * 0x1000000
	end
	return FSetMemoryX(Offset-ret,Type,Value,Mask)
end

function _TTMemoryW(Offset,Type,Value)
	local ret = bit32.band(Offset, 0xFFFFFFFF)%4
	if ret == 0 then
		Mask = 0xFFFF
	elseif ret == 2 then
		Mask = 0xFFFF0000
		Value = Value * 0x10000
	else
		_TTMemoryW_InputData_Error()
	end
	return _TTMemoryX(Offset-ret,Type,Value,Mask)
end

function TTMemoryW(Offset,Type,Value)
	local ret = bit32.band(Offset, 0xFFFFFFFF)%4
	if ret == 0 then
		Mask = 0xFFFF
	elseif ret == 2 then
		Mask = 0xFFFF0000
		Value = Value * 0x10000
	else
		TTMemoryW_InputData_Error()
	end
	return TTMemoryX(Offset-ret,Type,Value,Mask)
end

function _TTMemoryB(Offset,Type,Value)
	local ret = bit32.band(Offset, 0xFFFFFFFF)%4
	if ret == 0 then
		Mask = 0xFF
	elseif ret == 1 then
		Mask = 0xFF00
		Value = Value * 0x100
	elseif ret == 2 then
		Mask = 0xFF0000
		Value = Value * 0x10000
	elseif ret == 3 then
		Mask = 0xFF000000
		Value = Value * 0x1000000
	end
	return _TTMemoryX(Offset-ret,Type,Value,Mask)
end

function TTMemoryB(Offset,Type,Value)
	local ret = bit32.band(Offset, 0xFFFFFFFF)%4
	if ret == 0 then
		Mask = 0xFF
	elseif ret == 1 then
		Mask = 0xFF00
		Value = Value * 0x100
	elseif ret == 2 then
		Mask = 0xFF0000
		Value = Value * 0x10000
	elseif ret == 3 then
		Mask = 0xFF000000
		Value = Value * 0x1000000
	end
	return TTMemoryX(Offset-ret,Type,Value,Mask)
end

PlayerCheckOffset = 0
function Enable_PlayerCheck(Offset)
	if Offset == nil or Offset == "X" then
		Offset = 0x58F44C
	end
	PlayerCheckOffset = Offset
	DoActions(AllPlayers,{FSetMemory(Offset,SetTo,0)})

	for i = 0, 7 do
		Trigger {
			players = {AllPlayers},
			conditions = {
				FMemoryX(0x57EEE8 + 36*i,AtLeast,0x1,0xFF);
				FMemoryX(0x57EEE8 + 36*i,AtMost,0x2,0xFF);
			},
			actions = {
				FSetMemoryX(Offset,SetTo,2^i,2^i);
			},
			flag = {Preserved}
		}
	end
end

function PlayerCheck(Player,Status)
	if PlayerCheckOffset == 0 then
		Need_Enable_PlayerCheck()
	end
	if Player >= 8  or Player < 0 then
		PlayerCheck_InputData_Error()
	end
	if Status == "X" or Status == 0 then
		Status = 0
	else
		Status = 2^Player
	end
	return FMemoryX(PlayerCheckOffset,Exactly,Status,2^Player)
end

function NoAirCollisionX(PlayerID)

	f_Read(PlayerID,0x6D5CD8,"X",V(FuncAlloc))

	CVariable2(PlayerID,FuncAlloc,0x6509B0,SetTo,0)

	FuncAlloc = FuncAlloc + 1
	local RephArr = {}
	for i = 0, 609 do
		table.insert(RephArr,SetDeaths(CurrentPlayer,SetTo,0,i))
	end
	for j = 0, 1 do
		table.insert(RephArr,SetMemory(0x6509B0,Add,1))
		for i = 0, 609 do
			table.insert(RephArr,SetDeaths(CurrentPlayer,SetTo,0,i))
		end
	end
	for j = 0, 8 do
		table.insert(RephArr,SetMemory(0x6509B0,Add,1))
		for i = 0, 608 do
			table.insert(RephArr,SetDeaths(CurrentPlayer,SetTo,0,i))
		end
	end
	table.insert(RephArr,SetMemory(0x6509B0,SetTo,PlayerID))

	DoActions2(PlayerID,RephArr)

end

function GetStrId(String)
	StringKey = ParseString(String)
	table.insert(StringKeyArr,StringKey)
	return StringKey
end

function GetStrSize(cp949flag,String,Null)
	if type(String) == "number" then
		String = DecodeString(String)
	end
	local Size = 0
	if Null == nil then
		Null = 0
	else
		Null = 1
	end
	if cp949flag == "X" or cp949flag == nil or cp949flag == 0 then -- utf8 Size
		String = cp949_to_utf8(String)
		Size = #String-1+Null
	else -- cp949 Size
		Size = #String+Null
	end
	return Size
end

function GetStrArr(cp949flag,String,Null)
	if type(String) == "number" then
		String = DecodeString(String)
	end
	local Size = 0
	local Arr = {}
	if Null == nil then
		Null = 0
	else
		Null = 1
	end
	if cp949flag == "X" or cp949flag == nil or cp949flag == 0 then -- utf8 Size
		if Null == 0 then
			Arr = cp949_to_utf8(String)
			table.remove(Arr,#Arr)
		else
			Arr = cp949_to_utf8(String)
		end
	else -- cp949 Size
		for i = 1, #String do
			table.insert(Arr,string.byte(String,i))
		end
		if Null ~= 0 then
			table.insert(Arr,0)
		end
	end
	return Arr
end

function Print_String(PlayerID, Dest, String, InitBytes) -- EPD / CPRead
	STPopTrigArr(PlayerID)
	if type(Dest) == "number" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,SetTo,Dest);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X(Dest[1],Dest[2],0x158,Dest[3],SetTo,EPD(0x6509B0));
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Dest[1],Dest[2],Dest[3]);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then
		local TempRet = {"X",CRet[1],0,"V"}
		MovX(PlayerID,TempRet,Dest)
		Dest = TempRet
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X(Dest[1],Dest[2],0x158,Dest[3],SetTo,EPD(0x6509B0));
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Dest[1],Dest[2],Dest[3]);
			},
			flag = {Preserved}
		}
	end

	local Mask1
	if InitBytes == 0 then
		Mask1 = 0xFFFFFFFF
	elseif InitBytes == 1 then
		Mask1 = 0xFFFFFF00
	elseif InitBytes == 2 then
		Mask1 = 0xFFFF0000 
	elseif InitBytes == 3 then
		Mask1 = 0xFF000000 
	else
		print_String_InputData_Error()
	end

    local ret = {}
    if type(String) == "string" then
        local str = String
        local n = 1

        if InitBytes == "X" or InitBytes == nil then
        	InitBytes = 0
        end

        if InitBytes == 1 then
            str = '\0'..str 
        elseif InitBytes == 2 then
        	str = '\0\0'..str 
       	elseif InitBytes == 3 then
       		str = '\0\0\x0D'..str 
        end

        local t = cp949_to_utf8(str)

        while n <= #t do
        	if n+4 > #t then
        		local M = #t - n
        		if M == 1 then 
        			table.insert(ret,SetDeathsX(CurrentPlayer, SetTo, _dw(t, n),0,0xFF))
        		elseif M == 2 then
        			table.insert(ret,SetDeathsX(CurrentPlayer, SetTo, _dw(t, n),0,0xFFFF))
        		elseif M == 3 then
        			table.insert(ret,SetDeathsX(CurrentPlayer, SetTo, _dw(t, n),0,0xFFFFFF))
        		end
        	else
	        	if n == 1 then
	        		table.insert(ret,SetDeathsX(CurrentPlayer, SetTo, _dw(t, n),0,Mask1))
	            	table.insert(ret,SetMemory(0x6509B0,Add,1))
	            else
	            	table.insert(ret,SetDeaths(CurrentPlayer, SetTo, _dw(t, n),0))
	            	table.insert(ret,SetMemory(0x6509B0,Add,1))
	           	end
            end
            n = n + 4
        end
    else
    	print_String_InputData_Error()
    end
    DoActions2X(PlayerID,ret)
    RecoverCp(PlayerID)
end

function Print_StringX(PlayerID, DestVA, String, InitBytes) -- EPD / CPRead
	STPopTrigArr(PlayerID)
	if DestVA[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig2X(0x6509B0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]);
			},
			flag = {Preserved}
		}
	elseif DestVA[4] == "VA" then
		local TempRet = {"X",CRet[1],0,"V"}
		MovZ(PlayerID,TempRet,DestVA,0x15C)
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}
	end

	local Mask1
	if InitBytes == 0 then
		Mask1 = 0xFFFFFFFF
	elseif InitBytes == 1 then
		Mask1 = 0xFFFFFF00
	elseif InitBytes == 2 then
		Mask1 = 0xFFFF0000 
	elseif InitBytes == 3 then
		Mask1 = 0xFF000000 
	else
		print_String_InputData_Error()
	end

    local ret = {}
    if type(String) == "string" then
        local str = String
        local n = 1

        if InitBytes == "X" or InitBytes == nil then
        	InitBytes = 0
        end

        if InitBytes == 1 then
            str = '\0'..str 
        elseif InitBytes == 2 then
        	str = '\0\0'..str 
       	elseif InitBytes == 3 then
       		str = '\0\0\x0D'..str 
        end

        local t = cp949_to_utf8(str)

        while n <= #t do
        	if n+4 > #t then
        		local M = #t - n
        		if M == 1 then 
        			table.insert(ret,SetDeathsX(CurrentPlayer, SetTo, _dw(t, n),0,0xFF))
        		elseif M == 2 then
        			table.insert(ret,SetDeathsX(CurrentPlayer, SetTo, _dw(t, n),0,0xFFFF))
        		elseif M == 3 then
        			table.insert(ret,SetDeathsX(CurrentPlayer, SetTo, _dw(t, n),0,0xFFFFFF))
        		end
        	else
	        	if n == 1 then
	        		table.insert(ret,SetDeathsX(CurrentPlayer, SetTo, _dw(t, n),0,Mask1))
	            	table.insert(ret,SetMemory(0x6509B0,Add,604))
	            else
	            	table.insert(ret,SetDeaths(CurrentPlayer, SetTo, _dw(t, n),0))
	            	table.insert(ret,SetMemory(0x6509B0,Add,604))
	           	end
            end
            n = n + 4
        end
    else
    	print_String_InputData_Error()
    end
    DoActions2X(PlayerID,ret)
    RecoverCp(PlayerID)
end

function Print_13(PlayerID,DisplayPlayer,String)
	local X = {}
	local Y = {}
	PlayerID = PlayerConvert(PlayerID)
	if type(DisplayPlayer) == "number" then
		temp = {DisplayPlayer}
		DisplayPlayer = temp
	end
	for k, P in pairs(DisplayPlayer) do
		table.insert(X,CreateUnit(1,0,"Anywhere",P))
	end
	if String ~= nil then
		table.insert(Y,print_utf8(12, 0, String))
	end
	CIf(PlayerID,Memory(0x628438,AtLeast,1))
		f_ReadX(PlayerID,0x628438,V(FuncAlloc),1,0xFFFFFF)
		DoActionsX(PlayerID,{SetMemory(0x628438,SetTo,0),X,print_utf8(12, 0,"								"),Y})
		CVariable2(PlayerID,FuncAlloc,0x628438,SetTo,0)
	CIfEnd()
	FuncAlloc = FuncAlloc + 1
end

function GetPlayerName(PlayerID,TargetPlayer,OutputVA,InitBytes) -- VA[1~5] 사용
	if InitBytes == nil then
		InitBytes = 0
	end
	GetNameVArr = GetVArray(OutputVA)
	DoActionsX(PlayerID,{SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x0D0D0D0D),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D)})
	if InitBytes == 0 then
		for i = 0, 3 do
			f_ReadX(PlayerID,0x57EEE8 + 0x24*TargetPlayer+0x4*i,VArr(GetNameVArr,0+i),1/16777216,0xFF000000) -- 3->0
			f_ReadX(PlayerID,0x57EEEC + 0x24*TargetPlayer+0x4*i,VArr(GetNameVArr,0+i),256,0xFFFFFF) -- 012 -> 123
		end
	elseif InitBytes == 1 then
		for i = 0, 3 do
			f_ReadX(PlayerID,0x57EEE8 + 0x24*TargetPlayer+0x4*i,VArr(GetNameVArr,0+i),1/65536,0xFF000000) -- 3->1
			f_ReadX(PlayerID,0x57EEEC + 0x24*TargetPlayer+0x4*i,VArr(GetNameVArr,0+i),65536,0xFFFF) -- 01 -> 23
			f_ReadX(PlayerID,0x57EEEC + 0x24*TargetPlayer+0x4*i,VArr(GetNameVArr,1+i),1/65536,0xFF0000) -- 2->0
		end
	elseif InitBytes == 2 then
		for i = 0, 3 do
			f_ReadX(PlayerID,0x57EEE8 + 0x24*TargetPlayer+0x4*i,VArr(GetNameVArr,0+i),1/256,0xFF000000) -- 3->2
			f_ReadX(PlayerID,0x57EEEC + 0x24*TargetPlayer+0x4*i,VArr(GetNameVArr,0+i),16777216,0xFF) -- 0 -> 3
			f_ReadX(PlayerID,0x57EEEC + 0x24*TargetPlayer+0x4*i,VArr(GetNameVArr,1+i),1/256,0xFFFF00) -- 12->01
		end
	elseif InitBytes == 3 then
		for i = 0, 3 do
			f_ReadX(PlayerID,0x57EEE8 + 0x24*TargetPlayer+0x4*i,VArr(GetNameVArr,0+i),1,0xFF000000) -- 3->3
			f_ReadX(PlayerID,0x57EEEC + 0x24*TargetPlayer+0x4*i,VArr(GetNameVArr,1+i),1,0xFFFFFF) -- 012 -> 012
		end
	end
end

function GetPlayerLength(PlayerID,TargetPlayer,Output,Multiplier)
	if Multiplier == nil then
		Multiplier = 1
	end
	for i = 2, 14 do
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				MemoryB(0x57EEEB+i+0x24*TargetPlayer,AtLeast,1);
			},
			actions = {
				SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,(i+1)*Multiplier);
			},
			flag = {Preserved}
		}
	end
end

function ItoX(PlayerID,Input,OutputVA,Color) -- VA[0~3]
	if Color == nil or Color == "X" or Color == 0 then
 		Color = 0x0D
 	end
 	if type(Color) == "number" then
 		local TempColor = Color
 		Color = {}
 		for i = 1, 4 do
 			table.insert(Color,TempColor)
 		end
	end
	for i = 1, 4 do
		if Color[i] == nil or Color[i] == "X" or Color[i] == 0 then
			Color[i] = 0xD
		end
	end

	if type(OutputVA[4]) == "string" and OutputVA[4] ~= "X" then -- VArray 0 ~ 3 / 1234 -> １２３４

		DoActionsX(PlayerID,{SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x60BCEF00+Color[1]),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x60BCEF00+Color[2]),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x60BCEF00+Color[3]),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x60BCEF00+Color[4])})

		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x60*1,0xFF);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7E*1,0xFF);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x20BD0000,0xFFFF0000);
			},
			flag = {Preserved}
		}
		for i = 7, 0, -1 do -- 1 -> １
 			CBit = 2^i 
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,CBit,CBit);
				},
				actions = {
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
		end
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x5C*1,0xFF);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0xA6BFEF00,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x20*0x1,0xFF);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x8080E300,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x1F*1,0xFF);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x0D0D0D00,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x7F*1,0xFF);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x0D0D0D00,0xFFFFFF00);
			},
			flag = {Preserved}
		}

		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x60*0x100,0xFF00);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7E*0x100,0xFF00);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x20BD0000,0xFFFF0000);
			},
			flag = {Preserved}
		}
		for i = 15, 8, -1 do -- 2 -> ２
 			CBit = 2^i 
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,CBit,CBit);
				},
				actions = {
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,2^i*0x010000);
				},
				flag = {Preserved}
			}
		end
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x60*0x100,0xFF00);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x00BD0000,0x00FF0000);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x5C*0x100,0xFF00);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0xA6BFEF00,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x20*0x100,0xFF00);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x8080E300,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x1F*0x100,0xFF00);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D00,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x7F*0x100,0xFF00);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D00,0xFFFFFF00);
			},
			flag = {Preserved}
		}


		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x60*0x10000,0xFF0000);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7E*0x10000,0xFF0000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x20BD0000,0xFFFF0000);
			},
			flag = {Preserved}
		}
		for i = 23, 16, -1 do -- 3 -> ３
 			CBit = 2^i 
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,CBit,CBit);
				},
				actions = {
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,2^i*0x0100);
				},
				flag = {Preserved}
			}
		end
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x60*0x10000,0xFF0000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x00BD0000,0x00FF0000);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x5C*0x10000,0xFF0000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0xA6BFEF00,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x20*0x10000,0xFF0000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x8080E300,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x1F*0x10000,0xFF0000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D00,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x7F*0x10000,0xFF0000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D00,0xFFFFFF00);
			},
			flag = {Preserved}
		}


		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x60*0x1000000,0xFF000000);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7E*0x1000000,0xFF000000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x20BD0000,0xFFFF0000);
			},
			flag = {Preserved}
		}
		for i = 31, 24, -1 do -- 4 -> ４
 			CBit = 2^i 
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,CBit,CBit);
				},
				actions = {
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,Add,2^i*0x01);
				},
				flag = {Preserved}
			}
		end
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x60*0x1000000,0xFF000000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x00BD0000,0x00FF0000);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x5C*0x1000000,0xFF000000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0xA6BFEF00,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x20*0x1000000,0xFF000000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x8080E300,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x1F*0x1000000,0xFF000000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D00,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x7F*0x1000000,0xFF000000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D00,0xFFFFFF00);
			},
			flag = {Preserved}
		}

	else -- 선택 1234->１２３４
		if OutputVA[1] ~= nil or OutputVA[1] ~= "X" then
			DoActionsX(PlayerID,{SetCtrig1X(OutputVA[1][1],OutputVA[1][2],0x15C,OutputVA[1][3],SetTo,0x60BCEF00+Color[1])})

			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x60*1,0xFF);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7E*1,0xFF);
				},
				actions = {
					SetCtrig1X(OutputVA[1][1],OutputVA[1][2],0x15C,OutputVA[1][3],SetTo,0x20BD0000,0xFFFF0000);
				},
				flag = {Preserved}
			}
			for i = 7, 0, -1 do -- 1 -> １
	 			CBit = 2^i 
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,CBit,CBit);
					},
					actions = {
						SetCtrig1X(OutputVA[1][1],OutputVA[1][2],0x15C,OutputVA[1][3],Add,2^i*0x01000000);
					},
					flag = {Preserved}
				}
			end
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x5C*1,0xFF);
				},
				actions = {
					SetCtrig1X(OutputVA[1][1],OutputVA[1][2],0x15C,OutputVA[1][3],SetTo,0xA6BFEF00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x20*0x1,0xFF);
				},
				actions = {
					SetCtrig1X(OutputVA[1][1],OutputVA[1][2],0x15C,OutputVA[1][3],SetTo,0x8080E300,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x1F*0x1,0xFF);
				},
				actions = {
					SetCtrig1X(OutputVA[1][1],OutputVA[1][2],0x15C,OutputVA[1][3],SetTo,0x0D0D0D00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x7F*0x1,0xFF);
				},
				actions = {
					SetCtrig1X(OutputVA[1][1],OutputVA[1][2],0x15C,OutputVA[1][3],SetTo,0x0D0D0D00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
		end

		if OutputVA[2] ~= nil or OutputVA[2] ~= "X" then
			DoActionsX(PlayerID,{SetCtrig1X(OutputVA[2][1],OutputVA[2][2],0x15C,OutputVA[2][3],SetTo,0x60BCEF00+Color[2])})

			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x60*0x100,0xFF00);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7E*0x100,0xFF00);
				},
				actions = {
					SetCtrig1X(OutputVA[2][1],OutputVA[2][2],0x15C,OutputVA[2][3],SetTo,0x20BD0000,0xFFFF0000);
				},
				flag = {Preserved}
			}
			for i = 15, 8, -1 do -- 1 -> １
	 			CBit = 2^i 
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,CBit,CBit);
					},
					actions = {
						SetCtrig1X(OutputVA[2][1],OutputVA[2][2],0x15C,OutputVA[2][3],Add,2^i*0x010000);
					},
					flag = {Preserved}
				}
			end
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x5C*0x100,0xFF00);
				},
				actions = {
					SetCtrig1X(OutputVA[2][1],OutputVA[2][2],0x15C,OutputVA[2][3],SetTo,0xA6BFEF00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x20*0x100,0xFF00);
				},
				actions = {
					SetCtrig1X(OutputVA[2][1],OutputVA[2][2],0x15C,OutputVA[2][3],SetTo,0x8080E300,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x1F*0x100,0xFF00);
				},
				actions = {
					SetCtrig1X(OutputVA[2][1],OutputVA[2][2],0x15C,OutputVA[2][3],SetTo,0x0D0D0D00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x7F*0x100,0xFF00);
				},
				actions = {
					SetCtrig1X(OutputVA[2][1],OutputVA[2][2],0x15C,OutputVA[2][3],SetTo,0x0D0D0D00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
		end

		if OutputVA[3] ~= nil or OutputVA[3] ~= "X" then
			DoActionsX(PlayerID,{SetCtrig1X(OutputVA[3][1],OutputVA[3][2],0x15C,OutputVA[3][3],SetTo,0x60BCEF00+Color[3])})

			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x60*0x10000,0xFF0000);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7E*0x10000,0xFF0000);
				},
				actions = {
					SetCtrig1X(OutputVA[3][1],OutputVA[3][2],0x15C,OutputVA[3][3],SetTo,0x20BD0000,0xFFFF0000);
				},
				flag = {Preserved}
			}
			for i = 23, 16, -1 do -- 1 -> １
	 			CBit = 2^i 
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,CBit,CBit);
					},
					actions = {
						SetCtrig1X(OutputVA[3][1],OutputVA[3][2],0x15C,OutputVA[3][3],Add,2^i*0x0100);
					},
					flag = {Preserved}
				}
			end
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x5C*0x10000,0xFF0000);
				},
				actions = {
					SetCtrig1X(OutputVA[3][1],OutputVA[3][2],0x15C,OutputVA[3][3],SetTo,0xA6BFEF00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x20*0x10000,0xFF0000);
				},
				actions = {
					SetCtrig1X(OutputVA[3][1],OutputVA[3][2],0x15C,OutputVA[3][3],SetTo,0x8080E300,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x1F*0x10000,0xFF0000);
				},
				actions = {
					SetCtrig1X(OutputVA[3][1],OutputVA[3][2],0x15C,OutputVA[3][3],SetTo,0x0D0D0D00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x7F*0x10000,0xFF0000);
				},
				actions = {
					SetCtrig1X(OutputVA[3][1],OutputVA[3][2],0x15C,OutputVA[3][3],SetTo,0x0D0D0D00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
		end

		if OutputVA[4] ~= nil or OutputVA[4] ~= "X" then
			DoActionsX(PlayerID,{SetCtrig1X(OutputVA[4][1],OutputVA[4][2],0x15C,OutputVA[4][3],SetTo,0x60BCEF00+Color[4])})

			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x60*0x1000000,0xFF000000);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7E*0x1000000,0xFF000000);
				},
				actions = {
					SetCtrig1X(OutputVA[4][1],OutputVA[4][2],0x15C,OutputVA[4][3],SetTo,0x20BD0000,0xFFFF0000);
				},
				flag = {Preserved}
			}
			for i = 31, 24, -1 do -- 1 -> １
	 			CBit = 2^i 
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,CBit,CBit);
					},
					actions = {
						SetCtrig1X(OutputVA[4][1],OutputVA[4][2],0x15C,OutputVA[4][3],Add,2^i*0x01);
					},
					flag = {Preserved}
				}
			end
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x5C*0x1000000,0xFF000000);
				},
				actions = {
					SetCtrig1X(OutputVA[4][1],OutputVA[4][2],0x15C,OutputVA[4][3],SetTo,0xA6BFEF00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x20*0x1000000,0xFF000000);
				},
				actions = {
					SetCtrig1X(OutputVA[4][1],OutputVA[4][2],0x15C,OutputVA[4][3],SetTo,0x8080E300,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x1F*0x1000000,0xFF000000);
				},
				actions = {
					SetCtrig1X(OutputVA[4][1],OutputVA[4][2],0x15C,OutputVA[4][3],SetTo,0x0D0D0D00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x7F*0x1000000,0xFF000000);
				},
				actions = {
					SetCtrig1X(OutputVA[4][1],OutputVA[4][2],0x15C,OutputVA[4][3],SetTo,0x0D0D0D00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
		end
	end
end

function ItoName(PlayerID,TargetPlayer,OutputVA,Color) -- VA[0~4]
	if Color == nil or Color == "X" or Color == 0 then
 		Color = 0x0D
 	end
	GetNameVArr = GetVArray(OutputVA)
	DoActionsX(PlayerID,{SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x000D0D0D + Color*0x01000000),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D)})
	for i = 0, 3 do
		f_ReadX(PlayerID,0x57EEE8 + 0x24*TargetPlayer+0x4*i,VArr(GetNameVArr,1+i),1/16777216,0xFF000000) -- 3->0
		f_ReadX(PlayerID,0x57EEEC + 0x24*TargetPlayer+0x4*i,VArr(GetNameVArr,1+i),256,0xFFFFFF) -- 012 -> 123
	end
end

function ItoDec(PlayerID,Input,OutputVA,ZeroMode,Color,Sign,DigitMax,DigitMin) -- VA index = 상수 / Int -> Dec VA[0~3]
	STPopTrigArr(PlayerID)
-- B = 0x20, C = ColorCod, S = Sign, 0~9 = Number, X = 0x0D
-- ZeroMode : 0 표시 방법 선택 / 0 (0) / Space (1) / 0x0D (2)
-- Color : 컬러코드 추가 / 0x01 ~ 0x1F (기본 0x0D)
-- Sign : 부호 추가 / 부호없음 (0) / 부호추가(1) / 부호추가 +Space (2)
-- DigitMax : 시작 자리수 (기본 10) / DigitMin : 끝 자리수 (기본1)
 	if Sign == nil or Sign == "X" then
 		Sign = 0
 	end
 	if Color == nil or Color == "X" or Color == 0 then
 		Color = 0x0D
 	end
 	if ZeroMode == nil or ZeroMode == "X" then
 		ZeroMode = 0
 	end
 	if ZeroMode == 0 then
 		ZeroMode = 0x30
 	elseif ZeroMode == 1 then
 		ZeroMode = 0x20
 	elseif ZeroMode == 2 then
 		ZeroMode = 0x0D
 	end
 	if DigitMax == nil or DigitMax == "X" then
 		DigitMax = 10
 	end
 	if DigitMin == nil or DigitMin == "X" then
 		DigitMin = 1
 	end

 	local X = {}
 	if Sign == 0 then
	 	Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
				CallLabelAlways(Input[1],Input[2],Input[3]);
			},
			flag = {Preserved}
		}
	else
		CIfX(PlayerID, CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7FFFFFFF))
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
					CallLabelAlways(Input[1],Input[2],Input[3]);
				},
				flag = {Preserved}
			}
		CElseX()
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
					SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,Subtract*16777216,0xFF000000);
					SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
					CallLabelAlways(Input[1],Input[2],Input[3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
				},
				flag = {Preserved}
			}
		CIfXEnd()
	end
 	-- XXXX[0] 90SC[1] 5678[2] 1234[3] / CXXX[0] 90BS[1] 5678[2] 1234[3]
 	if Sign == 0 then
	 	DoActionsX(PlayerID,{SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x0D0D0D0D),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x30*0x01010000 + 0x00000D00 + Color*0x00000001),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x30*0x01010101),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x30*0x01010101)})
	 elseif Sign == 1 then
	 	DoActionsX(PlayerID,{SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x0D0D0D0D),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x30*0x01010000 + 0x00000D00 + Color*0x00000001),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x30*0x01010101),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x30*0x01010101)})
	 	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7FFFFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x00002B00,0x0000FF00)},flag = {Preserved}}
	 	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x80000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x00002D00,0x0000FF00)},flag = {Preserved}}
	 elseif Sign == 2 then
	 	DoActionsX(PlayerID,{SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x000D0D0D + Color * 0x01000000),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x30*0x01010000 + 0x0000200D),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x30*0x01010101),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x30*0x01010101)})
	 	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7FFFFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0000002B,0x000000FF)},flag = {Preserved}}
	 	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x80000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0000002D,0x000000FF)},flag = {Preserved}}
	 end

	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,999999999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x00010000*ZeroMode,0x00FF0000)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,99999999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x01000000*ZeroMode,0xFF000000)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,9999999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x00000001*ZeroMode,0x000000FF)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,999999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x00000100*ZeroMode,0x0000FF00)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,99999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x00010000*ZeroMode,0x00FF0000)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,9999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x01000000*ZeroMode,0xFF000000)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x00000001*ZeroMode,0x000000FF)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,99);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x00000100*ZeroMode,0x0000FF00)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,9);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x00010000*ZeroMode,0x00FF0000)},flag = {Preserved}}
	 	
 	for i = 2, 0, -1 do
 			CBit = 2^i * 1000000000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,2^i*0x010000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 100000000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 10000000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,2^i*0x00000001);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 1000000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,2^i*0x0100);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 100000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,2^i*0x010000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 10000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 1000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,Add,2^i*0x01);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 100
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,Add,2^i*0x0100);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 10
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,Add,2^i*0x010000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 1
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	if DigitMax == 9 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0x00FF0000))
	 elseif DigitMax == 8 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFF0000))
	 elseif DigitMax == 7 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFF0000))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0x000000FF))
	 elseif DigitMax == 6 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFF0000))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0x0000FFFF))
	 elseif DigitMax == 5 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFF0000))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0x00FFFFFF))
	 elseif DigitMax == 4 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFF0000))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 elseif DigitMax == 3 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFF0000))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0x000000FF))
	 elseif DigitMax == 2 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFF0000))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0x0000FFFF))
	 elseif DigitMax == 1 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFF0000))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0x00FFFFFF))
	 end

	 if DigitMin == 2 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFF000000))
	 elseif DigitMin == 3 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFF0000))
	 elseif DigitMin == 4 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 5 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 elseif DigitMin == 6 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFF000000))
	 elseif DigitMin == 7 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFF0000))
	 elseif DigitMin == 8 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 9 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 elseif DigitMin == 10 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFF000000))
	 end
	 DoActionsX(PlayerID,X)
end

function ItoHex(PlayerID,Input,OutputVA,ZeroMode,Color,Case,DigitMax,DigitMin) -- VA index = 상수 / Int -> Hex VA[0~2]
	STPopTrigArr(PlayerID)
-- B = 0x20, C = ColorCod, 1~8 = Number, X = 0x0D
-- ZeroMode : 0 표시 방법 선택 / 0 (0) / Space (1) / 0x0D (2)
-- Color : 컬러코드 추가 / 0x01 ~ 0x1F (기본 0x0D)
-- DigitMax : 시작 자리수 (기본 8) / DigitMin : 끝 자리수 (기본1)
-- Case : 대소문자 / 대문자(0) / 소문자(1)
	if Case == nil or Case == "X" then
		Case = 0
	end
	if Case == 0 then
		Case = 0x7
	elseif Case == 1 then
		Case = 0x27
	end
 	if Color == nil or Color == "X" or Color == 0 then
 		Color = 0x0D
 	end
 	if ZeroMode == nil or ZeroMode == "X" then
 		ZeroMode = 0
 	end
 	if ZeroMode == 0 then
 		ZeroMode = 0x30
 	elseif ZeroMode == 1 then
 		ZeroMode = 0x20
 	elseif ZeroMode == 2 then
 		ZeroMode = 0x0D
 	end
 	if DigitMax == nil or DigitMax == "X" then
 		DigitMax = 8
 	end
 	if DigitMin == nil or DigitMin == "X" then
 		DigitMin = 1
 	end

 	local X = {}
 	Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
				CallLabelAlways(Input[1],Input[2],Input[3]);
			},
			flag = {Preserved}
		}

 	-- CXXX[0] 5678[1] 1234[2]
 	DoActionsX(PlayerID,{SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x000D0D0D + Color*0x01000000),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x30*0x01010101),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x30*0x01010101)})

	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFFFFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x00000001*ZeroMode,0x000000FF)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFFFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x00000100*ZeroMode,0x0000FF00)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x00010000*ZeroMode,0x00FF0000)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x01000000*ZeroMode,0xFF000000)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x00000001*ZeroMode,0x000000FF)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x00000100*ZeroMode,0x0000FF00)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x00010000*ZeroMode,0x00FF0000)},flag = {Preserved}}
	 	
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x10000000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,2^i*0x00000001);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,AtLeast,0xA,0x0000000F);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,0x00000001*Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x1000000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,2^i*0x0100);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,AtLeast,0xA00,0x00000F00);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,0x00000100*Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x100000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,2^i*0x010000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,AtLeast,0xA0000,0x000F0000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,0x00010000*Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x10000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,AtLeast,0xA000000,0x0F000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,0x01000000*Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x1000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,2^i*0x01);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,AtLeast,0xA,0x0000000F);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,0x00000001*Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x100
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,2^i*0x0100);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,AtLeast,0xA00,0x00000F00);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,0x00000100*Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x10
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,2^i*0x010000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,AtLeast,0xA0000,0x000F0000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,0x00010000*Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x1
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,AtLeast,0xA000000,0x0F000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,0x01000000*Case)},flag = {Preserved}}
	if DigitMax == 7 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0x000000FF))
	 elseif DigitMax == 6 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0x0000FFFF))
	 elseif DigitMax == 5 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0x00FFFFFF))
	 elseif DigitMax == 4 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 elseif DigitMax == 3 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0x000000FF))
	 elseif DigitMax == 2 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0x0000FFFF))
	 elseif DigitMax == 1 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0x00FFFFFF))
	 end

	 if DigitMin == 2 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFF000000))
	 elseif DigitMin == 3 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFF0000))
	 elseif DigitMin == 4 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 5 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 elseif DigitMin == 6 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFF000000))
	 elseif DigitMin == 7 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFF0000))
	 elseif DigitMin == 8 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 end
	 DoActionsX(PlayerID,X)
end
--[[ 3Bytes Code
0x90BCEF00 ~ 0x99BCEF00 : ０１２３４５６７８９
0x8BBCEF00 : ＋
0x8DBCEF00 : －
0x8080E300 : 　(Space)
0xA1BCEF00 ~ 0xBABCEF00 : Ａ～Ｚ
0x78BDEF00 ~ 0x93BDEF00 : ａ～ｚ
]]--
function ItoDecX(PlayerID,Input,OutputVA,ZeroMode,Color,Sign,DigitMax,DigitMin) -- VA index = 상수 / Int -> DecX VA[0~11] 
	STPopTrigArr(PlayerID)
-- B = 0x20, C = ColorCod, S = Sign, 0~9 = Number, X = 0x0D
-- ZeroMode : 0 표시 방법 선택 / 0 (0) / Space (1) / 0x0D (2)
-- Color : 컬러코드 추가 / 0x01 ~ 0x1F (기본 0x0D) : 맨뒤부터 적용
-- Sign : 부호 추가 / 부호없음 (0) / 부호추가(1) / 부호추가 +Space (2)
-- DigitMax : 시작 자리수 (기본 10) / DigitMin : 끝 자리수 (기본1)
 	if Sign == nil or Sign == "X" then
 		Sign = 0
 	end
 	if Color == nil or Color == "X" or Color == 0 then
 		Color = 0x0D
 	end
 	if type(Color) == "number" then
 		local TempColor = Color
 		Color = {}
 		for i = 1, 11 do
 			table.insert(Color,TempColor)
 		end
	end
	for i = 1, 11 do
		if Color[i] == nil or Color[i] == "X" or Color[i] == 0 then
			Color[i] = 0xD
		end
	end
 	if ZeroMode == nil or ZeroMode == "X" then
 		ZeroMode = 0
 	end
 	if ZeroMode == 0 then
 		ZeroMode = 0x90BCEF00
 	elseif ZeroMode == 1 then
 		ZeroMode = 0x8080E300
 	elseif ZeroMode == 2 then
 		ZeroMode = 0x0D0D0D00
 	end
 	if DigitMax == nil or DigitMax == "X" then
 		DigitMax = 10
 	end
 	if DigitMin == nil or DigitMin == "X" then
 		DigitMin = 1
 	end

 	local X = {}
 	if Sign == 0 then
	 	Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
				CallLabelAlways(Input[1],Input[2],Input[3]);
			},
			flag = {Preserved}
		}
	else
		CIfX(PlayerID, CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7FFFFFFF))
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
					CallLabelAlways(Input[1],Input[2],Input[3]);
				},
				flag = {Preserved}
			}
		CElseX()
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
					SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,Subtract*16777216,0xFF000000);
					SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
					CallLabelAlways(Input[1],Input[2],Input[3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
				},
				flag = {Preserved}
			}
		CIfXEnd()
	end
	
	-- CXXX[0] BS-S[1] 0-0C[2] 9-9C[3] 8-8C[4] 7-7C[5] 6-6C[6] 5-5C[7] 4-4C[8] 3-3C[9] 2-2C[10] 1-1C[11] Sign == 2
 	-- XXXX[0] S-SC[1] 0-0C[2] 9-9C[3] 8-8C[4] 7-7C[5] 6-6C[6] 5-5C[7] 4-4C[8] 3-3C[9] 2-2C[10] 1-1C[11] Sign == 1
 	-- XXXX[0] XXXC[1] 0-0C[2] 9-9C[3] 8-8C[4] 7-7C[5] 6-6C[6] 5-5C[7] 4-4C[8] 3-3C[9] 2-2C[10] 1-1C[11] Sign == 0
 	if Sign == 0 then
	 	DoActionsX(PlayerID,{
	 			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+0,SetTo, 0x0D0D0D0D),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo, 0x0D0D0D00+Color[11]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo, 0x90BCEF00+Color[10]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo, 0x90BCEF00+Color[9]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo, 0x90BCEF00+Color[8]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo, 0x90BCEF00+Color[7]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo, 0x90BCEF00+Color[6]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo, 0x90BCEF00+Color[5]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo, 0x90BCEF00+Color[4]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo, 0x90BCEF00+Color[3]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x90BCEF00+Color[2]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x90BCEF00+Color[1])})
	 elseif Sign == 1 then
	 	DoActionsX(PlayerID,{
	 			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+0,SetTo, 0x0D0D0D0D),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo, 0x0D0D0D00+Color[11]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo, 0x90BCEF00+Color[10]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo, 0x90BCEF00+Color[9]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo, 0x90BCEF00+Color[8]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo, 0x90BCEF00+Color[7]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo, 0x90BCEF00+Color[6]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo, 0x90BCEF00+Color[5]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo, 0x90BCEF00+Color[4]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo, 0x90BCEF00+Color[3]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x90BCEF00+Color[2]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x90BCEF00+Color[1])})
	 	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7FFFFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x8BBCEF00,0xFFFFFF00)},flag = {Preserved}}
	 	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x80000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x8DBCEF00,0xFFFFFF00)},flag = {Preserved}}
	 elseif Sign == 2 then
	 	DoActionsX(PlayerID,{
	 			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+0,SetTo, 0x000D0D0D+Color[11]*0x01000000),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo, 0x200D0D0D),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo, 0x90BCEF00+Color[10]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo, 0x90BCEF00+Color[9]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo, 0x90BCEF00+Color[8]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo, 0x90BCEF00+Color[7]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo, 0x90BCEF00+Color[6]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo, 0x90BCEF00+Color[5]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo, 0x90BCEF00+Color[4]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo, 0x90BCEF00+Color[3]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x90BCEF00+Color[2]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x90BCEF00+Color[1])})
	 	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7FFFFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x008BBCEF,0x00FFFFFF)},flag = {Preserved}}
	 	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x80000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x008DBCEF,0x00FFFFFF)},flag = {Preserved}}
	 end
	
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,999999999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,99999999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,9999999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,999999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,99999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,9999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,99);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,9);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	
 	for i = 2, 0, -1 do
 			CBit = 2^i * 1000000000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 100000000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 10000000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 1000000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 100000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 10000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 1000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 100
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 10
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 1
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	if DigitMax == 9 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 8 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 7 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 6 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 5 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 4 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 3 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 2 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 1 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 end

	 if DigitMin == 2 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 3 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 4 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 5 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 6 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 7 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 8 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 9 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 10 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 end
	 DoActionsX(PlayerID,X)
end

function ItoHexX(PlayerID,Input,OutputVA,ZeroMode,Color,Case,DigitMax,DigitMin) -- VA index = 상수 / Int -> DecX VA[0~8] 
	STPopTrigArr(PlayerID)
-- B = 0x20, C = ColorCod,  1~8 = Number, X = 0x0D
-- ZeroMode : 0 표시 방법 선택 / 0 (0) / Space (1) / 0x0D (2)
-- Color : 컬러코드 추가 / 0x01 ~ 0x1F (기본 0x0D) : 맨뒤부터 적용
-- Case : 대소문자 / 대문자(0) / 소문자(1)
-- DigitMax : 시작 자리수 (기본 10) / DigitMin : 끝 자리수 (기본1)
 	if Case == nil or Case == "X" then
 		Case = 0
 	end
 	if Case == 0 then
		Case = 0x07000000
	elseif Case == 1 then
		Case = 0xE7010000
	end
 	if Color == nil or Color == "X" or Color == 0 then
 		Color = 0x0D
 	end
 	if type(Color) == "number" then
 		local TempColor = Color
 		Color = {}
 		for i = 1, 8 do
 			table.insert(Color,TempColor)
 		end
	end
	for i = 1, 8 do
		if Color[i] == nil or Color[i] == "X" or Color[i] == 0 then
			Color[i] = 0xD
		end
	end
 	if ZeroMode == nil or ZeroMode == "X" then
 		ZeroMode = 0
 	end
 	if ZeroMode == 0 then
 		ZeroMode = 0x90BCEF00
 	elseif ZeroMode == 1 then
 		ZeroMode = 0x8080E300
 	elseif ZeroMode == 2 then
 		ZeroMode = 0x0D0D0D00
 	end
 	if DigitMax == nil or DigitMax == "X" then
 		DigitMax = 8
 	end
 	if DigitMin == nil or DigitMin == "X" then
 		DigitMin = 1
 	end

 	local X = {}
 	Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
				CallLabelAlways(Input[1],Input[2],Input[3]);
			},
			flag = {Preserved}
		}

	-- XXXX[0] 8-8C[1] 7-7C[2] 6-6C[3] 5-5C[4] 4-4C[5] 3-3C[6] 2-2C[7] 1-1C[8]
	 DoActionsX(PlayerID,{
	 		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+0,SetTo, 0x0D0D0D0D),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo, 0x90BCEF00+Color[8]),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo, 0x90BCEF00+Color[7]),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo, 0x90BCEF00+Color[6]),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo, 0x90BCEF00+Color[5]),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo, 0x90BCEF00+Color[4]),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo, 0x90BCEF00+Color[3]),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo, 0x90BCEF00+Color[2]),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo, 0x90BCEF00+Color[1])})
	
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFFFFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFFFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x10000000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,AtLeast,0x0A000000,0x0F000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x1000000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,AtLeast,0x0A000000,0x0F000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x100000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,AtLeast,0x0A000000,0x0F000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,Add,Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x10000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,AtLeast,0x0A000000,0x0F000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,Add,Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x1000
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,AtLeast,0x0A000000,0x0F000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,Add,Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x100
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,AtLeast,0x0A000000,0x0F000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,Add,Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x10
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,AtLeast,0x0A000000,0x0F000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,Add,Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x1
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {ParsePlayer(PlayerID)},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,AtLeast,0x0A000000,0x0F000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,Add,Case)},flag = {Preserved}}
	if DigitMax == 7 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 6 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 5 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 4 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 3 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 2 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 1 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 end

	 if DigitMin == 2 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 3 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 4 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 5 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 6 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 7 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 8 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 end
	 DoActionsX(PlayerID,X)
end


-- 64비트 정수 입력용 내부 함수 -------------------------------------------------------------------------------------------------------------------------

function I64(Number)
	local Ret1, Ret2
	if type(Number) == "number" then -- I32
		return Number
	elseif type(Number) == "string" then
		local Check = string.sub(Number,1,2) 
		if Check == "0x" or Check == "0X" then -- Hex
			local str1, str2, lenT, len1, len2
			lenT = string.len(Number)
			if lenT >= 19 or lenT <= 2 then
				I64_InputError()
			end
			len1 = 0
			len2 = lenT-2
			if len2 >= 9 then
				len2 = 8
				len1 = lenT - 10
			end
			
			if len1 == 0 then
				str2 = string.sub(Number,1,lenT) 
				Ret1 = 0
				Ret2 = tonumber(str2)
			else
				str1 = string.sub(Number,1,2+len1) 
				str2 = "0x"..string.sub(Number,3+len1,lenT) 
				Ret1 = tonumber(str1)
				Ret2 = tonumber(str2)
			end
			return {Ret2, Ret1}
		else -- Dec
			local str1, str2, lenT, len1, len2
			lenT = string.len(Number)
			local Neg = 0
			if string.sub(Number,1,1) == "-" then
				Neg = 1
				Number = string.sub(Number,2,lenT)
				lenT = lenT - 1
			end 
			if lenT >= 21 or lenT == 0 then
				I64_InputError()
			end
			len1 = 0
			len2 = lenT
			if len2 >= 11 then
				len2 = 10
				len1 = lenT - 10
			end
			local pt1, pt2
			if len1 == 0 then
				str2 = string.sub(Number,1,lenT) 
				pt1 = 0.0
				pt2 = tonumber(str2)
			else
				str1 = string.sub(Number,1,len1) 
				str2 = string.sub(Number,1+len1,lenT) 
				pt1 = tonumber(str1)
				pt2 = tonumber(str2)
			end

			if Neg == 1 then
				local Ret = I64Neg(pt1,pt2)
				pt1 = Ret[1]
				pt2 = Ret[2]
			end

			local Top = {
			922337203.0,
			461168601.0,
			230584300.0,
			115292150.0,
			57646075.0,
			28823037.0,
			14411518.0,
			7205759.0,

			3602879.0,
			1801439.0,
			900719.0,
			450359.0,
			225179.0,
			112589.0,
			56294.0,
			28147.0,

			14073.0,
			7036.0,
			3518.0,
			1759.0,
			879.0,
			439.0,
			219.0,
			109.0,

			54.0,
			27.0,
			13.0,
			6.0,
			3.0,
			1.0,
			0.0,
			0.0,

			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,

			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,

			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,

			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0
			}
			local Bottom = {
			6854775808.0,
			8427387904.0,
			9213693952.0,
			4606846976.0,
			2303423488.0,
			6151711744.0,
			8075855872.0,
			4037927936.0,

			7018963968.0,
			8509481984.0,
			9254740992.0,
			9627370496.0,
			9813685248.0,
			9906842624.0,
			9953421312.0,
			4976710656.0,

			7488355328.0,
			8744177664.0,
			4372088832.0,
			2186044416.0,
			6093022208.0,
			8046511104.0,
			9023255552.0,
			9511627776.0,

			9755813888.0,
			4877906944.0,
			7438953472.0,
			8719476736.0,
			4359738368.0,
			7179869184.0,
			8589934592.0,
			4294967296.0,

			2147483648.0,
			1073741824.0,
			536870912.0,
			268435456.0,
			134217728.0,
			67108864.0,
			33554432.0,
			16777216.0,

			8388608.0,
			4194304.0,
			2097152.0,
			1048576.0,
			524288.0,
			262144.0,
			131072.0,
			65536.0,

			32768.0,
			16384.0,
			8192.0,
			4096.0,
			2048.0,
			1024.0,
			512.0,
			256.0,

			128.0,
			64.0,
			32.0,
			16.0,
			8.0,
			4.0,
			2.0,
			1.0
			}

			local Bit = {
			0x80000000,
			0x40000000,
			0x20000000,
			0x10000000,
			0x8000000,
			0x4000000,
			0x2000000,
			0x1000000,

			0x800000,
			0x400000,
			0x200000,
			0x100000,
			0x80000,
			0x40000,
			0x20000,
			0x10000,

			0x8000,
			0x4000,
			0x2000,
			0x1000,
			0x800,
			0x400,
			0x200,
			0x100,

			0x80,
			0x40,
			0x20,
			0x10,
			0x8,
			0x4,
			0x2,
			0x1,
			}
			Ret1 = 0
			Ret2 = 0
			for i = 63, 32, -1 do
				local index = 64-i 
				local Ret = I64Sub(pt1,pt2,Top[index],Bottom[index])
				if Ret ~= 0 then
					pt1 = Ret[1]
					pt2 = Ret[2]
					Ret1 = Ret1 + Bit[index]
				end
			end

			for i = 31, 0, -1 do
				local index = 64-i
				local Ret = I64Sub(pt1,pt2,Top[index],Bottom[index])
				if Ret ~= 0 then
					pt1 = Ret[1]
					pt2 = Ret[2]
					Ret2 = Ret2 + Bit[32-i]
				end
			end

			return {Ret2, Ret1}
		end
	else
		I64_InputError()
	end
end

function I64Add(a,b,c,d)
	local Ret1, Ret2
	Ret1 = a+c
	Ret2 = b+d
	if Ret2 >= 10000000000 then
		Ret2 = Ret2 - 10000000000
		Ret1 = Ret1 + 1
	end
	return {Ret1, Ret2}
end

function I64Sub(a,b,c,d)
	local Ret1, Ret2
	if a < c then
		return 0
	else
		Ret1 = a - c
		if b >= d then
			Ret2 = b - d
			return {Ret1, Ret2}
		elseif Ret1 >= 1 then
			Ret1 = Ret1 - 1
			Ret2 = b - d + 10000000000
			return {Ret1, Ret2}
		else
			return 0
		end
	end
end

function I64Neg(a,b)
	local Ret	
	Ret = I64Sub(1844674407,3709551616,a,b)
	if Ret[1] == 1844674407 and Ret[2] == 3709551616 then
		Ret[1] = 0
		Ret[2] = 0
	end
	return Ret
end

function I64Zero(Number,Digit)
	if Digit < 0  then
		I64Zero_InputError()
	end
	local Temp = 1
	local Str = ""
	for i = 2, Digit do
		Temp = Temp * 10
		if Number < Temp then
			Str = Str.."0"
		end
	end
	local Ret = Str..Number
	return Ret
end

function PushErrorMsg(Message)
	_G["\n"..Message.."\n"]() 
end

function PushRecoverCpMsg(Flag)
	if Flag == nil or Flag == 1 then
		DetectRecoverCp = 1
	else
		DetectRecoverCp = 0
	end
end

function PushValueMsg(...)
	local Message = "\n"
	local arg = table.pack(...)
	for k = 1, arg.n do
		if type(arg[k]) == "string" then
			Message = Message..arg[k].."\n"
		elseif type(arg[k]) == "table" then
			if type(arg[k][1]) == "table" then
				for i = 1, #arg[k][1] do
					if type(arg[k][1][i]) == "string" then
						Message = Message..arg[k][1][i].."  "
					elseif type(arg[k][1][i]) == "number" then
						if arg[k][2] == "X" or arg[k][2] == "x" then
							Message = Message..string.format("%X",arg[k][1][i]).."  "
						elseif arg[k][2] == "F" or arg[k][2] == "f"  then
							Message = Message..string.format("%f",arg[k][1][i]).."  "
						else
							Message = Message..string.format("%d",math.floor(arg[k][1][i])).."  "
						end
					elseif arg[k][1][i] == nil then
						Message = Message.."nil".."  "
					elseif type(arg[k][1][i]) == "table" then
						Message = Message.."table".."  "
					else
						PushValueMsg_InputError()
					end
				end
				Message = Message.."\n"
			elseif arg[k][2] == "X" or arg[k][2] == "x" then
				Message = Message..string.format("%X",arg[k][1]).."\n"
			elseif arg[k][2] == "F" or arg[k][2] == "f"  then
				Message = Message..string.format("%f",arg[k][1]).."\n"
			else
				Message = Message..string.format("%d",math.floor(arg[k][1])).."\n"
			end
		elseif type(arg[k]) == "number" then
			Message = Message..string.format("%d",math.floor(arg[k])).."\n"
		elseif arg[k] == nil then
			Message = Message.."nil".."\n"
		else
			PushValueMsg_InputError()
		end 
	end
	_G["\n"..Message.."\n"]() 
end

function f_LMov(PlayerID,Dest,Source,Deviation,Mask,Clear) -- << (매크로형)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end
	if Deviation == "X" then
		Deviation = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LMov_InputData_Error()
	end
	if Deviation == nil then
		Deviation = {0,0}
	elseif type(Deviation) == "string" then -- Value "8"
		Deviation = I64(Deviation)
	elseif type(Deviation) == "number" then -- Value {4,4}만 허용
		LMov_InputData_Error()
	end

	local Mask2 = Mask
	if Clear == 1 then
		Mask2 = {0xFFFFFFFF,0xFFFFFFFF}
	end

	-- Value : "8bytes" / {4bytes,4bytes}
	-- Offset(epd) : 4bytes = {4bytes,4bytes+4(1)} / {4bytes,4bytes} / {4bytes,{Size}} = {4bytes,4bytes+Size}
	-- Dest : W ← Ax2, VAx2, WA / Source : W ← VAx2, WA (MovW)
	-- W << WA, LA / V << VA, A 
	
	if type(Source) == "table" and #Source == 2 then
		if type(Source[1]) == "table" and Source[1][4] == "A" then
			LMov_InputData_Error()
		end
		if type(Source[2]) == "table" and Source[2][4] == "A" then
			LMov_InputData_Error()
		end
		if type(Source[1]) == "table" and Source[1][4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source[1])
			Source[1] = TempRet
		end
		if type(Source[2]) == "table" and Source[2][4] == "VA" then
			local TempRet = {"X",NRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source[2])
			Source[2] = TempRet
		end
	end
	if type(Source) == "table" and Source[4] == "WA" then
		local TempRet = {"X",WRet[7],0,"W"}
		MovW(PlayerID,TempRet,Source)
		Source = TempRet
	end
	if type(Source) == "table" and Source[4] == "LA_V" then
		LMov_InputData_Error()
	end
	if type(Source) == "table" and Source[4] == "LA_W" then
		LMov_InputData_Error()
	end

	local PDest, PDest2, PDest1
	if type(Dest) == "table" and #Dest == 2 then
		if type(Dest[1]) == "table" and Dest[1][4] == "A" then
			PDest1 = Dest[1]
			Dest[1] = {"X",CRet[8],0,"V"}
		end
		if type(Dest[2]) == "table" and Dest[2][4] == "A" then
			PDest2 = Dest[2]
			Dest[2] = {"X",NRet[8],0,"V"}
		end
		if type(Dest[1]) == "table" and Dest[1][4] == "VA" then
			PDest1 = Dest[1]
			Dest[1] = {"X",CRet[8],0,"V"}
		end
		if type(Dest[2]) == "table" and Dest[2][4] == "VA" then
			PDest2 = Dest[2]
			Dest[2] = {"X",NRet[8],0,"V"}
		end
	end
	if type(Dest) == "table" and Dest[4] == "WA" then
		PDest = Dest
		Dest = {"X",WRet[8],0,"W"}
	end
	if type(Dest) == "table" and Dest[4] == "LA_V" then
		PDest = Dest
		Dest = {"X",WRet[8],0,"W"}
	end
	if type(Dest) == "table" and Dest[4] == "LA_W" then
		PDest = Dest
		Dest = {"X",WRet[8],0,"W"}
	end
	



	--[[ Source All Cases
	"8" → {4,4}
	W → W
	{4,4} → {4,4}
	{4,V} → {4,V}
	{V,4} → {V,4}
	{V,V} → {V,V} 
	Ret = W, {4,4}, {4,V}, {V,V}, {V,4} ]]--
	local SourceArr = {}
	if type(Source) == "string" then -- Value "8"
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			for i = 1, 2 do
				if type(Source[i]) == "number" then -- {4, }
					table.insert(SourceArr,4)
				elseif Source[i][4] == "V" then -- {V, }
					table.insert(SourceArr,"V")
				else
					LMov_InputData_Error()
				end
			end
		else
			LMov_InputData_Error()
		end
	elseif type(Source) == "number" then
		Source = {Source,0}
		SourceArr = {4,4}
	else
		LMov_InputData_Error()
	end

	--[[ Dest All Cases
	"Cp" → {Cp,1}
	{"Cp",{4}} → {Cp,4}
	W → W
	4 → {4,4+0x4}
	{4,4} → {4,4}
	{4,{Size}} → {4,4+Size}
	{4,V} → {4,Mem}
	{4,Mem} → {4,Mem}
	{V,4} → {Mem,4}
	{V,V} → {Mem,Mem}
	{V,Mem} → {Mem,Mem}
	Mem → {Mem,Mem+0x4}
	{Mem,4} → {Mem,4}
	{Mem,{Size}} → {Mem,Mem+Size}
	{Mem,V} → {Mem,Mem}
	{Mem,Mem} → {Mem,Mem}
	Ret = {Cp,4}, W, {4,4}, {4,Mem}, {Mem,Mem}, {Mem,4} ]]--
	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						local Temp = {Dest[2][1],Dest[2][2],0x15C,Dest[2][3]}
						Dest = {Dest[1]}
						table.insert(Dest,Temp)
						DestArr = {4,"Mem"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						local Temp = {Dest[1][1],Dest[1][2],0x15C,Dest[1][3]}
						local Temp2 = Dest[2]
						Dest = {}
						table.insert(Dest,Temp)
						table.insert(Dest,Temp2)
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							local Temp = {Dest[1][1],Dest[1][2],0x15C,Dest[1][3]}
							local Temp2 = {Dest[2][1],Dest[2][2],0x15C,Dest[2][3]}
							Dest = {}
							table.insert(Dest,Temp)
							table.insert(Dest,Temp2)
							DestArr = {"Mem","Mem"}
						else -- {V,Mem}
							local Temp = {Dest[1][1],Dest[1][2],0x15C,Dest[1][3]}
							local Temp2 = Dest[2]
							Dest = {}
							table.insert(Dest,Temp)
							table.insert(Dest,Temp2)
							DestArr = {"Mem","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							local Temp = {Dest[2][1],Dest[2][2],0x15C,Dest[2][3]}
							local Temp2 = Dest[1]
							Dest = {}
							table.insert(Dest,Temp2)
							table.insert(Dest,Temp)
							DestArr = {"Mem","Mem"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LMov_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LMov_InputData_Error()
		end
	else
		LMov_InputData_Error()
	end

	--Source = W, {4,4}, {4,V}, {V,V}, {V,4} --
	--Dest = {Cp,4}, W, {4,4}, {4,Mem}, {Mem,Mem}, {Mem,4} --
	if SourceArr == "W" then -- 8bytes 
		if DestArr == "W" then -- 8 << 8
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation[1],Mask2[1]);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Deviation[2],Mask2[2]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
						SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
		elseif DestArr[1] == "Cp" then -- Cp << 8
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeathsX(CurrentPlayer,SetTo,Deviation[1],0,Mask[1]);
						SetMemory(0x6509B0,Add,Dest[2]);
						SetDeathsX(CurrentPlayer,SetTo,Deviation[2],0,Mask[2]);
						SetMemory(0x6509B0,Subtract,Dest[2]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
						SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,13);
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,13);
						SetCtrig1X(Source[1],Source[2],0x17C,Source[3],SetTo,Dest[2]); -- Cp Add Setting
						SetCtrig1X(Source[1],Source[2],0x184,Source[3],SetTo,0x0,0x2); -- Cp Add enable
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetMemory(0x6509B0,Subtract,Dest[2]);
						SetCtrig1X(Source[1],Source[2],0x17C,Source[3],SetTo,1); -- Cp Add Setting
						SetCtrig1X(Source[1],Source[2],0x184,Source[3],SetTo,0x2,0x2); -- Cp Add Disable
					},
					flag = {Preserved}
				}
		else -- {4/Mem,4/Mem} << 8
			local Box = {}
			for i = 1, 2 do
				if type(DestArr[i]) == "number" then
					table.insert(Box,SetMemoryX(Dest[i],SetTo,Deviation[i],Mask[i]))
					table.insert(Box,SetCtrig1X(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,EPD(Dest[i])))
				elseif DestArr[i] == "Mem" then
					table.insert(Box,SetCtrig1X(Dest[i][1],Dest[i][2],Dest[i][3],Dest[i][4],SetTo,Deviation[i],Mask[i]))
					table.insert(Box,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][1],Dest[i][2],Dest[i][3],1,Dest[i][4]))
				end
			end
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						Box,
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
						SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Add*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
		end
	else -- 4bytes x 2
		if type(SourceArr[1]) == "number" then -- 4/Mem << 4
			if type(SourceArr[2]) == "number" then -- 4/Mem << {4,4}
				local Box = {}
				if DestArr == "W" then
					table.insert(Box,SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Mask2[1]))
					table.insert(Box,SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[2],Mask2[2]))
				else
					for i = 1, 2 do
						if type(DestArr[i]) == "number" then
							table.insert(Box,SetMemoryX(Dest[i],SetTo,Source[i],Mask[i]))
						elseif DestArr[i] == "Mem" then
							table.insert(Box,SetCtrig1X(Dest[i][1],Dest[i][2],Dest[i][3],Dest[i][4],SetTo,Source[i],Mask[i]))
						end
					end
				end
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							Box,
						},
						flag = {Preserved}
					}
			else -- 4/Mem << {4,V}
				local Box = {}
				if DestArr == "W" then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Mask2[1]);
							SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Deviation[2],Mask2[2]);
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,Mask[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways(Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
				else
					if type(DestArr[1]) == "number" then
						table.insert(Box,SetMemoryX(Dest[1],SetTo,Source[1],Mask[1]))
					elseif DestArr[1] == "Mem" then
						table.insert(Box,SetCtrig1X(Dest[1][1],Dest[1][2],Dest[1][3],Dest[1][4],SetTo,Source[1],Mask[1]))
					end
					if type(DestArr[2]) == "number" then
						table.insert(Box,SetMemoryX(Dest[2],SetTo,Deviation[2],Mask[2]))
						table.insert(Box,SetCtrig1X(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,EPD(Dest[2])))
					elseif DestArr[2] == "Mem" then
						table.insert(Box,SetCtrig1X(Dest[2][1],Dest[2][2],Dest[2][3],Dest[2][4],SetTo,Deviation[2],Mask[2]))
						table.insert(Box,SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,Dest[2][1],Dest[2][2],Dest[2][3],1,Dest[2][4]))
					end
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							Box,
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,Mask[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways(Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
				end
			end
		else -- 4/Mem << V
			if type(SourceArr[2]) == "number" then -- 4/Mem << {V,4}
				local Box = {}
				if DestArr == "W" then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation[1],Mask2[1]);
							SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[2],Mask2[2]);
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,Mask[2]);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways(Source[1][1],Source[1][2],Source[1][3]);
						},
						flag = {Preserved}
					}
				else
					if type(DestArr[1]) == "number" then
						table.insert(Box,SetMemoryX(Dest[1],SetTo,Deviation[1],Mask[1]))
						table.insert(Box,SetCtrig1X(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,EPD(Dest[1])))
					elseif DestArr[1] == "Mem" then
						table.insert(Box,SetCtrig1X(Dest[1][1],Dest[1][2],Dest[1][3],Dest[1][4],SetTo,Deviation[1],Mask[1]))
						table.insert(Box,SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,Dest[1][1],Dest[1][2],Dest[1][3],1,Dest[1][4]))
					end
					if type(DestArr[2]) == "number" then
						table.insert(Box,SetMemoryX(Dest[2],SetTo,Source[2],Mask[2]))
					elseif DestArr[2] == "Mem" then
						table.insert(Box,SetCtrig1X(Dest[2][1],Dest[2][2],Dest[2][3],Dest[2][4],SetTo,Source[2],Mask[2]))
					end
					
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							Box,
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,Mask[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways(Source[1][1],Source[1][2],Source[1][3]);
						},
						flag = {Preserved}
					}
				end
			else -- 4/Mem << {v,V}
				local Box = {}
				if DestArr == "W" then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation[1],Mask2[1]);
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,Mask[2]);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Deviation[2],Mask2[2]);
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,Mask[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways2(Source[1][1],Source[1][2],Source[1][3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
				else
					if type(DestArr[1]) == "number" then
						table.insert(Box,SetMemoryX(Dest[1],SetTo,Deviation[1],Mask[1]))
						table.insert(Box,SetCtrig1X(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,EPD(Dest[1])))
					elseif DestArr[1] == "Mem" then
						table.insert(Box,SetCtrig1X(Dest[1][1],Dest[1][2],Dest[1][3],Dest[1][4],SetTo,Deviation[1],Mask[1]))
						table.insert(Box,SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,Dest[1][1],Dest[1][2],Dest[1][3],1,Dest[1][4]))
					end
					if type(DestArr[2]) == "number" then
						table.insert(Box,SetMemoryX(Dest[2],SetTo,Deviation[2],Mask[2]))
						table.insert(Box,SetCtrig1X(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,EPD(Dest[2])))
					elseif DestArr[2] == "Mem" then
						table.insert(Box,SetCtrig1X(Dest[2][1],Dest[2][2],Dest[2][3],Dest[2][4],SetTo,Deviation[2],Mask2[2]))
						table.insert(Box,SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,Dest[2][1],Dest[2][2],Dest[2][3],1,Dest[2][4]))
					end
					
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							Box,
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,Mask[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,Mask[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways2(Source[1][1],Source[1][2],Source[1][3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
				end
			end
		end
	end

	if PDest ~= nil then
		MovW(PlayerID,PDest,{"X",WRet[8],0,"W"})
	end
	if PDest1 ~= nil then
		MovX(PlayerID,PDest1,{"X",CRet[8],0,"V"})
	end
	if PDest2 ~= nil then
		MovX(PlayerID,PDest2,{"X",NRet[8],0,"V"})
	end
end

function MovW(PlayerID,Dest,Source,Mode,Mask,Clear) -- W << WA / WA,LA << W (Value) / 내부함수 (사용 권장X)
	--STPopTrigArr(PlayerID)
	if Mode == "X" or Mode == nil then
		Mode = SetTo
	end
	if Mask == "X" or Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	end

	local Mask2 = Mask
	if Clear == 1 then
		Mask2 = {0xFFFFFFFF,0xFFFFFFFF}
	end

	local Box0 = {}
	if Dest[4] == "W" and Source[4] == "WA" then -- Mov W, WA / {Index[1],Index[2],Index[3],"WA",WArray(WAPlayer,WAIndex,0),Index[5]}
		if Clear == 1 then
			table.insert(Box0,SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0,Mask2))
			table.insert(Box0,SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,0,Mask2))
		end
		Trigger {--(CPRead)로 값 출력
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					Box0,
					SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

					SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
					SetMemory(0x6509B0,Add,Source[6]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
					SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 

					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
					SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 
					CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x40/4));
					SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,Mask[1],0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x40/4));
					SetDeaths(CurrentPlayer,SetTo,Mask[2],0); -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
					SetMemory(0x6509B0,Add,(0x40/4));
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
				},
				flag = {Preserved}
			}

		RecoverCp(PlayerID)
	elseif #Dest == 2 and Dest[1][4] == "V" and Dest[2][4] == "V" and Source[4] == "WA" then -- Mov Vx2, WA / {Index[1],Index[2],Index[3],"WA",WArray(WAPlayer,WAIndex,0),Index[5]}
		Trigger {--(CPRead)로 값 출력
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

					SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
					SetMemory(0x6509B0,Add,Source[6]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
					SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 

					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
					SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 
					CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetCtrig2X("Cp",SetTo,Dest[1][1],Dest[1][2],0x15C,1,Dest[1][3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x40/4));
					SetCtrig2X("Cp",SetTo,Dest[2][1],Dest[2][2],0x15C,1,Dest[2][3]);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,Mask[1],0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x40/4));
					SetDeaths(CurrentPlayer,SetTo,Mask[2],0); -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
					SetMemory(0x6509B0,Add,(0x40/4));
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
				},
				flag = {Preserved}
			}

		RecoverCp(PlayerID)
	elseif #Dest == 2 and Source[4] == "WA" then -- Mov Memx2, WA / {Index[1],Index[2],Index[3],"WA",WArray(WAPlayer,WAIndex,0),Index[5]}
		Trigger {--(CPRead)로 값 출력
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

					SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
					SetMemory(0x6509B0,Add,Source[6]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
					SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 

					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
					SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 
					CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetCtrig2X("Cp",SetTo,Dest[1][1],Dest[1][2],Dest[1][3],1,Dest[1][4]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x40/4));
					SetCtrig2X("Cp",SetTo,Dest[2][1],Dest[2][2],Dest[2][3],1,Dest[2][4]);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,Mask[1],0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x40/4));
					SetDeaths(CurrentPlayer,SetTo,Mask[2],0); -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
					SetMemory(0x6509B0,Add,(0x40/4));
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
				},
				flag = {Preserved}
			}

		RecoverCp(PlayerID)
	elseif Dest[4] == "WA" and Source[4] == "W" then -- Mov WA, W 
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
					SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[5][1],Dest[5][2],0x19C,1,Dest[5][3]); 
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],Add,Dest[6]);
					SetCtrig1X(Source[1],Source[2],0x198,Source[3],Add,Dest[6]);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
					SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Source[1],Source[2],0x198,1,Source[3]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Mode*16777216,0xFF000000);
					CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	elseif Dest[4] == "LA_V" and Source[4] == "W" then -- Mov LA_V, W 
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
					CallLabelAlways(Dest[1],Dest[2],Dest[3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x198,1,Source[3]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Mode*16777216,0xFF000000);
					CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}

	elseif Dest[4] == "LA_W" and Source[4] == "W" then -- Mov LA_W, W 
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
					SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
					SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Source[1],Source[2],0x198,1,Source[3]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Mode*16777216,0xFF000000);
					CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	else
		MovW_InputData_Error()
	end
end

function f_LMovX(PlayerID,Dest,Source,Mode,Mask,Deviation,Clear) -- W,Cp,{4/Mem,4/Mem} << WA / WA,LA << W/{4/V,4/V} (Value)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end
	if Deviation == "X" then
		Deviation = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LMovX_InputData_Error()
	end
	if Deviation == nil then
		Deviation = {0,0}
	elseif type(Deviation) == "string" then -- Value "8"
		Deviation = I64(Deviation)
	elseif type(Deviation) == "number" then -- Value {4,4}만 허용
		LMovX_InputData_Error()
	end

	local Mask2 = Mask
	if Clear == 1 then
		Mask2 = {0xFFFFFFFF,0xFFFFFFFF}
	end
	if Mode == nil then
		Mode = SetTo
	end
	--[[ Source All Cases
	"8" → {4,4}
	W → W
	{4,4} → {4,4}
	{4,V} → {4,V}
	{V,4} → {V,4}
	{V,V} → {V,V} 
	Ret = W, {4,4}, {4,V}, {V,V}, {V,4} ]]--


	local SourceArr = {}
	local DestArr = {}

	if type(Dest) == "table" and type(Source) == "table" then
		if Source[4] == "WA" then
			if Dest[4] == "WA" or Dest[4] == "LA_V" or Dest[4] == "LA_W" then
				SourceArr = "WA"
				DestArr = Dest[4]
				goto LMovXTypeCheckEnd
			end
		end
	end

	if type(Dest) == "table" and (Dest[4] == "WA" or Dest[4] == "LA_V" or Dest[4] == "LA_W") then
		DestArr = Dest[4]
		if type(Source) == "string" then -- Value "8"
			Source = I64(Source)
			SourceArr = {4,4}
		elseif type(Source) == "table" then
			if Source[4] == "W" then -- W
				SourceArr = "W"
			elseif #Source == 2 then
				for i = 1, 2 do
					if type(Source[i]) == "number" then -- {4, }
						table.insert(SourceArr,4)
					elseif Source[i][4] == "V" then -- {V, }
						table.insert(SourceArr,"V")
					else
						LMovX_InputData_Error()
					end
				end
			else
				LMovX_InputData_Error()
			end
		elseif type(Source) == "number" then
			Source = {Source,0}
			SourceArr = {4,4}
		else
			LMovX_InputData_Error()
		end
		goto LMovXTypeCheckEnd
	end

	--[[ Dest All Cases
	"Cp" → {Cp,1}
	{"Cp",{4}} → {Cp,4}
	W → W
	4 → {4,4+0x4}
	{4,4} → {4,4}
	{4,{Size}} → {4,4+Size}
	{4,V} → {4,Mem}
	{4,Mem} → {4,Mem}
	{V,4} → {Mem,4}
	{V,V} → {Mem,Mem}
	{V,Mem} → {Mem,Mem}
	Mem → {Mem,Mem+0x4}
	{Mem,4} → {Mem,4}
	{Mem,{Size}} → {Mem,Mem+Size}
	{Mem,V} → {Mem,Mem}
	{Mem,Mem} → {Mem,Mem}
	Ret = {Cp,4}, W, {4,4}, {4,Mem}, {Mem,Mem}, {Mem,4} ]]--
	
	if type(Source) == "table" and (Source[4] == "WA") then
		SourceArr = "WA"
		if Dest == "Cp" then -- Cp
			Dest = {"Cp",1}
			DestArr = "Cp"
		elseif type(Dest) == "number" then -- Offset 4
			Dest = {Dest,Dest+4}
			DestArr = {4,4}
		elseif type(Dest) == "table" then
			if Dest[4] == "W" then -- W
				DestArr = "W"
			elseif #Dest == 2 then
				if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
					Dest = {"Cp",Dest[2][1]}
					DestArr = "Cp"
				elseif type(Dest[1]) == "number" then -- Offset {4, } 
					if type(Dest[2]) == "number" then -- Offset {4,4}
						DestArr = {4,4}
					elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
						if #Dest[2] == 1 then -- Offset {4,{Size}}
							Dest = {Dest[1],Dest[1]+Dest[2][1]}
							DestArr = {4,4}
						elseif Dest[2][4] == "V" then -- Offset {4,V}
							local Temp = {Dest[2][1],Dest[2][2],0x15C,Dest[2][3]}
							Dest = {Dest[1]}
							table.insert(Dest,Temp)
							DestArr = {4,"Mem"}
						else -- Offset {4,Mem}
							DestArr = {4,"Mem"}
						end
					end
				elseif type(Dest[1]) == "table" then
					if Dest[1][4] == "V" then -- {V, } 
						if type(Dest[2]) == "number" then -- {V,4}
							local Temp = {Dest[1][1],Dest[1][2],0x15C,Dest[1][3]}
							local Temp2 = Dest[2]
							Dest = {}
							table.insert(Dest,Temp)
							table.insert(Dest,Temp2)
							DestArr = {"Mem",4}
						elseif type(Dest[2]) == "table" then
							if Dest[2][4] == "V" then -- {V,V}
								local Temp = {Dest[1][1],Dest[1][2],0x15C,Dest[1][3]}
								local Temp2 = {Dest[2][1],Dest[2][2],0x15C,Dest[2][3]}
								Dest = {}
								table.insert(Dest,Temp)
								table.insert(Dest,Temp2)
								DestArr = {"Mem","Mem"}
							else -- {V,Mem}
								local Temp = {Dest[1][1],Dest[1][2],0x15C,Dest[1][3]}
								local Temp2 = Dest[2]
								Dest = {}
								table.insert(Dest,Temp)
								table.insert(Dest,Temp2)
								DestArr = {"Mem","Mem"}
							end
						end
					elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
						if type(Dest[2]) == "number" then -- {Mem,4}
							DestArr = {"Mem",4}
						elseif type(Dest[2]) == "table" then -- {Mem,{}}
							if #Dest[2] == 1 then -- {Mem,{Size}}
								local Temp = Dest
								Dest = {}
								table.insert(Dest,Temp[1])
								Temp[1][3] = Temp[1][3] + Dest[2][1]
								table.insert(Dest,Temp[1])
								DestArr = {"Mem","Mem"}
							elseif Dest[2][4] == "V" then -- {Mem,V}
								local Temp = {Dest[2][1],Dest[2][2],0x15C,Dest[2][3]}
								local Temp2 = Dest[1]
								Dest = {}
								table.insert(Dest,Temp2)
								table.insert(Dest,Temp)
								DestArr = {"Mem","Mem"}
							else -- {Mem,Mem}
								DestArr = {"Mem","Mem"}
							end	
						end
					end
				else
					LMovX_InputData_Error()
				end
			elseif type(Dest[4]) ~= "string" then -- Mem 4 
				local Temp = Dest
				Dest = {}
				table.insert(Dest,Temp)
				Temp[3] = Temp[3] + 4
				table.insert(Dest,Temp)
				DestArr = {"Mem","Mem"}
			else
				LMovX_InputData_Error()
			end
		else
			LMovX_InputData_Error()
		end
	end

	::LMovXTypeCheckEnd::

	if SourceArr == "WA" then -- 8bytes 
		if DestArr == "W" then -- 8 << 8
			Trigger {--(CPRead)로 값 출력
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation[1],Mask2[1]);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Deviation[2],Mask2[2]);
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
						SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 
						CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
					},
					flag = {Preserved}
				}

			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,Mask[1],0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeaths(CurrentPlayer,SetTo,Mask[2],0); -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
					},
					flag = {Preserved}
				}
		elseif DestArr == "WA" then -- WA << WA
			Trigger {--(CPRead)로 값 출력
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
						SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 

						SetCtrigX("X","X",0x19C,1,SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
						SetCtrigX("X","X",0x1DC,1,SetTo,Dest[5][1],Dest[5][2],0x19C,1,Dest[5][3]); 
						SetCtrig1X("X","X",0x19C,1,Add,Dest[6]);
						SetCtrig1X("X","X",0x1DC,1,Add,Dest[6]);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x19C,1,1);
						SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x1DC,1,1);
						CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}

			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,Mask[1],0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeaths(CurrentPlayer,SetTo,Mask[2],0); -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x15C-0x160-0x40)/4);
						SetDeaths(CurrentPlayer,Add,Deviation[1],0);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeaths(CurrentPlayer,Add,Deviation[2],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeaths(CurrentPlayer,Add,-Deviation[2],0);
						SetMemory(0x6509B0,Add,(-0x40/4));
						SetDeaths(CurrentPlayer,Add,-Deviation[1],0);
					},
					flag = {Preserved}
				}
		elseif DestArr == "LA_V" then -- LA_V << WA
			Trigger {--(CPRead)로 값 출력
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x19C,2,SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x19C,1,2);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}

			Trigger {--(CPRead)로 값 출력
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
						SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 

						SetCtrigX("X","X",0x1DC,1,SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x1DC,1,1);
						CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}

			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,Mask[1],0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeaths(CurrentPlayer,SetTo,Mask[2],0); -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x15C-0x160-0x40)/4);
						SetDeaths(CurrentPlayer,Add,Deviation[1],0);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeaths(CurrentPlayer,Add,Deviation[2],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeaths(CurrentPlayer,Add,-Deviation[2],0);
						SetMemory(0x6509B0,Add,(-0x40/4));
						SetDeaths(CurrentPlayer,Add,-Deviation[1],0);
					},
					flag = {Preserved}
				}
		elseif DestArr == "LA_W" then -- LA_W << WA
			Trigger {--(CPRead)로 값 출력
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
						SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 

						SetCtrigX("X","X",0x19C,1,SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
						SetCtrigX("X","X",0x1DC,1,SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x19C,1,1);
						SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x1DC,1,1);
						CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}

			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,Mask[1],0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeaths(CurrentPlayer,SetTo,Mask[2],0); -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x15C-0x160-0x40)/4);
						SetDeaths(CurrentPlayer,Add,Deviation[1],0);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeaths(CurrentPlayer,Add,Deviation[2],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeaths(CurrentPlayer,Add,-Deviation[2],0);
						SetMemory(0x6509B0,Add,(-0x40/4));
						SetDeaths(CurrentPlayer,Add,-Deviation[1],0);
					},
					flag = {Preserved}
				}
		elseif DestArr[1] == "Cp" then -- Cp << 8
			LMovX_InputData_Error()
		else -- {4/Mem,4/Mem} << 8
			local Box0 = {}
			local Box1 = {}
			if type(DestArr[1]) == "number" then
				table.insert(Box0,SetMemoryX(Dest[1],SetTo,Deviation[1],Mask[1]))
				table.insert(Box1,SetDeaths(CurrentPlayer,SetTo,EPD(Dest[1]),0))
			elseif DestArr[1] == "Mem" then
				table.insert(Box0,SetCtrig1X(Dest[1][1],Dest[1][2],Dest[1][3],Dest[1][4],SetTo,Deviation[1],Mask[1]))
				table.insert(Box1,SetCtrig2X("Cp",SetTo,Dest[1][1],Dest[1][2],Dest[1][3],1,Dest[1][4]))
			end
			local Box2 = {}
			if type(DestArr[2]) == "number" then
				table.insert(Box0,SetMemoryX(Dest[2],SetTo,Deviation[2],Mask[2]))
				table.insert(Box2,SetDeaths(CurrentPlayer,SetTo,EPD(Dest[2]),0))
			elseif DestArr[2] == "Mem" then
				table.insert(Box0,SetCtrig1X(Dest[2][1],Dest[2][2],Dest[2][3],Dest[2][4],SetTo,Deviation[2],Mask[2]))
				table.insert(Box2,SetCtrig2X("Cp",SetTo,Dest[2][1],Dest[2][2],Dest[2][3],1,Dest[2][4]))
			end

			Trigger {--(CPRead)로 값 출력
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						Box0,
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
						SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 
						CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						Box1,	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x40/4));
						Box2,	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,Mask[1],0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeaths(CurrentPlayer,SetTo,Mask[2],0); -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
					},
					flag = {Preserved}
				}
		end
		RecoverCp(PlayerID)
	elseif SourceArr == "W" then
		if DestArr == "WA" then -- Mov WA, W 
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
					SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[5][1],Dest[5][2],0x19C,1,Dest[5][3]); 
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],Add,Dest[6]);
					SetCtrig1X(Source[1],Source[2],0x198,Source[3],Add,Dest[6]);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
					SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Source[1],Source[2],0x198,1,Source[3]);

					SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,Deviation[1]);
					SetCtrig1X(Source[1],Source[2],0x19C,Source[3],Add,Deviation[2]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Mode*16777216,0xFF000000);
					CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
			Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,-Deviation[1]);
							SetCtrig1X(Source[1],Source[2],0x19C,Source[3],Add,-Deviation[2]);
						},
						flag = {Preserved}
				}
		elseif DestArr == "LA_V" then-- Mov LA_V, W 
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
					CallLabelAlways(Dest[1],Dest[2],Dest[3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x198,1,Source[3]);
					SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,Deviation[1]);
					SetCtrig1X(Source[1],Source[2],0x19C,Source[3],Add,Deviation[2]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Mode*16777216,0xFF000000);
					CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
			Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,-Deviation[1]);
							SetCtrig1X(Source[1],Source[2],0x19C,Source[3],Add,-Deviation[2]);
						},
						flag = {Preserved}
				}
		elseif DestArr == "LA_W" then -- Mov LA_W, W 
			Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
					SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
					SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Source[1],Source[2],0x198,1,Source[3]);

					SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,Deviation[1]);
					SetCtrig1X(Source[1],Source[2],0x19C,Source[3],Add,Deviation[2]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Mode*16777216,0xFF000000);
					CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
			Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,-Deviation[1]);
							SetCtrig1X(Source[1],Source[2],0x19C,Source[3],Add,-Deviation[2]);
						},
						flag = {Preserved}
				}
		end
	else -- 4bytes x 2
		if type(SourceArr[1]) == "number" then -- 4/Mem << 4
			if type(SourceArr[2]) == "number" then -- 4/Mem << {4,4}
				if DestArr == "WA" then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x158,1,SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
							SetCtrigX("X","X",0x178,1,SetTo,Dest[5][1],Dest[5][2],0x19C,1,Dest[5][3]); 
							SetCtrig1X("X","X",0x158,1,Add,Dest[6]);
							SetCtrig1X("X","X",0x178,1,Add,Dest[6]);
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x178,1,1);
							CallLabelAlways(Dest[1],Dest[2],Dest[3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemoryX(0,Mode,Source[1],Mask[1]);
							SetMemoryX(0,Mode,Source[2],Mask[2]);
						},
						flag = {Preserved}
					}
				elseif DestArr == "LA_V" then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x158,2,SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,2);
							CallLabelAlways(Dest[1],Dest[2],Dest[3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x178,1,SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x178,1,1);
							CallLabelAlways(Dest[1],Dest[2],Dest[3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemoryX(0,Mode,Source[1],Mask[1]);
							SetMemoryX(0,Mode,Source[2],Mask[2]);
						},
						flag = {Preserved}
					}
				elseif DestArr == "LA_W" then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x158,1,SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
							SetCtrigX("X","X",0x178,1,SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x178,1,1);
							CallLabelAlways(Dest[1],Dest[2],Dest[3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemoryX(0,Mode,Source[1],Mask[1]);
							SetMemoryX(0,Mode,Source[2],Mask[2]);
						},
						flag = {Preserved}
					}
				end
			else -- 4/Mem << {4,V}
				if DestArr == "WA" then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x158,1,SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,Dest[5][1],Dest[5][2],0x19C,1,Dest[5][3]); 
							SetCtrig1X("X","X",0x158,1,Add,Dest[6]);
							SetCtrig1X(Source[2][1],Source[2][2],0x158,Source[2][3],Add,Dest[6]);
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Source[2][1],Source[2][2],0x158,1,Source[2][3]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,Deviation[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,Mask[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Mode*16777216,0xFF000000);
							CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemoryX(0,Mode,Source[1],Mask[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,-Deviation[2]);
						},
						flag = {Preserved}
					}
				elseif DestArr == "LA_V" then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x158,2,SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,2);
							CallLabelAlways(Dest[1],Dest[2],Dest[3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[2][1],Source[2][2],0x158,1,Source[2][3]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,Deviation[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,Mask[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Mode*16777216,0xFF000000);
							CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemoryX(0,Mode,Source[1],Mask[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,-Deviation[2]);
						},
						flag = {Preserved}
					}
				elseif DestArr == "LA_W" then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x158,1,SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Source[2][1],Source[2][2],0x158,1,Source[2][3]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,Deviation[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,Mask[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Mode*16777216,0xFF000000);
							CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemoryX(0,Mode,Source[1],Mask[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,-Deviation[2]);
						},
						flag = {Preserved}
					}
				end
			end
		else -- 4/Mem << V
			if type(SourceArr[2]) == "number" then -- 4/Mem << {V,4}
				if DestArr == "WA" then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
							SetCtrigX("X","X",0x178,1,SetTo,Dest[5][1],Dest[5][2],0x19C,1,Dest[5][3]); 
							SetCtrig1X(Source[1][1],Source[1][2],0x158,Source[1][3],Add,Dest[6]);
							SetCtrig1X("X","X",0x178,1,Add,Dest[6]);
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1][1],Source[1][2],0x158,1,Source[1][3]);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x178,1,1);
							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,Deviation[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,Mask[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Mode*16777216,0xFF000000);
							CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1][1],Source[1][2],Source[1][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,-Deviation[1]);
							SetMemoryX(0,Mode,Source[2],Mask[2]);
						},
						flag = {Preserved}
					}
				elseif DestArr == "LA_V" then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1][1],Source[1][2],0x158,1,Source[1][3]);
							CallLabelAlways(Dest[1],Dest[2],Dest[3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x178,1,SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x178,1,1);
							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,Deviation[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,Mask[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Mode*16777216,0xFF000000);
							CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1][1],Source[1][2],Source[1][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,-Deviation[1]);
							SetMemoryX(0,Mode,Source[2],Mask[2]); 
						},
						flag = {Preserved}
					}
				elseif DestArr == "LA_W" then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
							SetCtrigX("X","X",0x178,1,SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1][1],Source[1][2],0x158,1,Source[1][3]);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x178,1,1);
							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,Deviation[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,Mask[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Mode*16777216,0xFF000000);
							CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1][1],Source[1][2],Source[1][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,-Deviation[1]);
							SetMemoryX(0,Mode,Source[2],Mask[2]); 
						},
						flag = {Preserved}
					}
				end
			else -- 4/Mem << {v,V}
				if DestArr == "WA" then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,Dest[5][1],Dest[5][2],0x19C,1,Dest[5][3]); 
							SetCtrig1X(Source[1][1],Source[1][2],0x158,Source[1][3],Add,Dest[6]);
							SetCtrig1X(Source[2][1],Source[2][2],0x158,Source[2][3],Add,Dest[6]);
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1][1],Source[1][2],0x158,1,Source[1][3]);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Source[2][1],Source[2][2],0x158,1,Source[2][3]);

							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,Deviation[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,Deviation[2]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,Mask[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,Mask[2]);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Mode*16777216,0xFF000000);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Mode*16777216,0xFF000000);
							CallLabelAlways3(Dest[1],Dest[2],Dest[3],Source[1][1],Source[1][2],Source[1][3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,-Deviation[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,-Deviation[2]);
						},
						flag = {Preserved}
					}
				elseif DestArr == "LA_V" then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1][1],Source[1][2],0x158,1,Source[1][3]);
							CallLabelAlways(Dest[1],Dest[2],Dest[3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[2][1],Source[2][2],0x158,1,Source[2][3]);

							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,Deviation[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,Deviation[2]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,Mask[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,Mask[2]);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Mode*16777216,0xFF000000);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Mode*16777216,0xFF000000);
							CallLabelAlways3(Dest[1],Dest[2],Dest[3],Source[1][1],Source[1][2],Source[1][3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,-Deviation[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,-Deviation[2]);
						},
						flag = {Preserved}
					}
				elseif DestArr == "LA_W" then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1][1],Source[1][2],0x158,1,Source[1][3]);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Source[2][1],Source[2][2],0x158,1,Source[2][3]);

							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,Deviation[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,Deviation[2]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,Mask[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,Mask[2]);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Mode*16777216,0xFF000000);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Mode*16777216,0xFF000000);
							CallLabelAlways3(Dest[1],Dest[2],Dest[3],Source[1][1],Source[1][2],Source[1][3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,-Deviation[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,-Deviation[2]);
						},
						flag = {Preserved}
					}
				end
			end
		end
	end
end

function f_Cast(PlayerID,Dest,Source,Deviation,Mask,Clear) -- V ↔ W Type Casting
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end
	if Deviation == "X" or Deviation == nil then
		Deviation = 0
	end

	local Mask2
	if Source[4] == "V" or Source[4] == "VA" then
		if Mask == nil then
			Mask = 0xFFFFFFFF
		elseif type(Mask) == "string" then -- Value "8"
			LMov_InputData_Error()
		end
		
		if Clear == 1 then
			Mask2 = 0xFFFFFFFF
		else
			Mask2 = Mask
		end
	else
		if Mask == nil then
			Mask = {0xFFFFFFFF,0xFFFFFFFF}
		elseif type(Mask) == "string" then -- Value "8"
			Mask = I64(Mask)
		elseif type(Mask) == "number" then -- Value {4,4}만 허용
			LMov_InputData_Error()
		end
		
		if Clear == 1 then
			Mask2 = {0xFFFFFFFF,0xFFFFFFFF}
		else 
			Mask2 = Mask
		end
	end

	

 	--[[
 	W → V
 	W → VA
 	WA → V
 	WA → VA
 	V → W
 	VA → W
 	V → WA
 	VA → WA
 	]]--
	if Source[4] == "W" then -- W -> V 
		if Dest[1][4] == "V" then 
			if Dest[2] == 0 then -- lower 32bit
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1][1],Dest[1][2],0x15C,Dest[1][3],SetTo,Deviation,Mask2[1]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1][1],Dest[1][2],0x15C,1,Dest[1][3]);
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			elseif Dest[2] == 1 then -- upper 32bit
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1][1],Dest[1][2],0x15C,Dest[1][3],SetTo,Deviation,Mask2[2]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[2]);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[1][1],Dest[1][2],0x15C,1,Dest[1][3]);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,0);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				Cast_InputData_Error()
			end
		elseif Dest[1][4] == "VA" then -- W -> VA
			if Dest[2] == 0 then -- lower 32bit
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1][5][1],Dest[1][5][2],0x15C,1,Dest[1][5][3]); 
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],Add,Dest[1][6]);
						SetCtrig1X(Dest[1][1],Dest[1][2],0x148,Dest[1][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1][1],Dest[1][2],0x160,Dest[1][3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1][1],Dest[1][2],0x158,Dest[1][3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,Deviation);
						CallLabelAlways2(Dest[1][1],Dest[1][2],Dest[1][3],Source[1],Source[2],Source[3]);
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,-Deviation); 
					},
					flag = {Preserved}
				}
			elseif Dest[2] == 1 then -- upper 32bit
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[1][5][1],Dest[1][5][2],0x15C,1,Dest[1][5][3]); 
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],Add,Dest[1][6]);
						SetCtrig1X(Dest[1][1],Dest[1][2],0x148,Dest[1][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1][1],Dest[1][2],0x160,Dest[1][3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1][1],Dest[1][2],0x158,Dest[1][3],SetTo,Source[1],Source[2],0x198,1,Source[3]);
						SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
						SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x19C,Source[3],Add,Deviation);
						CallLabelAlways2(Dest[1][1],Dest[1][2],Dest[1][3],Source[1],Source[2],Source[3]);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,0);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Source[1],Source[2],0x19C,Source[3],Add,-Deviation); 
					},
					flag = {Preserved}
				}
			else
				Cast_InputData_Error()
			end
		else
			Cast_InputData_Error()
		end
	elseif Source[4] == "WA" then -- WA -> V
		if Dest[1][4] == "V" then 
			if Dest[2] == 0 then -- lower 32bit
				Trigger {--(CPRead)로 값 출력
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1][1],Dest[1][2],0x15C,Dest[1][3],SetTo,Deviation,Mask2[1]);
							SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
							SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
							SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
							SetMemory(0x6509B0,Add,Source[6]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
							SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 
							SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
							SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 
							CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
						},
						flag = {Preserved}
					}

				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
							SetMemory(0x6509B0,Add,(0x158-0x0)/4);
							SetCtrig2X("Cp",SetTo,Dest[1][1],Dest[1][2],0x15C,1,Dest[1][3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x40/4));
							SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
							SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
							SetMemory(0x6509B0,Add,(0x148-0x4)/4);
							SetDeaths(CurrentPlayer,SetTo,Mask[1],0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x40/4));
							 -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
							SetDeathsX(CurrentPlayer,SetTo,Add*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
							SetMemory(0x6509B0,Add,(0x40/4));
							 -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
						},
						flag = {Preserved}
					}
				RecoverCp(PlayerID)
			elseif Dest[2] == 1 then -- upper 32bit
				Trigger {--(CPRead)로 값 출력
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1][1],Dest[1][2],0x15C,Dest[1][3],SetTo,Deviation,Mask2[2]);
							SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
							SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
							SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
							SetMemory(0x6509B0,Add,Source[6]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
							SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 
							SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
							SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 
							CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
						},
						flag = {Preserved}
					}

				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
							SetMemory(0x6509B0,Add,(0x158-0x0)/4);
							SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x40/4));
							SetCtrig2X("Cp",SetTo,Dest[1][1],Dest[1][2],0x15C,1,Dest[1][3]);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
							SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
							SetMemory(0x6509B0,Add,(0x148-0x4)/4);
							 -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x40/4));
							SetDeaths(CurrentPlayer,SetTo,Mask[2],0); -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
							 -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
							SetMemory(0x6509B0,Add,(0x40/4));
							SetDeathsX(CurrentPlayer,SetTo,Add*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
						},
						flag = {Preserved}
					}
				RecoverCp(PlayerID)
			else
				Cast_InputData_Error()
			end
		elseif Dest[1][4] == "VA" then -- WA -> VA
			if Dest[2] == 0 then -- lower 32bit
				Trigger {--(CPRead)로 값 출력
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
							SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
							SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
							SetMemory(0x6509B0,Add,Source[6]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
							SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 
							SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
							SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 
							
							SetCtrigX("X","X",0x19C,1,SetTo,Dest[1][5][1],Dest[1][5][2],0x15C,1,Dest[1][5][3]); 
							SetCtrig1X("X","X",0x19C,1,Add,Dest[1][6]);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x148,Dest[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x160,Dest[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1][1],Dest[1][2],0x158,Dest[1][3],SetTo,"X","X",0x19C,1,1);
							CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1][1],Dest[1][2],Dest[1][3]);
						},
						flag = {Preserved}
					}

				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
							SetMemory(0x6509B0,Add,(0x158-0x0)/4);
							SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x40/4));
							SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
							SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
							SetMemory(0x6509B0,Add,(0x148-0x4)/4);
							SetDeaths(CurrentPlayer,SetTo,Mask[1],0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x40/4));
							 -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
							SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
							SetMemory(0x6509B0,Add,(0x40/4));
							 -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
							SetMemory(0x6509B0,Add,(0x15C-0x160-0x40/4));
							SetDeaths(CurrentPlayer,Add,Deviation,0); 
							SetMemory(0x6509B0,Add,(0x40/4));

						},
						flag = {Preserved}
					}

				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							
							SetMemory(0x6509B0,Add,(-0x40/4));
							SetDeaths(CurrentPlayer,Add,-Deviation,0);
						},
						flag = {Preserved}
					}
				RecoverCp(PlayerID)
			elseif Dest[2] == 1 then -- upper 32bit
				Trigger {--(CPRead)로 값 출력
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
							SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
							SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
							SetMemory(0x6509B0,Add,Source[6]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
							SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 
							SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
							SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 
							
							SetCtrigX("X","X",0x1DC,1,SetTo,Dest[1][5][1],Dest[1][5][2],0x15C,1,Dest[1][5][3]); 
							SetCtrig1X("X","X",0x1DC,1,Add,Dest[1][6]);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x148,Dest[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x160,Dest[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1][1],Dest[1][2],0x158,Dest[1][3],SetTo,"X","X",0x1DC,1,1);
							CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1][1],Dest[1][2],Dest[1][3]);
						},
						flag = {Preserved}
					}

				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
							SetMemory(0x6509B0,Add,(0x158-0x0)/4);
							SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x40/4));
							SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
							SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
							SetMemory(0x6509B0,Add,(0x148-0x4)/4);
							--SetDeaths(CurrentPlayer,SetTo,Mask[2],0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x40/4));
							SetDeaths(CurrentPlayer,SetTo,Mask[2],0); -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
							-- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
							SetMemory(0x6509B0,Add,(0x40/4));
							SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
							SetMemory(0x6509B0,Add,(0x15C-0x160-0x40/4));
							
							SetMemory(0x6509B0,Add,(0x40/4));
							SetDeaths(CurrentPlayer,Add,Deviation,0); 
						},
						flag = {Preserved}
					}

				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetDeaths(CurrentPlayer,Add,-Deviation,0);
							SetMemory(0x6509B0,Add,(-0x40/4));
							
						},
						flag = {Preserved}
					}
			else
				Cast_InputData_Error()
			end
		else
			Cast_InputData_Error()
		end
	elseif Source[4] == "V" then -- V -> W  
		if Dest[4] == "W" then 
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);

						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x198,Dest[3],SetTo,0);
						CallLabelAlways2(Source[1],Source[2],Source[3],Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
		elseif Dest[4] == "WA" then -- V -> WA 
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],Add,Dest[6]);
						SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,Deviation);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x198,Dest[3],SetTo,0);
						CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],Add,0x40/4); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,-Deviation);
					},
					flag = {Preserved}
				}
		else
			Cast_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if Dest[4] == "W" then -- VA -> W
			Trigger {--(CPRead)로 값 출력
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
						CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
					},
					flag = {Preserved}
				}

			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158)/4);
						SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x0,0,Dest[3]); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148)/4);
						SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x198,Dest[3],SetTo,0); 
						SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0,0,1);
					},
					flag = {Preserved}
				}

			RecoverCp(PlayerID)
		elseif Dest[4] == "WA" then -- VA -> WA 
			Trigger {--(CPRead)로 값 출력
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 						

						SetCtrigX("X","X",0x19C,1,SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
						SetCtrig1X("X","X",0x19C,1,Add,Dest[6]);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x19C,1,1);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x198,Dest[3],SetTo,0);

						CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158)/4);
						SetCtrig2X("Cp",SetTo,Source[7],Source[8],0x0,0,Source[9]); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148)/4);
						SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x15C-0x160)/4);
						SetDeaths(CurrentPlayer,Add,Deviation,0);

						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
						SetCtrigX(Source[7],Source[8],0x4,Source[9],SetTo,"X","X",0,0,1);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x15C)/4);
						SetDeaths(CurrentPlayer,Add,0x40/4,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetMemory(0x6509B0,Add,(0x15C-0x4)/4);
						SetDeaths(CurrentPlayer,Add,-Deviation,0);
					},
					flag = {Preserved}
				}

			RecoverCp(PlayerID)
		else
			Cast_InputData_Error()
		end
	else
		Cast_InputData_Error()
	end
end

function f_iCast(PlayerID,Dest,Source) -- V ↔ W Type iCasting (Signed Number)
	STPopTrigArr(PlayerID)
	
 	--[[
 	W → V
 	W → VA
 	WA → V
 	WA → VA
 	V → W
 	VA → W
 	V → WA
 	VA → WA
 	]]--
	if Source[4] == "W" then -- W -> V 
		if Dest[4] == "V" then 
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
		elseif Dest[4] == "VA" then -- W -> VA
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],Add,Dest[6]);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
		else
			iCast_InputData_Error()
		end
	elseif Source[4] == "WA" then -- WA -> V
		if Dest[4] == "V" then 
				Trigger {--(CPRead)로 값 출력
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
							SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
							SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
							SetMemory(0x6509B0,Add,Source[6]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
							SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 
							SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
							SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 
							CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
						},
						flag = {Preserved}
					}

				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
							SetMemory(0x6509B0,Add,(0x158-0x0)/4);
							SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x40/4));
							SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
							SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
							SetMemory(0x6509B0,Add,(0x148-0x4)/4);
							SetDeaths(CurrentPlayer,SetTo,0xFFFFFFFF,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x40/4));
							 -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
							SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
							SetMemory(0x6509B0,Add,(0x40/4));
							 -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
						},
						flag = {Preserved}
					}
				RecoverCp(PlayerID)
		elseif Dest[4] == "VA" then -- WA -> VA
				Trigger {--(CPRead)로 값 출력
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
							SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
							SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
							SetMemory(0x6509B0,Add,Source[6]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
							SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 
							SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
							SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 
							
							SetCtrigX("X","X",0x19C,1,SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
							SetCtrig1X("X","X",0x19C,1,Add,Dest[6]);
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x19C,1,1);
							CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1],Dest[2],Dest[3]);
						},
						flag = {Preserved}
					}

				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
							SetMemory(0x6509B0,Add,(0x158-0x0)/4);
							SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x40/4));
							SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
							SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
							SetMemory(0x6509B0,Add,(0x148-0x4)/4);
							SetDeaths(CurrentPlayer,SetTo,0xFFFFFFFF,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x40/4));
							 -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
							SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
							SetMemory(0x6509B0,Add,(0x40/4));
							 -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
						},
						flag = {Preserved}
					}
				RecoverCp(PlayerID)
		else
			iCast_InputData_Error()
		end
	elseif Source[4] == "V" then -- V -> W  
		if Dest[4] == "W" then 
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,0);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,0xFFFFFFFF);
					},
					flag = {Preserved}
				}
		elseif Dest[4] == "WA" then -- V -> WA 
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],Add,Dest[6]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX("X","X",0x158,2,SetTo,Dest[5][1],Dest[5][2],0x19C,1,Dest[5][3]); 
						SetCtrig1X("X","X",0x158,2,Add,Dest[6]);
						SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x158,1,2);
						SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X("X","X",0x15C,2,SetTo,0);
						CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000);
					},
					actions = {
						SetCtrig1X("X","X",0x15C,1,SetTo,0xFFFFFFFF);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetMemory(0,SetTo,0);
					},
					flag = {Preserved}
				}
		else
			iCast_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if Dest[4] == "W" then -- VA -> W
			Trigger {--(CPRead)로 값 출력
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
						CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
					},
					flag = {Preserved}
				}

			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0x0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,0xFFFFFFFF,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148)/4);
						SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,0);
					},
					flag = {Preserved}
				}

			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						CtrigX(Dest[1],Dest[2],0x15C,Dest[3],AtLeast,0x80000000);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,0xFFFFFFFF);
					},
					flag = {Preserved}
				}

			RecoverCp(PlayerID)
		elseif Dest[4] == "WA" then -- VA -> WA 
			Trigger {--(CPRead)로 값 출력
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 

						SetCtrigX("X","X",0x19C,1,SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
						SetCtrig1X("X","X",0x19C,1,Add,Dest[6]);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x19C,1,1);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x198,Dest[3],SetTo,0);
						CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,0xFFFFFFFF,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148)/4);
						SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x19C-0x160)/4);
						SetDeaths(CurrentPlayer,SetTo,0,0);
						SetMemory(0x6509B0,Add,(-0x40)/4);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						Deaths(CurrentPlayer,AtLeast,0x80000000,0);
					},
					actions = {
						SetMemory(0x6509B0,Add,(0x19C-0x15C)/4);
						SetDeaths(CurrentPlayer,SetTo,0xFFFFFFFF,0);
					},
					flag = {Preserved}
				}

			RecoverCp(PlayerID)
		else
			iCast_InputData_Error()
		end
	else
		iCast_InputData_Error()
	end
end

function f_LWrite(PlayerID,Dest,Source,Deviation,Mask) -- << (CRead 대응)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end
	if Deviation == "X" then
		Deviation = nil
	end
	if Dest[5] == "X" then
		Dest[5] = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LMovX_InputData_Error()
	end
	if Deviation == nil then
		Deviation = {0,0}
	elseif type(Deviation) == "string" then -- Value "8"
		Deviation = I64(Deviation)
	elseif type(Deviation) == "number" then -- Value {4,4}만 허용
		LMovX_InputData_Error()
	end
	local Deviation2
	if Dest[5] == nil or Dest[4] == "WA" then
		Deviation2 = {0,0}
	elseif type(Dest[5]) == "string" then -- Value "8"
		Deviation2 = I64(Dest[5])
	elseif type(Dest[5]) == "number" then -- Value {4,4}만 허용
		LMovX_InputData_Error()
	else
		Deviation2 = Dest[5]
	end

	if type(Dest) == "table" and #Dest == 2 then
		if type(Dest[1]) == "table" and Dest[1][4] == "VA" then
			local TempRet = {"X",CRet[6],0,"V"}
			MovX(PlayerID,TempRet,Dest[1])
			Dest[1] = TempRet
		end
		if type(Dest[2]) == "table" and Dest[2][4] == "VA" then
			local TempRet = {"X",NRet[6],0,"V"}
			MovX(PlayerID,TempRet,Dest[2])
			Dest[2] = TempRet
		end
	end

	if type(Dest) == "table" and Dest[4] == "WA" then
		local TempRet = {"X",WRet[6],0,"W"}
		MovW(PlayerID,TempRet,Dest)
		Dest = TempRet
	end

	if type(Source) == "table" and #Source == 2 then
		if type(Source[1]) == "table" and Source[1][4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source[1])
			Source[1] = TempRet
		end
		if type(Source[2]) == "table" and Source[2][4] == "VA" then
			local TempRet = {"X",NRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source[2])
			Source[2] = TempRet
		end
	end

	if type(Source) == "table" and Source[4] == "WA" then
		local TempRet = {"X",WRet[7],0,"W"}
		MovW(PlayerID,TempRet,Source)
		Source = TempRet
	end

	--[[ Source All Cases
	"8" → {4,4}
	W → W
	{4,4} → {4,4}
	{4,V} → {4,V}
	{V,4} → {V,4}
	{V,V} → {V,V} 
	Ret = W, {4,4}, {4,V}, {V,V}, {V,4} ]]--
	local SourceArr = {}
	if type(Source) == "string" then -- Value "8"
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			for i = 1, 2 do
				if type(Source[i]) == "number" then -- {4, }
					table.insert(SourceArr,4)
				elseif Source[i][4] == "V" then -- {V, }
					table.insert(SourceArr,"V")
				else
					LWrite_InputData_Error()
				end
			end
		else
			LWrite_InputData_Error()
		end
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	else
		LWrite_InputData_Error()
	end
	
	--[[ Dest All Cases
	"8" → {4,4}
	W → W
	{V,V} → {V,V} 
	Ret = W, {4,4}, {4,V}, {V,V}, {V,4} ]]--
	local DestArr = {}
	if type(Dest) == "string" then -- Value "8"
		LWrite_InputData_Error()
	elseif type(Dest) == "table" then
		if Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			for i = 1, 2 do
				if type(Dest[i]) == "number" then -- {4, }
					LWrite_InputData_Error()
				elseif Dest[i][4] == "V" then -- {V, }
					table.insert(DestArr,"V")
				else
					LWrite_InputData_Error()
				end
			end
			if Dest[1][5] == "X" or Dest[1][5] == nil then
				Dest[1][5] = 0
			end
			if Dest[2][5] == "X" or Dest[2][5] == nil then
				Dest[2][5] = 0
			end
		else
			LWrite_InputData_Error()
		end
	else
		LWrite_InputData_Error()
	end

	if DestArr == "W" then
		if SourceArr == "W" then -- Write  W, W : EPD(W) << W

			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x15C,1,SetTo,Deviation[1]);
						SetCtrig1X("X","X",0x17C,1,SetTo,Deviation[2]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x15C,1,1);
						SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X","X",0x17C,1,1);

						SetCtrig1X("X","X",0x158,1,SetTo,Deviation2[1]);
						SetCtrig1X("X","X",0x178,1,SetTo,Deviation2[2]);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
						SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x178,1,1);
						CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						FSetMemoryX(0,SetTo,0,Mask[1]);
						FSetMemoryX(0,SetTo,0,Mask[2]);
					},
					flag = {Preserved}
				}
		else  -- Write X, 1 : EPD(X) << 1
			if type(SourceArr[1]) == "number" then
				if type(SourceArr[2]) == "number" then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x158,1,SetTo,Deviation2[1]);
							SetCtrig1X("X","X",0x178,1,SetTo,Deviation2[2]);
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x178,1,1);
							CallLabelAlways(Dest[1],Dest[2],Dest[3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							FSetMemoryX(0,SetTo,Source[1],Mask[1]);
							FSetMemoryX(0,SetTo,Source[2],Mask[2]);
						},
						flag = {Preserved}
					}
				else
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x17C,1,SetTo,Deviation[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,"X","X",0x17C,1,1);

							SetCtrig1X("X","X",0x158,1,SetTo,Deviation2[1]);
							SetCtrig1X("X","X",0x178,1,SetTo,Deviation2[2]);
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x178,1,1);
							CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							FSetMemoryX(0,SetTo,Source[1],Mask[1]);
							FSetMemoryX(0,SetTo,0,Mask[2]);
						},
						flag = {Preserved}
					}
				end
			else
				if type(SourceArr[2]) == "number" then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x15C,1,SetTo,Deviation[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,"X","X",0x15C,1,1);

							SetCtrig1X("X","X",0x158,1,SetTo,Deviation2[1]);
							SetCtrig1X("X","X",0x178,1,SetTo,Deviation2[2]);
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x178,1,1);
							CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1][1],Source[1][2],Source[1][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							FSetMemoryX(0,SetTo,0,Mask[1]);
							FSetMemoryX(0,SetTo,Source[2],Mask[2]);
						},
						flag = {Preserved}
					}
				else
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x15C,1,SetTo,Deviation[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,"X","X",0x15C,1,1);
							SetCtrig1X("X","X",0x17C,1,SetTo,Deviation[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,"X","X",0x17C,1,1);

							SetCtrig1X("X","X",0x158,1,SetTo,Deviation2[1]);
							SetCtrig1X("X","X",0x178,1,SetTo,Deviation2[2]);
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x178,1,1);
							CallLabelAlways3(Dest[1],Dest[2],Dest[3],Source[1][1],Source[1][2],Source[1][3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							FSetMemoryX(0,SetTo,0,Mask[1]);
							FSetMemoryX(0,SetTo,0,Mask[2]);
						},
						flag = {Preserved}
					}
				end
			end
		end
	else -- {V,V}
		if SourceArr == "W" then -- Write  Vx2, W : EPD(Vx2) << W
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x15C,1,SetTo,Deviation[1]);
						SetCtrig1X("X","X",0x17C,1,SetTo,Deviation[2]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x15C,1,1);
						SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X","X",0x17C,1,1);

						SetCtrig1X("X","X",0x158,1,SetTo,Dest[1][5]);
						SetCtrig1X(Dest[1][1],Dest[1][2],0x148,Dest[1][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1][1],Dest[1][2],0x160,Dest[1][3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1][1],Dest[1][2],0x158,Dest[1][3],SetTo,"X","X",0x158,1,1);
						SetCtrig1X("X","X",0x178,1,SetTo,Dest[2][5]);
						SetCtrig1X(Dest[2][1],Dest[2][2],0x148,Dest[2][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[2][1],Dest[2][2],0x160,Dest[2][3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[2][1],Dest[2][2],0x158,Dest[2][3],SetTo,"X","X",0x178,1,1);
						CallLabelAlways3(Dest[1][1],Dest[1][2],Dest[1][3],Dest[2][1],Dest[2][2],Dest[2][3],Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						FSetMemoryX(0,SetTo,0,Mask[1]);
						FSetMemoryX(0,SetTo,0,Mask[2]);
					},
					flag = {Preserved}
				}
		else  -- Write X, 1 : EPD(X) << 1
			if type(SourceArr[1]) == "number" then
				if type(SourceArr[2]) == "number" then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x158,1,SetTo,Dest[1][5]);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x148,Dest[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x160,Dest[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1][1],Dest[1][2],0x158,Dest[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X("X","X",0x178,1,SetTo,Dest[2][5]);
							SetCtrig1X(Dest[2][1],Dest[2][2],0x148,Dest[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[2][1],Dest[2][2],0x160,Dest[2][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[2][1],Dest[2][2],0x158,Dest[2][3],SetTo,"X","X",0x178,1,1);
							CallLabelAlways2(Dest[1][1],Dest[1][2],Dest[1][3],Dest[2][1],Dest[2][2],Dest[2][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							FSetMemoryX(0,SetTo,Source[1],Mask[1]);
							FSetMemoryX(0,SetTo,Source[2],Mask[2]);
						},
						flag = {Preserved}
					}
				else
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x17C,1,SetTo,Deviation[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,"X","X",0x17C,1,1);

							SetCtrig1X("X","X",0x158,1,SetTo,Dest[1][5]);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x148,Dest[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x160,Dest[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1][1],Dest[1][2],0x158,Dest[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X("X","X",0x178,1,SetTo,Dest[2][5]);
							SetCtrig1X(Dest[2][1],Dest[2][2],0x148,Dest[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[2][1],Dest[2][2],0x160,Dest[2][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[2][1],Dest[2][2],0x158,Dest[2][3],SetTo,"X","X",0x178,1,1);
							CallLabelAlways3(Dest[1][1],Dest[1][2],Dest[1][3],Dest[2][1],Dest[2][2],Dest[2][3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							FSetMemoryX(0,SetTo,Source[1],Mask[1]);
							FSetMemoryX(0,SetTo,0,Mask[2]);
						},
						flag = {Preserved}
					}
				end
			else
				if type(SourceArr[2]) == "number" then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x15C,1,SetTo,Deviation[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,"X","X",0x15C,1,1);

							SetCtrig1X("X","X",0x158,1,SetTo,Dest[1][5]);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x148,Dest[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x160,Dest[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1][1],Dest[1][2],0x158,Dest[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X("X","X",0x178,1,SetTo,Dest[2][5]);
							SetCtrig1X(Dest[2][1],Dest[2][2],0x148,Dest[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[2][1],Dest[2][2],0x160,Dest[2][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[2][1],Dest[2][2],0x158,Dest[2][3],SetTo,"X","X",0x178,1,1);
							CallLabelAlways3(Dest[1][1],Dest[1][2],Dest[1][3],Dest[2][1],Dest[2][2],Dest[2][3],Source[1][1],Source[1][2],Source[1][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							FSetMemoryX(0,SetTo,0,Mask[1]);
							FSetMemoryX(0,SetTo,Source[2],Mask[2]);
						},
						flag = {Preserved}
					}
				else
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x15C,1,SetTo,Deviation[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,"X","X",0x15C,1,1);
							SetCtrig1X("X","X",0x17C,1,SetTo,Deviation[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,"X","X",0x17C,1,1);

							SetCtrig1X("X","X",0x158,1,SetTo,Dest[1][5]);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x148,Dest[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x160,Dest[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1][1],Dest[1][2],0x158,Dest[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X("X","X",0x178,1,SetTo,Dest[2][5]);
							SetCtrig1X(Dest[2][1],Dest[2][2],0x148,Dest[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[2][1],Dest[2][2],0x160,Dest[2][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[2][1],Dest[2][2],0x158,Dest[2][3],SetTo,"X","X",0x178,1,1);
							CallLabelAlways4(Dest[1][1],Dest[1][2],Dest[1][3],Dest[2][1],Dest[2][2],Dest[2][3],Source[1][1],Source[1][2],Source[1][3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							FSetMemoryX(0,SetTo,0,Mask[1]);
							FSetMemoryX(0,SetTo,0,Mask[2]);
						},
						flag = {Preserved}
					}
				end
			end
		end
	end
end


function f_LRead(PlayerID,Input,Output,Mask,Clear) -- (CPRead) 방식으로 읽음
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LRead_InputData_Error()
	end

	local InputArr = {}
	if Input == "Cp" then -- Cp
		LRead_InputData_Error()
	elseif type(Input) == "number" then -- Offset 4
		Input = {Input,Input+4}
		InputArr = {4,4}
	elseif type(Input) == "table" then
		if Input[4] == "WA" then -- W
			InputArr = "WA"
		elseif Input[4] == "LA_V" then -- W
			InputArr = "LA_V"
		elseif Input[4] == "LA_W" then
			InputArr = "LA_W" 
		elseif Input[4] == "W" then -- W
			InputArr = "W"
		elseif #Input == 2 then
			if Input[1] == "Cp" and type(Input[2][1]) == "number" then -- Cp + Diff(epd)
				LRead_InputData_Error()
			elseif type(Input[1]) == "number" then -- Offset {4, } 
				if type(Input[2]) == "number" then -- Offset {4,4}
					InputArr = {4,4}
				elseif type(Input[2]) == "table" then -- Offset {4,{ }}
					if #Input[2] == 1 then -- Offset {4,{Size}}
						Input = {Input[1],Input[1]+Input[2][1]}
						InputArr = {4,4}
					elseif Input[2][4] == "V" then -- Offset {4,V}
						InputArr = {4,"V"}
					elseif Input[2][4] == "VA" then
						InputArr = {4,"VA"}
					elseif Input[2][4] == "A" then
						InputArr = {4,"A"}
					else -- Offset {4,Mem}
						InputArr = {4,"Mem"}
					end
				end
			elseif type(Input[1]) == "table" then
				if Input[1][4] == "V" then -- {V, } 
					if type(Input[2]) == "number" then -- {V,4}
						InputArr = {"V",4}
					elseif type(Input[2]) == "table" then
						if Input[2][4] == "V" then -- {V,V}
							InputArr = {"V","V"}
						elseif Input[2][4] == "VA" then
							InputArr = {"V","VA"}
						elseif Input[2][4] == "A" then
							InputArr = {"V","A"}
						else -- {V,Mem}
							InputArr = {"V","Mem"}
						end
					end
				elseif Input[1][4] == "VA" then -- {V, } 
					if type(Input[2]) == "number" then -- {V,4}
						InputArr = {"VA",4}
					elseif type(Input[2]) == "table" then
						if Input[2][4] == "V" then -- {V,V}
							InputArr = {"VA","V"}
						elseif Input[2][4] == "VA" then
							InputArr = {"VA","VA"}
						elseif Input[2][4] == "A" then
							InputArr = {"VA","A"}
						else -- {V,Mem}
							InputArr = {"VA","Mem"}
						end
					end
				elseif Input[1][4] == "A" then -- {V, } 
					if type(Input[2]) == "number" then -- {V,4}
						InputArr = {"A",4}
					elseif type(Input[2]) == "table" then
						if Input[2][4] == "V" then -- {V,V}
							InputArr = {"A","V"}
						elseif Input[2][4] == "VA" then
							InputArr = {"A","VA"}
						elseif Input[2][4] == "A" then
							InputArr = {"A","A"}
						else -- {V,Mem}
							InputArr = {"A","Mem"}
						end
					end
				elseif type(Input[1][4]) ~= "string" then -- {Mem, }
					if type(Input[2]) == "number" then -- {Mem,4}
						InputArr = {"Mem",4}
					elseif type(Input[2]) == "table" then -- {Mem,{}}
						if #Input[2] == 1 then -- {Mem,{Size}}
							local Temp = Input
							Input = {}
							table.insert(Input,Temp[1])
							Temp[1][3] = Temp[1][3] + Input[2][1]
							table.insert(Input,Temp[1])
							InputArr = {"Mem","Mem"}
						elseif Input[2][4] == "V" then -- {Mem,V}
							InputArr = {"Mem","V"}
						elseif Input[2][4] == "VA" then
							InputArr = {"Mem","VA"}
						elseif Input[2][4] == "A" then
							InputArr = {"Mem","A"}
						else -- {Mem,Mem}
							InputArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LRead_InputData_Error()
			end
		elseif type(Input[4]) ~= "string" then -- Mem 4 
			local Temp = Input
			Input = {}
			table.insert(Input,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Input,Temp)
			InputArr = {"Mem","Mem"}
		else
			LRead_InputData_Error()
		end
	else
		LRead_InputData_Error()
	end

	local OutputArr = {}
	if Output == "Cp" then -- Cp
		LRead_OutputData_Error()
	elseif type(Output) == "number" then -- Offset 4
		Output = {Output,Output+4}
		OutputArr = {4,4}
	elseif type(Output) == "table" then
		if Output[4] == "WA" then -- W
			OutputArr = "WA"
		elseif Output[4] == "LA_V" then -- W
			OutputArr = "LA_V"
		elseif Output[4] == "LA_W" then
			OutputArr = "LA_W" 
		elseif Output[4] == "W" then -- W
			OutputArr = "W"
		elseif #Output == 2 then
			if Output[1] == "Cp" and type(Output[2][1]) == "number" then -- Cp + Diff(epd)
				LRead_OutputData_Error()
			elseif type(Output[1]) == "number" then -- Offset {4, } 
				if type(Output[2]) == "number" then -- Offset {4,4}
					OutputArr = {4,4}
				elseif type(Output[2]) == "table" then -- Offset {4,{ }}
					if #Output[2] == 1 then -- Offset {4,{Size}}
						Output = {Output[1],Output[1]+Output[2][1]}
						OutputArr = {4,4}
					elseif Output[2][4] == "V" then -- Offset {4,V}
						OutputArr = {4,"V"}
					elseif Output[2][4] == "VA" then
						OutputArr = {4,"VA"}
					elseif Output[2][4] == "A" then
						OutputArr = {4,"A"}
					else -- Offset {4,Mem}
						OutputArr = {4,"Mem"}
					end
				end
			elseif type(Output[1]) == "table" then
				if Output[1][4] == "V" then -- {V, } 
					if type(Output[2]) == "number" then -- {V,4}
						OutputArr = {"V",4}
					elseif type(Output[2]) == "table" then
						if Output[2][4] == "V" then -- {V,V}
							OutputArr = {"V","V"}
						elseif Output[2][4] == "VA" then
							OutputArr = {"V","VA"}
						elseif Output[2][4] == "A" then
							OutputArr = {"V","A"}
						else -- {V,Mem}
							OutputArr = {"V","Mem"}
						end
					end
				elseif Output[1][4] == "VA" then -- {V, } 
					if type(Output[2]) == "number" then -- {V,4}
						OutputArr = {"VA",4}
					elseif type(Output[2]) == "table" then
						if Output[2][4] == "V" then -- {V,V}
							OutputArr = {"VA","V"}
						elseif Output[2][4] == "VA" then
							OutputArr = {"VA","VA"}
						elseif Output[2][4] == "A" then
							OutputArr = {"VA","A"}
						else -- {V,Mem}
							OutputArr = {"VA","Mem"}
						end
					end
				elseif Output[1][4] == "A" then -- {V, } 
					if type(Output[2]) == "number" then -- {V,4}
						OutputArr = {"A",4}
					elseif type(Output[2]) == "table" then
						if Output[2][4] == "V" then -- {V,V}
							OutputArr = {"A","V"}
						elseif Output[2][4] == "VA" then
							OutputArr = {"A","VA"}
						elseif Output[2][4] == "A" then
							OutputArr = {"A","A"}
						else -- {V,Mem}
							OutputArr = {"A","Mem"}
						end
					end
				elseif type(Output[1][4]) ~= "string" then -- {Mem, }
					if type(Output[2]) == "number" then -- {Mem,4}
						OutputArr = {"Mem",4}
					elseif type(Output[2]) == "table" then -- {Mem,{}}
						if #Output[2] == 1 then -- {Mem,{Size}}
							local Temp = Output
							Output = {}
							table.insert(Output,Temp[1])
							Temp[1][3] = Temp[1][3] + Output[2][1]
							table.insert(Output,Temp[1])
							OutputArr = {"Mem","Mem"}
						elseif Output[2][4] == "V" then -- {Mem,V}
							OutputArr = {"Mem","V"}
						elseif Output[2][4] == "VA" then
							OutputArr = {"Mem","VA"}
						elseif Output[2][4] == "A" then
							OutputArr = {"Mem","A"}
						else -- {Mem,Mem}
							OutputArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LRead_OutputData_Error()
			end
		elseif type(Output[4]) ~= "string" then -- Mem 4 
			local Temp = Output
			Output = {}
			table.insert(Output,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Output,Temp)
			OutputArr = {"Mem","Mem"}
		else
			LRead_OutputData_Error()
		end
	else
		LRead_OutputData_Error()
	end

	-- Input Data CRet[1],CRet[2] << EPD 
	if InputArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
				SetCtrigX(Input[1],Input[2],0x198,Input[3],SetTo,"X",CRet[2],0x15C,1,0);
				SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x188,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Input[1],Input[2],0x1A0,Input[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Input[1],Input[2],Input[3]);
			},
			flag = {Preserved}
		}
	elseif InputArr == "WA" then
		MovW(PlayerID,{{"X",CRet[1],0,"V"},{"X",CRet[2],0,"V"}},Input)
	elseif InputArr == "LA_V" then
		MovZ(PlayerID,{{"X",CRet[1],0,"V"},{"X",CRet[2],0,"V"}},Input)
	elseif InputArr == "LA_W" then
		MovZ(PlayerID,{{"X",CRet[1],0,"V"},{"X",CRet[2],0,"V"}},Input)
	else
		for i = 1, 2 do
			if type(InputArr[i]) == "number" then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SetCtrig1X("X",CRet[i],0x15C,0,SetTo,EPD(Input[i]));
					},
					flag = {Preserved}
				}
			elseif InputArr[i] == "Mem" then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SetCtrigX("X",CRet[i],0x15C,0,SetTo,Input[i][1],Input[i][2],Input[i][3],1,Input[i][4]);
					},
					flag = {Preserved}
				}
			elseif InputArr[i] == "V" then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SetCtrigX(Input[i][1],Input[i][2],0x158,Input[i][3],SetTo,"X",CRet[i],0x15C,1,0);
						SetCtrig1X(Input[i][1],Input[i][2],0x148,Input[i][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Input[i][1],Input[i][2],0x160,Input[i][3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Input[i][1],Input[i][2],Input[i][3]);
					},
					flag = {Preserved}
				}
			elseif InputArr[i] == "A" then
				MovZ(PlayerID,{"X",CRet[i],0,"V"},Input[i]) 
			elseif InputArr[i] == "VA" then
				MovX(PlayerID,{"X",CRet[i],0,"V"},Input[i]) 
			end
		end
	end

	-- Call f_LRead
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadCall1,0x0,0,0);
					SetCtrigX("X",FLReadCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLReadCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[1] = Output
	
	if OutputArr == "W" then
		local ClearAct = {}
		if Clear == 1 then
			table.insert(ClearAct,SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,0))
			table.insert(ClearAct,SetCtrig1X(Output[1],Output[2],0x19C,Output[3],SetTo,0))
		end
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				ClearAct,
				SetCtrigX("X",WRet[1],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,Output[1],Output[2],0x19C,1,Output[3]);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
	elseif OutputArr == "WA" then
		MovW(PlayerID,Output,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif OutputArr == "LA_V" then
		MovW(PlayerID,Output,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif OutputArr == "LA_W" then
		MovW(PlayerID,Output,{"X",WRet[1],0,"W"},SetTo,Mask)
	else
		MovY(PlayerID,Output,{"X",WRet[1],0,"W"},OutputArr,Mask)
	end
	
	-- Option : RecoverCp
	RecoverCp(PlayerID)
end

function f_LReadX(PlayerID,Input,Output,Multiplier,Mask,Clear) -- (CPRead) 방식으로 읽음
	STPopTrigArr(PlayerID)
	if Multiplier == "X" or Multiplier == nil then
		Multiplier = 0
	end
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LRead_InputData_Error()
	end

	local InputArr = {}
	if Input == "Cp" then -- Cp
		LRead_InputData_Error()
	elseif type(Input) == "number" then -- Offset 4
		Input = {Input,Input+4}
		InputArr = {4,4}
	elseif type(Input) == "table" then
		if Input[4] == "WA" then -- W
			InputArr = "WA"
		elseif Input[4] == "LA_V" then -- W
			InputArr = "LA_V"
		elseif Input[4] == "LA_W" then
			InputArr = "LA_W" 
		elseif Input[4] == "W" then -- W
			InputArr = "W"
		elseif #Input == 2 then
			if Input[1] == "Cp" and type(Input[2][1]) == "number" then -- Cp + Diff(epd)
				LRead_InputData_Error()
			elseif type(Input[1]) == "number" then -- Offset {4, } 
				if type(Input[2]) == "number" then -- Offset {4,4}
					InputArr = {4,4}
				elseif type(Input[2]) == "table" then -- Offset {4,{ }}
					if #Input[2] == 1 then -- Offset {4,{Size}}
						Input = {Input[1],Input[1]+Input[2][1]}
						InputArr = {4,4}
					elseif Input[2][4] == "V" then -- Offset {4,V}
						InputArr = {4,"V"}
					elseif Input[2][4] == "VA" then
						InputArr = {4,"VA"}
					elseif Input[2][4] == "A" then
						InputArr = {4,"A"}
					else -- Offset {4,Mem}
						InputArr = {4,"Mem"}
					end
				end
			elseif type(Input[1]) == "table" then
				if Input[1][4] == "V" then -- {V, } 
					if type(Input[2]) == "number" then -- {V,4}
						InputArr = {"V",4}
					elseif type(Input[2]) == "table" then
						if Input[2][4] == "V" then -- {V,V}
							InputArr = {"V","V"}
						elseif Input[2][4] == "VA" then
							InputArr = {"V","VA"}
						elseif Input[2][4] == "A" then
							InputArr = {"V","A"}
						else -- {V,Mem}
							InputArr = {"V","Mem"}
						end
					end
				elseif Input[1][4] == "VA" then -- {V, } 
					if type(Input[2]) == "number" then -- {V,4}
						InputArr = {"VA",4}
					elseif type(Input[2]) == "table" then
						if Input[2][4] == "V" then -- {V,V}
							InputArr = {"VA","V"}
						elseif Input[2][4] == "VA" then
							InputArr = {"VA","VA"}
						elseif Input[2][4] == "A" then
							InputArr = {"VA","A"}
						else -- {V,Mem}
							InputArr = {"VA","Mem"}
						end
					end
				elseif Input[1][4] == "A" then -- {V, } 
					if type(Input[2]) == "number" then -- {V,4}
						InputArr = {"A",4}
					elseif type(Input[2]) == "table" then
						if Input[2][4] == "V" then -- {V,V}
							InputArr = {"A","V"}
						elseif Input[2][4] == "VA" then
							InputArr = {"A","VA"}
						elseif Input[2][4] == "A" then
							InputArr = {"A","A"}
						else -- {V,Mem}
							InputArr = {"A","Mem"}
						end
					end
				elseif type(Input[1][4]) ~= "string" then -- {Mem, }
					if type(Input[2]) == "number" then -- {Mem,4}
						InputArr = {"Mem",4}
					elseif type(Input[2]) == "table" then -- {Mem,{}}
						if #Input[2] == 1 then -- {Mem,{Size}}
							local Temp = Input
							Input = {}
							table.insert(Input,Temp[1])
							Temp[1][3] = Temp[1][3] + Input[2][1]
							table.insert(Input,Temp[1])
							InputArr = {"Mem","Mem"}
						elseif Input[2][4] == "V" then -- {Mem,V}
							InputArr = {"Mem","V"}
						elseif Input[2][4] == "VA" then
							InputArr = {"Mem","VA"}
						elseif Input[2][4] == "A" then
							InputArr = {"Mem","A"}
						else -- {Mem,Mem}
							InputArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LReadX_InputData_Error()
			end
		elseif type(Input[4]) ~= "string" then -- Mem 4 
			local Temp = Input
			Input = {}
			table.insert(Input,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Input,Temp)
			InputArr = {"Mem","Mem"}
		else
			LReadX_InputData_Error()
		end
	else
		LReadX_InputData_Error()
	end

	local OutputArr = {}
	if Output == "Cp" then -- Cp
		LRead_OutputData_Error()
	elseif type(Output) == "number" then -- Offset 4
		Output = {Output,Output+4}
		OutputArr = {4,4}
	elseif type(Output) == "table" then
		if Output[4] == "WA" then -- W
			OutputArr = "WA"
		elseif Output[4] == "LA_V" then -- W
			OutputArr = "LA_V"
		elseif Output[4] == "LA_W" then
			OutputArr = "LA_W" 
		elseif Output[4] == "W" then -- W
			OutputArr = "W"
		elseif #Output == 2 then
			if Output[1] == "Cp" and type(Output[2][1]) == "number" then -- Cp + Diff(epd)
				LRead_OutputData_Error()
			elseif type(Output[1]) == "number" then -- Offset {4, } 
				if type(Output[2]) == "number" then -- Offset {4,4}
					OutputArr = {4,4}
				elseif type(Output[2]) == "table" then -- Offset {4,{ }}
					if #Output[2] == 1 then -- Offset {4,{Size}}
						Output = {Output[1],Output[1]+Output[2][1]}
						OutputArr = {4,4}
					elseif Output[2][4] == "V" then -- Offset {4,V}
						OutputArr = {4,"V"}
					elseif Output[2][4] == "VA" then
						OutputArr = {4,"VA"}
					elseif Output[2][4] == "A" then
						OutputArr = {4,"A"}
					else -- Offset {4,Mem}
						OutputArr = {4,"Mem"}
					end
				end
			elseif type(Output[1]) == "table" then
				if Output[1][4] == "V" then -- {V, } 
					if type(Output[2]) == "number" then -- {V,4}
						OutputArr = {"V",4}
					elseif type(Output[2]) == "table" then
						if Output[2][4] == "V" then -- {V,V}
							OutputArr = {"V","V"}
						elseif Output[2][4] == "VA" then
							OutputArr = {"V","VA"}
						elseif Output[2][4] == "A" then
							OutputArr = {"V","A"}
						else -- {V,Mem}
							OutputArr = {"V","Mem"}
						end
					end
				elseif Output[1][4] == "VA" then -- {V, } 
					if type(Output[2]) == "number" then -- {V,4}
						OutputArr = {"VA",4}
					elseif type(Output[2]) == "table" then
						if Output[2][4] == "V" then -- {V,V}
							OutputArr = {"VA","V"}
						elseif Output[2][4] == "VA" then
							OutputArr = {"VA","VA"}
						elseif Output[2][4] == "A" then
							OutputArr = {"VA","A"}
						else -- {V,Mem}
							OutputArr = {"VA","Mem"}
						end
					end
				elseif Output[1][4] == "A" then -- {V, } 
					if type(Output[2]) == "number" then -- {V,4}
						OutputArr = {"A",4}
					elseif type(Output[2]) == "table" then
						if Output[2][4] == "V" then -- {V,V}
							OutputArr = {"A","V"}
						elseif Output[2][4] == "VA" then
							OutputArr = {"A","VA"}
						elseif Output[2][4] == "A" then
							OutputArr = {"A","A"}
						else -- {V,Mem}
							OutputArr = {"A","Mem"}
						end
					end
				elseif type(Output[1][4]) ~= "string" then -- {Mem, }
					if type(Output[2]) == "number" then -- {Mem,4}
						OutputArr = {"Mem",4}
					elseif type(Output[2]) == "table" then -- {Mem,{}}
						if #Output[2] == 1 then -- {Mem,{Size}}
							local Temp = Output
							Output = {}
							table.insert(Output,Temp[1])
							Temp[1][3] = Temp[1][3] + Output[2][1]
							table.insert(Output,Temp[1])
							OutputArr = {"Mem","Mem"}
						elseif Output[2][4] == "V" then -- {Mem,V}
							OutputArr = {"Mem","V"}
						elseif Output[2][4] == "VA" then
							OutputArr = {"Mem","VA"}
						elseif Output[2][4] == "A" then
							OutputArr = {"Mem","A"}
						else -- {Mem,Mem}
							OutputArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LReadX_InputData_Error()
			end
		elseif type(Output[4]) ~= "string" then -- Mem 4 
			local Temp = Output
			Output = {}
			table.insert(Output,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Output,Temp)
			OutputArr = {"Mem","Mem"}
		else
			LReadX_InputData_Error()
		end
	else
		LReadX_InputData_Error()
	end

	-- Input Data CRet[1],CRet[2] << EPD 
	if InputArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
				SetCtrigX(Input[1],Input[2],0x198,Input[3],SetTo,"X",CRet[2],0x15C,1,0);
				SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x188,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Input[1],Input[2],0x1A0,Input[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Input[1],Input[2],Input[3]);
			},
			flag = {Preserved}
		}
	elseif InputArr == "WA" then
		MovW(PlayerID,{{"X",CRet[1],0,"V"},{"X",CRet[2],0,"V"}},Input)
	elseif InputArr == "LA_V" then
		MovZ(PlayerID,{{"X",CRet[1],0,"V"},{"X",CRet[2],0,"V"}},Input)
	elseif InputArr == "LA_W" then
		MovZ(PlayerID,{{"X",CRet[1],0,"V"},{"X",CRet[2],0,"V"}},Input)
	else
		for i = 1, 2 do
			if type(InputArr[i]) == "number" then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SetCtrig1X("X",CRet[i],0x15C,0,SetTo,EPD(Input[i]));
					},
					flag = {Preserved}
				}
			elseif InputArr[i] == "Mem" then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SetCtrigX("X",CRet[i],0x15C,0,SetTo,Input[i][1],Input[i][2],Input[i][3],1,Input[i][4]);
					},
					flag = {Preserved}
				}
			elseif InputArr[i] == "V" then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SetCtrigX(Input[i][1],Input[i][2],0x158,Input[i][3],SetTo,"X",CRet[i],0x15C,1,0);
						SetCtrig1X(Input[i][1],Input[i][2],0x148,Input[i][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Input[i][1],Input[i][2],0x160,Input[i][3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Input[i][1],Input[i][2],Input[i][3]);
					},
					flag = {Preserved}
				}
			elseif InputArr[i] == "A" then
				MovZ(PlayerID,{"X",CRet[i],0,"V"},Input[i]) 
			elseif InputArr[i] == "VA" then
				MovX(PlayerID,{"X",CRet[i],0,"V"},Input[i]) 
			end
		end
	end

	-- Call f_LReadX
	if Multiplier == 0 then
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[1],0x0,0,0);
					SetCtrigX("X",FLReadXCall[2],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == 1 then
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[3],0x0,0,0);
					SetCtrigX("X",FLReadXCall[4],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == 2 then
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[5],0x0,0,0);
					SetCtrigX("X",FLReadXCall[6],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == 3 then
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[7],0x0,0,0);
					SetCtrigX("X",FLReadXCall[8],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == 4 then
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[9],0x0,0,0);
					SetCtrigX("X",FLReadXCall[10],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == 5 then
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[11],0x0,0,0);
					SetCtrigX("X",FLReadXCall[12],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == 6 then
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[13],0x0,0,0);
					SetCtrigX("X",FLReadXCall[14],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == 7 then
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[15],0x0,0,0);
					SetCtrigX("X",FLReadXCall[16],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == -1 then
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[17],0x0,0,0);
					SetCtrigX("X",FLReadXCall[18],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == -2 then
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[19],0x0,0,0);
					SetCtrigX("X",FLReadXCall[20],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == -3 then
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[21],0x0,0,0);
					SetCtrigX("X",FLReadXCall[22],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == -4 then
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[23],0x0,0,0);
					SetCtrigX("X",FLReadXCall[24],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == -5 then
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[25],0x0,0,0);
					SetCtrigX("X",FLReadXCall[26],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == -6 then
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[27],0x0,0,0);
					SetCtrigX("X",FLReadXCall[28],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == -7 then
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[29],0x0,0,0);
					SetCtrigX("X",FLReadXCall[30],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	else
		LReadX_InputData_Error()
	end

	if FLReadXCall[1] == nil then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[1] = Output
	
	if OutputArr == "W" then
		local ClearAct = {}
		if Clear == 1 then
			table.insert(ClearAct,SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,0))
			table.insert(ClearAct,SetCtrig1X(Output[1],Output[2],0x19C,Output[3],SetTo,0))
		end
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				ClearAct,
				SetCtrigX("X",WRet[1],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,Output[1],Output[2],0x19C,1,Output[3]);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
	elseif OutputArr == "WA" then
		MovW(PlayerID,Output,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif OutputArr == "LA_V" then
		MovW(PlayerID,Output,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif OutputArr == "LA_W" then
		MovW(PlayerID,Output,{"X",WRet[1],0,"W"},SetTo,Mask)
	else
		MovY(PlayerID,Output,{"X",WRet[1],0,"W"},OutputArr,Mask)
	end
	
	-- Option : RecoverCp
	RecoverCp(PlayerID)
end

function f_LAnd(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LAnd_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LAnd_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LAnd_InputData_Error()
		end
	else
		LAnd_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LAnd_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LAnd_InputData_Error()
		elseif Source[4] == "LA_W" then
			LAnd_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LAnd_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LAnd_InputData_Error()
					else -- Offset {4,Mem}
						LAnd_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LAnd_InputData_Error()
						else -- {V,Mem}
							LAnd_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LAnd_InputData_Error()
						else -- {V,Mem}
							LAnd_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LAnd_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LAnd_InputData_Error()
				end
			else
				LAnd_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LAnd_InputData_Error()
		else
			LAnd_InputData_Error()
		end
	else
		LAnd_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LAnd_InputData_Error()
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LAnd_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LAnd_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LAnd_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LAnd_InputData_Error()
					else -- Offset {4,Mem}
						LAnd_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LAnd_InputData_Error()
						else -- {V,Mem}
							LAnd_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LAnd_InputData_Error()
						else -- {V,Mem}
							LAnd_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LAnd_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LAnd_InputData_Error()
				end
			else
				LAnd_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LAnd_InputData_Error()
		else
			LAnd_InputData_Error()
		end
	else
		LAnd_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end
	-- Input Data WRet[3] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[3],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[3],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[3],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[3],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LAnd
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLAndCall1,0x0,0,0);
					SetCtrigX("X",FLAndCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLAndCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[2] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[2],0,"W"},DestArr,Mask)
	end
end

function f_LOr(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LOr_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LOr_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LOr_InputData_Error()
		end
	else
		LOr_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LOr_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LOr_InputData_Error()
		elseif Source[4] == "LA_W" then
			LOr_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LOr_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LOr_InputData_Error()
					else -- Offset {4,Mem}
						LOr_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LOr_InputData_Error()
						else -- {V,Mem}
							LOr_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LOr_InputData_Error()
						else -- {V,Mem}
							LOr_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LOr_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LOr_InputData_Error()
				end
			else
				LOr_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LOr_InputData_Error()
		else
			LOr_InputData_Error()
		end
	else
		LOr_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LOr_InputData_Error()
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LOr_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LOr_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LOr_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LOr_InputData_Error()
					else -- Offset {4,Mem}
						LOr_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LOr_InputData_Error()
						else -- {V,Mem}
							LOr_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LOr_InputData_Error()
						else -- {V,Mem}
							LOr_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LOr_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LOr_InputData_Error()
				end
			else
				LOr_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LOr_InputData_Error()
		else
			LOr_InputData_Error()
		end
	else
		LOr_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end
	-- Input Data WRet[3] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[3],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[3],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[3],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[3],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LOr
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLOrCall1,0x0,0,0);
					SetCtrigX("X",FLOrCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLOrCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[2] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[2],0,"W"},DestArr,Mask)
	end
end

function f_LXor(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LXor_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LXor_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LXor_InputData_Error()
		end
	else
		LXor_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LXor_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LXor_InputData_Error()
		elseif Source[4] == "LA_W" then
			LXor_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LXor_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LXor_InputData_Error()
					else -- Offset {4,Mem}
						LXor_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LXor_InputData_Error()
						else -- {V,Mem}
							LXor_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LXor_InputData_Error()
						else -- {V,Mem}
							LXor_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LXor_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LXor_InputData_Error()
				end
			else
				LXor_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LXor_InputData_Error()
		else
			LXor_InputData_Error()
		end
	else
		LXor_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LXor_InputData_Error()
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LXor_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LXor_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LXor_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LXor_InputData_Error()
					else -- Offset {4,Mem}
						LXor_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LXor_InputData_Error()
						else -- {V,Mem}
							LXor_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LXor_InputData_Error()
						else -- {V,Mem}
							LXor_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LXor_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LXor_InputData_Error()
				end
			else
				LXor_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LXor_InputData_Error()
		else
			LXor_InputData_Error()
		end
	else
		LXor_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end
	-- Input Data WRet[3] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[3],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[3],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[3],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[3],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LXor
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLXorCall1,0x0,0,0);
					SetCtrigX("X",FLXorCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLXorCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[2] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[2],0,"W"},DestArr,Mask)
	end
end

function f_LNot(PlayerID,Dest,Source,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LNot_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LNot_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LNot_InputData_Error()
		end
	else
		LNot_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LNot_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LNot_InputData_Error()
		elseif Source[4] == "LA_W" then
			LNot_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LNot_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LNot_InputData_Error()
					else -- Offset {4,Mem}
						LNot_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LNot_InputData_Error()
						else -- {V,Mem}
							LNot_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LNot_InputData_Error()
						else -- {V,Mem}
							LNot_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LNot_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LNot_InputData_Error()
				end
			else
				LNot_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LNot_InputData_Error()
		else
			LNot_InputData_Error()
		end
	else
		LNot_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LNot
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLNotCall1,0x0,0,0);
					SetCtrigX("X",FLNotCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLNotCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[1] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[1],0,"W"},DestArr,Mask)
	end
end

function f_LAdd(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LAdd_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LAdd_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LAdd_InputData_Error()
		end
	else
		LAdd_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LAdd_InputData_Error()
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LAdd_InputData_Error()
		elseif Source[4] == "LA_W" then
			LAdd_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LAdd_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LAdd_InputData_Error()
					else -- Offset {4,Mem}
						LAdd_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LAdd_InputData_Error()
						else -- {V,Mem}
							LAdd_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LAdd_InputData_Error()
						else -- {V,Mem}
							LAdd_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LAdd_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LAdd_InputData_Error()
				end
			else
				LAdd_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LAdd_InputData_Error()
		else
			LAdd_InputData_Error()
		end
	else
		LAdd_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LAdd_InputData_Error()
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LAdd_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LAdd_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LAdd_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LAdd_InputData_Error()
					else -- Offset {4,Mem}
						LAdd_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LAdd_InputData_Error()
						else -- {V,Mem}
							LAdd_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LAdd_InputData_Error()
						else -- {V,Mem}
							LAdd_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LAdd_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LAdd_InputData_Error()
				end
			else
				LAdd_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LAdd_InputData_Error()
		else
			LAdd_InputData_Error()
		end
	else
		LAdd_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end
	-- Input Data WRet[3] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[3],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[3],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[3],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[3],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LAdd
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLAddCall1,0x0,0,0);
					SetCtrigX("X",FLAddCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLAddCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[2] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[2],0,"W"},DestArr,Mask)
	end
end

function f_LSub(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LSub_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LSub_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LSub_InputData_Error()
		end
	else
		LSub_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LSub_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LSub_InputData_Error()
		elseif Source[4] == "LA_W" then
			LSub_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LSub_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LSub_InputData_Error()
					else -- Offset {4,Mem}
						LSub_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LSub_InputData_Error()
						else -- {V,Mem}
							LSub_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LSub_InputData_Error()
						else -- {V,Mem}
							LSub_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LSub_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LSub_InputData_Error()
				end
			else
				LSub_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LSub_InputData_Error()
		else
			LSub_InputData_Error()
		end
	else
		LSub_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LSub_InputData_Error()
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LSub_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LSub_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LSub_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LSub_InputData_Error()
					else -- Offset {4,Mem}
						LSub_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LSub_InputData_Error()
						else -- {V,Mem}
							LSub_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LSub_InputData_Error()
						else -- {V,Mem}
							LSub_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LSub_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LSub_InputData_Error()
				end
			else
				LSub_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LSub_InputData_Error()
		else
			LSub_InputData_Error()
		end
	else
		LSub_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end
	-- Input Data WRet[3] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[3],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[3],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[3],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[3],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LSub
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLSubCall1,0x0,0,0);
					SetCtrigX("X",FLSubCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLSubCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[2] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[2],0,"W"},DestArr,Mask)
	end
end

function f_LNeg(PlayerID,Dest,Source,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LNeg_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LNeg_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LNeg_InputData_Error()
		end
	else
		LNeg_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LNeg_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LNeg_InputData_Error()
		elseif Source[4] == "LA_W" then
			LNeg_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LNeg_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LNeg_InputData_Error()
					else -- Offset {4,Mem}
						LNeg_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LNeg_InputData_Error()
						else -- {V,Mem}
							LNeg_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LNeg_InputData_Error()
						else -- {V,Mem}
							LNeg_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LNeg_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LNeg_InputData_Error()
				end
			else
				LNeg_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LNeg_InputData_Error()
		else
			LNeg_InputData_Error()
		end
	else
		LNeg_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LNeg
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLNegCall1,0x0,0,0);
					SetCtrigX("X",FLNegCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLNegCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[1] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[1],0,"W"},DestArr,Mask)
	end
end

function f_LiSub(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LiSub_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LiSub_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LiSub_InputData_Error()
		end
	else
		LiSub_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LiSub_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LiSub_InputData_Error()
		elseif Source[4] == "LA_W" then
			LiSub_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LiSub_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LiSub_InputData_Error()
					else -- Offset {4,Mem}
						LiSub_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LiSub_InputData_Error()
						else -- {V,Mem}
							LiSub_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LiSub_InputData_Error()
						else -- {V,Mem}
							LiSub_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LiSub_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LiSub_InputData_Error()
				end
			else
				LiSub_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LiSub_InputData_Error()
		else
			LiSub_InputData_Error()
		end
	else
		LiSub_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LiSub_InputData_Error()
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LiSub_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LiSub_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LiSub_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LiSub_InputData_Error()
					else -- Offset {4,Mem}
						LiSub_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LiSub_InputData_Error()
						else -- {V,Mem}
							LiSub_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LiSub_InputData_Error()
						else -- {V,Mem}
							LiSub_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LiSub_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LiSub_InputData_Error()
				end
			else
				LiSub_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LiSub_InputData_Error()
		else
			LiSub_InputData_Error()
		end
	else
		LiSub_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end
	-- Input Data WRet[3] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[3],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[3],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[3],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[3],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LiSub
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLiSubCall1,0x0,0,0);
					SetCtrigX("X",FLiSubCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLiSubCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[1] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[1],0,"W"},DestArr,Mask)
	end
end

function f_LAbs(PlayerID,Dest,Source,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LAbs_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LAbs_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LAbs_InputData_Error()
		end
	else
		LAbs_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LAbs_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LAbs_InputData_Error()
		elseif Source[4] == "LA_W" then
			LAbs_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LAbs_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LAbs_InputData_Error()
					else -- Offset {4,Mem}
						LAbs_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LAbs_InputData_Error()
						else -- {V,Mem}
							LAbs_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LAbs_InputData_Error()
						else -- {V,Mem}
							LAbs_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LAbs_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LAbs_InputData_Error()
				end
			else
				LAbs_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LAbs_InputData_Error()
		else
			LAbs_InputData_Error()
		end
	else
		LAbs_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LAbs
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLAbsCall1,0x0,0,0);
					SetCtrigX("X",FLAbsCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLAbsCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[1] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[1],0,"W"},DestArr,Mask)
	end
end

function f_LRand(PlayerID,Dest,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LRand_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LRand_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LRand_InputData_Error()
		end
	else
		LRand_InputData_Error()
	end

	-- Call f_LRand
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLRandCall1,0x0,0,0);
					SetCtrigX("X",FLRandCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLRandCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[1] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[1],0,"W"},DestArr,Mask)
	end
end


function f_LlShift(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LlShift_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LlShift_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LlShift_InputData_Error()
		end
	else
		LlShift_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LlShift_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LlShift_InputData_Error()
		elseif Source[4] == "LA_W" then
			LlShift_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LlShift_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LlShift_InputData_Error()
					else -- Offset {4,Mem}
						LlShift_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LlShift_InputData_Error()
						else -- {V,Mem}
							LlShift_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LlShift_InputData_Error()
						else -- {V,Mem}
							LlShift_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LlShift_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LlShift_InputData_Error()
				end
			else
				LlShift_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LlShift_InputData_Error()
		else
			LlShift_InputData_Error()
		end
	else
		LlShift_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Input Data CRet[1] << Value
	if type(Operand) == "number" then
		Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {Label(0);},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Operand,0x3F);
				},
				flag = {Preserved}
			}
	elseif Operand[4] == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",CRet[1],0x15C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x198,Operand[3],SetTo,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0x3F);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif Operand[4] == "WA" then
		f_Cast(PlayerID,{{"X",CRet[1],0,"V"},0},Operand,0,{0x3F,0})
	elseif Operand[4] == "V" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",CRet[1],0x15C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0x3F);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif Operand[4] == "VA" then
		MovX(PlayerID,{"X",CRet[1],0,"V"},Operand,SetTo,0x3F)
	end

	-- Call f_LlShift
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0,0xFFFFFFFF-0x3F);
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLlShiftCall1,0x0,0,0);
					SetCtrigX("X",FLlShiftCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLlShiftCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[2] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[2],0,"W"},DestArr,Mask)
	end
end



function f_LDiv(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LDiv_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LDiv_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LDiv_InputData_Error()
		end
	else
		LDiv_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LDiv_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LDiv_InputData_Error()
		elseif Source[4] == "LA_W" then
			LDiv_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LDiv_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LDiv_InputData_Error()
					else -- Offset {4,Mem}
						LDiv_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LDiv_InputData_Error()
						else -- {V,Mem}
							LDiv_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LDiv_InputData_Error()
						else -- {V,Mem}
							LDiv_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LDiv_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LDiv_InputData_Error()
				end
			else
				LDiv_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LDiv_InputData_Error()
		else
			LDiv_InputData_Error()
		end
	else
		LDiv_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LDiv_InputData_Error()
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LDiv_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LDiv_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LDiv_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LDiv_InputData_Error()
					else -- Offset {4,Mem}
						LDiv_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LDiv_InputData_Error()
						else -- {V,Mem}
							LDiv_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LDiv_InputData_Error()
						else -- {V,Mem}
							LDiv_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LDiv_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LDiv_InputData_Error()
				end
			else
				LDiv_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LDiv_InputData_Error()
		else
			LDiv_InputData_Error()
		end
	else
		LDiv_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Input Data WRet[3] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[3],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[3],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[3],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[3],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LDiv
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLDivCall1,0x0,0,0);
					SetCtrigX("X",FLDivCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLDivCall1 == 0 then
		Need_Include_64BitLibrary()
	end


	-- Output Data WRet[1] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[1],0,"W"},DestArr,Mask)
	end
end


function f_LMod(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LMod_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LMod_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LMod_InputData_Error()
		end
	else
		LMod_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LMod_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LMod_InputData_Error()
		elseif Source[4] == "LA_W" then
			LMod_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LMod_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LMod_InputData_Error()
					else -- Offset {4,Mem}
						LMod_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LMod_InputData_Error()
						else -- {V,Mem}
							LMod_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LMod_InputData_Error()
						else -- {V,Mem}
							LMod_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LMod_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LMod_InputData_Error()
				end
			else
				LMod_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LMod_InputData_Error()
		else
			LMod_InputData_Error()
		end
	else
		LMod_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LMod_InputData_Error()
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LMod_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LMod_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LMod_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LMod_InputData_Error()
					else -- Offset {4,Mem}
						LMod_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LMod_InputData_Error()
						else -- {V,Mem}
							LMod_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LMod_InputData_Error()
						else -- {V,Mem}
							LMod_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LMod_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LMod_InputData_Error()
				end
			else
				LMod_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LMod_InputData_Error()
		else
			LMod_InputData_Error()
		end
	else
		LMod_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Input Data WRet[3] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[3],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[3],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[3],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[3],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LMod
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLModCall1,0x0,0,0);
					SetCtrigX("X",FLModCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLModCall1 == 0 then
		Need_Include_64BitLibrary()
	end


	-- Output Data WRet[2] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[2],0,"W"},DestArr,Mask)
	end
end



function f_LiDiv(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LiDiv_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LiDiv_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LiDiv_InputData_Error()
		end
	else
		LiDiv_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LiDiv_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LiDiv_InputData_Error()
		elseif Source[4] == "LA_W" then
			LiDiv_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LiDiv_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LiDiv_InputData_Error()
					else -- Offset {4,Mem}
						LiDiv_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LiDiv_InputData_Error()
						else -- {V,Mem}
							LiDiv_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LiDiv_InputData_Error()
						else -- {V,Mem}
							LiDiv_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LiDiv_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LiDiv_InputData_Error()
				end
			else
				LiDiv_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LiDiv_InputData_Error()
		else
			LiDiv_InputData_Error()
		end
	else
		LiDiv_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LiDiv_InputData_Error()
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LiDiv_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LiDiv_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LiDiv_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LiDiv_InputData_Error()
					else -- Offset {4,Mem}
						LiDiv_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LiDiv_InputData_Error()
						else -- {V,Mem}
							LiDiv_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LiDiv_InputData_Error()
						else -- {V,Mem}
							LiDiv_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LiDiv_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LiDiv_InputData_Error()
				end
			else
				LiDiv_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LiDiv_InputData_Error()
		else
			LiDiv_InputData_Error()
		end
	else
		LiDiv_InputData_Error()
	end

	-- Input Data WRet[4] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[4],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[4],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[4],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[4],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[4],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[4],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Input Data WRet[3] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[3],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[3],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[3],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[3],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LiDiv
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLiDivCall1,0x0,0,0);
					SetCtrigX("X",FLiDivCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLiDivCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[4] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[4],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[4],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[4],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[4],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[4],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[4],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[4],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[4],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[4],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[4],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[4],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[4],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[4],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[4],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[4],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[4],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[4],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[4],0,"W"},DestArr,Mask)
	end
end



function f_LiMod(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LiMod_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LiMod_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LiMod_InputData_Error()
		end
	else
		LiMod_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LiMod_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LiMod_InputData_Error()
		elseif Source[4] == "LA_W" then
			LiMod_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LiMod_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LiMod_InputData_Error()
					else -- Offset {4,Mem}
						LiMod_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LiMod_InputData_Error()
						else -- {V,Mem}
							LiMod_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LiMod_InputData_Error()
						else -- {V,Mem}
							LiMod_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LiMod_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LiMod_InputData_Error()
				end
			else
				LiMod_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LiMod_InputData_Error()
		else
			LiMod_InputData_Error()
		end
	else
		LiMod_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LiMod_InputData_Error()
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LiMod_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LiMod_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LiMod_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LiMod_InputData_Error()
					else -- Offset {4,Mem}
						LiMod_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LiMod_InputData_Error()
						else -- {V,Mem}
							LiMod_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LiMod_InputData_Error()
						else -- {V,Mem}
							LiMod_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LiMod_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LiMod_InputData_Error()
				end
			else
				LiMod_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LiMod_InputData_Error()
		else
			LiMod_InputData_Error()
		end
	else
		LiMod_InputData_Error()
	end

	-- Input Data WRet[4] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[4],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[4],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[4],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[4],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[4],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[4],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Input Data WRet[3] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[3],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[3],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[3],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[3],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LiMod
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLiModCall1,0x0,0,0);
					SetCtrigX("X",FLiModCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLiModCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[4] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[4],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[4],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[4],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[4],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[4],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[4],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[4],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[4],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[4],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[4],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[4],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[4],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[4],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[4],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[4],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[4],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[4],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[4],0,"W"},DestArr,Mask)
	end
end


function f_LMul(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LMul_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LMul_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LMul_InputData_Error()
		end
	else
		LMul_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LMul_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LMul_InputData_Error()
		elseif Source[4] == "LA_W" then
			LMul_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LMul_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LMul_InputData_Error()
					else -- Offset {4,Mem}
						LMul_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LMul_InputData_Error()
						else -- {V,Mem}
							LMul_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LMul_InputData_Error()
						else -- {V,Mem}
							LMul_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LMul_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LMul_InputData_Error()
				end
			else
				LMul_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LMul_InputData_Error()
		else
			LMul_InputData_Error()
		end
	else
		LMul_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LMul_InputData_Error()
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LMul_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LMul_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LMul_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LMul_InputData_Error()
					else -- Offset {4,Mem}
						LMul_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LMul_InputData_Error()
						else -- {V,Mem}
							LMul_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LMul_InputData_Error()
						else -- {V,Mem}
							LMul_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LMul_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LMul_InputData_Error()
				end
			else
				LMul_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LMul_InputData_Error()
		else
			LMul_InputData_Error()
		end
	else
		LMul_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FLMulIndex,0x19C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",FLMulIndex,0x1BC,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{{"X",FLMulIndex,0x19C,0},{"X",FLMulIndex,0x1BC,0}},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",FLMulIndex,0x19C+0x20*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",FLMulIndex,0x19C+0x20*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",FLMulIndex,0x19C+0x20*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end
	-- Input Data WRet[3] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[3],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[3],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[3],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[3],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LMul
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLMulCall1,0x0,0,0);
					SetCtrigX("X",FLMulCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLMulCall1 == 0 then
		Need_Include_64BitLibrary()
	end


	-- Output Data WRet[1] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[1],0,"W"},DestArr,Mask)
	end
end

function f_LiMul(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LiMul_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LiMul_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LiMul_InputData_Error()
		end
	else
		LiMul_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LiMul_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LiMul_InputData_Error()
		elseif Source[4] == "LA_W" then
			LiMul_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LiMul_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LiMul_InputData_Error()
					else -- Offset {4,Mem}
						LiMul_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LiMul_InputData_Error()
						else -- {V,Mem}
							LiMul_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LiMul_InputData_Error()
						else -- {V,Mem}
							LiMul_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LiMul_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LiMul_InputData_Error()
				end
			else
				LiMul_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LiMul_InputData_Error()
		else
			LiMul_InputData_Error()
		end
	else
		LiMul_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LiMul_InputData_Error()
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LiMul_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LiMul_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LiMul_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LiMul_InputData_Error()
					else -- Offset {4,Mem}
						LiMul_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LiMul_InputData_Error()
						else -- {V,Mem}
							LiMul_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LiMul_InputData_Error()
						else -- {V,Mem}
							LiMul_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LiMul_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LiMul_InputData_Error()
				end
			else
				LiMul_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LiMul_InputData_Error()
		else
			LiMul_InputData_Error()
		end
	else
		LiMul_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FLMulIndex,0x19C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",FLMulIndex,0x1BC,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{{"X",FLMulIndex,0x19C,0},{"X",FLMulIndex,0x1BC,0}},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",FLMulIndex,0x19C+0x20*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",FLMulIndex,0x19C+0x20*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",FLMulIndex,0x19C+0x20*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Input Data WRet[2] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LiMul
	Trigger {
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLiMulCall1,0x0,0,0);
					SetCtrigX("X",FLiMulCall2,0x4,0,SetTo,"X","X",0x0,0,1);
					SetCtrigX("X",FLMulCall2,0x4,0,SetTo,"X",FLMulCall2,0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLiMulCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[2] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[2],0,"W"},DestArr,Mask)
	end
end

FLReadCall1 = 0
FLReadCall2 = 0
FLReadXCall = {}
FLAddCall1 = 0
FLAddCall2 = 0
FLSubCall1 = 0
FLSubIndex = 0
FLSubCall2 = 0
FLNegCall1 = 0
FLNegCall2 = 0
FLiSubCall1 = 0
FLiSubCall2 = 0
FLAbsCall1 = 0
FLAbsCall2 = 0
FLRandCall1 = 0
FLRandCall2 = 0
FLlShiftCall1 = 0
FLlShiftCall2 = 0
FLMulCall1 = 0
FLMulCall2 = 0
FLiMulCall1 = 0
FLiMulCall2 = 0
FLAndCall1 = 0
FLAndCall2 = 0
FLOrCall1 = 0
FLOrCall2 = 0
FLNotCall1 = 0
FLNotCall2 = 0
FLXorCall1 = 0
FLXorCall2 = 0
FLDIVCall1 = 0
FLDIVCall2 = 0
FLiDIVCall1 = 0
FLiDIVCall2 = 0
FLMODCall1 = 0
FLMODCall2 = 0
FLiMODCall1 = 0
FLiMODCall2 = 0
function Include_64BitLibrary(SeedSwitch,PlayerID) -- f_LRead / f_LReadX / f_LAdd / f_LSub / f_LNeg / f_LiSub / f_LAbs / f_LRand / f_LlShift / f_LMul / f_LiMul
	local IncludePlayer
	if PlayerID == nil then
		IncludePlayer = AllPlayers
	else
		IncludePlayer = ParsePlayer(PlayerID)
	end
	if SeedSwitch == "X" or nil then
		Need_SeedSwitch_Error()
	end
--------------------- f_LiDiv-------------------------------------------------------
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- FLIDIV1
				},
				flag = {Preserved}
			}
		CIfX(IncludePlayer,CtrigX("X",WRet[4],0x19C,0,AtLeast,0x80000000))
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,1); -- Sflag
						SetCtrig1X("X",WRet[4],0x15C,0,Add,-1);
						SetCtrig1X("X",WRet[2],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[2],0x19C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",WRet[4],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
						SetCtrigX("X",WRet[4],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
						SetCtrig1X("X",WRet[4],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[4],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[4],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						SetCtrig1X("X",WRet[4],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",WRet[4],0);
					},
					flag = {Preserved}
				}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",WRet[2],0x15C,0,Exactly,0);
				},
				actions = {
					SetCtrig1X("X",WRet[2],0x19C,0,Add,1);
				},
				flag = {Preserved}
			}	
		CElseX()
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0); -- Sflag
						SetCtrigX("X",WRet[4],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
						SetCtrigX("X",WRet[4],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
						SetCtrig1X("X",WRet[4],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[4],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",WRet[4],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",WRet[4],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()

		CIfX(IncludePlayer,CtrigX("X",WRet[3],0x19C,0,AtLeast,0x80000000))
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,Add,1,0x1); -- Sflag
						SetCtrig1X("X",WRet[3],0x15C,0,Add,-1);
						SetCtrig1X("X",FuncAlloc+5,0x15C+0x20*0,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FuncAlloc+5,0x15C+0x20*3,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FuncAlloc+5,0x15C+0x20*3,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FuncAlloc+5,0x15C+0x20*0,1,0);
						SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[3],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+5,0x15C+0x20*1,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FuncAlloc+5,0x15C+0x20*4,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FuncAlloc+5,0x15C+0x20*4,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FuncAlloc+5,0x15C+0x20*1,1,0);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+5,0x15C+0x20*2,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FuncAlloc+5,0x15C+0x20*5,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FuncAlloc+5,0x15C+0x20*5,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FuncAlloc+5,0x15C+0x20*2,1,0);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",FuncAlloc+5,0x15C+0x20*3,0,Exactly,0);
				},
				actions = {
					SetCtrig1X("X",FuncAlloc+5,0x15C+0x20*0,0,Add,1);
					SetCtrig1X("X",FuncAlloc+5,0x15C+0x20*1,0,Add,1);
					SetCtrig1X("X",FuncAlloc+5,0x15C+0x20*2,0,Add,1);
				},
				flag = {Preserved}
			}	
		CElseX()
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FuncAlloc+5,0x15C+0x20*3,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FuncAlloc+5,0x15C+0x20*0,1,0);
						SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FuncAlloc+5,0x15C+0x20*4,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FuncAlloc+5,0x15C+0x20*1,1,0);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FuncAlloc+5,0x15C+0x20*5,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FuncAlloc+5,0x15C+0x20*2,1,0);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- /0
					CtrigX("X",WRet[3],0x15C,0,Exactly,0);
					CtrigX("X",WRet[3],0x19C,0,Exactly,0);
					CtrigX("X",CRet[1],0x15C,0,Exactly,0,0x1);
				},
				actions = {
					SetCtrig1X("X",WRet[4],0x19C,0,SetTo,0x7FFFFFFF); 
					SetCtrig1X("X",WRet[4],0x15C,0,SetTo,0xFFFFFFFF); 
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+7,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+7,0x4,0,SetTo,"X",FuncAlloc+13,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+7,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FuncAlloc+7,0x15C,0,SetTo,"X","X",0,0,1);

				},
				flag = {Preserved}
			}

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- /0
					CtrigX("X",WRet[3],0x15C,0,Exactly,0);
					CtrigX("X",WRet[3],0x19C,0,Exactly,0);
					CtrigX("X",CRet[1],0x15C,0,Exactly,1,0x1);
				},
				actions = {
					SetCtrig1X("X",WRet[4],0x19C,0,SetTo,0x80000000); 
					SetCtrig1X("X",WRet[4],0x15C,0,SetTo,0x00000000); 
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+7,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+7,0x4,0,SetTo,"X",FuncAlloc+13,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+7,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FuncAlloc+7,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- FIDIV1
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+4,0x0,0,0); -- goto Div Calc Start
					SetCtrigX("X",FuncAlloc+7,0x4,0,SetTo,"X",FuncAlloc+12,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+7,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FuncAlloc+7,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}
		
	FLIDIVCall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1
--------------------- f_LiMod-------------------------------------------------------

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- FLIMOD1
				},
				flag = {Preserved}
			}

		CIfX(IncludePlayer,CtrigX("X",WRet[4],0x19C,0,AtLeast,0x80000000))
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,1); -- Sflag
						SetCtrig1X("X",WRet[4],0x15C,0,Add,-1);
						SetCtrig1X("X",WRet[2],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[2],0x19C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",WRet[4],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
						SetCtrigX("X",WRet[4],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
						SetCtrig1X("X",WRet[4],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[4],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[4],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						SetCtrig1X("X",WRet[4],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",WRet[4],0);
					},
					flag = {Preserved}
				}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",WRet[2],0x15C,0,Exactly,0);
				},
				actions = {
					SetCtrig1X("X",WRet[2],0x19C,0,Add,1);
				},
				flag = {Preserved}
			}	
		CElseX()
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0); -- Sflag
						SetCtrigX("X",WRet[4],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
						SetCtrigX("X",WRet[4],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
						SetCtrig1X("X",WRet[4],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[4],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",WRet[4],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",WRet[4],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()

		CIfX(IncludePlayer,CtrigX("X",WRet[3],0x19C,0,AtLeast,0x80000000))
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",WRet[3],0x15C,0,Add,-1);
						SetCtrig1X("X",FuncAlloc+4,0x15C+0x20*0,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FuncAlloc+4,0x15C+0x20*3,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FuncAlloc+4,0x15C+0x20*3,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FuncAlloc+4,0x15C+0x20*0,1,0);
						SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[3],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+4,0x15C+0x20*1,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FuncAlloc+4,0x15C+0x20*4,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FuncAlloc+4,0x15C+0x20*4,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FuncAlloc+4,0x15C+0x20*1,1,0);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+4,0x15C+0x20*2,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FuncAlloc+4,0x15C+0x20*5,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FuncAlloc+4,0x15C+0x20*5,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FuncAlloc+4,0x15C+0x20*2,1,0);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",FuncAlloc+4,0x15C+0x20*3,0,Exactly,0);
				},
				actions = {
					SetCtrig1X("X",FuncAlloc+4,0x15C+0x20*0,0,Add,1);
					SetCtrig1X("X",FuncAlloc+4,0x15C+0x20*1,0,Add,1);
					SetCtrig1X("X",FuncAlloc+4,0x15C+0x20*2,0,Add,1);
				},
				flag = {Preserved}
			}	
		CElseX()
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FuncAlloc+4,0x15C+0x20*3,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FuncAlloc+4,0x15C+0x20*0,1,0);
						SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FuncAlloc+4,0x15C+0x20*4,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FuncAlloc+4,0x15C+0x20*1,1,0);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FuncAlloc+4,0x15C+0x20*5,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FuncAlloc+4,0x15C+0x20*2,1,0);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- /0
					CtrigX("X",CRet[1],0x15C,0,Exactly,0,1);
					CtrigX("X",WRet[3],0x15C,0,Exactly,0);
					CtrigX("X",WRet[3],0x19C,0,Exactly,0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+6,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+6,0x4,0,SetTo,"X",FuncAlloc+10,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+6,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FuncAlloc+6,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- /0
					CtrigX("X",CRet[1],0x15C,0,Exactly,1,1);
					CtrigX("X",WRet[3],0x15C,0,Exactly,0);
					CtrigX("X",WRet[3],0x19C,0,Exactly,0);
				},
				actions = {
					SetCtrig1X("X",WRet[4],0x15C,0,Add,1);
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+6,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+6,0x4,0,SetTo,"X",FuncAlloc+10,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+6,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FuncAlloc+6,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+3,0x0,0,0); -- goto Div Calc Start
					SetCtrigX("X",FuncAlloc+6,0x4,0,SetTo,"X",FuncAlloc+9,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+6,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FuncAlloc+6,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}

	FLIMODCall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1
--------------------- f_LDiv-------------------------------------------------------
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- FLDIV1
				},
				actions = {
					SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FuncAlloc+3,0x15C+0x20*3,1,0);
					SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FuncAlloc+3,0x15C+0x20*0,1,0);
					SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",WRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",WRet[3],0);
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FuncAlloc+3,0x15C+0x20*4,1,0);
					SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FuncAlloc+3,0x15C+0x20*1,1,0);
					CallLabelAlways("X",WRet[3],0);
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- /0
					CtrigX("X",WRet[3],0x15C,0,Exactly,0);
					CtrigX("X",WRet[3],0x19C,0,Exactly,0);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0xFFFFFFFF);
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+5,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+5,0x4,0,SetTo,"X",FuncAlloc+7,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+5,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FuncAlloc+5,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FuncAlloc+3,0x15C+0x20*5,1,0);
					SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FuncAlloc+3,0x15C+0x20*2,1,0);
					SetCtrigX("X","X",0x4,0,SetTo,"X",WRet[3],0x0,0,0);
					SetCtrigX("X",WRet[3],0x4,0,SetTo,"X",FuncAlloc+2,0x0,0,0); -- goto Div Calc Start
					SetCtrigX("X",FuncAlloc+5,0x4,0,SetTo,"X",FuncAlloc+7,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+5,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FuncAlloc+5,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}
		

	FLDIVCall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

--------------------- f_Mod-------------------------------------------------------
	Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- FLDIV1
				},
				actions = {
					SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FuncAlloc+2,0x15C+0x20*3,1,0);
					SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FuncAlloc+2,0x15C+0x20*0,1,0);
					SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",WRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",WRet[3],0);
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FuncAlloc+2,0x15C+0x20*4,1,0);
					SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FuncAlloc+2,0x15C+0x20*1,1,0);
					CallLabelAlways("X",WRet[3],0);
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- /0
					CtrigX("X",WRet[3],0x15C,0,Exactly,0);
					CtrigX("X",WRet[3],0x19C,0,Exactly,0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+4,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+4,0x4,0,SetTo,"X",FuncAlloc+5,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+4,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FuncAlloc+4,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FuncAlloc+2,0x15C+0x20*5,1,0);
					SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FuncAlloc+2,0x15C+0x20*2,1,0);
					SetCtrigX("X","X",0x4,0,SetTo,"X",WRet[3],0x0,0,0);
					SetCtrigX("X",WRet[3],0x4,0,SetTo,"X",FuncAlloc+1,0x0,0,0); -- goto Div Calc Start
					SetCtrigX("X",FuncAlloc+4,0x4,0,SetTo,"X",FuncAlloc+5,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+4,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FuncAlloc+4,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}

	FLMODCall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

-------------------------------------------------------------------------------------------------------

		-- WRet[2] = X / WRet[3] = Y / Q = WRet[1], R = WRet[2]

		Trigger { -- Clear Value
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
					SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);
					SetCtrigX("X",FuncAlloc+1,0x15C+0x20*12,0,SetTo,"X",FuncAlloc+1,0,0,1); -- X -> B+1
					SetCtrigX("X",FuncAlloc+1,0x158+0x20*0,0,SetTo,"X",FuncAlloc+1,0x15C+0x20*0,1,0); -- X_epd -> X
					SetCtrigX("X",FuncAlloc+1,0x158+0x20*1,0,SetTo,"X",FuncAlloc+1,0x15C+0x20*1,1,0); -- X_epd -> X
					SetCtrigX("X",FuncAlloc+1,0x158+0x20*2,0,SetTo,"X",FuncAlloc+1,0x15C+0x20*2,1,0); -- X_epd -> X
					SetCtrigX("X",FuncAlloc+1,0x158+0x20*3,0,SetTo,"X",FuncAlloc+1,0x15C+0x20*3,1,0); -- X_epd -> X
					SetCtrigX("X",FuncAlloc+1,0x158+0x20*4,0,SetTo,"X",FuncAlloc+1,0x15C+0x20*4,1,0); -- X_epd -> X
					SetCtrigX("X",FuncAlloc+1,0x158+0x20*5,0,SetTo,"X",FuncAlloc+1,0x15C+0x20*5,1,0); -- X_epd -> X
				},
				flag = {Preserved}
			}

		FuncAlloc = FuncAlloc + 1

		local ClearNext3 = {}
		for i = 0, 63 do
			table.insert(ClearNext3,SetCtrigX("X",FuncAlloc+1,0x4,i+1,SetTo,"X",FuncAlloc+1,0x0,0,i-64)) -- W -> CRet
		end

		Trigger { -- Clear Next (-10)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					ClearNext3,
				},
				flag = {Preserved}
			}

		local ClearNext2 = {}
		for i = 0, 63 do
			table.insert(ClearNext2,SetCtrigX("X",FuncAlloc+1,0x4,256-3*i-2,SetTo,"X",FuncAlloc+1,0x0,0,256-3*i-1)) -- RecoverNext
		end

		Trigger { -- Clear Next (-9)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					ClearNext2,
				},
				flag = {Preserved}
			}

		local ClearNext = {}
		for i = 1, 64 do
			table.insert(ClearNext,SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",FuncAlloc,0,0,i+64)) -- B -> BF
		end

		Trigger { -- Clear Next (-8)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					ClearNext,
				},
				flag = {Preserved}
			}

		local ClearRet1 = {}
		for i = 0, 63 do
			table.insert(ClearRet1,SetCtrig1X("X",FuncAlloc+1,0x19C,64-i,SetTo,0))
		end

		Trigger { -- Clear Ret (-7)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					ClearRet1,
				},
				flag = {Preserved}
			}

		local ClearRet2 = {}
		for i = 0, 63 do
			table.insert(ClearRet2,SetCtrig1X("X",FuncAlloc+1,0x24,256-3*i-0,SetTo,0))
		end

		Trigger { -- Clear Ret (-6)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					ClearRet2,
				},
				flag = {Preserved}
			}

		local ClearRet3 = {}
		for i = 0, 63 do
			table.insert(ClearRet3,SetCtrig1X("X",FuncAlloc+1,0x24,256-3*i-2,SetTo,0))
		end

		Trigger { -- Clear Ret (-5)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					ClearRet3,
				},
				flag = {Preserved}
			}

		local ClearRet4 = {}
		for i = 0, 63 do
			table.insert(ClearRet4,SetCtrig1X("X",FuncAlloc+1,0x15C,64-i,SetTo,0))
		end

		Trigger { -- Clear Ret (-4)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					ClearRet4,
				},
				flag = {Preserved}
			}

		local ClearRet5 = {}
		for i = 0, 63 do
			table.insert(ClearRet5,SetCtrig1X("X",FuncAlloc+1,0x38,256-3*i-0,SetTo,0))
		end

		Trigger { -- Clear Ret (-3)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					ClearRet5,
				},
				flag = {Preserved}
			}

		local ClearRet6 = {}
		for i = 0, 63 do
			table.insert(ClearRet6,SetCtrig1X("X",FuncAlloc+1,0x24,256-3*i-1,SetTo,0))
		end

		Trigger { -- Clear Ret (-2)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					ClearRet6,
				},
				flag = {Preserved}
			}

		Trigger { -- A (-1) -> X
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",FuncAlloc,0x15C+0x20*3,0,AtLeast,0x80000000); -- VL >= 0x80000000 -> VH + 1
				},
				actions = {
					SetCtrig1X("X",FuncAlloc,0x164+0x20*6,0,SetTo,0x0,0x2); -- enable
					SetCtrig1X("X",FuncAlloc,0x164+0x20*7,0,SetTo,0x0,0x2); -- enable
					SetCtrig1X("X",FuncAlloc,0x164+0x20*8,0,SetTo,0x0,0x2); -- enable
				},
				flag = {Preserved}
			}

		Trigger { -- X (0)
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				actions = {
					SetMemoryX(0,Add,0,0xFFFFFFFF); -- VH
					SetMemoryX(0,Add,0,0xFFFFFFFF); -- VH
					SetMemoryX(0,Add,0,0xFFFFFFFF); -- VH
					SetMemoryX(0,Add,0,0xFFFFFFFF); -- VL
					SetMemoryX(0,Add,0,0xFFFFFFFF); -- VL
					SetMemoryX(0,Add,0,0xFFFFFFFF); -- VL
					Disabled(SetCtrig1X("X","X",0x15C+0x20*0,0,Add,1)); -- VH + 1
					Disabled(SetCtrig1X("X","X",0x15C+0x20*1,0,Add,1)); -- VH + 1
					Disabled(SetCtrig1X("X","X",0x15C+0x20*2,0,Add,1)); -- VH + 1
					SetCtrig1X("X","X",0x164+0x20*6,0,SetTo,0x2,0x2); -- disable
					SetCtrig1X("X","X",0x164+0x20*7,0,SetTo,0x2,0x2); -- disable
					SetCtrig1X("X","X",0x164+0x20*8,0,SetTo,0x2,0x2); -- disable
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,1); -- X -> B+1
					--------------------------------
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,-1); -- X -> A
					SetCtrig1X("X",FuncAlloc,0x15C+0x20*12,0,Add,0x970); -- X -> B+1 + i
					SetCtrigX("X",FuncAlloc,0x158+0x20*0,0,SetTo,"X",FuncAlloc,0x15C+0x20*0,1,0); -- X_epd -> X
					SetCtrigX("X",FuncAlloc,0x158+0x20*1,0,SetTo,"X",FuncAlloc,0x15C+0x20*1,1,0); -- X_epd -> X
					SetCtrigX("X",FuncAlloc,0x158+0x20*2,0,SetTo,"X",FuncAlloc,0x15C+0x20*2,1,0); -- X_epd -> X
					SetCtrigX("X",FuncAlloc,0x158+0x20*3,0,SetTo,"X",FuncAlloc,0x15C+0x20*3,1,0); -- X_epd -> X
					SetCtrigX("X",FuncAlloc,0x158+0x20*4,0,SetTo,"X",FuncAlloc,0x15C+0x20*4,1,0); -- X_epd -> X
					SetCtrigX("X",FuncAlloc,0x158+0x20*5,0,SetTo,"X",FuncAlloc,0x15C+0x20*5,1,0); -- X_epd -> X
					SetCtrig1X("X",FuncAlloc,0x160+0x20*13,0,SetTo,0x000000,0xFF0000); -- Close
				},
				flag = {Preserved}
			}

		for i = 0, 63 do
			Trigger { -- B (1~64)
					players = {IncludePlayer},
					conditions = {
						Label(0);
						CtrigX("X",FuncAlloc,0x15C+0x20*0,0,AtMost,0x7FFFFFFF); -- VH <= 0x7FFFFFFF
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,0); -- B -> X
						SetCtrigX("X",FuncAlloc,0x158+0x20*0,0,SetTo,"X",FuncAlloc+1,0x19C,1,64-i); -- X_epd -> Ret
						SetCtrigX("X",FuncAlloc,0x158+0x20*1,0,SetTo,"X",FuncAlloc+1,0x24,1,256-3*i-0); -- X_epd -> Ret
						SetCtrigX("X",FuncAlloc,0x158+0x20*2,0,SetTo,"X",FuncAlloc+1,0x24,1,256-3*i-2); -- X_epd -> Ret
						SetCtrigX("X",FuncAlloc,0x158+0x20*3,0,SetTo,"X",FuncAlloc+1,0x15C,1,64-i); -- X_epd -> Ret
						SetCtrigX("X",FuncAlloc,0x158+0x20*4,0,SetTo,"X",FuncAlloc+1,0x38,1,256-3*i-0); -- X_epd -> Ret
						SetCtrigX("X",FuncAlloc,0x158+0x20*5,0,SetTo,"X",FuncAlloc+1,0x24,1,256-3*i-1); -- X_epd -> Ret
						SetCtrig1X("X",FuncAlloc,0x160+0x20*13,0,SetTo,0x2D0000,0xFF0000); -- Open
					},
					flag = {Preserved}
				}
		end

		for i = 0, 63 do
			Trigger { -- BF (65~128)
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",FuncAlloc,0x15C+0x20*12,0,SetTo,"X",FuncAlloc+1,0,0,256-3*i-2); -- X -> Ret
						SetCtrigX("X",FuncAlloc,0x158+0x20*0,0,SetTo,"X",FuncAlloc+1,0x19C,1,64-i); -- X_epd -> Ret
						SetCtrigX("X",FuncAlloc,0x158+0x20*1,0,SetTo,"X",FuncAlloc+1,0x24,1,256-3*i-0); -- X_epd -> Ret
						SetCtrigX("X",FuncAlloc,0x158+0x20*2,0,SetTo,"X",FuncAlloc+1,0x24,1,256-3*i-2); -- X_epd -> Ret
						SetCtrigX("X",FuncAlloc,0x158+0x20*3,0,SetTo,"X",FuncAlloc+1,0x15C,1,64-i); -- X_epd -> Ret
						SetCtrigX("X",FuncAlloc,0x158+0x20*4,0,SetTo,"X",FuncAlloc+1,0x38,1,256-3*i-0); -- X_epd -> Ret
						SetCtrigX("X",FuncAlloc,0x158+0x20*5,0,SetTo,"X",FuncAlloc+1,0x24,1,256-3*i-1); -- X_epd -> Ret
					},
					flag = {Preserved}
				}
		end

		local PlayerID = IncludePlayer
		PlayerID = PlayerConvert(PlayerID)
		for k, P in pairs(PlayerID) do
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,-2,SetTo,"X",FuncAlloc,0x0,0,1)) -- Clear -> B1
			for i = 1, 64 do
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i+64,SetTo,"X",FuncAlloc,0x0,0,0)) -- BF -> X
			end
		end

		FuncAlloc = FuncAlloc + 1

		for i = 0, 63 do
			Trigger { -- CRet (-1~-64)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x17C,0,Add,1); -- CRet Add 1
					SetCtrig1X("X",WRet[2],0x15C,0,Add,0xFFFFFFFF); -- VL Add -D
					SetCtrig1X("X",WRet[2],0x19C,0,Subtract,1); -- A Sub 1
					SetCtrig1X("X","X",0x17C,0,SetTo,0xFFFFFFFF); -- CRet Clear
				},
				flag = {Preserved}
			}
		end

		Trigger { -- (0)
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				flag = {Preserved}
			}

		for i = 0, 31 do
			local CBit = 2^(31-i) -- 역행 2^63 -> 2^32
			Trigger { -- WRet (1~32)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FuncAlloc,0x17C,i-64,Subtract,0); -- XL - D
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit); -- Ret + 2^i
					SetCtrig1X("X",WRet[2],0x19C,0,Subtract,0); -- XH - C
					SetCtrigX("X",FuncAlloc,0x4,67+3*i,SetTo,"X",FuncAlloc,0x0,0,68+3*i); -- RecoverNext
					SetCtrigX("X","X",0x158,0,SetTo,"X",FuncAlloc,0x17C,1,i-64); -- b -> CRet
				},
				flag = {Preserved}
			}
		end

		for i = 0, 31 do
			local CBit = 2^(31-i) -- 역행 2^31 -> 2^0
			Trigger { -- WRet (33~64) 
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FuncAlloc,0x17C,i-32,Subtract,0); -- XL - D
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit); -- Ret + 2^i
					SetCtrig1X("X",WRet[2],0x19C,0,Subtract,0); -- XH - C
					SetCtrigX("X",FuncAlloc,0x4,67+3*(i+32),SetTo,"X",FuncAlloc,0x0,0,68+3*(i+32)); -- RecoverNext
					SetCtrigX("X","X",0x158,0,SetTo,"X",FuncAlloc,0x17C,1,i-32); -- b -> CRet
				},
				flag = {Preserved}
			}
		end

		for i = 0, 63 do
			Trigger { -- (-2) (65~256) α
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",WRet[2],0x19C,0,AtMost,0); -- A <= C 
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2); -- Next -> γ
				},
				flag = {Preserved}
			}
				Trigger { -- (-1) (65~256) β
					players = {IncludePlayer},
					conditions = {
						Label(0);
						CtrigX("X",WRet[2],0x15C,0,AtLeast,0); -- B >= D
					},
					actions = {
						SetCtrigX("X",FuncAlloc,0x4,i+1,SetTo,"X","X",0x0,0,2); -- W -> Next
						SetCtrigX("X",FuncAlloc,0x158,i+1,SetTo,"X",WRet[2],0x15C,1,0); -- b -> B ( -D)
					},
					flag = {Preserved}
				}
			Trigger { -- (-0) (65~256) γ
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",WRet[2],0x19C,0,Exactly,0); -- A == C
					CtrigX("X",WRet[2],0x15C,0,AtLeast,0); -- B >= D
				},
				actions = {
					SetCtrigX("X",FuncAlloc,0x4,i+1,SetTo,"X","X",0x0,0,1); -- W -> Next
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,i+1); -- Next -> W
					SetCtrigX("X",FuncAlloc,0x158,i+1,SetTo,"X",WRet[2],0x15C,1,0); -- b -> B ( -D)
				},
				flag = {Preserved}
			}
		end

		local PlayerID = IncludePlayer
		PlayerID = PlayerConvert(PlayerID)
		for k, P in pairs(PlayerID) do
			for i = 0, 63 do
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,256-3*i-1,SetTo,"X",FuncAlloc,0x0,0,64-i)) -- β -> W
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i-64,SetTo,"X",FuncAlloc,0x0,0,68+3*i)) -- CRet -> Next
			end
		end

	FuncAlloc = FuncAlloc + 1
		

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- 분기점
				},
				actions = {
					SetMemory(0,SetTo,0); -- RecoverNext
				},
				flag = {Preserved}
			}
	FuncAlloc = FuncAlloc + 1

	--------------------- f_LMod End-------------------------------------------------------
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- f_Mod End
				},
				flag = {Preserved}
			}
	FLMODCall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1
--------------------- f_LDiv End-------------------------------------------------------
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- f_Div End
				},
				flag = {Preserved}
			}
	FLDIVCall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

--------------------- f_LiMod End-------------------------------------------------------
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- LIMod End Start
				},
				flag = {Preserved}
			}

		CIfX(IncludePlayer,CtrigX("X",CRet[1],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",WRet[2],0x15C,0,Add,-1);
						SetCtrig1X("X",WRet[4],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[4],0x19C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[4],0x15C,1,0);
						SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[4],0x19C,1,0);
						SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",WRet[2],0);
					},
					flag = {Preserved}
				}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",WRet[4],0x15C,0,Exactly,0);
				},
				actions = {
					SetCtrig1X("X",WRet[4],0x19C,0,Add,1);
				},
				flag = {Preserved}
			}	
		CElseX()
			Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[4],0x15C,1,0);
						SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[4],0x19C,1,0);
						SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",WRet[2],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()
	
	FuncAlloc = FuncAlloc + 1

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- Exit Func
				},
				flag = {Preserved}
			}

	FLIMODCall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

--------------------- f_LiDiv End-------------------------------------------------------

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- LIDiv End Start
				},
				flag = {Preserved}
			}

		CIfX(IncludePlayer,CtrigX("X",CRet[1],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",WRet[1],0x15C,0,Add,-1);
						SetCtrig1X("X",WRet[4],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[4],0x19C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",WRet[1],0x158,0,SetTo,"X",WRet[4],0x15C,1,0);
						SetCtrigX("X",WRet[1],0x198,0,SetTo,"X",WRet[4],0x19C,1,0);
						SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[1],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",WRet[1],0);
					},
					flag = {Preserved}
				}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",WRet[4],0x15C,0,Exactly,0);
				},
				actions = {
					SetCtrig1X("X",WRet[4],0x19C,0,Add,1);
				},
				flag = {Preserved}
			}	
		CElseX()
			Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",WRet[1],0x158,0,SetTo,"X",WRet[4],0x15C,1,0);
						SetCtrigX("X",WRet[1],0x198,0,SetTo,"X",WRet[4],0x19C,1,0);
						SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[1],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",WRet[1],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()
	
	FuncAlloc = FuncAlloc + 1

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- Exit Func
				},
				flag = {Preserved}
			}

	FLIDIVCall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1
------------------------------------------------------------------------------------------

-- f_Xor - WRet[2] : X, WRet[3] : Y / WRet[2] = Output = X ^ Y
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[1],0x15C,1,0);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[1],0x19C,1,0);

				SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",WRet[4],0x148,1,0);
				SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",WRet[4],0x188,1,0);
				SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);

				SetCtrig1X("X",WRet[4],0x15C,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[4],0x19C,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[4],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX("X",WRet[4],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX("X",WRet[4],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);

				CallLabelAlways3("X",WRet[2],0,"X",WRet[3],0,"X",WRet[4],0);
			},
			flag = {Preserved}
		}
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[4],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[4],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",WRet[4],0x148,1,0);
				SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",WRet[4],0x188,1,0);
				SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x160,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);

				SetCtrig1X("X",WRet[4],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[4],0x19C,0,SetTo,0);
				SetCtrig1X("X",WRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[4],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX("X",WRet[4],0x158,0,SetTo,"X",WRet[1],0x15C,1,0);
				SetCtrigX("X",WRet[4],0x198,0,SetTo,"X",WRet[1],0x19C,1,0);

				SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrigX("X",WRet[1],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);

				CallLabelAlways3("X",WRet[3],0,"X",WRet[4],0,"X",WRet[1],0);
			},
			flag = {Preserved}
		}
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			flag = {Preserved}
		}

	FLXorCall1 = FuncAlloc
	FLXorCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_LNot - WRet[2] : X / WRet[1] = Output = ~X
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0xFFFFFFFF);

				SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[1],0x15C,1,0);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[1],0x19C,1,0);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			flag = {Preserved}
		}

	FLNotCall1 = FuncAlloc
	FLNotCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_LOr - WRet[2] : X, WRet[3] : Y / WRet[2] = Output = X | Y
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",WRet[1],0x148,1,0);
				SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",WRet[1],0x188,1,0);
				SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);

				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX("X",WRet[1],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
				CallLabelAlways2("X",WRet[3],0,"X",WRet[1],0);
			},
			flag = {Preserved}
		}
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			flag = {Preserved}
		}

	FLOrCall1 = FuncAlloc
	FLOrCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_LAnd - WRet[2] : X, WRet[3] : Y / WRet[2] = Output = X & Y
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",WRet[1],0x148,1,0);
				SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",WRet[1],0x188,1,0);
				SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x160,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);

				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX("X",WRet[1],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
				CallLabelAlways2("X",WRet[3],0,"X",WRet[1],0);
			},
			flag = {Preserved}
		}
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			flag = {Preserved}
		}

	FLAndCall1 = FuncAlloc
	FLAndCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_LMul / f_LiMul - FuncAlloc+2 : X, WRet[3] : Y / WRet[1] = Output 

	Trigger {
		players = {IncludePlayer},
		conditions = { 
			Label(FuncAlloc+4);
		},
		flag = {Preserved}
	}

	CIfX(IncludePlayer,CtrigX("X",WRet[2],0x19C,0,AtLeast,0x80000000))
		Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[3],0x15C,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x19C,0,SetTo,0xFFFFFFFF);
				SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CtrigX("X",WRet[3],0x15C,0,Exactly,0xFFFFFFFF);
			},
			actions = {
				SetCtrig1X("X",WRet[3],0x19C,0,Add,1);
			},
			flag = {Preserved}
		}	
		Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,1);
				SetCtrig1X("X",WRet[3],0x15C,0,Add,1);
			},
			flag = {Preserved}
		}
	CElseX()
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
						SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[3],0x15C,1,0);
						SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[3],0x19C,1,0);
						SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",WRet[2],0);
					},
					flag = {Preserved}
				}
	CIfXEnd()

	Trigger {
		players = {IncludePlayer},
		conditions = { -- Ret = 0
			Label(FuncAlloc);
		},
		actions = {
			SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);
			SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
			SetCtrigX("X",FuncAlloc+2,0x158+0x20*2,0,SetTo,"X",FuncAlloc+2,0x15C+0x20*2,1,0); 
			SetCtrigX("X",FuncAlloc+2,0x178+0x20*2,0,SetTo,"X",FuncAlloc+2,0x17C+0x20*2,1,0); 
			SetCtrigX("X",FuncAlloc+2,0x15C,0,SetTo,"X",FuncAlloc+2,0,0,2);
			SetCtrig1X("X",FuncAlloc+2,0x160+0x20*8,0,SetTo,0x0,0xFF0000);
		},
		flag = {Preserved}
	}

	for i = 31, 0, -1 do
		local CBit = 2^i
		Trigger { -- 1 ~ 32
			players = {IncludePlayer},
			conditions = { -- X Max Bit Check
				Label(0);
				CtrigX("X",WRet[3],0x19C,0,Exactly,CBit,CBit);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+2,0,0,1); -- Jump Calc
				SetCtrigX("X",FuncAlloc+1,0x158,0,SetTo,"X","X",0x4,1,0); -- RecoverNext
				SetCtrigX("X",FuncAlloc+1,0x15C,0,SetTo,"X","X",0,0,1); -- RecoverNext
				SetCtrigX("X",FuncAlloc+2,0x158+0x20*6,0,SetTo,"X",FuncAlloc+2,0x4-0x10*(i+32),1,0);
			},
			flag = {Preserved}
		}
	end
	for i = 31, 0, -1 do
		local CBit = 2^i
		Trigger { -- 33 ~ 64
			players = {IncludePlayer},
			conditions = { -- X Max Bit Check
				Label(0);
				CtrigX("X",WRet[3],0x15C,0,Exactly,CBit,CBit);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+2,0,0,1); -- Jump Calc
				SetCtrigX("X",FuncAlloc+1,0x158,0,SetTo,"X","X",0x4,1,0); -- RecoverNext
				SetCtrigX("X",FuncAlloc+1,0x15C,0,SetTo,"X","X",0,0,1); -- RecoverNext
				SetCtrigX("X",FuncAlloc+2,0x158+0x20*6,0,SetTo,"X",FuncAlloc+2,0x4-0x10*i,1,0);
			},
			flag = {Preserved}
		}
	end
	Trigger { -- 0
			players = {IncludePlayer},
			conditions = { -- X Max Bit Check
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+1,0,0,0); -- Jump Calc
				SetCtrigX("X",FuncAlloc+1,0x158,0,SetTo,"X","X",0x4,1,0); -- RecoverNext
				SetCtrigX("X",FuncAlloc+1,0x15C,0,SetTo,"X","X",0,0,1); -- RecoverNext
			},
			flag = {Preserved}
		}
		
	Trigger { -- -2
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CtrigX("X",FuncAlloc+2,0x15C+0x20*2,0,AtLeast,0x80000000);
			},
			actions = {
				SetCtrig1X("X",FuncAlloc+2,0x164+0x20*4,0,SetTo,0x0,0x2);
			},
			flag = {Preserved}
		}
	Trigger { -- -1 (LoopN)
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			flag = {Preserved}
		}
	Trigger { -- LoopX 
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+2);
			},
			actions = {
				SetCtrig1X("X","X",0x4,0,SetTo,0);
				SetCtrig1X("X","X",0x15C,0,Add,0x970);
				SetMemoryX(0,Add,0,0xFFFFFFFF); -- Inline Variable VL
				SetMemoryX(0,Add,0,0xFFFFFFFF); -- Inline Variable VH
				Disabled(SetCtrig1X("X","X",0x17C+0x20*2,0,Add,1));
				SetCtrig1X("X","X",0x164+0x20*4,0,SetTo,0x2,0x2);
				SetCtrig2X(0,SetTo,"X",FuncAlloc+1,0,0,0); -- Timer Action & Exit TRIG
				SetCtrig1X("X","X",0x158+0x20*6,0,Add,4); -- Run Tick
				-----------------------------------------------------------
				SetDeaths(0,SetTo,0,0); -- RecoverNext
				SetCtrigX("X",FuncAlloc+2,0x158+0x20*2,0,SetTo,"X",FuncAlloc+2,0x15C+0x20*2,1,0); -- X_epd -> X
				SetCtrigX("X",FuncAlloc+2,0x178+0x20*2,0,SetTo,"X",FuncAlloc+2,0x17C+0x20*2,1,0); 
				SetCtrig1X("X",FuncAlloc+2,0x164+0x20*0,0,SetTo,0,0x2); -- enable 
				SetCtrig1X("X",FuncAlloc+2,0x164+0x20*1,0,SetTo,0,0x2); -- enable
				SetCtrig1X("X",FuncAlloc+2,0x160+0x20*8,0,SetTo,0x000000,0xFF0000);
			},
			flag = {Preserved}
		}
	for i = 0, 31 do
		local CBit = 2^i
		Trigger { -- 1 ~ 32
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CtrigX("X",WRet[3],0x15C,0,Exactly,CBit,CBit);
			},
			actions = {
				SetCtrigX("X",FuncAlloc+2,0x158+0x20*2,0,SetTo,"X",WRet[1],0x15C,1,0); -- X_epd -> Ret
				SetCtrigX("X",FuncAlloc+2,0x178+0x20*2,0,SetTo,"X",WRet[1],0x19C,1,0);
				SetCtrig1X("X",FuncAlloc+2,0x164+0x20*0,0,SetTo,0x2,0x2); -- disable
				SetCtrig1X("X",FuncAlloc+2,0x164+0x20*1,0,SetTo,0x2,0x2); -- disable
				SetCtrig1X("X",FuncAlloc+2,0x160+0x20*8,0,SetTo,0x2D0000,0xFF0000);
				SetCtrig1X("X",FuncAlloc+2,0x158+0x20*6,0,Add,-0x10/4);

				SetCtrigX("X",WRet[1],0x158,0,SetTo,"X",FuncAlloc+3,0x24,1,0);
				SetCtrig1X("X",WRet[1],0x198,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x19C,0,Add,1); -- Carry 가불

				SetCtrigX("X","X",0x4,0,SetTo,"X",WRet[1],0x0,0,0);
				SetCtrigX("X",WRet[1],0x4,0,SetTo,"X",FuncAlloc+2,0x0,0,0);
				SetCtrigX("X",FuncAlloc+2,0x4,0,SetTo,"X",FuncAlloc+3,0x0,0,0);
				SetCtrigX("X",FuncAlloc+2,0x158+0x20*8,0,SetTo,"X","X",0x4,1,0);
				SetCtrigX("X",FuncAlloc+2,0x15C+0x20*8,0,SetTo,"X",FuncAlloc+2,0x0,0,-2);
			},
			flag = {Preserved}
		}
	end
	for i = 0, 31 do
		local CBit = 2^i
		Trigger { -- 33 ~ 64
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CtrigX("X",WRet[3],0x19C,0,Exactly,CBit,CBit);
			},
			actions = {
				SetCtrigX("X",FuncAlloc+2,0x158+0x20*2,0,SetTo,"X",WRet[1],0x15C,1,0); -- X_epd -> Ret
				SetCtrigX("X",FuncAlloc+2,0x178+0x20*2,0,SetTo,"X",WRet[1],0x19C,1,0);
				SetCtrig1X("X",FuncAlloc+2,0x164+0x20*0,0,SetTo,0x2,0x2); -- disable
				SetCtrig1X("X",FuncAlloc+2,0x164+0x20*1,0,SetTo,0x2,0x2); -- disable
				SetCtrig1X("X",FuncAlloc+2,0x160+0x20*8,0,SetTo,0x2D0000,0xFF0000);
				SetCtrig1X("X",FuncAlloc+2,0x158+0x20*6,0,Add,-0x10/4);

				SetCtrigX("X",WRet[1],0x158,0,SetTo,"X",FuncAlloc+3,0x24,1,0);
				SetCtrig1X("X",WRet[1],0x198,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x19C,0,Add,1); -- Carry 가불

				SetCtrigX("X","X",0x4,0,SetTo,"X",WRet[1],0x0,0,0);
				SetCtrigX("X",WRet[1],0x4,0,SetTo,"X",FuncAlloc+2,0x0,0,0);
				SetCtrigX("X",FuncAlloc+2,0x4,0,SetTo,"X",FuncAlloc+3,0x0,0,0);
				SetCtrigX("X",FuncAlloc+2,0x158+0x20*8,0,SetTo,"X","X",0x4,1,0);
				SetCtrigX("X",FuncAlloc+2,0x15C+0x20*8,0,SetTo,"X",FuncAlloc+2,0x0,0,-2);
			},
			flag = {Preserved}
		}
	end
	Trigger { -- 65
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+3);
				CtrigX("X",WRet[1],0x15C,0,AtLeast,0); -- X2 >= X2(전) : X1 -= 1 (No Carry)
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x19C,0,Add,-1);
			},
			flag = {Preserved}
		}

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
				SetDeaths(0,SetTo,0,0); -- RecoverNext
			},
			flag = {Preserved}
		}

	CIfX(IncludePlayer,CtrigX("X",CRet[1],0x15C,0,Exactly,1))
		Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x15C,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x19C,0,SetTo,0xFFFFFFFF);
				SetCtrigX("X",WRet[1],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CtrigX("X",WRet[2],0x15C,0,Exactly,0xFFFFFFFF);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x19C,0,Add,1);
			},
			flag = {Preserved}
		}	
		Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x15C,0,Add,1);
			},
			flag = {Preserved}
		}
	CElseX()
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",WRet[1],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
						SetCtrigX("X",WRet[1],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
						SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[1],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",WRet[1],0);
					},
					flag = {Preserved}
				}
	CIfXEnd()

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+5);
			},
			flag = {Preserved}
		}

	local PlayerID = IncludePlayer
	PlayerID = PlayerConvert(PlayerID)
	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc+3,0x4,0,SetTo,"X",FuncAlloc+2,0x0,0,-2))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc+2,0x4,-2,SetTo,"X",FuncAlloc+2,0x0,0,0))
		for i = 1, 64 do
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc+2,0x4,i,SetTo,"X",FuncAlloc+2,0x0,0,-2))
		end
	end

FLMulCall1 = FuncAlloc
FLMulCall2 = FuncAlloc+1
FLMulIndex = FuncAlloc+2
FLiMulCall1 = FuncAlloc+4
FLiMulCall2 = FuncAlloc+5
FuncAlloc = FuncAlloc + 6

-- f_LlShift - WRet[2] : X, CRet[1] : Loop / WRet[2] = Output (WRet[2]<<=CRet[1])

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
				CtrigX("X",CRet[1],0x15C,0,Exactly,0,0x3F);
			},
			actions = {
				SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc+1,0,0,0);
			},
			flag = {Preserved}
		}

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[2],0x1B8,0,SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X("X",WRet[2],0x1BC,0,SetTo,1);
				SetCtrig1X("X",WRet[2],0x1A8,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x1C0,0,SetTo,Add*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1C4,0,SetTo,0x2,0x2);

				SetCtrigX("X",FuncAlloc+2,0x4,1,SetTo,"X",WRet[2],0,0,0);
				SetCtrigX("X",WRet[2],0x4,0,SetTo,"X",FuncAlloc+2,0,0,0);
				SetCtrigX("X",FuncAlloc+2,0x4,0,SetTo,"X",FuncAlloc+2,0,0,1);

				SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,Add*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,Add*16777216,0xFF000000);

				SetCtrigX("X",FuncAlloc+2,0x158+0x20*1,0,SetTo,"X",FuncAlloc+2,0x1A4+0x20*1,1,0); -- Reset Timer
				SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+2,0x158+0x20*1,1,0);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",FuncAlloc+2,0x1A4+0x20*1,0,SetTo,0x2,0x2); -- Reset Flag

				SetCtrig1X("X",CRet[1],0x15C,0,Subtract,1);
				SetCtrigX("X","X",0x4,0,SetTo,"X",CRet[1],0,0,0);
				SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc+2,0,0,1);
			},
			flag = {Preserved}
		}



	Trigger {
		players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+2);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x1C4,0,SetTo,0x2,0x2);
				SetCtrig1X("X","X",0x1A4+0x20*1,0,SetTo,0x0,0x2); -- Timer Action
				SetCtrig1X("X","X",0x158+0x20*1,0,Subtract,1); -- Run Tick
				Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+1,0,0,0)); -- Exit Action
				},
				flag = {Preserved}
			}
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CtrigX("X",WRet[2],0x15C,0,AtLeast,0x80000000);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x1C4,0,SetTo,0x0,0x2);
			},
			flag = {Preserved}
		}



	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
				SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0,0,1);
				SetCtrig1X("X",WRet[2],0x1C0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1C4,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	
	FLlShiftCall1 = FuncAlloc
	FLlShiftCall2 = FuncAlloc+1
	FLlShiftIndex = FuncAlloc+2
	FuncAlloc = FuncAlloc + 3
-- f_LRand - WRet[1] = Output
	
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);
				SetSwitch(SeedSwitch,Random);
			},
			flag = {Preserved}
		}

	for i = 31, 0, -1 do
		Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(0);
				Switch(SeedSwitch,Set);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,Add,2^i);
			},
			flag = {Preserved}
		}
		Trigger { 
			players = {IncludePlayer},
			actions = {
				SetSwitch(SeedSwitch,Random);
			},
			flag = {Preserved}
		}
	end
	for i = 31, 0, -1 do
		Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(0);
				Switch(SeedSwitch,Set);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x19C,0,Add,2^i);
			},
			flag = {Preserved}
		}
		if i ~= 0 then
			Trigger { 
				players = {IncludePlayer},
				actions = {
					SetSwitch(SeedSwitch,Random);
				},
				flag = {Preserved}
			}
		end
	end
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			flag = {Preserved}
		}

	FLRandCall1 = FuncAlloc
	FLRandCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_LAbs - WRet[2] : X / WRet[1] = Output (WRet[1]=|WRet[2]|)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
				CtrigX("X",WRet[2],0x19C,0,AtMost,0x7FFFFFFF);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",WRet[2],0x0,0,0);
				SetCtrigX("X",WRet[2],0x4,0,SetTo,"X",FuncAlloc+1,0x0,0,0);
				SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[1],0x15C,1,0);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[1],0x19C,1,0);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x15C,0,Add,-1);
			},
			flag = {Preserved}
		}	

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0xFFFFFFFF);
				SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[1],0x15C,1,0);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[1],0x19C,1,0);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CtrigX("X",WRet[1],0x15C,0,Exactly,0xFFFFFFFF);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x19C,0,Add,1);
			},
			flag = {Preserved}
		}	
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,Add,1);
				SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
			},
			flag = {Preserved}
		}

	FLAbsCall1 = FuncAlloc
	FLAbsCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2


-- f_LiSub - WRet[2] : X, WRet[3] : Y & Switch / WRet[1] = Output (WRet[1]=WRet[2]-WRet[3])
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0xFFFFFFFF);
				SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",WRet[1],0x15C,1,0);
				SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",WRet[1],0x19C,1,0);
				SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x160,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
				CallLabelAlways("X",WRet[3],0);
			},
			flag = {Preserved}
		}

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CtrigX("X",WRet[1],0x15C,0,Exactly,0xFFFFFFFF);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x19C,0,Add,1);
			},
			flag = {Preserved}
		}	

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,Add,1);
				SetCtrigX("X",WRet[1],0x158,0,SetTo,"X","X",0x24,1,1);
				SetCtrig1X("X",WRet[1],0x198,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x19C,0,Add,1); -- Carry 가불
				SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[1],0x15C,1,0);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[1],0x19C,1,0);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,Add*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,Add*16777216,0xFF000000);
				CallLabelAlways2("X",WRet[1],0,"X",WRet[2],0);
			},
			flag = {Preserved}
		}
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
				CtrigX("X",WRet[1],0x15C,0,AtLeast,0); -- X2 >= X2(전) : X1 -= 1 (No Carry)
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x19C,0,Add,-1);
			},
			flag = {Preserved}
		}
	FLiSubCall1 = FuncAlloc
	FLiSubCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_LNeg - WRet[2] : X / WRet[1] = Output (WRet[1]=-WRet[2])
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0xFFFFFFFF);
				SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[1],0x15C,1,0);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[1],0x19C,1,0);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CtrigX("X",WRet[1],0x15C,0,Exactly,0xFFFFFFFF);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x19C,0,Add,1);
			},
			flag = {Preserved}
		}	

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,Add,1);
			},
			flag = {Preserved}
		}

	FLNegCall1 = FuncAlloc
	FLNegCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_LSub - WRet[2] : X, WRet[3] : Y, CRet[1] : Temp / WRet[2] = Output (WRet[2]-=WRet[3])

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FuncAlloc+3,0x24,1,0);
				SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FuncAlloc+4,0x24,1,0);
				SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[3],0);

				SetCtrigX("X",FuncAlloc+3,0x4,0,SetTo,"X",FuncAlloc+7,0,0,0); -- NifX Next 복구
				SetCtrigX("X",FuncAlloc+4,0x4,0,SetTo,"X",FuncAlloc+5,0,0,0); -- NifX Next 복구
				SetCtrigX("X",FuncAlloc+1,0x4,0,SetTo,"X",FuncAlloc+1,0,0,1); -- NifX Next 복구
			},
			flag = {Preserved}
		}
	Trigger { -- NIfX
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc+3);
			CtrigX("X",WRet[2],0x19C,0,AtLeast,0); -- A >= C
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1);
		},
		flag = {Preserved}
	}
		Trigger { -- NIfX
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+4);
				CtrigX("X",WRet[2],0x15C,0,AtLeast,0); -- B >= D
			},
			actions = {
				SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x160,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrigX("X","X",0x4,0,SetTo,"X",WRet[3],0x0,0,0);
				SetCtrigX("X",WRet[3],0x4,0,SetTo,"X",FuncAlloc+2,0x0,0,0);
			},
			flag = {Preserved}
		}

		Trigger { -- NElseX
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+5);
			},
			actions = {
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
				SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
				SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x160,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
				CallLabelAlways("X",WRet[3],0);
			},
			flag = {Preserved}
		}
			Trigger {
				players = {IncludePlayer},
				conditions = {Label(FuncAlloc+1);CtrigX("X",WRet[2],0x19C,0,Exactly,0)},
				actions = {
					SetCtrig1X("X",WRet[2],0x19C,0,SetTo,0);
					SetCtrig1X("X",WRet[2],0x15C,0,SetTo,0);
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+2,0x0,0,0);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {Label(FuncAlloc+6);},
				actions = {
					SetCtrig1X("X",WRet[2],0x19C,0,Subtract,1);
					SetCtrig1X("X",WRet[2],0x15C,0,Add,1);
					SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
					SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
					SetCtrigX("X","X",0x4,0,SetTo,"X",CRet[1],0x0,0,0);
					SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc+2,0x0,0,0);
				},
				flag = {Preserved}
			}
	Trigger { -- NElseX
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc+7);
		},
		actions = {
			SetCtrig1X("X",WRet[2],0x19C,0,SetTo,0);
			SetCtrig1X("X",WRet[2],0x15C,0,SetTo,0);
		},
		flag = {Preserved}
	}
	Trigger {
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc+2);
		},
		flag = {Preserved}
	}

	FLSubCall1 = FuncAlloc
	FLSubIndex = FuncAlloc+1
	FLSubCall2 = FuncAlloc+2
	FLSubNIFX1 = FuncAlloc+3
	FLSubNIFX2 = FuncAlloc+4
	FLSubNIFX3 = FuncAlloc+5
	FLSubNIFX4 = FuncAlloc+6
	FLSubNIFX5 = FuncAlloc+7
	FuncAlloc = FuncAlloc + 8

-- f_LAdd - WRet[2] : X, WRet[3] : Y, WRet[1] : Switch / WRet[2] = Output (WRet[2]+=WRet[3])
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrigX("X",WRet[2],0x158,0,SetTo,"X","X",0x24,1,1);
				SetCtrig1X("X",WRet[2],0x198,0,SetTo,0);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x19C,0,Add,1); -- Carry 가불
				SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x160,0,SetTo,Add*16777216,0xFF000000);
				SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,Add*16777216,0xFF000000);
				CallLabelAlways2("X",WRet[2],0,"X",WRet[3],0);
			},
			flag = {Preserved}
		}
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
				CtrigX("X",WRet[2],0x15C,0,AtLeast,0); -- X2 >= X2(전) : X1 -= 1 (No Carry)
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x19C,0,Add,-1);
			},
			flag = {Preserved}
		}

	FLAddCall1 = FuncAlloc
	FLAddCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_LRead - Ret[1] : Input[1] (Lower), Ret[2] : Input[2] (Upper) / WRet[1] = Output
	
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 0, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}

	for i = 0, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	FLReadCall1 = FuncAlloc
	FLReadCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2
-- f_LReadX - Ret[1] : Input[1] (Lower), Ret[2] : Input[2] (Upper) / WRet[1] = Output
-- +0
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 0, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}

	for i = 0, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2

-- +1 (x256)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 0, 23 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit*256);
				},
				flag = {Preserved}
			}
	end
	for i = 24, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit/16777216);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}

	for i = 0, 23 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit*256);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2

-- +2 (x65536)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 0, 15 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit*65536);
				},
				flag = {Preserved}
			}
	end
	for i = 16, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit/65536);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}

	for i = 0, 15 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit*65536);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2

-- +3 (x16777216)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 0, 7 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit*16777216);
				},
				flag = {Preserved}
			}
	end
	for i = 8, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit/256);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}

	for i = 0, 7 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit*16777216);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2
-- +4 (x4294967296)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 0, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2

-- +5 (x1099511627776)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 0, 23 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit*256);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2

-- +6 (x281474976710656)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 0, 15 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit*65536);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2
-- +7 (x72057594037927936)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 0, 7 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit*16777216);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2
-- -1 (/256)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 8, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit/256);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}
	for i = 0, 7 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit*16777216);
				},
				flag = {Preserved}
			}
	end

	for i = 8, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit/256);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2

	-- -2 (/65536)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 16, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit/65536);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}
	for i = 0, 15 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit*65536);
				},
				flag = {Preserved}
			}
	end

	for i = 16, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit/65536);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2
-- -3 (/16777216)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 24, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit/16777216);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}
	for i = 0, 23 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit*256);
				},
				flag = {Preserved}
			}
	end

	for i = 24, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit/16777216);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2

-- -4 (/4294967296)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}

	for i = 0, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2

-- -5 (/1099511627776)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}

	for i = 8, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit/256);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2
-- -6 (/281474976710656)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}

	for i = 16, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit/65536);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2
-- -7 (/72057594037927936)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}

	for i = 24, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit/16777216);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2
end
------------------------------------------------------------------------------------------------------

--[[ 이걸 열어본 사람에게 주는 선물.txt
Trigger { -- 값 대입 TRIG
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(0);
		},
		actions = {
			SetCtrigX(V[1],V[2],0x158,V[3],SetTo,"X","X",0x15C+0x20*0,1,1); 
			SetCtrigX(V[1],V[2],0x148,V[3],SetTo,Mask); 
			SetCtrigX(V[1],V[2],0x160,V[3],SetTo,SetTo*16777216,0xFF000000);
			CallLabelAlways(V[1],V[2],V[3]);
			},
			flag = {Preserved}
		}
Trigger { -- 값 증식 TRIG
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(0);
		},
		actions = {
			SetCtrig1X("X","X",0x15C+0x20*1,0,SetTo,0); -- 1st Action
			SetCtrig1X("X","X",0x15C+0x20*2,0,SetTo,0); -- 2nd Action
			SetCtrig1X("X","X",0x15C+0x20*3,0,SetTo,0); -- 3rd Action
			SetCtrig1X("X","X",0x15C+0x20*4,0,SetTo,0); -- 4th Action
			SetCtrig1X("X","X",0x15C+0x20*5,0,SetTo,0); -- 5th Action
			SetCtrig1X("X","X",0x15C+0x20*6,0,SetTo,0); -- 6th Action
			SetCtrig1X("X","X",0x15C+0x20*7,0,SetTo,0); -- 7th Action
			SetMemory(0,SetTo,0); -- 8th Action
			},
			flag = {Preserved}
		}

Trigger { --  Switch Actions for SLoopN 
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(0);
		},
		actions = {
			Action, -- Switch Action (Default = On)
			SetCtrig1X("X","X",0x164+0x20*Line,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
			
			Disabled(Action), -- Switch Action (Default = Off)
			SetCtrig1X("X","X",0x164+0x20*Line,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)

			Action, -- Switch Action (Default = On)
			Disabled(Action), -- Switch Action (Default = Off)
			SetCtrig1X("X","X",0x164+0x20*Line,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
			SetCtrig1X("X","X",0x184+0x20*Line,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)

			------------------------------------------------------------------------
			},
			flag = {Preserved}
		}


function _SLoop(PlayerID,Repeat,Conditions,Actions,EndActions) -- 초소형 반복문 2TRIG 버젼
	if Repeat >= 63 or Repeat <= 0 then
		_SLoop_InputError()
	end

	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc);
			Conditions, -- 루프 도중 조건 불만족시 무한 루프 발생 (루프 시작 조건으로만 사용)
		},
		actions = {
			SetCtrig1X("X","X",0x184+0x20*Repeat,0,SetTo,0x0,0x2); -- Timer Action
			SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,0); -- Make Loop Action A->A
			Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1)); -- Exit Action
			SetCtrig1X("X","X",0x158,0,Subtract,8); -- Run Tick
			Actions, -- Wait 금지
			},
			flag = {Preserved}
		}
	Trigger {
		players = {ParsePlayer(PlayerID)},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
			SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+1,0x0,0,1); -- Reset Next
			SetCtrigX("X",IndexAlloc,0x158,0,SetTo,"X",IndexAlloc,0x184+0x20*Repeat,1,0); -- Reset Timer
			SetCtrig1X("X",IndexAlloc,0x1A4,0,SetTo,0x2,0x2); -- Reset Flag
			EndActions,
			},
			flag = {Preserved}
		}

	PlayerID = PlayerConvert(PlayerID)
	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+1,0x0,0,1))
	end
	IndexAlloc = IndexAlloc + 0x2
end

function SLoop(PlayerID,Repeat,Conditions,Actions,InitActions,EndActions) -- 초소형 반복문 (변수 삽입가능)
	if type(Repeat) == "number" then
		if Repeat >= 64 or Repeat <= 0 then
			SLoop_InputError()
		end
		Trigger {
			players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(IndexAlloc);
					Conditions,
				},
				actions = {
					SetCtrigX("X",IndexAlloc+1,0x4,0,SetTo,"X",IndexAlloc+1,0,0,0); -- Make Loop Action A->A
					SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+1,0x0,0,0); -- Connect Next
					InitActions,
				},
				flag = {Preserved}
			}
		Trigger {
			players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(IndexAlloc+1);
				},
				actions = {
					SetCtrig1X("X","X",0x164+0x20*Repeat,0,SetTo,0x0,0x2); -- Timer Action
					Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1)); -- Exit Action
					SetCtrig1X("X","X",0x158,0,Subtract,8); -- Run Tick
					Actions, -- Wait 금지
					},
					flag = {Preserved}
				}
		Trigger {
			players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(IndexAlloc+2);
				},
				actions = {
					SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1); -- Reset Next
					SetCtrigX("X",IndexAlloc+1,0x158,0,SetTo,"X",IndexAlloc+1,0x164+0x20*Repeat,1,0); -- Reset Timer
					SetCtrig1X("X",IndexAlloc+1,0x184,0,SetTo,0x2,0x2); -- Reset Flag
					EndActions,
					},
					flag = {Preserved}
				}

		PlayerID = PlayerConvert(PlayerID)
		for k, P in pairs(PlayerID) do
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1))
		end
		IndexAlloc = IndexAlloc + 0x3
	else
		if Repeat[4] ~= "V" then
			SLoop_InputError()
		end
		local Deviation = Repeat[5]
		if Repeat[5] == "X" or Repeat[5] == nil then
			Deviation = 0
		end
		local min, max
		if Deviation >= 1 then
			min = 0
		else
			min = 1-Deviation
		end
		if Deviation >= 63 then
			max = 0
		else
			max = 63-Deviation
		end
		STPopTrigArr(PlayerID)

		Trigger {
			players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(IndexAlloc);
					NVar(Repeat,AtLeast,min*8,0xFFFFFFF8);
					NVar(Repeat,AtMost,max*8,0xFFFFFFF8);
					Conditions,
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,Repeat[1],Repeat[2],0,0,Repeat[3]);  -- Connect Next
					SetCtrigX(Repeat[1],Repeat[2],0x4,Repeat[3],SetTo,"X",IndexAlloc+1,0,0,0); -- Connect Next
					SetCtrigX("X",IndexAlloc+1,0x4,0,SetTo,"X",IndexAlloc+1,0,0,0); -- Make Loop Action A->A
					SetCtrigX(Repeat[1],Repeat[2],0x158,Repeat[3],SetTo,"X",IndexAlloc+1,0x158,1,0);
					SetCtrig1X(Repeat[1],Repeat[2],0x160,Repeat[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Repeat[1],Repeat[2],0x148,Repeat[3],SetTo,0xFFFFFFF8);
					SetCtrigX("X",IndexAlloc+1,0x158,0,SetTo,"X",IndexAlloc+1,0x164+0x20*Deviation,1,0); -- Reset Timer
					InitActions,
				},
				flag = {Preserved}
			}
		Trigger {
			players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(IndexAlloc+1);
				},
				actions = {
					SetDeathsX(0,SetTo,0x0,0,0x2); -- Timer Action
					Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1)); -- Exit Action
					SetCtrig1X("X","X",0x158,0,Subtract,8); -- Run Tick
					Actions, -- Wait 금지
					},
					flag = {Preserved}
				}
		Trigger {
			players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(IndexAlloc+2);
				},
				actions = {
					SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1); -- Reset Next
					SetCtrig1X("X",IndexAlloc+1,0x184,0,SetTo,0x2,0x2); -- Reset Flag
					EndActions,
					},
					flag = {Preserved}
				}

		PlayerID = PlayerConvert(PlayerID)
		for k, P in pairs(PlayerID) do
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1))
		end
		IndexAlloc = IndexAlloc + 0x3
	end
end

function SLoopX(PlayerID,Repeat,Conditions,Actions,InitActions,EndActions) -- 초소형 반복문 Another (Max 489)
	local StartLine = #Actions
	local RepeatMax = 1+(61-#Actions)*8
	if Repeat > RepeatMax or Repeat <= 0 then
		SLoopX_InputError()
	end

	Trigger {
		players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(IndexAlloc);
				Conditions,
			},
			actions = {
				SetCtrigX("X",IndexAlloc+1,0x4,0,SetTo,"X",IndexAlloc+1,0,0,0); -- Make Loop Action A->A
				SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+1,0x0,0,0); -- Connect Next
				InitActions,
			},
			flag = {Preserved}
		}
	Trigger {
		players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(IndexAlloc+1);
			},
			actions = {
				Actions, -- Wait 금지
				SetCtrig1X("X","X",0x1A0+0x20*StartLine+0x4*Repeat,0,SetTo,0x0,0x2); -- Timer Action
				SetCtrig1X("X","X",0x158+0x20*StartLine,0,Subtract,1); -- Run Tick
				Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1)); -- Exit Action
				},
				flag = {Preserved}
			}
	Trigger {
		players = {ParsePlayer(PlayerID)},
			conditions = {
				Label(IndexAlloc+2);
			},
			actions = {
				SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1); -- Reset Next
				SetCtrigX("X",IndexAlloc+1,0x158+0x20*StartLine,0,SetTo,"X",IndexAlloc+1,0x1A0+0x20*StartLine+0x4*Repeat,1,0); -- Reset Timer
				SetCtrig1X("X",IndexAlloc+1,0x1A4+0x20*StartLine,0,SetTo,0x2,0x2); -- Reset Flag
				EndActions,
				},
				flag = {Preserved}
			}

	PlayerID = PlayerConvert(PlayerID)
	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1))
	end
	IndexAlloc = IndexAlloc + 0x3
end

]]--

function SCopy(PlayerID,SVData,DestLine,SourceLine) -- 증식
	STPopTrigArr(PlayerID)

	local PDestS
	if SVData[4] == "SVA" then --{"X",Temp,0,"SVA",{"X",Index,0,"SA",Number,Size,Line},0,"X",Temp+1,0},
		PDestS = SVData
		SVData = {"X",SRet[SVData[5][5]][4],0,"SV",SVData[5][5]}
		MovS(PlayerID,SVData,PDestS)
	end

	local Box = {}
	local Box2 = {}
	if SVData[4] == "SV" then
		local CloseLine = {}
		for i = 1, SVData[5] do
			table.insert(CloseLine,i)
		end

		if type(SourceLine) == "number" then
			table.insert(Box,SetCtrigX(SVData[1],SVData[2],0x158+0x40*(SourceLine-1),SVData[3],SetTo,SVData[1],SVData[2],0x15C+0x40*(DestLine[1]-1),1,SVData[3]))
			table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x164+0x40*(SourceLine-1),SVData[3],SetTo,0x0,0x2))
			table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x160+0x40*(SourceLine-1),SVData[3],SetTo,SetTo*16777216,0xFF000000))
			table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x148+0x40*(SourceLine-1),SVData[3],SetTo,0xFFFFFFFF))
			CloseLine[SourceLine] = 0
			for i = 1, #DestLine do
				if i == #DestLine then
					table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x158+0x40*(DestLine[i]-1),SVData[3],SetTo,0))
				else
					table.insert(Box,SetCtrigX(SVData[1],SVData[2],0x158+0x40*(DestLine[i]-1),SVData[3],SetTo,SVData[1],SVData[2],0x15C+0x40*(DestLine[i+1]-1),1,SVData[3]))
				end
				table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x164+0x40*(DestLine[i]-1),SVData[3],SetTo,0x0,0x2))
				table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x160+0x40*(DestLine[i]-1),SVData[3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x148+0x40*(DestLine[i]-1),SVData[3],SetTo,0xFFFFFFFF))
				CloseLine[DestLine[i]] = 0
			end
		else
			for k, v in pairs(SourceLine) do
				table.insert(Box,SetCtrigX(SVData[1],SVData[2],0x158+0x40*(v-1),SVData[3],SetTo,SVData[1],SVData[2],0x15C+0x40*(DestLine[k][1]-1),1,SVData[3]))
				table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x164+0x40*(v-1),SVData[3],SetTo,0x0,0x2))
				table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x160+0x40*(v-1),SVData[3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x148+0x40*(v-1),SVData[3],SetTo,0xFFFFFFFF))
				CloseLine[v] = 0
				for i = 1, #DestLine[k] do
					if i == #DestLine[k] then
						table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x158+0x40*(DestLine[k][i]-1),SVData[3],SetTo,0))
					else
						table.insert(Box,SetCtrigX(SVData[1],SVData[2],0x158+0x40*(DestLine[k][i]-1),SVData[3],SetTo,SVData[1],SVData[2],0x15C+0x40*(DestLine[k][i+1]-1),1,SVData[3]))
					end
					table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x164+0x40*(DestLine[k][i]-1),SVData[3],SetTo,0x0,0x2))
					table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x160+0x40*(DestLine[k][i]-1),SVData[3],SetTo,SetTo*16777216,0xFF000000))
					table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x148+0x40*(DestLine[k][i]-1),SVData[3],SetTo,0xFFFFFFFF))
					CloseLine[DestLine[k][i]] = 0
				end
			end
		end

		for k, v in pairs(CloseLine) do
			if v ~= 0 then
				table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x164+0x40*(v-1),SVData[3],SetTo,0x2,0x2))
				table.insert(Box2,SetCtrig1X(SVData[1],SVData[2],0x164+0x40*(v-1),SVData[3],SetTo,0x0,0x2))
			end
		end

		if #Box == 62 then
			table.insert(Box,PreserveTrigger())
		end
		DoActions2X({ParsePlayer(PlayerID)},{Box,CallLabelAlways(SVData[1],SVData[2],SVData[3])})
		DoActions2X({ParsePlayer(PlayerID)},{Box2})
	end

	if PDestS ~= nil then
		MovS(PlayerID,PDestS,SVData)
	end
end


function SCast(PlayerID,Dest,Source,Deviation,Mask,Clear) -- V ↔ SV Type Casting
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end
	if Deviation == "X" then
		Deviation = nil
	end
	if Deviation == nil then
		Deviation = 0
	end
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local Mask2 = Mask
	if Clear == 1 then
		Mask2 = 0xFFFFFFFF
	end

	
 	--[[
 	SA → V
 	SA → VA
 	SVA → V
 	SvA → VA
 	V → SV
 	VA → SV
 	V → SVA
 	VA → SVA
 	]]-- {Player,SVariable[2],Next,"SV",SVariable[3],Line}
	if Source[4] == "SV" then -- SV -> V
		local Line = Source[6]
		local Number = Source[5] 
		local Distance = 0x40*(Line-1)
		local Box = {}
		local Box2 = {}
		for i = 1, Number do
			if i ~= Line then
				table.insert(Box,SetCtrig1X(Source[1],Source[2],0x164+0x40*(i-1),Source[3],SetTo,0x2,0x2))
				table.insert(Box2,SetCtrig1X(Source[1],Source[2],0x164+0x40*(i-1),Source[3],SetTo,0x0,0x2))
			else
				table.insert(Box,SetCtrig1X(Source[1],Source[2],0x164+0x40*(i-1),Source[3],SetTo,0x0,0x2))
			end
		end
		if Dest[4] == "V" then 
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						Box,
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2);
						SetCtrig1X(Source[1],Source[2],0x148+Distance,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160+Distance,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158+Distance,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						Box2,
					},
					flag = {Preserved}
				}
		elseif Dest[4] == "VA" then -- SV -> VA
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						Box,
						SetCtrigX(Source[1],Source[2],0x158+Distance,Source[3],SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
						SetCtrig1X(Source[1],Source[2],0x158+Distance,Source[3],Add,Dest[6]);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158+Distance,1,Source[3]);
						SetCtrig1X(Source[1],Source[2],0x148+Distance,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160+Distance,Source[3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x15C+Distance,Source[3],Add,Deviation);
						CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						Box2,
						SetCtrig1X(Source[1],Source[2],0x15C+Distance,Source[3],Add,-Deviation); 
					},
					flag = {Preserved}
				}
		else
			SCast_InputData_Error()
		end
	elseif Source[4] == "SVA" then -- SVA -> V
		local Line = Source[5][7]
		local Number = Source[5][5] 
		local Distance = 0x40*(Line-1)
		local Box = {}
		local Box2 = {}
		for i = 1, Number do
			if i ~= Line then
				table.insert(Box,SetDeathsX(CurrentPlayer,SetTo,0x2,0,0x2))
				table.insert(Box,SetMemory(0x6509B0,Add,(0x40)/4))

				table.insert(Box2,SetDeathsX(CurrentPlayer,SetTo,0x0,0,0x2))
				table.insert(Box2,SetMemory(0x6509B0,Add,(0x40)/4))
			else
				table.insert(Box,SetDeathsX(CurrentPlayer,SetTo,0x0,0,0x2))
				table.insert(Box,SetMemory(0x6509B0,Add,(0x40)/4))

				table.insert(Box2,SetMemory(0x6509B0,Add,(0x40)/4))
			end
		end
		if Dest[4] == "V" then -- {"X",Temp,0,"SVA",{"X",Index,0,"SA",Number,Size,Line},0,"X",Temp+1,0},
				Trigger {--(CPRead)로 값 출력
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2);
							SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
							SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
							SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
							SetMemory(0x6509B0,Add,Source[6]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
							SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
							CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
						},
						flag = {Preserved}
					}

				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
							SetMemory(0x6509B0,Add,(0x4-0x0)/4);
							SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
							SetMemory(0x6509B0,Add,(0x158-0x4+Distance)/4);		
							SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);					
							SetMemory(0x6509B0,Add,(0x148-0x158)/4);
							SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x160-0x148)/4);
							SetDeathsX(CurrentPlayer,SetTo,Add*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
							SetMemory(0x6509B0,Add,(0x164-0x160-Distance)/4);
							Box,
						},
						flag = {Preserved}
					}
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,Add,(-0x40*Number)/4);
							Box2,
						},
						flag = {Preserved}
					}
				RecoverCp(PlayerID)
		elseif Dest[4] == "VA" then -- SVA -> VA
				Trigger {--(CPRead)로 값 출력
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
							SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
							SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
							SetMemory(0x6509B0,Add,Source[6]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
							SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
							
							SetCtrigX("X","X",0x1DC,1,SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
							SetCtrig1X("X","X",0x1DC,1,Add,Dest[6]);
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x1DC,1,1);
							CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1],Dest[2],Dest[3]);
						},
						flag = {Preserved}
					}

				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
							SetMemory(0x6509B0,Add,(0x4-0x0)/4);
							SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
							SetMemory(0x6509B0,Add,(0x158-0x4+Distance)/4);		
							SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);					
							SetMemory(0x6509B0,Add,(0x148-0x158)/4);
							SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x15C-0x148)/4);
							SetDeaths(CurrentPlayer,Add,Deviation,0);
							SetMemory(0x6509B0,Add,(0x160-0x15C)/4);
							SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
							SetMemory(0x6509B0,Add,(0x164-0x160-Distance)/4);
							Box,
						},
						flag = {Preserved}
					}
				Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,Add,(-0x40*Number)/4);
							Box2,
							SetMemory(0x6509B0,Add,(0x15C-0x164-0x40*Number)/4);
							SetDeaths(CurrentPlayer,Add,-Deviation,0);

						},
						flag = {Preserved}
					}
				RecoverCp(PlayerID)
		else
			SCast_InputData_Error()
		end
	elseif Source[4] == "V" then -- V -> SV
		if Dest[4] == "SV" then 
			local Number = Dest[5] 
			local DestLine = {}
			for i = 2, Number do
				table.insert(DestLine,i)
			end
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			if Number >= 2 then
				SCopy(PlayerID,Dest,DestLine,1)
			end
		elseif Dest[4] == "SVA" then -- V -> SVA 
			local Number = Dest[5][5]
			local DestLine = {}
			for i = 2, Number do
				table.insert(DestLine,i)
			end
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],Add,Dest[6]);
						SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,Deviation);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,-Deviation);
					},
					flag = {Preserved}
				}
			if Number >= 2 then
				SCopy(PlayerID,Dest,DestLine,1)
			end
		else
			SCast_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if Dest[4] == "SV" then -- VA -> SV
			local Number = Dest[5] 
			local DestLine = {}
			for i = 2, Number do
				table.insert(DestLine,i)
			end
			Trigger {--(CPRead)로 값 출력
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
						CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
					},
					flag = {Preserved}
				}

			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148)/4);
						SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
					},
					flag = {Preserved}
				}
			RecoverCp(PlayerID)
			if Number >= 2 then
				SCopy(PlayerID,Dest,DestLine,1)
			end
		elseif Dest[4] == "SVA" then -- VA -> SVA 
			local Number = Dest[5][5]
			local DestLine = {}
			for i = 2, Number do
				table.insert(DestLine,i)
			end
			Trigger {--(CPRead)로 값 출력
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 

						SetCtrigX("X","X",0x19C,1,SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
						SetCtrig1X("X","X",0x19C,1,Add,Dest[6]);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x19C,1,1);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148)/4);
						SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x15C-0x160)/4);
						SetDeaths(CurrentPlayer,Add,Deviation,0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeaths(CurrentPlayer,Add,-Deviation,0);
					},
					flag = {Preserved}
				}

			RecoverCp(PlayerID)
			if Number >= 2 then
				SCopy(PlayerID,Dest,DestLine,1)
			end
		else
			SCast_InputData_Error()
		end
	else
		SCast_InputData_Error()
	end
end

function SMov(PlayerID,Dest,Source,Mode,Deviation,Mask,Clear) -- <<
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end
	if Deviation == "X" then
		Deviation = nil
	end
	if Mode == "X" then
		Mode = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	if Deviation == nil then
		Deviation = 0
	end
	if Mode == nil then
		Mode = SetTo
	end
	local Mask2 = Mask
	if Clear == 1 then
		Mask2 = 0xFFFFFFFF
	end
	local PDest = {}
	local TempAlloc = 1
	local TempVAlloc = 1
	local TMask, TDeviation, TMask2

	if type(Source) == "table" and Source[4] == "SVA" then
		local TempRet = {"X",SRet[Source[5][5]][3],0,"SV",Source[5][5],Source[5][7]}
		MovS(PlayerID,TempRet,Source)
		Source = TempRet
	end
	local PDestS, PMode, SDest
	if Dest[4] == "SVA" then
		PDestS = Dest
		Dest = {"X",SRet[Dest[5][5]][4],0,"SV",Dest[5][5],Dest[5][7]}
		SDest = Dest
		PMode = Mode
		Mode = SetTo
	end

	if Dest[4] == "SV" then
		if Dest[5] == 1 or type(Dest[6]) == "number" then 
			Dest = {_SMem(Dest,nil)}
		else
			Dest = _SMem(Dest,nil)
		end
	end

	if type(Source) == "table" and Source[4] == "SV" then
		local Box = {}
		local Box2 = {}
		local CloseLine = {}
		for i = 1, Source[5] do
			table.insert(CloseLine,i)
		end

		local Line = {}
		if Source[6] == nil then
			for i = 1, Source[5] do
				table.insert(Line,i)
			end
		else
			Line = Source[6]
		end

		for k, v in pairs(Line) do 
			if type(Mode) == "number" then
				TMode = Mode
			elseif Mode[k] == nil then
				TMode = SetTo
			else
				TMode = Mode[k]
			end
			TMode2 = TMode
			if TMode2 == SetTo then
				TMode2 = Add
			end
			if type(Mask) == "number" then
				TMask = Mask
			elseif Mask[k] == nil then
				TMask = 0xFFFFFFFF
			else
				TMask = Mask[k]
			end
			if type(Mask2) == "number" then
				TMask2 = Mask2
			elseif Mask2[k] == nil then
				TMask2 = 0xFFFFFFFF
			else
				TMask2 = Mask2[k]
			end
			if type(Deviation) == "number" then
				TDeviation = Deviation
			elseif Deviation[k] == nil then
				TDeviation = 0
			else
				TDeviation = Deviation[k]
			end
			if type(Dest[k]) == "number" then
				table.insert(Box,SetMemoryX(Dest[k],TMode,TDeviation,TMask))
				table.insert(Box,SetCtrig1X(Source[1],Source[2],0x158+0x40*(v-1),Source[3],SetTo,EPD(Dest[k])))
			elseif Dest[k][4] == "V" then
				table.insert(Box,SetCtrig1X(Dest[k][1],Dest[k][2],0x15C,Dest[k][3],TMode,TDeviation,TMask))
				table.insert(Box,SetCtrigX(Source[1],Source[2],0x158+0x40*(v-1),Source[3],SetTo,Dest[k][1],Dest[k][2],0x15C,1,Dest[k][3]))
			elseif Dest[k][4] == "A" then
				table.insert(PDest,{Dest[k],TMode})
				Dest[k] = {"X",NRet[TempAlloc],0,"V"}
				TempAlloc = TempAlloc + 1
				table.insert(Box,SetCtrig1X(Dest[k][1],Dest[k][2],0x15C,Dest[k][3],SetTo,TDeviation,0xFFFFFFFF))
				table.insert(Box,SetCtrigX(Source[1],Source[2],0x158+0x40*(v-1),Source[3],SetTo,Dest[k][1],Dest[k][2],0x15C,1,Dest[k][3]))
			elseif Dest[k][4] == "VA" then 
				table.insert(PDest,{Dest[k],TMode})
				Dest[k] = {"X",NRet[TempAlloc],0,"V"}
				TempAlloc = TempAlloc + 1
				table.insert(Box,SetCtrig1X(Dest[k][1],Dest[k][2],0x15C,Dest[k][3],SetTo,TDeviation,0xFFFFFFFF))
				table.insert(Box,SetCtrigX(Source[1],Source[2],0x158+0x40*(v-1),Source[3],SetTo,Dest[k][1],Dest[k][2],0x15C,1,Dest[k][3]))
			else
				table.insert(Box,SetCtrig1X(Dest[k][1],Dest[k][2],Dest[k][3],Dest[k][4],TMode,TDeviation,TMask2))
				table.insert(Box,SetCtrigX(Source[1],Source[2],0x158+0x40*(v-1),Source[3],SetTo,Dest[k][1],Dest[k][2],Dest[k][3],1,Dest[k][4]))
			end
			
			table.insert(Box,SetCtrig1X(Source[1],Source[2],0x164+0x40*(v-1),Source[3],SetTo,0x0,0x2))
			table.insert(Box,SetCtrig1X(Source[1],Source[2],0x160+0x40*(v-1),Source[3],SetTo,TMode2*16777216,0xFF000000))
			table.insert(Box,SetCtrig1X(Source[1],Source[2],0x148+0x40*(v-1),Source[3],SetTo,TMask))
			CloseLine[v] = 0
		end
		for k, v in pairs(CloseLine) do
			if v ~= 0 then
				table.insert(Box,SetCtrig1X(Source[1],Source[2],0x164+0x40*(v-1),Source[3],SetTo,0x2,0x2))
				table.insert(Box2,SetCtrig1X(Source[1],Source[2],0x164+0x40*(v-1),Source[3],SetTo,0x0,0x2))
			end
		end
		if #Box <= 60 then
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						Box,
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
		else
			local Box10 = {}
			local Box11 = {}
			for i = 1, 64 do
				table.insert(Box10,Box1[i])
			end
			for i = 65, #Box1 do
				table.insert(Box11,Box1[i])
			end
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						Box10,
					},
					flag = {Preserved}
				}
			Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						Box11,
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
		end
		Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						Box2,
					},
					flag = {Preserved}
				}
	else -- Source ~= SV
		local SourceN = {}
		local SourceV = {}
		local SourceVA = {}
		local DestN = {}
		local DestV = {}
		local DestVA = {}
		for k, v in pairs(Source) do 
			if type(v) == "number" then
				table.insert(SourceN,v)
				table.insert(DestN,k)
			elseif v[4] == "V" then
				table.insert(SourceV,v)
				table.insert(DestV,k)
			elseif v[4] == "VA" then
				table.insert(SourceVA,v)
				table.insert(DestVA,k)
			else
				SMov_InputData_Error()
			end
		end

		local Box = {}
		local Box2 = {}
		local Box3 = {}

		for k, v in pairs(SourceN) do 
			local CurDest = Dest[DestN[k]]
			if type(Mode) == "number" then
				TMode = Mode
			elseif Mode[DestN[k]] == nil then
				TMode = SetTo
			else
				TMode = Mode[DestN[k]]
			end
			if type(Mask) == "number" then
				TMask = Mask
			elseif Mask[DestN[k]] == nil then
				TMask = 0xFFFFFFFF
			else
				TMask = Mask[DestN[k]]
			end
			if type(Mask2) == "number" then
				TMask2 = Mask2
			elseif Mask2[DestN[k]] == nil then
				TMask2 = 0xFFFFFFFF
			else
				TMask2 = Mask2[DestN[k]]
			end

			if type(CurDest) == "number" then
				table.insert(Box,SetMemoryX(CurDest,TMode,v,TMask))
			elseif CurDest[4] == "V" then
				table.insert(Box,SetCtrig1X(CurDest[1],CurDest[2],0x15C,CurDest[3],TMode,v,TMask))
			elseif CurDest[4] == "A" then
				table.insert(PDestN,{CurDest,TMode})
				CurDest = {"X",NRet[TempAlloc],0,"V"}
				TempAlloc = TempAlloc + 1
				table.insert(Box,SetCtrig1X(CurDest[1],CurDest[2],0x15C,CurDest[3],SetTo,0,0xFFFFFFFF))
				table.insert(Box,SetCtrig1X(CurDest[1],CurDest[2],0x15C,CurDest[3],TMode,v,TMask))
			elseif CurDest[4] == "VA" then 
				table.insert(PDestN,{CurDest,TMode})
				CurDest = {"X",NRet[TempAlloc],0,"V"}
				TempAlloc = TempAlloc + 1
				table.insert(Box,SetCtrig1X(CurDest[1],CurDest[2],0x15C,CurDest[3],SetTo,0,0xFFFFFFFF))
				table.insert(Box,SetCtrig1X(CurDest[1],CurDest[2],0x15C,CurDest[3],TMode,v,TMask))
			else
				table.insert(Box,SetCtrig1X(CurDest[1],CurDest[2],CurDest[3],CurDest[4],TMode,v,TMask2))
			end
		end
		if SourceN ~= nil then
		Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						Box,
					},
					flag = {Preserved}
				}
		end
		for k, v in pairs(SourceV) do 
			local CurDest = Dest[DestV[k]]
			if type(Mode) == "number" then
				TMode = Mode
			elseif Mode[DestV[k]] == nil then
				TMode = SetTo
			else
				TMode = Mode[DestV[k]]
			end
			TMode2 = TMode
			if TMode2 == SetTo then
				TMode2 = Add
			end
			if type(Mask) == "number" then
				TMask = Mask
			elseif Mask[DestV[k]] == nil then
				TMask = 0xFFFFFFFF
			else
				TMask = Mask[DestV[k]]
			end
			if type(Mask2) == "number" then
				TMask2 = Mask2
			elseif Mask2[DestV[k]] == nil then
				TMask2 = 0xFFFFFFFF
			else
				TMask2 = Mask2[DestV[k]]
			end
			if type(Deviation) == "number" then
				TDeviation = Deviation
			elseif Deviation[DestV[k]] == nil then
				TDeviation = 0
			else
				TDeviation = Deviation[DestV[k]]
			end

			if type(CurDest) == "number" then
				table.insert(Box2,SetMemoryX(CurDest,TMode,TDeviation,TMask))
				table.insert(Box2,SetCtrig1X(v[1],v[2],0x158,v[3],SetTo,EPD(CurDest)))
			elseif CurDest[4] == "V" then
				table.insert(Box2,SetCtrig1X(CurDest[1],CurDest[2],0x15C,CurDest[3],TMode,TDeviation,TMask))
				table.insert(Box2,SetCtrigX(v[1],v[2],0x158,v[3],SetTo,CurDest[1],CurDest[2],0x15C,1,CurDest[3]))
			elseif CurDest[4] == "A" then
				table.insert(PDest,{CurDest,TMode})
				CurDest = {"X",NRet[TempAlloc],0,"V"}
				TempAlloc = TempAlloc + 1
				table.insert(Box2,SetCtrig1X(CurDest[1],CurDest[2],0x15C,CurDest[3],SetTo,TDeviation,0xFFFFFFFF))
				table.insert(Box2,SetCtrigX(v[1],v[2],0x158,v[3],SetTo,CurDest[1],CurDest[2],0x15C,1,CurDest[3]))
			elseif CurDest[4] == "VA" then 
				table.insert(PDest,{CurDest,TMode})
				CurDest = {"X",NRet[TempAlloc],0,"V"}
				TempAlloc = TempAlloc + 1
				table.insert(Box2,SetCtrig1X(CurDest[1],CurDest[2],0x15C,CurDest[3],SetTo,TDeviation,0xFFFFFFFF))
				table.insert(Box2,SetCtrigX(v[1],v[2],0x158,v[3],SetTo,CurDest[1],CurDest[2],0x15C,1,CurDest[3]))
			else
				table.insert(Box2,SetCtrig1X(CurDest[1],CurDest[2],CurDest[3],CurDest[4],TMode,TDeviation,TMask2))
				table.insert(Box2,SetCtrigX(v[1],v[2],0x158,v[3],SetTo,CurDest[1],CurDest[2],CurDest[3],1,CurDest[4]))
			end
			table.insert(Box2,SetCtrig1X(v[1],v[2],0x160,v[3],SetTo,TMode2*16777216,0xFF000000))
			table.insert(Box2,SetCtrig1X(v[1],v[2],0x148,v[3],SetTo,TMask))
		end
		if SourceV ~= nil then
		Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						Box2,
						CallLabelAlwaysN(table.unpack(SourceV));
					},
					flag = {Preserved}
				}
		end
		local JumpVA = {}
		for k, v in pairs(SourceVA) do 
			local CurDest = Dest[DestVA[k]]
			if type(Mode) == "number" then
				TMode = Mode
			elseif Mode[DestVA[k]] == nil then
				TMode = SetTo
			else
				TMode = Mode[DestVA[k]]
			end
			TMode2 = TMode
			if TMode2 == SetTo then
				TMode2 = Add
			end
			if type(Mask) == "number" then
				TMask = Mask
			elseif Mask[DestVA[k]] == nil then
				TMask = 0xFFFFFFFF
			else
				TMask = Mask[DestVA[k]]
			end
			if type(Mask2) == "number" then
				TMask2 = Mask2
			elseif Mask2[DestVA[k]] == nil then
				TMask2 = 0xFFFFFFFF
			else
				TMask2 = Mask2[DestVA[k]]
			end
			if type(Deviation) == "number" then
				TDeviation = Deviation
			elseif Deviation[DestVA[k]] == nil then
				TDeviation = 0
			else
				TDeviation = Deviation[DestVA[k]]
			end
			local TempRet = {"X",CRet[TempVAlloc],0,"V"}
			table.insert(JumpVA,TempRet)
			MovX(PlayerID,TempRet,v)
			SourceVA[k] = TempRet
			TempVAlloc = TempVAlloc + 1
			if type(CurDest) == "number" then
				table.insert(Box3,SetMemoryX(CurDest,TMode,TDeviation,TMask))
				table.insert(Box3,SetCtrig1X(SourceVA[k][1],SourceVA[k][2],0x158,SourceVA[k][3],SetTo,EPD(CurDest)))
			elseif CurDest[4] == "V" then
				table.insert(Box3,SetCtrig1X(CurDest[1],CurDest[2],0x15C,CurDest[3],TMode,TDeviation,TMask))
				table.insert(Box3,SetCtrigX(SourceVA[k][1],SourceVA[k][2],0x158,SourceVA[k][3],SetTo,CurDest[1],CurDest[2],0x15C,1,CurDest[3]))
			elseif CurDest[4] == "A" then
				table.insert(PDest,{CurDest,TMode})
				CurDest = {"X",NRet[TempAlloc],0,"V"}
				TempAlloc = TempAlloc + 1
				table.insert(Box3,SetCtrig1X(CurDest[1],CurDest[2],0x15C,CurDest[3],SetTo,TDeviation,0xFFFFFFFF))
				table.insert(Box3,SetCtrigX(SourceVA[k][1],SourceVA[k][2],0x158,SourceVA[k][3],SetTo,CurDest[1],CurDest[2],0x15C,1,CurDest[3]))
			elseif CurDest[4] == "VA" then 
				table.insert(PDest,{CurDest,TMode})
				CurDest = {"X",NRet[TempAlloc],0,"V"}
				TempAlloc = TempAlloc + 1
				table.insert(Box3,SetCtrig1X(CurDest[1],CurDest[2],0x15C,CurDest[3],SetTo,TDeviation,0xFFFFFFFF))
				table.insert(Box3,SetCtrigX(SourceVA[k][1],SourceVA[k][2],0x158,SourceVA[k][3],SetTo,CurDest[1],CurDest[2],0x15C,1,CurDest[3]))
			else
				table.insert(Box3,SetCtrig1X(CurDest[1],CurDest[2],CurDest[3],CurDest[4],TMode,TDeviation,TMask2))
				table.insert(Box3,SetCtrigX(SourceVA[k][1],SourceVA[k][2],0x158,SourceVA[k][3],SetTo,CurDest[1],CurDest[2],CurDest[3],1,CurDest[4]))
			end
			table.insert(Box3,SetCtrig1X(SourceVA[k][1],SourceVA[k][2],0x160,SourceVA[k][3],SetTo,TMode2*16777216,0xFF000000))
			table.insert(Box3,SetCtrig1X(SourceVA[k][1],SourceVA[k][2],0x148,SourceVA[k][3],SetTo,TMask))
		end
		if SourceVA ~= nil then
		Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						Box3,
						CallLabelAlwaysN(table.unpack(JumpVA));
					},
					flag = {Preserved}
				}
		end
	end
	if PDest ~= nil then
		for k, v in pairs(PDest) do
			MovX(PlayerID,v[1],{"X",NRet[k],0,"V"},v[2])
		end
	end

	if PDestS ~= nil then
		MovS(PlayerID,PDestS,SDest,PMode)
	end
end

function MovS(PlayerID,Dest,Source,Mode,Mask,Clear) -- SV << SVA / SVA << SV (Value) / 내부함수 (사용 권장X)
	STPopTrigArr(PlayerID)
	if Mask == "X" or Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Mask2 = Mask
	if Clear == 1 then
		Mask2 = 0xFFFFFFFF
	end
	if Mode == "X" then
		Mode = nil
	end
	if Mode == nil then
		Mode = SetTo
	end

	if Dest[4] == "SV" and Source[4] == "SVA" then -- Mov SV, SVA / {"X",Temp,0,"SVA",{"X",Index,0,"SA",Number,Size,Line},0,"X",Temp+1,0},
		if Dest[5] ~= Source[5][5] then
			MovS_InputData_Error()
		end
		local Box0 = {}
		local Box1 = {}
		local Box2 = {}
		local Box3 = {}
		for i = 1, Dest[5] do  
			if Clear == 1 then
				table.insert(Box0,SetCtrig1X(Dest[1],Dest[2],0x15C+0x40*(i-1),Dest[3],SetTo,0,Mask2))
			end
			table.insert(Box1,SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x15C+0x40*(i-1),1,Dest[3]))
			table.insert(Box1,SetMemory(0x6509B0,Add,0x40/4))
			table.insert(Box2,SetDeaths(CurrentPlayer,SetTo,Mask,0))
			table.insert(Box2,SetMemory(0x6509B0,Add,0x40/4))
			table.insert(Box3,SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000))
			table.insert(Box3,SetMemory(0x6509B0,Add,0x40/4))
		end
		table.insert(Box1,SetMemory(0x6509B0,Add,(-0x40*Dest[5])/4))
		table.insert(Box2,SetMemory(0x6509B0,Add,(-0x40*Dest[5])/4))
		table.insert(Box3,SetMemory(0x6509B0,Add,(-0x40*Dest[5])/4))
		Trigger {--(CPRead)로 값 출력
				players = {ParsePlayer(PlayerID)},
				conditions = {
					Label(0);
				},
				actions = {
					Box0,
					SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

					SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
					SetMemory(0x6509B0,Add,Source[6]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
					CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}
		DoActions2X(PlayerID,{
			SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
			SetMemory(0x6509B0,Add,(0x4-0x0)/4);
			SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
			SetMemory(0x6509B0,Add,(0x158-0x4)/4);
			Box1,
			SetMemory(0x6509B0,Add,(0x148-0x158)/4);
			Box2,
			SetMemory(0x6509B0,Add,(0x160-0x148)/4);
			Box3,
		})
		RecoverCp(PlayerID)
	elseif Dest[4] == "SVA" and Source[4] == "SV" then -- Mov SVA, SV 
		local TMode, TMode2
		if Dest[5][5] ~= Source[5] then
			MovS_InputData_Error()
		end
		local N = Source[5]
		local Box1 = {}
		local Box2 = {}
		if N >= 2 then
			table.insert(Box1,SetCtrigX("X",SRet[N][1],0x158,0,SetTo,"X",SRet[N][1],0x15C+0x40*1,1,0))
			table.insert(Box1,SetCtrig1X("X",SRet[N][1],0x148,0,SetTo,0xFFFFFFFF))
			table.insert(Box1,SetCtrig1X("X",SRet[N][1],0x160,0,SetTo,SetTo*16777216,0xFF000000))
			for i = 1, N-1 do
				if i == N-1 then
					table.insert(Box1,SetCtrig1X("X",SRet[N][1],0x158+0x40*i,0,SetTo,0))
				else
					table.insert(Box1,SetCtrigX("X",SRet[N][1],0x158+0x40*i,0,SetTo,"X",SRet[N][1],0x15C+0x40*(i+1),1,0))
				end
				table.insert(Box1,SetCtrig1X("X",SRet[N][1],0x148+0x40*i,0,SetTo,0xFFFFFFFF))
				table.insert(Box1,SetCtrig1X("X",SRet[N][1],0x160+0x40*i,0,SetTo,SetTo*16777216,0xFF000000))
			end
		end
		for i = 1, N do
			if type(Mode) == "number" then
				TMode = Mode
			elseif Mode[i] == nil then
				TMode = SetTo
			else
				TMode = Mode[i]
			end
			table.insert(Box2,SetCtrig1X("X",SRet[N][1],0x15C+0x40*(i-1),0,Add,0x10*(i-1)))
			table.insert(Box2,SetCtrigX("X",SRet[N][1],0x158+0x40*(i-1),0,SetTo,Source[1],Source[2],0x158+0x40*(i-1),1,Source[3]))
			table.insert(Box2,SetCtrig1X(Source[1],Source[2],0x148+0x40*(i-1),Source[3],SetTo,Mask))
			table.insert(Box2,SetCtrig1X(Source[1],Source[2],0x160+0x40*(i-1),Source[3],SetTo,TMode*16777216,0xFF000000))
			table.insert(Box2,SetCtrig1X(Source[1],Source[2],0x164+0x40*(i-1),Source[3],SetTo,0x0,0x2))
		end
		DoActions2X(PlayerID,{
					SetCtrigX("X",SRet[N][1],0x15C,0,SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
					SetCtrig1X("X",SRet[N][1],0x15C,0,Add,Dest[6]);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",SRet[N][1],0x15C,1,0);
					Box1,
					CallLabelAlways2(Dest[1],Dest[2],Dest[3],"X",SRet[N][1],0);
		})
		DoActions2X(PlayerID,{
					Box2,
					CallLabelAlways2("X",SRet[N][1],0,Source[1],Source[2],Source[3]);
		})
	else
		MovS_InputData_Error()
	end
end

function TSMem(PlayerID,Dest,Source,Address,Next,OffsetFlag) -- V << SV_EPD/Offset, SVA_EPD/Offset
	STPopTrigArr(PlayerID)
	if OffsetFlag == "X" or OffsetFlag == nil then
		OffsetFlag = 0
	end
	if Address == "X" or Address == nil then
		Address = 0x15C
	end
	if Next == "X" or Next == nil then
		Next = 0
	end

	if Dest[4] == "V" then
		if Source[4] == "SV" then
			if Source[3] == nil or Source[3] == "X" then
				Source[3] = 0 
			end
			if OffsetFlag == 0 then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Address,1,Source[3]+Next); 
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Address,0,Source[3]+Next); 
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "SVA" then
			if OffsetFlag == 0 then
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address,1,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address,0,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]*4);
						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						CallLabelAlways(Source[7],Source[8],Source[9]);
					},
					flag = {Preserved}
				}
			end
		end
	else
		_TSMem_InputData_Error()
	end
end

function f_Diff(PlayerID,Dest,Source,Mask,Time,Delay,Init)
	STPopTrigArr(PlayerID)
	if Mask == "X" or Mask == nil then
		Mask = 0xFFFFFFFF
	end
	if Time == "X" or Time == nil or Time == 1 then
		Time = 0
	end
	if Delay == "X" or Delay == nil then
		Delay = 0
	end
	if Init == "X" or Init == nil then
		Init = 0
	end

	if type(Source) == "table" and Source[4] == "VA" then
		local TempRet = {"X",CRet[7],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	end
	local PDest
	if type(Dest) == "table" and Dest[4] == "VA" then
		PDest = Dest
		Dest = {"X",CRet[8],0,"V"}
	end
	if Dest[4] == "V" then
		if Source[4] == "V" then -- Diff V, X : V << ΔX
			if Time == 0 then
				Trigger {-- Z << X - Y
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000); 
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X","X",0x158,1,SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X("X","X",0x148,1,SetTo,0xFFFFFFFF);
						SetCtrig1X("X","X",0x160,1,SetTo,Subtract*16777216,0xFF000000);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);

						SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
						SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0x0,0,1);
						SetCtrigX("X","X",0x4,1,SetTo,"X",CRet[1],0x0,0,0);
						SetCtrigX("X",CRet[1],0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
				Trigger { -- Temp V
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
						SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
					},
					flag = {Preserved}
				}
				Trigger {-- Y << X
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x15C,-1,SetTo,0);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x15C,1,-1);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				if Init ~= 0 then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0);
						},
					}
				end
			else
				if Delay ~= 0 then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x19C,4,SetTo,Delay);
						},
					}
				end
				Trigger { -- Temp Z
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0,0xFFFFFFFF); -- Full Variable
						},
						flag = {Preserved}
					}
				CIf(PlayerID,CtrigX("X","X",0x19C,2,Exactly,0),SetCtrig1X("X","X",0x19C,2,Add,Time))
					Trigger {-- Z << X - Y
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x15C,-2,SetTo,0);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x15C,1,-2);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000); 
							SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
							SetCtrigX("X","X",0x158,1,SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X("X","X",0x148,1,SetTo,0xFFFFFFFF);
							SetCtrig1X("X","X",0x160,1,SetTo,Subtract*16777216,0xFF000000);
							SetCtrigX("X",CRet[1],0x158,0,SetTo,"X","X",0x15C,1,-2);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);

							SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
							SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0x0,0,1);
							SetCtrigX("X","X",0x4,1,SetTo,"X",CRet[1],0x0,0,0);
							SetCtrigX("X",CRet[1],0x4,0,SetTo,"X","X",0x0,0,2);
						},
						flag = {Preserved}
					}
					Trigger { -- Temp V
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
							SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
							Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Timer
						},
						flag = {Preserved}
					}
					Trigger {-- Y << X
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x15C,-1,SetTo,0);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x15C,1,-1);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				CIfEnd(SetCtrig1X("X","X",0x19C,-2,Subtract,1))
				if Init ~= 0 then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
							CtrigX("X","X",0x15C,0,AtMost,Time+Delay);
						},
						actions = {
							Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Timer
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0);
							SetCtrig1X("X","X",0x15C,0,Add,1);
						},
						flag = {Preserved}
					}
				end
			end
		else
			f_Diff_InputData_Error()
		end
	else
		f_Diff_InputData_Error()
	end
	if PDest ~= nil then
		MovX(PlayerID,PDest,Dest)
	end
end

function f_LDiff(PlayerID,Dest,Source,Mask,Time,Delay,Init)
	STPopTrigArr(PlayerID)
	if Mask == "X" or Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then
		Mask = I64(Mask)
	end
	if Time == "X" or Time == nil or Time == 1 then
		Time = 0
	end
	if Delay == "X" or Delay == nil then
		Delay = 0
	end
	if Init == "X" or Init == nil then
		Init = 0
	end

	if type(Source) == "table" and Source[4] == "WA" then
		local TempRet = {"X",WRet[7],0,"W"}
		MovW(PlayerID,TempRet,Source)
		Source = TempRet
	end
	local PDest
	if type(Dest) == "table" and Dest[4] == "WA" then
		PDest = Dest
		Dest = {"X",WRet[8],0,"W"}
	end
	
	if Dest[4] == "W" then
		if Source[4] == "W" then -- LDiff V, X : V << ΔX
			if Time == 0 then
				Trigger {-- Z << X - Y
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,0);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
						SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000); 
						SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000); 
						SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X","X",0x158,1,SetTo,"X",WRet[1],0x15C,1,0);
						SetCtrigX("X","X",0x198,1,SetTo,"X",WRet[1],0x19C,1,0);
						SetCtrig1X("X","X",0x148,1,SetTo,0xFFFFFFFF);
						SetCtrig1X("X","X",0x188,1,SetTo,0xFFFFFFFF);
						SetCtrig1X("X","X",0x160,1,SetTo,Subtract*16777216,0xFF000000);
						SetCtrig1X("X","X",0x1A0,1,SetTo,Subtract*16777216,0xFF000000);

						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x24,1,3);
						SetCtrig1X(Dest[1],Dest[2],0x198,Dest[3],SetTo,0);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrigX("X",WRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrigX("X",WRet[1],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
						SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[1],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
						SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,Add*16777216,0xFF000000);

						SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
						SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0x0,0,1);
						SetCtrigX("X","X",0x4,2,SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
						SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X",WRet[1],0x0,0,0);
						SetCtrigX("X",WRet[1],0x4,0,SetTo,"X","X",0x0,0,3);
					},
					flag = {Preserved}
				}
				Trigger { -- Temp V
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
						Disabled(SetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)); -- Cp Add (Must be Preserved)
						SetDeathsX(0,SetTo,0,0,0xFFFFFFFF);  -- Full Variable
						SetCtrig1X("X",WRet[1],0x15C,0,Add,1);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],Add,1); -- Carry 가불
					},
					flag = {Preserved}
				}
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						CtrigX("X",WRet[1],0x15C,0,Exactly,0);
					},
					actions = {
						SetCtrig1X("X",WRet[1],0x19C,0,Add,1);
					},
					flag = {Preserved}
				}	
				Trigger {
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
						CtrigX(Dest[1],Dest[2],0x15C,Dest[3],AtLeast,0); -- X2 >= X2(전) : X1 -= 1 (No Carry)
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],Add,-1);
					},
					flag = {Preserved}
				}
				Trigger {-- Y << X
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x15C,-3,SetTo,0);
						SetCtrig1X("X","X",0x19C,-3,SetTo,0);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x15C,1,-3);
						SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X","X",0x19C,1,-3);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				if Init ~= 0 then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0);
							SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,0);
						},
					}
				end
			else
				if Delay ~= 0 then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x17C,4,SetTo,Delay);
						},
					}
				end
				Trigger { -- Temp Z
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0,0xFFFFFFFF); -- Full Variable
							Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Timer
							SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,0,0xFFFFFFFF); -- Full Variable
						},
						flag = {Preserved}
					}
				CIf(PlayerID,CtrigX("X","X",0x17C,2,Exactly,0),SetCtrig1X("X","X",0x17C,2,Add,Time))
					Trigger {-- Z << X - Y
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x15C,-2,SetTo,0);
							SetCtrig1X("X","X",0x19C,-2,SetTo,0);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x15C,1,-2);
							SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X","X",0x19C,1,-2);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
							SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000); 
							SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000); 
							SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0xFFFFFFFF);
							SetCtrigX("X","X",0x158,1,SetTo,"X",WRet[1],0x15C,1,0);
							SetCtrigX("X","X",0x198,1,SetTo,"X",WRet[1],0x19C,1,0);
							SetCtrig1X("X","X",0x148,1,SetTo,0xFFFFFFFF);
							SetCtrig1X("X","X",0x188,1,SetTo,0xFFFFFFFF);
							SetCtrig1X("X","X",0x160,1,SetTo,Subtract*16777216,0xFF000000);
							SetCtrig1X("X","X",0x1A0,1,SetTo,Subtract*16777216,0xFF000000);

							SetCtrigX("X","X",0x158,-2,SetTo,"X","X",0x24,1,3);
							SetCtrig1X("X","X",0x198,-2,SetTo,0);

							SetCtrigX("X",WRet[1],0x158,0,SetTo,"X","X",0x15C,1,-2);
							SetCtrigX("X",WRet[1],0x198,0,SetTo,"X","X",0x19C,1,-2);
							SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",WRet[1],0x188,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",WRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,Add*16777216,0xFF000000);

							SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
							SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0x0,0,1);
							SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,-2);
							SetCtrigX("X","X",0x4,-2,SetTo,"X",WRet[1],0x0,0,0);
							SetCtrigX("X",WRet[1],0x4,0,SetTo,"X","X",0x0,0,3);
						},
						flag = {Preserved}
					}
					Trigger { -- Temp V
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
							Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Timer
							SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
							SetCtrig1X("X",WRet[1],0x15C,0,Add,1);
							SetCtrig1X("X","X",0x19C,-3,Add,1); -- Carry 가불
						},
						flag = {Preserved}
					}
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
							CtrigX("X",WRet[1],0x15C,0,Exactly,0);
						},
						actions = {
							SetCtrig1X("X",WRet[1],0x19C,0,Add,1);
						},
						flag = {Preserved}
					}	
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
							CtrigX("X","X",0x15C,-5,AtLeast,0); -- X2 >= X2(전) : X1 -= 1 (No Carry)
						},
						actions = {
							SetCtrig1X("X","X",0x19C,-5,Add,-1);
						},
						flag = {Preserved}
					}
					Trigger {-- Y << X
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x15C,-3,SetTo,0);
							SetCtrig1X("X","X",0x19C,-3,SetTo,0);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x15C,1,-3);
							SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X","X",0x19C,1,-3);
							CallLabelAlways(Source[1],Source[2],Source[3]);
							SetCtrigX("X","X",0x4,-6,SetTo,"X","X",0x0,0,-5); -- RecoverNext
							SetCtrigX("X","X",0x158,-6,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrigX("X","X",0x198,-6,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
						},
						flag = {Preserved}
					}
				CIfEnd(SetCtrig1X("X","X",0x17C,-4,Subtract,1))
				if Init ~= 0 then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
							CtrigX("X","X",0x15C,0,AtMost,Time+Delay);
						},
						actions = {
							Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Timer
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0);
							SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,0);
							SetCtrig1X("X","X",0x15C,0,Add,1);
						},
						flag = {Preserved}
					}
				end
			end
		else
			f_LDiff_InputData_Error()
		end
	else
		f_LDiff_InputData_Error()
	end

	if PDest ~= nil then
		MovW(PlayerID,PDest,Dest)
	end
end

function f_SDiff(PlayerID,Dest,Source,Mask,Time,Delay,Init) -- SV << ΔSV(A)
	STPopTrigArr(PlayerID)
	
	if Mask == "X" or Mask == nil then
		Mask = 0xFFFFFFFF
	end
	if Time == "X" or Time == nil or Time == 1 then
		Time = 0
	end
	if Delay == "X" or Delay == nil then
		Delay = 0
	end
	if Init == "X" or Init == nil then
		Init = 0
	end

	if type(Source) == "table" and Source[4] == "SVA" then
		local TempRet = {"X",SRet[Source[5][5]][3],0,"SV",Source[5][5]}
		MovS(PlayerID,TempRet,Source)
		Source = TempRet
	end
	local PDest
	if type(Dest) == "table" and Dest[4] == "SVA" then
		PDest = Dest
		Dest = {"X",SRet[Dest[5][5]][4],0,"SV",Dest[5][5]}
	end

	local Number = Source[5]
	if Number ~= Dest[5] or Number < 1 or Number > 16 then
		SDiff_InputData_Error()
	end

	if Dest[4] == "SV" then
		if Source[4] == "SV" then -- Diff SV, X : V << ΔX
			if Time == 0 then
				local Box10 = {}
				for i = 1, Number do
					table.insert(Box10,SetCtrig1X(Dest[1],Dest[2],0x15C+0x40*(i-1),Dest[3],SetTo,0))
					table.insert(Box10,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[1],Dest[2],0x15C+0x40*(i-1),1,Dest[3]))
					table.insert(Box10,SetCtrig1X(Source[1],Source[2],0x148+0x40*(i-1),Source[3],SetTo,Mask))
					table.insert(Box10,SetCtrig1X(Source[1],Source[2],0x160+0x40*(i-1),Source[3],SetTo,SetTo*16777216,0xFF000000))
				end
				Trigger {-- Clear
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						Box10,
					},
					flag = {Preserved}
				}

				local Box11 = {}
				for i = 1, Number do
					table.insert(Box11,SetCtrig1X("X",SRet[Number][1],0x15C+0x40*(i-1),0,SetTo,0xFFFFFFFF))
					table.insert(Box11,SetCtrigX("X","X",0x158+0x40*(i-1),2,SetTo,"X",SRet[Number][1],0x15C+0x40*(i-1),1,0))
					table.insert(Box11,SetCtrig1X("X","X",0x148+0x40*(i-1),2,SetTo,0xFFFFFFFF))
					table.insert(Box11,SetCtrig1X("X","X",0x160+0x40*(i-1),2,SetTo,Subtract*16777216,0xFF000000))
				end
				Trigger {-- Clear
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						Box11,
					},
					flag = {Preserved}
				}

				local Box12 = {}
				for i = 1, Number do
					table.insert(Box12,SetCtrigX("X",SRet[Number][1],0x158+0x40*(i-1),0,SetTo,Dest[1],Dest[2],0x15C+0x40*(i-1),1,Dest[3]))
					table.insert(Box12,SetCtrig1X("X",SRet[Number][1],0x148+0x40*(i-1),0,SetTo,0xFFFFFFFF))
					table.insert(Box12,SetCtrig1X("X",SRet[Number][1],0x160+0x40*(i-1),0,SetTo,Add*16777216,0xFF000000))
				end
				Trigger {-- Z << X - Y
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						Box12,
						SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
						SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0x0,0,1);
						SetCtrigX("X","X",0x4,1,SetTo,"X",SRet[Number][1],0x0,0,0);
						SetCtrigX("X",SRet[Number][1],0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
				local Box2 = {}
				for i = 1, Number do
					table.insert(Box2,SetDeathsX(0,SetTo,0,0,0xFFFFFFFF))
					table.insert(Box2,SetCtrig1X("X",SRet[Number][1],0x15C+0x40*(i-1),0,Add,1))
				end
				Trigger { -- Temp V
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						Box2,
					},
					flag = {Preserved}
				}
				local Box3 = {}
				for i = 1, Number do
					table.insert(Box3,SetCtrig1X("X","X",0x15C+0x40*(i-1),-1,SetTo,0))
					table.insert(Box3,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,"X","X",0x15C+0x40*(i-1),1,-1))
				end
				Trigger {-- Y << X
					players = {ParsePlayer(PlayerID)},
					conditions = {
						Label(0);
					},
					actions = {
						Box3,
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				if Init ~= 0 then
					local Box4 = {}
					for i = 1, Number do
						table.insert(Box4,SetCtrig1X(Dest[1],Dest[2],0x15C+0x40*(i-1),Dest[3],SetTo,0))
					end
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							Box4,
						},
					}
				end
			else
				if Delay ~= 0 then
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x15C+0x40*Number,6,SetTo,Delay);
						},
					}
				end
				local Box0 = {}
				for i = 1, Number do
					table.insert(Box0,SetCtrig1X(Dest[1],Dest[2],0x15C+0x40*(i-1),Dest[3],SetTo,0,0xFFFFFFFF))
					table.insert(Box0,Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)))
				end
				Trigger { -- Temp Z
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							Box0; -- Full Variable
						},
						flag = {Preserved}
					}
				CIf(PlayerID,CtrigX("X","X",0x15C+0x40*Number,4,Exactly,0),SetCtrig1X("X","X",0x15C+0x40*Number,4,Add,Time))

					local Box10 = {}
					for i = 1, Number do
						table.insert(Box10,SetCtrig1X("X","X",0x15C+0x40*(i-1),-2,SetTo,0))
						table.insert(Box10,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,"X","X",0x15C+0x40*(i-1),1,-2))
						table.insert(Box10,SetCtrig1X(Source[1],Source[2],0x148+0x40*(i-1),Source[3],SetTo,Mask))
						table.insert(Box10,SetCtrig1X(Source[1],Source[2],0x160+0x40*(i-1),Source[3],SetTo,SetTo*16777216,0xFF000000))
					end
					Trigger {-- Clear
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							Box10,
						},
						flag = {Preserved}
					}

					local Box11 = {}
					for i = 1, Number do
						table.insert(Box11,SetCtrig1X("X",SRet[Number][1],0x15C+0x40*(i-1),0,SetTo,0xFFFFFFFF))
						table.insert(Box11,SetCtrigX("X","X",0x158+0x40*(i-1),2,SetTo,"X",SRet[Number][1],0x15C+0x40*(i-1),1,0))
						table.insert(Box11,SetCtrig1X("X","X",0x148+0x40*(i-1),2,SetTo,0xFFFFFFFF))
						table.insert(Box11,SetCtrig1X("X","X",0x160+0x40*(i-1),2,SetTo,Subtract*16777216,0xFF000000))	
					end
					Trigger {-- Clear
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							Box11,
						},
						flag = {Preserved}
					}

					local Box12 = {}
					for i = 1, Number do
						table.insert(Box12,SetCtrigX("X",SRet[Number][1],0x158+0x40*(i-1),0,SetTo,"X","X",0x15C+0x40*(i-1),1,-4))
						table.insert(Box12,SetCtrig1X("X",SRet[Number][1],0x148+0x40*(i-1),0,SetTo,0xFFFFFFFF))
						table.insert(Box12,SetCtrig1X("X",SRet[Number][1],0x160+0x40*(i-1),0,SetTo,Add*16777216,0xFF000000))
					end
					Trigger {-- Z << X - Y
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							Box12,
							SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
							SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0x0,0,1);
							SetCtrigX("X","X",0x4,1,SetTo,"X",SRet[Number][1],0x0,0,0);
							SetCtrigX("X",SRet[Number][1],0x4,0,SetTo,"X","X",0x0,0,2);
						},
						flag = {Preserved}
					}
					local Box2 = {}
					for i = 1, Number do
						table.insert(Box2,SetDeathsX(0,SetTo,0,0,0xFFFFFFFF))
						table.insert(Box2,SetCtrig1X("X",SRet[Number][1],0x15C+0x40*(i-1),0,Add,1))
					end
					Trigger { -- Temp V
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							Box2,
							Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Timer 0x15C+0x40*Number
						},
						flag = {Preserved}
					}
					local Box3 = {}
					for i = 1, Number do
						table.insert(Box3,SetCtrig1X("X","X",0x15C+0x40*(i-1),-1,SetTo,0))
						table.insert(Box3,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,"X","X",0x15C+0x40*(i-1),1,-1))
					end
					Trigger {-- Y << X
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
						},
						actions = {
							Box3,
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					} 
				CIfEnd(SetCtrig1X("X","X",0x15C+0x40*Number,-2,Subtract,1))
				if Init ~= 0 then
					local Box4 = {}
					for i = 1, Number do
						table.insert(Box4,SetCtrig1X(Dest[1],Dest[2],0x15C+0x40*(i-1),Dest[3],SetTo,0))
					end
					Trigger {
						players = {ParsePlayer(PlayerID)},
						conditions = {
							Label(0);
							CtrigX("X","X",0x15C,0,AtMost,Time+Delay);
						},
						actions = {
							Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Timer
							SetCtrig1X("X","X",0x15C,0,Add,1);
							Box4,
						},
						flag = {Preserved}
					}
				end
			end
		else
			f_SDiff_InputData_Error()
		end
	else
		f_SDiff_InputData_Error()
	end
	if PDest ~= nil then
		MovS(PlayerID,PDest,Dest,SetTo)
	end
end

function SetCreateVarIndex(Init,Max,Ccode,NCode)
	CreateVarInitIndex = Init
	CreateVarXAlloc = Init-1
	CreateMaxVAlloc = Max
	CreateCCodeVarXAlloc = Max-Ccode
	CreateNCodeVarXAlloc = Max-NCode-Ccode
end

function CreateVar(PlayerID)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"V",PlayerID})
	return V(CreateVarXAlloc)
end

function CreateVar2(Value,PlayerID,Offset,Type,Mask)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"V2",PlayerID,Offset,Type,Value,Mask})
	return V(CreateVarXAlloc)
end

function CreateVars(Number,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"V",PlayerID})
		table.insert(ret,V(CreateVarXAlloc))
	end
	return table.unpack(ret)
end

function CreateVarArr(Number,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"V",PlayerID})
		table.insert(ret,V(CreateVarXAlloc))
	end
	return ret
end

function CreateWar(PlayerID)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"W",PlayerID})
	return W(CreateVarXAlloc)
end

function CreateWar2(PlayerID,Offset,Type,Value,Mask)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"W2",PlayerID,Offset,Type,Value,Mask})
	return W(CreateVarXAlloc)
end

function CreateWars(Number,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"W",PlayerID})
		table.insert(ret,W(CreateVarXAlloc))
	end
	return table.unpack(ret)
end

function CreateWarArr(Number,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"W",PlayerID})
		table.insert(ret,W(CreateVarXAlloc))
	end
	return ret
end

function CreateSVar(Size,PlayerID)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"SV",PlayerID,Size})
	return {SV({"S",CreateVarXAlloc,Size}),{"S",CreateVarXAlloc,Size}}
end

function CreateSVar2(Size,PlayerID,Offset,Type,Value,Mask)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"SV2",PlayerID,Size,Offset,Type,Value,Mask})
	return {SV({"S",CreateVarXAlloc,Size}),{"S",CreateVarXAlloc,Size}}
end

function CreateSVars(Size,Number,PlayerID)	
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"SV",PlayerID,Size})
		table.insert(ret,{SV({"S",CreateVarXAlloc,Size}),{"S",CreateVarXAlloc,Size}})
	end
	return table.unpack(ret)
end

function CreateSVarArr(Size,Number,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"SV",PlayerID,Size})
		table.insert(ret,{SV({"S",CreateVarXAlloc,Size}),{"S",CreateVarXAlloc,Size}})
	end
	return ret
end

function CreateVoid()
	VoidAreaAlloc = VoidAreaAlloc+4
	return VoidAreaAlloc
end

function CreateVoids(Number)
	local ret = {}
	for i = 1, Number do
		VoidAreaAlloc = VoidAreaAlloc+4
		table.insert(ret,VoidAreaAlloc)
	end
	return table.unpack(ret)
end

function CreateVoidArr(Number)
	local ret = {}
	for i = 1, Number do
		VoidAreaAlloc = VoidAreaAlloc+4
		table.insert(ret,VoidAreaAlloc)
	end
	return ret
end

function CreateCcode()
	CreateCCodeAlloc = CreateCCodeAlloc+1
	return Ccode(CreateCCodeVarXAlloc+math.floor((CreateCCodeAlloc-1)/480),(CreateCCodeAlloc-1)%480)
end

function CreateCcodes(Number)
	local ret = {}
	for i = 1, Number do
		CreateCCodeAlloc = CreateCCodeAlloc+1
		table.insert(ret,Ccode(CreateCCodeVarXAlloc+math.floor((CreateCCodeAlloc-1)/480),(CreateCCodeAlloc-1)%480))
	end
	return table.unpack(ret)
end

function CreateCcodeArr(Number)
	local ret = {}
	for i = 1, Number do
		CreateCCodeAlloc = CreateCCodeAlloc+1
		table.insert(ret,Ccode(CreateCCodeVarXAlloc+math.floor((CreateCCodeAlloc-1)/480),(CreateCCodeAlloc-1)%480))
	end
	return ret
end

function CreateNcode()
	CreateNCodeAlloc = CreateNCodeAlloc+1
	return CCode(CreateNCodeVarXAlloc+math.floor((CreateNCodeAlloc-1)/60),(CreateNCodeAlloc-1)%60)
end

function CreateNcodes(Number)
	local ret = {}
	for i = 1, Number do
		CreateNCodeAlloc = CreateNCodeAlloc+1
		table.insert(ret,CCode(CreateNCodeVarXAlloc+math.floor((CreateNCodeAlloc-1)/60),(CreateNCodeAlloc-1)%60))
	end
	return table.unpack(ret)
end

function CreateNcodeArr(Number)
	local ret = {}
	for i = 1, Number do
		CreateNCodeAlloc = CreateNCodeAlloc+1
		table.insert(ret,CCode(CreateNCodeVarXAlloc+math.floor((CreateNCodeAlloc-1)/60),(CreateNCodeAlloc-1)%60))
	end
	return ret
end

function CreateVArr(Size,PlayerID)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"VA",PlayerID,Size})
	return {"X",CreateVarXAlloc,0,"V",0,Size}
end

function CreateWArr(Size,PlayerID)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"WA",PlayerID,Size})
	return {"X",CreateVarXAlloc,0,"W",0,Size}
end

function CreateSVArr(Number,Size,PlayerID)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"SVA",PlayerID,Size,Number})
	return {"X",CreateVarXAlloc,0,"SA",Number,Size}
end

function CreateArr(Size,PlayerID)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"A",PlayerID,Size})
	return {"X",CreateVarXAlloc,0,0}
end

function CreateLArr(Size,PlayerID)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"LA",PlayerID,Size})
	return {"X",CreateVarXAlloc,0,0}
end

function CreateDb(ByteSize,PlayerID)
	return CreateArr(ByteSize/4,PlayerID)
end

function CreateLDb(ByteSize,PlayerID)
	return CreateLArr(ByteSize/4,PlayerID)
end

function CreateVArrs(Number,Size,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"VA",PlayerID,Size})
		table.insert(ret,{"X",CreateVarXAlloc,0,"V",0,Size})
	end
	return table.unpack(ret)
end

function CreateWArrs(Number,Size,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"WA",PlayerID,Size})
		table.insert(ret,{"X",CreateVarXAlloc,0,"W",0,Size})
	end
	return table.unpack(ret)
end

function CreateSVArrs(Numbers,Number,Size,PlayerID)
	local ret = {}
	for i = 1, Numbers do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"SVA",PlayerID,Size,Number})
		table.insert(ret,{"X",CreateVarXAlloc,0,"SA",Number,Size})
	end
	return table.unpack(ret)
end

function CreateArrs(Number,Size,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"A",PlayerID,Size})
		table.insert(ret,{"X",CreateVarXAlloc,0,0})
	end
	return table.unpack(ret)
end

function CreateLArrs(Number,Size,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"LA",PlayerID,Size})
		table.insert(ret,{"X",CreateVarXAlloc,0,0})
	end
	return table.unpack(ret)
end

function CreateDbs(Number,ByteSize,PlayerID)
	return CreateArrs(Number,ByteSize/4,PlayerID)
end

function CreateLDbs(Number,ByteSize,PlayerID)
	return CreateLArrs(Number,ByteSize/4,PlayerID)
end

function CreateVArrArr(Number,Size,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"VA",PlayerID,Size})
		table.insert(ret,{"X",CreateVarXAlloc,0,"V",0,Size})
	end
	return ret
end

function CreateWArrArr(Number,Size,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"WA",PlayerID,Size})
		table.insert(ret,{"X",CreateVarXAlloc,0,"W",0,Size})
	end
	return ret
end

function CreateSVArrArr(Numbers,Number,Size,PlayerID)
	local ret = {}
	for i = 1, Numbers do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"SVA",PlayerID,Size,Number})
		table.insert(ret,{"X",CreateVarXAlloc,0,"SA",Number,Size})
	end
	return ret
end

function CreateArrArr(Number,Size,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"A",PlayerID,Size})
		table.insert(ret,{"X",CreateVarXAlloc,0,0})
	end
	return ret
end

function CreateLArrArr(Number,Size,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"LA",PlayerID,Size})
		table.insert(ret,{"X",CreateVarXAlloc,0,0})
	end
	return ret
end

function CreateDbArr(Number,ByteSize,PlayerID)
	return CreateArrArr(Number,ByteSize/4,PlayerID)
end

function CreateLDbArr(Number,ByteSize,PlayerID)
	return CreateLArrArr(Number,ByteSize/4,PlayerID)
end