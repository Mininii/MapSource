P1=0
P2=1
P3=2
P4=3
P5=4
P6=5
P7=6
P8=7
P9=8
P10=9
P11=10
P12=11

CSetTo = 10
CAdd = 11
CSubtract = 12
AtLeast = 0
AtMost = 1
Exactly = 10
SetTo = 7
Add = 8
Subtract = 9

Above = 2
Below = 3

iAtLeast = 4
iAtMost = 5
iAbove = 6
iBelow = 7

NotSame = 9

-- STR(X) ptr 고정 0x191943c8 --
-- TBL ptr 고정 0x19184660 --
STRXFlag = 0

CtrigInitArr = {}
for i = 1, 8 do
	CtrigInitArr[i] = {}
end

CJumpArr = {}
CJumpEndArr = {}
NJumpArr = {}
NJumpEndArr = {}
CIfArr = {}
CIfPArr = {}
CIfptr = 0
NIfArr = {}
NIfPArr = {}
NIfptr = 0
CWhileArr = {}
CWhilePArr = {}
CWhileptr = 0
NWhileArr = {}
NWhilePArr = {}
NWhileptr = 0
DWhileArr = {}
DWhilePArr = {}
DWhileptr = 0
CForArr = {}
CForPArr = {}
CForStep = {}
CForptr = 0
NIfXArr = {}
NIfXPArr = {}
NIfXNotArr = {}
NIfXptr = 0
CIfXArr = {}
CIfXPArr = {}
CIfXptr = 0
CWhileXArr = {}
CWhileXPArr = {}
CWhileXptr = 0
NWhileXArr = {}
NWhileXPArr = {}
NWhileXptr = 0
SLoopNArr = {}
SLoopNPArr = {}
SLoopNptr = 0
SLoopNVArr = {}
SLoopNCount = 0
NForArr = {}
NForPArr = {}
NForStepArr = {}
NForptr = 0
CSwitchArr = {}
CSwitchPArr = {}
CSwitchCaseArr = {}
CSwitchDataArr = {}
CSwitchKeyArr = {}
CSwitchptr = 0
IndexAlloc = 0xC000 -- 0xC000 ~ 0xEFFF : If, While / 0xA000 ~ 0xBFFF : Jump
IndexAllocLimit = 0xF000
FuncAlloc = 0x1D000 -- 0x1D000 ~ 0x1FFFF : CMul, CDiv, CMod / CtrigFunc
FuncAllocLimit = 0x20000
JumpStartAlloc = 0xA000
JumpEndAlloc = 0xB000
FlagAllocBase = 0xF300
FlagAllocLimit = 0xF400
VarXAlloc = 0xFE00 --  0xFE00 ~ 0xFFEF : Temp CVariable Alloc 
MAXVAlloc = 0xFE00
VarXReleaseLock = 0

WarXAlloc = 0xFC00 --  0xFC00 ~ 0xFDEF : Temp CWariable Alloc 
MAXWAlloc = 0xFC00

SVarXOrig = {0xF400,0xF440,0xF480,0xF4C0,0xF500,0xF540,0xF580,0xF5C0,0xF600,0xF640,0xF680,0xF6C0,0xF700,0xF740,0xF780,0xF7C0,0xF800,0xF840,0xF880,0xF8C0,0xF900,0xF940,0xF980,0xF9C0,0xFA00,0xFA40,0xFA80,0xFAC0,0xFB00,0xFB40,0xFB80,0xFBC0} 
SVarXAlloc = {0xF400,0xF440,0xF480,0xF4C0,0xF500,0xF540,0xF580,0xF5C0,0xF600,0xF640,0xF680,0xF6C0,0xF700,0xF740,0xF780,0xF7C0,0xF800,0xF840,0xF880,0xF8C0,0xF900,0xF940,0xF980,0xF9C0,0xFA00,0xFA40,0xFA80,0xFAC0,0xFB00,0xFB40,0xFB80,0xFBC0} --  0xF400 ~ 0xFBFF : Temp CSVariable Alloc[1~32] 
MAXSVAlloc = {0xF400,0xF440,0xF480,0xF4C0,0xF500,0xF540,0xF580,0xF5C0,0xF600,0xF640,0xF680,0xF6C0,0xF700,0xF740,0xF780,0xF7C0,0xF800,0xF840,0xF880,0xF8C0,0xF900,0xF940,0xF980,0xF9C0,0xFA00,0xFA40,0xFA80,0xFAC0,0xFB00,0xFB40,0xFB80,0xFBC0}

LabelArr = {}

CRet = {0xFFF1,0xFFF2,0xFFF3,0xFFF4,0xFFF5,0xFFF6,0xFFF7,0xFFF8,0xFFF9,0xFFFA}
NRet = {0xFFE1,0xFFE2,0xFFE3,0xFFE4,0xFFE5,0xFFE6,0xFFE7,0xFFE8,0xFFE9,0xFFEA,0xFFEB,0xFFEC,0xFFED,0xFFEE,0xFFEF,0xFFF0}
WRet = {0xFDF0,0xFDF1,0xFDF2,0xFDF3,0xFDF4,0xFDF5,0xFDF6,0xFDF7,0xFDF8,0xFDF9,0xFDFA,0xFDFB,0xFDFC,0xFDFD,0xFDFE,0xFDFF}
SRet = {{0xF43C,0xF43D,0xF43E,0xF43F},{0xF47C,0xF47D,0xF47E,0xF47F},{0xF4BC,0xF4BD,0xF4BE,0xF4BF},{0xF4FC,0xF4FD,0xF4FE,0xF4FF},
		{0xF53C,0xF53D,0xF53E,0xF53F},{0xF57C,0xF57D,0xF57E,0xF57F},{0xF5BC,0xF5BD,0xF5BE,0xF5BF},{0xF5FC,0xF5FD,0xF5FE,0xF5FF},
		{0xF63C,0xF63D,0xF63E,0xF63F},{0xF67C,0xF67D,0xF67E,0xF67F},{0xF6BC,0xF6BD,0xF6BE,0xF6BF},{0xF6FC,0xF6FD,0xF6FE,0xF6FF},
		{0xF73C,0xF73D,0xF73E,0xF73F},{0xF77C,0xF77D,0xF77E,0xF77F},{0xF7BC,0xF7BD,0xF7BE,0xF7BF},{0xF7FC,0xF7FD,0xF7FE,0xF7FF},
		{0xF83C,0xF83D,0xF83E,0xF83F},{0xF87C,0xF87D,0xF87E,0xF87F},{0xF8BC,0xF8BD,0xF8BE,0xF8BF},{0xF8FC,0xF8FD,0xF8FE,0xF8FF},
		{0xF93C,0xF93D,0xF93E,0xF93F},{0xF97C,0xF97D,0xF97E,0xF97F},{0xF9BC,0xF9BD,0xF9BE,0xF9BF},{0xF9FC,0xF9FD,0xF9FE,0xF9FF},
		{0xFA3C,0xFA3D,0xFA3E,0xFA3F},{0xFA7C,0xFA7D,0xFA7E,0xFA7F},{0xFABC,0xFABD,0xFABE,0xFABF},{0xFAFC,0xFAFD,0xFAFE,0xFAFF},
		{0xFB3C,0xFB3D,0xFB3E,0xFB3F},{0xFB7C,0xFB7D,0xFB7E,0xFB7F},{0xFBBC,0xFBBD,0xFBBE,0xFBBF},{0xFBFC,0xFBFD,0xFBFE,0xFBFF}}
ForwardPoint = {}

PushTrigArr = {}
PushTrigStack = 0
PushCondArr = {}
PushCondStack = {}
PushActArr = {}
PushActStack = {}
CondStackCount = 0
StackArrptr = 0
CondLineArr = {}
ActLineArr = {}

FlagAlloc = 0 -- 0xFFF1 ~ 0xFFFA 의 CDeaths Code (0x0000FFF1 ~ 0x01DFFFFA)

EUDORPlayer = 0
EUDORFlag = 0

TTFCodeArr = {}
TTModeArr = {}
TTPushTrigArr = {}
TTPushCondArr = {}

TTPopTrigLock = 0
TPopTrigLock = 0

ORPushCondArr = {}
ORFCodeArr = {}
ORPopTrigLock = 0

_TPushCondArr = {}
_TFCodeArr = {}
_TPopTrigLock = 0
_TPushVarXAlloc = {}
_TPopPlayerIDArr = {}

STPushTrigArr = {}
STPopTrigLock = 0
RecoverCpValue = "X"
MoveCpValue = 0
CCArr = {}
CCPArr = {}
CCptr = 0

CForce1 = {0,0,0,0,0,0,0,0}
CForce2 = {0,0,0,0,0,0,0,0}
CForce3 = {0,0,0,0,0,0,0,0}
CForce4 = {0,0,0,0,0,0,0,0}
CAllPlayers = {0,0,0,0,0,0,0,0}
Force5 = "Force5"
EveryPlayers = "EveryPlayers"

VoidAreaOffset = 0x58F500
VoidAreaAlloc = 0x58F500-4
VoidAreaLimit = 0x5967F0
StringKeyArr = {}
DetectRecoverCp = 0

CreateVarInitIndex = 0x18000
CreateVarXAlloc = 0x18000-1
CreateMaxVAlloc = 0x19FFF 
CreateVarPArr = {}

CFuncParaVarNum = 16
CStackArr = {}
LStackArr = {}
CStackptr = {}
LStackptr = {}
CStackptr2 = {}
LStackptr2 = {}
CreateCStackVarXAlloc = 64
CreateLStackVarXAlloc = 32
CreateCCodeVarXAlloc = 0x19F00
CreateNCodeVarXAlloc = 0x19A00
CreateCCodeAlloc = 0
CreateNCodeAlloc = 0

iStringKeyArr = {}
iTBLIndexArr = {}
BulletTable = {}
BulletInitTable = {}
CFuncParaVarArr = {}
CFuncRetVarArr = {}
VFuncParaVarArr = {}

STRCTRIGASM = 0
NSQCVArray = {}
IncludePlayerID = 0
NBagLoopArr = {}
NBagIndexArr = {}
NBagLoopptr = 0
math.randomseed(os.time())

CheckInclude_DataTransfer = 0
CheckInclude_ArithMetic = 0
CheckInclude_MatheMatics = 0
CheckInclude_MiscFunctions = 0
CheckInclude_64BitLibrary = 0
CheckInclude_CtrigPlib = 0
-- 맵 정보 입력 관련 함수 ---------------------------------------------------------------

function SetFixedPlayer(PlayerID)
	FixPlayer = PlayerID
end

function SetForces(defForce1,defForce2,defForce3,defForce4,defAllPlayers)
	for k, P in pairs(defForce1) do
		CForce1[P+1] = 1
	end

	for k, P in pairs(defForce2) do
		CForce2[P+1] = 1
	end

	for k, P in pairs(defForce3) do
		CForce3[P+1] = 1
	end

	for k, P in pairs(defForce4) do
		CForce4[P+1] = 1
	end

	for k, P in pairs(defAllPlayers) do
		CAllPlayers[P+1] = 1
	end
end

function PlayerConvert(PlayerID)
	local Temp = {}
	if type(PlayerID) == "number" or PlayerID == Force1 or PlayerID == Force2 or PlayerID == Force3 or PlayerID == Force4 or PlayerID == AllPlayers then
		PlayerID = {PlayerID}
	end
	
	local Input = {0,0,0,0,0,0,0,0}

	for k, P in pairs(PlayerID) do
		if P == Force1 then
			for i, v in pairs(CForce1) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == Force2 then
			for i, v in pairs(CForce2) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == Force3 then
			for i, v in pairs(CForce3) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == Force4 then
			for i, v in pairs(CForce4) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == AllPlayers then
			for i, v in pairs(CAllPlayers) do
				if v == 1 then
					Input[i] = 1
				end
			end
		else 
			Input[P+1] = 1
		end
	end

	for i = 1, 8 do
		if Input[i] == 1 then
			table.insert(Temp,i-1)
		end
	end

	return Temp
end

function PlayerConvertX(PlayerID)
	local Temp = {}
	if type(PlayerID) == "number" or PlayerID == Force1 or PlayerID == Force2 or PlayerID == Force3 or PlayerID == Force4 or PlayerID == AllPlayers then
		PlayerID = {PlayerID}
	end
	if PlayerID == Force5 then
		PlayerID = {P9,P10,P11,P12}
	end
	if PlayerID == EveryPlayers then
		PlayerID = {AllPlayers,P9,P10,P11,P12}
	end
 	
	local Input = {0,0,0,0,0,0,0,0,0,0,0,0}

	for k, P in pairs(PlayerID) do
		if P == Force1 then
			for i, v in pairs(CForce1) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == Force2 then
			for i, v in pairs(CForce2) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == Force3 then
			for i, v in pairs(CForce3) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == Force4 then
			for i, v in pairs(CForce4) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == AllPlayers then
			for i, v in pairs(CAllPlayers) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == Force5 then
			Input[9] = 1
			Input[10] = 1
			Input[11] = 1
			Input[12] = 1
		elseif P == EveryPlayers then
			for i, v in pairs(CAllPlayers) do
				if v == 1 then
					Input[i] = 1
				end
			end
			Input[9] = 1
			Input[10] = 1
			Input[11] = 1
			Input[12] = 1
		else 
			Input[P+1] = 1
		end
	end

	for i = 1, 8 do
		if Input[i] == 1 then
			table.insert(Temp,i-1)
		end
	end
	for i = 9, 12 do
		if Input[i] == 1 then
			table.insert(Temp,i-9+128)
		end
	end

	return Temp
end

-- CtrigAsm 표준 환경 설치 함수 ---------------------------------------------------------

function StartCtrig(STRX,IncludePlayer,NSQC,STRCTRIG,AbsolutePath,CFunc,CStack,LStack)
	if IncludePlayer == nil then IncludePlayer = AllPlayers end
	IncludePlayerID = IncludePlayer
	-- Init Alloc 
	if CFunc ~= nil then
		CFuncParaVarNum = CFunc
	else
		CFuncParaVarNum = 16
	end
	if CStack ~= nil then
		CreateCStackVarXAlloc = CStack
	else
		CreateCStackVarXAlloc = 64
	end
	if LStack ~= nil then
		CreateLStackVarXAlloc = LStack
	else
		CreateLStackVarXAlloc = 32
	end
	CFuncParaVarArr = CreateVarArr(CFuncParaVarNum,FixPlayer) -- CFunc x16
	CFuncRetVarArr = CreateVarArr(CFuncParaVarNum,FixPlayer) -- CFunc x16
	VFuncParaVarArr = CreateVarArr(CFuncParaVarNum,FixPlayer) -- CFunc x16
	CStackArr = CreateVArr(CreateCStackVarXAlloc,FixPlayer)
	CStackptr = CreateVar(FixPlayer)
	CStackptr2 = CreateWar(FixPlayer)
	LStackArr = CreateWArr(CreateLStackVarXAlloc,FixPlayer)
	LStackptr = CreateVar(FixPlayer)
	LStackptr2 = CreateWar(FixPlayer)
	
	if STRX == 0 or STRX == nil or STRX == "X" or STRX == "STR" then
		STRXFlag = 0
	else
		STRXFlag = 1
	end
	if STRCTRIG == 0 or STRCTRIG == nil or STRCTRIG == "X" then
		STRCTRIGASM = 0
	else
		STRCTRIGASM = 1
	end
	if AbsolutePath ~= nil then
		SetFileDirectory(AbsolutePath)
	end
	Trigger {
		players = {AllPlayers},
		conditions = {
			Label(0xFFFB);
			Disabled(DeathsX(0,Exactly,FixPlayer,0,0));
		},
		actions = {
			SetNext(0xFFFB,0xFFFC);
		},
	}
	if NSQC == nil then
		NSQC = 0
	end
	for i = 1, NSQC do
		local NSQCTemp = CVArray(FixPlayer,8)
		table.insert(NSQCVArray,NSQCTemp)
	end

	for j = 1, 16 do
		for i = 1, 4 do
			CSVariable(AllPlayers,SRet[j][i],j)
		end
	end
	for i = 0, 15 do -- WRet
		CWariable(AllPlayers,0xFDF0 + i)
	end
	for i = 1, 16 do -- NRet
		CVariable(AllPlayers,0xFFE0 + i)
	end
	for i = 1, 10 do -- CRet
		CVariable(AllPlayers,0xFFF0 + i)
	end

	if STRCTRIGASM == 0 then
		Trigger {
			players = {AllPlayers},
			conditions = {
				Label(0xFFFC);
			},
			actions = {
				SetNext(0xFFFC,0xFFFD);
			},
		}
	else
		Trigger {
			players = {AllPlayers},
			conditions = {
				Label(0xFFFC);
			},
			actions = {
				SetNext(0xFFFC,0xFFFD);
				Disabled(SetCtrigX("X",0xFFFD,0x4,0,SetTo,"X",0xFFFF,0x0,0,0));
			},
			flag = {Preserved},
		}
	end
	return NSQCVArray
end

function EndCtrig()
	if #iStringKeyArr > 0 then
		if STRXFlag == 0 then -- STR Table
			ISTRCheck = 1
			FPSTRCheck = 1
		else -- STRX Table
			FISTRXCheck = 1
		end
	end
	if #iTBLIndexArr > 0 then
		ITBLCheck = 1
		FPTBLCheck = 1
	end
	Include_Last()

	if STRCTRIGASM == 0 then
		Trigger {
			players = {AllPlayers},
			conditions = { 
				Label(0xFFFD);
			},
		}
	else
		Trigger {
			players = {AllPlayers},
			conditions = { 
				Label(0xFFFD);
			},
			actions = {
				Disabled(SetCtrigX("X",0xFFFC,0x4,0,SetTo,"X",0xFFFD,0x0,0,0));
			},
			flag = {Preserved},
		}
		Trigger {
			players = {AllPlayers},
			conditions = { 
				Label(0);
			},
			actions = {
				Disabled(SetCtrigX("X",0xFFFD,0x4,0,SetTo,"X",0xFFFD,0x0,0,0));
			},
			flag = {Preserved},
		}
	end
	InitCtrig()

	if CheckInclude_Wireframe == 1 then
		Trigger {
			players = {FixPlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FWIREINITCall1,0x0,0,0);
				SetCtrigX("X",FWIREINITCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}

		RecoverCp(FixPlayer)
	end

	for k, v in pairs(iStringKeyArr) do
		if STRXFlag == 0 then -- STR Table
			f_GetiStrptr(v[2],v[3],v[1]) 
			f_InitiStrptr(v[2],v[3],v[3],v[4])
		else -- STRX Table
			f_GetiStrXepd(v[2],v[3],v[1]) -- +0x0 Fixed
		end
	end

	for k, v in pairs(iTBLIndexArr) do
		f_GetTblptr(v[2],v[3],v[1]) 
		f_InitiTblptr(v[2],v[3],v[3],v[4],v[1])
	end

	if STRCTRIGASM == 0 then
		Trigger {
			players = {AllPlayers},
			conditions = {
				Label(0xFFFE);
			},
			actions = {
				SetNext(0xFFFC,0xFFFC,1);
				SetNext(0xFFFD,0xFFFE);
				SetNext(0xFFFE,0xFFFF);
			},
		}
	else
		Trigger {
			players = {AllPlayers},
			conditions = {
				Label(0xFFFE);
			},
			actions = {
				SetNext(0xFFFE,0xFFFF);
				SetCtrigX("X",0xFFFC,0x158,0,SetTo,"X",0xFFFC,0x4,1,0);
				SetCtrigX("X",0xFFFC,0x15C,0,SetTo,"X",0xFFFC,0x0,0,1);
				SetCtrigX("X",0xFFFD,0x4,1,SetTo,"X",0xFFFF,0x0,0,0);
				SetCtrig1X("X",0xFFFD,0x164,1,SetTo,0x0,0x2);
				SetCtrig1X("X",0xFFFD,0x164,0,SetTo,0x0,0x2);
				SetCtrig1X("X",0xFFFC,0x184,0,SetTo,0x0,0x2);
			},
		}
	end

	local FlagAllocIndex = FlagAllocBase+math.ceil(FlagAlloc/480)-1
	for i = FlagAllocBase, FlagAllocIndex do
		Trigger {
			players = {AllPlayers},
			conditions = {
				Label(i);
			},
		}
	end
	
	Trigger {
		players = {AllPlayers},
			conditions = {
				Label(0xF000); -- ARet
			},
			actions = {
				SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
				Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
			},
			flag = {Preserved}
		}
	local StartOff = {0x640B60+218*0,0x640B62+218*1,0x640B60+218*2,0x640B62+218*3,0x640B60+218*4,0x640B62+218*5,0x640B60+218*6,0x640B62+218*7,0x640B60+218*8,0x640B62+218*9,
					0x640B60+218*10,0x640B60+218*0,0x640B62+218*1,0x640B60+218*2,0x640B62+218*3,0x640B60+218*4,0x640B62+218*5,0x640B60+218*6,0x640B62+218*7,0x640B60+218*8,0x640B62+218*9}
	local InitOff = {SetMemoryX(0x640C38+218*0,SetTo,0x0D0D,0xFFFF),
			SetMemoryX(0x640C38+218*0,SetTo,0x0D0D0000,0xFFFF0000),
			SetMemoryX(0x640C38+218*2,SetTo,0x0D0D,0xFFFF),
			SetMemoryX(0x640C38+218*2,SetTo,0x0D0D0000,0xFFFF0000),
			SetMemoryX(0x640C38+218*4,SetTo,0x0D0D,0xFFFF),
			SetMemoryX(0x640C38+218*4,SetTo,0x0D0D0000,0xFFFF0000),
			SetMemoryX(0x640C38+218*6,SetTo,0x0D0D,0xFFFF),
			SetMemoryX(0x640C38+218*6,SetTo,0x0D0D0000,0xFFFF0000),
			SetMemoryX(0x640C38+218*8,SetTo,0x0D0D,0xFFFF),
			SetMemoryX(0x640C38+218*8,SetTo,0x0D0D0000,0xFFFF0000),
			SetMemoryX(0x640C38+218*10,SetTo,0x0D0D,0xFFFF),
			SetMemoryX(0x640C38+218*0,SetTo,0x0D0D,0xFFFF),
			SetMemoryX(0x640C38+218*0,SetTo,0x0D0D0000,0xFFFF0000),
			SetMemoryX(0x640C38+218*2,SetTo,0x0D0D,0xFFFF),
			SetMemoryX(0x640C38+218*2,SetTo,0x0D0D0000,0xFFFF0000),
			SetMemoryX(0x640C38+218*4,SetTo,0x0D0D,0xFFFF),
			SetMemoryX(0x640C38+218*4,SetTo,0x0D0D0000,0xFFFF0000),
			SetMemoryX(0x640C38+218*6,SetTo,0x0D0D,0xFFFF),
			SetMemoryX(0x640C38+218*6,SetTo,0x0D0D0000,0xFFFF0000),
			SetMemoryX(0x640C38+218*8,SetTo,0x0D0D,0xFFFF),
			SetMemoryX(0x640C38+218*8,SetTo,0x0D0D0000,0xFFFF0000),
		}
	local MaskOff = {0xFFFF,0xFFFF0000,0xFFFF,0xFFFF0000,0xFFFF,0xFFFF0000,0xFFFF,0xFFFF0000,0xFFFF,0xFFFF0000,0xFFFF,
					0xFFFF,0xFFFF0000,0xFFFF,0xFFFF0000,0xFFFF,0xFFFF0000,0xFFFF,0xFFFF0000,0xFFFF,0xFFFF0000}
	for i = 1, 21 do
		local Box = {}
		for j = 0, 53 do
			table.insert(Box,SetMemoryX(StartOff[i]+0x4*j,SetTo,0x0D0D0D0D,0xFFFFFFFF))
		end
		Trigger {
			players = {AllPlayers},
			conditions = {
				Label(0);
			},
			actions = {
				Box,
				InitOff[i],
				SetCtrig1X("X","X",0x148+0x20*54,0,SetTo,MaskOff[i]);
			},
			flag = {Preserved}
		}
	end
	if EncodeTable ~= 0 then
		EncodeTableptr(AllPlayers)
	end
	if TBLStringTable ~= 0 then
		io.close(TBLStringTable)
	end
	for i = CreateVarInitIndex, CreateVarXAlloc do
		local k = i - CreateVarInitIndex+1
		if CreateVarPArr[k][1] == "V" then
			 CVariable(CreateVarPArr[k][2],i)
		elseif CreateVarPArr[k][1] == "V2" then
			CVariable2(CreateVarPArr[k][2],i,CreateVarPArr[k][3],CreateVarPArr[k][4],CreateVarPArr[k][5],CreateVarPArr[k][6])
		elseif CreateVarPArr[k][1] == "W" then
			CWariable(CreateVarPArr[k][2],i)
		elseif CreateVarPArr[k][1] == "W2" then
			CWariable2(CreateVarPArr[k][2],i,CreateVarPArr[k][3],CreateVarPArr[k][4],CreateVarPArr[k][5],CreateVarPArr[k][6])
		elseif CreateVarPArr[k][1] == "SV" then
			CSVariable(CreateVarPArr[k][2],i,CreateVarPArr[k][3])
		elseif CreateVarPArr[k][1] == "SV2" then
			CSVariable2(CreateVarPArr[k][2],i,CreateVarPArr[k][3],CreateVarPArr[k][4],CreateVarPArr[k][5],CreateVarPArr[k][6],CreateVarPArr[k][7])
		elseif CreateVarPArr[k][1] == "VA" then
			Trigger {
				players = {CreateVarPArr[k][2]},
				conditions = {
					Label(i);
				},
				actions = {
					SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
			for i = 2, CreateVarPArr[k][3] do 
				Trigger {
					players = {CreateVarPArr[k][2]},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
						Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
					},
					flag = {Preserved}
				}
			end
		elseif CreateVarPArr[k][1] == "VA2" then
			local TempValue = CreateVarPArr[k][4][1]
			if CreateVarPArr[k][4][1] == nil then
				TempValue = 0
			end
			Trigger {
				players = {CreateVarPArr[k][2]},
				conditions = {
					Label(i);
				},
				actions = {
					SetDeathsX(0,SetTo,TempValue,0,0xFFFFFFFF); -- Full Variable
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
			for i = 2, CreateVarPArr[k][3] do 
				TempValue = CreateVarPArr[k][4][i]
				if CreateVarPArr[k][4][i] == nil then
					TempValue = 0
				end
				Trigger {
					players = {CreateVarPArr[k][2]},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeathsX(0,SetTo,TempValue,0,0xFFFFFFFF); -- Full Variable
						Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
					},
					flag = {Preserved}
				}
			end
		elseif CreateVarPArr[k][1] == "WA" then
			Trigger {
				players = {CreateVarPArr[k][2]},
				conditions = {
					Label(i);
				},
				actions = {
					SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
					Disabled(SetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)); -- Cp Add (Must be Preserved)
					SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
			for i = 2, CreateVarPArr[k][3] do 
				Trigger {
					players = {CreateVarPArr[k][2]},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
						Disabled(SetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)); -- Cp Add (Must be Preserved)
						SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
						Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
					},
					flag = {Preserved}
				}
			end
		elseif CreateVarPArr[k][1] == "WA2" then
			local TempValue
			if CreateVarPArr[k][4][1] == nil then
				TempValue = {0,0}
			elseif type(CreateVarPArr[k][4][1]) == "number" then -- Type == "table" 일 경우 그대로 삽입
				TempValue = {CreateVarPArr[k][4][1],0} -- 32Bit Number
			elseif type(CreateVarPArr[k][4][1]) == "string" then
				TempValue = I64(CreateVarPArr[k][4][1])
			else 
				TempValue = CreateVarPArr[k][4][1]
			end
			Trigger {
				players = {CreateVarPArr[k][2]},
				conditions = {
					Label(i);
				},
				actions = {
					SetDeathsX(0,SetTo,TempValue[1],0,0xFFFFFFFF); -- Full Variable
					Disabled(SetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)); -- Cp Add (Must be Preserved)
					SetDeathsX(0,SetTo,TempValue[2],0,0xFFFFFFFF); -- Full Variable
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
			for i = 2, CreateVarPArr[k][3] do 
				if CreateVarPArr[k][4][i] == nil then
					TempValue = {0,0}
				elseif type(CreateVarPArr[k][4][i]) == "number" then -- Type == "table" 일 경우 그대로 삽입
					TempValue = {CreateVarPArr[k][4][i],0} -- 32Bit Number
				elseif type(CreateVarPArr[k][4][i]) == "string" then
					TempValue = I64(CreateVarPArr[k][4][i])
				else 
					TempValue = CreateVarPArr[k][4][i]
				end
				Trigger {
					players = {CreateVarPArr[k][2]},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeathsX(0,SetTo,TempValue[1],0,0xFFFFFFFF); -- Full Variable
						Disabled(SetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)); -- Cp Add (Must be Preserved)
						SetDeathsX(0,SetTo,TempValue[2],0,0xFFFFFFFF); -- Full Variable
						Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
					},
					flag = {Preserved}
				}
			end
		elseif CreateVarPArr[k][1] == "SVA" then
			if CreateVarPArr[k][4] <= 0 or CreateVarPArr[k][4] >= 33 then
				SVariable_InputData_Error()
			end
			local Box = {}
			for i = 2, CreateVarPArr[k][4] do
				table.insert(Box,Disabled(SetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)))
				table.insert(Box,SetDeathsX(0,SetTo,0,0,0xFFFFFFFF))
			end
			Trigger {
				players = {CreateVarPArr[k][2]},
				conditions = {
					Label(i);
				},
				actions = {
					SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); 
					Box,
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
			for i = 2, CreateVarPArr[k][3] do 
				Trigger {
					players = {CreateVarPArr[k][2]},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); 
						Box,
						Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
					},
					flag = {Preserved}
				}
			end
		elseif CreateVarPArr[k][1] == "A" then
			local TNum = CreateVarPArr[k][3]/602
			if  CreateVarPArr[k][3]%602 ~= 0 then
				TNum = TNum + 1
			end
			Trigger {
				players = {CreateVarPArr[k][2]},
				conditions = {
					Label(i);
				},
				flag = {Preserved}
			}
			for i = 2, TNum do 
				Trigger {
					players = {CreateVarPArr[k][2]},
					flag = {Preserved}
				}
			end
		elseif CreateVarPArr[k][1] == "LA" then
			local TNum = math.ceil(CreateVarPArr[k][3]/151)
			Trigger {
				players = {CreateVarPArr[k][2]},
				conditions = {
					Label(i);
				},
				flag = {Preserved}
			}
			for i = 2, TNum do 
				Trigger {
					players = {CreateVarPArr[k][2]},
					flag = {Preserved}
				}
			end
		elseif CreateVarPArr[k][1] == "FA" then
			local TNum = math.ceil(CreateVarPArr[k][3]/0x970)
			Trigger {
				players = {P10,CreateVarPArr[k][2]},
				conditions = {
					Label(i);
					Never();
				},
				actions = {
					SetDeathsX(0,SetTo,TNum,0,0);
				},
				flag = {Preserved}
			}
		elseif CreateVarPArr[k][1] == "SVA32" then
			local Size = CreateVarPArr[k][4]
			local Arr = CreateVarPArr[k][3]
			local Box1 = {}
			local Box2 = {}
			local n = 1
			while true do
				if n <= 128 then
					table.insert(Box1,SetDeaths(CurrentPlayer,SetTo,Arr[n]+Arr[n+1]*256+Arr[n+2]*65536+Arr[n+3]*16777216,0))
					table.insert(Box1,SetMemory(0x6509B0,Add,1))
				else
					table.insert(Box2,SetDeaths(CurrentPlayer,SetTo,Arr[n]+Arr[n+1]*256+Arr[n+2]*65536+Arr[n+3]*16777216,0))
					table.insert(Box2,SetMemory(0x6509B0,Add,1))
				end
				n = n+4
				if n > #Arr then break end
			end
			Trigger {
				players = {CreateVarPArr[k][2]},
				conditions = {
					Label(i);
				},
				actions = {
					Box1,
				},
				flag = {Preserved}
			}
			for m = 2, Size do
				DoActions2X(CreateVarPArr[k][2],Box2)
			end
		elseif CreateVarPArr[k][1] == "SVA32X" then
			local Size = CreateVarPArr[k][4]
			local Arr = CreateVarPArr[k][3]
			local Box1 = {}
			local Box2 = {}
			local n = 1
			while true do
				if n <= 128 then
					table.insert(Box1,SetDeaths(CurrentPlayer,SetTo,Arr[n]+Arr[n+1]*256+Arr[n+2]*65536+Arr[n+3]*16777216,0))
					table.insert(Box1,SetMemory(0x6509B0,Add,8))
				else
					table.insert(Box2,SetDeaths(CurrentPlayer,SetTo,Arr[n]+Arr[n+1]*256+Arr[n+2]*65536+Arr[n+3]*16777216,0))
					table.insert(Box2,SetMemory(0x6509B0,Add,8))
				end
				n = n+4
				if n > #Arr then break end
			end
			Trigger {
				players = {CreateVarPArr[k][2]},
				conditions = {
					Label(i);
				},
				actions = {
					Box1,
				},
				flag = {Preserved}
			}
			for m = 2, Size do
				DoActions2X(CreateVarPArr[k][2],Box2)
			end
		elseif CreateVarPArr[k][1] == "SVA1" then
			local Size = CreateVarPArr[k][4]
			local Arr = CreateVarPArr[k][3]
			local Box1 = {}
			local Box2 = {}
			local n = 1
			while true do
				if n <= 4 then
					table.insert(Box1,Disabled(SetDeathsX(CurrentPlayer,SetTo,Arr[n]+Arr[n+1]*256+Arr[n+2]*65536+Arr[n+3]*16777216,0,0xFFFFFFFF)))
				else
					table.insert(Box2,Disabled(SetDeathsX(CurrentPlayer,SetTo,Arr[n]+Arr[n+1]*256+Arr[n+2]*65536+Arr[n+3]*16777216,0,0xFFFFFFFF)))
				end
				n = n+4
				if n > #Arr then break end
			end
			Trigger {
				players = {CreateVarPArr[k][2]},
				conditions = {
					Label(i);
				},
				actions = {
					Box1,
					FSetMemoryX(0x6509B0,Add,1,0xFFFFFFFF);
					SetCtrig1X("X","X",0x164,0,SetTo,0x2,0x2);
				},
				flag = {Preserved}
			}
			for m = 2, Size do
				Trigger {
					players = {CreateVarPArr[k][2]},
					conditions = {
						Label();
					},
					actions = {
						Box2[m-1],
						FSetMemoryX(0x6509B0,Add,1,0xFFFFFFFF);
						SetCtrig1X("X","X",0x164,0,SetTo,0x2,0x2);
					},
					flag = {Preserved}
				}
			end
		elseif CreateVarPArr[k][1] == "NP1" then
			local Number = CreateVarPArr[k][3]
			local Index = CreateVarPArr[k][4]
			local Box1 = {}
			for n = 0, Number-1 do
				table.insert(Box1, SetCtrig2X(0,SetTo,"X",Index,0x15C+0x40*n,1,0))
				table.insert(Box1, SetCtrig1X("X",Index,0x15C+0x40*n,0,SetTo,0))
			end

			Trigger {
				players = {CreateVarPArr[k][2]},
				conditions = {
					Label(i);
				},
				actions = {
					Box1,
				},
				flag = {Preserved}
			}
		elseif CreateVarPArr[k][1] == "NP2" then
			local Number = CreateVarPArr[k][3]
			local Index = CreateVarPArr[k][4]
			local Box1 = {}
			for n = 0, Number-1 do
				table.insert(Box1, SetCtrig1X("X",Index,0x158+0x40*n,0,SetTo,0))
			end
			Trigger {
				players = {CreateVarPArr[k][2]},
				conditions = {
					Label(i);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",Index,0x0,0,0);
					SetCtrig1X("X",Index,0x4,0,SetTo,0);
					Box1,
				},
				flag = {Preserved}
			}
		elseif CreateVarPArr[k][1] == "VFP" then
			local Number = CreateVarPArr[k][3]
			local CFuncPara = CreateVarPArr[k][4]
			local Box1 = {}
			for n = 0, Number-1 do
				table.insert(Box1, SetCtrigX(FixPlayer,VFuncParaVarArr[n+1][2],0x158,0,SetTo,FixPlayer,CFuncPara[n+1][2],0x15C,1,0))
			end
			Trigger {
				players = {CreateVarPArr[k][2]},
				conditions = {
					Label(i);
				},
				actions = {
					Box1,
				},
				flag = {Preserved}
			}
		end
	end
	local CcodeVarX = math.ceil(CreateCCodeAlloc/480)
	for i = 1, CcodeVarX do 
		CVariable(AllPlayers,i+CreateCCodeVarXAlloc-1)
	end
	local NcodeVarX = math.ceil(CreateNCodeAlloc/60)
	for i = 1, NcodeVarX do 
		CVariable(FixPlayer,i+CreateNCodeVarXAlloc-1)
	end
	for i = 0xFC00, MAXWAlloc do
		CWariable(AllPlayers,i)
	end
	for i = 0xFE00, MAXVAlloc do
		CVariable(AllPlayers,i)
	end
	for j = 1, 16 do
		for i = SVarXOrig[j], MAXSVAlloc[j] do
			CSVariable(AllPlayers,i,j)
		end
	end
	local StringAct = {}
	for k, v in pairs (StringKeyArr) do
		table.insert(StringAct,Disabled(DisplayText(v,4)))
	end
	DoActions2(FixPlayer,{StringAct})

	if ExtTextIndex > 1 then
		f_PatchSTRxArr(FixPlayer)
	end
	Trigger { 
		players = {AllPlayers},
		conditions = {
			Label(0xFFFF);
		},
	}
	AllocCheck()
	CAPlotAllocCheck()
	CAPrintAllocCheck()
end

-- 기본 내장 조건/액션 (.py) ------------------------------------------------------------

function Label(Index)
	if Index == nil then
		Index = 0
	end
	local Label = Condition(0,0,Index,0,Exactly,0xFE,0,0x2) -- flag : 조건/액션 - 0x2 = Disabled
	if Index >= 1 then
		table.insert(LabelArr,Index)
	end
	return Label
end

function CtrigX(Player,Index,Address,Next,Type,Value,Mask)

	if Player == "X" then 
		Player = nil
	end
	if Index == "X" then 
		Index = nil
	end
	if Next == "X" then 
		Next = nil
	end
	if Mask == "X" then 
		Mask = nil
	end

	local Pflag
	if Player == nil then
		Pflag = 0
	else
		if Player >= 0 and Player <= 7 then
			Pflag = Player + 1
		else
			Pflag = 0
		end
	end

	local Mflag
	if Mask == nil then
		Mflag = 0
		Mask = 0
	else
		--Mflag = 32 (Rflag)
		Mflag = 0x80
	end

	local Nflag
	if Next == 0 or Next == nil then
		Nflag = 0
	elseif Next == 1 then 
		Nflag = 16
	else
		Nflag = 0
		Address = Address + 0x970*Next
	end

	local Cflag
	if Index == nil then
		Index = 0
		Cflag = 64
	else
		Cflag = 0
	end

	local Xflag = 0
	if Index >= 0x10000 then
		Index = Index - 0x10000
		Xflag = 128
	end

	local Rflag
	Rflag = Pflag + Nflag + Cflag + Xflag

	local ExCtrigX = Condition(Mask,Address/4,Value,Index,Type,0xFF,Rflag,0x10+Mflag) -- #DefCond
	return ExCtrigX
end

function SetCtrigX(Player1,Index1,Address1,Next1,Type,Player2,Index2,Address2,EPD2,Next2,Mask)
	if Player1 == "X" then 
		Player1 = nil
	end
	if Index1 == "X" then 
		Index1 = nil
	end
	if Next1 == "X" then 
		Next1 = nil
	end
	if Player2 == "X" then 
		Player2 = nil
	end
	if Index2 == "X" then 
		Index2 = nil
	end
	if Next2 == "X" then 
		Next2 = nil
	end
	if EPD2 == "X" then
		EPD2 = nil
	end
	if Mask == "X" then 
		Mask = nil
	end

	local Pflag1
	if Player1 == nil then
		Pflag1 = 0
	else
		if Player1 >= 0 and Player1 <= 7 then
			Pflag1 = Player1 + 1
		else
			Pflag1 = 0
		end
	end

	local Nflag1
	if Next1 == 0 or Next1 == nil then
		Nflag1 = 0
	elseif Next1 == 1 then 
		Nflag1 = 16
	else
		Nflag1 = 0
		Address1 = Address1 + 0x970*Next1
	end

	local Cflag1
	if Index1 == nil then
		Index1 = 0
		Cflag1 = 32
	else
		Cflag1 = 0
	end

	local Xflag1 = 0
	if Index1 >= 0x10000 then
		Index1 = Index1 - 0x10000
		Xflag1 = 64
	end

	local Pflag2
	if Player2 == nil then
		Pflag2 = 0
	else
		if Player2 >= 0 and Player2 <= 7 then
			Pflag2 = Player2 + 1
		else
			Pflag2 = 0
		end
	end

	local Nflag2
	if Next2 == 0 or Next2 == nil then
		Nflag2 = 0
	elseif Next2 == 1 then 
		Nflag2 = 16
	else
		Nflag2 = 0
		Address2 = Address2 + 0x970*Next2
	end

	local Mflag2
	if Mask == nil then
		Mflag2 = 0
		Mask = 0
	else
		--Mflag2 = 64 (Rflag2)
		Mflag2 = 0x80
	end

	local Addr2
	if EPD2 == 0 or EPD2 == nil then
		Addr2 = Address2
		Eflag2 = 0
	else
		Addr2 = Address2/4
		Eflag2 = 32
	end

	local Cflag2
	if Index2 == nil then
		Index2 = 0
		Cflag2 = 128
	else
		Cflag2 = 0
	end

	local Xflag2 = 0
	if Index2 >= 0x10000 then
		Index2 = Index2 - 0x10000
		Xflag2 = 128
	end

	local Rflag1
	Rflag1 = Pflag1 + Nflag1 + Cflag1 + Xflag1 + Xflag2
	local Rflag2
	Rflag2 = Pflag2 + Nflag2 + Eflag2 + Cflag2

	local ExSetCtrigX = Action(Mask,Index1,Rflag1,Rflag2,Address1/4,Addr2,Index2,0x5,Type,0x14+Mflag2) -- #DefAct (PauseGame = 0x5)
	return ExSetCtrigX
end

function SetCtrig1X(Player1,Index1,Address1,Next1,Type,Value,Mask)
	if Player1 == "X" then 
		Player1 = nil
	end
	if Index1 == "X" then 
		Index1 = nil
	end
	if Next1 == "X" then 
		Next1 = nil
	end
	if Mask == "X" then 
		Mask = nil
	end

	local Pflag1
	if Player1 == nil then
		Pflag1 = 0
	else
		if Player1 >= 0 and Player1 <= 7 then
			Pflag1 = Player1 + 1
		else
			Pflag1 = 0
		end
	end

	local Nflag1
	if Next1 == 0 or Next1 == nil then
		Nflag1 = 0
	elseif Next1 == 1 then 
		Nflag1 = 16
	else
		Nflag1 = 0
		Address1 = Address1 + 0x970*Next1
	end

	local Cflag1
	if Index1 == nil then
		Index1 = 0
		Cflag1 = 32
	else
		Cflag1 = 0
	end

	local Xflag1 = 0
	if Index1 >= 0x10000 then
		Index1 = Index1 - 0x10000
		Xflag1 = 64
	end

	local Rflag1
	Rflag1 = Pflag1 + Nflag1 + Cflag1 + Xflag1

	local Mflag2
	if Mask == nil then
		Mflag2 = 0
		Mask = 0
	else
		--Mflag2 = 64 (Rflag2)
		Mflag2 = 0x80
	end

	local ExSetCtrig1X = Action(Mask,Index1,Rflag1,0,Address1/4,Value,0,0x5,Type,0x14+Mflag2) -- (PauseGame = 0x5)
	return ExSetCtrig1X
end

function SetCtrig2X(Offset,Type,Player2,Index2,Address2,EPD2,Next2,Mask)
	if Player2 == "X" then 
		Player2 = nil
	end
	if Index2 == "X" then 
		Index2 = nil
	end
	if Next2 == "X" then 
		Next2 = nil
	end
	if EPD2 == "X" then
		EPD2 = nil
	end
	if Mask == "X" then 
		Mask = nil
	end

	local Pflag2
	if Player2 == nil then
		Pflag2 = 0
	else
		if Player2 >= 0 and Player2 <= 7 then
			Pflag2 = Player2 + 1
		else
			Pflag2 = 0
		end
	end

	local Nflag2
	if Next2 == 0 or Next2 == nil then
		Nflag2 = 0
	elseif Next2 == 1 then 
		Nflag2 = 16
	else
		Nflag2 = 0
		Address2 = Address2 + 0x970*Next2
	end

	local Mflag2
	if Mask == nil then
		Mflag2 = 0
		Mask = 0
	else
		--Mflag2 = 64 (Rflag2)
		Mflag2 = 0x80
	end

	local Addr2
	if EPD2 == 0 or EPD2 == nil then
		Addr2 = Address2
		Eflag2 = 0
	else
		Addr2 = Address2/4
		Eflag2 = 32
	end

	local Cflag2
	if Index2 == nil then
		Index2 = 0
		Cflag2 = 128
	else
		Cflag2 = 0
	end

	local Xflag2 = 0
	if Index2 >= 0x10000 then
		Index2 = Index2 - 0x10000
		Xflag2 = 128
	end

	local Rflag1
	Rflag1 = Xflag2
	local Rflag2
	Rflag2 = Pflag2 + Nflag2 + Eflag2 + Cflag2

	local Offset2
	if Offset == "Cp" then
		Offset2 = 13
	else
		Offset2 = EPD(Offset)
	end

	local ExSetCtrig2X = Action(Mask,0,Rflag1,Rflag2,Offset2,Addr2,Index2,0x5,Type,0x14+Mflag2) -- (PauseGame = 0x5)
	return ExSetCtrig2X
end

-- 오류 체크 기본 함수 ------------------------------------------------------------------
function __SetFuncAlloc(Start,End)
	FuncAlloc = Start
	FuncAllocLimit = End
end

function __SetIndexAlloc(Start,End)
	IndexAlloc = Start
	IndexAllocLimit = End
end

function __SetJumpAlloc(Start,End)
	JumpStartAlloc = Start
	JumpEndAlloc = End
end

function __SetCreateVarIndex(Init,Max,Ccode,NCode)
	CreateVarInitIndex = Init
	CreateVarXAlloc = Init-1
	CreateMaxVAlloc = Max
	CreateCCodeVarXAlloc = Max-Ccode
	CreateNCodeVarXAlloc = Max-NCode-Ccode
end

function __SetVoidArea(Start,End)
	VoidAreaOffset = Start
	VoidAreaAlloc = Start-4
	VoidAreaLimit = End
end

function __SetFlagAlloc(Start,End)
	FlagAllocBase = Start
	FlagAllocLimit = End
end

function __SetCAPlotJumpAlloc(Start,End)
	CAPlotJumpAlloc = Start
	CAPlotJumpLimit = End
end

function __SetCAPlotVarAlloc(Start,End)
	CAPlotVarAlloc = Start
	CAPlotVarLimit = End
end

function __SetCAPrintVarAlloc(Start,End)
	CAPrintVarAlloc = Start
	CAPrintVarLimit = End
end

function ErrorCheck() -- Ctrig 문법 오류 점검 함수
	--AllocCheck() 기본적용됨
	LabelCheck()
	ControlCheck()
end

function AllocCheck()
	if IndexAlloc >= IndexAllocLimit then
		IndexAllocation_Overflow()
	end
	if FuncAlloc >= FuncAllocLimit then
		FuncAllocation_Overflow()
	end
	if FlagAlloc >= (FlagAllocLimit-FlagAllocBase)*480 then
		FlagAllocation_Overflow()
	end
	if VoidAreaAlloc >= VoidAreaLimit then
		VoidAllocation_Overflow()
	end
	if CAPlotJumpAlloc >= CAPlotJumpLimit then
		CAPlotJumpAllocation_Overflow()
	end
	if MAXVAlloc >= 0xFFE0 then
		VarXAllocation_Overflow()
	end
	if MAXWAlloc >= 0xFDF0 then
		WarXAllocation_Overflow()
	end
	for j = 1, 32 do
		if MAXSVAlloc[j] >= SVarXOrig[j] + 0x3C then
			SVarXAllocation_Overflow()
		end
	end
end

function LabelCheck() -- Label 중복 체크
	local C = {}
	for k,v in pairs(LabelArr) do
		if v ~= 0xFFE0 then
			if not C[v] then
				C[v] = true
			else
				if v < JumpStartAlloc or v >= JumpEndAlloc + (JumpEndAlloc-JumpStartAlloc) then
					_G["Label_duplicated! Current Label : 0x"..string.format("%X",v)]() -- push error msg
				else
					_G["sIndex_duplicated! Current sIndex : 0x"..string.format("%X",v%(JumpEndAlloc-JumpStartAlloc))]() -- push error msg
				end
			end
		else
			Prohibited_Label()
		end
	end
end

function ControlCheck() -- 제어문 입력 오류 체크
	local C
	C = {}
	for i,key in pairs(CJumpEndArr) do C[key] = true end
	for i,key in pairs(CJumpArr) do if not C[key] then CJumppair_missing() end end
	C = {}
	for i,key in pairs(NJumpEndArr) do C[key] = true end
	for i,key in pairs(NJumpArr) do if not C[key] then NJumppair_missing() end end

	for k, v in pairs(CIfArr) do
		if v ~= nil then
			CIfpair_missing()
		end
	end
	for k, v in pairs(NIfArr) do
		if v ~= nil then
			NIfpair_missing()
		end
	end
	for k, v in pairs(CWhileArr) do
		if v ~= nil then
			CWhilepair_missing()
		end
	end
	for k, v in pairs(NWhileArr) do
		if v ~= nil then
			NWhilepair_missing()
		end
	end
	for k, v in pairs(DWhileArr) do
		if v ~= nil then
			DoWhilepair_missing()
		end
	end
	for k, v in pairs(CForArr) do
		if v ~= nil then
			CForpair_missing()
		end
	end
	for k, v in pairs(CIfXArr) do
		if v ~= nil then
			CIfXpair_missing()
		end
	end
	for k, v in pairs(NIfXArr) do
		if v ~= nil then
			NIfXpair_missing()
		end
	end
	for k, v in pairs(CWhileXArr) do
		if v ~= nil then
			CWhileXpair_missing()
		end
	end
	for k, v in pairs(NWhileXArr) do
		if v ~= nil then
			NWhileXpair_missing()
		end
	end
	for k, v in pairs(NForArr) do
		if v ~= nil then
			NForpair_missing()
		end
	end
	for k, v in pairs(SLoopNArr) do
		if v ~= nil then
			SLoopNpair_missing()
		end
	end
	for k, v in pairs(CFuncArr) do
		if v ~= nil then
			CFuncArrpair_missing()
		end
	end
end

-- 표준 입출력 및 변환 함수 -------------------------------------------------------------

function CAddr(Section,Line,Next) -- Convert (Data -> Mem_Address)
	if Line == "X" or Line == nil then
		Line = 1
	end
	Line = Line - 1
	local Offset

	if Section == "Prev" then
		Offset = 0
	end
	if Section == "Next" then
		Offset = 0x4
	end
	if Section == "Internal" then
		Offset = 0x948
	end

	if Section == "CMask" then
		Offset = 0x0
		Offset = Offset + 0x14 * Line + 0x8
	end
	if Section == "CEPD" then
		Offset = 0x4
		Offset = Offset + 0x14 * Line + 0x8
	end
	if Section == "CType" then
		Offset = 0xC
		Offset = Offset + 0x14 * Line + 0x8
	end
	if Section == "CValue" then
		Offset = 0x8
		Offset = Offset + 0x14 * Line + 0x8
	end
	if Section == "CFlag" then
		Offset = 0x10
		Offset = Offset + 0x14 * Line + 0x8
	end

	if Section == "Mask" then
		Offset = 0x0
		Offset = Offset + 0x20 * Line + 0x148
	end
	if Section == "Str" then
		Offset = 0x4
		Offset = Offset + 0x20 * Line + 0x148
	end
	if Section == "Wav" then
		Offset = 0x8
		Offset = Offset + 0x20 * Line + 0x148
	end
	if Section == "Time" then
		Offset = 0xC
		Offset = Offset + 0x20 * Line + 0x148
	end
	if Section == "EPD" then
		Offset = 0x10
		Offset = Offset + 0x20 * Line + 0x148
	end
	if Section == "Type" then
		Offset = 0x18
		Offset = Offset + 0x20 * Line + 0x148
	end
	if Section == "Value" then
		Offset = 0x14
		Offset = Offset + 0x20 * Line + 0x148
	end
	if Section == "Flag" then
		Offset = 0x1C
		Offset = Offset + 0x20 * Line + 0x148
	end

	if Next == nil or Next == "X" then
		Next = 0
	end

	local CAddress = Next * 0x970 + Offset
	return CAddress
end

function DtoA(Player,UnitId) -- Convert(Deaths -> OffSet)
 	local DtoA = 0x58A364 + 0x30 * ParseUnit(UnitId) + 0x4 * Player
 	return DtoA
end 

-- CIf : 2 / NIf : 3 / CWhile : 3 / NWhile : 4 / DoWhile : 2 / CFor : 4 / CIfX : 1* / NIfX : 1*
function Forward(Move) -- Return(Struct_Index)
	if Move == nil then
		Move = 0
	end
	local Forward = IndexAlloc + Move
	return Forward
end

function Struct(Type,Number) -- Convert(Data -> Forward_Move)
	local Struct
	if Type == "CIfX" or Type == "NIfX" then
		Struct = Number	* 2	
	elseif Type == "CIf" or Type == "DoWhile" then
		Struct = Number * 2
	elseif Type == "CWhile" or Type == "NIf" then
		Struct = Number * 3
	elseif Type == "NWhile" or Type == "CFor" then
		Struct = Number * 4
	end
	return Struct
end

function Ccode(Index,Line) -- Convert(Data -> N/CDeaths_Code)
	local Ccode = Line*0x100000 + Index
	return Ccode
end

-- "X" -> nil
-- Number -> Return(Constant Data) --
-- "Cp" -> Return(CurrentPlayer Data)

function V(Index,Player,Next) -- Return(Variable Data)
	if Player == nil then
		Player = "X"
	end
	return {Player,Index,Next,"V"}
end

function Vi(Index,Deviation,Player,Next) -- Return(Variable Data+) : T,TT Cond/Act 전용 / SetRecoverCp / Arr,VArr
	if Deviation == "X" or Deviation == nil then
		Deviation = 0
	end
	if Player == nil then
		Player = "X"
	end
	return {Player,Index,Next,"V",Deviation}
end

function W(Index,Player,Next) -- Return(Wariable Data)
	if Player == nil then
		Player = "X"
	end
	return {Player,Index,Next,"W"}
end

function Wi(Index,Deviation,Player,Next) -- Return(Wariable Data+) : T,TT Cond/Act 전용 
	if Deviation == "X" or Deviation == nil then
		Deviation = 0
	end
	if Player == nil then
		Player = "X"
	end
	return {Player,Index,Next,"W",Deviation}
end

function SV(SVariable,Line,Player,Next) -- Return(SVariable Data)
	if SVariable[1] ~= "S" then
		SV_InputData_Error()
	end
	if Player == nil then
		Player = "X"
	end
	return {Player,SVariable[2],Next,"SV",SVariable[3],Line}
end

function X(Lua_Variable) -- Convert(Lua_Var -> Return(Variable Data))
	return {Lua_Variable[1],Lua_Variable[2],Lua_Variable[3],"V"}
end

function Mem(Player,Index,Address,Next,EPDflag) -- Return(Ctrig Memory Data)
	if Player == nil then
		Player = "X"
	end
	if EPDflag == "X" or EPDflag == nil or EPDflag == 0 then
		EPDflag = nil
	else
		EPDflag = 1
	end

	if Address == "X" or Address == nil then
		Address = 0
	end
	return {Player,Index,Address,Next,EPDflag}
end

function _Mem(Variable,Address,Next,EPDflag) -- Convert(Variable Data -> Ctrig Memory Data)
	if Variable[3] == nil then
		Variable[3] = 0
	end
	if EPDflag == "X" or EPDflag == nil or EPDflag == 0 then
		EPDflag = nil
	else
		EPDflag = 1
	end
	if Variable[4] ~= "V" then
		_Mem_InputData_Error()
	end
	if Address == "X" or Address == nil then
		Address = 0x15C
	end
	if Next == "X" or Next == nil then
		Next = 0
	end
	return {Variable[1],Variable[2],Address,Variable[3]+Next,EPDflag}
end

function LMem(Player,Index,Address,Next,EPDflag) -- Return(Ctrig Memory Data)

	if Player == nil then
		Player = {"X","X"}
	elseif type(Player) ~= "table" then
		Player = {Player,Player}
	end
	if EPDflag == "X" or EPDflag == nil or EPDflag == 0 then
		EPDflag = nil
	else
		EPDflag = 1
	end
	if type(Index) ~= "table" then
		Index = {Index,Index}
	end
	if type(Next) ~= "table" then
		Next = {Next,Next}
	end
	if type(Address) ~= "table" then
		Address = {Address,Address}
	end
	if Address[1] == "X" or Address[1] == nil then
		Address[1] = 0
	end
	if Address[2] == "X" or Address[2] == nil then
		Address[2] = 0
	end
	return {{Player[1],Index[1],Address[1],Next[1],EPDflag},{Player[2],Index[2],Address[2],Next[2],EPDflag}}
end

function _LMem(Wariable,Address,Next,EPDflag) -- Convert(Wariable Data -> Ctrig Memory Data)
	local Check 
	if Wariable[3] == nil then
		Wariable[3] = 0
	end
	if EPDflag == "X" or EPDflag == nil or EPDflag == 0 then
		EPDflag = nil
	else
		EPDflag = 1
	end
	if Wariable[4] ~= "W" then
		_LMem_InputData_Error()
	end
	if Address == "X" or Address == nil then
		Address = {0x15C,0x19C}
	elseif type(Address) == "number" then
		Check = 0
	elseif type(Address) == "table" and type(Address[2]) == "table" then
		Check = 1
	end
	if Next == "X" or Next == nil then
		Next = 0
	end
	if Check == 0 then
		return {Wariable[1],Wariable[2],Address,Wariable[3]+Next,EPDflag}
	elseif Check == 1 then
		return {{Wariable[1],Wariable[2],Address[1],Wariable[3]+Next,EPDflag},{Wariable[1],Wariable[2],Address[1]+Address[2][1],Wariable[3]+Next,EPDflag}}
	else 
		return {{Wariable[1],Wariable[2],Address[1],Wariable[3]+Next,EPDflag},{Wariable[1],Wariable[2],Address[2],Wariable[3]+Next,EPDflag}}
	end
end

function _SMem(SVData,Address,Next,EPDflag) -- Convert(SVData -> Ctrig Memory Data)
	local Box = {}
	local Check
	local Line = SVData[6]
	local Number = SVData[5]
	if Next == nil or "X" then
		Next = 0
	end
	if Line == "X" then
		Line = nil
	end
	if SVData[3] == nil then
		SVData[3] = 0
	end
	if EPDflag == "X" or EPDflag == nil or EPDflag == 0 then
		EPDflag = nil
	else
		EPDflag = 1
	end
	if SVData[4] ~= "SV" then
		_SMem_InputData_Error()
	end
	if Address == "X" or Address == nil then
		Check = 1
		if type(Line) == "number" then
			Box = {SVData[1],SVData[2],0x15C+0x40*(Line-1),SVData[3]+Next,EPDflag}
		elseif Line == nil then
			for i = 1, Number do
				table.insert(Box,{SVData[1],SVData[2],0x15C+0x40*(i-1),SVData[3]+Next,EPDflag})
			end
		else
			for k, v in pairs(Line) do
				table.insert(Box,{SVData[1],SVData[2],0x15C+0x40*(v-1),SVData[3]+Next,EPDflag})
			end
		end
	elseif type(Address) == "number" then
		Check = 0
		if type(Line) == "number" then
			if Address >= 0x148 and Address <= 0x164 then
				Address = Address + (Line-1)*0x40
			end
		end
	elseif type(Address) == "table" and type(Address[2]) == "table" then
		Check = 1
		local Distance = Address[2][1]
		if type(Line) == "number" then
				Box = {SVData[1],SVData[2],Address[1]+Distance*(Line-1),SVData[3]+Next,EPDflag}
		elseif Line == nil then
			for i = 1, Number do
				table.insert(Box,{SVData[1],SVData[2],Address[1]+Distance*(i-1),SVData[3]+Next,EPDflag})
			end
		else
			for k, v in pairs(Line) do
				table.insert(Box,{SVData[1],SVData[2],Address[1]+Distance*(v-1),SVData[3]+Next,EPDflag})
			end
		end
	end
	
	if Check == 0 then
		return {SVData[1],SVData[2],Address,SVData[3]+Next,EPDflag}
	elseif Check == 1 then
		return Box
	end
end

function Arr(Array,Index,Player) -- 1, V, _Mov(VArr()) 사용
	if type(Player) == "table" then
		Arr_InputData_Error()
	end
	if Player == nil then
		Player = "X"
	else
		Array[1] = Player
	end

	if type(Index) == "number" then
		return {Player,Array[2],(Index+(math.floor(Index/602))*2)*4,0}
	elseif Index[4] == "V" then
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"A",Array}

		if Index[5] == nil then
			Index[5]= 0
		end

		table.insert(STPushTrigArr,{"ConvertArr",{"X",Temp,0,"V"},Index})

		VarXAlloc = VarXAlloc + 1
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TempData
	else
		Arr_InputData_Error()
	end
end

function ArrX(Array,Index,Player) -- 1, V, _Mov(VArr()) 사용
	if type(Player) == "table" then
		ArrX_InputData_Error()
	end
	if Player == nil then
		Player = "X"
	else
		Array[1] = Player
	end

	if type(Index) == "number" then
		return {Player,Array[2],(Index+(math.floor(Index/602))*2)*4,0}
	elseif Index[4] == "V" then
		return {Index[1],Index[2],Index[3],"A",Array}
	else
		ArrX_InputData_Error()
	end
end

function ConvertArr(PlayerID,Dest,Source) -- V << (i+D)/301 -> V SetTo 0 0x1 -> V += Arr
	-- Dest = TempV, Source = Index, Operand = Arr / V << V 전용
	STPopTrigArr(PlayerID)
	if Source[4] == "VA" or Dest[4] == "VA" then
		ConvertArr_InputData_Error()
	end

	if Source[5] == nil then
		Source[5] = 0
	end
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0);
			SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Source[5]);
			SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
			SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
			SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
			CallLabelAlways(Source[1],Source[2],Source[3]);
		},
		flag = {Preserved}
	}

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(FuncAlloc);
			CtrigX("X",CRet[1],0x15C,0,AtMost,601);
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+1,0,0,0);
		},
		flag = {Preserved}
	}

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
			--CtrigX("X",CRet[1],0x15C,0,AtLeast,602);
			CtrigX("X",CRet[1],0x15C,0,AtMost,1203); 
		},
		actions = {
			SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,2);
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+1,0,0,0);
		},
		flag = {Preserved}
	}

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
			--CtrigX("X",CRet[1],0x15C,0,AtLeast,1204);
			CtrigX("X",CRet[1],0x15C,0,AtMost,1805); 
		},
		actions = {
			SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,4);
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+1,0,0,0);
		},
		flag = {Preserved}
	}

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
			--CtrigX("X",CRet[1],0x15C,0,AtLeast,1806);
			CtrigX("X",CRet[1],0x15C,0,AtMost,2407); 
		},
		actions = {
			SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,6);
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+1,0,0,0);
		},
		flag = {Preserved}
	}

	for i = 22, 0, -1 do
		local CBit = 2^i
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,602*CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,602*CBit);
					SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,2*CBit);
				},
				flag = {Preserved}
			}
	end

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(FuncAlloc+1);
		},
		actions = {
			SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0,0,1);
			SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0,0,2);
			SetCtrigX("X",FuncAlloc,0x4,2,SetTo,"X",FuncAlloc,0,0,3);
			SetCtrigX("X",FuncAlloc,0x4,3,SetTo,"X",FuncAlloc,0,0,4);
			SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[5]);
			SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
			SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
			SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
			CallLabelAlways(Source[1],Source[2],Source[3]);
		},
		flag = {Preserved}
	}
	FuncAlloc = FuncAlloc + 2
end

function LArr(LArray,Index,Player) -- 1, V, _Mov(VArr()) 사용 : Output Mem, {Mem,Mem+1}, A, {A,A}, LA[V], LA[W] 
	local Mode = 0
	if #LArray == 1 then
		Mode = 8
		LArray = LArray[1]
	end
	if #LArray == 2 then
		if LArray[2] == 0 then
			Mode = 0
			LArray = LArray[1]
		elseif LArray[2] == 1 then
			Mode = 1
			LArray = LArray[1]
		elseif LArray[2] == 8 then
			Mode = 8
			LArray = LArray[1]
		else
			LArr_Mode_Error()
		end
	end

	if type(Player) == "table" then
		LArr_InputData_Error()
	end

	if Player == nil then
		Player = "X"
	else
		LArray[1] = Player
	end

	if Mode == 8 then -- Mode 8bytes
		if type(Index) == "number" then -- {Mem,Mem}
			return {{Player,LArray[2],math.floor(Index)*0x10,0},{Player,LArray[2],math.floor(Index)*0x10+0x4,0}}
		elseif Index[4] == "V" then -- LA[V]
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"LA_V",LArray}

			if Index[5] == nil then
				Index[5]= 0
			end

			table.insert(STPushTrigArr,{"ConvertLArr",{"X",Temp,0,"V"},Index,Mode})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			return TempData
		elseif Index[4] == "W" then -- LA[W]
			local Temp = WarXAlloc
			local TempData = {"X",Temp,0,"LA_W",LArray}

			if Index[5] == nil then
				Index[5]= 0
			end

			table.insert(STPushTrigArr,{"ConvertLArr",{"X",Temp,0,"W"},Index,Mode})

			WarXAlloc = WarXAlloc + 1
			if WarXAlloc > MAXWAlloc then
				MAXWAlloc = WarXAlloc
			end
			return TempData
 		else
			LArr_InputData_Error()
		end
	else -- Mode 4bytes (0/1)
		if type(Index) == "number" then -- Mem
			if Mode == 0 then
				return {Player,LArray[2],math.floor(Index)*0x10,0}
			elseif Mode == 1 then
				return {Player,LArray[2],math.floor(Index)*0x10+0x4,0}
			end
		elseif Index[4] == "V" then -- A
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"A",LArray}

			if Index[5] == nil then
				Index[5]= 0
			end

			table.insert(STPushTrigArr,{"ConvertLArr",{"X",Temp,0,"V"},Index,Mode})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			return TempData
		else
			LArr_InputData_Error()
		end
	end
end

function LArrX(LArray,Index,Player) -- 1, V, _Mov(VArr()) 사용
	local Mode = 0
	if #LArray == 1 then
		Mode = 8
		LArray = LArray[1]
	end
	if #LArray == 2 then
		if LArray[2] == 0 then
			Mode = 0
			LArray = LArray[1]
		elseif LArray[2] == 1 then
			Mode = 1
			LArray = LArray[1]
		elseif LArray[2] == 8 then
			Mode = 8
			LArray = LArray[1]
		else
			LArrX_Mode_Error()
		end
	end

	if type(Player) == "table" then
		LArrX_InputData_Error()
	end

	if Player == nil then
		Player = "X"
	else
		LArray[1] = Player
	end

	if Mode == 8 then -- Mode 8bytes
		if type(Index) == "number" then -- {Mem,Mem}
			return {{Player,LArray[2],math.floor(Index)*0x10,0},{Player,LArray[2],math.floor(Index)*0x10+0x4,0}}
		elseif Index[4] == "V" then -- LA[V]
			if Index[5] == nil then
				LArray[3] = 0
			else 
				LArray[3] = Index[5]*0x10
			end
			return {Index[1],Index[2],Index[3],"LA_V",LArray}
		elseif Index[4] == "W" then -- LA[W]
			if Index[5] == nil then
				LArray[3] = 0
			else 
				LArray[3] = Index[5]*0x10
			end
			return {Index[1],Index[2],Index[3],"LA_W",LArray}
		else
			LArr_InputData_Error()
		end
	else -- Mode 4bytes (0/1)
		if type(Index) == "number" then -- Mem
			if Mode == 0 then
				return {Player,LArray[2],math.floor(Index)*0x10,0}
			elseif Mode == 1 then
				return {Player,LArray[2],math.floor(Index)*0x10+0x4,0}
			end
		elseif Index[4] == "V" then -- A
			if Index[5] == nil then
				LArray[3] = 0
			else 
				LArray[3] = Index[5]*0x10
			end
			if Mode == 0 then
				return {Index[1],Index[2],Index[3],"A",LArray}
			elseif Mode == 1 then
				LArray[3] = LArray[3] + 0x4
				return {Index[1],Index[2],Index[3],"A",LArray}
			end
		else
			LArrX_InputData_Error()
		end
	end
end

function ConvertLArr(PlayerID,Dest,Source,Mode) -- V << (i+D)/301 -> V SetTo 0 0x1 -> V += Arr
	-- Dest = TempV, Source = Index, Operand = Arr / V << V 전용
	STPopTrigArr(PlayerID)
	if not((Dest[4] == "V" and Source[4] == "V") or (Dest[4] == "W" and Source[4] == "W")) then
		ConvertLArr_InputData_Error()
	end

	if Source[5] == nil then
		Source[5] = 0
	end

	if Mode == 0 or Mode == 1 then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
				SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
				SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
				SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
				SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}
		if Mode == 0 then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[5]*4);
				},
				flag = {Preserved}
			}
		elseif Mode == 1 then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[5]*4+1);
				},
				flag = {Preserved}
			}
		end
	elseif Mode == 8 then
		if Dest[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
					SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
					SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
					SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[5]*4);
				},
				flag = {Preserved}
			}
		elseif Dest[4] == "W" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
					SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
					SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
					SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
					SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[5]*4);
					SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],Add,Source[5]*4);
				},
				flag = {Preserved}
			}
		end
	else
		ConvertLArr_InputData_Error()
	end
end

function GetVArray(Header,Size)
	return {"X",Header[2],Header[3],"V",0,Size}
end

function VArr(VArray,Index,Player) -- 1, V, _Mov(VArr()) 사용
	if type(Player) == "table" then
		VArr_InputData_Error()
	end
	if Player == nil then
		Player = "X"
	else
		VArray[1] = Player
	end
	
	if VArray[3] == nil or VArray[3] == "X" then
		VArray[3] = 0
	end

	if type(Index) == "number" then
		return {Player,VArray[2],Index+VArray[3],"V"}
	elseif Index[4] == "V" then
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"VA",VArray,0,"X",Temp+1,0}

		if Index[5] == nil then
			Index[5] = 0
		end
		
		table.insert(STPushTrigArr,{"ConvertVArr",{"X",Temp,0,"V"},{"X",Temp+1,0,"V"},Index,VArray[6]}) 

		VarXAlloc = VarXAlloc + 2
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TempData
	else
		VArr_InputData_Error()
	end
end

function VArrX(VArray,Index,Index4,Player) -- 1, V, _Mov(VArr()) 사용
	if type(Player) == "table" then
		VArrX_InputData_Error()
	end
	if Player == nil then
		Player = "X"
	else
		VArray[1] = Player
	end

	if VArray[3] == nil or VArray[3] == "X" then
		VArray[3] = 0
	end

	if type(Index) == "number" then
		return {Player,VArray[2],Index+VArray[3],"V"}
	elseif Index[4] == "V" and Index4[4] == "V" then
		if Index[5] == nil then
			Index[5] = 0
		end
		return {Index[1],Index[2],Index[3],"VA",VArray,Index[5]*604,Index4[1],Index4[2],Index4[3]}
	else
		VArrX_InputData_Error()
	end
end

function ConvertVArr(PlayerID,Dest,Dest4,Source,Size) -- V << (i+D) * 604 -> V += Arr
	-- Dest = TempV, Source = Index, Operand = Arr / V << V 전용
	STPopTrigArr(PlayerID)
	if Source[4] == "VA" or Dest[4] == "VA" or Dest4[4] == "VA" then
		ConvertVArr_InputData_Error()
	end

	if Source[5] == nil then
		Source[5] = 0
	end

	if Size == nil then
		Size = 4095
	end

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5]*604);
			SetCtrig1X(Dest4[1],Dest4[2],0x15C,Dest4[3],SetTo,Source[5]*2416);
		},
		flag = {Preserved}
	}

	for i = 0, 11 do
		local CBit = 2^i
		if Size >= CBit then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,CBit,CBit);
				},
				actions = {
					SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit*604);
					SetCtrig1X(Dest4[1],Dest4[2],0x15C,Dest4[3],Add,CBit*2416);
				},
				flag = {Preserved}
			}
		end
	end
end

function GetSVArray(Header,Size)
	return {"X",Header[2],0,"SA",Header[3],Size}
end

function SVArr(SVArray,Index,Line,Player) -- 1, V, _Mov(VArr()) 사용
	if SVArray[4] ~= "SA" then 
		SVArr_InputData_Error()
	end
	if type(Player) == "table" then
		SVArr_InputData_Error()
	end
	if Player == nil then
		Player = "X"
	else
		SVArray[1] = Player
	end
	
	if SVArray[3] == nil or SVArray[3] == "X" then
		SVArray[3] = 0
	end

	if type(Index) == "number" then
		return {Player,SVArray[2],Index+SVArray[3],"SV",SVArray[5],Line}
	elseif Index[4] == "V" then -- SV[V] 만 허용
		local SVArrayX = {SVArray[1],SVArray[2],SVArray[3],SVArray[4],SVArray[5],SVArray[6],Line}
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"SVA",SVArrayX,0,"X",Temp+1,0} -- << {"X",Index,0,"SA",Number,Size,Line}

		if Index[5] == nil then
			Index[5] = 0
		end
		
		table.insert(STPushTrigArr,{"ConvertSVArr",{"X",Temp,0,"V"},{"X",Temp+1,0,"V"},Index,SVArray[6]}) 

		VarXAlloc = VarXAlloc + 2
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TempData
	else
		SVArr_InputData_Error()
	end
end

function SVArrX(SVArray,Index,Index4,Line,Player) -- 1, V, _Mov(VArr()) 사용
	if SVArray[4] ~= "SA" then 
		SVArr_InputData_Error()
	end
	if type(Player) == "table" then
		SVArrX_InputData_Error()
	end
	if Player == nil then
		Player = "X"
	else
		SVArray[1] = Player
	end

	if SVArray[3] == nil or SVArray[3] == "X" then
		SVArray[3] = 0
	end

	if type(Index) == "number" then
		return {Player,SVArray[2],Index+SVArray[3],"SV",SVArray[5],Line}
	elseif Index[4] == "V" and Index4[4] == "V" then
		local SVArrayX = {SVArray[1],SVArray[2],SVArray[3],SVArray[4],SVArray[5],SVArray[6],Line}
		if Index[5] == nil then
			Index[5] = 0
		end
		return {Index[1],Index[2],Index[3],"SVA",SVArrayX,Index[5]*604,Index4[1],Index4[2],Index4[3]}
	else
		SVArrX_InputData_Error()
	end
end

function ConvertSVArr(PlayerID,Dest,Dest4,Source,Size) -- V << (i+D) * 604 -> V += Arr
	-- Dest = TempV, Source = Index, Operand = Arr / V << V 전용
	STPopTrigArr(PlayerID)
	if Source[4] == "VA" or Dest[4] == "VA" or Dest4[4] == "VA" then
		ConvertSVArr_InputData_Error()
	end

	if Source[5] == nil then
		Source[5] = 0
	end

	if Size == nil then
		Size = 4095
	end

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5]*604);
			SetCtrig1X(Dest4[1],Dest4[2],0x15C,Dest4[3],SetTo,Source[5]*2416);
		},
		flag = {Preserved}
	}

	for i = 0, 11 do
		local CBit = 2^i
		if Size >= CBit then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,CBit,CBit);
				},
				actions = {
					SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit*604);
					SetCtrig1X(Dest4[1],Dest4[2],0x15C,Dest4[3],Add,CBit*2416);
				},
				flag = {Preserved}
			}
		end
	end
end

function GetWArray(Header,Size)
	return {"X",Header[2],Header[3],"W",0,Size}
end

function WArr(WArray,Index,Player) -- 1, W, _Mov(WArr()) 사용 : Output = W/WA[V]/WA[W]
	if type(Player) == "table" then
		WArr_InputData_Error()
	end
	if Player == nil then
		Player = "X"
	else
		WArray[1] = Player
	end

	if WArray[3] == nil or WArray[3] == "X" then
		WArray[3] = 0
	end
	
	if type(Index) == "number" then
		return {Player,WArray[2],Index+WArray[3],"W"}
	elseif Index[4] == "V" then
		local Temp = WarXAlloc
		local TempData = {"X",Temp,0,"WA",WArray,0,"X",Temp+1,0}

		if Index[5] == nil then
			Index[5] = 0
		end
		
		table.insert(STPushTrigArr,{"ConvertWArr",{"X",Temp,0,"W"},{"X",Temp+1,0,"W"},Index,WArray[6]}) 

		WarXAlloc = WarXAlloc + 2
		if WarXAlloc > MAXWAlloc then
			MAXWAlloc = WarXAlloc
		end
		return TempData
	elseif Index[4] == "W" then
		local Temp = WarXAlloc
		local TempData = {"X",Temp,0,"WA",WArray,0,"X",Temp+1,0}

		if Index[5] == nil then
			Index[5] = 0
		end
		
		table.insert(STPushTrigArr,{"ConvertWArr",{"X",Temp,0,"W"},{"X",Temp+1,0,"W"},Index,WArray[6]}) 

		WarXAlloc = WarXAlloc + 2
		if WarXAlloc > MAXWAlloc then
			MAXWAlloc = WarXAlloc
		end
		return TempData
	else
		WArr_InputData_Error()
	end
end

function WArrX(WArray,Index,Index4,Player) -- 1, V, _Mov(VArr()) 사용
	if type(Player) == "table" then
		WArrX_InputData_Error()
	end
	if Player == nil then
		Player = "X"
	else
		WArray[1] = Player
	end

	if WArray[3] == nil or WArray[3] == "X" then
		WArray[3] = 0
	end

	if type(Index) == "number" then
		return {Player,WArray[2],Index+WArray[3],"W"}
	elseif Index[4] == "W" and Index4[4] == "W" then
		if Index[5] == nil then
			Index[5] = 0
		end
		return {Index[1],Index[2],Index[3],"WA",WArray,Index[5]*604,Index4[1],Index4[2],Index4[3]}
	else
		WArrX_InputData_Error()
	end
end

function ConvertWArr(PlayerID,Dest,Dest4,Source,Size) -- V << (i+D) * 604 -> V += Arr
	-- Dest = TempV, Source = Index, Operand = Arr / V << V 전용
	STPopTrigArr(PlayerID)
	if Source[4] ~= "W" and Source[4] ~= "V" then
		ConvertWArr_InputData_Error()
	end
	if Dest[4] ~= "W" or Dest4[4] ~= "W" then
		ConvertWArr_InputData_Error()
	end

	if Source[5] == nil then
		Source[5] = 0
	end

	if Size == nil then
		Size = 4095
	end

	if Source[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5]*604);
				SetCtrig1X(Dest4[1],Dest4[2],0x15C,Dest4[3],SetTo,Source[5]*2416);
				SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5]*604);
				SetCtrig1X(Dest4[1],Dest4[2],0x19C,Dest4[3],SetTo,Source[5]*2416);
			},
			flag = {Preserved}
		}

		for i = 0, 11 do
			local CBit = 2^i
			if Size >= CBit then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,CBit,CBit);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit*604);
						SetCtrig1X(Dest4[1],Dest4[2],0x15C,Dest4[3],Add,CBit*2416);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],Add,CBit*604);
						SetCtrig1X(Dest4[1],Dest4[2],0x19C,Dest4[3],Add,CBit*2416);
					},
					flag = {Preserved}
				}
			end
		end
	elseif Source[4] == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5]*604);
				SetCtrig1X(Dest4[1],Dest4[2],0x15C,Dest4[3],SetTo,Source[5]*2416);
				SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5]*604);
				SetCtrig1X(Dest4[1],Dest4[2],0x19C,Dest4[3],SetTo,Source[5]*2416);
			},
			flag = {Preserved}
		}

		for i = 0, 11 do
			local CBit = 2^i
			if Size >= CBit then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,CBit,CBit); -- Index W = {index,index} 
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit*604);
						SetCtrig1X(Dest4[1],Dest4[2],0x15C,Dest4[3],Add,CBit*2416);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],Add,CBit*604);
						SetCtrig1X(Dest4[1],Dest4[2],0x19C,Dest4[3],Add,CBit*2416);
					},
					flag = {Preserved}
				}
			end
		end
	end
end

function MovX(PlayerID,Dest,Source,Mode,Mask,Clear) -- V << VA / VA,A << V (Value) / 내부함수 (사용 권장X)
	--STPopTrigArr(PlayerID)
	if Mode == "X" or Mode == nil then
		Mode = SetTo
	end
	if Mask == "X" or Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local Mask2 = Mask
	if Clear == 1 then
		Mask2 = 0xFFFFFFFF
	end

	local Box0 = {}
	if type(Dest) == "number" and Source[4] == "VA" then -- Mov Offset, VA / {Index[1],Index[2],Index[3],"VA",VArray(VAPlayer,VAIndex,0),Index[5]}
		Trigger {--(CPRead)로 값 출력
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

					SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
					SetMemory(0x6509B0,Add,Source[6]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
					CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetDeaths(CurrentPlayer,SetTo,EPD(Dest),0); -- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);

				},
				flag = {Preserved}
			}

		RecoverCp(PlayerID)
	elseif Dest[4] == "V" and Source[4] == "VA" then -- Mov V, VA / {Index[1],Index[2],Index[3],"VA",VArray(VAPlayer,VAIndex,0),Index[5]}
		if Clear == 1 then
			table.insert(Box0,SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0,Mask2))
		end

		Trigger {--(CPRead)로 값 출력
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					Box0,
					SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

					SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
					SetMemory(0x6509B0,Add,Source[6]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
					CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);

				},
				flag = {Preserved}
			}

		RecoverCp(PlayerID)

		-- Ctrig->Ctrig->Ctrig Version : Cp사용 X
		--[[
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x158,3,SetTo,Source[5][1],Source[5][2],0x158,1,Source[5][3]); 
					SetCtrigX("X","X",0x17C,3,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrigX("X","X",0x198,3,SetTo,Source[5][1],Source[5][2],0x4,1,Source[5][3]); 
					SetCtrig1X("X","X",0x158,3,Add,Source[6]);
					SetCtrig1X("X","X",0x17C,3,Add,Source[6]*4);
					SetCtrig1X("X","X",0x198,3,Add,Source[6]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x158,1,3); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x198,1,2); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x17C,1,1); 
					CallLabelAlways(Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0,0,Source[3]);
					SetCtrig2X(0,SetTo,"X","X",0,0,1); -- SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}
			]]--
	elseif type(Dest[4]) ~= "string" and Source[4] == "VA" then -- Mov Mem, VA / {Index[1],Index[2],Index[3],"VA",VArray(VAPlayer,VAIndex,0),Index[5]}
		Trigger {--(CPRead)로 값 출력
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

					SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
					SetMemory(0x6509B0,Add,Source[6]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
					CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);

				},
				flag = {Preserved}
			}

		RecoverCp(PlayerID)
	elseif Dest[4] == "VA" and Source[4] == "V" then -- Mov VA, V 
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],Add,Dest[6]);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
					CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	elseif Dest[4] == "A" and Source[4] == "V" then -- Mov A, V 
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
					CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	else
		MovX_InputData_Error()
	end
end

--[[
function MovY(PlayerID,Dest,Source,Mode,Mask) -- 상수,V << VA / 내부함수 (사용 권장X) CPRead 미사용 버젼
	--STPopTrigArr(PlayerID)
	if Mode == "X" or Mode == nil then
		Mode = SetTo
	end
	if Mask == "X" or Mask == nil then
		Mask = 0xFFFFFFFF
	end
	if type(Dest) == "number" and Source[4] == "VA" then -- Mov Offset, VA 
		-- Ctrig->Ctrig->Ctrig Version : Cp사용 X

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x158,5,SetTo,Source[5][1],Source[5][2],0x158,1,Source[5][3]); 
					SetCtrigX("X","X",0x17C,5,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrigX("X","X",0x198,5,SetTo,Source[5][1],Source[5][2],0x4,1,Source[5][3]); 
					SetCtrigX("X","X",0x1B8,5,SetTo,Source[5][1],Source[5][2],0x148,1,Source[5][3]); 
					SetCtrigX("X","X",0x1D8,5,SetTo,Source[5][1],Source[5][2],0x160,1,Source[5][3]); 
					SetCtrig1X("X","X",0x158,5,Add,Source[6]);
					SetCtrig1X("X","X",0x17C,5,Add,Source[6]*4);
					SetCtrig1X("X","X",0x198,5,Add,Source[6]);
					SetCtrig1X("X","X",0x1B8,5,Add,Source[6]);
					SetCtrig1X("X","X",0x1D8,5,Add,Source[6]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x158,1,5); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x198,1,4); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x1B8,1,3); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x1D8,1,2); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x17C,1,1); 
					CallLabelAlways(Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetDeaths(0,SetTo,EPD(Dest),0);	-- SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(Dest));
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0,0,Source[3]);
					SetCtrig2X(0,SetTo,"X","X",0,0,1); -- SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0,0,1);
					SetDeaths(0,SetTo,Mask,0); -- SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
					SetDeathsX(0,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
				},
				flag = {Preserved}
			}
	elseif Dest[4] == "V" and Source[4] == "VA" then -- Mov V, VA / MovY(PlayerID,{"X",Temp,0,"V"},{"X",Temp,0,"VA",VArray,0,"X",Temp+1,0})
		-- Ctrig->Ctrig->Ctrig Version : Cp사용 X

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x158,5,SetTo,Source[5][1],Source[5][2],0x158,1,Source[5][3]); 
					SetCtrigX("X","X",0x17C,5,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrigX("X","X",0x198,5,SetTo,Source[5][1],Source[5][2],0x4,1,Source[5][3]); 
					SetCtrigX("X","X",0x1B8,5,SetTo,Source[5][1],Source[5][2],0x148,1,Source[5][3]); 
					SetCtrigX("X","X",0x1D8,5,SetTo,Source[5][1],Source[5][2],0x160,1,Source[5][3]); 
					SetCtrig1X("X","X",0x158,5,Add,Source[6]);
					SetCtrig1X("X","X",0x17C,5,Add,Source[6]*4);
					SetCtrig1X("X","X",0x198,5,Add,Source[6]);
					SetCtrig1X("X","X",0x1B8,5,Add,Source[6]);
					SetCtrig1X("X","X",0x1D8,5,Add,Source[6]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x158,1,5); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x198,1,4); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x1B8,1,3); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x1D8,1,2); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x17C,1,1); 
					CallLabelAlways(Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0,0,Source[3]);
					SetCtrig2X(0,SetTo,"X","X",0,0,1); -- SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0,0,1);
					SetDeaths(0,SetTo,Mask,0); -- SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
					SetDeathsX(0,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
				},
				flag = {Preserved}
			}
	else
		MovY_InputData_Error()
	end
end
]]-- 
function MovY(PlayerID,Dest,Source,Type,Mask) -- 상수 Mem V VA A << W 전용 내부함수
	--STPopTrigArr(PlayerID)

	if type(Type[1]) == "number" or Type[1] == "Mem" or Type[1] == "V" then
		if type(Type[2]) == "number" or Type[2] == "Mem" or Type[2] == "V" then
			local Box = {}

			for i = 1, 2 do
				if type(Type[i]) == "number" then
					table.insert(Box,SetCtrig1X(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,EPD(Dest[i])))
				elseif Type[i] == "Mem" then
					table.insert(Box,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][1],Dest[i][2],Dest[i][3],1,Dest[i][4]))
				elseif Type[i] == "V" then
					if Clear == 1 then
						table.insert(Box,SetCtrig1X(Dest[i][1],Dest[i][2],0x15C,Dest[i][3],SetTo,0))
					end
					table.insert(Box,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][1],Dest[i][2],0x15C,1,Dest[i][3]))
				end
			end

			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					Box,
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
		elseif Type[2] == "VA" or Type[2] == "A" then
			local Box = {}
			for i = 1, 1 do
				if type(Type[i]) == "number" then
					table.insert(Box,SetCtrig1X(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,EPD(Dest[i])))
				elseif Type[i] == "Mem" then
					table.insert(Box,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][1],Dest[i][2],Dest[i][3],1,Dest[i][4]))
				elseif Type[i] == "V" then
					if Clear == 1 then
						table.insert(Box,SetCtrig1X(Dest[i][1],Dest[i][2],0x15C,Dest[i][3],SetTo,0))
					end
					table.insert(Box,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][1],Dest[i][2],0x15C,1,Dest[i][3]))
				end
			end

			local Box2 = {}
			for i = 2, 2 do
				if Type[i] == "VA" then
					table.insert(Box2,SetCtrigX(Dest[i][1],Dest[i][2],0x158,Dest[i][3],SetTo,Source[1],Source[2],0x158+0x40*(i-1),1,Source[3]))
					table.insert(Box2,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][5][1],Dest[i][5][2],0x15C,1,Dest[i][5][3]))
					table.insert(Box2,SetCtrig1X(Source[1],Source[2],0x158+0x40*(i-1),Source[3],Add,Dest[i][6]))
				elseif Type[i] == "A" then
					table.insert(Box2,SetCtrigX(Dest[i][1],Dest[i][2],0x158,Dest[i][3],SetTo,Source[1],Source[2],0x158+0x40*(i-1),1,Source[3]))
					table.insert(Box2,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][5][1],Dest[i][5][2],Dest[i][5][3],1,0))
				end
			end

			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					Box,
					SetCtrig1X(Dest[2][1],Dest[2][2],0x148,Dest[2][3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[2][1],Dest[2][2],0x160,Dest[2][3],SetTo,Add*16777216,0xFF000000);
					Box2,
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways2(Dest[2][1],Dest[2][2],Dest[2][3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
		end
	elseif Type[1] == "VA" or Type[1] == "A" then
		if type(Type[2]) == "number" or Type[2] == "Mem" or Type[2] == "V" then
			local Box = {}
			for i = 2, 2 do
				if type(Type[i]) == "number" then
					table.insert(Box,SetCtrig1X(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,EPD(Dest[i])))
				elseif Type[i] == "Mem" then
					table.insert(Box,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][1],Dest[i][2],Dest[i][3],1,Dest[i][4]))
				elseif Type[i] == "V" then
					if Clear == 1 then
						table.insert(Box,SetCtrig1X(Dest[i][1],Dest[i][2],0x15C,Dest[i][3],SetTo,0))
					end
					table.insert(Box,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][1],Dest[i][2],0x15C,1,Dest[i][3]))
				end
			end

			local Box2 = {}
			for i = 1, 1 do
				if Type[i] == "VA" then
					table.insert(Box2,SetCtrigX(Dest[i][1],Dest[i][2],0x158,Dest[i][3],SetTo,Source[1],Source[2],0x158+0x40*(i-1),1,Source[3]))
					table.insert(Box2,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][5][1],Dest[i][5][2],0x15C,1,Dest[i][5][3]))
					table.insert(Box2,SetCtrig1X(Source[1],Source[2],0x158+0x40*(i-1),Source[3],Add,Dest[i][6]))
				elseif Type[i] == "A" then
					table.insert(Box2,SetCtrigX(Dest[i][1],Dest[i][2],0x158,Dest[i][3],SetTo,Source[1],Source[2],0x158+0x40*(i-1),1,Source[3]))
					table.insert(Box2,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][5][1],Dest[i][5][2],Dest[i][5][3],1,0))
				end
			end

			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					Box,
					SetCtrig1X(Dest[1][1],Dest[1][2],0x148,Dest[1][3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1][1],Dest[1][2],0x160,Dest[1][3],SetTo,Add*16777216,0xFF000000);
					Box2,
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways2(Dest[1][1],Dest[1][2],Dest[1][3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
		elseif Type[2] == "VA" or Type[2] == "A" then
			local Box2 = {}
			for i = 1, 2 do
				if Type[i] == "VA" then
					table.insert(Box2,SetCtrigX(Dest[i][1],Dest[i][2],0x158,Dest[i][3],SetTo,Source[1],Source[2],0x158+0x40*(i-1),1,Source[3]))
					table.insert(Box2,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][5][1],Dest[i][5][2],0x15C,1,Dest[i][5][3]))
					table.insert(Box2,SetCtrig1X(Source[1],Source[2],0x158+0x40*(i-1),Source[3],Add,Dest[i][6]))
				elseif Type[i] == "A" then
					table.insert(Box2,SetCtrigX(Dest[i][1],Dest[i][2],0x158,Dest[i][3],SetTo,Source[1],Source[2],0x158+0x40*(i-1),1,Source[3]))
					table.insert(Box2,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][5][1],Dest[i][5][2],Dest[i][5][3],1,0))
				end
			end

			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Dest[1][1],Dest[1][2],0x148,Dest[1][3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1][1],Dest[1][2],0x160,Dest[1][3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Dest[2][1],Dest[2][2],0x148,Dest[2][3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[2][1],Dest[2][2],0x160,Dest[2][3],SetTo,Add*16777216,0xFF000000);
					Box2,
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways3(Dest[1][1],Dest[1][2],Dest[1][3],Dest[2][1],Dest[2][2],Dest[2][3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
		end
	end
end

function MovZ(PlayerID,Dest,Source,Address) -- V << LA_EPD, VA_EPD, A_EPD / W << WA_EPD, LA_EPD / 내부함수 (사용 권장X)
	--STPopTrigArr(PlayerID)
	if Address == nil then
		Address = 0
	end
	if Dest[4] == "V" and Source[4] == "VA" then -- Mov V, VA_EPD / {Index[1],Index[2],Index[3],"VA",VArray(VAPlayer,VAIndex,0),Index[5]}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address,1,Source[5][3]); 
					SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	elseif Dest[4] == "V" and Source[4] == "A" then -- Mov V, A_EPD / {Index[1],Index[2],Index[3],"A",Array(APlayer,AIndex,0)}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	elseif Dest[4] == "W" and Source[4] == "WA" then -- Mov W, WA_EPD / {Index[1],Index[2],Index[3],"WA",WArray(WAPlayer,WAIndex,0)}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address,1,Source[5][3]); 
					SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5][1],Source[5][2],Address,1,Source[5][3]); 
					SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]);
					SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],Add,Source[6]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
					SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	elseif Dest[4] == "V" and Source[4] == "LA_V" then -- Mov V, LA_EPD (2번 사용 필요)/ {Index[1],Index[2],Index[3],"LA",WArray(LAPlayer,LAIndex,0)}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	elseif Dest[4] == "W" and Source[4] == "LA_V" then -- Mov W, LA_EPD / {Index[1],Index[2],Index[3],"LA",WArray(LAPlayer,LAIndex,0)}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3]+0x4,1,0); 
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	elseif Dest[4] == "W" and Source[4] == "LA_W" then -- Mov W, LA_EPD / {Index[1],Index[2],Index[3],"LA",LArray(LAPlayer,LAIndex,0)}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
					SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3]+0x4,1,0); 
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
					SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	elseif #Dest == 2 and Dest[1][4] == "V" and Dest[2][4] == "V" and Source[4] == "LA_V" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1][1],Dest[1][2],0x15C,Dest[1][3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1][1],Dest[1][2],0x15C,1,Dest[1][3]); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[2][1],Dest[2][2],0x15C,Dest[2][3],SetTo,Source[5][1],Source[5][2],Source[5][3]+0x4,1,0); 
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[2][1],Dest[2][2],0x15C,1,Dest[2][3]); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	elseif #Dest == 2 and Dest[1][4] == "V" and Dest[2][4] == "V" and Source[4] == "LA_W" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1][1],Dest[1][2],0x15C,Dest[1][3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
					SetCtrigX(Dest[2][1],Dest[2][2],0x15C,Dest[2][3],SetTo,Source[5][1],Source[5][2],Source[5][3]+0x4,1,0); 
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1][1],Dest[1][2],0x15C,1,Dest[1][3]); 
					SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[2][1],Dest[2][2],0x15C,1,Dest[2][3]); 
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	else
		MovZ_InputData_Error()
	end
end

function TMem(PlayerID,Dest,Source,Address,Next,OffsetFlag) -- V << V_EPD/Offset, Mem_EPD/Offset, A_EPD/Offset, VA_EPD/Offset, WA_EPD/Offset, LA_EPD/Offset, W_EPD/Offset
	STPopTrigArr(PlayerID)
	if OffsetFlag == "X" or OffsetFlag == nil then
		OffsetFlag = 0
	end
	if Address == "X" or Address == nil then
		Address = 0x15C
	end
	if Next == "X" or Next == nil then
		Next = 0
	end

	if Dest[4] == "V" then
		if Source[4] == "V" then
			if Source[3] == nil or Source[3] == "X" then
				Source[3] = 0 
			end
			if OffsetFlag == 0 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Address,1,Source[3]+Next); 
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Address,0,Source[3]+Next); 
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "W" then
			if Source[3] == nil or Source[3] == "X" then
				Source[3] = 0 
			end
			if OffsetFlag == 0 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Address,1,Source[3]+Next); 
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Address,0,Source[3]+Next); 
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "A" then
			if OffsetFlag == 0 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0);
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1452249);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
						SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
						SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "VA" then
			if OffsetFlag == 0 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address,1,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address,0,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]*4);
						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						CallLabelAlways(Source[7],Source[8],Source[9]);
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "WA" then 
			if OffsetFlag == 0 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address,1,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,0); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address,0,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]*4);
						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrig1X(Source[7],Source[8],0x158,Source[9],SetTo,0); 
						CallLabelAlways(Source[7],Source[8],Source[9]);
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "LA_V" then
			if OffsetFlag == 0 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0);
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1452249);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
						SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
						SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "LA_W" then
			if OffsetFlag == 0 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1452249);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
						SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
						SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
			end
		else
			if OffsetFlag == 0 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Source[3],1,Source[4]); 
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Source[3],0,Source[4]); 
					},
					flag = {Preserved}
				}
			end
		end
	else
		_TMem_InputData_Error()
	end
end

function TLMem(PlayerID,Dest,Source,Address,Next,OffsetFlag) -- W << V_EPD/Offset, Mem_EPD/Offset, A_EPD/Offset, VA_EPD/Offset, WA_EPD/Offset, LA_EPD/Offset, W_EPD/Offset
	STPopTrigArr(PlayerID)
	if OffsetFlag == "X" or OffsetFlag == nil then
		OffsetFlag = 0
	end
	local AddressN
	if Address == "X" or Address == nil then
		Address = {0x15C,0x15C}
		AddressN = 1
	end
	if Next == "X" or Next == nil then
		Next = 0
	end

	if Dest[4] == "W" then
		if Source[4] == "V" then
			if Source[3] == nil or Source[3] == "X" then
				Source[3] = 0 
			end
			if OffsetFlag == 0 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Address[1],1,Source[3]+Next); 
						SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[1],Source[2],Address[2],1,Source[3]+Next); 
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Address[1],0,Source[3]+Next); 
						SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[1],Source[2],Address[2],0,Source[3]+Next); 
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "W" then
			if AddressN == 1 then
				Address[2] = 0x19C
			end
			if Source[3] == nil or Source[3] == "X" then
				Source[3] = 0 
			end
			if OffsetFlag == 0 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Address[1],1,Source[3]+Next); 
						SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[1],Source[2],Address[2],1,Source[3]+Next); 
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Address[1],0,Source[3]+Next); 
						SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[1],Source[2],Address[2],0,Source[3]+Next); 
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "A" then
			if OffsetFlag == 0 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0);
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1452249);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x198,Dest[3],SetTo,0); 
						SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
						SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
						SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "VA" then
			if OffsetFlag == 0 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address[1],1,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5][1],Source[5][2],Address[2],1,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],Add,Source[6]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address[1],0,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]*4);
						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						CallLabelAlways(Source[7],Source[8],Source[9]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5][1],Source[5][2],Address[2],0,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],Add,Source[6]*4);
						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						CallLabelAlways(Source[7],Source[8],Source[9]);
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "WA" then 
			if AddressN == 1 then
				Address[2] = 0x19C
			end
			if OffsetFlag == 0 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address[1],1,Source[5][3]+Next); 
						SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5][1],Source[5][2],Address[2],1,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],Add,Source[6]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address[1],0,Source[5][3]+Next); 
						SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5][1],Source[5][2],Address[2],0,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]*4);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],Add,Source[6]*4);
						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x188,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[7],Source[8],0x1A0,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrigX(Source[7],Source[8],0x198,Source[9],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						CallLabelAlways(Source[7],Source[8],Source[9]);
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "LA_V" then
			if OffsetFlag == 0 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,1);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x198,Dest[3],SetTo,0); 
						SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
						SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
						SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,1);
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1452249);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x198,Dest[3],SetTo,0); 
						SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
						SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
						SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "LA_W" then
			if OffsetFlag == 0 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
						SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3]+0x4,1,0); 
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3],1,0); 
						SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[5][1],Source[5][2],Source[5][3]+0x4,1,0); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1452249);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],Add,1452249);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
						SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
						SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
			end
		else
			if #Source == 2 then
				if OffsetFlag == 0 then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1][1],Source[1][2],Source[1][3],1,Source[1][4]); 
							SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[2][1],Source[2][2],Source[2][3],1,Source[2][4]); 
						},
						flag = {Preserved}
					}
				else
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1][1],Source[1][2],Source[1][3],0,Source[1][4]); 
							SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[2][1],Source[2][2],Source[2][3],0,Source[2][4]); 
						},
						flag = {Preserved}
					}
				end
			else
				if OffsetFlag == 0 then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Source[3],1,Source[4]); 
							SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[1],Source[2],Source[3],1,Source[4]); 
						},
						flag = {Preserved}
					}
				else
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Source[3],0,Source[4]); 
							SetCtrigX(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[1],Source[2],Source[3],0,Source[4]); 
						},
						flag = {Preserved}
					}
				end
			end
		end
	else
		_TLMem_InputData_Error()
	end
end

function CMovX(PlayerID,Dest,Source,Mode,Mask,Deviation,Clear) -- V << VA / VA,A << V (Value)
	STPopTrigArr(PlayerID)
	if Deviation == "X" or Deviation == nil then
		Deviation = 0
	end
	if Mode == "X" or Mode == nil then
		Mode = SetTo
	end
	if Mask == "X" or Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local Mask2 = Mask
	if Clear == 1 then
		Mask2 = 0xFFFFFFFF
	end

	if type(Dest) == "number" and Source[4] == "VA" then -- Mov V, VA / {Index[1],Index[2],Index[3],"VA",VArray(VAPlayer,VAIndex,0),Index[5]}
		Trigger {--(CPRead)로 값 출력
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
					SetMemoryX(Dest,SetTo,Deviation,Mask);

					SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
					SetMemory(0x6509B0,Add,Source[6]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
					CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetDeaths(CurrentPlayer,SetTo,EPD(Dest),0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);

				},
				flag = {Preserved}
			}

		RecoverCp(PlayerID)
	elseif type(Dest[4]) ~= "string" and Source[4] == "VA" then -- Mov Mem, VA / {Index[1],Index[2],Index[3],"VA",VArray(VAPlayer,VAIndex,0),Index[5]}
		Trigger {--(CPRead)로 값 출력
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
					SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation,Mask);

					SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
					SetMemory(0x6509B0,Add,Source[6]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
					CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);

				},
				flag = {Preserved}
			}

		RecoverCp(PlayerID)
	elseif Dest[4] == "V" and Source[4] == "VA" then -- Mov V, VA / {Index[1],Index[2],Index[3],"VA",VArray(VAPlayer,VAIndex,0),Index[5]}
		Trigger {--(CPRead)로 값 출력
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
					SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2);

					SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
					SetMemory(0x6509B0,Add,Source[6]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
					CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);

				},
				flag = {Preserved}
			}

		RecoverCp(PlayerID)
	elseif Dest[4] == "VA" then -- Mov VA, V 
		if type(Source) == "number" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x158,1,SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
					SetCtrig1X("X","X",0x158,1,Add,Dest[6]);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
					CallLabelAlways(Dest[1],Dest[2],Dest[3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetMemoryX(0,Mode,Source,Mask); 
				},
				flag = {Preserved}
			}
		elseif Source[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],Add,Dest[6]);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,Deviation);
					CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,-Deviation);
				},
				flag = {Preserved}
			}
		elseif Source[4] == "VA" then
			Trigger {--(CPRead)로 값 출력
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1);

						SetCtrigX("X","X",0x19C,1,SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
						SetCtrig1X("X","X",0x19C,1,Add,Dest[6]);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x19C,1,1);
						CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}

			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148)/4);
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x15C-0x160)/4);
						SetDeaths(CurrentPlayer,Add,Deviation,0); 
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeaths(CurrentPlayer,Add,-Deviation,0); 
					},
					flag = {Preserved}
				}

			RecoverCp(PlayerID)
		end
	elseif Dest[4] == "A" then -- Mov A, V 
		if type(Source) == "number" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x158,1,SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1); 
					CallLabelAlways(Dest[1],Dest[2],Dest[3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetMemoryX(0,Mode,Source,Mask); 
				},
				flag = {Preserved}
			}
		elseif Source[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,Deviation);
					CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,-Deviation);
				},
				flag = {Preserved}
			}
		elseif Source[4] == "VA" then
			Trigger {--(CPRead)로 값 출력
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1);

						SetCtrigX("X","X",0x19C,1,SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x19C,1,1);
						CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}

			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148)/4);
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x15C-0x160)/4);
						SetDeaths(CurrentPlayer,Add,Deviation,0); 
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeaths(CurrentPlayer,Add,-Deviation,0); 
					},
					flag = {Preserved}
				}

			RecoverCp(PlayerID)
		end
	else
		CMovX_InputData_Error()
	end
end

-- CurrentPlayer 관련 함수 / CunitCtrig -------------------------------------------------------------

function RecoverCp(PlayerID)
	if DetectRecoverCp == 1 then
		_G["\n- RecoverCp() Detected! -\n"]() 
	end
	if RecoverCpValue == "X" then	
		PlayerID = PlayerConvert(PlayerID)
		for k, P in pairs(PlayerID) do
			Trigger {
				players = {P},
				conditions = {
					Label(0);
				},
				actions = {
					SetMemory(0x6509B0,SetTo,P);
				},
				flag = {Preserved}
			}	
		end
	elseif type(RecoverCpValue) == "number" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetMemory(0x6509B0,SetTo,RecoverCpValue);
				},
				flag = {Preserved}
			}	
	elseif RecoverCpValue[4] == "V" then -- 변수입력 Vi 가능
		if RecoverCpValue[5] == nil then
			RecoverCpValue[5] = 0
		end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetMemory(0x6509B0,SetTo,RecoverCpValue[5]);
					SetCtrig1X(RecoverCpValue[1],RecoverCpValue[2],0x158,RecoverCpValue[3],SetTo,EPD(0x6509B0));
					SetCtrig1X(RecoverCpValue[1],RecoverCpValue[2],0x148,RecoverCpValue[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(RecoverCpValue[1],RecoverCpValue[2],0x160,RecoverCpValue[3],SetTo,Add*16777216,0xFF000000);
					CallLabelAlways(RecoverCpValue[1],RecoverCpValue[2],RecoverCpValue[3]);
				},
				flag = {Preserved}
			}	
	end
end

function SetRecoverCp(Cp)
	if Cp == nil then
		Cp = "X"
	end
	RecoverCpValue = Cp
end

function MoveCp(Type,Value)
	local CpValue
	local CpRet
	if Type == nil then
		CpRet = MoveCpValue
	else
		if Type == Add then
			CpValue = Value/4
			MoveCpValue = MoveCpValue + Value
			CpRet = SetMemory(0x6509B0,Add,CpValue)
		elseif Type == Subtract then
			CpValue = (0-Value)/4
			MoveCpValue = MoveCpValue - Value
			CpRet = SetMemory(0x6509B0,Add,CpValue)
		elseif Type == SetTo then
			CpValue = (Value-MoveCpValue)/4
			MoveCpValue = Value
			CpRet = SetMemory(0x6509B0,Add,CpValue)
		elseif Type == "X" or Type == "Clear" then
			if Value == nil then
				Value = 0
			end
			MoveCpValue = Value
			CpRet = nil
		end
	end
	return CpRet
end

function SaveCp(PlayerID,Output,OffsetOutput)
	if OffsetOutput == "X" then
		OffsetOutput = nil
	end
	if Output == "X" then
		Output = nil
	end

	local CPRead1 = {}
	if Output[4] == "V" then
		table.insert(CPRead1,SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,0))
	elseif Output[4] == "VA" then
		SaveCp_InputData_Error() 
	end
	if OffsetOutput ~= nil then
		if OffsetOutput[4] == "V" then
			table.insert(CPRead1,SetCtrig1X(OffsetOutput[1],OffsetOutput[2],0x15C,OffsetOutput[3],SetTo,0x58A364))
		elseif OffsetOutput[4] == "VA" then
			SaveCp_InputData_Error() 
		end
	end
	Trigger {
		players = {PlayerID},
		conditions = { 
			Label(0);
		},
		actions = {
			CPRead1,
		},
		flag = {Preserved}
		
	}
	for i = 0, 31 do
		local CPRead2 = {}
		local CBit = 2^i
		if Output[4] == "V" then
			table.insert(CPRead2,SetCtrig1X(Output[1],Output[2],0x15C,Output[3],Add,CBit)) 
		elseif Output[4] == "VA" then
			SaveCp_InputData_Error() 
		end
		if OffsetOutput ~= nil then
			if OffsetOutput[4] == "V" and i <= 29 then
				table.insert(CPRead2,SetCtrig1X(OffsetOutput[1],OffsetOutput[2],0x15C,OffsetOutput[3],Add,CBit*4))
			elseif OffsetOutput[4] == "VA" then
				SaveCp_InputData_Error() 
			end
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			   	MemoryX(0x6509B0,Exactly,CBit,CBit);
			},
			actions = {
				CPRead2,
			},
			flag = {Preserved}
		}
	end
end

function LoadCp(PlayerID,Cp)
	SetRecoverCp(Cp)
	RecoverCp(PlayerID)
end

function LoadCpX(PlayerID,Cp)
	local TempCp = RecoverCpValue
	SetRecoverCp(Cp)
	RecoverCp(PlayerID)
	SetRecoverCp(TempCp)
end

function CunitCtrig_Part1(PlayerID,Actions)
	Trigger { -- Cunit Ctrig Start
		players = {PlayerID},
		conditions = { 
			Label(0);
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+2,0,0,1); 
		},
		flag = {Preserved}
	}	
	Trigger { -- Cunit Calc Selector
		players = {PlayerID},
		conditions = { 
			Label(FuncAlloc);
		},
		actions = {
			SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- RecoverNext
			Actions,
		},
		flag = {Preserved}
	}	
	PlayerID = PlayerConvert(PlayerID)
	table.insert(CCArr, FuncAlloc)
	table.insert(CCPArr, PlayerID)
	CCptr = CCptr + 1
	FuncAlloc = FuncAlloc + 3
end
-- NJump Trig 삽입 부분 (조건만족시 Jump)
function CunitCtrig_Part2()
	PlayerID = CCPArr[CCptr]
	PlayerID = PlayerConvert(PlayerID)
	for k, P in pairs(PlayerID) do
		Trigger { -- Cunit Calc Last
			players = {P},
			conditions = { 
				Label(CCArr[CCptr]+1);
			},
		   	actions = {
				SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- RecoverNext
				SetMemory(0x6509B0,SetTo,P); -- 루프를 돌릴 플레이어 값으로 맞추기 ( P1 = 0, P2 = 1, ... , P8 = 7 )
			},
			flag = {Preserved}
		}	
	end
end
-- Cunit 연산 트리거 삽입 부분 (Break/Clear로 Return)
function CunitCtrig_Part3(Conditions,Actions)
	PlayerID = CCPArr[CCptr]
	Trigger { -- Cunit Calc Start
		players = {PlayerID},
		conditions = { 
			Label(CCArr[CCptr]+2);
		},
		flag = {Preserved}
	}	

	for i = 0 , 1699 do
		MoveCpValue = 0
		Trigger { -- Cunit Calc Main
			players = {PlayerID},
			conditions = { 
				Label(0);
				Conditions,
			},
			actions = { 
				SetCtrigX("X","X",0x4,0,SetTo,"X",CCArr[CCptr],0,0,0);
				SetCtrigX("X",CCArr[CCptr]+1,0x4,0,SetTo,"X","X",0,0,1);
				SetCtrigX("X",CCArr[CCptr],0x158,0,SetTo,"X","X",0x4,1,0);
				SetCtrigX("X",CCArr[CCptr],0x15C,0,SetTo,"X","X",0,0,1);
				SetMemory(0x6509B0,SetTo,161741 - 84 * i);
				Actions,
				},
			flag = {Preserved}
		}	
	end
	table.remove(CCArr,CCptr)
	table.remove(CCPArr,CCptr)
	CCptr = CCptr - 1
end

function CunitCtrig_Part3X()
	MoveCpValue = 0
	PlayerID = CCPArr[CCptr]
	Trigger { -- Cunit Calc Start
		players = {PlayerID},
		conditions = { 
			Label(CCArr[CCptr]+2);
		},
		flag = {Preserved}
	}	
end

function CunitCtrig_Part4X(LoopIndex,Conditions,Actions)
	MoveCpValue = 0
	Trigger { -- Cunit Calc Main
		players = {PlayerID},
		conditions = { 
			Label(0);
			Conditions,
		},
		actions = { 
			SetCtrigX("X","X",0x4,0,SetTo,"X",CCArr[CCptr],0,0,0);
			SetCtrigX("X",CCArr[CCptr]+1,0x4,0,SetTo,"X","X",0,0,1);
			SetCtrigX("X",CCArr[CCptr],0x158,0,SetTo,"X","X",0x4,1,0);
			SetCtrigX("X",CCArr[CCptr],0x15C,0,SetTo,"X","X",0,0,1);
			SetMemory(0x6509B0,SetTo,161741 - 84 * LoopIndex);
			Actions,
			},
		flag = {Preserved}
	}		
end

function CunitCtrig_End()
	table.remove(CCArr,CCptr)
	table.remove(CCPArr,CCptr)
	CCptr = CCptr - 1
end
	
function ClearCalc()
	PlayerID = CCPArr[CCptr]
	Trigger { -- Cunit Calc End
		players = {PlayerID},
		conditions = { 
			Label(0);
		}, 
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",CCArr[CCptr]+1,0,0,0);
		},
		flag = {Preserved}
	}	
end

function BreakCalc(Conditions,Actions)	
	PlayerID = CCPArr[CCptr]
	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,3)

	Trigger { -- Cunit Calc Break
		players = {PlayerID},
		conditions = { 
			Label(0);
			Conditions,
		}, 
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",CCArr[CCptr]+1,0,0,0);
			SetCtrigX("X",CCArr[CCptr]+1,0x158,0,SetTo,"X","X",0x4,1,0);
			SetCtrigX("X",CCArr[CCptr]+1,0x15C,0,SetTo,"X","X",0,0,1);
			Actions,
		},
		flag = {Preserved}
	}	
end

-- 변수/배열 선언/호출 함수 -----------------------------------------------------------------

function CVariable(Player,Index)
	Trigger {
				players = {Player},
				conditions = {
					Label(Index);
				},
				actions = {
					SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
end

function CVariable2(Player,Index,Offset,Type,Value,Mask)
	if Offset == "X" then 
		Offset = nil
	end
	if Type == "X" then 
		Type = nil
	end
	if Mask == "X" then 
		Mask = nil
	end
	if Value == "X" then 
		Value = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	if Offset == nil then
		Offset = 0x58A364
	end
	if Type == nil then
		Type = SetTo
	end
	if Value == nil then
		Value = 0
	end
	Trigger {
				players = {Player},
				conditions = {
					Label(Index);
				},
				actions = {
					SetDeathsX(EPD(Offset),Type,Value,0,Mask); -- Full Variable
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
end

function CWariable(Player,Index)
	Trigger {
				players = {Player},
				conditions = {
					Label(Index);
				},
				actions = {
					SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable Lower 32
					Disabled(FSetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)); -- Cp Add (Must be Preserved)
					SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable Upper 32
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
end

function CWariable2(Player,Index,Offset,Type,Value,Mask)
	if Offset == "X" then 
		Offset = nil
	end
	if Type == "X" then 
		Type = nil
	end
	if Mask == "X" then 
		Mask = nil
	end
	if Value == "X" then 
		Value = nil
	end

	if type(Offset) == "number" then
		Offset = {Offset,Offset+4}
	elseif type(Offset) == "table" and type(Offset[2]) == "table" then
		Offset = {Offset[1],Offset[1]+Offset[2][1]}
	elseif type(Offset) == "string" then
		Offset = I64(Offset)
	end
	if type(Type) == "number" then
		Type = {Type,Type}
	elseif type(Type) == "string" then
		Type = I64(Type)
	end
	if type(Value) == "number" then -- Type == "table" 일 경우 그대로 삽입
		Value = {Value,0} -- 32Bit Number
	elseif type(Value) == "string" then
		Value = I64(Value)
	end
	if type(Mask) == "number" then
		Mask = {Mask,Mask}
	elseif type(Mask) == "string" then
		Mask = I64(Mask)
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	end
	if Offset == nil then
		Offset = {0x58A364,0x58A364}
	end
	if Type == nil then
		Type = {SetTo,SetTo}
	end
	if Value == nil then 
		Value = {0,0}
	end

	Trigger {
				players = {Player},
				conditions = {
					Label(Index);
				},
				actions = {
					SetDeathsX(EPD(Offset[1]),Type[1],Value[1],0,Mask[1]); -- Full Variable
					Disabled(FSetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)); -- Cp Add (Must be Preserved)
					SetDeathsX(EPD(Offset[2]),Type[2],Value[2],0,Mask[2]); -- Full Variable
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
end

function CSVariable(Player,Index,Number)
	if Number <= 0 or Number >= 33 then
		CSVariable_InputData_Error()
	end
	local Box = {}
	for i = 2, Number do
		table.insert(Box,Disabled(FSetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)))
		table.insert(Box,SetDeathsX(0,SetTo,0,0,0xFFFFFFFF))
	end
	Trigger {
				players = {Player},
				conditions = {
					Label(Index);
				},
				actions = {
					SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable Lower 32
					Box,
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
	return {"S",Index,Number}
end

function CSVariable2(Player,Index,Number,Offset,Type,Value,Mask)
	if Number <= 0 or Number >= 33 then
		CSVariable_InputData_Error()
	end
	local Box = {}

	if Offset == "X" then 
		Offset = nil
	end
	if Type == "X" then 
		Type = nil
	end
	if Mask == "X" then 
		Mask = nil
	end
	if Value == "X" then 
		Value = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	if Offset == nil then
		Offset = 0x58A364
	end
	if Type == nil then
		Type = SetTo
	end
	if Value == nil then 
		Value = 0
	end

	local OffsetN = 0x58A364
	local TypeN = SetTo
	local ValueN = 0
	local MaskN = 0xFFFFFFFF
	local OffsetT,TypeT,ValueT,MaskT
	if type(Offset) == "number" then
		OffsetN = Offset
	end
	if type(Type) == "number" then
		TypeN = Type
	end
	if type(Value) == "number" then 
		ValueN = Value
	end
	if type(Mask) == "number" then
		MaskN = Mask
	end
	
	for i = 2, Number do
		if type(Offset) == "table" and Offset ~= nil then
			OffsetT = Offset[i]
		else
			OffsetT = OffsetN
		end
		if type(Type) == "table" and Type ~= nil then
			TypeT = Type[i]
		else
			TypeT = TypeN
		end
		if type(Value) == "table" and Value ~= nil then
			ValueT = Value[i]
		else
			ValueT = ValueN
		end
		if type(Mask) == "table" and Mask ~= nil then
			MaskT = Mask[i]
		else
			MaskT = MaskN
		end
		table.insert(Box,Disabled(FSetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)))
		table.insert(Box,SetDeathsX(EPD(OffsetT),TypeT,ValueT,0,MaskT))
	end
	if type(Offset) == "table" and Offset ~= nil then
		OffsetT = Offset[1]
	else
		OffsetT = OffsetN
	end
	if type(Type) == "table" and Type ~= nil then
		TypeT = Type[1]
	else
		TypeT = TypeN
	end
	if type(Value) == "table" and Value ~= nil then
		ValueT = Value[1]
	else
		ValueT = ValueN
	end
	if type(Mask) == "table" and Mask ~= nil then
		MaskT = Mask[1]
	else
		MaskT = MaskN
	end
	Trigger {
				players = {Player},
				conditions = {
					Label(Index);
				},
				actions = {
					SetDeathsX(EPD(OffsetT),TypeT,ValueT,0,MaskT); -- Full Variable
					Box,
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
	return {"S",Index,Number}
end

function CallLabel1(Player,Index,Next)
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrigX(Player,Index,0x178,Next,SetTo,"X","X",0x4,1,0))
	table.insert(X,SetCtrigX(Player,Index,0x17C,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrig1X(Player,Index,0x184,Next,SetTo,0x0,0x2))
	return X
end

function CallLabel2(Player,Index,Next)
	local X = {}
	table.insert(X,SetCtrig1X(Player,Index,0x184,Next,SetTo,0x2,0x2))
	return X
end

function CallLabelAlways(Player,Index,Next)
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,"X","X",0,0,1))
	return X
end

function CallLabelAlways2(Player,Index,Next,Player2,Index2,Next2)
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,Player2,Index2,0,0,Next2))
	table.insert(X,SetCtrigX(Player2,Index2,0x4,Next2,SetTo,"X","X",0,0,1))
	return X
end

function CallLabelAlways3(Player,Index,Next,Player2,Index2,Next2,Player3,Index3,Next3)
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,Player2,Index2,0,0,Next2))
	table.insert(X,SetCtrigX(Player2,Index2,0x4,Next2,SetTo,Player3,Index3,0,0,Next3))
	table.insert(X,SetCtrigX(Player3,Index3,0x4,Next3,SetTo,"X","X",0,0,1))
	return X
end

function CallLabelAlways4(Player,Index,Next,Player2,Index2,Next2,Player3,Index3,Next3,Player4,Index4,Next4)
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,Player2,Index2,0,0,Next2))
	table.insert(X,SetCtrigX(Player2,Index2,0x4,Next2,SetTo,Player3,Index3,0,0,Next3))
	table.insert(X,SetCtrigX(Player3,Index3,0x4,Next3,SetTo,Player4,Index4,0,0,Next4))
	table.insert(X,SetCtrigX(Player4,Index4,0x4,Next4,SetTo,"X","X",0,0,1))
	return X
end

function CallLabel1X(Variable)
	local Player = Variable[1]
	local Index = Variable[2]
	local Next = Variable[3]
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrigX(Player,Index,0x178,Next,SetTo,"X","X",0x4,1,0))
	table.insert(X,SetCtrigX(Player,Index,0x17C,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrig1X(Player,Index,0x184,Next,SetTo,0x0,0x2))
	return X
end

function CallLabel2X(Variable)
	local Player = Variable[1]
	local Index = Variable[2]
	local Next = Variable[3]
	local X = {}
	table.insert(X,SetCtrig1X(Player,Index,0x184,Next,SetTo,0x2,0x2))
	return X
end

function CallLabelAlwaysX(Variable)
	local Player = Variable[1]
	local Index = Variable[2]
	local Next = Variable[3]
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,"X","X",0,0,1))
	return X
end

function CallLabelAlways2X(Variable,Variable2)
	local Player = Variable[1]
	local Index = Variable[2]
	local Next = Variable[3]
	local Player2 = Variable2[1]
	local Index2 = Variable2[2]
	local Next2 = Variable2[3]
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,Player2,Index2,0,0,Next2))
	table.insert(X,SetCtrigX(Player2,Index2,0x4,Next2,SetTo,"X","X",0,0,1))
	return X
end

function CallLabelAlways3X(Variable,Variable2,Variable3)
	local Player = Variable[1]
	local Index = Variable[2]
	local Next = Variable[3]
	local Player2 = Variable2[1]
	local Index2 = Variable2[2]
	local Next2 = Variable2[3]
	local Player3 = Variable3[1]
	local Index3 = Variable3[2]
	local Next3 = Variable3[3]
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,Player2,Index2,0,0,Next2))
	table.insert(X,SetCtrigX(Player2,Index2,0x4,Next2,SetTo,Player3,Index3,0,0,Next3))
	table.insert(X,SetCtrigX(Player3,Index3,0x4,Next3,SetTo,"X","X",0,0,1))
	return X
end

function CallLabelAlways4X(Variable,Variable2,Variable3,Variable4)
	local Player = Variable[1]
	local Index = Variable[2]
	local Next = Variable[3]
	local Player2 = Variable2[1]
	local Index2 = Variable2[2]
	local Next2 = Variable2[3]
	local Player3 = Variable3[1]
	local Index3 = Variable3[2]
	local Next3 = Variable3[3]
	local Player4 = Variable4[1]
	local Index4 = Variable4[2]
	local Next4 = Variable4[3]
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,Player2,Index2,0,0,Next2))
	table.insert(X,SetCtrigX(Player2,Index2,0x4,Next2,SetTo,Player3,Index3,0,0,Next3))
	table.insert(X,SetCtrigX(Player3,Index3,0x4,Next3,SetTo,Player4,Index4,0,0,Next4))
	table.insert(X,SetCtrigX(Player4,Index4,0x4,Next4,SetTo,"X","X",0,0,1))
	return X
end

function CallLabelAlwaysN(...)
	local X = {}
	local arg = table.pack(...)

	if arg.n == 1 then
		table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,arg[1][1],arg[1][2],0,0,arg[1][3]))
		table.insert(X,SetCtrigX(arg[1][1],arg[1][2],0x4,arg[1][3],SetTo,"X","X",0,0,1))
	else
		for k = 1, arg.n do
			if k == 1 then
				table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,arg[k][1],arg[k][2],0,0,arg[k][3]))
			elseif k == arg.n then
				table.insert(X,SetCtrigX(arg[k-1][1],arg[k-1][2],0x4,arg[k-1][3],SetTo,arg[k][1],arg[k][2],0,0,arg[k][3]))
				table.insert(X,SetCtrigX(arg[k][1],arg[k][2],0x4,arg[k][3],SetTo,"X","X",0,0,1))
			else
				table.insert(X,SetCtrigX(arg[k-1][1],arg[k-1][2],0x4,arg[k-1][3],SetTo,arg[k][1],arg[k][2],0,0,arg[k][3]))
			end
		end
	end
	return X
end

function CallVariableAlwaysN(PlayerID,...)
	local X = {}
	local Y = {}
	local arg = table.pack(...)

	if arg.n == 1 then
		table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,arg[1][1],arg[1][2],0,0,arg[1][3]))
		table.insert(X,SetCtrigX(arg[1][1],arg[1][2],0x4,arg[1][3],SetTo,"X","X",0,0,1))
	else
		for k = 1, arg.n do
			if k == 1 then
				table.insert(Y,SetCtrigX("X","X",0x4,0,SetTo,arg[k][1],arg[k][2],0,0,arg[k][3]))
			elseif k == arg.n then
				table.insert(Y,SetCtrigX(arg[k-1][1],arg[k-1][2],0x4,arg[k-1][3],SetTo,arg[k][1],arg[k][2],0,0,arg[k][3]))
				table.insert(Y,SetCtrigX(arg[k][1],arg[k][2],0x4,arg[k][3],SetTo,"X","X",0,0,1))
			else
				table.insert(X,SetCtrigX(arg[k-1][1],arg[k-1][2],0x4,arg[k-1][3],SetTo,arg[k][1],arg[k][2],0,0,arg[k][3]))
			end
		end
	end
	if arg.n == 1 then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				X,
			},
			flag = {Preserved}
		}
	else
		DoActions2X(PlayerID,X)
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				Y,
			},
			flag = {Preserved}
		}
	end
end

function CallVariable(PlayerID,Player,Index,Next,Conditions,Actions)
		if Next == nil then
			Next = 0
		end
		if Conditions == nil or Conditions == "X" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabelAlways(Player,Index,Next);
					Actions,
				},
				flag = {Preserved}
			}
		else
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					Conditions,
				},
				actions = {
					CallLabel1(Player,Index,Next);
					Actions,
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabel2(Player,Index,Next);
				},
				flag = {Preserved}
			}
		end
end

function CallVariableX(PlayerID,Variable,Conditions,Actions)
		local Player = Variable[1]
		local Index = Variable[2]
		local Next = Variable[3]
		if Next == nil then
			Next = 0
		end
		if Conditions == nil or Conditions == "X" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabelAlways(Player,Index,Next);
					Actions,
				},
				flag = {Preserved}
			}
		else
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					Conditions,
				},
				actions = {
					CallLabel1(Player,Index,Next);
					Actions,
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabel2(Player,Index,Next);
				},
				flag = {Preserved}
			}
		end
end

function LCallLabel1(Player,Index,Next)
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrigX(Player,Index,0x1B8,Next,SetTo,"X","X",0x4,1,0))
	table.insert(X,SetCtrigX(Player,Index,0x1BC,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrig1X(Player,Index,0x1C4,Next,SetTo,0x0,0x2))
	return X
end

function LCallLabel2(Player,Index,Next)
	local X = {}
	table.insert(X,SetCtrig1X(Player,Index,0x1C4,Next,SetTo,0x2,0x2))
	return X
end

function LCallLabel1X(Wariable)
	local Player = Wariable[1]
	local Index = Wariable[2]
	local Next = Wariable[3]
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrigX(Player,Index,0x1B8,Next,SetTo,"X","X",0x4,1,0))
	table.insert(X,SetCtrigX(Player,Index,0x1BC,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrig1X(Player,Index,0x1C4,Next,SetTo,0x0,0x2))
	return X
end

function LCallLabel2X(Wariable)
	local Player = Wariable[1]
	local Index = Wariable[2]
	local Next = Wariable[3]
	local X = {}
	table.insert(X,SetCtrig1X(Player,Index,0x1C4,Next,SetTo,0x2,0x2))
	return X
end

function CallWariable(PlayerID,Player,Index,Next,Conditions,Actions)
		if Next == nil then
			Next = 0
		end
		if Conditions == nil or Conditions == "X" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabelAlways(Player,Index,Next);
					Actions,
				},
				flag = {Preserved}
			}
		else
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					Conditions,
				},
				actions = {
					LCallLabel1(Player,Index,Next);
					Actions,
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					LCallLabel2(Player,Index,Next);
				},
				flag = {Preserved}
			}
		end
end

function CallWariableX(PlayerID,Wariable,Conditions,Actions)
		local Player = Wariable[1]
		local Index = Wariable[2]
		local Next = Wariable[3]
		if Next == nil then
			Next = 0
		end
		if Conditions == nil or Conditions == "X" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabelAlways(Player,Index,Next);
					Actions,
				},
				flag = {Preserved}
			}
		else
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					Conditions,
				},
				actions = {
					LCallLabel1(Player,Index,Next);
					Actions,
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					LCallLabel2(Player,Index,Next);
				},
				flag = {Preserved}
			}
		end
end

function SCallLabel1(Player,SVariable,Next)
	if SVariable[1] ~= "S" then
		SCallLabel_InputData_Error()
	end
	local Index = SVariable[2]
	local Distance = 0x40*(SVariable[3]-1)
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrigX(Player,Index,0x178+Distance,Next,SetTo,"X","X",0x4,1,0))
	table.insert(X,SetCtrigX(Player,Index,0x17C+Distance,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrig1X(Player,Index,0x184+Distance,Next,SetTo,0x0,0x2))
	return X
end

function SCallLabel2(Player,SVariable,Next)
	if SVariable[1] ~= "S" then
		SCallLabel_InputData_Error()
	end
	local Index = SVariable[2]
	local Distance = 0x40*(SVariable[3]-1)
	local X = {}
	table.insert(X,SetCtrig1X(Player,Index,0x184+Distance,Next,SetTo,0x2,0x2))
	return X
end

function SCallLabel1X(SVData)
	if SVData[4] ~= "SV" then
		SCallLabelX_InputData_Error()
	end
	local Player = SVData[1]
	local Index = SVData[2]
	local Next = SVData[3]
	local Distance = 0x40*(SVData[5]-1)
	local X = {}
	table.insert(X,SetCtrigX("X","X",0x4,0,SetTo,Player,Index,0,0,Next))
	table.insert(X,SetCtrigX(Player,Index,0x4,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrigX(Player,Index,0x178+Distance,Next,SetTo,"X","X",0x4,1,0))
	table.insert(X,SetCtrigX(Player,Index,0x17C+Distance,Next,SetTo,"X","X",0,0,1))
	table.insert(X,SetCtrig1X(Player,Index,0x184+Distance,Next,SetTo,0x0,0x2))
	return X
end

function SCallLabel2X(SVData)
	if SVData[4] ~= "SV" then
		SCallLabelX_InputData_Error()
	end
	local Player = SVData[1]
	local Index = SVData[2]
	local Next = SVData[3]
	local Distance = 0x40*(SVData[5]-1)
	local X = {}
	table.insert(X,SetCtrig1X(Player,Index,0x184+Distance,Next,SetTo,0x2,0x2))
	return X
end

function CallSVariable(PlayerID,Player,SVariable,Next,Conditions,Actions)
		if SVariable[1] ~= "S" then
			CallSVariable_InputData_Error()
		end

		if Next == nil then
			Next = 0
		end
		if Conditions == nil or Conditions == "X" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabelAlways(Player,SVariable[2],Next);
					Actions,
				},
				flag = {Preserved}
			}
		else
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					Conditions,
				},
				actions = {
					SCallLabel1(Player,SVariable,Next);
					Actions,
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SCallLabel2(Player,SVariable,Next);
				},
				flag = {Preserved}
			}
		end
end

function CallSVariableX(PlayerID,SVData,Conditions,Actions)
		if SVData[4] ~= "SV" then
			CallSVariableX_InputData_Error()
		end
		local Player = SVData[1]
		local Index = SVData[2]
		local Next = SVData[3]

		if Next == nil then
			Next = 0
		end
		if Conditions == nil or Conditions == "X" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabelAlways(Player,Index,Next);
					Actions,
				},
				flag = {Preserved}
			}
		else
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					Conditions,
				},
				actions = {
					SCallLabel1X(SVData);
					Actions,
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SCallLabel2X(SVData);
				},
				flag = {Preserved}
			}
		end
end

function CDb(PlayerID,ByteSize)
	if bit32.band(ByteSize, 0xFFFFFFFF) >= 0x1000000 or ByteSize == 0 then
		Db_Size_Overflow()
	end
	return CArray(PlayerID,ByteSize/4)
end

function CArray(PlayerID,Size)
	if bit32.band(Size, 0xFFFFFFFF) >= 4096*602 or Size == 0 then
		Array_Size_Overflow()
	end

	local TNum = Size/602
	if Size%602 ~= 0 then
		TNum = TNum + 1
	end
	local Arrindex = FuncAlloc

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(Arrindex);
		},
		flag = {Preserved}
	}

	for i = 2, TNum do 
		Trigger {
			players = {PlayerID},
			flag = {Preserved}
		}
	end

	FuncAlloc = FuncAlloc + 1
	return {"X",Arrindex,0,0}
end

function LDb(PlayerID,ByteSize)
	if bit32.band(ByteSize, 0xFFFFFFFF) >= 0x400000 or ByteSize == 0 then
		LDb_Size_Overflow()
	end
	return LArray(PlayerID,ByteSize/4)
end

function LArray(PlayerID,Size)
	if bit32.band(Size, 0xFFFFFFFF) >= 4096*151 or Size == 0 then
		LArray_Size_Overflow()
	end

	local TNum = math.ceil(Size/151)
	local Arrindex = FuncAlloc

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(Arrindex);
		},
		flag = {Preserved}
	}

	for i = 2, TNum do 
		Trigger {
			players = {PlayerID},
			flag = {Preserved}
		}
	end

	FuncAlloc = FuncAlloc + 1
	return {"X",Arrindex,0,0}
end

function CVArray(PlayerID,Size)
	if bit32.band(Size, 0xFFFFFFFF) >= 4096 or Size == 0 then
		VArray_Size_Overflow()
	end

	local VArrindex = FuncAlloc

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(VArrindex);
		},
		actions = {
			SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
			Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
		},
		flag = {Preserved}
	}

	for i = 2, Size do 
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
				Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
			},
			flag = {Preserved}
		}
	end

	FuncAlloc = FuncAlloc + 1
	return {"X",VArrindex,0,"V",0,Size}
end

function CWArray(PlayerID,Size)
	if bit32.band(Size, 0xFFFFFFFF) >= 4096 or Size == 0 then
		WArray_Size_Overflow()
	end

	local WArrindex = FuncAlloc

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(WArrindex);
		},
		actions = {
			SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
			Disabled(FSetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)); -- Cp Add (Must be Preserved)
			SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
			Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
		},
		flag = {Preserved}
	}

	for i = 2, Size do 
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
				Disabled(FSetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)); -- Cp Add (Must be Preserved)
				SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
				Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
			},
			flag = {Preserved}
		}
	end

	FuncAlloc = FuncAlloc + 1
	return {"X",WArrindex,0,"W",0,Size}
end

function SVArray(PlayerID,Size,Number)
	if Number <= 0 or Number >= 33 then
		SVariable_InputData_Error()
	end
	if bit32.band(Size, 0xFFFFFFFF) >= 4096 or Size == 0 then
		SVArray_Size_Overflow()
	end

	local SVArrindex = FuncAlloc
	local Box = {}
	for i = 2, Number do
		table.insert(Box,Disabled(FSetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)))
		table.insert(Box,SetDeathsX(0,SetTo,0,0,0xFFFFFFFF))
	end
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(SVArrindex);
		},
		actions = {
			SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable Lower 32
			Box,
			Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
		},
		flag = {Preserved}
	}
	for i = 2, Size do 
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable Lower 32
				Box,
				Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
			},
			flag = {Preserved}
		}
	end

	FuncAlloc = FuncAlloc + 1
	return {"X",SVArrindex,0,"SA",Number,Size}
end
-- DoActions류 함수 -------------------------------------------------------------------

function DoActions(PlayerID,Actions,Flags)
	if Flags == nil then
		Flags = {Preserved}
	end
	Trigger {
		players = {PlayerID},
		actions = {
			Actions,
		},
		flag = {
			Flags,
		},
	}
end

function __FlattenAct(Actions)
	local Ret = {}
	if type(Actions) == "table" and Actions.__trg_magic == "action" then
		Ret = {Actions}
	elseif Actions ~= nil then
		for k, v in pairs(Actions) do
			if type(k) == "number" and v ~= nil then
				if type(v) == "table" and v.__trg_magic == nil then
					v = __FlattenAct(v)
					for _, u in pairs(v) do
						table.insert(Ret,u)
					end
				elseif  v.__trg_magic == "action" then
					table.insert(Ret,v)
				else
					__FlattenAct_InputData_Error()
				end
			end
		end
	end
	return Ret
end

function DoActions2(PlayerID,Actions,Flags)
	local k = 1
	if Flags == nil then
		Flags = {Preserved}
	end

	local Act = __FlattenAct(Actions)
	Size = #Act

	while k <= Size do
		if Size - k + 1 >= 64 then
			local X = {}
			for i = 0, 63 do
				table.insert(X, Act[k])
				k = k + 1
			end
			Trigger {
					players = {PlayerID},
					actions = {
						X,
					},
					flag = {
						Flags,
					},
				}
		else
			local X = {}
			repeat
				table.insert(X, Act[k])
				k = k + 1
			until k == Size + 1
			Trigger {
					players = {PlayerID},
					actions = {
						X,
					},
					flag = {
						Flags,
					},
				}
		end
	end
end

function DoActionsX(PlayerID,Actions,Flags,Index)
	if Index == nil then
		Index = 0
	end
	if Flags == nil then
		Flags = {Preserved}
	end
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(Index);
		},
		actions = {
			Actions,
		},
		flag = {
			Flags,
		},
	}
end

function DoActions2X(PlayerID,Actions,Flags)
	local k = 1
	if Flags == nil then
		Flags = {Preserved}
	end

	local Act = __FlattenAct(Actions)
	Size = #Act

	while k <= Size do
		if Size - k + 1 >= 64 then
			local X = {}
			for i = 0, 63 do
				table.insert(X, Act[k])
				k = k + 1
			end
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						X,
					},
					flag = {
						Flags,
					},
				}
		else
			local X = {}
			repeat
				table.insert(X, Act[k])
				k = k + 1
			until k == Size + 1
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						X,
					},
					flag = {
						Flags,
					},
				}
		end
	end
end

function TriggerX(Player, Conditions, Actions, Flags, Index)
	if Index == nil then
		Index = 0
	end
	Trigger {
				players = {Player},
				conditions = {
					Label(Index);
					Conditions,
				},
				actions = {
					Actions,
				},
				flag = {
					Flags,
				}
			}
end

function Trigger2(Player, Conditions, Actions, Flags)
	local k = 1

	local Act = __FlattenAct(Actions)
	Size = #Act

	while k <= Size do
		if Size - k + 1 >= 64 then
			local X = {}
			for i = 0, 63 do
				table.insert(X, Act[k])
				k = k + 1
			end
			Trigger {
					players = {Player},
					conditions = {
						Conditions,
					},
					actions = {
						X,
					},
					flag = {
						Flags,
					}
				}
		else
			local X = {}
			repeat
				table.insert(X, Act[k])
				k = k + 1
			until k == Size + 1
			Trigger {
					players = {Player},
					conditions = {
						Conditions,
					},
					actions = {
						X,
					},
					flag = {
						Flags,
					}
				}
		end
	end
end

function Trigger2X(Player, Conditions, Actions, Flags)
	local k = 1

	local Act = __FlattenAct(Actions)
	Size = #Act

	while k <= Size do
		if Size - k + 1 >= 64 then
			local X = {}
			for i = 0, 63 do
				table.insert(X, Act[k])
				k = k + 1
			end
			Trigger {
					players = {Player},
					conditions = {
						Label(0);
						Conditions,
					},
					actions = {
						X,
					},
					flag = {
						Flags,
					}
				}
		else
			local X = {}
			repeat
				table.insert(X, Act[k])
				k = k + 1
			until k == Size + 1
			Trigger {
					players = {Player},
					conditions = {
						Label(0);
						Conditions,
					},
					actions = {
						X,
					},
					flag = {
						Flags,
					}
				}
		end
	end
end

-- Ctrig 구조체 트리거 (T,TT 삽입 가능) --
function __FlattenCCond(Conditions)
	local Ret = {}
	if type(Conditions) == "table" and Conditions.__trg_magic == "condition" then
		Ret = {Conditions}
	elseif Conditions ~= nil then
		for k, v in pairs(Conditions) do
			if type(k) == "number" and v ~= nil then
				if type(v) == "table" and v.__trg_magic == nil then
					v = __FlattenCCond(v)
					for _, u in pairs(v) do
						table.insert(Ret,u)
					end
				elseif (type(v) == "table" and v.__trg_magic == "condition") or type(v) == "string" then
					table.insert(Ret,v)
				else
					__FlattenCCond_InputData_Error()
				end
			end
		end
	end
	return Ret
end

function __FlattenCAct(Actions)
	local Ret = {}
	if type(Actions) == "table" and Actions.__trg_magic == "action" then
		Ret = {Actions}
	elseif Actions ~= nil then
		for k, v in pairs(Actions) do
			if type(k) == "number" and v ~= nil then
				if type(v) == "table" and v.__trg_magic == nil then
					v = __FlattenCAct(v)
					for _, u in pairs(v) do
						table.insert(Ret,u)
					end
				elseif  (type(v) == "table" and v.__trg_magic == "action") or type(v) == "string" then
					table.insert(Ret,v)
				else
					__FlattenCAct_InputData_Error()
				end
			end
		end
	end
	return Ret
end

function CDoActions(PlayerID,Actions,Flags,Index)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID)

	if Flags == nil then
		Flags = {Preserved}
	end

	if Index == nil or Index == "X" then
		Index = 0
	end

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(Index);
		},
		actions = {
			Actions,
		},
		flag = {
			Flags,
		}
	}
end

function CTrigger(PlayerID, Conditions, Actions, Flags, Index)
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)
	
	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID)

	if Flags == 1 then
		Flags = {Preserved}
	end
	if Index == nil or Index == "X" then
		Index = 0 
	end

	Trigger {
				players = {PlayerID},
				conditions = {
					Label(Index);
					Conditions,
				},
				actions = {
					Actions,
				},
				flag = {
					Flags,
				}
			}
		
end

-- Ctrig 파생 액션들 -------------------------------------------------------------------

function SetNext(Index1,Index2,Next)
	if Next == nil then
		Next = 0
	end
	local SetNext = SetCtrigX(nil,Index1,0x4,0,SetTo,nil,Index2,0x0,0,Next);
	return SetNext
end

function SetCJump(sIndex,Status,NewDest)
	local SetCJump 
	if NewDest == nil or NewDest == "X" then
		if Status == 1 or Status == "On" then
			SetCJump = SetNext(sIndex+JumpStartAlloc,sIndex+JumpEndAlloc,0)
		else
			SetCJump = SetNext(sIndex+JumpStartAlloc,sIndex+JumpStartAlloc,1)
		end
	else
		SetCJump = SetNext(sIndex+JumpStartAlloc,NewDest,0)
	end
	return SetCJump
end

function VariableX(Player,Index,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local VariableX = CtrigX(Player,Index,Addr,0,Type,Value,Mask)
	return VariableX
end

function SetVariableX(Player,Index,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local SetVariableX = SetCtrig1X(Player,Index,Addr,0,Type,Value,Mask)
	return SetVariableX
end

function Variable(Variable,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local VariableX = CtrigX(Variable[1],Variable[2],Addr,Variable[3],Type,Value,Mask)
	return VariableX
end

function SetVariable(Variable,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local SetVariableX = SetCtrig1X(Variable[1],Variable[2],Addr,Variable[3],Type,Value,Mask)
	return SetVariableX
end

function VArrayX(VArray,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if VArray[4] ~= "V" then
		VArrayX_InputData_Error()
	end

	local VArrayX = CtrigX(VArray[1],VArray[2],Addr,VArray[3],Type,Value,Mask)
	return VArrayX
end

function SetVArrayX(VArray,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if VArray[4] ~= "V" then
		SetVArrayX_InputData_Error()
	end

	local SetVArrayX = SetCtrig1X(VArray[1],VArray[2],Addr,VArray[3],Type,Value,Mask)
	return SetVArrayX
end

function WariableX(Player,Index,Section,Type,Value,Mask)
	local Check
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD" then
		Addr = 0x158
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value+1}
		elseif type(Value) == "table" and type(Value[2]) == "table" then
			Value = {Value[1],Value[1]+Value[2][1]}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Type" then
		Addr = 0x160
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF000000,0xFF000000}
		end
	elseif Section == "Value" then
		Addr = 0x15C
		Check = 1
		if type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Mask" then
		Addr = 0x148
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Flag" then
		Addr = 0x164
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF,0xFF}
		end
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		if Check == 1 then
			Mask = {0xFFFFFFFF,0xFFFFFFFF}
		else
			Mask = 0xFFFFFFFF
		end
	end

	local WariableX
	if Check ==  1 then
		WariableX = {CtrigX(Player,Index,Addr,0,Type,Value[1],Mask[1]),CtrigX(Player,Index,Addr+0x40,0,Type,Value[2],Mask[2])}
	else
		WariableX = CtrigX(Player,Index,Addr,0,Type,Value,Mask)
	end
	return WariableX
end

function SetWariableX(Player,Index,Section,Type,Value,Mask)
	local Check
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD" then
		Addr = 0x158
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value+1}
		elseif type(Value) == "table" and type(Value[2]) == "table" then
			Value = {Value[1],Value[1]+Value[2][1]}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Type" then
		Addr = 0x160
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF000000,0xFF000000}
		end
	elseif Section == "Value" then
		Addr = 0x15C
		Check = 1
		if type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Mask" then
		Addr = 0x148
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Flag" then
		Addr = 0x164
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF,0xFF}
		end
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		if Check == 1 then
			Mask = {0xFFFFFFFF,0xFFFFFFFF}
		else
			Mask = 0xFFFFFFFF
		end
	end

	local SetWariableX
	if Check ==  1 then
		SetWariableX = {SetCtrig1X(Player,Index,Addr,0,Type,Value[1],Mask[1]),SetCtrig1X(Player,Index,Addr+0x40,0,Type,Value[2],Mask[2])}
	else
		SetWariableX = SetCtrig1X(Player,Index,Addr,0,Type,Value,Mask)
	end
	return SetWariableX
end

function Wariable(Wariable,Section,Type,Value,Mask)
	local Check
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD" then
		Addr = 0x158
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value+1}
		elseif type(Value) == "table" and type(Value[2]) == "table" then
			Value = {Value[1],Value[1]+Value[2][1]}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Type" then
		Addr = 0x160
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF000000,0xFF000000}
		end
	elseif Section == "Value" then
		Addr = 0x15C
		Check = 1
		if type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Mask" then
		Addr = 0x148
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Flag" then
		Addr = 0x164
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF,0xFF}
		end
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		if Check == 1 then
			Mask = {0xFFFFFFFF,0xFFFFFFFF}
		else
			Mask = 0xFFFFFFFF
		end
	end

	local WariableX
	if Check ==  1 then
		WariableX = {CtrigX(Wariable[1],Wariable[2],Addr,Wariable[3],Type,Value[1],Mask[1]),CtrigX(Wariable[1],Wariable[2],Addr+0x40,Wariable[3],Type,Value[2],Mask[2])}
	else
		WariableX = CtrigX(Wariable[1],Wariable[2],Addr,Wariable[3],Type,Value,Mask)
	end
	return WariableX
end

function SetWariable(Wariable,Section,Type,Value,Mask)
	local Check
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD" then
		Addr = 0x158
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value+1}
		elseif type(Value) == "table" and type(Value[2]) == "table" then
			Value = {Value[1],Value[1]+Value[2][1]}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Type" then
		Addr = 0x160
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF000000,0xFF000000}
		end
	elseif Section == "Value" then
		Addr = 0x15C
		Check = 1
		if type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Mask" then
		Addr = 0x148
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Flag" then
		Addr = 0x164
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF,0xFF}
		end
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		if Check == 1 then
			Mask = {0xFFFFFFFF,0xFFFFFFFF}
		else
			Mask = 0xFFFFFFFF
		end
	end

	local SetWariableX
	if Check ==  1 then
		SetWariableX = {SetCtrig1X(Wariable[1],Wariable[2],Addr,Wariable[3],Type,Value[1],Mask[1]),SetCtrig1X(Wariable[1],Wariable[2],Addr+0x40,Wariable[3],Type,Value[2],Mask[2])}
	else
		SetWariableX = SetCtrig1X(Wariable[1],Wariable[2],Addr,Wariable[3],Type,Value,Mask)
	end
	return SetWariableX
end

function WArrayX(WArray,Section,Type,Value,Mask)
	local Check
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD" then
		Addr = 0x158
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value+1}
		elseif type(Value) == "table" and type(Value[2]) == "table" then
			Value = {Value[1],Value[1]+Value[2][1]}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Type" then
		Addr = 0x160
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF000000,0xFF000000}
		end
	elseif Section == "Value" then
		Addr = 0x15C
		Check = 1
		if type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Mask" then
		Addr = 0x148
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Flag" then
		Addr = 0x164
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF,0xFF}
		end
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		if Check == 1 then
			Mask = {0xFFFFFFFF,0xFFFFFFFF}
		else
			Mask = 0xFFFFFFFF
		end
	end

	if WArray[4] ~= "W" then
		WArrayX_InputData_Error()
	end

	local WArrayX
	if Check ==  1 then
		WArrayX = {CtrigX(WArray[1],WArray[2],Addr,WArray[3],Type,Value[1],Mask[1]),CtrigX(WArray[1],WArray[2],Addr+0x40,WArray[3],Type,Value[2],Mask[2])}
	else
		WArrayX = CtrigX(WArray[1],WArray[2],Addr,WArray[3],Type,Value,Mask)
	end
	return WArrayX
end

function SetWArrayX(WArray,Section,Type,Value,Mask)
	local Check
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD" then
		Addr = 0x158
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value+1}
		elseif type(Value) == "table" and type(Value[2]) == "table" then
			Value = {Value[1],Value[1]+Value[2][1]}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Type" then
		Addr = 0x160
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF000000,0xFF000000}
		end
	elseif Section == "Value" then
		Addr = 0x15C
		Check = 1
		if type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Mask" then
		Addr = 0x148
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		end
	elseif Section == "Flag" then
		Addr = 0x164
		Check = 1
		if type(Value) == "number" then
			Value = {Value,Value}
		elseif type(Value) == "string" then
			Value = I64(Value)
		end
		if type(Mask) == "number" then
			Mask = {Mask,Mask}
		elseif type(Mask) == "string" then
			Mask = I64(Mask)
		elseif Mask == nil then
			Mask = {0xFF,0xFF}
		end
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		if Check == 1 then
			Mask = {0xFFFFFFFF,0xFFFFFFFF}
		else
			Mask = 0xFFFFFFFF
		end
	end

	if WArray[4] ~= "W" then
		SetWArrayX_InputData_Error()
	end

	local SetWArrayX
	if Check ==  1 then
		SetWArrayX = {SetCtrig1X(WArray[1],WArray[2],Addr,WArray[3],Type,Value[1],Mask[1]),SetCtrig1X(WArray[1],WArray[2],Addr+0x40,WArray[3],Type,Value[2],Mask[2])}
	else
		SetWArrayX = SetCtrig1X(WArray[1],WArray[2],Addr,WArray[3],Type,Value,Mask)
	end
	return SetWArrayX
end

function SVariableX(Player,SVariable,Line,Section,Type,Value,Mask)
	if SVariable[1] ~= "S" then
		SVariableX_InputData_Error()
	end
	if Line <= 0 or Line >= 33 then
		SVariableX_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local SVariableX = CtrigX(Player,SVariable[2],Addr,0,Type,Value,Mask)
	return SVariableX
end

function SetSVariableX(Player,SVariable,Line,Section,Type,Value,Mask)
	if SVariable[1] ~= "S" then
		SetSVariableX_InputData_Error()
	end
	if Line <= 0 or Line >= 33 then
		SVariableX_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local SetSVariableX = SetCtrig1X(Player,SVariable[2],Addr,0,Type,Value,Mask)
	return SetSVariableX
end

function SVariable(SVData,Section,Type,Value,Mask)
	local Line = SVData[6]
	if SVData[4] ~= "SV" then
		SVariable_InputData_Error()
	end
	if Line <= 0 or Line >= 33 then
		SVariable_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local SVariable = CtrigX(SVData[1],SVData[2],Addr,SVData[3],Type,Value,Mask)
	return SVariable
end

function SetSVariable(SVData,Section,Type,Value,Mask)
	local Line = SVData[6]
	if SVData[4] ~= "SV" then
		SVariable_InputData_Error()
	end
	if Line <= 0 or Line >= 33 then
		SVariable_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local SetSVariable = SetCtrig1X(SVData[1],SVData[2],Addr,SVData[3],Type,Value,Mask)
	return SetSVariable
end

function SVArrayX(SVArray,Section,Type,Value,Mask)
	local Line = SVArray[6]
	if SVArray[4] ~= "SV" then
		SVArrayX_InputData_Error()
	end
	if Line <= 0 or Line >= 33 then
		SVArrayX_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local SVArrayX = CtrigX(SVArray[1],SVArray[2],Addr,SVArray[3],Type,Value,Mask)
	return SVArrayX
end

function SetSVArrayX(SVArray,Section,Type,Value,Mask)
	local Line = SVArray[6]
	if SVArray[4] ~= "SV" then
		SetSVArrayX_InputData_Error()
	end
	if Line <= 0 or Line >= 33 then
		SetSVArrayX_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local SetSVArrayX = SetCtrig1X(SVArray[1],SVArray[2],Addr,SVArray[3],Type,Value,Mask)
	return SetSVArrayX
end

function MemX(Mem,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if type(Mem[4]) == "string" then
		MemX_InputData_Error()
	end

	local MemX = CtrigX(Mem[1],Mem[2],Mem[3],Mem[4],Type,Value,Mask)
	return MemX
end

function SetMemX(Mem1,Type,Mem2,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local SetMemX
	if type(Mem1) == "table" and type(Mem2) == "number" then
		SetMemX = SetCtrig1X(Mem1[1],Mem1[2],Mem1[3],Mem1[4],Type,Mem2,Mask)
	elseif type(Mem1) == "number" and type(Mem2) == "table" then
		SetMemX = SetCtrig2X(Mem1,Type,Mem2[1],Mem2[2],Mem2[3],Mem2[5],Mem2[4],Mask)
	elseif type(Mem1) == "table" and type(Mem2) == "table" then
		SetMemX = SetCtrigX(Mem1[1],Mem1[2],Mem1[3],Mem1[4],Type,Mem2[1],Mem2[2],Mem2[3],Mem2[5],Mem2[4],Mask)
	else
		SetMemX_InputData_Error()
	end
	
	return SetMemX
end

function LMemX(LMem,Type,Value,Mask)
	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	end

	if type(LMem[4]) == "string" then
		LMemX_InputData_Error()
	end

	if type(Type) == "number" then
		Type = {Type,Type}
	end
	if type(Value) == "number" then
		Value = {Value,Value}
	elseif type(Value) == "string" then
		Value = I64(Value)
	end
	if type(Mask) == "number" then
		Mask = {Mask,Mask}
	elseif type(Mask) == "string" then
		Mask = I64(Mask)
	end

	local LMemX = {CtrigX(LMem[1][1],LMem[1][2],LMem[1][3],LMem[1][4],Type[1],Value[1],Mask[1]),CtrigX(LMem[2][1],LMem[2][2],LMem[2][3],LMem[2][4],Type[2],Value[2],Mask[2])}
	return LMemX
end

function SetLMemX(LMem1,Type,LMem2,Mask)
	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	end

	local SetLMemX
	if type(Type) == "number" then
		Type = {Type,Type}
	end
	if type(Mask) == "number" then
		Mask = {Mask,Mask}
	elseif type(Mask) == "string" then
		Mask = I64(Mask)
	end

	if type(LMem1) == "string" then
		LMem1 = I64(LMem1)
	end
	if type(LMem2) == "string" then
		LMem2 = I64(LMem2)
	end
	if type(LMem1) == "number" then
		LMem1 = {LMem1,LMem1+0x4}
	end
	if type(LMem2) == "number" then
		LMem2 = {LMem2,LMem2}
	end

	if (type(LMem1[1]) == "table" and type(LMem1[2]) == "table") and (type(LMem2[1]) == "number" and type(LMem2[2]) == "number") then
		SetLMemX = {SetCtrig1X(LMem1[1][1],LMem1[1][2],LMem1[1][3],LMem1[1][4],Type[1],LMem2[1],Mask[1]),SetCtrig1X(LMem1[2][1],LMem1[2][2],LMem1[2][3],LMem1[2][4],Type[2],LMem2[2],Mask[2])}
	elseif (type(LMem1[1]) == "number" and type(LMem1[2]) == "number") and (type(LMem2[1]) == "table" and type(LMem2[2]) == "table") then
		SetLMemX = {SetCtrig2X(LMem1[1],Type[1],LMem2[1][1],LMem2[1][2],LMem2[1][3],LMem2[1][5],LMem2[1][4],Mask[1]),SetCtrig2X(LMem1[2],Type[2],LMem2[2][1],LMem2[2][2],LMem2[2][3],LMem2[2][5],LMem2[2][4],Mask[2])}
	elseif (type(LMem1[1]) == "table" and type(LMem1[2]) == "table") and (type(LMem2[1]) == "table" and type(LMem2[2]) == "table") then
		SetLMemX = {SetCtrigX(LMem1[1][1],LMem1[1][2],LMem1[1][3],LMem1[1][4],Type[1],LMem2[1][1],LMem2[1][2],LMem2[1][3],LMem2[1][5],LMem2[1][4],Mask[1]),SetCtrigX(LMem1[2][1],LMem1[2][2],LMem1[2][3],LMem1[2][4],Type[2],LMem2[2][1],LMem2[2][2],LMem2[2][3],LMem2[2][5],LMem2[2][4],Mask[2])}
	else
		SetLMemX_InputData_Error()
	end

	return SetLMemX
end

function CVar(Player,Index,Type,Value,Mask)
	return VariableX(Player,Index,"Value",Type,Value,Mask)
end

function SetCVar(Player,Index,Type,Value,Mask)
	return SetVariableX(Player,Index,"Value",Type,Value,Mask)
end

function NVar(Variable,Type,Value,Mask)
	return VariableX(Variable[1],Variable[2],"Value",Type,Value,Mask)
end

function SetNVar(Variable,Type,Value,Mask)
	return SetVariableX(Variable[1],Variable[2],"Value",Type,Value,Mask)
end

function CVAar(VArray,Type,Value,Mask)
	return VArrayX(VArray,"Value",Type,Value,Mask)
end

function SetCVAar(VArray,Type,Value,Mask)
	return SetVArrayX(VArray,"Value",Type,Value,Mask)
end

function CWar(Player,Index,Type,Value,Mask)
	if type(Value) == "number" then
		return WariableX(Player,Index,"Value1",Type,Value,Mask)
	elseif type(Value) == "table" and Value[2] == nil then
		return WariableX(Player,Index,"Value2",Type,Value[1],Mask)
	else
		return WariableX(Player,Index,"Value",Type,Value,Mask)
	end
end

function SetCWar(Player,Index,Type,Value,Mask)
	if type(Value) == "number" then
		return SetWariableX(Player,Index,"Value1",Type,Value,Mask)
	elseif type(Value) == "table" and Value[2] == nil then
		return SetWariableX(Player,Index,"Value2",Type,Value[1],Mask)
	else
		return SetWariableX(Player,Index,"Value",Type,Value,Mask)
	end
end

function NWar(Wariable,Type,Value,Mask)
	if type(Value) == "number" then
		return WariableX(Wariable[1],Wariable[2],"Value1",Type,Value,Mask)
	elseif type(Value) == "table" and Value[2] == nil then
		return WariableX(Wariable[1],Wariable[2],"Value2",Type,Value[1],Mask)
	else
		return WariableX(Wariable[1],Wariable[2],"Value",Type,Value,Mask)
	end
end

function SetNWar(Wariable,Type,Value,Mask)
	if type(Value) == "number" then
		return SetWariableX(Wariable[1],Wariable[2],"Value1",Type,Value,Mask)
	elseif type(Value) == "table" and Value[2] == nil then
		return SetWariableX(Wariable[1],Wariable[2],"Value2",Type,Value[1],Mask)
	else
		return SetWariableX(Wariable[1],Wariable[2],"Value",Type,Value,Mask)
	end
end

function CWAar(WArray,Type,Value,Mask)
	if type(Value) == "number" then
		return WArrayX(WArray,"Value1",Type,Value,Mask)
	elseif type(Value) == "table" and Value[2] == nil then
		return WArrayX(WArray,"Value2",Type,Value[1],Mask)
	else
		return WArrayX(WArray,"Value",Type,Value,Mask)
	end
end

function SetCWAar(WArray,Type,Value,Mask)
	if type(Value) == "number" then
		return SetWArrayX(WArray,"Value1",Type,Value,Mask)
	elseif type(Value) == "table" and Value[2] == nil then
		return SetWArrayX(WArray,"Value2",Type,Value[1],Mask)
	else
		return SetWArrayX(WArray,"Value",Type,Value,Mask)
	end
end

function CSVar(Player,SVariable,Line,Type,Value,Mask)
	return SVariableX(Player,SVariable,Line,"Value",Type,Value,Mask)
end

function SetCSVar(Player,SVariable,Line,Type,Value,Mask)
	return SetSVariableX(Player,SVariable,Line,"Value",Type,Value,Mask)
end

function NSVar(SVData,Type,Value,Mask)
	return SVariable(SVData,"Value",Type,Value,Mask)
end

function SetNSVar(SVData,Type,Value,Mask)
	return SetSVariable(SVData,"Value",Type,Value,Mask)
end

function CSVAar(SVArray,Type,Value,Mask)
	return SVArrayX(SVArray,"Value",Type,Value,Mask)
end

function SetCSVAar(SVArray,Type,Value,Mask)
	return SetSVArrayX(SVArray,"Value",Type,Value,Mask)
end

function CSVA1(SVA1,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local CSVA1 = CtrigX(SVA1[1],SVA1[2],0x15C,SVA1[5]+SVA1[3],Type,Value,Mask)
	return CSVA1
end

function SetCSVA1(SVA1,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local SetCSVA1 = SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[5]+SVA1[3],Type,Value,Mask)
	return SetCSVA1
end

function TCSVA1(SVA1,Type,Value,Mask)
	local PushLine = 0
	local TypeNum = 0
	if type(Mask) == "table" then
		if Mask[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Mask})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Mask = TempData
		end

		if Mask[4] == "V" then
			if Mask[5] == nil then
				Mask[5] = 0
			end
			local X = {CallLabelAlways(Mask[1],Mask[2],Mask[3]),
					SetCtrig1X(Mask[1],Mask[2],0x148,Mask[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Mask[1],Mask[2],0x160,Mask[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Mask[1],Mask[2],0x158,Mask[3],SetTo,"X","X",0x8,1,0),
					SetCtrig1X("X","X",0x8,0,SetTo,Mask[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Mask = 0
			PushLine = PushLine + 1
		else
			TMemoryX_InputData_Error()
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			if type(Value[5]) == "number" then
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
						SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Value = 0
				PushLine = PushLine + 1
			else
				if Value[5][5] == nil then
					Value[5][5] = 0
				end
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
						SetCtrigX("X","X",0x10,0,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Value = 0
				PushLine = PushLine + 1
			end
		else
			TMemoryX_InputData_Error()
		end
	end

	if SVA1[4] == "VA" then
		if SVA1[5][5] == nil then
			SVA1[5][5] = 0
		end
		local X = {CallLabelAlways(SVA1[5][1],SVA1[5][2],SVA1[5][3]),
				SetCtrig1X(SVA1[5][1],SVA1[5][2],0x148,SVA1[5][3],SetTo,0xFFFFFFFF),
				SetCtrig1X(SVA1[5][1],SVA1[5][2],0x160,SVA1[5][3],SetTo,Add*16777216,0xFF000000),
				SetCtrigX(SVA1[5][1],SVA1[5][2],0x158,SVA1[5][3],SetTo,"X","X",0xC,1,0),
				SetCtrigX("X","X",0xC,0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+SVA1[5][5])}

		table.insert(PushTrigArr,X)
		PushTrigStack = PushTrigStack + 1
		SVA1 = 0x58A364
		PushLine = PushLine + 1
	else -- Mem
		TypeNum = TypeNum + 1
	end

	local TCSVA1 
	if TypeNum == 0 then
		TCSVA1 = FMemoryX(SVA1,Type,Value,Mask)
	elseif TypeNum == 1 then
		TCSVA1 = CtrigX(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5],Type,Value,Mask)
	end 
	table.insert(PushCondArr,TCSVA1)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TSetCSVA1(SVA1,Type,Value,Mask)
	local PushLine = 0
	local TypeNum = 0
	if type(Mask) == "table" then
		if Mask[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Mask})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Mask = TempData
		end

		if Mask[4] == "V" then
			if Mask[5] == nil then
				Mask[5] = 0
			end
			local X = {CallLabelAlways(Mask[1],Mask[2],Mask[3]),
					SetCtrig1X(Mask[1],Mask[2],0x148,Mask[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Mask[1],Mask[2],0x160,Mask[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Mask[1],Mask[2],0x158,Mask[3],SetTo,"X","X",0x128,1,0),
					SetCtrig1X("X","X",0x128,0,SetTo,Mask[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Mask = 0
			PushLine = PushLine + 1
		else
			TSetMemoryX_InputData_Error()
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			if type(Value[5]) == "number" then
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
						SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
				
				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Value = 0
				PushLine = PushLine + 1
			else
				if Value[5][5] == nil then
					Value[5][5] = 0
				end
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
						SetCtrigX("X","X",0x13C,0,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4])}
				
				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Value = 0
				PushLine = PushLine + 1
			end
		else
			TypeNum = TypeNum + 2
		end
	end

	if SVA1[4] == "VA" then
		if SVA1[5][5] == nil then
			SVA1[5][5] = 0
		end
		local X = {CallLabelAlways(SVA1[5][1],SVA1[5][2],SVA1[5][3]),
						SetCtrig1X(SVA1[5][1],SVA1[5][2],0x148,SVA1[5][3],SetTo,0xFFFFFFFF),
						SetCtrig1X(SVA1[5][1],SVA1[5][2],0x160,SVA1[5][3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(SVA1[5][1],SVA1[5][2],0x158,SVA1[5][3],SetTo,"X","X",0x138,1,0),
						SetCtrigX("X","X",0x138,0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+SVA1[5][5])}

		table.insert(PushTrigArr,X)
		PushTrigStack = PushTrigStack + 1
		SVA1 = 0x58A364
		PushLine = PushLine + 1
	else -- Mem
		TypeNum = TypeNum + 1
	end

	local TSetCSVA1
	if TypeNum == 0 then
		TSetCSVA1 = FSetMemoryX(SVA1,Type,Value,Mask)
	elseif TypeNum == 1 then
		TSetCSVA1 = SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5],Type,Value,Mask)
	elseif TypeNum == 2 then
		TSetCSVA1 = SetCtrig2X(SVA1,Type,Value[1],Value[2],Value[3],Value[5],Value[4],Mask)
	elseif TypeNum == 3 then
		TSetCSVA1 = SetCtrigX(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5],Type,Value[1],Value[2],Value[3],Value[5],Value[4],Mask)
	end 
	table.insert(PushActArr,TSetCSVA1)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TTCSVA1(SVA1,Type,Value,Mask)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	else
		TTMemoryX_TypeError()
	end
	local TypeNum = 0
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0
	if type(Mask) == "table" then
		if Mask[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Mask})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Mask = TempData
		end
		if Mask[4] == "V" then
			if Mask[5] == nil then
				Mask[5] = 0
			end
			local X = {CallLabelAlways(Mask[1],Mask[2],Mask[3]),
						SetCtrig1X(Mask[1],Mask[2],0x148,Mask[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Mask[1],Mask[2],0x160,Mask[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Mask[1],Mask[2],0x158,Mask[3],SetTo,"X","X",0x1C,1,0),
						SetCtrig1X("X","X",0x1C,0,SetTo,Mask[5])}
			Z = Z + 1
			table.insert(Y,X)
			Mask = 0
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end


		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			if type(Value[5]) == "number" then
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
							SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
				Z = Z + 1
				table.insert(Y,X)
				Value = 0
			else
				if Value[5][5] == nil then
					Value[5][5] = 0
				end
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
							SetCtrigX("X","X",0x24,0,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4])}
				Z = Z + 1
				table.insert(Y,X)
				Value = 0
			end
		end
	end

	if SVA1[4] == "VA" then
		if SVA1[5][5] == nil then
			SVA1[5][5] = 0
		end
			
		local X = {CallLabelAlways(SVA1[5][1],SVA1[5][2],SVA1[5][3]),
				SetCtrig1X(SVA1[5][1],SVA1[5][2],0x148,SVA1[5][3],SetTo,0xFFFFFFFF),
				SetCtrig1X(SVA1[5][1],SVA1[5][2],0x160,SVA1[5][3],SetTo,Add*16777216,0xFF000000),
				SetCtrigX(SVA1[5][1],SVA1[5][2],0x158,SVA1[5][3],SetTo,"X","X",0x20,1,0),
				SetCtrigX("X","X",0x20,0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+SVA1[5][5])}
		Z = Z + 1
		table.insert(Y,X)
		SVA1 = 0x58A364
	else
		TypeNum = 1
	end

	local TTCSVA2
	if TypeNum == 0 then
		TTCSVA2 = FMemoryX(SVA1,Exactly,Value,Mask)
	elseif TypeNum == 1 then
		TTCSVA2 = CtrigX(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5],Exactly,Value,Mask)
	end 
	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,TTCSVA2)
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTCSVA1 = CDeaths("X",Exactly,1,FCode)
	return TTCSVA1
end

function _TCSVA1(SVA1,Type,Value,Mask)
	return {"T","TCSVA1",SVA1,Type,Value,Mask}
end

function _TTCSVA1(SVA1,Type,Value,Mask)
	return {"TT","TTCSVA1",SVA1,Type,Value,Mask}
end

-- 확장 데스값 --

function _Ccode(Player,Code,EPDflag) -- Convert(CDeaths Data -> Ctrig Mem Data)
	if EPDflag == "X" or EPDflag == nil or EPDflag == 0 then
		EPDflag = nil
	else
		EPDflag = 1
	end
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)
	return {Player,Index,0x1C8+0x4*Line,0,EPDflag}
end

function _Ncode(Player,Code,EPDflag) -- Convert(NDeaths Data -> Ctrig Mem Data)
	if EPDflag == "X" or EPDflag == nil or EPDflag == 0 then
		EPDflag = nil
	else
		EPDflag = 1
	end
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if type(Player) == "number" then
		return {FixPlayer,Index,0x1C8+0x20*Line+0x4*Player,0,EPDflag}
	elseif Player[4] == "V" then
		return {Player[1],Player[2],Player[3],"V",{FixPlayer,Index,0x1C8+0x20*Line,0,EPDflag}}
	end
end

function CDeathsX(Player,Type,Value,Code,Mask)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 480 or Line < 0 then
		CDeathX_LineOverflow()
	end
	local CDeathsX = CtrigX(Player,Index,0x1C8+0x4*Line,0,Type,Value,Mask)
	return CDeathsX
end

function CDeaths(Player,Type,Value,Code)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 480 or Line < 0 then
		CDeath_LineOverflow()
	end
	local CDeaths = CtrigX(Player,Index,0x1C8+0x4*Line,0,Type,Value)
	return CDeaths
end

function SetCDeathsX(Player,Type,Value,Code,Mask)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 480 or Line < 0 then
		SetCDeathsX_LineOverflow()
	end
	local SetCDeathsX = SetCtrig1X(Player,Index,0x1C8+0x4*Line,0,Type,Value,Mask)
	return SetCDeathsX
end

function SetCDeaths(Player,Type,Value,Code)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 480 or Line < 0 then
		SetCDeaths_LineOverflow()
	end
	local SetCDeaths = SetCtrig1X(Player,Index,0x1C8+0x4*Line,0,Type,Value)
	return SetCDeaths
end

function NDeathsX(Player,Type,Value,Code,Mask)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 60 or Line < 0 then
		NDeathX_LineOverflow()
	end
	local NDeathsX = CtrigX(FixPlayer,Index,0x1C8+0x20*Line+0x4*Player,0,Type,Value,Mask)
	return NDeathsX
end

function NDeaths(Player,Type,Value,Code)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 60 or Line < 0 then
		NDeath_LineOverflow()
	end
	local NDeaths = CtrigX(FixPlayer,Index,0x1C8+0x20*Line+0x4*Player,0,Type,Value)
	return NDeaths
end

function SetNDeathsX(Player,Type,Value,Code,Mask)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 60 or Line < 0 then
		SetNDeathsX_LineOverflow()
	end
	local SetNDeathsX = SetCtrig1X(FixPlayer,Index,0x1C8+0x20*Line+0x4*Player,0,Type,Value,Mask)
	return SetNDeathsX
end

function SetNDeaths(Player,Type,Value,Code)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 60 or Line < 0 then
		SetNDeaths_LineOverflow()
	end
	local SetNDeaths = SetCtrig1X(FixPlayer,Index,0x1C8+0x20*Line+0x4*Player,0,Type,Value)
	return SetNDeaths
end

-- 데이터 읽기 관련 함수 (Read) ---------------------------------------------------------

function SafeReadX(PlayerID,Input,Output,Mask,EPDRead) -- CRead 1 -> N 
	if type(Input) == "table" then
		if Input[4] == "VA" or Input[4] == "A" then
			SafeReadX_InputData_Error()
		end
	end
	if type(Output) == "number" then
		Output = {Output}
	end

	if Mask == "X" or Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if EPDRead == "X" then
		EPDRead = nil
	end
	if EPDRead == nil then
		local EPDArr = {} 

		for k, v in pairs(Output) do
			if type(v) == "table" then
				if v[4] == "VA" or v[4] == "A" then
					SafeReadX_InputData_Error()
				end
			end
			if type(v) == "number" then 
				table.insert(EPDArr,SetMemoryX(v,SetTo,0,Mask))
			elseif v == "Cp" then
				table.insert(EPDArr,SetDeathsX(CurrentPlayer,SetTo,0,0,Mask))
			elseif v[4] == "V" then				
				table.insert(EPDArr,SetCtrig1X(v[1],v[2],0x15C,v[3],SetTo,0,Mask))
			else
				table.insert(EPDArr,SetCtrig1X(v[1],v[2],v[3],v[4],SetTo,0,Mask))
			end
		end
		Trigger {
			players = {PlayerID},
			conditions = {
		   		 Label(0);
			},
			actions = {
				EPDArr,
			},
			flag = {Preserved}
		}

		for i = 0, 31 do
			local CBit = bit32.band(Mask, 2^i)
			if CBit == 2^i then
				local InputArr = {}
				local OutputArr = {}

				if type(Input) == "number" then 
					InputArr = {MemoryX(Input,Exactly,CBit,CBit)}
				elseif Input == "Cp" then
					InputArr = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
				elseif Input[4] == "V" then
					InputArr = {CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,CBit,CBit)}
				else
					InputArr = {CtrigX(Input[1],Input[2],Input[3],Input[4],Exactly,CBit,CBit)}
				end

				for k, v in pairs(Output) do
					if type(v) == "table" then
						if v[4] == "VA" or v[4] == "A" then
							SafeReadX_InputData_Error()
						end
					end
					if type(v) == "number" then 
						table.insert(OutputArr,SetMemoryX(v,SetTo,CBit,CBit))
					elseif v == "Cp" then
						table.insert(OutputArr,SetDeathsX(CurrentPlayer,SetTo,CBit,0,CBit))
					elseif v[4] == "V" then
						table.insert(OutputArr,SetCtrig1X(v[1],v[2],0x15C,v[3],SetTo,CBit,CBit))
					else
						table.insert(OutputArr,SetCtrig1X(v[1],v[2],v[3],v[4],SetTo,CBit,CBit))
					end
				end

				Trigger {
					players = {PlayerID},
					conditions = {
				   		 Label(0);
						 InputArr,
					},
					actions = {
						OutputArr,
					},
					flag = {Preserved}
				}
			end
		end
	else
		local EPDArr = {} 

		for k, v in pairs(Output) do
			if type(v) == "table" then
				if v[4] == "VA" or v[4] == "A" then
					SafeReadX_InputData_Error()
				end
			end
			if type(v) == "number" then 
				table.insert(EPDArr,SetMemory(v,SetTo,-1452249))
			elseif v == "Cp" then
				table.insert(EPDArr,SetDeaths(CurrentPlayer,SetTo,-1452249,0))
			elseif v[4] == "V" then				
				table.insert(EPDArr,SetCtrig1X(v[1],v[2],0x15C,v[3],SetTo,-1452249))
			else
				table.insert(EPDArr,SetCtrig1X(v[1],v[2],v[3],v[4],SetTo,-1452249))
			end
		end
		Trigger {
			players = {PlayerID},
			conditions = {
		   		 Label(0);
			},
			actions = {
				EPDArr,
			},
			flag = {Preserved}
		}

		for i = 2, 31 do
			local CBit = bit32.band(Mask, 2^i)
			if CBit == 2^i then
				
				local InputArr = {}
				local OutputArr = {}
				local EBit = CBit / 4

				if type(Input) == "number" then 
					InputArr = {MemoryX(Input,Exactly,CBit,CBit)}
				elseif Input == "Cp" then
					InputArr = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
				elseif Input[4] == "V" then
					InputArr = {CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,CBit,CBit)}
				else
					InputArr = {CtrigX(Input[1],Input[2],Input[3],Input[4],Exactly,CBit,CBit)}
				end

				for k, v in pairs(Output) do
					if type(v) == "table" then
						if v[4] == "VA" or v[4] == "A" then
							SafeReadX_InputData_Error()
						end
					end
					if type(v) == "number" then 
						table.insert(OutputArr,SetMemory(v,Add,EBit))
					elseif v == "Cp" then
						table.insert(OutputArr,SetDeaths(CurrentPlayer,Add,EBit,0))
					elseif v[4] == "V" then
						table.insert(OutputArr,SetCtrig1X(v[1],v[2],0x15C,v[3],Add,EBit))
					else
						table.insert(OutputArr,SetCtrig1X(v[1],v[2],v[3],v[4],Add,EBit))
					end
				end

				Trigger {
					players = {PlayerID},
					conditions = {
				   		 Label(0);
						 InputArr,
					},
					actions = {
						OutputArr,
					},
					flag = {Preserved}
				}
			end
		end
	end
end

function UnitReadX(PlayerID,Player,UnitId,Loc,Output,AtMostflag) -- Binary Bring/Command Read
	STPopTrigArr(PlayerID)
	if AtMostflag == nil or AtMostflag == "X" then
		AtMostflag = 0
	end 
	if type(Output) == "table" then
		if Output[4] == "VA" or Output[4] == "A" then
			UnitReadX_InputData_Error()
		end
	end
	if Output == nil or Output == "X" then
		Output = V(CRet[1],"X",0)
	end
	if Loc == "X" then
		Loc = nil
	end

	if type(Player) == "table" and Player[4] == "V" then
		if Player[5] == nil then
			Player[5] = 0
		end
		
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				CallLabelAlways(Player[1],Player[2],Player[3]);
				SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
				SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
				SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x15C,1,1),
				SetCtrig1X("X","X",0x15C,1,SetTo,Player[5]);

				SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2);
				SetCtrigX("X","X",0x158+0x20*0,1,SetTo,"X","X",0x15C+0x20*1,1,1);
				SetCtrigX("X","X",0x158+0x20*1,1,SetTo,"X","X",0x15C+0x20*2,1,1);
				SetCtrigX("X","X",0x158+0x20*2,1,SetTo,"X","X",0x15C+0x20*3,1,1);
				SetCtrigX("X","X",0x158+0x20*3,1,SetTo,"X","X",0x15C+0x20*4,1,1);
				SetCtrigX("X","X",0x158+0x20*4,1,SetTo,"X","X",0x15C+0x20*5,1,1);
				SetCtrigX("X","X",0x158+0x20*5,1,SetTo,"X","X",0x15C+0x20*6,1,1);
				SetCtrigX("X","X",0x158+0x20*6,1,SetTo,"X","X",0x15C+0x20*7,1,1);
				SetCtrigX("X","X",0x158+0x20*7,1,SetTo,"X","X",0x15C+0x20*8,1,1);
				SetCtrigX("X","X",0x158+0x20*8,1,SetTo,"X","X",0x15C+0x20*9,1,1);
				SetCtrigX("X","X",0x158+0x20*9,1,SetTo,"X","X",0x15C+0x20*10,1,1);
				SetCtrigX("X","X",0x158+0x20*10,1,SetTo,"X","X",0x15C+0x20*11,1,1);	
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetDeaths(0,SetTo,0,0);
				SetDeaths(0,SetTo,0,0);
				SetDeaths(0,SetTo,0,0);
				SetDeaths(0,SetTo,0,0);
				SetDeaths(0,SetTo,0,0);
				SetDeaths(0,SetTo,0,0);
				SetDeaths(0,SetTo,0,0);
				SetDeaths(0,SetTo,0,0);
				SetDeaths(0,SetTo,0,0);
				SetDeaths(0,SetTo,0,0);
				SetDeaths(0,SetTo,0,0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1);
				SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1);
				SetCtrigX("X","X",0x158+0x20*0,-1,SetTo,"X",IndexAlloc,0x20,1,1);
				SetCtrigX("X","X",0x158+0x20*1,-1,SetTo,"X",IndexAlloc,0x20,1,2);
				SetCtrigX("X","X",0x158+0x20*2,-1,SetTo,"X",IndexAlloc,0x20,1,3);
				SetCtrigX("X","X",0x158+0x20*3,-1,SetTo,"X",IndexAlloc,0x20,1,4);
				SetCtrigX("X","X",0x158+0x20*4,-1,SetTo,"X",IndexAlloc,0x20,1,5);
				SetCtrigX("X","X",0x158+0x20*5,-1,SetTo,"X",IndexAlloc,0x20,1,6);
				SetCtrigX("X","X",0x158+0x20*6,-1,SetTo,"X",IndexAlloc,0x20,1,7);
				SetCtrigX("X","X",0x158+0x20*7,-1,SetTo,"X",IndexAlloc,0x20,1,8);
				SetCtrigX("X","X",0x158+0x20*8,-1,SetTo,"X",IndexAlloc,0x20,1,9);
				SetCtrigX("X","X",0x158+0x20*9,-1,SetTo,"X",IndexAlloc,0x20,1,10);
				SetCtrigX("X","X",0x158+0x20*10,-1,SetTo,"X",IndexAlloc,0x20,1,11);	
			},
			flag = {Preserved}
		}
		Player = 0
	end

	if type(UnitId) == "table" and UnitId[4] == "V" then
		if UnitId[5] == nil then
			UnitId[5] = 0
		end
		
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]);
				SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFFFFFF),
				SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
				SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x15C,1,1),
				SetCtrig1X("X","X",0x15C,1,SetTo,UnitId[5]);

				SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2);
				SetCtrigX("X","X",0x158+0x20*0,1,SetTo,"X","X",0x15C+0x20*1,1,1);
				SetCtrigX("X","X",0x158+0x20*1,1,SetTo,"X","X",0x15C+0x20*2,1,1);
				SetCtrigX("X","X",0x158+0x20*2,1,SetTo,"X","X",0x15C+0x20*3,1,1);
				SetCtrigX("X","X",0x158+0x20*3,1,SetTo,"X","X",0x15C+0x20*4,1,1);
				SetCtrigX("X","X",0x158+0x20*4,1,SetTo,"X","X",0x15C+0x20*5,1,1);
				SetCtrigX("X","X",0x158+0x20*5,1,SetTo,"X","X",0x15C+0x20*6,1,1);
				SetCtrigX("X","X",0x158+0x20*6,1,SetTo,"X","X",0x15C+0x20*7,1,1);
				SetCtrigX("X","X",0x158+0x20*7,1,SetTo,"X","X",0x15C+0x20*8,1,1);
				SetCtrigX("X","X",0x158+0x20*8,1,SetTo,"X","X",0x15C+0x20*9,1,1);
				SetCtrigX("X","X",0x158+0x20*9,1,SetTo,"X","X",0x15C+0x20*10,1,1);
				SetCtrigX("X","X",0x158+0x20*10,1,SetTo,"X","X",0x15C+0x20*11,1,1);	
			},
			flag = {Preserved}
		}
		
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetDeathsX(0,SetTo,0,0,0xFFFF);
				SetDeathsX(0,SetTo,0,0,0xFFFF);
				SetDeathsX(0,SetTo,0,0,0xFFFF);
				SetDeathsX(0,SetTo,0,0,0xFFFF);
				SetDeathsX(0,SetTo,0,0,0xFFFF);
				SetDeathsX(0,SetTo,0,0,0xFFFF);
				SetDeathsX(0,SetTo,0,0,0xFFFF);
				SetDeathsX(0,SetTo,0,0,0xFFFF);
				SetDeathsX(0,SetTo,0,0,0xFFFF);
				SetDeathsX(0,SetTo,0,0,0xFFFF);
				SetDeathsX(0,SetTo,0,0,0xFFFF);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1);
				SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1);
				SetCtrigX("X","X",0x158+0x20*0,-1,SetTo,"X",IndexAlloc,0x28,1,1);
				SetCtrigX("X","X",0x158+0x20*1,-1,SetTo,"X",IndexAlloc,0x28,1,2);
				SetCtrigX("X","X",0x158+0x20*2,-1,SetTo,"X",IndexAlloc,0x28,1,3);
				SetCtrigX("X","X",0x158+0x20*3,-1,SetTo,"X",IndexAlloc,0x28,1,4);
				SetCtrigX("X","X",0x158+0x20*4,-1,SetTo,"X",IndexAlloc,0x28,1,5);
				SetCtrigX("X","X",0x158+0x20*5,-1,SetTo,"X",IndexAlloc,0x28,1,6);
				SetCtrigX("X","X",0x158+0x20*6,-1,SetTo,"X",IndexAlloc,0x28,1,7);
				SetCtrigX("X","X",0x158+0x20*7,-1,SetTo,"X",IndexAlloc,0x28,1,8);
				SetCtrigX("X","X",0x158+0x20*8,-1,SetTo,"X",IndexAlloc,0x28,1,9);
				SetCtrigX("X","X",0x158+0x20*9,-1,SetTo,"X",IndexAlloc,0x28,1,10);
				SetCtrigX("X","X",0x158+0x20*10,-1,SetTo,"X",IndexAlloc,0x28,1,11);	
			},
			flag = {Preserved}
		}
		UnitId = 0
	end

	if type(Loc) == "table" and Loc[4] == "V" then
		if Loc[5] == nil then
			Loc[5] = 0
		end
		
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				CallLabelAlways(Loc[1],Loc[2],Loc[3]);
				SetCtrig1X(Loc[1],Loc[2],0x148,Loc[3],SetTo,0xFFFFFFFF),
				SetCtrig1X(Loc[1],Loc[2],0x160,Loc[3],SetTo,Add*16777216,0xFF000000),
				SetCtrigX(Loc[1],Loc[2],0x158,Loc[3],SetTo,"X","X",0x15C,1,1),
				SetCtrig1X("X","X",0x15C,1,SetTo,Loc[5]);

				SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2);
				SetCtrigX("X","X",0x158+0x20*0,1,SetTo,"X","X",0x15C+0x20*1,1,1);
				SetCtrigX("X","X",0x158+0x20*1,1,SetTo,"X","X",0x15C+0x20*2,1,1);
				SetCtrigX("X","X",0x158+0x20*2,1,SetTo,"X","X",0x15C+0x20*3,1,1);
				SetCtrigX("X","X",0x158+0x20*3,1,SetTo,"X","X",0x15C+0x20*4,1,1);
				SetCtrigX("X","X",0x158+0x20*4,1,SetTo,"X","X",0x15C+0x20*5,1,1);
				SetCtrigX("X","X",0x158+0x20*5,1,SetTo,"X","X",0x15C+0x20*6,1,1);
				SetCtrigX("X","X",0x158+0x20*6,1,SetTo,"X","X",0x15C+0x20*7,1,1);
				SetCtrigX("X","X",0x158+0x20*7,1,SetTo,"X","X",0x15C+0x20*8,1,1);
				SetCtrigX("X","X",0x158+0x20*8,1,SetTo,"X","X",0x15C+0x20*9,1,1);
				SetCtrigX("X","X",0x158+0x20*9,1,SetTo,"X","X",0x15C+0x20*10,1,1);
				SetCtrigX("X","X",0x158+0x20*10,1,SetTo,"X","X",0x15C+0x20*11,1,1);	
			},
			flag = {Preserved}
		}
		
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetDeaths(0,SetTo,0,0);
				SetDeaths(0,SetTo,0,0);
				SetDeaths(0,SetTo,0,0);
				SetDeaths(0,SetTo,0,0);
				SetDeaths(0,SetTo,0,0);
				SetDeaths(0,SetTo,0,0);
				SetDeaths(0,SetTo,0,0);
				SetDeaths(0,SetTo,0,0);
				SetDeaths(0,SetTo,0,0);
				SetDeaths(0,SetTo,0,0);
				SetDeaths(0,SetTo,0,0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1);
				SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1);
				SetCtrigX("X","X",0x158+0x20*0,-1,SetTo,"X",IndexAlloc,0x1C,1,1);
				SetCtrigX("X","X",0x158+0x20*1,-1,SetTo,"X",IndexAlloc,0x1C,1,2);
				SetCtrigX("X","X",0x158+0x20*2,-1,SetTo,"X",IndexAlloc,0x1C,1,3);
				SetCtrigX("X","X",0x158+0x20*3,-1,SetTo,"X",IndexAlloc,0x1C,1,4);
				SetCtrigX("X","X",0x158+0x20*4,-1,SetTo,"X",IndexAlloc,0x1C,1,5);
				SetCtrigX("X","X",0x158+0x20*5,-1,SetTo,"X",IndexAlloc,0x1C,1,6);
				SetCtrigX("X","X",0x158+0x20*6,-1,SetTo,"X",IndexAlloc,0x1C,1,7);
				SetCtrigX("X","X",0x158+0x20*7,-1,SetTo,"X",IndexAlloc,0x1C,1,8);
				SetCtrigX("X","X",0x158+0x20*8,-1,SetTo,"X",IndexAlloc,0x1C,1,9);
				SetCtrigX("X","X",0x158+0x20*9,-1,SetTo,"X",IndexAlloc,0x1C,1,10);
				SetCtrigX("X","X",0x158+0x20*10,-1,SetTo,"X",IndexAlloc,0x1C,1,11);	
			},
			flag = {Preserved}
		}
		Loc = 0
	end

	local UnitArr1 = {}
	if AtMostflag == 0 then
		local j = 1
		for i = 10, 0, -1 do
			table.insert(UnitArr1,SetCtrig1X("X","X",0x24,j,SetTo,2^i))
			j = j + 1
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(IndexAlloc);
			},
			actions = {
				SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,0);
				UnitArr1,
			},
			flag = {Preserved}
		}

		for i = 10, 0, -1 do
			local CBit = 2^i

			local UnitArr2 = {}
			if Loc == nil then
				table.insert(UnitArr2,Command(Player,AtLeast,0,UnitId))
			else 
				table.insert(UnitArr2,Bring(Player,AtLeast,0,UnitId,Loc))
			end

			local UnitArr3 = {}
			for j = 1, i do
				table.insert(UnitArr3,SetCtrig1X("X","X",0x24,j,Add,CBit))
			end

			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					UnitArr2,
				},
				actions = {
					SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,CBit,CBit);
					UnitArr3,
				},
				flag = {Preserved}
			}
		end
	else
		local j = 1
		local k = 0
		for i = 10, 0, -1 do
			k = k + 2^i
			table.insert(UnitArr1,SetCtrig1X("X","X",0x24,j,SetTo,k-1))
			j = j + 1
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(IndexAlloc);
			},
			actions = {
				SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,k);
				UnitArr1,
			},
			flag = {Preserved}
		}

		for i = 10, 0, -1 do
			local CBit = 2^i

			local UnitArr2 = {}
			if Loc == nil then
				table.insert(UnitArr2,Command(Player,AtMost,0,UnitId))
			else 
				table.insert(UnitArr2,Bring(Player,AtMost,0,UnitId,Loc))
			end

			local UnitArr3 = {}
			for j = 1, i do
				table.insert(UnitArr3,SetCtrig1X("X","X",0x24,j,Subtract,CBit))
			end

			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					UnitArr2,
				},
				actions = {
					SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,0,CBit);
					UnitArr3,
				},
				flag = {Preserved}
			}
		end
	end
	IndexAlloc = IndexAlloc + 1
	return Output
end

function ConvertReadX(PlayerID,Input,Output,Multiplier,Mask,UseCycle) -- 메모리 * 상수 or 메모리 / 상수(2의 제곱수)
	if type(Input) == "table" then
		if Input[4] == "VA" or Input[4] == "A" then
			ConvertReadX_InputData_Error()
		end
	end
	if type(Output) == "number" then
		Output = {Output}
	end

	if Mask == "X" or Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if UseCycle == "X" or UseCycle == nil then
		UseCycle = 0
	end

	local ClearArr = {} 

	for k, v in pairs(Output) do
		if type(v) == "table" then
			if v[4] == "VA" or v[4] == "A" then
				ConvertReadX_InputData_Error()
			end
		end
		if type(v) == "number" then 
			table.insert(ClearArr,SetMemory(v,SetTo,0))
		elseif v == "Cp" then
			table.insert(ClearArr,SetDeaths(CurrentPlayer,SetTo,0,0))
		elseif v[4] == "V" then				
			table.insert(ClearArr,SetCtrig1X(v[1],v[2],0x15C,v[3],SetTo,0))
		else
			table.insert(ClearArr,SetCtrig1X(v[1],v[2],v[3],v[4],SetTo,0))
		end
	end
	Trigger {
		players = {PlayerID},
		conditions = {
	   		 Label(0);
		},
		actions = {
			ClearArr,
		},
		flag = {Preserved}
	}

	local  Check = 0
	for i = 0, 31 do
		local CBit = bit32.band(Mask, 2^i)
		if CBit == 2^i then
			local InputArr = {}
			local OutputArr = {}
			local MBit = CBit * Multiplier

			if type(Input) == "number" then 
				InputArr = {MemoryX(Input,Exactly,CBit,CBit)}
			elseif Input == "Cp" then
				InputArr = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
			elseif Input[4] == "V" then
				InputArr = {CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,CBit,CBit)}
			else
				InputArr = {CtrigX(Input[1],Input[2],Input[3],Input[4],Exactly,CBit,CBit)}
			end

			for k, v in pairs(Output) do
				if type(v) == "table" then
					if v[4] == "VA" or v[4] == "A" then
						ConvertReadX_InputData_Error()
					end
				end
				if type(v) == "number" then 
					table.insert(OutputArr,SetMemory(v,Add,MBit))
				elseif v == "Cp" then
					table.insert(OutputArr,SetDeaths(CurrentPlayer,Add,MBit,0))
				elseif v[4] == "V" then
					table.insert(OutputArr,SetCtrig1X(v[1],v[2],0x15C,v[3],Add,MBit))
				else
					table.insert(OutputArr,SetCtrig1X(v[1],v[2],v[3],v[4],Add,MBit))
				end
			end
			if Check == 0 then
				Trigger {
					players = {PlayerID},
					conditions = {
				   		 Label(0);
						 InputArr,
					},
					actions = {
						OutputArr,
					},
					flag = {Preserved}
				}
			end
			if bit32.band(CBit*Multiplier,0xFFFFFFFF) >= 0x80000000 and UseCycle == 0 then
				Check = 1
			end
		end
	end
end

-- 제어문 (if,Jump,While) 관련 함수 ----------------------------------------------------

function SLoopN2(PlayerID,Repeat,Conditions,Actions,InitActions,Single)
	return SLoopN(PlayerID,Repeat,Conditions,Actions,InitActions,Single,1)
end

function SLoopN(PlayerID,Repeat,Conditions,Actions,InitActions,Single,UnPack) -- 초소형 반복문 Next 변경 + Db 삽입방식 (CStruct) X Jump 탈출 가능
	if UnPack == 1 then
		if Conditions ~= nil then
			for k, v in pairs(Conditions) do
				local Temp = CunPack(v)
				Conditions[k] = Temp
			end
		end
		if InitActions ~= nil then
			for k, v in pairs(InitActions) do
				local Temp = CunPack(v)
				InitActions[k] = Temp
			end
		end
	end
	Conditions = __FlattenCCond(Conditions)
	InitActions = __FlattenCAct(InitActions)

	if Single == nil or Single == 0 or Single == "X" then
		

		if type(Repeat) == "number" then
			STPopTrigArr(PlayerID)
			_TPopCondArr(PlayerID)
			ORPopCondArr(PlayerID)
			TTPopTrigArr(PlayerID)
			Conditions = PopCondArr(Conditions)
			InitActions = PopActArr(InitActions)
			PopTrigArr(PlayerID,1)

			if Repeat < 0 or Repeat > 500000 then
				SLoopN_InputError()
			end
			local Size = math.ceil(Repeat/151) -- N = 151*TRIG
			Trigger {
				players = {PlayerID},
					conditions = {
						Label(IndexAlloc);
						Conditions,
					},
					actions = {
						SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc,0x0,0,1); -- Connect Next
						InitActions,
					},
					flag = {Preserved}
				}
			Trigger {
				players = {PlayerID},
					conditions = {
						Label();
					},
					actions = {
						SetCtrigX("X",IndexAlloc+1,0x158,0,SetTo,"X",IndexAlloc+1,0x4-0x10*Repeat,1,0); -- Reset Timer
						SetCtrigX("X",IndexAlloc+1,0x4,0,SetTo,"X",IndexAlloc+1,0,0,1); -- Make Loop Action A->A1
						SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1); -- Reset Next
						SetCtrigX("X",IndexAlloc+2,0x4,-1,SetTo,"X",IndexAlloc+1,0x0,0,0); -- Make Loop
					},
					flag = {Preserved}
				}
			for i = 1, Size do
				Trigger {
					players = {PlayerID},
					flag = {Preserved}
				}
			end

			Trigger {
				players = {PlayerID},
					conditions = {
						Label(IndexAlloc+1);
					},
					actions = {
						SetCtrigX("X","X",0x4-0x10*Repeat,0,SetTo,"X",IndexAlloc+2,0,0,0); -- Timer Action & Exit TRIG
						SetCtrig1X("X","X",0x158,0,Add,4); -- Run Tick
						Actions, -- Wait 금지
						},
						flag = {Preserved}
					}

			PlayerID = PlayerConvert(PlayerID)
			table.insert(SLoopNArr, IndexAlloc)
			table.insert(SLoopNPArr, PlayerID)
			table.insert(SLoopNVArr, Repeat)
			SLoopNptr = SLoopNptr + 1
			SLoopNCount = SLoopNCount + 1
			IndexAlloc = IndexAlloc + 0x3
		elseif Repeat[1][4] == "V" then
			STPopTrigArr(PlayerID)
			_TPopCondArr(PlayerID)
			ORPopCondArr(PlayerID)
			TTPopTrigArr(PlayerID)
			Conditions = PopCondArr(Conditions)
			InitActions = PopActArr(InitActions)
			PopTrigArr(PlayerID,7,2)

			local min, max, RepeatMax
			RepeatMax = Repeat[2]
			local Size = math.ceil(RepeatMax/151) -- N = 151*TRIG
			local Deviation = Repeat[1][5]
			if Deviation == "X" or Deviation == nil then
				Deviation = 0
			end
			if Deviation >= 0 then
				min = 0
			else
				min = -Deviation
			end
			if Deviation >= RepeatMax then
				max = 0
			else
				max = RepeatMax-Deviation
			end
			if RepeatMax < 0 or RepeatMax > 500000 then
				SLoopN_InputError()
			end
			
			Trigger {
				players = {PlayerID},
					conditions = {
						Label(IndexAlloc);
						NVar(Repeat[1],AtLeast,min*4,0xFFFFFFFC);
						NVar(Repeat[1],AtMost,max*4,0xFFFFFFFC);
						Conditions,
					},
					actions = {
						SetCtrigX("X",IndexAlloc,0x4,0,SetTo,Repeat[1][1],Repeat[1][2],0,0,Repeat[1][3]);  -- Connect Next
						SetCtrigX(Repeat[1][1],Repeat[1][2],0x4,Repeat[1][3],SetTo,"X",IndexAlloc,0,0,1); -- Connect Next
						SetCtrigX("X",IndexAlloc+1,0x4,0,SetTo,"X",IndexAlloc+1,0,0,1); -- Make Loop Action A->A1
						SetCtrigX(Repeat[1][1],Repeat[1][2],0x158,Repeat[1][3],SetTo,"X",IndexAlloc+1,0x158,1,0);
						SetCtrig1X(Repeat[1][1],Repeat[1][2],0x160,Repeat[1][3],SetTo,Subtract*16777216,0xFF000000);
						SetCtrig1X(Repeat[1][1],Repeat[1][2],0x148,Repeat[1][3],SetTo,0xFFFFFFFC);
						SetCtrigX("X",IndexAlloc+1,0x158,0,SetTo,"X",IndexAlloc+1,0x4-0x10*Deviation,1,0); -- Reset Timer
						InitActions,
					},
					flag = {Preserved}
				}
			Trigger {
				players = {PlayerID},
					conditions = {
						Label();
					},
					actions = {
						SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+1,0x0,0,1); -- Reset Next
						SetCtrigX("X",IndexAlloc+2,0x4,-1,SetTo,"X",IndexAlloc+1,0x0,0,0); -- Make Loop
					},
					flag = {Preserved}
				}
			for i = 1, Size do
				Trigger {
					players = {PlayerID},
					flag = {Preserved}
				}
			end

			Trigger {
				players = {PlayerID},
					conditions = {
						Label(IndexAlloc+1);
					},
					actions = {
						SetCtrig2X(0,SetTo,"X",IndexAlloc+2,0,0,0); -- Timer Action & Exit TRIG
						SetCtrig1X("X","X",0x158,0,Add,4); -- Run Tick
						Actions, -- Wait 금지
						},
						flag = {Preserved}
					}
			PlayerID = PlayerConvert(PlayerID)
			table.insert(SLoopNArr, IndexAlloc)
			table.insert(SLoopNPArr, PlayerID)
			table.insert(SLoopNVArr, Repeat)
			SLoopNptr = SLoopNptr + 1
			SLoopNCount = SLoopNCount + 1
			IndexAlloc = IndexAlloc + 0x3
		else
			SLoopN_InputError()
		end
	else
		if type(Repeat) == "number" then
			STPopTrigArr(PlayerID)
			_TPopCondArr(PlayerID)
			ORPopCondArr(PlayerID)
			TTPopTrigArr(PlayerID)
			Conditions = PopCondArr(Conditions)
			InitActions = PopActArr(InitActions)
			PopTrigArr(PlayerID,2)

			if Repeat <= 0 or Repeat > 500000 then
				SLoopN_InputError()
			end
			local Size = math.ceil((Repeat-1)/151) -- N = 151*TRIG
			Trigger {
				players = {PlayerID},
					conditions = {
						Label(IndexAlloc);
						Conditions,
					},
					actions = {
						SetCtrigX("X",IndexAlloc+1,0x4,0,SetTo,"X",IndexAlloc+1,0,0,0); -- Make Loop Action A->A
						SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+1,0x0,0,0); -- Connect Next
						InitActions,
					},
					flag = {Preserved}
				}

			for i = 1, Size do
				Trigger {
					players = {PlayerID},
					flag = {Preserved}
				}
			end

			Trigger {
				players = {PlayerID},
					conditions = {
						Label(IndexAlloc+1);
					},
					actions = {
						SetCtrigX("X","X",0x4-0x10*(Repeat-1),0,SetTo,"X",IndexAlloc+2,0,0,0); -- Timer Action & Exit TRIG
						SetCtrig1X("X","X",0x158,0,Add,4); -- Run Tick
						Actions, -- Wait 금지
						},
						flag = {Preserved}
					}
			local EndActions = {}
			if type(Single) == "table" then
				EndActions = Single
			end
			Trigger {
				players = {PlayerID},
					conditions = {
						Label(IndexAlloc+2);
					},
					actions = {
						SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1); -- Reset Next
						SetCtrigX("X",IndexAlloc+1,0x158,0,SetTo,"X",IndexAlloc+1,0x4-0x10*(Repeat-1),1,0); -- Reset Timer
						EndActions,
						},
						flag = {Preserved}
					}
			PlayerID = PlayerConvert(PlayerID)
			for k, P in pairs(PlayerID) do
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1))
			end
			IndexAlloc = IndexAlloc + 0x3
		elseif Repeat[1][4] == "V" then
			STPopTrigArr(PlayerID)
			_TPopCondArr(PlayerID)
			ORPopCondArr(PlayerID)
			TTPopTrigArr(PlayerID)
			Conditions = PopCondArr(Conditions)
			InitActions = PopActArr(InitActions)
			PopTrigArr(PlayerID,7,2)

			local min, max, RepeatMax
			RepeatMax = Repeat[2]
			local Size = math.ceil((RepeatMax-1)/151) -- N = 151*TRIG
			local Deviation = Repeat[1][5]
			if Deviation == "X" or Deviation == nil then
				Deviation = 0
			end
			if Deviation >= 1 then
				min = 0
			else
				min = 1-Deviation
			end
			if Deviation >= RepeatMax then
				max = 0
			else
				max = RepeatMax-Deviation
			end
			if RepeatMax <= 0 or RepeatMax > 500000 then
				SLoopN_InputError()
			end
			
			Trigger {
				players = {PlayerID},
					conditions = {
						Label(IndexAlloc);
						NVar(Repeat[1],AtLeast,min*4,0xFFFFFFFC);
						NVar(Repeat[1],AtMost,max*4,0xFFFFFFFC);
						Conditions,
					},
					actions = {
						SetCtrigX("X",IndexAlloc,0x4,0,SetTo,Repeat[1][1],Repeat[1][2],0,0,Repeat[1][3]);  -- Connect Next
						SetCtrigX(Repeat[1][1],Repeat[1][2],0x4,Repeat[1][3],SetTo,"X",IndexAlloc+1,0,0,0); -- Connect Next
						SetCtrigX("X",IndexAlloc+1,0x4,0,SetTo,"X",IndexAlloc+1,0,0,0); -- Make Loop Action A->A
						SetCtrigX(Repeat[1][1],Repeat[1][2],0x158,Repeat[1][3],SetTo,"X",IndexAlloc+1,0x158,1,0);
						SetCtrig1X(Repeat[1][1],Repeat[1][2],0x160,Repeat[1][3],SetTo,Subtract*16777216,0xFF000000);
						SetCtrig1X(Repeat[1][1],Repeat[1][2],0x148,Repeat[1][3],SetTo,0xFFFFFFFC);
						SetCtrigX("X",IndexAlloc+1,0x158,0,SetTo,"X",IndexAlloc+1,0x14-0x10*Deviation,1,0); -- Reset Timer
						InitActions,
					},
					flag = {Preserved}
				}

			for i = 1, Size do
				Trigger {
					players = {PlayerID},
					flag = {Preserved}
				}
			end

			Trigger {
				players = {PlayerID},
					conditions = {
						Label(IndexAlloc+1);
					},
					actions = {
						SetCtrig2X(0,SetTo,"X",IndexAlloc+2,0,0,0); -- Timer Action & Exit TRIG
						SetCtrig1X("X","X",0x158,0,Add,4); -- Run Tick
						Actions, -- Wait 금지
						},
						flag = {Preserved}
					}
			local EndActions = {}
			if type(Single) == "table" then
				EndActions = Single
			end
			Trigger {
				players = {PlayerID},
					conditions = {
						Label(IndexAlloc+2);
					},
					actions = {
						SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1); -- Reset Next
						EndActions,
						},
						flag = {Preserved}
					}
			PlayerID = PlayerConvert(PlayerID)
			for k, P in pairs(PlayerID) do
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1))
			end
			IndexAlloc = IndexAlloc + 0x3
		else
			SLoopN_InputError()
		end
	end
end

function SLoopNEnd(Actions)
	if SLoopNCount <= 0 then
		SLoopNpair_Error()
	end
	if type(SLoopNVArr[SLoopNptr]) == "number" then		
		local Index = SLoopNArr[SLoopNptr] + 2
		local PlayerID = SLoopNPArr[SLoopNptr]
		local Repeat = SLoopNVArr[SLoopNptr]
		table.remove(SLoopNArr,SLoopNptr)
		table.remove(SLoopNPArr,SLoopNptr)
		table.remove(SLoopNVArr,SLoopNptr)
		SLoopNptr = SLoopNptr - 1
		SLoopNCount = SLoopNCount - 1

		Trigger {
			players = {PlayerID},
				conditions = {
					Label(Index);
				},
				actions = {
					Actions,
					},
					flag = {Preserved}
				}

		for k, P in pairs(PlayerID) do
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x4,0,SetTo,"X",Index,0x0,0,1))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x4,1,SetTo,"X",Index-1,0x0,0,0))
		end
		IndexAlloc = IndexAlloc + 0x1
	else
		local Index = SLoopNArr[SLoopNptr] + 2
		local PlayerID = SLoopNPArr[SLoopNptr]
		local Repeat = SLoopNVArr[SLoopNptr]
		table.remove(SLoopNArr,SLoopNptr)
		table.remove(SLoopNPArr,SLoopNptr)
		table.remove(SLoopNVArr,SLoopNptr)
		SLoopNptr = SLoopNptr - 1
		SLoopNCount = SLoopNCount - 1

		Trigger {
			players = {PlayerID},
				conditions = {
					Label(Index);
				},
				actions = {
					Actions,
					},
					flag = {Preserved}
				}

		for k, P in pairs(PlayerID) do
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x4,0,SetTo,"X",Index,0x0,0,1))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x4,1,SetTo,"X",Index-1,0x0,0,0))
		end
		IndexAlloc = IndexAlloc + 0x1
	end
end

function CJump(PlayerID,sIndex)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(sIndex+JumpStartAlloc);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1],SetNext(sIndex+JumpStartAlloc,sIndex+JumpEndAlloc,1))
	end
	table.insert(CJumpArr,sIndex)
end

function CJumpEnd(PlayerID,sIndex)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(sIndex+JumpEndAlloc);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	table.insert(CJumpEndArr,sIndex)
end

function NJump2(PlayerID,sIndex,Conditions,Actions)
	return NJump(PlayerID,sIndex,Conditions,Actions,1)
end

function NJump(PlayerID,sIndex,Conditions,Actions,UnPack)
	if UnPack == 1 then
		if Conditions ~= nil then
		for k, v in pairs(Conditions) do
			local Temp = CunPack(v)
			Conditions[k] = Temp
		end
	end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(sIndex+JumpStartAlloc);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",sIndex+JumpStartAlloc,0x158,0,SetTo,"X",sIndex+JumpStartAlloc,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",sIndex+JumpStartAlloc,0x15C,0,SetTo,"X",sIndex+JumpEndAlloc,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",sIndex+JumpEndAlloc,0x158,0,SetTo,"X",sIndex+JumpStartAlloc,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",sIndex+JumpEndAlloc,0x15C,0,SetTo,"X",sIndex+JumpStartAlloc,0x0,0,1))
	end
	table.insert(NJumpArr,sIndex)
end
function NJumpEnd(PlayerID,sIndex,Actions_Always)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(sIndex+JumpEndAlloc);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions_Always,
			PreserveTrigger();
		},
	}
	table.insert(NJumpEndArr,sIndex)
end

function CJumpX(PlayerID,sIndex)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			SetNext("X",sIndex+JumpEndAlloc,1);
	   		PreserveTrigger();
		},
	}
	table.insert(CJumpArr,sIndex)
end

function CJumpXEnd(PlayerID,sIndex)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(sIndex+JumpEndAlloc);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	table.insert(CJumpEndArr,sIndex)
end

function NJumpX2(PlayerID,sIndex,Conditions,Actions)
	return NJumpX(PlayerID,sIndex,Conditions,Actions,1)
end

function NJumpX(PlayerID,sIndex,Conditions,Actions,UnPack)
	if UnPack == 1 then
		if Conditions ~= nil then
		for k, v in pairs(Conditions) do
			local Temp = CunPack(v)
			Conditions[k] = Temp
		end
	end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
			Conditions,
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",sIndex+JumpEndAlloc,0x0,0,0);
			SetCtrigX("X",sIndex+JumpEndAlloc,0x158,0,SetTo,"X","X",0x4,1,0);
			SetCtrigX("X",sIndex+JumpEndAlloc,0x15C,0,SetTo,"X","X",0x0,0,1);
			SetCtrig1X("X",sIndex+JumpEndAlloc,0x2C,0,SetTo,0x0200,0x0200);
			Actions,
	   		PreserveTrigger();
		},
	}
	table.insert(NJumpArr,sIndex)
end
function NJumpXEnd(PlayerID,sIndex,Actions)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(sIndex+JumpEndAlloc);
			Never();
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			SetCtrig1X("X",sIndex+JumpEndAlloc,0x2C,0,SetTo,0x0000,0x0200);
			Actions,
			PreserveTrigger();
		},
	}
	table.insert(NJumpEndArr,sIndex)
end

function CIfOnce2(PlayerID, Conditions, Actions)
	return CIfOnce(PlayerID, Conditions, Actions, 1)
end

function CIfOnce(PlayerID, Conditions, Actions, UnPack) -- 1번만 실행
	if UnPack == 1 then
		if Conditions ~= nil then
		for k, v in pairs(Conditions) do
			local Temp = CunPack(v)
			Conditions[k] = Temp
		end
	end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(CIfArr, IndexAlloc)
	table.insert(CIfPArr, PlayerID)
	CIfptr = CIfptr + 1
	IndexAlloc = IndexAlloc + 0x2
end

function CIf2(PlayerID, Conditions, Actions)
	return CIf(PlayerID, Conditions, Actions, 1)
end

function CIf(PlayerID, Conditions, Actions, UnPack)
	if UnPack == 1 then
		if Conditions ~= nil then
		for k, v in pairs(Conditions) do
			local Temp = CunPack(v)
			Conditions[k] = Temp
		end
	end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(CIfArr, IndexAlloc)
	table.insert(CIfPArr, PlayerID)
	CIfptr = CIfptr + 1
	IndexAlloc = IndexAlloc + 0x2
end

function CIfEnd2(PlayerID, Conditions, Actions)
	return CIfEnd(Actions,1)
end

function CIfEnd(Actions,UnPack)
	local Index
	Index = CIfArr[CIfptr] + 1
	local PlayerID
	PlayerID = CIfPArr[CIfptr]
	table.remove(CIfArr,CIfptr)
	table.remove(CIfPArr,CIfptr)
	CIfptr = CIfptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x4,0,SetTo,"X",Index,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x158,0,SetTo,"X",Index-1,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x15C,0,SetTo,"X",Index-1,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x158,0,SetTo,"X",Index-1,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x15C,0,SetTo,"X",Index,0x0,0,1))
	end

	if UnPack == 1 then
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(Index);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
			PreserveTrigger();
		},
	}
end

function NIfOnce2(PlayerID, Conditions, Actions)
	return NIfOnce(PlayerID, Conditions, Actions, 1)
end

function NIfOnce(PlayerID, Conditions, Actions, UnPack)
	if UnPack == 1 then
		if Conditions ~= nil then
		for k, v in pairs(Conditions) do
			local Temp = CunPack(v)
			Conditions[k] = Temp
		end
	end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(NIfArr, IndexAlloc)
	table.insert(NIfPArr, PlayerID)
	NIfptr = NIfptr + 1
	IndexAlloc = IndexAlloc + 0x3
end

function NIf2(PlayerID, Conditions, Actions)
	return NIf(PlayerID, Conditions, Actions, 1)
end

function NIf(PlayerID, Conditions, Actions, UnPack)
	if UnPack == 1 then
		if Conditions ~= nil then
		for k, v in pairs(Conditions) do
			local Temp = CunPack(v)
			Conditions[k] = Temp
		end
	end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(NIfArr, IndexAlloc)
	table.insert(NIfPArr, PlayerID)
	NIfptr = NIfptr + 1
	IndexAlloc = IndexAlloc + 0x3
end

function NIfEnd()
	local Index
	Index = NIfArr[NIfptr] + 2
	local PlayerID
	PlayerID = NIfPArr[NIfptr]
	table.remove(NIfArr,NIfptr)
	table.remove(NIfPArr,NIfptr)
	NIfptr = NIfptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x4,0,SetTo,"X",Index,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x158,0,SetTo,"X",Index-2,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x15C,0,SetTo,"X",Index-1,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x158,0,SetTo,"X",Index-2,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x15C,0,SetTo,"X",Index,0x0,0,1))
	end
	
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(Index);
		},
		actions = {
			PreserveTrigger();
		},
	}
end

function CWhile2(PlayerID, Conditions, Actions)
	return CWhile(PlayerID, Conditions, Actions, 1)
end

function CWhile(PlayerID, Conditions, Actions, UnPack)
	if UnPack == 1 then
		if Conditions ~= nil then
		for k, v in pairs(Conditions) do
			local Temp = CunPack(v)
			Conditions[k] = Temp
		end
	end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(CWhileArr, IndexAlloc)
	table.insert(CWhilePArr, PlayerID)
	CWhileptr = CWhileptr + 1
	IndexAlloc = IndexAlloc + 0x3
end

function CLoop2(PlayerID,Repeat,Conditions,Actions)
	return CLoop(PlayerID,Repeat,Conditions,Actions,1)
end

function CLoop(PlayerID,Repeat,Conditions,Actions,UnPack)
	DoActionsX(PlayerID,SetCDeaths("X",SetTo,0,Ccode(IndexAlloc+1,0)))

	if UnPack == 1 then
		if Conditions ~= nil then
		for k, v in pairs(Conditions) do
			local Temp = CunPack(v)
			Conditions[k] = Temp
		end
	end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,2,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
			CDeaths("X",AtMost,Repeat-1,Ccode(IndexAlloc+1,0));
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			SetCDeaths("X",Add,1,Ccode(IndexAlloc+1,0));
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(CWhileArr, IndexAlloc)
	table.insert(CWhilePArr, PlayerID)
	CWhileptr = CWhileptr + 1
	IndexAlloc = IndexAlloc + 0x3
end

function CWhileEnd2(Actions)
	return CWhileEnd(Actions,1)
end

function CWhileEnd(Actions,UnPack)
	local Index
	Index = CWhileArr[CWhileptr] + 2
	local PlayerID
	PlayerID = CWhilePArr[CWhileptr]
	table.remove(CWhileArr,CWhileptr)
	table.remove(CWhilePArr,CWhileptr)
	CWhileptr = CWhileptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x4,0,SetTo,"X",Index-2,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x4,0,SetTo,"X",Index,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x158,0,SetTo,"X",Index-2,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x15C,0,SetTo,"X",Index-1,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x158,0,SetTo,"X",Index-2,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x15C,0,SetTo,"X",Index-1,0x0,0,0))
	end

	if UnPack == 1 then
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(Index);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
			PreserveTrigger();
		},
	}
end

function CWhileX2(PlayerID, Conditions, Actions)
	return CWhileX(PlayerID, Conditions, Actions, 1)
end

function CWhileX(PlayerID, Conditions, Actions, UnPack)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
			Never();
		},
		actions = {
	   		PreserveTrigger();
		},
	}

	if UnPack == 1 then
		if Conditions ~= nil then
		for k, v in pairs(Conditions) do
			local Temp = CunPack(v)
			Conditions[k] = Temp
		end
	end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+1);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+2);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(CWhileXArr, IndexAlloc)
	table.insert(CWhileXPArr, PlayerID)
	CWhileXptr = CWhileXptr + 1
	IndexAlloc = IndexAlloc + 0x4
end

function CLoopX2(PlayerID,Repeat,Conditions,Actions)
	return CLoopX(PlayerID,Repeat,Conditions,Actions,1)
end

function CLoopX(PlayerID,Repeat,Conditions,Actions,UnPack)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
		},
		actions = {
			SetCDeaths("X",SetTo,0,Ccode(IndexAlloc+2,0));
	   		PreserveTrigger();
		},
	}

	if type(Repeat) == "number" then
		if UnPack == 1 then
		if Conditions ~= nil then
			for k, v in pairs(Conditions) do
				local Temp = CunPack(v)
				Conditions[k] = Temp
			end
		end
			if Actions ~= nil then
			for k, v in pairs(Actions) do
				local Temp = CunPack(v)
				Actions[k] = Temp
			end
		end
		end
		Conditions = __FlattenCCond(Conditions)
		Actions = __FlattenCAct(Actions)

		STPopTrigArr(PlayerID)
		_TPopCondArr(PlayerID)
		ORPopCondArr(PlayerID)
		TTPopTrigArr(PlayerID)
		Conditions = PopCondArr(Conditions)
		Actions = PopActArr(Actions)
		PopTrigArr(PlayerID,2,1)
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(IndexAlloc+1);
				CDeaths("X",AtMost,Repeat-1,Ccode(IndexAlloc+2,0));
				Conditions,
			},
			actions = {
				SetDeaths(0,SetTo,0,0);
				SetCDeaths("X",Add,1,Ccode(IndexAlloc+2,0));
				Actions,
		   		PreserveTrigger();
			},
		}		
	else
		Conditions = {Conditions,TCDeaths("X",AtMost,Vi(Repeat[2],-1,Repeat[1],Repeat[3]),Ccode(IndexAlloc+2,0))}

		if UnPack == 1 then
		if Conditions ~= nil then
			for k, v in pairs(Conditions) do
				local Temp = CunPack(v)
				Conditions[k] = Temp
			end
		end
			if Actions ~= nil then
			for k, v in pairs(Actions) do
				local Temp = CunPack(v)
				Actions[k] = Temp
			end
		end
		end

		Conditions = __FlattenCCond(Conditions)
		Actions = __FlattenCAct(Actions)
		
		STPopTrigArr(PlayerID)
		_TPopCondArr(PlayerID)
		ORPopCondArr(PlayerID)
		TTPopTrigArr(PlayerID)
		Conditions = PopCondArr(Conditions)
		Actions = PopActArr(Actions)
		PopTrigArr(PlayerID,2)

		Trigger {
			players = {PlayerID},
			conditions = {
				Label(IndexAlloc+1);
				Conditions;
			},
			actions = {
				SetDeaths(0,SetTo,0,0);
			 	SetCDeaths("X",Add,1,Ccode(IndexAlloc+2,0));
				Actions,
			},
			flag = {Preserved}
		}
	end
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+2);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(CWhileXArr, IndexAlloc)
	table.insert(CWhileXPArr, PlayerID)
	CWhileXptr = CWhileXptr + 1
	IndexAlloc = IndexAlloc + 0x4
end

function CWhileXEnd2(Actions)
	return CWhileXEnd(Actions,1)
end

function CWhileXEnd(Actions,UnPack)
	local Index
	Index = CWhileXArr[CWhileXptr] + 3
	local PlayerID
	PlayerID = CWhileXPArr[CWhileXptr]
	table.remove(CWhileXArr,CWhileXptr)
	table.remove(CWhileXPArr,CWhileXptr)
	CWhileXptr = CWhileXptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x4,0,SetTo,"X",Index-3,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x4,0,SetTo,"X",Index,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x158,0,SetTo,"X",Index-2,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x15C,0,SetTo,"X",Index-1,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x158,0,SetTo,"X",Index-2,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x15C,0,SetTo,"X",Index-1,0x0,0,0))
	end
	if UnPack == 1 then
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(Index);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
			PreserveTrigger();
		},
	}
end

function NWhile2(PlayerID, Conditions, Actions)
	return NWhile(PlayerID, Conditions, Actions,1)
end

function NWhile(PlayerID, Conditions, Actions,UnPack)
	if UnPack == 1 then
		if Conditions ~= nil then
		for k, v in pairs(Conditions) do
			local Temp = CunPack(v)
			Conditions[k] = Temp
		end
	end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+2);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(NWhileArr, IndexAlloc)
	table.insert(NWhilePArr, PlayerID)
	NWhileptr = NWhileptr + 1
	IndexAlloc = IndexAlloc + 0x4
end

function NLoop2(PlayerID,Repeat,Conditions,Actions)
	return NLoop(PlayerID,Repeat,Conditions,Actions,1)
end

function NLoop(PlayerID,Repeat,Conditions,Actions,UnPack)
	DoActionsX(PlayerID,SetCDeaths("X",SetTo,0,Ccode(IndexAlloc+1,0)))
	if UnPack == 1 then
		if Conditions ~= nil then
		for k, v in pairs(Conditions) do
			local Temp = CunPack(v)
			Conditions[k] = Temp
		end
	end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,2,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
			CDeaths("X",AtMost,Repeat-1,Ccode(IndexAlloc+1,0));
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			SetCDeaths("X",Add,1,Ccode(IndexAlloc+1,0));
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+2);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(NWhileArr, IndexAlloc)
	table.insert(NWhilePArr, PlayerID)
	NWhileptr = NWhileptr + 1
	IndexAlloc = IndexAlloc + 0x4
end

function NWhileEnd2(Actions)
	return NWhileEnd(Actions,1)
end

function NWhileEnd(Actions,UnPack)
	local Index
	Index = NWhileArr[NWhileptr] + 3
	local PlayerID
	PlayerID = NWhilePArr[NWhileptr]
	table.remove(NWhileArr,NWhileptr)
	table.remove(NWhilePArr,NWhileptr)
	NWhileptr = NWhileptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x4,0,SetTo,"X",Index-3,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x4,0,SetTo,"X",Index,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-3,0x158,0,SetTo,"X",Index-3,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-3,0x15C,0,SetTo,"X",Index-1,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x158,0,SetTo,"X",Index-3,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x15C,0,SetTo,"X",Index-2,0x0,0,0))
	end
	if UnPack == 1 then
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(Index);
		},
		actions = {
			Actions,
			PreserveTrigger();
		},
	}
end

function NWhileX2(PlayerID, Conditions, Actions)
	return NWhileX(PlayerID, Conditions, Actions,1)
end

function NWhileX(PlayerID, Conditions, Actions,UnPack)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
			Never();
		},
		actions = {
	   		PreserveTrigger();
		},
	}

	if UnPack == 1 then
		if Conditions ~= nil then
		for k, v in pairs(Conditions) do
			local Temp = CunPack(v)
			Conditions[k] = Temp
		end
	end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+1);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+2);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+3);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(NWhileXArr, IndexAlloc)
	table.insert(NWhileXPArr, PlayerID)
	NWhileXptr = NWhileXptr + 1
	IndexAlloc = IndexAlloc + 0x5
end

function NLoopX2(PlayerID,Repeat,Conditions,Actions)
	return NLoopX(PlayerID,Repeat,Conditions,Actions,1)
end

function NLoopX(PlayerID,Repeat,Conditions,Actions,UnPack)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
		},
		actions = {
			SetCDeaths("X",SetTo,0,Ccode(IndexAlloc+2,0));
	   		PreserveTrigger();
		},
	}

	if type(Repeat) == "number" then
		if UnPack == 1 then
			if Conditions ~= nil then
			for k, v in pairs(Conditions) do
				local Temp = CunPack(v)
				Conditions[k] = Temp
			end
		end
			if Actions ~= nil then
			for k, v in pairs(Actions) do
				local Temp = CunPack(v)
				Actions[k] = Temp
			end
		end
		end
		Conditions = __FlattenCCond(Conditions)
		Actions = __FlattenCAct(Actions)

		STPopTrigArr(PlayerID)
		_TPopCondArr(PlayerID)
		ORPopCondArr(PlayerID)
		TTPopTrigArr(PlayerID)
		Conditions = PopCondArr(Conditions)
		Actions = PopActArr(Actions)
		PopTrigArr(PlayerID,2,1)
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(IndexAlloc+1);
				CDeaths("X",AtMost,Repeat-1,Ccode(IndexAlloc+2,0));
				Conditions,
			},
			actions = {
				SetDeaths(0,SetTo,0,0);
				SetCDeaths("X",Add,1,Ccode(IndexAlloc+2,0));
				Actions,
		   		PreserveTrigger();
			},
		}
	else
		Conditions = {Conditions,TCDeaths("X",AtMost,Vi(Repeat[2],-1,Repeat[1],Repeat[3]),Ccode(IndexAlloc+2,0))}

		if UnPack == 1 then
		if Conditions ~= nil then
			for k, v in pairs(Conditions) do
				local Temp = CunPack(v)
				Conditions[k] = Temp
			end
		end
			if Actions ~= nil then
			for k, v in pairs(Actions) do
				local Temp = CunPack(v)
				Actions[k] = Temp
			end
		end
		end
		
		Conditions = __FlattenCCond(Conditions)
		Actions = __FlattenCAct(Actions)
		
		STPopTrigArr(PlayerID)
		_TPopCondArr(PlayerID)
		ORPopCondArr(PlayerID)
		TTPopTrigArr(PlayerID)
		Conditions = PopCondArr(Conditions)
		Actions = PopActArr(Actions)
		PopTrigArr(PlayerID,2)

		Trigger {
			players = {PlayerID},
			conditions = {
				Label(IndexAlloc+1);
				Conditions;
			},
			actions = {
				SetDeaths(0,SetTo,0,0);
			 	SetCDeaths("X",Add,1,Ccode(IndexAlloc+2,0));
				Actions,
			},
			flag = {Preserved}
		}
	end

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+2);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+3);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(NWhileXArr, IndexAlloc)
	table.insert(NWhileXPArr, PlayerID)
	NWhileXptr = NWhileXptr + 1
	IndexAlloc = IndexAlloc + 0x5
end

function NWhileXEnd2(Actions)
	return NWhileXEnd(Actions,1)
end

function NWhileXEnd(Actions,UnPack)
	local Index
	Index = NWhileXArr[NWhileXptr] + 4
	local PlayerID
	PlayerID = NWhileXPArr[NWhileXptr]
	table.remove(NWhileXArr,NWhileXptr)
	table.remove(NWhileXPArr,NWhileXptr)
	NWhileXptr = NWhileXptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x4,0,SetTo,"X",Index-4,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x4,0,SetTo,"X",Index,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-3,0x158,0,SetTo,"X",Index-3,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-3,0x15C,0,SetTo,"X",Index-1,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x158,0,SetTo,"X",Index-3,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x15C,0,SetTo,"X",Index-2,0x0,0,0))
	end
	if UnPack == 1 then
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(Index);
		},
		actions = {
			Actions,
			PreserveTrigger();
		},
	}
end

function DoWhile(PlayerID, Actions_Always)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions_Always,
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(DWhileArr, IndexAlloc)
	table.insert(DWhilePArr, PlayerID)
	DWhileptr = DWhileptr + 1
	IndexAlloc = IndexAlloc + 0x2
end

function DoWhileEnd2(Loop_Conditions, Actions)
	return DoWhileEnd(Loop_Conditions, Actions,1)
end

function DoWhileEnd(Loop_Conditions, Actions,UnPack)
	local Index
	Index = DWhileArr[DWhileptr] + 1
	local PlayerID
	PlayerID = DWhilePArr[DWhileptr]
	table.remove(DWhileArr,DWhileptr)
	table.remove(DWhilePArr,DWhileptr)
	DWhileptr = DWhileptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x158,0,SetTo,"X",Index,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x15C,0,SetTo,"X",Index,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x158,0,SetTo,"X",Index,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x15C,0,SetTo,"X",Index-1,0x0,0,0))
	end
	if UnPack == 1 then
		for k, v in pairs(Loop_Conditions) do
			local Temp = CunPack(v)
			Loop_Conditions[k] = Temp
		end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Loop_Conditions = __FlattenCCond(Loop_Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Loop_Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(Index);
			Loop_Conditions,
		},
		actions = {
		SetDeaths(0,SetTo,0,0);
			Actions,
			PreserveTrigger();
		},
	}
end

function CFor2(PlayerID,Init,End,Step,Actions) -- DoWhile x CJump
	return CFor(PlayerID,Init,End,Step,Actions,1) -- DoWhile x CJump
end

function CFor(PlayerID,Init,End,Step,Actions,UnPack) -- DoWhile x CJump
	DoActionsX(PlayerID,SetVariableX("X",IndexAlloc+1,"Value",SetTo,Init)) -- Calc Init
	if UnPack == 1 then
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
			VariableX("X",IndexAlloc+1,"Value",Exactly,End); -- Calc Last
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	CVariable(PlayerID,IndexAlloc+1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+2);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(CForArr, IndexAlloc)
	table.insert(CForPArr, PlayerID)
	table.insert(CForStep, Step)
	CForptr = CForptr + 1
	IndexAlloc = IndexAlloc + 0x4

	return {"X",IndexAlloc-3,0,"V"}
end

function CForEnd2(Actions)
	return CForEnd(Actions,1)
end

function CForEnd(Actions,UnPack)
	local Index
	Index = CForArr[CForptr] + 3
	local PlayerID
	PlayerID = CForPArr[CForptr]
	local Step
	Step = CForStep[CForptr]
	table.remove(CForArr,CForptr)
	table.remove(CForPArr,CForptr)
	table.remove(CForStep,CForptr)
	CForptr = CForptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-3,0x4,0,SetTo,"X",Index-1,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x4,0,SetTo,"X",Index,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x4,0,SetTo,"X",Index-3,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-3,0x158,0,SetTo,"X",Index-3,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-3,0x15C,0,SetTo,"X",Index-1,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x158,0,SetTo,"X",Index-3,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x15C,0,SetTo,"X",Index-1,0x0,0,1))
	end
	if UnPack == 1 then
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	STPopTrigArr(PlayerID)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(Index);
		},
		actions = {
			SetVariableX("X",Index-2,"Value",Add,Step);
			Actions,
			PreserveTrigger();
		},
	}
end

function CForVariable(NestingLevel)
	if NestingLevel == nil or NestingLevel == "X" then
		NestingLevel = CForptr
	end
	local CForLabel = CForArr[NestingLevel] + 1
	return {"X",CForLabel,0,"V"}
end

function CIfX2(PlayerID, Conditions, Actions)
	return CIfX(PlayerID, Conditions, Actions,1)
end

function CIfX(PlayerID, Conditions, Actions,UnPack)
	if UnPack == 1 then
		if Conditions ~= nil then
		for k, v in pairs(Conditions) do
			local Temp = CunPack(v)
			Conditions[k] = Temp
		end
	end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,3)

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			SetDeaths(0,SetTo,0,0);
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	local X = {}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(X, IndexAlloc)
	table.insert(CIfXArr, X)
	table.insert(CIfXPArr, PlayerID)
	CIfXptr = CIfXptr + 1
	IndexAlloc = IndexAlloc + 0x2
end

function CElseIfX2(Conditions, Actions)
	return CElseIfX(Conditions, Actions,1)
end

function CElseIfX(Conditions, Actions,UnPack)
	local PlayerID
	PlayerID = CIfXPArr[CIfXptr]
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		flag = {Preserved}
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
		},
		flag = {Preserved}
	}
	if UnPack == 1 then
		if Conditions ~= nil then
		for k, v in pairs(Conditions) do
			local Temp = CunPack(v)
			Conditions[k] = Temp
		end
	end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,3)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+1);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			SetDeaths(0,SetTo,0,0);
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	table.insert(CIfXArr[CIfXptr],IndexAlloc+1)
	IndexAlloc = IndexAlloc + 0x2
end

function CElseX2(Actions)
	return CElseX(Actions,1)
end

function CElseX(Actions,UnPack)
	local PlayerID
	PlayerID = CIfXPArr[CIfXptr]
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		flag = {Preserved}
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
		},
		flag = {Preserved}
	}
	if UnPack == 1 then
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,3)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			SetDeaths(0,SetTo,0,0);
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	table.insert(CIfXArr[CIfXptr],IndexAlloc+1)
	IndexAlloc = IndexAlloc + 0x2
end

function CIfXEnd()
	local PlayerID
	PlayerID = CIfXPArr[CIfXptr]
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		flag = {Preserved}
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
		},
		flag = {Preserved}
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			PreserveTrigger();
		},
	}
	table.insert(CIfXArr[CIfXptr],IndexAlloc+1)
	IndexAlloc = IndexAlloc + 0x2

	for k, P in pairs(PlayerID) do
		local Size = 0
		for i, index in pairs(CIfXArr[CIfXptr]) do
			Size = Size + 1
		end
		for i = 1, Size-1 do
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",CIfXArr[CIfXptr][i],0x4,0,SetTo,"X",CIfXArr[CIfXptr][i+1]-1,0x0,0,0))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",CIfXArr[CIfXptr][i+1]-1,0x4,-1,SetTo,"X",IndexAlloc-1,0x0,0,0))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",CIfXArr[CIfXptr][i],0x158,0,SetTo,"X",CIfXArr[CIfXptr][i],0x4,1,0))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",CIfXArr[CIfXptr][i],0x15C,0,SetTo,"X",CIfXArr[CIfXptr][i],0x0,0,1))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",CIfXArr[CIfXptr][i],0x178,0,SetTo,"X",IndexAlloc-1,0x158,1,0))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",CIfXArr[CIfXptr][i],0x17C,0,SetTo,"X",CIfXArr[CIfXptr][i],0x4,1,0))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",CIfXArr[CIfXptr][i],0x198,0,SetTo,"X",IndexAlloc-1,0x15C,1,0))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",CIfXArr[CIfXptr][i],0x19C,0,SetTo,"X",CIfXArr[CIfXptr][i+1]-1,0x0,0,0))
		end
	end

	table.remove(CIfXArr,CIfXptr)
	table.remove(CIfXPArr,CIfXptr)
	CIfXptr = CIfXptr - 1
end

-- 변수 삽입형 조건/액션 (T) ------------------------------------------------------------

function TCDeathsX(Player,Type,Value,Code,Mask)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 480 or Line < 0 then
		TCDeathX_LineOverflow()
	end
	local TCDeathsX = TCtrigX(Player,Index,0x1C8+0x4*Line,0,Type,Value,Mask)
	return TCDeathsX
end

function TCDeaths(Player,Type,Value,Code)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 480 or Line < 0 then
		TCDeath_LineOverflow()
	end
	local TCDeaths = TCtrigX(Player,Index,0x1C8+0x4*Line,0,Type,Value)
	return TCDeaths
end

function TSetCDeathsX(Player,Type,Value,Code,Mask)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 480 or Line < 0 then
		TSetCDeathsX_LineOverflow()
	end
	local TSetCDeathsX = TSetCtrig1X(Player,Index,0x1C8+0x4*Line,0,Type,Value,Mask)
	return TSetCDeathsX
end

function TSetCDeaths(Player,Type,Value,Code)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 480 or Line < 0 then
		TSetCDeaths_LineOverflow()
	end
	local TSetCDeaths = TSetCtrig1X(Player,Index,0x1C8+0x4*Line,0,Type,Value)
	return TSetCDeaths
end

function TNDeathsX(Player,Type,Value,Code,Mask)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 60 or Line < 0 then
		TNDeathX_LineOverflow()
	end
	if type(Player) == "number" then
		local TNDeathsX = TCtrigX(FixPlayer,Index,0x1C8+0x20*Line+0x4*Player,0,Type,Value,Mask)
		return TNDeathsX
	elseif Player[4] == "V" then
		if Player[5] == nil then
			Player[5] = 0
		end
		local TNDeathsX = TMemoryX(Vi(Player[2],Mem(FixPlayer,Index,0x1C8+0x20*Line+4*Player[5],0),Player[1],Player[3]),Type,Value,Mask)
		return TNDeathsX
	end
end

function TNDeaths(Player,Type,Value,Code)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 60 or Line < 0 then
		TNDeath_LineOverflow()
	end
	if type(Player) == "number" then
		local TNDeaths = TCtrigX(FixPlayer,Index,0x1C8+0x20*Line+0x4*Player,0,Type,Value)
		return TNDeaths
	elseif Player[4] == "V" then
		if Player[5] == nil then
			Player[5] = 0
		end
		local TNDeaths = TMemory(Vi(Player[2],Mem(FixPlayer,Index,0x1C8+0x20*Line+4*Player[5],0),Player[1],Player[3]),Type,Value)
		return TNDeaths
	end
end

function TSetNDeathsX(Player,Type,Value,Code,Mask)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 60 or Line < 0 then
		TSetNDeathsX_LineOverflow()
	end
	if type(Player) == "number" then
		local TSetNDeathsX = TSetCtrig1X(FixPlayer,Index,0x1C8+0x20*Line+0x4*Player,0,Type,Value,Mask)
		return TSetNDeathsX
	elseif Player[4] == "V" then
		if Player[5] == nil then
			Player[5] = 0
		end
		local TSetNDeathsX = TSetMemoryX(Vi(Player[2],Mem(FixPlayer,Index,0x1C8+0x20*Line+4*Player[5],0),Player[1],Player[3]),Type,Value,Mask)
		return TSetNDeathsX
	end
end

function TSetNDeaths(Player,Type,Value,Code)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 60 or Line < 0 then
		TSetNDeaths_LineOverflow()
	end
	if type(Player) == "number" then
		local TSetNDeaths = TSetCtrig1X(FixPlayer,Index,0x1C8+0x20*Line+0x4*Player,0,Type,Value)
		return TSetNDeaths
	elseif Player[4] == "V" then
		if Player[5] == nil then
			Player[5] = 0
		end
		local TSetNDeaths = TSetMemory(Vi(Player[2],Mem(FixPlayer,Index,0x1C8+0x20*Line+4*Player[5],0),Player[1],Player[3]),Type,Value)
		return TSetNDeaths
	end
end

function TVariableX(Player,Index,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TVariableX = TCtrigX(Player,Index,Addr,0,Type,Value,Mask)
	return TVariableX
end

function TSetVariableX(Player,Index,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TSetVariableX = TSetCtrig1X(Player,Index,Addr,0,Type,Value,Mask)
	return TSetVariableX
end

function TVariable(Variable,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TVariableX = TCtrigX(Variable[1],Variable[2],Addr,Variable[3],Type,Value,Mask)
	return TVariableX
end

function TSetVariable(Variable,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TSetVariableX = TSetCtrig1X(Variable[1],Variable[2],Addr,Variable[3],Type,Value,Mask)
	return TSetVariableX
end

function TVArrayX(VArray,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if VArray[4] ~= "V" then
		TVArrayX_InputData_Error()
	end

	local TVArrayX = TCtrigX(VArray[1],VArray[2],Addr,VArray[3],Type,Value,Mask)
	return TVArrayX
end

function TSetVArrayX(VArray,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if VArray[4] ~= "V" then
		TSetVArrayX_InputData_Error()
	end

	local TSetVArrayX = TSetCtrig1X(VArray[1],VArray[2],Addr,VArray[3],Type,Value,Mask)
	return TSetVArrayX
end

function TSVariableX(Player,SVariable,Line,Section,Type,Value,Mask)
	if SVariable[1] ~= "S" then
		SVariableX_InputData_Error()
	end
	if Line <= 0 or Line >= 33 then
		SVariableX_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TSVariableX = TCtrigX(Player,SVariable[2],Addr,0,Type,Value,Mask)
	return TSVariableX
end

function TSetSVariableX(Player,SVariable,Line,Section,Type,Value,Mask)
	if SVariable[1] ~= "S" then
		SetSVariableX_InputData_Error()
	end
	if Line <= 0 or Line >= 33 then
		SVariableX_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TSetSVariableX = TSetCtrig1X(Player,SVariable[2],Addr,0,Type,Value,Mask)
	return TSetSVariableX
end

function TSVariable(SVData,Section,Type,Value,Mask)
	local Line = SVData[6]
	if SVData[4] ~= "SV" then
		SVariable_InputData_Error()
	end
	if Line <= 0 or Line >= 33 then
		SVariable_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TSVariable = TCtrigX(SVData[1],SVData[2],Addr,SVData[3],Type,Value,Mask)
	return TSVariable
end

function TSetSVariable(SVData,Section,Type,Value,Mask)
	local Line = SVData[6]
	if SVData[4] ~= "SV" then
		SVariable_InputData_Error()
	end
	if Line <= 0 or Line >= 33 then
		SVariable_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TSetSVariable = TSetCtrig1X(SVData[1],SVData[2],Addr,SVData[3],Type,Value,Mask)
	return TSetSVariable
end

function TSVArrayX(SVArray,Section,Type,Value,Mask)
	local Line = SVArray[6]
	if SVArray[4] ~= "SV" then
		SVArrayX_InputData_Error()
	end
	if Line <= 0 or Line >= 33 then
		SVArrayX_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TSVArrayX = TCtrigX(SVArray[1],SVArray[2],Addr,SVArray[3],Type,Value,Mask)
	return TSVArrayX
end

function TSetSVArrayX(SVArray,Section,Type,Value,Mask)
	local Line = SVArray[6]
	if SVArray[4] ~= "SV" then
		SetSVArrayX_InputData_Error()
	end
	if Line <= 0 or Line >= 33 then
		SetSVArrayX_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TSetSVArrayX = TSetCtrig1X(SVArray[1],SVArray[2],Addr,SVArray[3],Type,Value,Mask)
	return TSetSVArrayX
end

function TCVar(Player,Index,Type,Value,Mask)
	return TVariableX(Player,Index,"Value",Type,Value,Mask)
end

function TSetCVar(Player,Index,Type,Value,Mask)
	return TSetVariableX(Player,Index,"Value",Type,Value,Mask)
end

function TNVar(Variable,Type,Value,Mask)
	return TVariableX(Variable[1],Variable[2],"Value",Type,Value,Mask)
end

function TSetNVar(Variable,Type,Value,Mask)
	return TSetVariableX(Variable[1],Variable[2],"Value",Type,Value,Mask)
end

function TCVAar(VArray,Type,Value,Mask)
	return TVArrayX(VArray,"Value",Type,Value,Mask)
end

function TSetCVAar(VArray,Type,Value,Mask)
	return TSetVArrayX(VArray,"Value",Type,Value,Mask)
end

function TCSVar(Player,SVariable,Line,Type,Value,Mask)
	return TSVariableX(Player,SVariable,Line,"Value",Type,Value,Mask)
end

function TSetCSVar(Player,SVariable,Line,Type,Value,Mask)
	return TSetSVariableX(Player,SVariable,Line,"Value",Type,Value,Mask)
end

function TNSVar(SVData,Type,Value,Mask)
	return TSVariable(SVData,"Value",Type,Value,Mask)
end

function TSetNSVar(SVData,Type,Value,Mask)
	return TSetSVariable(SVData,"Value",Type,Value,Mask)
end

function TCSVAar(SVArray,Type,Value,Mask)
	return TSVArrayX(SVArray,"Value",Type,Value,Mask)
end

function TSetCSVAar(SVArray,Type,Value,Mask)
	return TSetSVArrayX(SVArray,"Value",Type,Value,Mask)
end

function TSetCtrigX(Player1,Index1,Address1,Next1,Type,Player2,Index2,Address2,EPD2,Next2,Mask)
	return TSetMemoryX(Mem(Player1,Index1,Address1,Next1),Type,Mem(Player2,Index2,Address2,Next2,EPD2),Mask)
end

function TSetCtrig2X(Offset,Type,Player2,Index2,Address2,EPD2,Next2,Mask)
	return TSetMemoryX(Offset,Type,Mem(Player2,Index2,Address2,Next2,EPD2),Mask)
end

function TSetCtrig1X(Player1,Index1,Address1,Next1,Type,Value,Mask)
	return TSetMemoryX(Mem(Player1,Index1,Address1,Next1),Type,Value,Mask)
end

function TCtrigX(Player,Index,Address,Next,Type,Value,Mask)
	return TMemoryX(Mem(Player,Index,Address,Next),Type,Value,Mask)
end

function TDeaths(Player,Type,Value,UnitId)
	local PushLine = 0
	local TypeNum = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x14,1,0),
					SetCtrig1X("X","X",0x14,0,SetTo,UnitId[5],0xFFFF)}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
					SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0xC,1,0),
					SetCtrig1X("X","X",0xC,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		else
			TypeNum = TypeNum + 1
		end	
	end

	local TDeaths
	if TypeNum == 0 then
		TDeaths = Deaths(Player,Type,Value,UnitId)
	elseif TypeNum == 1 then
		TDeaths = CtrigX(Player[1],Player[2],Player[3],Player[4],Type,Value) -- UnitId 무시
	end 
	table.insert(PushCondArr,TDeaths)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TSetDeaths(Player,Type,Value,UnitId)
	local PushLine = 0
	local TypeNum = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		else
			TypeNum = TypeNum + 2
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		else
			TypeNum = TypeNum + 1
		end
	end

	local TSetDeaths
	if TypeNum == 0 then
		TSetDeaths = SetDeaths(Player,Type,Value,UnitId)
	elseif TypeNum == 1 then
		TSetDeaths = SetCtrig1X(Player[1],Player[2],Player[3],Player[4],Type,Value)
	elseif TypeNum == 2 then
		TSetDeaths = SetCtrig2X(Player,Type,Value[1],Value[2],Value[3],EPD2,Value[4])
	elseif TypeNum == 3 then
		TSetDeaths = SetCtrigX(Player[1],Player[2],Player[3],Player[4],Type,Value[1],Value[2],Value[3],Value[5],Value[4])
	end 
	table.insert(PushActArr,TSetDeaths)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TDeathsX(Player,Type,Value,UnitId,Mask)
	local PushLine = 0
	local TypeNum = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x14,1,0),
					SetCtrig1X("X","X",0x14,0,SetTo,UnitId[5],0xFFFF)}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Mask) == "table" then
		if Mask[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Mask})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Mask = TempData
		end

		if Mask[4] == "V" then
			if Mask[5] == nil then
				Mask[5] = 0
			end
			local X = {CallLabelAlways(Mask[1],Mask[2],Mask[3]),
					SetCtrig1X(Mask[1],Mask[2],0x148,Mask[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Mask[1],Mask[2],0x160,Mask[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Mask[1],Mask[2],0x158,Mask[3],SetTo,"X","X",0x8,1,0),
					SetCtrig1X("X","X",0x8,0,SetTo,Mask[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Mask = 0
			PushLine = PushLine + 1
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
					SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0xC,1,0),
					SetCtrig1X("X","X",0xC,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		else
			TypeNum = TypeNum + 1
		end	
	end

	local TDeathsX
	if TypeNum == 0  then
		TDeathsX = DeathsX(Player,Type,Value,UnitId,Mask)
	elseif TypeNum == 1 then
		TDeathsX = CtrigX(Player[1],Player[2],Player[3],Player[4],Type,Value,Mask) -- UnitId 무시
	end 
	table.insert(PushCondArr,TDeathsX)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TSetDeathsX(Player,Type,Value,UnitId,Mask)
	local PushLine = 0
	local TypeNum = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Mask) == "table" then
		if Mask[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Mask})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Mask = TempData
		end

		if Mask[4] == "V" then
			if Mask[5] == nil then
				Mask[5] = 0
			end
			local X = {CallLabelAlways(Mask[1],Mask[2],Mask[3]),
					SetCtrig1X(Mask[1],Mask[2],0x148,Mask[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Mask[1],Mask[2],0x160,Mask[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Mask[1],Mask[2],0x158,Mask[3],SetTo,"X","X",0x128,1,0),
					SetCtrig1X("X","X",0x128,0,SetTo,Mask[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Mask = 0
			PushLine = PushLine + 1
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		else
			TypeNum = TypeNum + 2
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		else
			TypeNum = TypeNum + 1
		end
	end

	local TSetDeathsX
	if TypeNum == 0 then
		TSetDeathsX = SetDeathsX(Player,Type,Value,UnitId,Mask)
	elseif TypeNum == 1 then
		TSetDeathsX = SetCtrig1X(Player[1],Player[2],Player[3],Player[4],Type,Value,Mask)
	elseif TypeNum == 2 then
		TSetDeathsX = SetCtrig2X(Player,Type,Value[1],Value[2],Value[3],Value[5],Value[4],Mask)
	elseif TypeNum == 3 then
		TSetDeathsX = SetCtrigX(Player[1],Player[2],Player[3],Player[4],Type,Value[1],Value[2],Value[3],Value[5],Value[4],Mask)
	end 
	table.insert(PushActArr,TSetDeathsX)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TMemory(Offset,Type,Value)
	local PushLine = 0
	local TypeNum = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			if type(Value[5]) == "number" then
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
						SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Value = 0
				PushLine = PushLine + 1
			else
				if Value[5][5] == nil then
					Value[5][5] = 0
				end
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
						SetCtrigX("X","X",0x10,0,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Value = 0
				PushLine = PushLine + 1
			end
		end
	end

	if type(Offset) == "table" then
		if Offset[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Offset})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Offset = TempData
		end

		if Offset[4] == "V" then
			if Offset[5] == nil then
				Offset[5] = 0
			end
			if type(Offset[5]) == "number" then
				local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
						SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0xC,1,0),
						SetCtrig1X("X","X",0xC,0,SetTo,Offset[5])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Offset = 0x58A364
				PushLine = PushLine + 1
			else
				local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
						SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0xC,1,0),
						SetCtrigX("X","X",0xC,0,SetTo,Offset[5][1],Offset[5][2],Offset[5][3],1,Offset[5][4])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Offset = 0x58A364
				PushLine = PushLine + 1
			end
		else
			TypeNum = TypeNum + 1
		end	
	end

	local TMemory
	if TypeNum == 0 then
		TMemory = FMemory(Offset,Type,Value)
	elseif TypeNum == 1 then
		TMemory = CtrigX(Offset[1],Offset[2],Offset[3],Offset[4],Type,Value)
	end 
	table.insert(PushCondArr,TMemory)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TSetMemory(Offset,Type,Value)
	local PushLine = 0
	local TypeNum = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			if type(Value[5]) == "number" then
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
						SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
				
				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Value = 0
				PushLine = PushLine + 1
			else
				if Value[5][5] == nil then
					Value[5][5] = 0
				end
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
						SetCtrigX("X","X",0x13C,0,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4])}
				
				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Value = 0
				PushLine = PushLine + 1
			end
		else
			TypeNum = TypeNum + 2
		end
	end

	if type(Offset) == "table" then
		if Offset[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Offset})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Offset = TempData
		end

		if Offset[4] == "V" then
			if Offset[5] == nil then
				Offset[5] = 0
			end
			if type(Offset[5]) == "number" then
				local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
						SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x138,1,0),
						SetCtrig1X("X","X",0x138,0,SetTo,Offset[5])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Offset = 0x58A364
				PushLine = PushLine + 1
			else
				local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
						SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x138,1,0),
						SetCtrigX("X","X",0x138,0,SetTo,Offset[5][1],Offset[5][2],Offset[5][3],1,Offset[5][4])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Offset = 0x58A364
				PushLine = PushLine + 1
			end
		else
			TypeNum = TypeNum + 1
		end
	end

	local TSetMemory 
	if TypeNum == 0 then
		TSetMemory = FSetMemory(Offset,Type,Value)
	elseif TypeNum == 1 then
		TSetMemory = SetCtrig1X(Offset[1],Offset[2],Offset[3],Offset[4],Type,Value)
	elseif TypeNum == 2 then
		TSetMemory = SetCtrig2X(Offset,Type,Value[1],Value[2],Value[3],Value[5],Value[4])
	elseif TypeNum == 3 then
		TSetMemory = SetCtrigX(Offset[1],Offset[2],Offset[3],Offset[4],Type,Value[1],Value[2],Value[3],Value[5],Value[4])
	end 
	table.insert(PushActArr,TSetMemory)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TMemoryX(Offset,Type,Value,Mask)
	local PushLine = 0
	local TypeNum = 0
	if type(Mask) == "table" then
		if Mask[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Mask})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Mask = TempData
		end

		if Mask[4] == "V" then
			if Mask[5] == nil then
				Mask[5] = 0
			end
			local X = {CallLabelAlways(Mask[1],Mask[2],Mask[3]),
					SetCtrig1X(Mask[1],Mask[2],0x148,Mask[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Mask[1],Mask[2],0x160,Mask[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Mask[1],Mask[2],0x158,Mask[3],SetTo,"X","X",0x8,1,0),
					SetCtrig1X("X","X",0x8,0,SetTo,Mask[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Mask = 0
			PushLine = PushLine + 1
		else
			TMemoryX_InputData_Error()
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			if type(Value[5]) == "number" then
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
						SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Value = 0
				PushLine = PushLine + 1
			else
				if Value[5][5] == nil then
					Value[5][5] = 0
				end
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
						SetCtrigX("X","X",0x10,0,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Value = 0
				PushLine = PushLine + 1
			end
		else
			TMemoryX_InputData_Error()
		end
	end

	if type(Offset) == "table" then
		if Offset[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Offset})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Offset = TempData
		end

		if Offset[4] == "V" then
			if Offset[5] == nil then
				Offset[5] = 0
			end
			if type(Offset[5]) == "number" then
				local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
						SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0xC,1,0),
						SetCtrig1X("X","X",0xC,0,SetTo,Offset[5])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Offset = 0x58A364
				PushLine = PushLine + 1
			else
				local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
						SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0xC,1,0),
						SetCtrigX("X","X",0xC,0,SetTo,Offset[5][1],Offset[5][2],Offset[5][3],1,Offset[5][4])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Offset = 0x58A364
				PushLine = PushLine + 1
			end
		else -- Mem
			TypeNum = TypeNum + 1
		end	
	end

	local TMemoryX 
	if TypeNum == 0 then
		TMemoryX = FMemoryX(Offset,Type,Value,Mask)
	elseif TypeNum == 1 then
		TMemoryX = CtrigX(Offset[1],Offset[2],Offset[3],Offset[4],Type,Value,Mask)
	end 
	table.insert(PushCondArr,TMemoryX)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TSetMemoryX(Offset,Type,Value,Mask)
	local PushLine = 0
	local TypeNum = 0
	if type(Mask) == "table" then
		if Mask[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Mask})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Mask = TempData
		end

		if Mask[4] == "V" then
			if Mask[5] == nil then
				Mask[5] = 0
			end
			local X = {CallLabelAlways(Mask[1],Mask[2],Mask[3]),
					SetCtrig1X(Mask[1],Mask[2],0x148,Mask[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Mask[1],Mask[2],0x160,Mask[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Mask[1],Mask[2],0x158,Mask[3],SetTo,"X","X",0x128,1,0),
					SetCtrig1X("X","X",0x128,0,SetTo,Mask[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Mask = 0
			PushLine = PushLine + 1
		else
			TSetMemoryX_InputData_Error()
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			if type(Value[5]) == "number" then
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
						SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
				
				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Value = 0
				PushLine = PushLine + 1
			else
				if Value[5][5] == nil then
					Value[5][5] = 0
				end
				local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
						SetCtrigX("X","X",0x13C,0,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4])}
				
				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Value = 0
				PushLine = PushLine + 1
			end
		else
			TypeNum = TypeNum + 2
		end
	end

	if type(Offset) == "table" then
		if Offset[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Offset})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Offset = TempData
		end

		if Offset[4] == "V" then
			if Offset[5] == nil then
				Offset[5] = 0
			end
			if type(Offset[5]) == "number" then
				local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
						SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x138,1,0),
						SetCtrig1X("X","X",0x138,0,SetTo,Offset[5])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Offset = 0x58A364
				PushLine = PushLine + 1
			else
				local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
						SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x138,1,0),
						SetCtrigX("X","X",0x138,0,SetTo,Offset[5][1],Offset[5][2],Offset[5][3],1,Offset[5][4])}

				table.insert(PushTrigArr,X)
				PushTrigStack = PushTrigStack + 1
				Offset = 0x58A364
				PushLine = PushLine + 1
			end
		else
			TypeNum = TypeNum + 1
		end
	end

	local TSetMemoryX
	if TypeNum == 0 then
		TSetMemoryX = FSetMemoryX(Offset,Type,Value,Mask)
	elseif TypeNum == 1 then
		TSetMemoryX = SetCtrig1X(Offset[1],Offset[2],Offset[3],Offset[4],Type,Value,Mask)
	elseif TypeNum == 2 then
		TSetMemoryX = SetCtrig2X(Offset,Type,Value[1],Value[2],Value[3],Value[5],Value[4],Mask)
	elseif TypeNum == 3 then
		TSetMemoryX = SetCtrigX(Offset[1],Offset[2],Offset[3],Offset[4],Type,Value[1],Value[2],Value[3],Value[5],Value[4],Mask)
	end 
	table.insert(PushActArr,TSetMemoryX)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TCommand(Player,Type,Value,UnitId)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x14,1,0),
					SetCtrig1X("X","X",0x14,0,SetTo,UnitId[5],0xFFFF)}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
					SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0xC,1,0),
					SetCtrig1X("X","X",0xC,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end	
	end

	local TCommand = Command(Player,Type,Value,UnitId)
	table.insert(PushCondArr,TCommand)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TBring(Player,Type,Value,UnitId,Location)
	local PushLine = 0

	if type(Location) == "table" then
		if Location[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Location})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Location = TempData
		end

		if Location[4] == "V" then
			if Location[5] == nil then
				Location[5] = 0
			end
			local X = {CallLabelAlways(Location[1],Location[2],Location[3]),
					SetCtrig1X(Location[1],Location[2],0x148,Location[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Location[1],Location[2],0x160,Location[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Location[1],Location[2],0x158,Location[3],SetTo,"X","X",0x8,1,0),
					SetCtrig1X("X","X",0x8,0,SetTo,Location[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Location = 0
			PushLine = PushLine + 1
		end
	end

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x14,1,0),
					SetCtrig1X("X","X",0x14,0,SetTo,UnitId[5],0xFFFF)}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
					SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0xC,1,0),
					SetCtrig1X("X","X",0xC,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end	
	end

	local TBring = Bring(Player,Type,Value,UnitId,Location)
	table.insert(PushCondArr,TBring)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TAccumulate(Player,Type,Value,ResourceType)
	local PushLine = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
					SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0xC,1,0),
					SetCtrig1X("X","X",0xC,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end	
	end

	local TAccumulate = Accumulate(Player,Type,Value,ResourceType)
	table.insert(PushCondArr,TAccumulate)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TCountdownTimer(Type,Value)
	local PushLine = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
					SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	local TCountdownTimer = CountdownTimer(Type,Value)
	table.insert(PushCondArr,TCountdownTimer)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TElapsedTime(Type,Value)
	local PushLine = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
					SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	local TElapsedTime = ElapsedTime(Type,Value)
	table.insert(PushCondArr,TElapsedTime)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TKills(Player,Type,Value,UnitId)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x14,1,0),
					SetCtrig1X("X","X",0x14,0,SetTo,UnitId[5],0xFFFF)}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
					SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0xC,1,0),
					SetCtrig1X("X","X",0xC,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end	
	end

	local TKills = Kills(Player,Type,Value,UnitId)
	table.insert(PushCondArr,TKills)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TScore(Player,ScoreType,Type,Value)
	local PushLine = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
					SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0xC,1,0),
					SetCtrig1X("X","X",0xC,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end	
	end

	local TScore = Score(Player,ScoreType,Type,Value)
	table.insert(PushCondArr,TScore)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TOpponents(Player,Type,Value)
	local PushLine = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x10,1,0),
					SetCtrig1X("X","X",0x10,0,SetTo,Value[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0xC,1,0),
					SetCtrig1X("X","X",0xC,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end	
	end

	local TOpponents = Opponents(Player,Type,Value)
	table.insert(PushCondArr,TOpponents)
	table.insert(CondLineArr,PushLine)
	return "TCond"
end

function TDisplayText(Text,AlwaysDisplay)
	local PushLine = 0
	if type(Text) == "table" then
		if Text[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Text})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Text = TempData
		end

		if Text[4] == "V" then
			if Text[5] == nil then
				Text[5] = 0
			end
			local X = {CallLabelAlways(Text[1],Text[2],Text[3]),
					SetCtrig1X(Text[1],Text[2],0x148,Text[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Text[1],Text[2],0x160,Text[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Text[1],Text[2],0x158,Text[3],SetTo,"X","X",0x12C,1,0),
					SetCtrig1X("X","X",0x12C,0,SetTo,Text[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Text = ""
			PushLine = PushLine + 1
		end
	end

	local TDisplayText = DisplayText(Text,AlwaysDisplay)
	table.insert(PushActArr,TDisplayText)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TSetMissionObjectives(Text)
	local PushLine = 0
	if type(Text) == "table" then
		if Text[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Text})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Text = TempData
		end

		if Text[4] == "V" then
			if Text[5] == nil then
				Text[5] = 0
			end
			local X = {CallLabelAlways(Text[1],Text[2],Text[3]),
					SetCtrig1X(Text[1],Text[2],0x148,Text[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Text[1],Text[2],0x160,Text[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Text[1],Text[2],0x158,Text[3],SetTo,"X","X",0x12C,1,0),
					SetCtrig1X("X","X",0x12C,0,SetTo,Text[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Text = ""
			PushLine = PushLine + 1
		end
	end

	local TSetMissionObjectives = SetMissionObjectives(Text)
	table.insert(PushActArr,TSetMissionObjectives)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TPlayWAV(WAVName)
	local PushLine = 0
	if type(WAVName) == "table" then
		if WAVName[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,WAVName})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			WAVName = TempData
		end

		if WAVName[4] == "V" then
			if WAVName[5] == nil then
				WAVName[5] = 0
			end
			local X = {CallLabelAlways(WAVName[1],WAVName[2],WAVName[3]),
					SetCtrig1X(WAVName[1],WAVName[2],0x148,WAVName[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(WAVName[1],WAVName[2],0x160,WAVName[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(WAVName[1],WAVName[2],0x158,WAVName[3],SetTo,"X","X",0x130,1,0),
					SetCtrig1X("X","X",0x130,0,SetTo,WAVName[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			WAVName = ""
			PushLine = PushLine + 1
		end
	end

	local TPlayWAV = PlayWAV(WAVName)
	table.insert(PushActArr,TPlayWAV)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TCreateUnit(Amount,UnitId,Location,Player)
	local PushLine = 0

	if type(Location) == "table" then
		if Location[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Location})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Location = TempData
		end

		if Location[4] == "V" then
			if Location[5] == nil then
				Location[5] = 0
			end
			local X = {CallLabelAlways(Location[1],Location[2],Location[3]),
					SetCtrig1X(Location[1],Location[2],0x148,Location[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Location[1],Location[2],0x160,Location[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Location[1],Location[2],0x158,Location[3],SetTo,"X","X",0x128,1,0),
					SetCtrig1X("X","X",0x128,0,SetTo,Location[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Location = 0
			PushLine = PushLine + 1
		end
	end

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Amount) == "table" then
		if Amount[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Amount})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Amount = TempData
		end

		if Amount[4] == "V" then
			if Amount[5] == nil then
				Amount[5] = 0
			end
			local X = {CallLabelAlways(Amount[1],Amount[2],Amount[3]),
					SetCtrig1X(Amount[1],Amount[2],0x148,Amount[3],SetTo,0xFF000000),
					SetCtrig1X(Amount[1],Amount[2],0x160,Amount[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Amount[1],Amount[2],0x158,Amount[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,Amount[5]*0x01000000,0xFF000000)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Amount = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TCreateUnit = CreateUnit(Amount,UnitId,Location,Player)
	table.insert(PushActArr,TCreateUnit)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TCreateUnitWithProperties(Amount,UnitId,Location,Player,Property)
	local PushLine = 0

	if type(Location) == "table" then
		if Location[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Location})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Location = TempData
		end

		if Location[4] == "V" then
			if Location[5] == nil then
				Location[5] = 0
			end
			local X = {CallLabelAlways(Location[1],Location[2],Location[3]),
					SetCtrig1X(Location[1],Location[2],0x148,Location[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Location[1],Location[2],0x160,Location[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Location[1],Location[2],0x158,Location[3],SetTo,"X","X",0x128,1,0),
					SetCtrig1X("X","X",0x128,0,SetTo,Location[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Location = 0
			PushLine = PushLine + 1
		end
	end

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Amount) == "table" then
		if Amount[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Amount})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Amount = TempData
		end

		if Amount[4] == "V" then
			if Amount[5] == nil then
				Amount[5] = 0
			end
			local X = {CallLabelAlways(Amount[1],Amount[2],Amount[3]),
					SetCtrig1X(Amount[1],Amount[2],0x148,Amount[3],SetTo,0xFF000000),
					SetCtrig1X(Amount[1],Amount[2],0x160,Amount[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Amount[1],Amount[2],0x158,Amount[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,Amount[5]*0x01000000,0xFF000000)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Amount = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TCreateUnitWithProperties = CreateUnitWithProperties(Amount,UnitId,Location,Player,Property)
	table.insert(PushActArr,TCreateUnitWithProperties)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TKillUnit(UnitId,Player)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TKillUnit = KillUnit(UnitId,Player)
	table.insert(PushActArr,TKillUnit)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end


function TKillUnitAt(Amount,UnitId,Location,Player)
	local PushLine = 0

	if type(Location) == "table" then
		if Location[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Location})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Location = TempData
		end

		if Location[4] == "V" then
			if Location[5] == nil then
				Location[5] = 0
			end
			local X = {CallLabelAlways(Location[1],Location[2],Location[3]),
					SetCtrig1X(Location[1],Location[2],0x148,Location[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Location[1],Location[2],0x160,Location[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Location[1],Location[2],0x158,Location[3],SetTo,"X","X",0x128,1,0),
					SetCtrig1X("X","X",0x128,0,SetTo,Location[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Location = 0
			PushLine = PushLine + 1
		end
	end

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Amount) == "table" then
		if Amount[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Amount})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Amount = TempData
		end

		if Amount[4] == "V" then
			if Amount[5] == nil then
				Amount[5] = 0
			end
			local X = {CallLabelAlways(Amount[1],Amount[2],Amount[3]),
					SetCtrig1X(Amount[1],Amount[2],0x148,Amount[3],SetTo,0xFF000000),
					SetCtrig1X(Amount[1],Amount[2],0x160,Amount[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Amount[1],Amount[2],0x158,Amount[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,Amount[5]*0x01000000,0xFF000000)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Amount = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TKillUnitAt = KillUnitAt(Amount,UnitId,Location,Player)
	table.insert(PushActArr,TKillUnitAt)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end


function TRemoveUnit(UnitId,Player)
	local PushLine = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TRemoveUnit = RemoveUnit(UnitId,Player)
	table.insert(PushActArr,TRemoveUnit)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TRemoveUnitAt(Amount,UnitId,Location,Player)
	local PushLine = 0

	if type(Location) == "table" then
		if Location[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Location})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Location = TempData
		end

		if Location[4] == "V" then
			if Location[5] == nil then
				Location[5] = 0
			end
			local X = {CallLabelAlways(Location[1],Location[2],Location[3]),
					SetCtrig1X(Location[1],Location[2],0x148,Location[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Location[1],Location[2],0x160,Location[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Location[1],Location[2],0x158,Location[3],SetTo,"X","X",0x128,1,0),
					SetCtrig1X("X","X",0x128,0,SetTo,Location[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Location = 0
			PushLine = PushLine + 1
		end
	end

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Amount) == "table" then
		if Amount[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Amount})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Amount = TempData
		end

		if Amount[4] == "V" then
			if Amount[5] == nil then
				Amount[5] = 0
			end
			local X = {CallLabelAlways(Amount[1],Amount[2],Amount[3]),
					SetCtrig1X(Amount[1],Amount[2],0x148,Amount[3],SetTo,0xFF000000),
					SetCtrig1X(Amount[1],Amount[2],0x160,Amount[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Amount[1],Amount[2],0x158,Amount[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,Amount[5]*0x01000000,0xFF000000)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Amount = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TRemoveUnitAt = RemoveUnitAt(Amount,UnitId,Location,Player)
	table.insert(PushActArr,TRemoveUnitAt)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TGiveUnits(Amount,UnitId,Player,Location,NewPlayer)
	local PushLine = 0

	if type(Location) == "table" then
		if Location[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Location})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Location = TempData
		end

		if Location[4] == "V" then
			if Location[5] == nil then
				Location[5] = 0
			end
			local X = {CallLabelAlways(Location[1],Location[2],Location[3]),
					SetCtrig1X(Location[1],Location[2],0x148,Location[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Location[1],Location[2],0x160,Location[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Location[1],Location[2],0x158,Location[3],SetTo,"X","X",0x128,1,0),
					SetCtrig1X("X","X",0x128,0,SetTo,Location[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Location = 0
			PushLine = PushLine + 1
		end
	end

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Amount) == "table" then
		if Amount[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Amount})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Amount = TempData
		end

		if Amount[4] == "V" then
			if Amount[5] == nil then
				Amount[5] = 0
			end
			local X = {CallLabelAlways(Amount[1],Amount[2],Amount[3]),
					SetCtrig1X(Amount[1],Amount[2],0x148,Amount[3],SetTo,0xFF000000),
					SetCtrig1X(Amount[1],Amount[2],0x160,Amount[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Amount[1],Amount[2],0x158,Amount[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,Amount[5]*0x01000000,0xFF000000)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Amount = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end
	
	if type(NewPlayer) == "table" and NewPlayer[1] ~= nil then
		if NewPlayer[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,NewPlayer})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			NewPlayer = TempData
		end

		if NewPlayer[4] == "V" then
			if NewPlayer[5] == nil then
				NewPlayer[5] = 0
			end
			local X = {CallLabelAlways(NewPlayer[1],NewPlayer[2],NewPlayer[3]),
					SetCtrig1X(NewPlayer[1],NewPlayer[2],0x148,NewPlayer[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(NewPlayer[1],NewPlayer[2],0x160,NewPlayer[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(NewPlayer[1],NewPlayer[2],0x158,NewPlayer[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,NewPlayer[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			NewPlayer = 0
			PushLine = PushLine + 1
		end
	end

	local TGiveUnits = GiveUnits(Amount,UnitId,Player,Location,NewPlayer)
	table.insert(PushActArr,TGiveUnits)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TMoveUnit(Amount,UnitId,Player,StartLocation,DestLocation)
	local PushLine = 0

	if type(StartLocation) == "table" then
		if StartLocation[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,StartLocation})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			StartLocation = TempData
		end

		if StartLocation[4] == "V" then
			if StartLocation[5] == nil then
				StartLocation[5] = 0
			end
			local X = {CallLabelAlways(StartLocation[1],StartLocation[2],StartLocation[3]),
					SetCtrig1X(StartLocation[1],StartLocation[2],0x148,StartLocation[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(StartLocation[1],StartLocation[2],0x160,StartLocation[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(StartLocation[1],StartLocation[2],0x158,StartLocation[3],SetTo,"X","X",0x128,1,0),
					SetCtrig1X("X","X",0x128,0,SetTo,StartLocation[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			StartLocation = 0
			PushLine = PushLine + 1
		end
	end

	if type(DestLocation) == "table" then
		if DestLocation[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,DestLocation})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			DestLocation = TempData
		end

		if DestLocation[4] == "V" then
			if DestLocation[5] == nil then
				DestLocation[5] = 0
			end
			local X = {CallLabelAlways(DestLocation[1],DestLocation[2],DestLocation[3]),
					SetCtrig1X(DestLocation[1],DestLocation[2],0x148,DestLocation[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(DestLocation[1],DestLocation[2],0x160,DestLocation[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(DestLocation[1],DestLocation[2],0x158,DestLocation[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,DestLocation[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			DestLocation = 0
			PushLine = PushLine + 1
		end
	end

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Amount) == "table" then
		if Amount[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Amount})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Amount = TempData
		end

		if Amount[4] == "V" then
			if Amount[5] == nil then
				Amount[5] = 0
			end
			local X = {CallLabelAlways(Amount[1],Amount[2],Amount[3]),
					SetCtrig1X(Amount[1],Amount[2],0x148,Amount[3],SetTo,0xFF000000),
					SetCtrig1X(Amount[1],Amount[2],0x160,Amount[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Amount[1],Amount[2],0x158,Amount[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,Amount[5]*0x01000000,0xFF000000)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Amount = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end
	
	local TMoveUnit = MoveUnit(Amount,UnitId,Player,StartLocation,DestLocation)
	table.insert(PushActArr,TMoveUnit)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TMoveLocation(Location,UnitId,Player,DestLocation)
	local PushLine = 0

	if type(Location) == "table" then
		if Location[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Location})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Location = TempData
		end

		if Location[4] == "V" then
			if Location[5] == nil then
				Location[5] = 0
			end
			local X = {CallLabelAlways(Location[1],Location[2],Location[3]),
					SetCtrig1X(Location[1],Location[2],0x148,Location[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Location[1],Location[2],0x160,Location[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Location[1],Location[2],0x158,Location[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,Location[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Location = 0
			PushLine = PushLine + 1
		end
	end

	if type(DestLocation) == "table" then
		if DestLocation[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,DestLocation})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			DestLocation = TempData
		end

		if DestLocation[4] == "V" then
			if DestLocation[5] == nil then
				DestLocation[5] = 0
			end
			local X = {CallLabelAlways(DestLocation[1],DestLocation[2],DestLocation[3]),
					SetCtrig1X(DestLocation[1],DestLocation[2],0x148,DestLocation[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(DestLocation[1],DestLocation[2],0x160,DestLocation[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(DestLocation[1],DestLocation[2],0x158,DestLocation[3],SetTo,"X","X",0x128,1,0),
					SetCtrig1X("X","X",0x128,0,SetTo,DestLocation[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			DestLocation = 0
			PushLine = PushLine + 1
		end
	end

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end
	
	local TMoveLocation = MoveLocation(Location,UnitId,Player,DestLocation)
	table.insert(PushActArr,TMoveLocation)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TOrder(UnitId,Player,StartLocation,OrderType,DestLocation)
	local PushLine = 0

	if type(StartLocation) == "table" then
		if StartLocation[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,StartLocation})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			StartLocation = TempData
		end

		if StartLocation[4] == "V" then
			if StartLocation[5] == nil then
				StartLocation[5] = 0
			end
			local X = {CallLabelAlways(StartLocation[1],StartLocation[2],StartLocation[3]),
					SetCtrig1X(StartLocation[1],StartLocation[2],0x148,StartLocation[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(StartLocation[1],StartLocation[2],0x160,StartLocation[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(StartLocation[1],StartLocation[2],0x158,StartLocation[3],SetTo,"X","X",0x128,1,0),
					SetCtrig1X("X","X",0x128,0,SetTo,StartLocation[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			StartLocation = 0
			PushLine = PushLine + 1
		end
	end

	if type(DestLocation) == "table" then
		if DestLocation[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,DestLocation})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			DestLocation = TempData
		end

		if DestLocation[4] == "V" then
			if DestLocation[5] == nil then
				DestLocation[5] = 0
			end
			local X = {CallLabelAlways(DestLocation[1],DestLocation[2],DestLocation[3]),
					SetCtrig1X(DestLocation[1],DestLocation[2],0x148,DestLocation[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(DestLocation[1],DestLocation[2],0x160,DestLocation[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(DestLocation[1],DestLocation[2],0x158,DestLocation[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,DestLocation[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			DestLocation = 0
			PushLine = PushLine + 1
		end
	end

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end
	
	local TOrder = Order(UnitId,Player,StartLocation,OrderType,DestLocation)
	table.insert(PushActArr,TOrder)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TModifyUnitEnergy(Amount,UnitId,Player,Location,Value)
	local PushLine = 0

	if type(Location) == "table" then
		if Location[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Location})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Location = TempData
		end

		if Location[4] == "V" then
			if Location[5] == nil then
				Location[5] = 0
			end
			local X = {CallLabelAlways(Location[1],Location[2],Location[3]),
					SetCtrig1X(Location[1],Location[2],0x148,Location[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Location[1],Location[2],0x160,Location[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Location[1],Location[2],0x158,Location[3],SetTo,"X","X",0x128,1,0),
					SetCtrig1X("X","X",0x128,0,SetTo,Location[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Location = 0
			PushLine = PushLine + 1
		end
	end

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Amount) == "table" then
		if Amount[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Amount})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Amount = TempData
		end

		if Amount[4] == "V" then
			if Amount[5] == nil then
				Amount[5] = 0
			end
			local X = {CallLabelAlways(Amount[1],Amount[2],Amount[3]),
					SetCtrig1X(Amount[1],Amount[2],0x148,Amount[3],SetTo,0xFF000000),
					SetCtrig1X(Amount[1],Amount[2],0x160,Amount[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Amount[1],Amount[2],0x158,Amount[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,Amount[5]*0x01000000,0xFF000000)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Amount = 0
			PushLine = PushLine + 1
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TModifyUnitEnergy = ModifyUnitEnergy(Amount,UnitId,Player,Location,Value)
	table.insert(PushActArr,TModifyUnitEnergy)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TModifyUnitHangarCount(Value,Amount,UnitId,Player,Location)
	local PushLine = 0

	if type(Location) == "table" then
		if Location[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Location})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Location = TempData
		end

		if Location[4] == "V" then
			if Location[5] == nil then
				Location[5] = 0
			end
			local X = {CallLabelAlways(Location[1],Location[2],Location[3]),
					SetCtrig1X(Location[1],Location[2],0x148,Location[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Location[1],Location[2],0x160,Location[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Location[1],Location[2],0x158,Location[3],SetTo,"X","X",0x128,1,0),
					SetCtrig1X("X","X",0x128,0,SetTo,Location[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Location = 0
			PushLine = PushLine + 1
		end
	end

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Amount) == "table" then
		if Amount[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Amount})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Amount = TempData
		end

		if Amount[4] == "V" then
			if Amount[5] == nil then
				Amount[5] = 0
			end
			local X = {CallLabelAlways(Amount[1],Amount[2],Amount[3]),
					SetCtrig1X(Amount[1],Amount[2],0x148,Amount[3],SetTo,0xFF000000),
					SetCtrig1X(Amount[1],Amount[2],0x160,Amount[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Amount[1],Amount[2],0x158,Amount[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,Amount[5]*0x01000000,0xFF000000)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Amount = 0
			PushLine = PushLine + 1
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TModifyUnitHangarCount = ModifyUnitHangarCount(Value,Amount,UnitId,Player,Location)
	table.insert(PushActArr,TModifyUnitHangarCount)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TModifyUnitHitPoints(Amount,UnitId,Player,Location,Value)
	local PushLine = 0

	if type(Location) == "table" then
		if Location[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Location})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Location = TempData
		end

		if Location[4] == "V" then
			if Location[5] == nil then
				Location[5] = 0
			end
			local X = {CallLabelAlways(Location[1],Location[2],Location[3]),
					SetCtrig1X(Location[1],Location[2],0x148,Location[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Location[1],Location[2],0x160,Location[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Location[1],Location[2],0x158,Location[3],SetTo,"X","X",0x128,1,0),
					SetCtrig1X("X","X",0x128,0,SetTo,Location[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Location = 0
			PushLine = PushLine + 1
		end
	end

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Amount) == "table" then
		if Amount[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Amount})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Amount = TempData
		end

		if Amount[4] == "V" then
			if Amount[5] == nil then
				Amount[5] = 0
			end
			local X = {CallLabelAlways(Amount[1],Amount[2],Amount[3]),
					SetCtrig1X(Amount[1],Amount[2],0x148,Amount[3],SetTo,0xFF000000),
					SetCtrig1X(Amount[1],Amount[2],0x160,Amount[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Amount[1],Amount[2],0x158,Amount[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,Amount[5]*0x01000000,0xFF000000)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Amount = 0
			PushLine = PushLine + 1
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TModifyUnitHitPoints = ModifyUnitHitPoints(Amount,UnitId,Player,Location,Value)
	table.insert(PushActArr,TModifyUnitHitPoints)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TModifyUnitResourceAmount(Amount,Player,Location,Value)
	local PushLine = 0

	if type(Location) == "table" then
		if Location[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Location})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Location = TempData
		end

		if Location[4] == "V" then
			if Location[5] == nil then
				Location[5] = 0
			end
			local X = {CallLabelAlways(Location[1],Location[2],Location[3]),
					SetCtrig1X(Location[1],Location[2],0x148,Location[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Location[1],Location[2],0x160,Location[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Location[1],Location[2],0x158,Location[3],SetTo,"X","X",0x128,1,0),
					SetCtrig1X("X","X",0x128,0,SetTo,Location[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Location = 0
			PushLine = PushLine + 1
		end
	end

	if type(Amount) == "table" then
		if Amount[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Amount})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Amount = TempData
		end

		if Amount[4] == "V" then
			if Amount[5] == nil then
				Amount[5] = 0
			end
			local X = {CallLabelAlways(Amount[1],Amount[2],Amount[3]),
					SetCtrig1X(Amount[1],Amount[2],0x148,Amount[3],SetTo,0xFF000000),
					SetCtrig1X(Amount[1],Amount[2],0x160,Amount[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Amount[1],Amount[2],0x158,Amount[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,Amount[5]*0x01000000,0xFF000000)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Amount = 0
			PushLine = PushLine + 1
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TModifyUnitResourceAmount = ModifyUnitResourceAmount(Amount,Player,Location,Value)
	table.insert(PushActArr,TModifyUnitResourceAmount)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TModifyUnitShields(Amount,UnitId,Player,Location,Value)
	local PushLine = 0

	if type(Location) == "table" then
		if Location[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Location})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Location = TempData
		end

		if Location[4] == "V" then
			if Location[5] == nil then
				Location[5] = 0
			end
			local X = {CallLabelAlways(Location[1],Location[2],Location[3]),
					SetCtrig1X(Location[1],Location[2],0x148,Location[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Location[1],Location[2],0x160,Location[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Location[1],Location[2],0x158,Location[3],SetTo,"X","X",0x128,1,0),
					SetCtrig1X("X","X",0x128,0,SetTo,Location[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Location = 0
			PushLine = PushLine + 1
		end
	end

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Amount) == "table" then
		if Amount[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Amount})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Amount = TempData
		end

		if Amount[4] == "V" then
			if Amount[5] == nil then
				Amount[5] = 0
			end
			local X = {CallLabelAlways(Amount[1],Amount[2],Amount[3]),
					SetCtrig1X(Amount[1],Amount[2],0x148,Amount[3],SetTo,0xFF000000),
					SetCtrig1X(Amount[1],Amount[2],0x160,Amount[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Amount[1],Amount[2],0x158,Amount[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,Amount[5]*0x01000000,0xFF000000)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Amount = 0
			PushLine = PushLine + 1
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TModifyUnitShields = ModifyUnitShields(Amount,UnitId,Player,Location,Value)
	table.insert(PushActArr,TModifyUnitShields)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TSetCountdownTimer(Type,Time)
	local PushLine = 0

	if type(Time) == "table" then
		if Time[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Time})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Time = TempData
		end

		if Time[4] == "V" then
			if Time[5] == nil then
				Time[5] = 0
			end
			local X = {CallLabelAlways(Time[1],Time[2],Time[3]),
					SetCtrig1X(Time[1],Time[2],0x148,Time[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Time[1],Time[2],0x160,Time[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Time[1],Time[2],0x158,Time[3],SetTo,"X","X",0x134,1,0),
					SetCtrig1X("X","X",0x134,0,SetTo,Time[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Time = 0
			PushLine = PushLine + 1
		end
	end

	local TSetCountdownTimer = SetCountdownTimer(Type,Time)
	table.insert(PushActArr,TSetCountdownTimer)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TSetResources(Player,Type,Value,ResourceType)
	local PushLine = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TSetResources = SetResources(Player,Type,Value,ResourceType)
	table.insert(PushActArr,TSetResources)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TSetScore(Player,Type,Value,ScoreType)
	local PushLine = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x13C,1,0),
					SetCtrig1X("X","X",0x13C,0,SetTo,Value[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Value = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TSetScore = SetScore(Player,Type,Value,ScoreType)
	table.insert(PushActArr,TSetScore)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TWait(Time)
	local PushLine = 0

	if type(Time) == "table" then
		if Time[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Time})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Time = TempData
		end

		if Time[4] == "V" then
			if Time[5] == nil then
				Time[5] = 0
			end
			local X = {CallLabelAlways(Time[1],Time[2],Time[3]),
					SetCtrig1X(Time[1],Time[2],0x148,Time[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Time[1],Time[2],0x160,Time[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Time[1],Time[2],0x158,Time[3],SetTo,"X","X",0x134,1,0),
					SetCtrig1X("X","X",0x134,0,SetTo,Time[5])}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Time = 0
			PushLine = PushLine + 1
		end
	end

	local TWait = Wait(Time)
	table.insert(PushActArr,TWait)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TSetDoodadState(State,UnitId,Player,Location)
	local PushLine = 0

	if type(Location) == "table" then
		if Location[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Location})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Location = TempData
		end

		if Location[4] == "V" then
			if Location[5] == nil then
				Location[5] = 0
			end
			local X = {CallLabelAlways(Location[1],Location[2],Location[3]),
					SetCtrig1X(Location[1],Location[2],0x148,Location[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Location[1],Location[2],0x160,Location[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Location[1],Location[2],0x158,Location[3],SetTo,"X","X",0x128,1,0),
					SetCtrig1X("X","X",0x128,0,SetTo,Location[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Location = 0
			PushLine = PushLine + 1
		end
	end

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TSetDoodadState = SetDoodadState(State,UnitId,Player,Location)
	table.insert(PushActArr,TSetDoodadState)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TSetInvincibility(State,UnitId,Player,Location)
	local PushLine = 0

	if type(Location) == "table" then
		if Location[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Location})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Location = TempData
		end

		if Location[4] == "V" then
			if Location[5] == nil then
				Location[5] = 0
			end
			local X = {CallLabelAlways(Location[1],Location[2],Location[3]),
					SetCtrig1X(Location[1],Location[2],0x148,Location[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Location[1],Location[2],0x160,Location[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Location[1],Location[2],0x158,Location[3],SetTo,"X","X",0x128,1,0),
					SetCtrig1X("X","X",0x128,0,SetTo,Location[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Location = 0
			PushLine = PushLine + 1
		end
	end

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x140,1,0),
					SetCtrig1X("X","X",0x140,0,SetTo,UnitId[5],0xFFFF)}
			
			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			UnitId = 0
			PushLine = PushLine + 1
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TSetInvincibility = SetInvincibility(State,UnitId,Player,Location)
	table.insert(PushActArr,TSetInvincibility)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

function TSetAllianceStatus(Player,Status)
	local PushLine = 0

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x138,1,0),
					SetCtrig1X("X","X",0x138,0,SetTo,Player[5])}

			table.insert(PushTrigArr,X)
			PushTrigStack = PushTrigStack + 1
			Player = 0
			PushLine = PushLine + 1
		end
	end

	local TSetAllianceStatus = SetAllianceStatus(Player,Status)
	table.insert(PushActArr,TSetAllianceStatus)
	table.insert(ActLineArr,PushLine)
	return "TAct"
end

-- 특수 조건 관련 조건/함수 (EUD/TT) --------------------------------------------------------

function EUDORInit(PlayerID) -- Flag1 = CORInit(P1) -> CORCond(Flag1) -- 구 함수 / 실질 사용X
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)

	EUDORPlayer = PlayerID
	EUDORFlag = FCode
	DoActionsX(PlayerID,SetCDeaths("X",SetTo,0,FCode))

	FlagAlloc = FlagAlloc + 1
	return FIndex
end

function EUDOR(AND_Conditions) -- {{<-And->}<-Or->{<-And->}<-Or->{<-And->}} -- 구 함수 / 실질 사용X
	CTrigger({EUDORPlayer},AND_Conditions,{SetCDeaths("X",SetTo,1,EUDORFlag)},{Preserved})
end

function EUDCond(FlagID) -- 구 함수 / 실질 사용X
	return CDeaths("X",Exactly,1,FlagIndex(FlagID))
end

function EUDCompare(PlayerID,Mode,TargetCond)  -- 구 함수 / 실질 사용X

	local FIndex
	if Mode == ">" or Mode == Above then
		FIndex = EUDAbove(PlayerID,TargetCond)
	elseif Mode == "<" or Mode == Below then
		FIndex = EUDBelow(PlayerID,TargetCond)
	elseif Mode == "!=" or Mode == NotSame then
		FIndex = EUDNotSame(PlayerID,TargetCond)
	else
		EUDCompare_TypeError()
	end
	return FIndex
end

function EUDNotSame(PlayerID,TargetCond) -- 구 함수 / 실질 사용X
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)

	DoActionsX(PlayerID,{SetCDeaths("X",SetTo,1,FCode),SetCtrig1X("X","X",0x28,PushTrigStack+1,SetTo,Exactly*65536,0xFF0000)})
	CTrigger(PlayerID,{TargetCond},{SetCDeaths("X",SetTo,0,FCode)},{Preserved})

	FlagAlloc = FlagAlloc + 1
	return FIndex
end

function EUDAbove(PlayerID,TargetCond) -- 구 함수 / 실질 사용X
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)

	DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode),
						SetCtrigX("X","X",0x4,PushTrigStack+1,SetTo,"X","X",0x0,0,PushTrigStack+2),
						SetCtrig1X("X","X",0x15C,PushTrigStack+1,SetTo,1),
						SetCtrig1X("X","X",0x28,PushTrigStack+1,SetTo,AtLeast*65536,0xFF0000)})
	CTrigger(PlayerID,{TargetCond},{SetCDeaths("X",SetTo,1,FCode)},{Preserved})
	DoActionsX(PlayerID,{SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1),
						SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1),
						SetCtrig1X("X","X",0x15C,-1,SetTo,0),
						SetCtrig1X("X","X",0x28,-1,SetTo,Exactly*65536,0xFF0000)})

	FlagAlloc = FlagAlloc + 1
	return FIndex
end

function EUDBelow(PlayerID,TargetCond) -- 구 함수 / 실질 사용X
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)

	DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode),
						SetCtrigX("X","X",0x4,PushTrigStack+1,SetTo,"X","X",0x0,0,PushTrigStack+2),
						SetCtrig1X("X","X",0x15C,PushTrigStack+1,SetTo,1),
						SetCtrig1X("X","X",0x28,PushTrigStack+1,SetTo,AtMost*65536,0xFF0000)})
	CTrigger(PlayerID,{TargetCond},{SetCDeaths("X",SetTo,1,FCode)},{Preserved})
	DoActionsX(PlayerID,{SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1),
						SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1),
						SetCtrig1X("X","X",0x15C,-1,SetTo,0),
						SetCtrig1X("X","X",0x28,-1,SetTo,Exactly*65536,0xFF0000)})

	FlagAlloc = FlagAlloc + 1
	return FIndex
end

function TTOR(OR_Conditions) -- 구버젼 호환용 함수
	VarXReleaseLock = 1
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)

	if type(OR_Conditions) ~= "table" then
		TTOR_InputData_Error()
	end 

	table.insert(ORPushCondArr,OR_Conditions)
	table.insert(ORFCodeArr,FCode)

	FlagAlloc = FlagAlloc + 1
	local TTOR = CDeaths("X",Exactly,1,FCode)
	return TTOR
end

function TTAND(AND_Conditions) -- 구버젼 호환용 함수
	if type(AND_Conditions) ~= "table" then
		TTAND_InputData_Error()
	end 
	local TTAND = {"AND"}
	table.insert(TTAND,AND_Conditions)
	return TTAND
end
------------------------------------------
function _TOR(...)
	local arg = table.pack(...)
	if arg.n < 2 then
		_TOr_InputData_Error()
	end 
	local TOr = {"OR"}
	for k = 1, arg.n do
		table.insert(TOr,arg[k])
	end
	return TOr
end

function _TAND(...) 
	local arg = table.pack(...)
	if arg.n < 2 then
		_TAnd_InputData_Error()
	end 
	local TAnd = {"AND"}
	for k = 1, arg.n do
		table.insert(TAnd,arg[k])
	end
	return TAnd
end

function _TNOT(...)
	local arg = table.pack(...)
	if arg.n ~= 1 then
		_TNot_InputData_Error()
	end
	local TNot = {"NOT"}
	table.insert(TNot,arg[1])
	return TNot
end

function _TC(...) -- Convert
	local TCond = {"X"}
	local arg = table.pack(...)
	arg[1].__trg_magic = "condition"
	table.insert(TCond,arg)
	return TCond
end

function _TB(...) -- Bind (MAX 16)
	local arg = table.pack(...)
	if arg.n > 16 or arg.n < 2 then
		_TBind_InputData_Error()
	end
	local TBind = {"B"}
	for k = 1, arg.n do
		table.insert(TBind,arg[k])
	end
	return TBind
end

function _TP(...) -- _TPack : _TAnd + Input Arr
	VarXReleaseLock = 2
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)

	local arg = table.pack(...)
	if arg.n < 1 then
		_TPack_InputData_Error()
	end

	_TPushCondArr = {}
	_TFCodeArr = {}
	_TPushVarXAlloc = {}
	table.insert(_TPushVarXAlloc,VarXAlloc)
	table.insert(_TPushVarXAlloc,WarXAlloc)
	table.insert(_TPushVarXAlloc,{})
	for i = 1, 32 do
		table.insert(_TPushVarXAlloc[3],SVarXAlloc[i])
	end
	table.insert(_TPushCondArr,arg)
	table.insert(_TFCodeArr,FCode)

	FlagAlloc = FlagAlloc + 1
	local _TTCond = CDeaths("X",Exactly,arg.n,FCode)
	return _TTCond
end

----------------------------------------------------

function _TMemoryX(Offset,Type,Value,Mask)
	return {"T","TMemoryX",Offset,Type,Value,Mask}
end

function _TMemory(Offset,Type,Value)
	return {"T","TMemory",Offset,Type,Value}
end

function _TCVar(Player,Index,Type,Value,Mask)
	return {"T","TCVar",Player,Index,Type,Value,Mask}
end

function _TNVar(Variable,Type,Value,Mask)
	return {"T","TCVar",Variable[1],Variable[2],Type,Value,Mask}
end

function _TCVAar(VArray,Type,Value,Mask)
	return {"T","TCVAar",VArray,Type,Value,Mask}
end

function _TVariableX(Player,Index,Section,Type,Value,Mask)
	return {"T","TVariableX",Player,Index,Section,Type,Value,Mask}
end

function _TVariable(Variable,Section,Type,Value,Mask)
	return {"T","TVariable",Variable,Section,Type,Value,Mask}
end

function _TVArrayX(VArray,Section,Type,Value,Mask)
	return {"T","TVArrayX",VArray,Section,Type,Value,Mask}
end

function _TNDeathsX(Player,Type,Value,Code,Mask)
	return {"T","TNDeathsX",Player,Type,Value,Code,Mask}
end

function _TNDeaths(Player,Type,Value,Code)
	return {"T","TNDeaths",Player,Type,Value,Code}
end

function _TCDeathsX(Player,Type,Value,Code,Mask)
	return {"T","TCDeathsX",Player,Type,Value,Code,Mask}
end

function _TCDeaths(Player,Type,Value,Code)
	return {"T","TCDeaths",Player,Type,Value,Code}
end

function _TCtrigX(Player,Index,Address,Next,Type,Value,Mask)
	return {"T","TCtrigX",Player,Index,Address,Next,Type,Value,Mask}
end

function _TDeaths(Player,Type,Value,UnitId)
	return {"T","TDeaths",Player,Type,Value,UnitId}
end

function _TDeathsX(Player,Type,Value,UnitId,Mask)
	return {"T","TDeathsX",Player,Type,Value,UnitId,Mask}
end

function _TCommand(Player,Type,Value,UnitId)
	return {"T","TCommand",Player,Type,Value,UnitId}
end

function _TBring(Player,Type,Value,UnitId,Location)
	return {"T","TBring",Player,Type,Value,UnitId,Location}
end

function _TAccumulate(Player,Type,Value,ResourceType)
	return {"T","TAccumulate",Player,Type,Value,ResourceType}
end

function _TCountdownTimer(Type,Value)
	return {"T","TCountdownTimer",Type,Value}
end

function _TElapsedTime(Type,Value)
	return {"T","TElapsedTime",Type,Value}
end

function _TKills(Player,Type,Value,UnitId)
	return {"T","TKills",Player,Type,Value,UnitId}
end

function _TScore(Player,ScoreType,Type,Value)
	return {"T","TScore",Player,ScoreType,Type,Value}
end

function _TOpponents(Player,Type,Value)
	return {"T","TOpponents",Player,Type,Value}
end

function _TTbytecmp(Dest,SourceVA,Size,Distance)
	return {"TT","TTbytecmp",Dest,SourceVA,Size,Distance}
end

function _TTbytecmpX(Dest,DestX,SourceVA,Size,Distance)
	return {"TT","TTbytecmpX",Dest,DestX,SourceVA,Size,Distance}
end

function _TTepdcmp(Dest,Source,Size,Mask)
	return {"TT","TTepdcmp",Dest,Source,Size,Mask}
end

function _TTLMemoryX(Offset,Type,Value,Mask)
	return {"TT","TTLMemoryX",Offset,Type,Value,Mask}
end

function _TTLMemory(Offset,Type,Value)
	return {"TT","TTLMemory",Offset,Type,Value}
end

function _TTMemoryX(Offset,Type,Value,Mask)
	return {"TT","TTMemoryX",Offset,Type,Value,Mask}
end

function _TTMemory(Offset,Type,Value)
	return {"TT","TTMemory",Offset,Type,Value}
end

function _TTCVar(Player,Index,Type,Value,Mask)
	return {"TT","TTCVar",Player,Index,Type,Value,Mask}
end

function _TTNVar(Variable,Type,Value,Mask)
	return {"TT","TTCVar",Variable[1],Variable[2],Type,Value,Mask}
end

function _TTCVAar(VArray,Type,Value,Mask)
	return {"TT","TTCVAar",VArray,Type,Value,Mask}
end

function _TTVariableX(Player,Index,Section,Type,Value,Mask)
	return {"TT","TTVariableX",Player,Index,Section,Type,Value,Mask}
end

function _TTVariable(Variable,Section,Type,Value,Mask)
	return {"TT","TTVariable",Variable,Section,Type,Value,Mask}
end

function _TTVArrayX(VArray,Section,Type,Value,Mask)
	return {"TT","TTVArrayX",VArray,Section,Type,Value,Mask}
end

function _TTNDeathsX(Player,Type,Value,Code,Mask)
	return {"TT","TTNDeathsX",Player,Type,Value,Code,Mask}
end

function _TTNDeaths(Player,Type,Value,Code)
	return {"TT","TTNDeaths",Player,Type,Value,Code}
end

function _TTCDeathsX(Player,Type,Value,Code,Mask)
	return {"TT","TTCDeathsX",Player,Type,Value,Code,Mask}
end

function _TTCDeaths(Player,Type,Value,Code)
	return {"TT","TTCDeaths",Player,Type,Value,Code}
end

function _TTCtrigX(Player,Index,Address,Next,Type,Value,Mask)
	return {"TT","TTCtrigX",Player,Index,Address,Next,Type,Value,Mask}
end

function _TTDeaths(Player,Type,Value,UnitId)
	return {"TT","TTDeaths",Player,Type,Value,UnitId}
end

function _TTDeathsX(Player,Type,Value,UnitId,Mask)
	return {"TT","TTDeathsX",Player,Type,Value,UnitId,Mask}
end

function _TTCommand(Player,Type,Value,UnitId)
	return {"TT","TTCommand",Player,Type,Value,UnitId}
end

function _TTBring(Player,Type,Value,UnitId,Location)
	return {"TT","TTBring",Player,Type,Value,UnitId,Location}
end

function _TTAccumulate(Player,Type,Value,ResourceType)
	return {"TT","TTAccumulate",Player,Type,Value,ResourceType}
end

function _TTCountdownTimer(Type,Value)
	return {"TT","TTCountdownTimer",Type,Value}
end

function _TTElapsedTime(Type,Value)
	return {"TT","TTElapsedTime",Type,Value}
end

function _TTKills(Player,Type,Value,UnitId)
	return {"TT","TTKills",Player,Type,Value,UnitId}
end

function _TTScore(Player,ScoreType,Type,Value)
	return {"TT","TTScore",Player,ScoreType,Type,Value}
end

function _TTOpponents(Player,Type,Value)
	return {"TT","TTOpponents",Player,Type,Value}
end

function _TTWariableX(Player,Index,Section,Type,Value,Mask)
	return {"TT","TTWariableX",Player,Index,Section,Type,Value,Mask}
end
function _TTWariable(Wariable,Section,Type,Value,Mask)
	return {"TT","TTWariable",Wariable,Section,Type,Value,Mask}
end
function _TTWArrayX(WArray,Section,Type,Value,Mask)
	return {"TT","TTWArrayX",WArray,Section,Type,Value,Mask}
end
function _TTCWar(Player,Index,Type,Value,Mask)
	return {"TT","TTCWar",Player,Index,Type,Value,Mask}
end
function _TTNWar(Wariable,Type,Value,Mask)
	return {"TT","TTNWar",Wariable,Type,Value,Mask}
end
function _TTCWAar(WArray,Type,Value,Mask)
	return {"TT","TTCWar",WArray,Type,Value,Mask}
end
function _TWariableX(Player,Index,Section,Type,Value,Mask)
	return {"T","TWariableX",Player,Index,Section,Type,Value,Mask}
end
function _TWariable(Wariable,Section,Type,Value,Mask)
	return {"T","TWariable",Wariable,Section,Type,Value,Mask}
end
function _TWArrayX(WArray,Section,Type,Value,Mask)
	return {"T","TWArrayX",WArray,Section,Type,Value,Mask}
end
function _TCWar(Player,Index,Type,Value,Mask)
	return {"T","TCWar",Player,Index,Type,Value,Mask}
end
function _TNWar(Wariable,Type,Value,Mask)
	return {"T","TNWar",Wariable,Type,Value,Mask}
end
function _TCWAar(WArray,Type,Value,Mask)
	return {"T","TCWAar",WArray,Type,Value,Mask}
end

function _TSVariableX(Player,SVariable,Line,Section,Type,Value,Mask)
	return {"T","TSVariableX",Player,SVariable,Line,Section,Type,Value,Mask}
end
function _TSVariable(SVData,Section,Type,Value,Mask)
	return {"T","TSVariable",SVData,Section,Type,Value,Mask}
end
function _TSVArrayX(SVArray,Section,Type,Value,Mask)
	return {"T","TSVArrayX",SVArray,Section,Type,Value,Mask}
end
function _TCSVar(Player,SVariable,Line,Type,Value,Mask)
	return {"T","TCSVar",Player,SVariable,Line,Type,Value,Mask}
end
function _TNSVar(SVData,Type,Value,Mask)
	return {"T","TNSVar",SVData,Type,Value,Mask}
end
function _TCSVAar(SVArray,Type,Value,Mask)
	return {"T","TCSVAar",SVArray,Type,Value,Mask}
end

function _TTCSVar(Player,SVariable,Line,Type,Value,Mask)
	return {"TT","TTCSVar",Player,SVariable,Line,Type,Value,Mask}
end
function _TTNSVar(SVData,Type,Value,Mask)
	return {"TT","TTNSVar",SVData,Type,Value,Mask}
end
function _TTCSVAar(SVArray,Type,Value,Mask)
	return {"TT","TTCSVAar",SVArray,Type,Value,Mask}
end
function _TTSVariableX(Player,SVariable,Line,Section,Type,Value,Mask)
	return {"TT","TTSVariableX",Player,SVariable,Line,Section,Type,Value,Mask}
end
function _TTSVariable(SVData,Section,Type,Value,Mask)
	return {"TT","TTSVariable",SVData,Section,Type,Value,Mask}
end
function _TTSVArrayX(SVArray,Section,Type,Value,Mask)
	return {"TT","TTSVArrayX",SVArray,Section,Type,Value,Mask}
end

function _TTFunc(CFunction,Parameter,flag)
	return {"TT","TTFunc",CFunction,Parameter,flag}
end

function _TTKeyPress(KeyName,Status)
	return {"TT","TTKeyPress",KeyName,Status}
end
function _TTMousePress(KeyName,Status)
	return {"TT","TTMousePress",KeyName,Status}
end

function _THotkeyUnit(Player,Group,Index,Type,Value)
	return {"T","THotkeyUnit",Player,Group,Index,Type,Value}
end
function _TTHotKeyUnit(Player,Group,Index,Type,Value)
	return {"TT","TTHotKeyUnit",Player,Group,Index,Type,Value}
end

-----------------------------------------------------------------

function TTFunc(CFunction,Parameter,flag)
	local Mode = 30
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)

	local Pack = {}
	table.insert(Pack,CFunction)
	table.insert(Pack,Parameter)

	table.insert(TTPushTrigArr,{})
	table.insert(TTPushCondArr,Pack)
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTfuncX
	if flag == 0 then
		TTFuncX = CDeaths("X",Exactly,0,FCode)
	else
		TTFuncX = CDeaths("X",AtLeast,1,FCode)
	end
	return TTFuncX
end

function TWariableX(Player,Index,Section,Type,Value,Mask)
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local TWariableX
	TWariableX = TCtrigX(Player,Index,Addr,0,Type,Value,Mask)
	return TWariableX
end

function TSetWariableX(Player,Index,Section,Type,Value,Mask)
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local TSetWariableX
	TSetWariableX = TSetCtrig1X(Player,Index,Addr,0,Type,Value,Mask)
	return TSetWariableX
end

function TWariable(Wariable,Section,Type,Value,Mask)
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local TWariableX
	TWariableX = TCtrigX(Wariable[1],Wariable[2],Addr,Wariable[3],Type,Value,Mask)
	return TWariableX
end

function TSetWariable(Wariable,Section,Type,Value,Mask)
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local TSetWariableX
	TSetWariableX = TSetCtrig1X(Wariable[1],Wariable[2],Addr,Wariable[3],Type,Value,Mask)
	return TSetWariableX
end

function TWArrayX(WArray,Section,Type,Value,Mask)
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if WArray[4] ~= "W" then
		TWArrayX_InputData_Error()
	end

	local TWArrayX
	TWArrayX = TCtrigX(WArray[1],WArray[2],Addr,WArray[3],Type,Value,Mask)
	return TWArrayX
end

function TSetWArrayX(WArray,Section,Type,Value,Mask)
	local Addr
	if Section == "Next" then
		Addr = 0x4
	elseif Section == "EPD1" then
		Addr = 0x158
	elseif Section == "Type1" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value1" then
		Addr = 0x15C
	elseif Section == "Mask1" then
		Addr = 0x148
	elseif Section == "Flag1" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	elseif Section == "EPD2" then
		Addr = 0x198
	elseif Section == "Type2" then
		Addr = 0x1A0
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value2" then
		Addr = 0x19C
	elseif Section == "Mask2" then
		Addr = 0x188
	elseif Section == "Flag2" then
		Addr = 0x1A4
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if WArray[4] ~= "W" then
		TSetWArrayX_InputData_Error()
	end

	local TSetWArrayX
	TSetWArrayX = TSetCtrig1X(WArray[1],WArray[2],Addr,WArray[3],Type,Value,Mask)
	return TSetWArrayX
end

function TCWar(Player,Index,Type,Value,Mask)
	if type(Value) == "table" and #Value == 1 then
		return TWariableX(Player,Index,"Value2",Type,Value[1],Mask)
	else
		return TWariableX(Player,Index,"Value1",Type,Value,Mask)
	end
end

function TSetCWar(Player,Index,Type,Value,Mask)
	if type(Value) == "table" and #Value == 1 then
		return TSetWariableX(Player,Index,"Value2",Type,Value[1],Mask)
	else
		return TSetWariableX(Player,Index,"Value1",Type,Value,Mask)
	end
end

function TNWar(Wariable,Type,Value,Mask)
	if type(Value) == "table" and #Value == 1 then
		return TWariableX(Wariable[1],Wariable[2],"Value2",Type,Value[1],Mask)
	else
		return TWariableX(Wariable[1],Wariable[2],"Value1",Type,Value,Mask)
	end
end

function TSetNWar(Wariable,Type,Value,Mask)
	if type(Value) == "table" and #Value == 1 then
		return TSetWariableX(Wariable[1],Wariable[2],"Value2",Type,Value[1],Mask)
	else
		return TSetWariableX(Wariable[1],Wariable[2],"Value1",Type,Value,Mask)
	end
end

function TCWAar(WArray,Type,Value,Mask)
	if type(Value) == "table" and #Value == 1 then
		return TWArrayX(WArray,"Value2",Type,Value[1],Mask)
	else
		return TWArrayX(WArray,"Value1",Type,Value,Mask)
	end
end

function TSetCWAar(WArray,Type,Value,Mask)
	if type(Value) == "table" and #Value == 1 then
		return TSetWArrayX(WArray,"Value2",Type,Value[1],Mask)
	else
		return TSetWArrayX(WArray,"Value1",Type,Value,Mask)
	end
end

function TTepdcmp(Dest,Source,Size,Mask)
	local Mode = 22
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)

	local Pack = {}
	table.insert(Pack,Dest)
	table.insert(Pack,Source)
	table.insert(Pack,Size)
	table.insert(Pack,Mask)

	table.insert(TTPushTrigArr,{})
	table.insert(TTPushCondArr,Pack)
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTepdcmp = CDeaths("X",Exactly,1,FCode)
	return TTepdcmp
end

function TTbytecmp(Dest,SourceVA,Size,Distance)
	local Mode = 9
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)

	local Pack = {"bytecmp"}
	table.insert(Pack,Dest)
	table.insert(Pack,SourceVA)
	table.insert(Pack,Size)
	table.insert(Pack,Distance)

	table.insert(TTPushTrigArr,{})
	table.insert(TTPushCondArr,Pack)
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTbytecmp = CDeaths("X",Exactly,1,FCode)
	return TTbytecmp
end

function TTbytecmpX(Dest,DestX,SourceVA,Size,Distance)
	local Mode = 9
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)

	local Pack = {"bytecmpX"}
	table.insert(Pack,Dest)
	table.insert(Pack,DestX)
	table.insert(Pack,SourceVA)
	table.insert(Pack,Size)
	table.insert(Pack,Distance)

	table.insert(TTPushTrigArr,{})
	table.insert(TTPushCondArr,Pack)
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTbytecmpX = CDeaths("X",Exactly,1,FCode)
	return TTbytecmpX
end

function TTWariableX(Player,Index,Section,Type,Value,Mask)
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = {0xFF000000,0xFF000000}
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = {0xFF,0xFF}
		end
	end

	local TTWariableX
	TTWariableX = {TTLMemoryX({{Player,Index,Addr,0},{Player,Index,Addr+0x40,0}},Type,Value,Mask)}
	return TTWariableX
end

function TTWariable(Wariable,Section,Type,Value,Mask)
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = {0xFF000000,0xFF000000}
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = {0xFF,0xFF}
		end
	end

	local TTWariable
	TTWariable = {TTLMemoryX({{Wariable[1],Wariable[2],Addr,Wariable[3]},{Wariable[1],Wariable[2],Addr+0x40,Wariable[3]}},Type,Value,Mask)}
	return TTWariable
end

function TTWArrayX(WArray,Section,Type,Value,Mask)
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = {0xFF000000,0xFF000000}
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = {0xFF,0xFF}
		end
	end

	if WArray[4] ~= "W" then
		TTWArrayX_InputData_Error()
	end

	local TTWArrayX
	TTWArrayX = {TTLMemoryX({{WArray[1],WArray[2],Addr,WArray[3]},{WArray[1],WArray[2],Addr+0x40,WArray[3]}},Type,Value,Mask)}
	return TTWArrayX
end

function TTCSVar(Player,SVariable,Line,Type,Value,Mask)
	return TTSVariableX(Player,SVariable,Line,"Value",Type,Value,Mask)
end

function TTNSVar(SVData,Type,Value,Mask)
	return TTSVariable(SVData,"Value",Type,Value,Mask)
end

function TTCSVAar(SVArray,Type,Value,Mask)
	return TTSVArrayX(SVArray,"Value",Type,Value,Mask)
end

function TTCWar(Player,Index,Type,Value,Mask)
	return TTWariableX(Player,Index,"Value",Type,Value,Mask)
end

function TTNWar(Wariable,Type,Value,Mask)
	return TTWariableX(Wariable[1],Wariable[2],"Value",Type,Value,Mask)
end

function TTCWAar(WArray,Type,Value,Mask)
	return TTWArrayX(WArray,"Value",Type,Value,Mask)
end

function TTCVar(Player,Index,Type,Value,Mask)
	return TTVariableX(Player,Index,"Value",Type,Value,Mask)
end

function TTNVar(Variable,Type,Value,Mask)
	return TTVariableX(Variable[1],Variable[2],"Value",Type,Value,Mask)
end

function TTCVAar(VArray,Type,Value,Mask)
	return TTVArrayX(VArray,"Value",Type,Value,Mask)
end

function TTSVariableX(Player,SVariable,Line,Section,Type,Value,Mask)
	if SVariable[1] ~= "S" then
		SVariableX_InputData_Error()
	end
	if Line <= 0 or Line >= 33 then
		SVariableX_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TTSVariableX = TTCtrigX(Player,SVariable[2],Addr,0,Type,Value,Mask)
	return TTSVariableX
end

function TTSVariable(SVData,Section,Type,Value,Mask)
	local Line = SVData[6]
	if SVData[4] ~= "SV" then
		SVariable_InputData_Error()
	end
	if Line <= 0 or Line >= 33 then
		SVariable_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TTSVariableX = TTCtrigX(SVData[1],SVData[2],Addr,SVData[3],Type,Value,Mask)
	return TTSVariableX
end

function TTSVArrayX(SVArray,Section,Type,Value,Mask)
	local Line = SVArray[6]
	if SVArray[4] ~= "SV" then
		SVArrayX_InputData_Error()
	end
	if Line <= 0 or Line >= 33 then
		SVArrayX_InputData_Error()
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158+0x40*(Line-1)
	elseif Section == "Type" then
		Addr = 0x160+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C+0x40*(Line-1)
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148+0x40*(Line-1)
	elseif Section == "Flag" then
		Addr = 0x164+0x40*(Line-1)
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TTSVArrayX = TTCtrigX(SVArray[1],SVArray[2],Addr,SVArray[3],Type,Value,Mask)
	return TTSVArrayX
end

function TTVariableX(Player,Index,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TTVariableX = TTCtrigX(Player,Index,Addr,0,Type,Value,Mask)
	return TTVariableX
end

function TTVariable(Variable,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	local TTVariableX = TTCtrigX(Variable[1],Variable[2],Addr,Variable[3],Type,Value,Mask)
	return TTVariableX
end

function TTVArrayX(VArray,Section,Type,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Addr
	if Section == "EPD" then
		Addr = 0x158
	elseif Section == "Type" then
		Addr = 0x160
		if Mask == nil then
			Mask = 0xFF000000
		end
	elseif Section == "Value" then
		Addr = 0x15C
	elseif Section == "Next" then
		Addr = 0x4
	elseif Section == "Mask" then
		Addr = 0x148
	elseif Section == "Flag" then
		Addr = 0x164
		if Mask == nil then
			Mask = 0xFF
		end
	end

	if VArray[4] ~= "V" then
		TTVArrayX_InputData_Error()
	end

	local TTVArrayX = TTCtrigX(VArray[1],VArray[2],Addr,VArray[3],Type,Value,Mask)
	return TTVArrayX
end

function TTNDeathsX(Player,Type,Value,Code,Mask)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 60 or Line < 0 then
		TTNDeathX_LineOverflow()
	end
	if type(Player) == "number" then
		local TTNDeathsX = TTCtrigX(FixPlayer,Index,0x1C8+0x20*Line+0x4*Player,0,Type,Value,Mask)
		return TTNDeathsX
	elseif Player[4] == "V" then
		if Player[5] == nil then
			Player[5] = 0
		end
		local TTNDeathsX = TTMemoryX(Vi(Player[2],Mem(FixPlayer,Index,0x1C8+0x20*Line+4*Player[5],0),Player[1],Player[3]),Type,Value,Mask)
		return TTNDeathsX
	end
end

function TTNDeaths(Player,Type,Value,Code)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 60 or Line < 0 then
		TTNDeath_LineOverflow()
	end
	if type(Player) == "number" then
		local TTNDeaths = TTCtrigX(FixPlayer,Index,0x1C8+0x20*Line+0x4*Player,0,Type,Value)
		return TTNDeaths
	elseif Player[4] == "V" then
		if Player[5] == nil then
			Player[5] = 0
		end
		local TTNDeaths = TTMemory(Vi(Player[2],Mem(FixPlayer,Index,0x1C8+0x20*Line+4*Player[5],0),Player[1],Player[3]),Type,Value)
		return TTNDeaths
	end
end

function TTCDeathsX(Player,Type,Value,Code,Mask)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 480 or Line < 0 then
		TTCDeathX_LineOverflow()
	end
	local TTCDeathsX = TTCtrigX(Player,Index,0x1C8+0x4*Line,0,Type,Value,Mask)
	return TTCDeathsX
end

function TTCDeaths(Player,Type,Value,Code)
	local Line = bit32.band(Code, 0xFFF00000)/0x100000
	local Index = bit32.band(Code, 0x1FFFF)

	if Line >= 480 or Line < 0 then
		TTCDeath_LineOverflow()
	end
	local TTCDeaths = TTCtrigX(Player,Index,0x1C8+0x4*Line,0,Type,Value)
	return TTCDeaths
end

function TTCtrigX(Player,Index,Address,Next,Type,Value,Mask)	
	return TTMemoryX(Mem(Player,Index,Address,Next),Type,Value,Mask)
end

function TTDeaths(Player,Type,Value,UnitId)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	elseif Type == "i>=" or Type == iAtLeast then
		Mode = 10
	elseif Type == "i<=" or Type == iAtMost then
		Mode = 11
	elseif Type == "i>" or Type == iAbove then
		Mode = 12
	elseif Type == "i>" or Type == iBelow then
		Mode = 13
	else
		TTDeaths_TypeError()
	end
	local TypeNum = 0
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x28,1,0),
					SetCtrig1X("X","X",0x28,0,SetTo,UnitId[5],0xFFFF)}
			Z = Z + 1
			table.insert(Y,X)
			UnitId = 0
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Mode < 10 then
			if Value[4] == "V" then
				if Value[5] == nil then
					Value[5] = 0
				end
				if type(Value[5]) == "number" then
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
							SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
					Z = Z + 1
					table.insert(Y,X)
					Value = 0
				else
					if Value[5][5] == nil then
						Value[5][5] = 0
					end
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
							SetCtrigX("X","X",0x24,0,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4])}
					Z = Z + 1
					table.insert(Y,X)
					Value = 0
				end
			end
		else
			if Value[4] == "V" then
				if Value[5] == nil then
					Value[5] = 0
				end
				if type(Value[5]) == "number" then
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,2),
							SetCtrig1X("X","X",0x24,2,SetTo,Value[5])}
					Z = Z + 1
					table.insert(Y,X)
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X",CRet[1],0x15C,1,0),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,SetTo*16777216,0xFF000000),
							Disabled(SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0)),
							Disabled(SetCtrig1X("X","X",0x24,0,SetTo,Value[5]))}
					Z = Z + 1
					table.insert(Y,X)
					Value = 0
				else
					if Value[5][5] == nil then
						Value[5][5] = 0
					end
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,2),
							SetCtrigX("X","X",0x24,2,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4])}
					Z = Z + 1
					table.insert(Y,X)
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X",CRet[1],0x15C,1,0),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,SetTo*16777216,0xFF000000),
							Disabled(SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0)),
							Disabled(SetCtrigX("X","X",0x24,0,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4]))}
					Z = Z + 1
					table.insert(Y,X)
					Value = 0
				end
			end
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Mode < 10 then
			if Player[4] == "V" then
				if Player[5] == nil then
					Player[5] = 0
				end
				local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
						SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x20,1,0),
						SetCtrig1X("X","X",0x20,0,SetTo,Player[5])}
				Z = Z + 1
				table.insert(Y,X)
				Player = 0
			else
				TypeNum = 1
			end
		else
			if Player[4] == "V" then
				if Player[5] == nil then
					Player[5] = 0
				end
				local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
						SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x20,1,2),
						SetCtrig1X("X","X",0x20,2,SetTo,Player[5])}
				Z = Z + 1
				table.insert(Y,X)
				local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
						SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x20,1,1),
						SetCtrig1X("X","X",0x20,1,SetTo,Player[5])}
				Z = Z + 1
				table.insert(Y,X)
				local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
						SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x20,1,0),
						SetCtrig1X("X","X",0x20,0,SetTo,Player[5])}
				Z = Z + 1
				table.insert(Y,X)
				Player = 0
			else
				TypeNum = 1
				Mode = Mode + 4
			end
		end
	end

	local TTDeaths2
	if TypeNum == 0 then
		TTDeaths2 = Deaths(Player,Exactly,Value,UnitId)
	elseif TypeNum == 1 then
		TTDeaths2 = CtrigX(Player[1],Player[2],Player[3],Player[4],Exactly,Value)
	end 
	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,TTDeaths2)
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTDeaths = CDeaths("X",Exactly,1,FCode)
	return TTDeaths
end

function TTDeathsX(Player,Type,Value,UnitId,Mask)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	elseif Type == "i>=" or Type == iAtLeast then
		Mode = 10
	elseif Type == "i<=" or Type == iAtMost then
		Mode = 11
	elseif Type == "i>" or Type == iAbove then
		Mode = 12
	elseif Type == "i>" or Type == iBelow then
		Mode = 13
	else
		TTDeathsX_TypeError()
	end
	local TypeNum = 0
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0
	if type(Mask) == "table" then
		if Mask[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Mask})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Mask = TempData
		end

		if Mode < 10 then
			if Mask[4] == "V" then
				if Mask[5] == nil then
					Mask[5] = 0
				end
				local X = {CallLabelAlways(Mask[1],Mask[2],Mask[3]),
						SetCtrig1X(Mask[1],Mask[2],0x148,Mask[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Mask[1],Mask[2],0x160,Mask[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Mask[1],Mask[2],0x158,Mask[3],SetTo,"X","X",0x1C,1,0),
						SetCtrig1X("X","X",0x1C,0,SetTo,Mask[5])}
				Z = Z + 1
				table.insert(Y,X)
				Mask = 0
			end
		else
			if Mask[4] == "V" then
				if Mask[5] == nil then
					Mask[5] = 0
				end
				local X = {CallLabelAlways(Mask[1],Mask[2],Mask[3]),
						SetCtrig1X(Mask[1],Mask[2],0x148,Mask[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Mask[1],Mask[2],0x160,Mask[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Mask[1],Mask[2],0x158,Mask[3],SetTo,"X","X",0x1C,1,2),
						SetCtrig1X("X","X",0x1C,2,SetTo,Mask[5])}
				Z = Z + 1
				table.insert(Y,X)
				Mask = 0
			end
		end
	end

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x28,1,0),
					SetCtrig1X("X","X",0x28,0,SetTo,UnitId[5],0xFFFF)}
			Z = Z + 1
			table.insert(Y,X)
			UnitId = 0
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Mode < 10 then
			if Value[4] == "V" then
				if Value[5] == nil then
					Value[5] = 0
				end
				if type(Value[5]) == "number" then
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
							SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
					Z = Z + 1
					table.insert(Y,X)
					Value = 0
				else
					if Value[5][5] == nil then
						Value[5][5] = 0
					end
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
							SetCtrigX("X","X",0x24,0,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4])}
					Z = Z + 1
					table.insert(Y,X)
					Value = 0
				end
			end
		else
			if Value[4] == "V" then
				if Value[5] == nil then
					Value[5] = 0
				end
				if type(Value[5]) == "number" then
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,2),
							SetCtrig1X("X","X",0x24,2,SetTo,Value[5])}
					Z = Z + 1
					table.insert(Y,X)
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X",CRet[1],0x15C,1,0),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,SetTo*16777216,0xFF000000),
							Disabled(SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0)),
							Disabled(SetCtrig1X("X","X",0x24,0,SetTo,Value[5]))}
					Z = Z + 1
					table.insert(Y,X)
					Value = 0
				else
					if Value[5][5] == nil then
						Value[5][5] = 0
					end
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,2),
							SetCtrigX("X","X",0x24,2,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4])}
					Z = Z + 1
					table.insert(Y,X)
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X",CRet[1],0x15C,1,0),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,SetTo*16777216,0xFF000000),
							Disabled(SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0)),
							Disabled(SetCtrigX("X","X",0x24,0,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4]))}
					Z = Z + 1
					table.insert(Y,X)
					Value = 0
				end
			end
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end
		if Mode < 10 then
			if Player[4] == "V" then
				if Player[5] == nil then
					Player[5] = 0
				end
				local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
						SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x20,1,0),
						SetCtrig1X("X","X",0x20,0,SetTo,Player[5])}
				Z = Z + 1
				table.insert(Y,X)
				Player = 0
			else
				TypeNum = 1
			end
		else
			if Player[4] == "V" then
				if Player[5] == nil then
					Player[5] = 0
				end
				local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
						SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x20,1,2),
						SetCtrig1X("X","X",0x20,2,SetTo,Player[5])}
				Z = Z + 1
				table.insert(Y,X)
				local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
						SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x20,1,1),
						SetCtrig1X("X","X",0x20,1,SetTo,Player[5])}
				Z = Z + 1
				table.insert(Y,X)
				local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
						SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x20,1,0),
						SetCtrig1X("X","X",0x20,0,SetTo,Player[5])}
				Z = Z + 1
				table.insert(Y,X)
				Player = 0
			else
				TypeNum = 1
				Mode = Mode + 4
			end
		end
	end

	local TTDeaths2X
	if TypeNum == 0 then
		TTDeaths2X = DeathsX(Player,Exactly,Value,UnitId,Mask)
	elseif TypeNum == 1 then
		TTDeaths2X = CtrigX(Player[1],Player[2],Player[3],Player[4],Exactly,Value,Mask)
	end 
	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,TTDeaths2X)
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTDeathsX = CDeaths("X",Exactly,1,FCode)
	return TTDeathsX
end

function TTMemory(Offset,Type,Value)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	elseif Type == "i>=" or Type == iAtLeast then
		Mode = 10
	elseif Type == "i<=" or Type == iAtMost then
		Mode = 11
	elseif Type == "i>" or Type == iAbove then
		Mode = 12
	elseif Type == "i>" or Type == iBelow then
		Mode = 13
	else
		TTMemory_TypeError()
	end
	local TypeNum = 0
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Mode < 10 then
			if Value[4] == "V" then
				if Value[5] == nil then
					Value[5] = 0
				end
				if type(Value[5]) == "number" then
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
							SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
					Z = Z + 1
					table.insert(Y,X)
					Value = 0
				else
					if Value[5][5] == nil then
						Value[5][5] = 0
					end
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
							SetCtrigX("X","X",0x24,0,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4])}
					Z = Z + 1
					table.insert(Y,X)
					Value = 0
				end
			end
		else
			if Value[4] == "V" then
				if Value[5] == nil then
					Value[5] = 0
				end
				if type(Value[5]) == "number" then
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,2),
							SetCtrig1X("X","X",0x24,2,SetTo,Value[5])}
					Z = Z + 1
					table.insert(Y,X)
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X",CRet[1],0x15C,1,0),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,SetTo*16777216,0xFF000000),
							Disabled(SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0)),
							Disabled(SetCtrig1X("X","X",0x24,0,SetTo,Value[5]))}
					Z = Z + 1
					table.insert(Y,X)
					Value = 0
				else
					if Value[5][5] == nil then
						Value[5][5] = 0
					end
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,2),
							SetCtrigX("X","X",0x24,2,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4])}
					Z = Z + 1
					table.insert(Y,X)
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X",CRet[1],0x15C,1,0),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,SetTo*16777216,0xFF000000),
							Disabled(SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0)),
							Disabled(SetCtrigX("X","X",0x24,0,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4]))}
					Z = Z + 1
					table.insert(Y,X)
					Value = 0
				end
			end
		end
	end

	if type(Offset) == "table" then
		if Offset[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Offset})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Offset = TempData
		end
		if Mode < 10 then
			if Offset[4] == "V" then
				if Offset[5] == nil then
					Offset[5] = 0
				end
				if type(Offset[5]) == "number" then
					local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
							SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x20,1,0),
							SetCtrig1X("X","X",0x20,0,SetTo,Offset[5])}
					Z = Z + 1
					table.insert(Y,X)
					Offset = 0x58A364
				else
					local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
							SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x20,1,0),
							SetCtrigX("X","X",0x20,0,SetTo,Offset[5][1],Offset[5][2],Offset[5][3],1,Offset[5][4])}
					Z = Z + 1
					table.insert(Y,X)
					Offset = 0x58A364
				end
			else
				TypeNum = 1
			end
		else
			if Offset[4] == "V" then
				if Offset[5] == nil then
					Offset[5] = 0
				end
				if type(Offset[5]) == "number" then
					local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
							SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x20,1,2),
							SetCtrig1X("X","X",0x20,2,SetTo,Offset[5])}
					Z = Z + 1
					table.insert(Y,X)
					local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
							SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x20,1,1),
							SetCtrig1X("X","X",0x20,1,SetTo,Offset[5])}
					Z = Z + 1
					table.insert(Y,X)
					local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
							SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x20,1,0),
							SetCtrig1X("X","X",0x20,0,SetTo,Offset[5])}
					Z = Z + 1
					table.insert(Y,X)
					Offset = 0x58A364
				else
					local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
							SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x20,1,2),
							SetCtrigX("X","X",0x20,2,SetTo,Offset[5][1],Offset[5][2],Offset[5][3],1,Offset[5][4])}
					Z = Z + 1
					table.insert(Y,X)
					local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
							SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x20,1,1),
							SetCtrigX("X","X",0x20,1,SetTo,Offset[5][1],Offset[5][2],Offset[5][3],1,Offset[5][4])}
					Z = Z + 1
					table.insert(Y,X)
					local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
							SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x20,1,0),
							SetCtrigX("X","X",0x20,0,SetTo,Offset[5][1],Offset[5][2],Offset[5][3],1,Offset[5][4])}
					Z = Z + 1
					table.insert(Y,X)
					Offset = 0x58A364
				end
			else
				TypeNum = 1
				Mode = Mode + 4
			end
		end
	end

	local TTMemory2
	if TypeNum == 0 then
		TTMemory2 = FMemory(Offset,Exactly,Value)
	elseif TypeNum == 1 then
		TTMemory2 = CtrigX(Offset[1],Offset[2],Offset[3],Offset[4],Exactly,Value)
	end 
	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,TTMemory2)
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTMemory = CDeaths("X",Exactly,1,FCode)
	return TTMemory
end

function TTMemoryX(Offset,Type,Value,Mask)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	elseif Type == "i>=" or Type == iAtLeast then
		Mode = 10
	elseif Type == "i<=" or Type == iAtMost then
		Mode = 11
	elseif Type == "i>" or Type == iAbove then
		Mode = 12
	elseif Type == "i>" or Type == iBelow then
		Mode = 13
	else
		TTMemoryX_TypeError()
	end
	local TypeNum = 0
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0
	if type(Mask) == "table" then
		if Mask[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Mask})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Mask = TempData
		end

		if Mode < 10 then
			if Mask[4] == "V" then
				if Mask[5] == nil then
					Mask[5] = 0
				end
				local X = {CallLabelAlways(Mask[1],Mask[2],Mask[3]),
						SetCtrig1X(Mask[1],Mask[2],0x148,Mask[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Mask[1],Mask[2],0x160,Mask[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Mask[1],Mask[2],0x158,Mask[3],SetTo,"X","X",0x1C,1,0),
						SetCtrig1X("X","X",0x1C,0,SetTo,Mask[5])}
				Z = Z + 1
				table.insert(Y,X)
				Mask = 0
			end
		else
			if Mask[4] == "V" then
				if Mask[5] == nil then
					Mask[5] = 0
				end
				local X = {CallLabelAlways(Mask[1],Mask[2],Mask[3]),
						SetCtrig1X(Mask[1],Mask[2],0x148,Mask[3],SetTo,0xFFFFFFFF),
						SetCtrig1X(Mask[1],Mask[2],0x160,Mask[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Mask[1],Mask[2],0x158,Mask[3],SetTo,"X","X",0x1C,1,2),
						SetCtrig1X("X","X",0x1C,2,SetTo,Mask[5])}
				Z = Z + 1
				table.insert(Y,X)
				Mask = 0
			end
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Mode < 10 then
			if Value[4] == "V" then
				if Value[5] == nil then
					Value[5] = 0
				end
				if type(Value[5]) == "number" then
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
							SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
					Z = Z + 1
					table.insert(Y,X)
					Value = 0
				else
					if Value[5][5] == nil then
						Value[5][5] = 0
					end
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
							SetCtrigX("X","X",0x24,0,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4])}
					Z = Z + 1
					table.insert(Y,X)
					Value = 0
				end
			end
		else
			if Value[4] == "V" then
				if Value[5] == nil then
					Value[5] = 0
				end
				if type(Value[5]) == "number" then
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,2),
							SetCtrig1X("X","X",0x24,2,SetTo,Value[5])}
					Z = Z + 1
					table.insert(Y,X)
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X",CRet[1],0x15C,1,0),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,SetTo*16777216,0xFF000000),
							Disabled(SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0)),
							Disabled(SetCtrig1X("X","X",0x24,0,SetTo,Value[5]))}
					Z = Z + 1
					table.insert(Y,X)
					Value = 0
				else
					if Value[5][5] == nil then
						Value[5][5] = 0
					end
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,2),
							SetCtrigX("X","X",0x24,2,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4])}
					Z = Z + 1
					table.insert(Y,X)
					local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X",CRet[1],0x15C,1,0),
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,SetTo*16777216,0xFF000000),
							Disabled(SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0)),
							Disabled(SetCtrigX("X","X",0x24,0,SetTo,Value[5][1],Value[5][2],Value[5][3],Value[5][5],Value[5][4]))}
					Z = Z + 1
					table.insert(Y,X)
					Value = 0
				end
			end
		end
	end

	if type(Offset) == "table" then
		if Offset[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Offset})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Offset = TempData
		end
		if Mode < 10 then
			if Offset[4] == "V" then
				if Offset[5] == nil then
					Offset[5] = 0
				end
				if type(Offset[5]) == "number" then
					local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
							SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x20,1,0),
							SetCtrig1X("X","X",0x20,0,SetTo,Offset[5])}
					Z = Z + 1
					table.insert(Y,X)
					Offset = 0x58A364
				else
					local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
							SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x20,1,0),
							SetCtrigX("X","X",0x20,0,SetTo,Offset[5][1],Offset[5][2],Offset[5][3],1,Offset[5][4])}
					Z = Z + 1
					table.insert(Y,X)
					Offset = 0x58A364
				end
			else
				TypeNum = 1
			end
		else
			if Offset[4] == "V" then
				if Offset[5] == nil then
					Offset[5] = 0
				end
				if type(Offset[5]) == "number" then
					local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
							SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x20,1,2),
							SetCtrig1X("X","X",0x20,2,SetTo,Offset[5])}
					Z = Z + 1
					table.insert(Y,X)
					local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
							SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x20,1,1),
							SetCtrig1X("X","X",0x20,1,SetTo,Offset[5])}
					Z = Z + 1
					table.insert(Y,X)
					local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
							SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x20,1,0),
							SetCtrig1X("X","X",0x20,0,SetTo,Offset[5])}
					Z = Z + 1
					table.insert(Y,X)
					Offset = 0x58A364
				else
					local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
							SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x20,1,2),
							SetCtrigX("X","X",0x20,2,SetTo,Offset[5][1],Offset[5][2],Offset[5][3],1,Offset[5][4])}
					Z = Z + 1
					table.insert(Y,X)
					local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
							SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x20,1,1),
							SetCtrigX("X","X",0x20,1,SetTo,Offset[5][1],Offset[5][2],Offset[5][3],1,Offset[5][4])}
					Z = Z + 1
					table.insert(Y,X)
					local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
							SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
							SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
							SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x20,1,0),
							SetCtrigX("X","X",0x20,0,SetTo,Offset[5][1],Offset[5][2],Offset[5][3],1,Offset[5][4])}
					Z = Z + 1
					table.insert(Y,X)
					Offset = 0x58A364
				end
			else
				TypeNum = 1
				Mode = Mode + 4
			end
		end
	end

	local TTMemory2X
	if TypeNum == 0 then
		TTMemory2X = FMemoryX(Offset,Exactly,Value,Mask)
	elseif TypeNum == 1 then
		TTMemory2X = CtrigX(Offset[1],Offset[2],Offset[3],Offset[4],Exactly,Value,Mask)
	end 
	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,TTMemory2X)
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTMemoryX = CDeaths("X",Exactly,1,FCode)
	return TTMemoryX
end

function TTLMemory(Offset,Type,Value) -- {V,V} / {V,4} / {4,V} -> Cast 사용
	return TTLMemoryX(Offset,Type,Value,0xFFFFFFFF)
end	
function TTLMemoryX(Offset,Type,Value,Mask) -- {V,V} / {V,4} / {4,V} -> Cast 사용
	local Mode
	if Type == ">" or Type == Above then
		Mode = 8
	elseif Type == "<" or Type == Below then
		Mode = 6
	elseif Type == "!=" or Type == NotSame then
		Mode = 4
	elseif Type == "==" or Type == Exactly then
		Mode = 3
	elseif Type == ">=" or Type == AtLeast then
		Mode = 5
	elseif Type == "<=" or Type == AtMost then
		Mode = 7
	elseif Type == "i>=" or Type == iAtLeast then
		Mode = 25
	elseif Type == "i<=" or Type == iAtMost then
		Mode = 26
	elseif Type == "i>" or Type == iAbove then
		Mode = 27
	elseif Type == "i>" or Type == iBelow then
		Mode = 28
	else
		TTLMemoryX_Type_Error()
	end

	local TypeNum = 0
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0

	if Mask == "X" or Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "number" then
		Mask = {Mask,Mask}
	elseif type(Mask) == "string" then
		Mask = I64(Mask)
	elseif type(Mask) == "table" and #Mask > 2 then
		if Mask[4] == "WA" then
			local Temp = WarXAlloc
			local TempData = {"X",Temp,0,"W"}

			table.insert(STPushTrigArr,{"MovW",TempData,Mask})

			WarXAlloc = WarXAlloc + 1
			if WarXAlloc > MAXWAlloc then
				MAXWAlloc = WarXAlloc
			end
			Mask = TempData
		end

		if Mask[4] == "W" then
			if Mask[5] == nil then
				Mask[5] = {0,0}
			else
				Mask[5] = I64(Mask[5])
			end
			local X = {CallLabelAlways(Mask[1],Mask[2],Mask[3]),
					SetCtrig1X(Mask[1],Mask[2],0x148,Mask[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Mask[1],Mask[2],0x188,Mask[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Mask[1],Mask[2],0x160,Mask[3],SetTo,Add*16777216,0xFF000000),
					SetCtrig1X(Mask[1],Mask[2],0x1A0,Mask[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Mask[1],Mask[2],0x158,Mask[3],SetTo,"X","X",0x1C+0x14,1,0),
					SetCtrigX(Mask[1],Mask[2],0x198,Mask[3],SetTo,"X","X",0x1C,1,0),
					SetCtrig1X("X","X",0x1C+0x14,0,SetTo,Mask[5][1]),
					SetCtrig1X("X","X",0x1C,0,SetTo,Mask[5][2])}
			Z = Z + 1
			table.insert(Y,X)
			Mask = {0,0}
		end
	end

	if type(Value) == "string" then
		Value = I64(Value)
	elseif type(Value) == "table" and #Value > 2 then
		if Value[4] == "WA" then
			local Temp = WarXAlloc
			local TempData = {"X",Temp,0,"W"}

			table.insert(STPushTrigArr,{"MovW",TempData,Value})

			WarXAlloc = WarXAlloc + 1
			if WarXAlloc > MAXWAlloc then
				MAXWAlloc = WarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "W" then
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x188,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrig1X(Value[1],Value[2],0x1A0,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24+0x14,1,0),
					SetCtrigX(Value[1],Value[2],0x198,Value[3],SetTo,"X","X",0x24,1,0)}

			if Value[5] == nil then
				Value[5] = {0,0}
				table.insert(X,SetCtrig1X("X","X",0x24+0x14,0,SetTo,Value[5][1]))
				table.insert(X,SetCtrig1X("X","X",0x24,0,SetTo,Value[5][2]))
			elseif type(Value[5]) == "string" then
				Value[5] = I64(Value[5])
				table.insert(X,SetCtrig1X("X","X",0x24+0x14,0,SetTo,Value[5][1]))
				table.insert(X,SetCtrig1X("X","X",0x24,0,SetTo,Value[5][2]))
			else
				if type(Value[5][1]) == "number" then
					table.insert(X,SetCtrig1X("X","X",0x24+0x14,0,SetTo,Value[5][1]))
				else
					table.insert(X,SetCtrigX("X","X",0x24+0x14,0,SetTo,Value[5][1][1],Value[5][1][2],Value[5][1][3],1,Value[5][1][4]))
				end
				if type(Value[5][2]) == "number" then
					table.insert(X,SetCtrig1X("X","X",0x24,0,SetTo,Value[5][2]))
				else
					table.insert(X,SetCtrigX("X","X",0x24,0,SetTo,Value[5][2][1],Value[5][2][2],Value[5][2][3],1,Value[5][2][4]))
				end
			end

			Z = Z + 1
			table.insert(Y,X)
			Value = {0,0}
		end
	end

	if type(Offset) == "number" then
		Offset = {Offset,Offset+0x4}
		TypeNum = 0
	elseif type(Offset) == "string" then
		Offset = I64(Offset)
		TypeNum = 0
	elseif type(Offset) == "table" and #Offset == 2 then
		if type(Offset[1]) == "number" and type(Offset[2]) == "number" then
			TypeNum = 0
		elseif type(Offset[1]) == "number" and type(Offset[2]) == "table" and #Offset[2] == 1 then
			Offset = {Offset[1],Offset[1]+Offset[2][1]}
			TypeNum = 0
		elseif type(Offset[1]) == "number" and type(Offset[2]) == "table" then
			TypeNum = 1
		elseif type(Offset[1]) == "table" and type(Offset[2]) == "number"then
			TypeNum = 2
		elseif type(Offset[1]) == "table" and type(Offset[2]) == "table" and #Offset[2] == 1 then
			TypeNum = 3
			local TempX = {Offset[1][1],Offset[1][2],Offset[1][3]+Offset[2][1],Offset[1][4]}
			Offset[2] = TempX
		elseif type(Offset[1]) == "table" and type(Offset[2]) == "table" then
			TypeNum = 3
		end
	elseif type(Offset) == "table" then
		if Offset[4] == "WA" then
			local Temp = WarXAlloc
			local TempData = {"X",Temp,0,"W"}

			table.insert(STPushTrigArr,{"MovW",TempData,Offset})

			WarXAlloc = WarXAlloc + 1
			if WarXAlloc > MAXWAlloc then
				MAXWAlloc = WarXAlloc
			end
			Offset = TempData
		end

		if Offset[4] == "W" then
			local X = {CallLabelAlways(Offset[1],Offset[2],Offset[3]),
					SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Offset[1],Offset[2],0x188,Offset[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000),
					SetCtrig1X(Offset[1],Offset[2],0x1A0,Offset[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X","X",0x20+0x14,1,0),
					SetCtrigX(Offset[1],Offset[2],0x198,Offset[3],SetTo,"X","X",0x20,1,0)}

			if Offset[5] == nil then
				Offset[5] = {0,0}
				table.insert(X,SetCtrig1X("X","X",0x20+0x14,0,SetTo,Offset[5][1]))
				table.insert(X,SetCtrig1X("X","X",0x20,0,SetTo,Offset[5][2]))
			elseif type(Offset[5]) == "string" then
				Offset[5] = I64(Offset[5])
				table.insert(X,SetCtrig1X("X","X",0x20+0x14,0,SetTo,Offset[5][1]))	
				table.insert(X,SetCtrig1X("X","X",0x20,0,SetTo,Offset[5][2]))
			else
				if type(Offset[5][1]) == "number" then
					table.insert(X,SetCtrig1X("X","X",0x20+0x14,0,SetTo,Offset[5][1]))
				else
					table.insert(X,SetCtrigX("X","X",0x20+0x14,0,SetTo,Offset[5][1][1],Offset[5][1][2],Offset[5][1][3],1,Offset[5][1][4]))
				end
				if type(Offset[5][2]) == "number" then
					table.insert(X,SetCtrig1X("X","X",0x20,0,SetTo,Offset[5][2]))
				else
					table.insert(X,SetCtrigX("X","X",0x20,0,SetTo,Offset[5][2][1],Offset[5][2][2],Offset[5][2][3],1,Offset[5][2][4]))
				end
			end
			
			Z = Z + 1
			table.insert(Y,X)
			Offset = {0x58A364,0x58A364}
			TypeNum = 0
		end
	end

	local TTLMemoryX
	if TypeNum == 0 then
		TTLMemoryX = {FMemoryX(Offset[2],Exactly,Value[2],Mask[2]),FMemoryX(Offset[1],Exactly,Value[1],Mask[1])}
	elseif TypeNum == 1 then
		TTLMemoryX = {CtrigX(Offset[2][1],Offset[2][2],Offset[2][3],Offset[2][4],Exactly,Value[2],Mask[2]),FMemoryX(Offset[1],Exactly,Value[1],Mask[1])}
	elseif TypeNum == 2 then
		TTLMemoryX = {FMemoryX(Offset[2],Exactly,Value[2],Mask[2]),CtrigX(Offset[1][1],Offset[1][2],Offset[1][3],Offset[1][4],Exactly,Value[1],Mask[1])}
	elseif TypeNum == 3 then
		TTLMemoryX = {CtrigX(Offset[2][1],Offset[2][2],Offset[2][3],Offset[2][4],Exactly,Value[2],Mask[2]),CtrigX(Offset[1][1],Offset[1][2],Offset[1][3],Offset[1][4],Exactly,Value[1],Mask[1])}
	end 
	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,TTLMemoryX)
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTWemoryX = CDeaths("X",Exactly,1,FCode)
	return TTWemoryX
end

function TTCommand(Player,Type,Value,UnitId)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	else
		TTCommandX_TypeError()
	end

	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x28,1,0),
					SetCtrig1X("X","X",0x28,0,SetTo,UnitId[5],0xFFFF)}
			Z = Z + 1
			table.insert(Y,X)
			UnitId = 0
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
					SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
			Z = Z + 1
			table.insert(Y,X)
			Value = 0
		end
	end

	if type(Player) == "table" and Player ~= CurrentPlayer then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x20,1,0),
					SetCtrig1X("X","X",0x20,0,SetTo,Player[5])}
			Z = Z + 1
			table.insert(Y,X)
			Player = 0
		end
	end

	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,Command(Player,Exactly,Value,UnitId))
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTCommandX = CDeaths("X",Exactly,1,FCode)
	return TTCommandX
end

function TTBring(Player,Type,Value,UnitId,Location)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	else
		TTBringX_TypeError()
	end

	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0
	if type(Location) == "table" then
		if Location[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Location})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Location = TempData
		end

		if Location[4] == "V" then
			if Location[5] == nil then
				Location[5] = 0
			end
			local X = {CallLabelAlways(Location[1],Location[2],Location[3]),
					SetCtrig1X(Location[1],Location[2],0x148,Location[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Location[1],Location[2],0x160,Location[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Location[1],Location[2],0x158,Location[3],SetTo,"X","X",0x1C,1,0),
					SetCtrig1X("X","X",0x1C,0,SetTo,Location[5])}
			Z = Z + 1
			table.insert(Y,X)
			Location = 0
		end
	end

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x28,1,0),
					SetCtrig1X("X","X",0x28,0,SetTo,UnitId[5],0xFFFF)}
			Z = Z + 1
			table.insert(Y,X)
			UnitId = 0
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
					SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
			Z = Z + 1
			table.insert(Y,X)
			Value = 0
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x20,1,0),
					SetCtrig1X("X","X",0x20,0,SetTo,Player[5])}
			Z = Z + 1
			table.insert(Y,X)
			Player = 0
		end
	end

	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,Bring(Player,Exactly,Value,UnitId,Location))
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTBringX = CDeaths("X",Exactly,1,FCode)
	return TTBringX
end

function TTAccumulate(Player,Type,Value,ResourceType)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	else
		TTAccumulateX_TypeError()
	end

	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
					SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
			Z = Z + 1
			table.insert(Y,X)
			Value = 0
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x20,1,0),
					SetCtrig1X("X","X",0x20,0,SetTo,Player[5])}
			Z = Z + 1
			table.insert(Y,X)
			Player = 0
		end
	end

	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,Accumulate(Player,Exactly,Value,ResourceType))
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTAccumulateX = CDeaths("X",Exactly,1,FCode)
	return TTAccumulateX
end

function TTCountdownTimer(Type,Value)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	else
		TTCountdownTimerX_TypeError()
	end

	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
					SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
			Z = Z + 1
			table.insert(Y,X)
			Value = 0
		end
	end

	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,CountdownTimer(Exactly,Value))
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTCountdownTimerX = CDeaths("X",Exactly,1,FCode)
	return TTCountdownTimerX
end

function TTElapsedTime(Type,Value)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	else
		TTElapsedTimeX_TypeError()
	end

	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
					SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
			Z = Z + 1
			table.insert(Y,X)
			Value = 0
		end
	end

	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,ElapsedTime(Exactly,Value))
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTElapsedTimeX = CDeaths("X",Exactly,1,FCode)
	return TTElapsedTimeX
end

function TTKills(Player,Type,Value,UnitId)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	else
		TTKillsX_TypeError()
	end

	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0

	if type(UnitId) == "table" then
		if UnitId[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,UnitId})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			UnitId = TempData
		end

		if UnitId[4] == "V" then
			if UnitId[5] == nil then
				UnitId[5] = 0
			end
			local X = {CallLabelAlways(UnitId[1],UnitId[2],UnitId[3]),
					SetCtrig1X(UnitId[1],UnitId[2],0x148,UnitId[3],SetTo,0xFFFF),
					SetCtrig1X(UnitId[1],UnitId[2],0x160,UnitId[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(UnitId[1],UnitId[2],0x158,UnitId[3],SetTo,"X","X",0x28,1,0),
					SetCtrig1X("X","X",0x28,0,SetTo,UnitId[5],0xFFFF)}
			Z = Z + 1
			table.insert(Y,X)
			UnitId = 0
		end
	end

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
					SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
			Z = Z + 1
			table.insert(Y,X)
			Value = 0
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x20,1,0),
					SetCtrig1X("X","X",0x20,0,SetTo,Player[5])}
			Z = Z + 1
			table.insert(Y,X)
			Player = 0
		end
	end

	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,Kills(Player,Exactly,Value,UnitId))
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTKillsX = CDeaths("X",Exactly,1,FCode)
	return TTKillsX
end

function TTScore(Player,ScoreType,Type,Value)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	else
		TTScoreX_TypeError()
	end

	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
					SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
			Z = Z + 1
			table.insert(Y,X)
			Value = 0
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x20,1,0),
					SetCtrig1X("X","X",0x20,0,SetTo,Player[5])}
			Z = Z + 1
			table.insert(Y,X)
			Player = 0
		end
	end

	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,Score(Player,ScoreType,Exactly,Value))
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTScoreX = CDeaths("X",Exactly,1,FCode)
	return TTScoreX
end

function TTOpponents(Player,Type,Value)
	local Mode
	if Type == ">" or Type == Above then
		Mode = 1
	elseif Type == "<" or Type == Below then
		Mode = 2
	elseif Type == "!=" or Type == NotSame then
		Mode = 0
	else
		TTOpponentsX_TypeError()
	end

	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0

	if type(Value) == "table" then
		if Value[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Value})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Value = TempData
		end

		if Value[4] == "V" then
			if Value[5] == nil then
				Value[5] = 0
			end
			local X = {CallLabelAlways(Value[1],Value[2],Value[3]),
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x24,1,0),
					SetCtrig1X("X","X",0x24,0,SetTo,Value[5])}
			Z = Z + 1
			table.insert(Y,X)
			Value = 0
		end
	end

	if type(Player) == "table" and Player[1] ~= nil then
		if Player[4] == "VA" then
			local Temp = VarXAlloc
			local TempData = {"X",Temp,0,"V"}

			table.insert(STPushTrigArr,{"MovX",TempData,Player})

			VarXAlloc = VarXAlloc + 1
			if VarXAlloc > MAXVAlloc then
				MAXVAlloc = VarXAlloc
			end
			Player = TempData
		end

		if Player[4] == "V" then
			if Player[5] == nil then
				Player[5] = 0
			end
			local X = {CallLabelAlways(Player[1],Player[2],Player[3]),
					SetCtrig1X(Player[1],Player[2],0x148,Player[3],SetTo,0xFFFFFFFF),
					SetCtrig1X(Player[1],Player[2],0x160,Player[3],SetTo,Add*16777216,0xFF000000),
					SetCtrigX(Player[1],Player[2],0x158,Player[3],SetTo,"X","X",0x20,1,0),
					SetCtrig1X("X","X",0x20,0,SetTo,Player[5])}
			Z = Z + 1
			table.insert(Y,X)
			Player = 0
		end
	end

	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,Opponents(Player,Exactly,Value))
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTOpponentsX = CDeaths("X",Exactly,1,FCode)
	return TTOpponentsX
end

-- 매크로 함수형 최종 연산 함수(C) ------------------------------------------------------

function CRead(PlayerID,Dest,Source,Deviation,Mask,EPDRead,Clear) -- f_maskread
	STPopTrigArr(PlayerID)
	if EPDRead == "X" then
		EPDRead = nil
	end
	if Mask == "X" then
		Mask = nil
	end
	if Deviation == "X" then
		Deviation = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	if Deviation == nil then
		Deviation = 0
	end

	local Mask2 = Mask
	if Clear == 1 then
		Mask2 = 0xFFFFFFFF
	end

	Recover = 0
	CRead1 = {}
	CRead2 = {}
	CRead3 = {}

	if type(Source) == "table" and Source[4] == "VA" then
		local TempRet = {"X",CRet[7],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	end
	if type(Source) == "table" and Source[4] == "A" then
		local TempRet = {"X",CRet[7],0,"V"}
		MovZ(PlayerID,TempRet,Source)
		Source = TempRet
	end
	local PDest
	if type(Dest) == "table" and Dest[4] == "VA" then
		PDest = Dest
		Dest = {"X",CRet[8],0,"V"}
	end
	if type(Dest) == "table" and Dest[4] == "A" then
		PDest = Dest
		Dest = {"X",CRet[8],0,"V"}
	end

	if EPDRead == nil then
		if type(Dest) == "number" then 
			if type(Source) == "number" then -- Read 0x58A364, 0x58A368 : 0x58A364 << 0x58A368 + D
					CRead1 = {SetMemoryX(Dest,SetTo,Deviation,Mask)}
			elseif Source == "Cp" then -- Read 0x58A364, Cp : 0x58A364 << Cp + D
					CRead1 = {SetMemoryX(Dest,SetTo,Deviation,Mask)}
			elseif Source[4] == "V" then -- Read 0x58A364, X : 0x58A364 << EPD(X) + D (CPRead)
					CRead1 = {SetMemoryX(Dest,SetTo,Deviation,Mask)}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,SetTo,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0));
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
					Recover = 1
			else -- Read 0x58A364, Mem : 0x58A364 << Mem + D
					CRead1 = {SetMemoryX(Dest,SetTo,Deviation,Mask)}
			end
		elseif Dest == "Cp" then
			if type(Source) == "number" then -- Read Cp, 0x58A368 : Cp << 0x58A368 + D
					CRead1 = {SetDeathsX(CurrentPlayer,SetTo,Deviation,0,Mask)}
			elseif Source == "Cp" then -- Read Cp, Cp : Cp << Cp + D / Cp중복
				CRead_InputData_Error()
			elseif Source[4] == "V" then -- Read Cp, X : Cp << EPD(X) + D (CPRead) / Cp중복
				CRead_InputData_Error()
			else -- Read Cp, Mem : Cp << Mem + D
					CRead1 = {SetDeathsX(CurrentPlayer,SetTo,Deviation,0,Mask)}
			end
		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- Read X, 0x58A364 : X << 0x58A364 + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2)}
			elseif Source == "Cp" then  -- Read X, Cp : X << Cp + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2)}
			elseif Source[4] == "V" then -- Read X, Y : X << EPD(Y) + D (CPRead)
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2)}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,SetTo,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0));
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
					Recover = 1
			else -- Read X, Mem : X << Mem + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2)}
			end
		else 
			if type(Source) == "number" then -- Read Mem, 0x58A364 : Mem << 0x58A364 + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation,Mask)}
			elseif Source == "Cp" then -- Read Mem, Cp : Mem << Cp + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation,Mask)}
			elseif Source[4] == "V" then -- Read Mem, X : Mem << EPD(X) + D (CPRead)
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation,Mask)}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,SetTo,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0));
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
					Recover = 1
			else -- Read Mem1, Mem2 : Mem1 << Mem2 + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation,Mask)}
			end
		end

		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				CRead1,
			},
			flag = {Preserved}
		}
		for i = 0, 31 do
			local CBit = bit32.band(Mask, 2^i)
			if type(Dest) == "number" then 
				if type(Source) == "number" then -- Read 0x58A364, 0x58A368 : 0x58A364 << 0x58A368 + D
						CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
						CRead3 = {SetMemory(Dest,Add,CBit)}
				elseif Source == "Cp" then -- Read 0x58A364, Cp : 0x58A364 << Cp + D
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetMemory(Dest,Add,CBit)}
				elseif Source[4] == "V" then -- Read 0x58A364, X : 0x58A364 << EPD(X) + D (CPRead)
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetMemory(Dest,Add,CBit)}
						Recover = 1
				else -- Read 0x58A364, Mem : 0x58A364 << Mem + D
						CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
						CRead3 = {SetMemory(Dest,Add,CBit)}
				end
			elseif Dest == "Cp" then
				if type(Source) == "number" then -- Read Cp, 0x58A368 : Cp << 0x58A368 + D
						CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
						CRead3 = {SetDeaths(CurrentPlayer,Add,CBit,0)}
				elseif Source == "Cp" then -- Read Cp, Cp : Cp << Cp + D / Cp중복
					CRead_InputData_Error()
				elseif Source[4] == "V" then -- Read Cp, X : Cp << EPD(X) + D (CPRead) / Cp중복
					CRead_InputData_Error()
				else -- Read Cp, Mem : Cp << Mem + D
						CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
						CRead3 = {SetDeaths(CurrentPlayer,Add,CBit,0)}
				end
			elseif Dest[4] == "V" then
				if type(Source) == "number" then -- Read X, 0x58A364 : X << 0x58A364 + D
						CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit)}
				elseif Source == "Cp" then  -- Read X, Cp : X << Cp + D
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit)}
				elseif Source[4] == "V" then -- Read X, Y : X << EPD(Y) + D (CPRead)
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit)}
						Recover = 1
				else -- Read X, Mem : X << Mem + D
						CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit)}
				end
			else 
				if type(Source) == "number" then -- Read Mem, 0x58A364 : Mem << 0x58A364 + D
						CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit)}
				elseif Source == "Cp" then -- Read Mem, Cp : Mem << Cp + D
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit)}
				elseif Source[4] == "V" then -- Read Mem, X : Mem << EPD(X) + D (CPRead)
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit)}
						Recover = 1
				else -- Read Mem1, Mem2 : Mem1 << Mem2 + D
						CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit)}
				end
			end
			if CBit == 2^i then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					   	CRead2,
					},
					actions = {
						CRead3,
					},
					flag = {Preserved}
				}
			end
		end
	else
		if type(Dest) == "number" then 
			if type(Source) == "number" then -- Read 0x58A364, 0x58A368 : 0x58A364 << 0x58A368 + D
					CRead1 = {SetMemory(Dest,SetTo,Deviation-1452249)}
			elseif Source == "Cp" then -- Read 0x58A364, Cp : 0x58A364 << Cp + D
					CRead1 = {SetMemory(Dest,SetTo,Deviation-1452249)}
			elseif Source[4] == "V" then -- Read 0x58A364, X : 0x58A364 << EPD(X) + D (CPRead)
					CRead1 = {SetMemoryX(Dest,SetTo,Deviation-1452249)}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,SetTo,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0));
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
					Recover = 1
			else -- Read 0x58A364, Mem : 0x58A364 << Mem + D
					CRead1 = {SetMemory(Dest,SetTo,Deviation-1452249)}
			end
		elseif Dest == "Cp" then
			if type(Source) == "number" then -- Read Cp, 0x58A368 : Cp << 0x58A368 + D
					CRead1 = {SetDeaths(CurrentPlayer,SetTo,Deviation-1452249,0)}
			elseif Source == "Cp" then -- Read Cp, Cp : Cp << Cp + D / Cp중복
				CRead_InputData_Error()
			elseif Source[4] == "V" then -- Read Cp, X : Cp << EPD(X) + D (CPRead) / Cp중복
				CRead_InputData_Error()
			else -- Read Cp, Mem : Cp << Mem + D
					CRead1 = {SetDeaths(CurrentPlayer,SetTo,Deviation-1452249,0)}
			end
		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- Read X, 0x58A364 : X << 0x58A364 + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation-1452249)}
			elseif Source == "Cp" then  -- Read X, Cp : X << Cp + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation-1452249)}
			elseif Source[4] == "V" then -- Read X, Y : X << EPD(Y) + D (CPRead)
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation-1452249)}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,SetTo,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0));
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
					Recover = 1
			else -- Read X, Mem : X << Mem + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation-1452249)}
			end
		else 
			if type(Source) == "number" then -- Read Mem, 0x58A364 : Mem << 0x58A364 + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation-1452249)}
			elseif Source == "Cp" then -- Read Mem, Cp : Mem << Cp + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation-1452249)}
			elseif Source[4] == "V" then -- Read Mem, X : Mem << EPD(X) + D (CPRead)
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation-1452249)}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,SetTo,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0));
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
					Recover = 1
			else -- Read Mem1, Mem2 : Mem1 << Mem2 + D
					CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation-1452249)}
			end
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				CRead1,
			},
			flag = {Preserved}
		}
		for i = 2, 31 do
			local CBit = bit32.band(Mask, 2^i)
			if type(Dest) == "number" then 
				if type(Source) == "number" then -- Read 0x58A364, 0x58A368 : 0x58A364 << 0x58A368 + D
						CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
						CRead3 = {SetMemory(Dest,Add,CBit/4)}
				elseif Source == "Cp" then -- Read 0x58A364, Cp : 0x58A364 << Cp + D
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetMemory(Dest,Add,CBit/4)}
				elseif Source[4] == "V" then -- Read 0x58A364, X : 0x58A364 << EPD(X) + D (CPRead)
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetMemory(Dest,Add,CBit/4)}
						Recover = 1
				else -- Read 0x58A364, Mem : 0x58A364 << Mem + D
						CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
						CRead3 = {SetMemory(Dest,Add,CBit/4)}
				end
			elseif Dest == "Cp" then
				if type(Source) == "number" then -- Read Cp, 0x58A368 : Cp << 0x58A368 + D
						CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
						CRead3 = {SetDeaths(CurrentPlayer,Add,CBit/4,0)}
				elseif Source == "Cp" then -- Read Cp, Cp : Cp << Cp + D / Cp중복
					CRead_InputData_Error()
				elseif Source[4] == "V" then -- Read Cp, X : Cp << EPD(X) + D (CPRead) / Cp중복
					CRead_InputData_Error()
				else -- Read Cp, Mem : Cp << Mem + D
						CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
						CRead3 = {SetDeaths(CurrentPlayer,Add,CBit/4,0)}
				end
			elseif Dest[4] == "V" then
				if type(Source) == "number" then -- Read X, 0x58A364 : X << 0x58A364 + D
						CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit/4)}
				elseif Source == "Cp" then  -- Read X, Cp : X << Cp + D
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit/4)}
				elseif Source[4] == "V" then -- Read X, Y : X << EPD(Y) + D (CPRead)
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit/4)}
						Recover = 1
				else -- Read X, Mem : X << Mem + D
						CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit/4)}
				end
			else 
				if type(Source) == "number" then -- Read Mem, 0x58A364 : Mem << 0x58A364 + D
						CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit/4)}
				elseif Source == "Cp" then -- Read Mem, Cp : Mem << Cp + D
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit/4)}
				elseif Source[4] == "V" then -- Read Mem, X : Mem << EPD(X) + D (CPRead)
						CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit/4)}
						Recover = 1
				else -- Read Mem1, Mem2 : Mem1 << Mem2 + D
						CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
						CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit/4)}
				end
			end
			if CBit == 2^i then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					   	CRead2,
					},
					actions = {
						CRead3,
					},
					flag = {Preserved}
				}
			end
		end
	end

	if Recover == 1 then
		RecoverCp(PlayerID)
	end

	if PDest ~= nil then
		MovX(PlayerID,PDest,Dest)
	end
end

function CReadX(PlayerID,Dest,Source,Deviation,Mask,Multiplier,Clear) -- f_ConvertRead
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end
	if Deviation == "X" then
		Deviation = nil
	end
	if Multiplier == "X" then
		Multiplier = nil
	end
	local DestMask
	if Mask == nil then
		Mask = 0xFFFFFFFF
		DestMask = 0xFFFFFFFF
	end
	if Deviation == nil then
		Deviation = 0
	end
	if Multiplier == nil then
		Multiplier = 1
	end

	if type(Mask) == "table" then
		DestMask = Mask[2]
		Mask = Mask[1]
	else
		DestMask = Mask
	end

	local Mask2 = DestMask
	if Clear == 1 then
		Mask2 = 0xFFFFFFFF
	end

	local Recover = 0
	local CRead1 = {}
	local CRead2 = {}
	local CRead3 = {}

	if type(Source) == "table" and Source[4] == "VA" then
		local TempRet = {"X",CRet[7],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	end
	if type(Source) == "table" and Source[4] == "A" then
		local TempRet = {"X",CRet[7],0,"V"}
		MovZ(PlayerID,TempRet,Source)
		Source = TempRet
	end
	local PDest
	if type(Dest) == "table" and Dest[4] == "VA" then
		PDest = Dest
		Dest = {"X",CRet[8],0,"V"}
	end
	if type(Dest) == "table" and Dest[4] == "A" then
		PDest = Dest
		Dest = {"X",CRet[8],0,"V"}
	end

	if type(Dest) == "number" then 
		if type(Source) == "number" then -- Read 0x58A364, 0x58A368 : 0x58A364 << 0x58A368 + D
				CRead1 = {SetMemoryX(Dest,SetTo,Deviation,DestMask)}
		elseif Source == "Cp" then -- Read 0x58A364, Cp : 0x58A364 << Cp + D
				CRead1 = {SetMemoryX(Dest,SetTo,Deviation,DestMask)}
		elseif Source[4] == "V" then -- Read 0x58A364, X : 0x58A364 << EPD(X) + D (CPRead)
				CRead1 = {SetMemoryX(Dest,SetTo,Deviation,DestMask)}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,SetTo,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0));
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				Recover = 1
		else -- Read 0x58A364, Mem : 0x58A364 << Mem + D
				CRead1 = {SetMemoryX(Dest,SetTo,Deviation,DestMask)}
		end
	elseif Dest == "Cp" then
		if type(Source) == "number" then -- Read Cp, 0x58A368 : Cp << 0x58A368 + D
				CRead1 = {SetDeathsX(CurrentPlayer,SetTo,Deviation,0,DestMask)}
		elseif Source == "Cp" then -- Read Cp, Cp : Cp << Cp + D / Cp중복
			CRead_InputData_Error()
		elseif Source[4] == "V" then -- Read Cp, X : Cp << EPD(X) + D (CPRead) / Cp중복
			CRead_InputData_Error()
		else -- Read Cp, Mem : Cp << Mem + D
				CRead1 = {SetDeathsX(CurrentPlayer,SetTo,Deviation,0,DestMask)}
		end
	elseif Dest[4] == "V" then
		if type(Source) == "number" then -- Read X, 0x58A364 : X << 0x58A364 + D
				CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,DestMask)}
		elseif Source == "Cp" then  -- Read X, Cp : X << Cp + D
				CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,DestMask)}
		elseif Source[4] == "V" then -- Read X, Y : X << EPD(Y) + D (CPRead)
				CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,DestMask)}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,SetTo,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0));
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				Recover = 1
		else -- Read X, Mem : X << Mem + D
				CRead1 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,DestMask)}
		end
	else 
		if type(Source) == "number" then -- Read Mem, 0x58A364 : Mem << 0x58A364 + D
				CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation,DestMask)}
		elseif Source == "Cp" then -- Read Mem, Cp : Mem << Cp + D
				CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation,DestMask)}
		elseif Source[4] == "V" then -- Read Mem, X : Mem << EPD(X) + D (CPRead)
				CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation,DestMask)}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,SetTo,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0));
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				Recover = 1
		else -- Read Mem1, Mem2 : Mem1 << Mem2 + D
				CRead1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation,DestMask)}
		end
	end

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			CRead1,
		},
		flag = {Preserved}
	}
	local Check = 0
	for i = 0, 31 do
		local CBit = bit32.band(Mask, 2^i)
		if type(Dest) == "number" then 
			if type(Source) == "number" then -- Read 0x58A364, 0x58A368 : 0x58A364 << 0x58A368 + D
					CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
					CRead3 = {SetMemory(Dest,Add,CBit*Multiplier)}
			elseif Source == "Cp" then -- Read 0x58A364, Cp : 0x58A364 << Cp + D
					CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
					CRead3 = {SetMemory(Dest,Add,CBit*Multiplier)}
			elseif Source[4] == "V" then -- Read 0x58A364, X : 0x58A364 << EPD(X) + D (CPRead)
					CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
					CRead3 = {SetMemory(Dest,Add,CBit*Multiplier)}
					Recover = 1
			else -- Read 0x58A364, Mem : 0x58A364 << Mem + D
					CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
					CRead3 = {SetMemory(Dest,Add,CBit*Multiplier)}
			end
		elseif Dest == "Cp" then
			if type(Source) == "number" then -- Read Cp, 0x58A368 : Cp << 0x58A368 + D
					CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
					CRead3 = {SetDeaths(CurrentPlayer,Add,CBit*Multiplier,0)}
			elseif Source == "Cp" then -- Read Cp, Cp : Cp << Cp + D / Cp중복
				CRead_InputData_Error()
			elseif Source[4] == "V" then -- Read Cp, X : Cp << EPD(X) + D (CPRead) / Cp중복
				CRead_InputData_Error()
			else -- Read Cp, Mem : Cp << Mem + D
					CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
					CRead3 = {SetDeaths(CurrentPlayer,Add,CBit*Multiplier,0)}
			end
		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- Read X, 0x58A364 : X << 0x58A364 + D
					CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
					CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit*Multiplier)}
			elseif Source == "Cp" then  -- Read X, Cp : X << Cp + D
					CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
					CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit*Multiplier)}
			elseif Source[4] == "V" then -- Read X, Y : X << EPD(Y) + D (CPRead)
					CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
					CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit*Multiplier)}
					Recover = 1
			else -- Read X, Mem : X << Mem + D
					CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
					CRead3 = {SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,CBit*Multiplier)}
			end
		else 
			if type(Source) == "number" then -- Read Mem, 0x58A364 : Mem << 0x58A364 + D
					CRead2 = {MemoryX(Source,Exactly,CBit,CBit)}
					CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit*Multiplier)}
			elseif Source == "Cp" then -- Read Mem, Cp : Mem << Cp + D
					CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
					CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit*Multiplier)}
			elseif Source[4] == "V" then -- Read Mem, X : Mem << EPD(X) + D (CPRead)
					CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
					CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit*Multiplier)}
					Recover = 1
			else -- Read Mem1, Mem2 : Mem1 << Mem2 + D
					CRead2 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
					CRead3 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,CBit*Multiplier)}
			end
		end
		if CBit == 2^i and CBit*Multiplier >= 1 and Check == 0 then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				   	CRead2,
				},
				actions = {
					CRead3,
				},
				flag = {Preserved}
			}
		end
		if bit32.band(CBit*Multiplier,0xFFFFFFFF) >= 0x80000000 then
			Check = 1
		end
	end

	if Recover == 1 then
		RecoverCp(PlayerID)
	end

	if PDest ~= nil then
		MovX(PlayerID,PDest,Dest)
	end
end

function CRead2X(PlayerID,Input,OutputArr,Mask) -- f_ConvertRead2X {Dest,Multiplier,Mask,Deviation,Clear}
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	for k, v in pairs(OutputArr) do
		if v[2] == nil then
			v[2] = 1
		end
		if v[3] == nil then
			v[3] = 0xFFFFFFFF
		end
		if v[4] == nil then
			v[4] = 0
		end
	end

	local Recover = 0
	local CRead1 = {}
	local CRead2 = {}

	if type(Input) == "table" and Input[4] == "VA" then
		local TempRet = {"X",CRet[7],0,"V"}
		MovX(PlayerID,TempRet,Input)
		Input = TempRet
	end
	if type(Input) == "table" and Input[4] == "A" then
		local TempRet = {"X",CRet[7],0,"V"}
		MovZ(PlayerID,TempRet,Input)
		Input = TempRet
	end

	if type(Input) == "table" and Input[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,SetTo,0);
				SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Input[1],Input[2],0x158,Input[3],SetTo,EPD(0x6509B0));
				CallLabelAlways(Input[1],Input[2],Input[3]);
			},
			flag = {Preserved}
		}
		Recover = 1
	end

	for k, v in pairs(OutputArr) do
		local DestMask = v[3]
		if v[5] == 1 then
			DestMask = 0xFFFFFFFF
		end
		if type(v[1]) == "number" then
			table.insert(CRead1,SetMemoryX(v[1],SetTo,v[4],DestMask))
		elseif v[1][4] == "V" then
			table.insert(CRead1,SetNVar(v[1],SetTo,v[4],DestMask))
		else
			table.insert(CRead1,SetCtrig1X(v[1][1],v[1][2],v[1][3],v[1][4],SetTo,v[4],DestMask))
		end
	end
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			CRead1,
		},
		flag = {Preserved}
	}

	local Check = {}
	for i = 0, 31 do
		local CBit = bit32.lshift(1,i)
		if bit32.band(Mask,CBit) ~= 0 then
			if type(Input) == "number" then -- Read 0x58A364, 0x58A368 : 0x58A364 << 0x58A368 + D
				CRead2 = {MemoryX(Input,Exactly,CBit,CBit)}
			elseif Input == "Cp" then -- Read 0x58A364, Cp : 0x58A364 << Cp + D
				CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
			elseif Input[4] == "V" then -- Read 0x58A364, X : 0x58A364 << EPD(X) + D (CPRead)
				CRead2 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
			else -- Read 0x58A364, Mem : 0x58A364 << Mem + D
				CRead2 = {CtrigX(Input[1],Input[2],Input[3],Input[4],Exactly,CBit,CBit)}
			end

			local CRead3 = {}
			for k, v in pairs(OutputArr) do
				if bit32.band(v[3],CBit) ~= 0 and Check[k] == nil then
					if type(v[1]) == "number" then
						table.insert(CRead3,SetMemory(v[1],Add,CBit*v[2]))
					elseif v[1][4] == "V" then
						table.insert(CRead3,SetNVar(v[1],Add,CBit*v[2]))
					else
						table.insert(CRead3,SetCtrig1X(v[1][1],v[1][2],v[1][3],v[1][4],Add,CBit*v[2]))
					end
				end
			end

			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				   	CRead2,
				},
				actions = {
					CRead3,
				},
				flag = {Preserved}
			}
		end

		for k, v in pairs(OutputArr) do
			if CBit*v[2] >= 0x80000000 then
				Check[k] = 1
			end
		end
	end

	if Recover == 1 then
		RecoverCp(PlayerID)
	end
end

function CMov(PlayerID,Dest,Source,Deviation,Mask,Clear) -- <<
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end
	if Deviation == "X" then
		Deviation = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	if Deviation == nil then
		Deviation = 0
	end

	local Mask2 = Mask
	if Clear == 1 then
		Mask2 = 0xFFFFFFFF
	end

	if type(Source) == "table" and Source[4] == "VA" then
		local TempRet = {"X",CRet[7],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	end
	if type(Source) == "table" and Source[4] == "A" then
		CMov_InputData_Error()
	end
	local PDest
	if type(Dest) == "table" and Dest[4] == "VA" then
		PDest = Dest
		Dest = {"X",CRet[8],0,"V"}
	end
	if type(Dest) == "table" and Dest[4] == "A" then
		PDest = Dest
		Dest = {"X",CRet[8],0,"V"}
	end

	if type(Dest) == "number" then -- Mov 0x58A364, 1 : 0x58A364 << 1
		if type(Source) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetMemoryX(Dest,SetTo,Source,Mask);
					},
					flag = {Preserved}
				}
		elseif Source[4] == "V" then -- Mov 0x58A364, X : 0x58A364 << X + D
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetMemoryX(Dest,SetTo,Deviation,Mask);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(Dest));
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
		else
			CMov_InputData_Error()
		end
	elseif Dest == "Cp" then
		if type(Source) == "number" then -- Mov Cp, 1 : Cp << 1
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeathsX(CurrentPlayer,SetTo,Source,0,Mask);
					},
					flag = {Preserved}
				}
		elseif Source[4] == "V" then -- Mov Cp, X : Cp << X + D
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeathsX(CurrentPlayer,SetTo,Deviation,0,Mask);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,13);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
		else
			CMov_InputData_Error()
		end
	elseif Dest[4] == "V" then
		if type(Source) == "number" then -- Mov X, 1 : X << 1
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source,Mask2);
					},
					flag = {Preserved}
				}
		elseif Source[4] == "V" then -- Mov X, Y : X << Y + D
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
		else
			CMov_InputData_Error()
		end

	else 
		if type(Source) == "number" then -- Mov Mem 1 : Mem << 1
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Source,Mask);
					},
					flag = {Preserved}
				}
		elseif Source[4] == "V" then -- Mov Mem, X : Mem << X + D
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,Deviation,Mask);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask),
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000),
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
		else
			CMov_InputData_Error()
		end

	end

	if PDest ~= nil then
		MovX(PlayerID,PDest,Dest)
	end
end

function CWrite(PlayerID,Dest,Source,Deviation,Mask) -- << (CRead 대응)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end
	if Deviation == "X" then
		Deviation = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	if Deviation == nil then
		Deviation = 0
	end

	if type(Source) == "table" and Source[4] == "VA" then
		local TempRet = {"X",CRet[7],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	end
	local PDest
	if type(Dest) == "table" and Dest[4] == "VA" then
		local TempRet = {"X",CRet[8],0,"V"}
		MovX(PlayerID,TempRet,Dest)
		Dest = TempRet
	end
	
	if Dest[4] == "V" then
		if Dest[5] == nil then
			Dest[5] = 0
		end
		if type(Source) == "number" then -- Write X, 1 : EPD(X) << 1
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x158,1,SetTo,Dest[5]);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						FSetMemoryX(0,SetTo,Source,Mask);
					},
					flag = {Preserved}
				}
		elseif Source[4] == "V" then -- Write X, Y : EPD(X) << Y + D
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x15C,1,SetTo,Deviation);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x15C,1,1);
						SetCtrig1X("X","X",0x158,1,SetTo,Dest[5]);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
						CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						FSetMemoryX(0,SetTo,0,Mask);
					},
					flag = {Preserved}
				}
		else
			CWrite_InputData_Error()
		end
	else
		CWrite_InputData_Error()
	end
end

function ClShift(PlayerID,Dest,Source,Operand,Mask) -- << (x2)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if Operand == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			ClShift_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			ClShift_InputData_Error()
		end
		if type(Dest) == "number" then 
			ClShift_InputData_Error()
		elseif Dest == "Cp" then
			ClShift_InputData_Error()
		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- And X, 1 : X <<= 1 (max 31)
				if Source >= 32 or Source <= 0 then
					Source = math.abs(Source % 32)
				end
				if Source ~= 0 then
					local Repeat = Source
					Trigger {
						players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x4,1,SetTo,"X","X",0,0,1); -- Make Loop Action A->A
								SetCtrigX("X","X",0x158,1,SetTo,"X","X",0x164+0x20*Repeat,1,1); -- Reset Timer
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x1BC,1,1);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
								SetCtrigX("X","X",0x1B8,1,SetTo,"X","X",0x1BC,1,1);
								SetCtrig1X("X","X",0x1A8,1,SetTo,0xFFFFFFFF);
								SetCtrig1X("X","X",0x1C0,1,SetTo,Add*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
							},
							flag = {Preserved}
						}
					Trigger {
						players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X","X",0x164+0x20*Repeat,0,SetTo,0x0,0x2); -- Timer Action
								Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1)); -- Exit Action
								SetCtrig1X("X","X",0x158,0,Subtract,8); -- Run Tick
								SetMemoryX(0,SetTo,0,0xFFFFFFFF); -- Temp Variable
								},
								flag = {Preserved}
							}
					Trigger {
						players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X","X",0x184,-1,SetTo,0x2,0x2); -- Reset Flag
								SetCtrigX("X","X",0x1B8,-1,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X","X",0x1A8,-1,SetTo,Mask);
								SetCtrig1X("X","X",0x1C0,-1,SetTo,SetTo*16777216,0xFF000000);
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1);
								SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1);
								},
								flag = {Preserved}
							}
				end
			elseif Source[4] == "V" then -- And X, Y : X <<= Y
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
							CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,0,0x1F);
						},
						actions = {
							SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,4);
						},
						flag = {Preserved}
					}
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x178,1,SetTo,"X","X",0x1A0+0x20*1,1,1); -- Reset Timer
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0x1F);
							SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
							SetCtrigX("X",CRet[1],0x158,0,SetTo,"X","X",0x178,1,1);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);

							SetCtrigX("X","X",0x4,1,SetTo,"X","X",0,0,1); -- Make Loop Action A->A
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x15C,1,1);
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X","X",0x158,1,SetTo,"X","X",0x15C,1,1);
							SetCtrig1X("X","X",0x148,1,SetTo,0xFFFFFFFF);
							SetCtrig1X("X","X",0x160,1,SetTo,Add*16777216,0xFF000000);
							CallLabelAlways3(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3],"X",CRet[1],0);
						},
						flag = {Preserved}
					}
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemoryX(0,SetTo,0,0xFFFFFFFF); -- Temp Variable
							SetCtrig1X("X","X",0x1A0+0x20*1,0,SetTo,0x0,0x2); -- Timer Action
							SetCtrig1X("X","X",0x158+0x20*1,0,Subtract,1); -- Run Tick
							Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1)); -- Exit Action
							},
							flag = {Preserved}
						}
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x158+0x20*1,-1,Add,32); -- Reset Flag
							SetCtrig1X("X","X",0x1A4+0x20*1,-1,SetTo,0x2,0x2); -- Reset Flag
							SetCtrigX("X","X",0x158,-1,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X("X","X",0x148,-1,SetTo,Mask);
							SetCtrig1X("X","X",0x160,-1,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1);
							SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,2);
							},
							flag = {Preserved}
						}
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x4,-4,SetTo,"X","X",0x0,0,-3);
						},
							flag = {Preserved}
						}	
			else
				ClShift_InputData_Error()
			end
		else 
			ClShift_InputData_Error()
		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Operand) == "table" and Operand[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Operand)
			Operand = TempRet
		end
		if type(Operand) == "table" and Operand[4] == "A" then
			ClShift_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			ClShift_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			ClShift_InputData_Error()
		end

		if type(Source) == "number" then -- And V, 0x58A364, 1 : V << 0x58A364 & 1 / Read필요
			if type(Operand) == "number" then
				ClShift_InputData_Error()
			elseif Operand[4] == "V" then -- And V, 0x58A364, X : V << 0x58A364 & X / Read필요
				ClShift_InputData_Error()
			else
				ClShift_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Operand) == "number" then -- And V, Cp, 1 : V << Cp & 1 / Read필요 
				ClShift_InputData_Error()
			elseif Operand[4] == "V" then -- And V, Cp, X : V << Cp & X / Read필요 
				ClShift_InputData_Error()
			else
				ClShift_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Operand) == "number" then -- And V, X, 1 : V << (X << 1)
				if Operand >= 32 or Operand <= 0 then
					Operand = math.abs(Operand % 32)
				end
				if Operand ~= 0 then
					local Repeat = Operand
					Trigger {
						players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x4,1,SetTo,"X","X",0,0,1); -- Make Loop Action A->A
								SetCtrigX("X","X",0x158,1,SetTo,"X","X",0x164+0x20*Repeat,1,1); -- Reset Timer
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x1BC,1,1);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								SetCtrigX("X","X",0x1B8,1,SetTo,"X","X",0x1BC,1,1);
								SetCtrig1X("X","X",0x1A8,1,SetTo,0xFFFFFFFF);
								SetCtrig1X("X","X",0x1C0,1,SetTo,Add*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
							},
							flag = {Preserved}
						}
					Trigger {
						players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X","X",0x164+0x20*Repeat,0,SetTo,0x0,0x2); -- Timer Action
								Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1)); -- Exit Action
								SetCtrig1X("X","X",0x158,0,Subtract,8); -- Run Tick
								SetMemoryX(0,SetTo,0,0xFFFFFFFF); -- Temp Variable
								},
								flag = {Preserved}
							}
					Trigger {
						players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X","X",0x184,-1,SetTo,0x2,0x2); -- Reset Flag
								SetCtrigX("X","X",0x1B8,-1,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X","X",0x1A8,-1,SetTo,Mask);
								SetCtrig1X("X","X",0x1C0,-1,SetTo,SetTo*16777216,0xFF000000);
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1);
								SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1);
								},
								flag = {Preserved}
							}
				end
			elseif Operand[4] == "V" then -- And V, X, Y : V << (X << Y)
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
							CtrigX(Operand[1],Operand[2],0x15C,Operand[3],Exactly,0,0x1F);
						},
						actions = {
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
							SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0x0,0,4);
						},
						flag = {Preserved}
					}
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x178,1,SetTo,"X","X",0x1A0+0x20*1,1,1); -- Reset Timer
							SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0x1F);
							SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
							SetCtrigX("X",CRet[1],0x158,0,SetTo,"X","X",0x178,1,1);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);

							SetCtrigX("X","X",0x4,1,SetTo,"X","X",0,0,1); -- Make Loop Action A->A
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x15C,1,1);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X","X",0x158,1,SetTo,"X","X",0x15C,1,1);
							SetCtrig1X("X","X",0x148,1,SetTo,0xFFFFFFFF);
							SetCtrig1X("X","X",0x160,1,SetTo,Add*16777216,0xFF000000);
							CallLabelAlways3(Source[1],Source[2],Source[3],Operand[1],Operand[2],Operand[3],"X",CRet[1],0);
						},
						flag = {Preserved}
					}
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemoryX(0,SetTo,0,0xFFFFFFFF); -- Temp Variable
							SetCtrig1X("X","X",0x1A0+0x20*1,0,SetTo,0x0,0x2); -- Timer Action
							SetCtrig1X("X","X",0x158+0x20*1,0,Subtract,1); -- Run Tick
							Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1)); -- Exit Action
							},
							flag = {Preserved}
						}
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x158+0x20*1,-1,Add,32); -- Reset Flag
							SetCtrig1X("X","X",0x1A4+0x20*1,-1,SetTo,0x2,0x2); -- Reset Flag
							SetCtrigX("X","X",0x158,-1,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X("X","X",0x148,-1,SetTo,Mask);
							SetCtrig1X("X","X",0x160,-1,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1);
							SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,2);
							},
							flag = {Preserved}
						}
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x4,-4,SetTo,"X","X",0x0,0,-3);
						},
							flag = {Preserved}
						}	
			else
				ClShift_InputData_Error()
			end
		else 
			if type(Operand) == "number" then -- And V, Mem, 1 : V << Mem & 1 / Read필요
				ClShift_InputData_Error()
			elseif Operand[4] == "V" then -- And V, Mem, X : V << Mem & X / Read필요
				ClShift_InputData_Error()
			else
				ClShift_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		ClShift_InputData_Error()
	end
end

function CAdd(PlayerID,Dest,Source,Operand,Mask) -- +
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if Operand == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CAdd_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end

		if type(Dest) == "number" then -- Add 0x58A364, 1 : 0x58A364 += 1
			if type(Source) == "number" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(Dest,Add,Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- Add 0x58A364, X : 0x58A364 += X
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(Dest));
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
			else
				CAdd_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- Add Cp, 1 : Cp += 1
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetDeaths(CurrentPlayer,Add,Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- Add Cp, X : Cp += X
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,13);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
			else
				CAdd_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- Add X, 1 : X += 1
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- Add X, Y : X += Y
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
			else
				CAdd_InputData_Error()
			end

		else 
			if type(Source) == "number" then -- Add Mem, 1 : Mem += 1
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- Add Mem, X : Mem += X
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
			else
				CAdd_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Operand) == "table" and Operand[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Operand)
			Operand = TempRet
		end
		if type(Operand) == "table" and Operand[4] == "A" then
			CAdd_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CAdd_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end

		if type(Source) == "number" then -- Add V, 0x58A364, 1 : V << 0x58A364 + 1 / Read필요
			if type(Operand) == "number" then
				CAdd_InputData_Error()
			elseif Operand[4] == "V" then -- Add V, 0x58A364, X : V << 0x58A364 + X / Read필요
				CAdd_InputData_Error()
			else
				CAdd_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Operand) == "number" then -- Add V, Cp, 1 : V << Cp + 1 / Read필요 
				CAdd_InputData_Error()
			elseif Operand[4] == "V" then -- Add V, Cp, X : V << Cp + X / Read필요 
				CAdd_InputData_Error()
			else
				CAdd_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Operand) == "number" then -- Add V, X, 1 : V << X + 1
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Operand,Mask);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			elseif Operand[4] == "V" then -- Add V, X, Y : V << X + Y
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,Mask);
						SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,Add*16777216,0xFF000000);
						CallLabelAlways(Operand[1],Operand[2],Operand[3]);
					},
					flag = {Preserved}
				}
			else
				CAdd_InputData_Error()
			end

		else 
			if type(Operand) == "number" then -- Add V, Mem, 1 : V << Mem + 1 / Read필요
				CAdd_InputData_Error()
			elseif Operand[4] == "V" then -- Add V, Mem, X : V << Mem + X / Read필요
				CAdd_InputData_Error()
			else
				CAdd_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CAdd_InputData_Error()
	end
end

function CSub(PlayerID,Dest,Source,Operand,Mask) -- - (1 - 2 = 0)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if Operand == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CSub_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "number" then -- Sub 0x58A364, 1 : 0x58A364 -= 1
			if type(Source) == "number" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(Dest,Subtract,Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- Sub 0x58A364, X : 0x58A364 -= X
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(Dest));
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
			else
				CSub_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- Sub Cp, 1 : Cp -= 1
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetDeaths(CurrentPlayer,Subtract,Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- Sub Cp, X : Cp -= X
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,13);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
			else
				CSub_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- Sub X, 1 : X -= 1
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Subtract,Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- Sub X, Y : X -= Y
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
			else
				CSub_InputData_Error()
			end

		else 
			if type(Source) == "number" then -- Sub Mem, 1 : Mem -= 1
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Subtract,Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- Sub Mem, X : Mem -= X
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
			else
				CSub_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Operand) == "table" and Operand[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Operand)
			Operand = TempRet
		end
		if type(Operand) == "table" and Operand[4] == "A" then
			CSub_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CSub_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end

		if type(Source) == "number" then -- Sub V, 0x58A364, 1 : V << 0x58A364 - 1 / Read필요
			if type(Operand) == "number" then
				CSub_InputData_Error()
			elseif Operand[4] == "V" then -- Sub V, 0x58A364, X : V << 0x58A364 - X / Read필요
				CSub_InputData_Error()
			else
				CSub_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Operand) == "number" then -- Sub V, Cp, 1 : V << Cp - 1 / Read필요 
				CSub_InputData_Error()
			elseif Operand[4] == "V" then -- Sub V, Cp, X : V << Cp - X / Read필요 
				CSub_InputData_Error()
			else
				CSub_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Operand) == "number" then -- Sub V, X, 1 : V << X - 1
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Subtract,Operand,Mask);
					},
					flag = {Preserved}
				}
			elseif Operand[4] == "V" then -- Sub V, X, Y : V << X - Y
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,Mask);
						SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways(Operand[1],Operand[2],Operand[3]);
					},
					flag = {Preserved}
				}
			else
				CSub_InputData_Error()
			end

		else 
			if type(Operand) == "number" then -- Sub V, Mem, 1 : V << Mem - 1 / Read필요
				CSub_InputData_Error()
			elseif Operand[4] == "V" then -- Sub V, Mem, X : V << Mem - X / Read필요
				CSub_InputData_Error()
			else
				CSub_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CSub_InputData_Error()
	end
end

function CiSub(PlayerID,Dest,Source,Operand,Mask) -- - (1 - 2 = -1)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if Operand == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CiSub_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "number" then -- iSub 0x58A364, 1 : 0x58A364 -= 1
			if type(Source) == "number" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(Dest,Add,0-Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- iSub 0x58A364, X : 0x58A364 -= X
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(Dest));
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
			else
				CiSub_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- iSub Cp, 1 : Cp -= 1
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetDeaths(CurrentPlayer,Add,0-Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- iSub Cp, X : Cp -= X
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrig1X("X",CRet[1],0x158,0,SetTo,13);
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
			else
				CiSub_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- iSub X, 1 : X -= 1
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,0-Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- iSub X, Y : X -= Y
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
			else
				CiSub_InputData_Error()
			end

		else 
			if type(Source) == "number" then -- iSub Mem, 1 : Mem -= 1
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,0-Source);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- iSub Mem, X : Mem -= X
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
			else
				CiSub_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Operand) == "table" and Operand[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Operand)
			Operand = TempRet
		end
		if type(Operand) == "table" and Operand[4] == "A" then
			CiSub_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CiSub_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Source) == "number" then -- iSub V, 0x58A364, 1 : V << 0x58A364 - 1 / Read필요
			if type(Operand) == "number" then
				CiSub_InputData_Error()
			elseif Operand[4] == "V" then -- iSub V, 0x58A364, X : V << 0x58A364 - X / Read필요
				CiSub_InputData_Error()
			else
				CiSub_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Operand) == "number" then -- iSub V, Cp, 1 : V << Cp - 1 / Read필요 
				CiSub_InputData_Error()
			elseif Operand[4] == "V" then -- iSub V, Cp, X : V << Cp - X / Read필요 
				CiSub_InputData_Error()
			else
				CiSub_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Operand) == "number" then -- iSub V, X, 1 : V << X - 1
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,0-Operand,Mask);
					},
					flag = {Preserved}
				}
			elseif Operand[4] == "V" then -- iSub V, X, Y : V << X - Y
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways(Operand[1],Operand[2],Operand[3]);
					},
					flag = {Preserved}
				}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,Mask);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
			else
				CiSub_InputData_Error()
			end

		else 
			if type(Operand) == "number" then -- iSub V, Mem, 1 : V << Mem - 1 / Read필요
				CiSub_InputData_Error()
			elseif Operand[4] == "V" then -- iSub V, Mem, X : V << Mem - X / Read필요
				CiSub_InputData_Error()
			else
				CiSub_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CiSub_InputData_Error()
	end
end

function CNeg(PlayerID,Dest,Source,Mask) -- x-1
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if Source == nil then
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
			MovX(PlayerID,Dest,PDest)
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CNeg_InputData_Error()
		end
		if type(Dest) == "number" then -- Neg 0x58A364 / Read필요
			CNeg_InputData_Error()
		elseif Dest == "Cp" then -- Neg Cp / Read필요
			CNeg_InputData_Error()
		elseif Dest[4] == "V" then -- Neg X : X << -X
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Subtract*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[1],0x15C,1,0);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
		else -- Neg Mem / Read필요
			CNeg_InputData_Error()
		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CNeg_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "number" then
			CNeg_InputData_Error()
		elseif Dest == "Cp" then
			CNeg_InputData_Error()
		elseif Dest[4] == "V" then
			if type(Source) == "number" then
				CNeg_InputData_Error()
			elseif Source[4] == "V" then -- Neg V, X : V << -X
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,Mask);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
			else
				CNeg_InputData_Error()
			end
		else
			CNeg_InputData_Error()
		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CNeg_InputData_Error()
	end
end

--[[ 구 CMul 함수
function CMul(PlayerID,Dest,Source,Multiplier,Mask,BitLimit) -- *, Y만 Limit bit 제한 (메모리에 )
	STPopTrigArr(PlayerID)

	if Multiplier == "X" then
		Multiplier = nil
	end

	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local  Bit = 0
	if BitLimit == nil or BitLimit == "X" then
		Bit = 31
	else
		while 2^Bit <= BitLimit and Bit <= 31 do
			Bit = Bit + 1
		end
		Bit = Bit - 1
	end

	local MulArr1 = {}
	local MulArr2 = {}
	local MulArr3 = {}
	local MulType = 0
	local MulType2 = 0
	local MulType3 = 0
	if Multiplier == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CMul_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CMul_InputData_Error()
		end
		if type(Dest) == "number" then -- Mul 0x58A364, 1 : 0x58A364 *= 1
			if type(Source) == "number" then
				MulType2 = 1
			elseif Source[4] == "V" then -- Mul 0x58A364, X : 0x58A364 *= X / Read필요
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- Mul Cp, 1 : Cp *= 1
				MulType2 = 2
			elseif Source[4] == "V" then -- Mul Cp, X : Cp *= X / Read필요
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- Mul X, 1 : X *= 1
				MulType2 = 3
			elseif Source[4] == "Cp" then -- Mul X, Cp : X *= Cp
				MulType = 1
				MulType3 = 1
			elseif Source[4] == "V" then -- Mul X, Y : X *= Y
				MulType = 1
				MulType3 = 2
			else -- Mul X, Mem : X *= Mem
				MulType = 1
				MulType3 = 3
			end

		else 
			if type(Source) == "number" then -- Mul Mem, 1 : Mem *= 1
				MulType2 = 4
			elseif Source[4] == "V" then -- Add Mem, X : Mem *= X / Read필요
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		end

		if type(Source) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
					},
					flag = {Preserved}
				}
			local Block = 0
			for i = 0, Bit do
				local CBit = 2^i
				if MulType2 == 1 then
					MulArr1 = {MemoryX(Dest,Exactly,CBit,CBit)}
				elseif MulType2 == 2 then
					MulArr1 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
				elseif MulType2 == 3 then
					MulArr1 = {CtrigX(Dest[1],Dest[2],0x15C,Dest[3],Exactly,CBit,CBit)}
				elseif MulType2 == 4 then
					MulArr1 = {CtrigX(Dest[1],Dest[2],Dest[3],Dest[4],Exactly,CBit,CBit)}
				end
				if Block == 0 then
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
								MulArr1,
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x15C,0,Add,Source*CBit);
							},
							flag = {Preserved}
						}
				end
				if  bit32.band(Source*CBit,0xFFFFFFFF) >= 0x80000000 then
					Block = 0 -- 나눗셈 : Block 필요 / 곱셈 : Block 불필요
				end
			end
			if MulType2 == 1 then
				MulArr2 = {SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(Dest))}
			elseif MulType2 == 2 then
				MulArr2 = {SetCtrig1X("X",CRet[1],0x158,0,SetTo,13)}
			elseif MulType2 == 3 then
				MulArr2 = {SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3])}
			elseif MulType2 == 4 then
				MulArr2 = {SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4])}
			end
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						MulArr2,
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
		end
		if MulType == 1 then
			if Dest == Source then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[3],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Source = {"X",CRet[3],0,"V"}
			end

			Trigger { 
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
						SetCtrigX("X",FuncAlloc,0x19C,1,SetTo,"X",FuncAlloc,0x0,0,2);
					},
					flag = {Preserved}
				}

			local ClearValue = {}
			for i = 0, Bit do
				table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,(Bit+3)+i,SetTo,0))
			end

			Trigger { 
					players = {PlayerID},
					conditions = {
						Label(FuncAlloc);
					},
					actions = {
						ClearValue,
					},
					flag = {Preserved}
				}

			Trigger { -- local Var1 (1)
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X("X",FuncAlloc,0x19C,1,Add,0x970);
						SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,2);
					},
					flag = {Preserved}
				}

			for i = 0, Bit do
				Trigger { -- (2 ~ Bit+2)
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc,0x15C,1,(Bit+3)+i);
						SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
					},
					flag = {Preserved}
				}
			end

			PlayerID = PlayerConvert(PlayerID)
			for k, P in pairs(PlayerID) do
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,2))
				for i = 1, (Bit+2) do
					table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",CRet[1],0x0,0,0))
				end
			end

			for i = 0, Bit do
				local CBit = 2^i

				if MulType3 == 1 then
					MulArr3 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
				elseif MulType3 == 2 then
					MulArr3 = {CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,CBit,CBit)}
				elseif MulType3 == 3 then
					MulArr3 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
				end

				Trigger { -- (Bit+3 ~ 2*Bit+3)
					players = {PlayerID},
					conditions = {
						Label(0);
						MulArr3,
					},
					actions = {
						SetCtrig1X("X",CRet[2],0x15C,0,Add,0);
					},
					flag = {Preserved}
				}
			end

			Trigger { -- 2*Bit + 4
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}

			FuncAlloc = FuncAlloc + 1
		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Multiplier) == "table" and Multiplier[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Multiplier)
			Multiplier = TempRet
		end
		if type(Multiplier) == "table" and Multiplier[4] == "A" then
			CMul_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CMul_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CMul_InputData_Error()
		end
		if type(Source) == "number" then -- Mul V, 0x58A364, 1 : V << 0x58A364 * 1 / Read필요
			if type(Multiplier) == "number" then
				CMul_InputData_Error()
			elseif Multiplier[4] == "V" then -- Mul V, 0x58A364, X : V << 0x58A364 * X / Read필요
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Multiplier) == "number" then -- Mul V, Cp, 1 : V << Cp * 1 / Read필요 
				CMul_InputData_Error()
			elseif Multiplier[4] == "V" then -- Mul V, Cp, X : V << Cp * X / Read필요 
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Multiplier) == "number" then -- Mul V, X, 1 : V << X * 1
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
					},
					flag = {Preserved}
				}
				local Block = 0
				for i = 0, Bit do
					local CBit = 2^i
					if Block == 0 then
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
									CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,CBit,CBit);
								},
								actions = {
									SetCtrig1X("X",CRet[1],0x15C,0,Add,Multiplier*CBit);
								},
								flag = {Preserved}
							}
					end
					if  bit32.band(Multiplier*CBit,0xFFFFFFFF) >= 0x80000000 then
						Block = 0 -- 나눗셈 : Block 필요 / 곱셈 : Block 불필요
					end
				end
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}

			elseif Multiplier == "Cp" then -- Mul V, X, Cp : V << X * Cp
				MulType = 1
				MulType3 = 1
			elseif Multiplier[4] == "V" then -- Mul V, X, Y : V << X * Y
				MulType = 1
				MulType3 = 2
			else -- Mul V, X, Mem : V << X * Mem
				MulType = 1
				MulType3 = 3
			end
			if MulType == 1 then
				if Source == Multiplier then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[3],0x15C,1,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
					Source = {"X",CRet[3],0,"V"}
				end

				Trigger { 
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways(Source[1],Source[2],Source[3]);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
							SetCtrigX("X",FuncAlloc,0x19C,1,SetTo,"X",FuncAlloc,0x0,0,2);
						},
						flag = {Preserved}
					}

				local ClearValue = {}
				for i = 0, Bit do
					table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,(Bit+3)+i,SetTo,0))
				end

				Trigger { 
						players = {PlayerID},
						conditions = {
							Label(FuncAlloc);
						},
						actions = {
							ClearValue,
						},
						flag = {Preserved}
					}

				Trigger { -- local Var1 (1)
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X("X",FuncAlloc,0x19C,1,Add,0x970);
							SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,2);
						},
						flag = {Preserved}
					}

				for i = 0, Bit do
					Trigger { -- (2 ~ Bit+2)
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc,0x15C,1,(Bit+3)+i);
							SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
						},
						flag = {Preserved}
					}
				end

				PlayerID = PlayerConvert(PlayerID)
				for k, P in pairs(PlayerID) do
					table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,2))
					for i = 1, (Bit+2) do
						table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",CRet[1],0x0,0,0))
					end
				end

				for i = 0, Bit do
					local CBit = 2^i

					if MulType3 == 1 then
						MulArr3 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
					elseif MulType3 == 2 then
						MulArr3 = {CtrigX(Multiplier[1],Multiplier[2],0x15C,Multiplier[3],Exactly,CBit,CBit)}
					elseif MulType3 == 3 then
						MulArr3 = {CtrigX(Multiplier[1],Multiplier[2],Multiplier[3],Multiplier[4],Exactly,CBit,CBit)}
					end

					Trigger { -- (Bit+3 ~ 2*Bit+3)
						players = {PlayerID},
						conditions = {
							Label(0);
							MulArr3,
						},
						actions = {
							SetCtrig1X("X",CRet[2],0x15C,0,Add,0);
						},
						flag = {Preserved}
					}
				end

				Trigger { -- 2*Bit + 4
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}

				FuncAlloc = FuncAlloc + 1
			end
		else 
			if type(Multiplier) == "number" then -- Mul V, Mem, 1 : V << Mem * 1 / Read필요
				CMul_InputData_Error()
			elseif Multiplier[4] == "V" then -- Mul V, Mem, X : V << Mem * X / Read필요
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CMul_InputData_Error()
	end
end
]]--

function CMul(PlayerID,Dest,Source,Multiplier,Mask,BitLimit) -- *, Y만 Limit bit 제한 (메모리에 )
	STPopTrigArr(PlayerID)

	if Multiplier == "X" then
		Multiplier = nil
	end

	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local  Bit = 0
	if BitLimit == nil or BitLimit == "X" then
		Bit = 31
	else
		while 2^Bit <= BitLimit and Bit <= 31 do
			Bit = Bit + 1
		end
		Bit = Bit - 1
	end

	local MulArr1 = {}
	local MulArr2 = {}
	local MulArr3 = {}
	local MulType = 0
	local MulType2 = 0
	local MulType3 = 0
	if Multiplier == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CMul_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CMul_InputData_Error()
		end
		if type(Dest) == "number" then -- Mul 0x58A364, 1 : 0x58A364 *= 1
			if type(Source) == "number" then
				MulType2 = 1
			elseif Source[4] == "V" then -- Mul 0x58A364, X : 0x58A364 *= X / Read필요
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- Mul Cp, 1 : Cp *= 1
				MulType2 = 2
			elseif Source[4] == "V" then -- Mul Cp, X : Cp *= X / Read필요
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- Mul X, 1 : X *= 1
				MulType2 = 3
			elseif Source[4] == "Cp" then -- Mul X, Cp : X *= Cp
				MulType = 1
				MulType3 = 1
			elseif Source[4] == "V" then -- Mul X, Y : X *= Y
				MulType = 1
				MulType3 = 2
			else -- Mul X, Mem : X *= Mem
				MulType = 1
				MulType3 = 3
			end

		else 
			if type(Source) == "number" then -- Mul Mem, 1 : Mem *= 1
				MulType2 = 4
			elseif Source[4] == "V" then -- Add Mem, X : Mem *= X / Read필요
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		end

		if type(Source) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
					},
					flag = {Preserved}
				}
			local Block = 0
			for i = 0, Bit do
				local CBit = 2^i
				if MulType2 == 1 then
					MulArr1 = {MemoryX(Dest,Exactly,CBit,CBit)}
				elseif MulType2 == 2 then
					MulArr1 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
				elseif MulType2 == 3 then
					MulArr1 = {CtrigX(Dest[1],Dest[2],0x15C,Dest[3],Exactly,CBit,CBit)}
				elseif MulType2 == 4 then
					MulArr1 = {CtrigX(Dest[1],Dest[2],Dest[3],Dest[4],Exactly,CBit,CBit)}
				end
				if Block == 0 then
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
								MulArr1,
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x15C,0,Add,Source*CBit);
							},
							flag = {Preserved}
						}
				end
				if  bit32.band(Source*CBit,0xFFFFFFFF) >= 0x80000000 then
					Block = 0 -- 나눗셈 : Block 필요 / 곱셈 : Block 불필요
				end
			end
			if MulType2 == 1 then
				MulArr2 = {SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(Dest))}
			elseif MulType2 == 2 then
				MulArr2 = {SetCtrig1X("X",CRet[1],0x158,0,SetTo,13)}
			elseif MulType2 == 3 then
				MulArr2 = {SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3])}
			elseif MulType2 == 4 then
				MulArr2 = {SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4])}
			end
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						MulArr2,
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
		end
		if MulType == 1 then
			if Dest == Source then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
				Dest = {"X",CRet[1],0,"V"}
			end

			local ClearValue = {}
			for i = 0, Bit do
				table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,2+i,SetTo,0)) --2~Bit+2
			end
			local Repeat = Bit*2
			Trigger {  -- 0
					players = {PlayerID},
					conditions = {
						Label(FuncAlloc);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FuncAlloc,0x15C+0x20*5,1,1);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
						ClearValue,
						SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0,0,1); -- Make Loop Action A->A
						SetCtrigX("X",FuncAlloc,0x158+0x20*6,1,SetTo,"X",FuncAlloc,0x1A4+0x20*6+0x4*Repeat,1,1); -- Reset Timer
						SetCtrig1X("X",FuncAlloc,0x1A4+0x20*6,1,SetTo,0x2,0x2); -- Reset Flag
						SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x15C,1,2);
						SetCtrig1X("X",FuncAlloc,0x164,1,SetTo,0x0,0x2);
						SetCtrig1X("X",FuncAlloc,0x184,1,SetTo,0x2,0x2);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}

			Trigger { -- local Var1 (1)
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x158+0x20*5,0,SetTo,"X",FuncAlloc,0x15C,1,2); -- Switch Action (Default = On)
						Disabled(SetCtrigX("X","X",0x158+0x20*5,0,SetTo,"X","X",0x15C+0x20*5,1,0)), -- Switch Action (Default = Off)
						SetCtrig1X("X","X",0x164,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
						SetCtrig1X("X","X",0x184,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
						SetCtrig1X("X","X",0x15C,0,Add,0x970/8);
						SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
						SetCtrig1X("X","X",0x1A4+0x20*6+0x4*Repeat,0,SetTo,0x0,0x2); -- Timer Action
						SetCtrig1X("X","X",0x158+0x20*6,0,Subtract,1); -- Run Tick
						Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1)); -- Exit Action
					},
					flag = {Preserved}
				}

			for i = 0, Bit do
				local CBit = 2^i

				if MulType3 == 1 then
					MulArr3 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
				elseif MulType3 == 2 then
					MulArr3 = {CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,CBit,CBit)}
				elseif MulType3 == 3 then
					MulArr3 = {CtrigX(Source[1],Source[2],Source[3],Source[4],Exactly,CBit,CBit)}
				end

				Trigger { -- (+2 ~ Bit+2)
					players = {PlayerID},
					conditions = {
						Label(0);
						MulArr3,
					},
					actions = {
						SetCtrig1X("X",CRet[2],0x15C,0,Add,0);
					},
					flag = {Preserved}
				}
			end

			Trigger { -- Bit + 3
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}

			FuncAlloc = FuncAlloc + 1
		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Multiplier) == "table" and Multiplier[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Multiplier)
			Multiplier = TempRet
		end
		if type(Multiplier) == "table" and Multiplier[4] == "A" then
			CMul_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CMul_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CMul_InputData_Error()
		end
		if type(Source) == "number" then -- Mul V, 0x58A364, 1 : V << 0x58A364 * 1 / Read필요
			if type(Multiplier) == "number" then
				CMul_InputData_Error()
			elseif Multiplier[4] == "V" then -- Mul V, 0x58A364, X : V << 0x58A364 * X / Read필요
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Multiplier) == "number" then -- Mul V, Cp, 1 : V << Cp * 1 / Read필요 
				CMul_InputData_Error()
			elseif Multiplier[4] == "V" then -- Mul V, Cp, X : V << Cp * X / Read필요 
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Multiplier) == "number" then -- Mul V, X, 1 : V << X * 1
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
					},
					flag = {Preserved}
				}
				local Block = 0
				for i = 0, Bit do
					local CBit = 2^i
					if Block == 0 then
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
									CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,CBit,CBit);
								},
								actions = {
									SetCtrig1X("X",CRet[1],0x15C,0,Add,Multiplier*CBit);
								},
								flag = {Preserved}
							}
					end
					if  bit32.band(Multiplier*CBit,0xFFFFFFFF) >= 0x80000000 then
						Block = 0 -- 나눗셈 : Block 필요 / 곱셈 : Block 불필요
					end
				end
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}

			elseif Multiplier == "Cp" then -- Mul V, X, Cp : V << X * Cp
				MulType = 1
				MulType3 = 1
			elseif Multiplier[4] == "V" then -- Mul V, X, Y : V << X * Y
				MulType = 1
				MulType3 = 2
			else -- Mul V, X, Mem : V << X * Mem
				MulType = 1
				MulType3 = 3
			end
			if MulType == 1 then
				if Source == Multiplier then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
					Source = {"X",CRet[1],0,"V"}
				end

				local ClearValue = {}
				for i = 0, Bit do
					table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,2+i,SetTo,0)) --2~Bit+2
				end
				local Repeat = Bit*2
				Trigger {  -- 0
						players = {PlayerID},
						conditions = {
							Label(FuncAlloc);
						},
						actions = {
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x15C+0x20*5,1,1);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
							ClearValue,
							SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0,0,1); -- Make Loop Action A->A
							SetCtrigX("X",FuncAlloc,0x158+0x20*6,1,SetTo,"X",FuncAlloc,0x1A4+0x20*6+0x4*Repeat,1,1); -- Reset Timer
							SetCtrig1X("X",FuncAlloc,0x1A4+0x20*6,1,SetTo,0x2,0x2); -- Reset Flag
							SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x15C,1,2);
							SetCtrig1X("X",FuncAlloc,0x164,1,SetTo,0x0,0x2);
							SetCtrig1X("X",FuncAlloc,0x184,1,SetTo,0x2,0x2);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}

				Trigger { -- local Var1 (1)
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x158+0x20*5,0,SetTo,"X",FuncAlloc,0x15C,1,2); -- Switch Action (Default = On)
							Disabled(SetCtrigX("X","X",0x158+0x20*5,0,SetTo,"X","X",0x15C+0x20*5,1,0)), -- Switch Action (Default = Off)
							SetCtrig1X("X","X",0x164,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
							SetCtrig1X("X","X",0x184,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
							SetCtrig1X("X","X",0x15C,0,Add,0x970/8);
							SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
							SetCtrig1X("X","X",0x1A4+0x20*6+0x4*Repeat,0,SetTo,0x0,0x2); -- Timer Action
							SetCtrig1X("X","X",0x158+0x20*6,0,Subtract,1); -- Run Tick
							Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1)); -- Exit Action
						},
						flag = {Preserved}
					}

				for i = 0, Bit do
					local CBit = 2^i

					if MulType3 == 1 then
						MulArr3 = {DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)}
					elseif MulType3 == 2 then
						MulArr3 = {CtrigX(Multiplier[1],Multiplier[2],0x15C,Multiplier[3],Exactly,CBit,CBit)}
					elseif MulType3 == 3 then
						MulArr3 = {CtrigX(Multiplier[1],Multiplier[2],Multiplier[3],Multiplier[4],Exactly,CBit,CBit)}
					end

					Trigger { -- (+2 ~ Bit+2)
						players = {PlayerID},
						conditions = {
							Label(0);
							MulArr3,
						},
						actions = {
							SetCtrig1X("X",CRet[2],0x15C,0,Add,0);
						},
						flag = {Preserved}
					}
				end

				Trigger { -- Bit + 3
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}

				FuncAlloc = FuncAlloc + 1
			end
		else 
			if type(Multiplier) == "number" then -- Mul V, Mem, 1 : V << Mem * 1 / Read필요
				CMul_InputData_Error()
			elseif Multiplier[4] == "V" then -- Mul V, Mem, X : V << Mem * X / Read필요
				CMul_InputData_Error()
			else
				CMul_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CMul_InputData_Error()
	end
end

function CDiv(PlayerID,Dest,Source,Divisor,Mask,BitLimit) -- /, X,Y 둘다 Limit bit 제한, 
	STPopTrigArr(PlayerID)

	if Divisor == "X" then
		Divisor = nil
	end

	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local  Bit = 0
	if BitLimit == nil or BitLimit == "X" then
		Bit = 31
	else
		while 2^Bit <= BitLimit and Bit <= 31 do
			Bit = Bit + 1
		end
		Bit = Bit - 1
	end
	
	if Divisor == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CDiv_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CDiv_InputData_Error()
		end

		if type(Dest) == "number" then -- Div 0x58A364, 1 : 0x58A364 /= 1 / Read필요
			if type(Source) == "number" then
				CDiv_InputData_Error()
			elseif Source[4] == "V" then -- Div 0x58A364, X : 0x58A364 /= X / Read필요
				CDiv_InputData_Error()
			else
				CDiv_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- Div Cp, 1 : Cp /= 1 / Read필요
				CDiv_InputData_Error()
			elseif Source[4] == "V" then -- Div Cp, X : Cp /= X / Read필요
				CDiv_InputData_Error()
			else
				CDiv_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- Div X, 1 : X /= 1
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
				local Block = 0
				for i = 0, Bit do
					local CBit = 2^i
					if  bit32.band(Source*CBit,0xFFFFFFFF) >= 0x80000000 then
						Block = i
						break
					end
				end
				for i = Block, 0, -1 do
					local CBit = 2^i
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
									CtrigX("X",CRet[2],0x15C,0,AtLeast,Source*CBit);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Subtract,Source*CBit);
									SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
								},
								flag = {Preserved}
							}
				end
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
			elseif Source[4] == "V" then -- Div X, Y : X /= Y
				if BitLimit ~= nil and BitLimit ~= "X" then
					Trigger { -- Y -> CRet[1] Act#1 (-3)
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}

					Trigger { -- Y -> CRet[1] Act#2 (-2)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x17C,1,0);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
							},
							flag = {Preserved}
						}

					
					Trigger { -- X -> CRet[2] (-1)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
							},
							flag = {Preserved}
						}

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,(Bit+4)+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,(Bit+4)+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {PlayerID},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}


					Trigger { -- local Var2 (1)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (2)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",CRet[1],0x17C,1,0);
								SetCtrig1X("X",FuncAlloc,0x1BC,2,Add,0x970);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						Trigger { -- (3 ~ Bit+3)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc,0x24,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",FuncAlloc,0x15C,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4-i);
							},
							flag = {Preserved}
						}
					end

					PlayerID = PlayerConvert(PlayerID)
					for k, P in pairs(PlayerID) do
						table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,3)) --> Create Local Var
						for i = 2, (Bit+3) do
							table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",CRet[1],0x0,0,0)) -- -> VarX
						end
					end

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (Bit+4 ~ 2*Bit+4)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[3],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- 2*Bit + 5
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[3],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[3],0);
							},
							flag = {Preserved}
						}

					FuncAlloc = FuncAlloc + 1
				else
					Bit = 31
					local ClearValue = {}
					for i = 0, 7 do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end
					local ClearValue2 = {}
					for i = 8, Bit do
						table.insert(ClearValue2,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue2,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end
					
					Trigger { --  (-2) /0 처리
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,0x0);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+4);
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF); -- 몫
							},
							flag = {Preserved}
						}

					Trigger { --  (-1)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								ClearValue,
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x4,2,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,2,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
								SetCtrig1X("X",FuncAlloc,0x15C,2,Add,0x970/2);
								CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
								SetCtrig1X("X",FuncAlloc,0x164,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x1A4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x1C4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x164+0x20*12,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184+0x20*12,1,SetTo,0x2,0x2);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x24,1,Bit+3);
								SetCtrigX("X",FuncAlloc,0x17C,1,SetTo,"X",FuncAlloc,0x15C,1,Bit+3);
							},
							flag = {Preserved}
						}

					Trigger { -- Clear Value 
							players = {PlayerID},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue2,
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
								CallLabelAlways(Source[1],Source[2],Source[3]);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (1)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X",FuncAlloc,0x24,1,Bit+3); -- Switch Action (Default = On)
								SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X",FuncAlloc,0x15C,1,Bit+3); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X","X",0x15C+0x20*10,1,0)), -- Switch Action (Default = Off)
								Disabled(SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X","X",0x17C+0x20*10,1,0)), -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1A4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1C4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,0,Subtract,0x970/8);
								SetCtrig1X("X","X",0x17C,0,Subtract,0x970/8);
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,0)); -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,1,Subtract,0x970/2);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var2 (2)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",FuncAlloc,0x15C+0x20*10,1,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (3 ~ Bit+3)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- Bit + 4
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,-2,SetTo,"X",FuncAlloc,0x0,0,-1);
								SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[1],0);
							},
							flag = {Preserved}
						}
					FuncAlloc = FuncAlloc + 1
				end
			else
				CDiv_InputData_Error()
			end

		else 
			if type(Source) == "number" then -- Div Mem, 1 : Mem /= 1 / Read필요
				CDiv_InputData_Error()
			elseif Source[4] == "V" then -- Add Mem, X : Mem /= X / Read필요
				CDiv_InputData_Error()
			else
				CDiv_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Divisor) == "table" and Divisor[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Divisor)
			Divisor = TempRet
		end
		if type(Divisor) == "table" and Divisor[4] == "A" then
			CDiv_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CDiv_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CDiv_InputData_Error()
		end
		if type(Source) == "number" then -- Div V, 0x58A364, 1 : V << 0x58A364 / 1 / Read필요
			if type(Divisor) == "number" then
				CDiv_InputData_Error()
			elseif Divisor[4] == "V" then -- Div V, 0x58A364, X : V << 0x58A364 / X / Read필요
				CDiv_InputData_Error()
			else
				CDiv_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Divisor) == "number" then -- Div V, Cp, 1 : V << Cp / 1 / Read필요 
				CDiv_InputData_Error()
			elseif Divisor[4] == "V" then -- Div V, Cp, X : V << Cp / X / Read필요 
				CDiv_InputData_Error()
			else
				CDiv_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Divisor) == "number" then -- Div V, X, 1 : V << X / 1
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				local Block = 0
				for i = 0, Bit do
					local CBit = 2^i
					if  bit32.band(Divisor*CBit,0xFFFFFFFF) >= 0x80000000 then
						Block = i
						break
					end
				end
				for i = Block, 0, -1 do
					local CBit = 2^i
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
									CtrigX("X",CRet[2],0x15C,0,AtLeast,Divisor*CBit);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Subtract,Divisor*CBit);
									SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
								},
								flag = {Preserved}
							}
				end
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
			elseif Divisor[4] == "V" then -- Div V, X, Y : V << X / Y
				if BitLimit ~= nil and BitLimit ~= "X" then
					Trigger { -- Y -> CRet[1] Act#1 (-3)
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
						},
						flag = {Preserved}
					}

					Trigger { -- Y -> CRet[1] Act#2 (-2)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x17C,1,0);
								CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
							},
							flag = {Preserved}
						}

					
					Trigger { -- X -> CRet[2] (-1)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
							},
							flag = {Preserved}
						}

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,(Bit+4)+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,(Bit+4)+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {PlayerID},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}


					Trigger { -- local Var2 (1)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (2)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",CRet[1],0x17C,1,0);
								SetCtrig1X("X",FuncAlloc,0x1BC,2,Add,0x970);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						Trigger { -- (3 ~ Bit+3)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc,0x24,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",FuncAlloc,0x15C,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4-i);
							},
							flag = {Preserved}
						}
					end

					PlayerID = PlayerConvert(PlayerID)
					for k, P in pairs(PlayerID) do
						table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,3)) --> Create Local Var
						for i = 2, (Bit+3) do
							table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",CRet[1],0x0,0,0)) -- -> VarX
						end
					end

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (Bit+4 ~ 2*Bit+4)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[3],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- 2*Bit + 5
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[3],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[3],0);
							},
							flag = {Preserved}
						}

					FuncAlloc = FuncAlloc + 1
				else
					Bit = 31
					local ClearValue = {}
					for i = 0, 7 do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end
					local ClearValue2 = {}
					for i = 8, Bit do
						table.insert(ClearValue2,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue2,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end
					
					Trigger { --  (-2) /0 처리
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],Exactly,0x0);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+4);
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF); -- 몫
							},
							flag = {Preserved}
						}

					Trigger { --  (-1)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								ClearValue,
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
								SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x4,2,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,2,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
								SetCtrig1X("X",FuncAlloc,0x15C,2,Add,0x970/2);
								CallLabelAlways2(Source[1],Source[2],Source[3],Divisor[1],Divisor[2],Divisor[3]);
								SetCtrig1X("X",FuncAlloc,0x164,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x1A4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x1C4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x164+0x20*12,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184+0x20*12,1,SetTo,0x2,0x2);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x24,1,Bit+3);
								SetCtrigX("X",FuncAlloc,0x17C,1,SetTo,"X",FuncAlloc,0x15C,1,Bit+3);
							},
							flag = {Preserved}
						}

					Trigger { -- Clear Value 
							players = {PlayerID},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue2,
								SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
								CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (1)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X",FuncAlloc,0x24,1,Bit+3); -- Switch Action (Default = On)
								SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X",FuncAlloc,0x15C,1,Bit+3); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X","X",0x15C+0x20*10,1,0)), -- Switch Action (Default = Off)
								Disabled(SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X","X",0x17C+0x20*10,1,0)), -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1A4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1C4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,0,Subtract,0x970/8);
								SetCtrig1X("X","X",0x17C,0,Subtract,0x970/8);
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,0)); -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,1,Subtract,0x970/2);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var2 (2)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",FuncAlloc,0x15C+0x20*10,1,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (3 ~ Bit+3)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- Bit + 4
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,-2,SetTo,"X",FuncAlloc,0x0,0,-1);
								SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[1],0);
							},
							flag = {Preserved}
						}
					FuncAlloc = FuncAlloc + 1
				end
			else
				CDiv_InputData_Error()
			end

		else 
			if type(Divisor) == "number" then -- Div V, Mem, 1 : V << Mem v1 / Read필요
				CDiv_InputData_Error()
			elseif Divisor[4] == "V" then -- Div V, Mem, X : V << Mem / X / Read필요
				CDiv_InputData_Error()
			else
				CDiv_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CDiv_InputData_Error()
	end
end

function CMod(PlayerID,Dest,Source,Divisor,Mask,BitLimit) -- %, X,Y 둘다 Limit bit 제한
	STPopTrigArr(PlayerID)

	if Divisor == "X" then
		Divisor = nil
	end

	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local  Bit = 0
	if BitLimit == nil or BitLimit == "X" then
		Bit = 31
	else
		while 2^Bit <= BitLimit and Bit <= 31 do
			Bit = Bit + 1
		end
		Bit = Bit - 1
	end
	
	if Divisor == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CMod_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CMod_InputData_Error()
		end
		if type(Dest) == "number" then -- Mod 0x58A364, 1 : 0x58A364 %= 1 / Read필요
			if type(Source) == "number" then
				CMod_InputData_Error()
			elseif Source[4] == "V" then -- Mod 0x58A364, X : 0x58A364 %= X / Read필요
				CMod_InputData_Error()
			else
				CMod_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- Mod Cp, 1 : Cp %= 1 / Read필요
				CMod_InputData_Error()
			elseif Source[4] == "V" then -- Mod Cp, X : Cp %= X / Read필요
				CMod_InputData_Error()
			else
				CMod_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- Mod X, 1 : X %= 1
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
				local Block = 0
				for i = 0, Bit do
					local CBit = 2^i
					if  bit32.band(Source*CBit,0xFFFFFFFF) >= 0x80000000 then
						Block = i
						break
					end
				end
				for i = Block, 0, -1 do
					local CBit = 2^i
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
									CtrigX("X",CRet[2],0x15C,0,AtLeast,Source*CBit);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Subtract,Source*CBit);
									SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
								},
								flag = {Preserved}
							}
				end
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}

			elseif Source[4] == "V" then -- Mod X, Y : X %= Y
				if BitLimit ~= nil and BitLimit ~= "X" then
					Trigger { -- Y -> CRet[1] Act#1 (-3)
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}

					Trigger { -- Y -> CRet[1] Act#2 (-2)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x17C,1,0);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
							},
							flag = {Preserved}
						}

					
					Trigger { -- X -> CRet[2] (-1)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
							},
							flag = {Preserved}
						}

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,(Bit+4)+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,(Bit+4)+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {PlayerID},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}


					Trigger { -- local Var2 (1)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (2)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",CRet[1],0x17C,1,0);
								SetCtrig1X("X",FuncAlloc,0x1BC,2,Add,0x970);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						Trigger { -- (3 ~ Bit+3)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc,0x24,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",FuncAlloc,0x15C,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4-i);
							},
							flag = {Preserved}
						}
					end

					PlayerID = PlayerConvert(PlayerID)
					for k, P in pairs(PlayerID) do
						table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,3)) --> Create Local Var
						for i = 2, (Bit+3) do
							table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",CRet[1],0x0,0,0)) -- -> VarX
						end
					end

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (Bit+4 ~ 2*Bit+4)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[3],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- 2*Bit + 5
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}


					FuncAlloc = FuncAlloc + 1
				else
					Bit = 31
					local ClearValue = {}
					for i = 0, 7 do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end
					local ClearValue2 = {}
					for i = 8, Bit do
						table.insert(ClearValue2,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue2,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end
					
					Trigger { --  (-2)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								ClearValue,
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x4,2,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,2,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
								SetCtrig1X("X",FuncAlloc,0x15C,2,Add,0x970/2);
								CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
								SetCtrig1X("X",FuncAlloc,0x164,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x1A4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x1C4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x164+0x20*12,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184+0x20*12,1,SetTo,0x2,0x2);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x24,1,Bit+3);
								SetCtrigX("X",FuncAlloc,0x17C,1,SetTo,"X",FuncAlloc,0x15C,1,Bit+3);
							},
							flag = {Preserved}
						}

					Trigger { --  (-1) /0 처리
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,0x0);
							},
							actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { -- Clear Value 
							players = {PlayerID},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue2,
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
								CallLabelAlways(Source[1],Source[2],Source[3]);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (1)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X",FuncAlloc,0x24,1,Bit+3); -- Switch Action (Default = On)
								SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X",FuncAlloc,0x15C,1,Bit+3); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X","X",0x15C+0x20*10,1,0)), -- Switch Action (Default = Off)
								Disabled(SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X","X",0x17C+0x20*10,1,0)), -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1A4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1C4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,0,Subtract,0x970/8);
								SetCtrig1X("X","X",0x17C,0,Subtract,0x970/8);
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,0)); -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,1,Subtract,0x970/2);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var2 (2)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",FuncAlloc,0x15C+0x20*10,1,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (3 ~ Bit+3)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- Bit + 4
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,-1,SetTo,"X",FuncAlloc,0x0,0,0);
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}
					FuncAlloc = FuncAlloc + 1
				end
			else
				CMod_InputData_Error()
			end

		else 
			if type(Source) == "number" then -- Mod Mem, 1 : Mem %= 1 / Read필요
				CMod_InputData_Error()
			elseif Source[4] == "V" then -- Add Mem, X : Mem %= X / Read필요
				CMod_InputData_Error()
			else
				CMod_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Divisor) == "table" and Divisor[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Divisor)
			Divisor = TempRet
		end
		if type(Divisor) == "table" and Divisor[4] == "A" then
			CMod_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CMod_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CMod_InputData_Error()
		end
		if type(Source) == "number" then -- Mod V, 0x58A364, 1 : V << 0x58A364 % 1 / Read필요
			if type(Divisor) == "number" then
				CMod_InputData_Error()
			elseif Divisor[4] == "V" then -- Mod V, 0x58A364, X : V << 0x58A364 % X / Read필요
				CMod_InputData_Error()
			else
				CMod_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Divisor) == "number" then -- Mod V, Cp, 1 : V << Cp % 1 / Read필요 
				CMod_InputData_Error()
			elseif Divisor[4] == "V" then -- Mod V, Cp, X : V << Cp % X / Read필요 
				CMod_InputData_Error()
			else
				CMod_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Divisor) == "number" then -- Mod V, X, 1 : V << X % 1
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				local Block = 0
				for i = 0, Bit do
					local CBit = 2^i
					if  bit32.band(Divisor*CBit,0xFFFFFFFF) >= 0x80000000 then
						Block = i
						break
					end
				end
				for i = Block, 0, -1 do
					local CBit = 2^i
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
									CtrigX("X",CRet[2],0x15C,0,AtLeast,Divisor*CBit);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Subtract,Divisor*CBit);
									SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
								},
								flag = {Preserved}
							}
				end
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}


			elseif Divisor[4] == "V" then -- Mod V, X, Y : V << X % Y
				if BitLimit ~= nil and BitLimit ~= "X" then
					Trigger { -- Y -> CRet[1] Act#1 (-3)
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
						},
						flag = {Preserved}
					}

					Trigger { -- Y -> CRet[1] Act#2 (-2)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x17C,1,0);
								CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
							},
							flag = {Preserved}
						}

					
					Trigger { -- X -> CRet[2] (-1)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
							},
							flag = {Preserved}
						}

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,(Bit+4)+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,(Bit+4)+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {PlayerID},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}


					Trigger { -- local Var2 (1)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (2)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",CRet[1],0x17C,1,0);
								SetCtrig1X("X",FuncAlloc,0x1BC,2,Add,0x970);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						Trigger { -- (3 ~ Bit+3)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc,0x24,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",FuncAlloc,0x15C,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4-i);
							},
							flag = {Preserved}
						}
					end

					PlayerID = PlayerConvert(PlayerID)
					for k, P in pairs(PlayerID) do
						table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,3)) --> Create Local Var
						for i = 2, (Bit+3) do
							table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",CRet[1],0x0,0,0)) -- -> VarX
						end
					end

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (Bit+4 ~ 2*Bit+4)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[3],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- 2*Bit + 5
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}

					FuncAlloc = FuncAlloc + 1
				else
					Bit = 31
					local ClearValue = {}
					for i = 0, 7 do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end
					local ClearValue2 = {}
					for i = 8, Bit do
						table.insert(ClearValue2,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue2,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end
					
					Trigger { --  (-2)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								ClearValue,
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
								SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x4,2,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,2,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
								SetCtrig1X("X",FuncAlloc,0x15C,2,Add,0x970/2);
								CallLabelAlways2(Source[1],Source[2],Source[3],Divisor[1],Divisor[2],Divisor[3]);
								SetCtrig1X("X",FuncAlloc,0x164,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x1A4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x1C4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x164+0x20*12,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184+0x20*12,1,SetTo,0x2,0x2);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x24,1,Bit+3);
								SetCtrigX("X",FuncAlloc,0x17C,1,SetTo,"X",FuncAlloc,0x15C,1,Bit+3);
							},
							flag = {Preserved}
						}

					Trigger { --  (-1) /0 처리
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],Exactly,0x0);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { -- Clear Value 
							players = {PlayerID},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue2,
								SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
								CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (1)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X",FuncAlloc,0x24,1,Bit+3); -- Switch Action (Default = On)
								SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X",FuncAlloc,0x15C,1,Bit+3); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X","X",0x15C+0x20*10,1,0)), -- Switch Action (Default = Off)
								Disabled(SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X","X",0x17C+0x20*10,1,0)), -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1A4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1C4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,0,Subtract,0x970/8);
								SetCtrig1X("X","X",0x17C,0,Subtract,0x970/8);
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,0)); -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,1,Subtract,0x970/2);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var2 (2)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",FuncAlloc,0x15C+0x20*10,1,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (3 ~ Bit+3)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- Bit + 4
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,-1,SetTo,"X",FuncAlloc,0x0,0,0);
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}
					FuncAlloc = FuncAlloc + 1
				end
			else
				CMod_InputData_Error()
			end
		else 
			if type(Divisor) == "number" then -- Mod V, Mem, 1 : V << Mem % 1 / Read필요
				CMod_InputData_Error()
			elseif Divisor[4] == "V" then -- Mod V, Mem, X : V << Mem % X / Read필요
				CMod_InputData_Error()
			else
				CMod_InputData_Error()
			end
		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CMod_InputData_Error()
	end
end

function CiDiv(PlayerID,Dest,Source,Divisor,Mask,BitLimit) -- CDiv의 Signed 연산 | 10/-3 = -3 / -10/3 = -3 / -10/-3 = 3
	STPopTrigArr(PlayerID)

	if Divisor == "X" then
		Divisor = nil
	end

	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local  Bit = 0
	if BitLimit == nil or BitLimit == "X" then
		Bit = 31
	else
		while 2^Bit <= BitLimit and Bit <= 31 do
			Bit = Bit + 1
		end
		Bit = Bit - 1
	end
	
	if Divisor == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CiDiv_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CiDiv_InputData_Error()
		end
		if type(Dest) == "number" then -- iDiv 0x58A364, 1 : 0x58A364 /= 1 / Read필요
			if type(Source) == "number" then
				CiDiv_InputData_Error()
			elseif Source[4] == "V" then -- iDiv 0x58A364, X : 0x58A364 /= X / Read필요
				CiDiv_InputData_Error()
			else
				CiDiv_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- iDiv Cp, 1 : Cp /= 1 / Read필요
				CiDiv_InputData_Error()
			elseif Source[4] == "V" then -- iDiv Cp, X : Cp /= X / Read필요
				CiDiv_InputData_Error()
			else
				CiDiv_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- iDiv X, 1 : X /= 1
				CIfX(PlayerID,CtrigX(Dest[1],Dest[2],0x15C,Dest[3],AtLeast,0x80000000))
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
							},
							flag = {Preserved}
						}
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
							},
							flag = {Preserved}
						}
				CElseX()
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
							},
							flag = {Preserved}
						}
				CIfXEnd()

				if bit32.band(Source,0xFFFFFFFF) >= 0x80000000 then
					Source = 0 - Source
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,Add,1); -- Sflag
							},
							flag = {Preserved}
						}
				end
			
				local Block = 0
				for i = 0, Bit do
					local CBit = 2^i
					if  bit32.band(Source*CBit,0xFFFFFFFF) >= 0x80000000 then
						Block = i
						break
					end
				end
				for i = Block, 0, -1 do
					local CBit = 2^i
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
									CtrigX("X",CRet[2],0x15C,0,AtLeast,Source*CBit);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Subtract,Source*CBit);
									SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
								},
								flag = {Preserved}
							}
				end
				CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF,Mask);
								SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[1],0);
							},
							flag = {Preserved}
						}
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
				CElseX()
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[1],0);
							},
							flag = {Preserved}
						}
				CIfXEnd()
			elseif Source[4] == "V" then -- iDiv X, Y : X /= Y
				if BitLimit ~= nil and BitLimit ~= "X" then
					CIfX(PlayerID,CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000))
						Trigger { -- Y -> CRet[1] Act#1 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
									SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0xFFFFFFFF);
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
									SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}

						Trigger { -- Y -> CRet[1] Act#2 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x17C,1,0);
									CallLabelAlways(Source[1],Source[2],Source[3]);
									SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
									SetCtrig1X("X",CRet[1],0x17C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { -- Y -> CRet[1] Act#1 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
									SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}

						Trigger { -- Y -> CRet[1] Act#2 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x17C,1,0);
									CallLabelAlways(Source[1],Source[2],Source[3]);
									SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					CIfX(PlayerID,CtrigX(Dest[1],Dest[2],0x15C,Dest[3],AtLeast,0x80000000))
						Trigger { -- X -> CRet[2] (-2)
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,Add,1); -- Sflag
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
								},
								flag = {Preserved}
							}
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { -- X -> CRet[2] (-1)
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
								},
								flag = {Preserved}
							}
					CIfXEnd()

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,(Bit+4)+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,(Bit+4)+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {PlayerID},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}


					Trigger { -- local Var2 (1)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (2)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",CRet[1],0x17C,1,0);
								SetCtrig1X("X",FuncAlloc,0x1BC,2,Add,0x970);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						Trigger { -- (3 ~ Bit+3)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc,0x24,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",FuncAlloc,0x15C,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4-i);
							},
							flag = {Preserved}
						}
					end

					PlayerID = PlayerConvert(PlayerID)
					for k, P in pairs(PlayerID) do
						table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,3)) --> Create Local Var
						for i = 2, (Bit+3) do
							table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",CRet[1],0x0,0,0)) -- -> VarX
						end
					end

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (Bit+4 ~ 2*Bit+4)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[3],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[3],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[3],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[3],0);
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF);
							},
							flag = {Preserved}
						}
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
						Trigger { -- X(<0)/0 -> 0x80000000
								players = {PlayerID},
								conditions = {
									Label(0);
									CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,0x0);
								},
								actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0x80000000);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[3],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[3],0);
							},
							flag = {Preserved}
						}
						Trigger { -- X(>=0)/0 -> 0x7FFFFFFF
								players = {PlayerID},
								conditions = {
									Label(0);
									CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,0x0);
								},
								actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0x7FFFFFFF);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					FuncAlloc = FuncAlloc + 1
				else
					Bit = 31
					CIfX(PlayerID,CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000))
						Trigger { 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
									SetCtrig1X("X",FuncAlloc,0x15C+0x20*10,1,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",FuncAlloc,0x17C+0x20*10,1,SetTo,0xFFFFFFFF);
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
									SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}

						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",FuncAlloc,0x15C+0x20*10,1,Add,1);
									SetCtrig1X("X",FuncAlloc,0x17C+0x20*10,1,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
									SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}

						Trigger { 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					CIfX(PlayerID,CtrigX(Dest[1],Dest[2],0x15C,Dest[3],AtLeast,0x80000000))
						Trigger { 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,Add,1); -- Sflag
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
								},
								flag = {Preserved}
							}
					CIfXEnd()
					
					Trigger { --  (-2) /0 처리
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,0x0);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { --  (-1)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x4,2,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,2,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
								SetCtrig1X("X",FuncAlloc,0x15C,2,Add,0x970/2);
								SetCtrig1X("X",FuncAlloc,0x164,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x1A4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x1C4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x164+0x20*12,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184+0x20*12,1,SetTo,0x2,0x2);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x24,1,Bit+3);
								SetCtrigX("X",FuncAlloc,0x17C,1,SetTo,"X",FuncAlloc,0x15C,1,Bit+3);
							},
							flag = {Preserved}
						}

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {PlayerID},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (1)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X",FuncAlloc,0x24,1,Bit+3); -- Switch Action (Default = On)
								SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X",FuncAlloc,0x15C,1,Bit+3); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X","X",0x15C+0x20*10,1,0)), -- Switch Action (Default = Off)
								Disabled(SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X","X",0x17C+0x20*10,1,0)), -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1A4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1C4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,0,Subtract,0x970/8);
								SetCtrig1X("X","X",0x17C,0,Subtract,0x970/8);
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,0)); -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,1,Subtract,0x970/2);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var2 (2)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",FuncAlloc,0x15C+0x20*10,1,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (3 ~ Bit+3)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- Bit + 4
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,-2,SetTo,"X",FuncAlloc,0x0,0,-1);
							},
							flag = {Preserved}
						}

					CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[1],0);
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF);
							},
							flag = {Preserved}
						}
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
						Trigger { -- X(<0)/0 -> 0x80000000
								players = {PlayerID},
								conditions = {
									Label(0);
									CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,0x0);
								},
								actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0x80000000);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[1],0);
							},
							flag = {Preserved}
						}
						Trigger { -- X(>=0)/0 -> 0x7FFFFFFF
								players = {PlayerID},
								conditions = {
									Label(0);
									CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,0x0);
								},
								actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0x7FFFFFFF);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					FuncAlloc = FuncAlloc + 1
				end
			else
				CiDiv_InputData_Error()
			end

		else 
			if type(Source) == "number" then -- iDiv Mem, 1 : Mem /= 1 / Read필요
				CiDiv_InputData_Error()
			elseif Source[4] == "V" then -- Add Mem, X : Mem /= X / Read필요
				CiDiv_InputData_Error()
			else
				CiDiv_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Divisor) == "table" and Divisor[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Divisor)
			Divisor = TempRet
		end
		if type(Divisor) == "table" and Divisor[4] == "A" then
			CiDiv_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CiDiv_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CiDiv_InputData_Error()
		end
		if type(Source) == "number" then -- iDiv V, 0x58A364, 1 : V << 0x58A364 / 1 / Read필요
			if type(Divisor) == "number" then
				CiDiv_InputData_Error()
			elseif Divisor[4] == "V" then -- iDiv V, 0x58A364, X : V << 0x58A364 / X / Read필요
				CiDiv_InputData_Error()
			else
				CiDiv_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Divisor) == "number" then -- iDiv V, Cp, 1 : V << Cp / 1 / Read필요 
				CiDiv_InputData_Error()
			elseif Divisor[4] == "V" then -- iDiv V, Cp, X : V << Cp / X / Read필요 
				CiDiv_InputData_Error()
			else
				CiDiv_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Divisor) == "number" then -- iDiv V, X, 1 : V << X / 1
				CIfX(PlayerID,CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000))
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
							},
							flag = {Preserved}
						}
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
							},
							flag = {Preserved}
						}
				CElseX()
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
							},
							flag = {Preserved}
						}
				CIfXEnd()

				if bit32.band(Divisor,0xFFFFFFFF) >= 0x80000000 then
					Divisor = 0 - Divisor
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,Add,1); -- Sflag
							},
							flag = {Preserved}
						}
				end
				local Block = 0
				for i = 0, Bit do
					local CBit = 2^i
					if  bit32.band(Divisor*CBit,0xFFFFFFFF) >= 0x80000000 then
						Block = i
						break
					end
				end
				for i = Block, 0, -1 do
					local CBit = 2^i
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
									CtrigX("X",CRet[2],0x15C,0,AtLeast,Divisor*CBit);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Subtract,Divisor*CBit);
									SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
								},
								flag = {Preserved}
							}
				end
				CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF,Mask);
								SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[1],0);
							},
							flag = {Preserved}
						}
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
				CElseX()
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[1],0);
							},
							flag = {Preserved}
						}
				CIfXEnd()
			elseif Divisor[4] == "V" then -- iDiv V, X, Y : V << X / Y
				if BitLimit ~= nil and BitLimit ~= "X" then
					CIfX(PlayerID,CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],AtLeast,0x80000000))
						Trigger { -- Y -> CRet[1] Act#1 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
									SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0xFFFFFFFF);
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x15C,1,0);
									SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,Subtract*16777216,0xFF000000);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}

						Trigger { -- Y -> CRet[1] Act#2 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x17C,1,0);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
									SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
									SetCtrig1X("X",CRet[1],0x17C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { -- Y -> CRet[1] Act#1 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x15C,1,0);
									SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}

						Trigger { -- Y -> CRet[1] Act#2 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x17C,1,0);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
									SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					CIfX(PlayerID,CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000))
						Trigger { -- X -> CRet[2] (-2)
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,Add,1); -- Sflag
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
								},
								flag = {Preserved}
							}
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { -- X -> CRet[2] (-1)
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
								},
								flag = {Preserved}
							}
					CIfXEnd()

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,(Bit+4)+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,(Bit+4)+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {PlayerID},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}


					Trigger { -- local Var2 (1)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (2)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",CRet[1],0x17C,1,0);
								SetCtrig1X("X",FuncAlloc,0x1BC,2,Add,0x970);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						Trigger { -- (3 ~ Bit+3)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc,0x24,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",FuncAlloc,0x15C,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4-i);
							},
							flag = {Preserved}
						}
					end

					PlayerID = PlayerConvert(PlayerID)
					for k, P in pairs(PlayerID) do
						table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,3)) --> Create Local Var
						for i = 2, (Bit+3) do
							table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",CRet[1],0x0,0,0)) -- -> VarX
						end
					end

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (Bit+4 ~ 2*Bit+4)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[3],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[3],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[3],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[3],0);
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF);
							},
							flag = {Preserved}
						}
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
					Trigger { -- X(<0)/0 -> 0x80000000
								players = {PlayerID},
								conditions = {
									Label(0);
									CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],Exactly,0x0);
								},
								actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0x80000000);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[3],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[3],0);
							},
							flag = {Preserved}
						}
						Trigger { -- X(>=0)/0 -> 0x7FFFFFFF
								players = {PlayerID},
								conditions = {
									Label(0);
									CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],Exactly,0x0);
								},
								actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0x7FFFFFFF);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					FuncAlloc = FuncAlloc + 1
				else
					Bit = 31
					CIfX(PlayerID,CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],AtLeast,0x80000000))
						Trigger { 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
									SetCtrig1X("X",FuncAlloc,0x15C+0x20*10,1,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",FuncAlloc,0x17C+0x20*10,1,SetTo,0xFFFFFFFF);
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
									SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,Subtract*16777216,0xFF000000);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}

						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",FuncAlloc,0x15C+0x20*10,1,Add,1);
									SetCtrig1X("X",FuncAlloc,0x17C+0x20*10,1,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
									SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}

						Trigger { 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					CIfX(PlayerID,CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000))
						Trigger { 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,Add,1); -- Sflag
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}
					CIfXEnd()
					
					Trigger { --  (-2) /0 처리
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],Exactly,0x0);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { --  (-1)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x4,2,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,2,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
								SetCtrig1X("X",FuncAlloc,0x15C,2,Add,0x970/2);
								SetCtrig1X("X",FuncAlloc,0x164,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x1A4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x1C4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x164+0x20*12,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184+0x20*12,1,SetTo,0x2,0x2);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x24,1,Bit+3);
								SetCtrigX("X",FuncAlloc,0x17C,1,SetTo,"X",FuncAlloc,0x15C,1,Bit+3);
							},
							flag = {Preserved}
						}

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {PlayerID},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (1)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X",FuncAlloc,0x24,1,Bit+3); -- Switch Action (Default = On)
								SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X",FuncAlloc,0x15C,1,Bit+3); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X","X",0x15C+0x20*10,1,0)), -- Switch Action (Default = Off)
								Disabled(SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X","X",0x17C+0x20*10,1,0)), -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1A4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1C4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,0,Subtract,0x970/8);
								SetCtrig1X("X","X",0x17C,0,Subtract,0x970/8);
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,0)); -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,1,Subtract,0x970/2);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var2 (2)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",FuncAlloc,0x15C+0x20*10,1,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (3 ~ Bit+3)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- Bit + 4
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,-2,SetTo,"X",FuncAlloc,0x0,0,-1);
							},
							flag = {Preserved}
						}

					CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[1],0);
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF);
							},
							flag = {Preserved}
						}
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
						Trigger { -- X(<0)/0 -> 0x80000000
								players = {PlayerID},
								conditions = {
									Label(0);
									CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],Exactly,0x0);
								},
								actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0x80000000);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[1],0);
							},
							flag = {Preserved}
						}
						Trigger { -- X(>=0)/0 -> 0x7FFFFFFF
								players = {PlayerID},
								conditions = {
									Label(0);
									CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],Exactly,0x0);
								},
								actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0x7FFFFFFF);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					FuncAlloc = FuncAlloc + 1
				end
			else
				CiDiv_InputData_Error()
			end

		else 
			if type(Divisor) == "number" then -- iDiv V, Mem, 1 : V << Mem v1 / Read필요
				CiDiv_InputData_Error()
			elseif Divisor[4] == "V" then -- iDiv V, Mem, X : V << Mem / X / Read필요
				CiDiv_InputData_Error()
			else
				CiDiv_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CiDiv_InputData_Error()
	end
end

function CiMod(PlayerID,Dest,Source,Divisor,Mask,BitLimit) -- CMod의 Signed 연산 | 10%-3 = 1 / -10%3 = -1 / -10%-3 = -1 (C++방식)
	STPopTrigArr(PlayerID)

	if Divisor == "X" then
		Divisor = nil
	end

	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local  Bit = 0
	if BitLimit == nil or BitLimit == "X" then
		Bit = 31
	else
		while 2^Bit <= BitLimit and Bit <= 31 do
			Bit = Bit + 1
		end
		Bit = Bit - 1
	end
	
	if Divisor == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CiMod_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CiMod_InputData_Error()
		end
		if type(Dest) == "number" then -- iMod 0x58A364, 1 : 0x58A364 %= 1 / Read필요
			if type(Source) == "number" then
				CiMod_InputData_Error()
			elseif Source[4] == "V" then -- iMod 0x58A364, X : 0x58A364 %= X / Read필요
				CiMod_InputData_Error()
			else
				CiMod_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- iMod Cp, 1 : Cp %= 1 / Read필요
				CiMod_InputData_Error()
			elseif Source[4] == "V" then -- iMod Cp, X : Cp %= X / Read필요
				CiMod_InputData_Error()
			else
				CiMod_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- iMod X, 1 : X %= 1
				CIfX(PlayerID,CtrigX(Dest[1],Dest[2],0x15C,Dest[3],AtLeast,0x80000000))
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
							},
							flag = {Preserved}
						}
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
							},
							flag = {Preserved}
						}
				CElseX()
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
							},
							flag = {Preserved}
						}
				CIfXEnd()

				if bit32.band(Source,0xFFFFFFFF) >= 0x80000000 then
					Source = 0 - Source
				end
				
				local Block = 0
				for i = 0, Bit do
					local CBit = 2^i
					if  bit32.band(Source*CBit,0xFFFFFFFF) >= 0x80000000 then
						Block = i
						break
					end
				end
				for i = Block, 0, -1 do
					local CBit = 2^i
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
									CtrigX("X",CRet[2],0x15C,0,AtLeast,Source*CBit);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Subtract,Source*CBit);
									SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
								},
								flag = {Preserved}
							}
				end
				CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF,Mask);
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
				CElseX()
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}
				CIfXEnd()

			elseif Source[4] == "V" then -- iMod X, Y : X %= Y
				if BitLimit ~= nil and BitLimit ~= "X" then
					CIfX(PlayerID,CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000))
						Trigger { -- Y -> CRet[1] Act#1 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0xFFFFFFFF);
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
									SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}

						Trigger { -- Y -> CRet[1] Act#2 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x17C,1,0);
									CallLabelAlways(Source[1],Source[2],Source[3]);
									SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
									SetCtrig1X("X",CRet[1],0x17C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { -- Y -> CRet[1] Act#1 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
									SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}

						Trigger { -- Y -> CRet[1] Act#2 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x17C,1,0);
									CallLabelAlways(Source[1],Source[2],Source[3]);
									SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					CIfX(PlayerID,CtrigX(Dest[1],Dest[2],0x15C,Dest[3],AtLeast,0x80000000))
						Trigger { -- X -> CRet[2] (-2)
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
								},
								flag = {Preserved}
							}
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { -- X -> CRet[2] (-1)
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
								},
								flag = {Preserved}
							}
					CIfXEnd()

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,(Bit+4)+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,(Bit+4)+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {PlayerID},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}


					Trigger { -- local Var2 (1)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (2)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",CRet[1],0x17C,1,0);
								SetCtrig1X("X",FuncAlloc,0x1BC,2,Add,0x970);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						Trigger { -- (3 ~ Bit+3)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc,0x24,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",FuncAlloc,0x15C,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4-i);
							},
							flag = {Preserved}
						}
					end

					PlayerID = PlayerConvert(PlayerID)
					for k, P in pairs(PlayerID) do
						table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,3)) --> Create Local Var
						for i = 2, (Bit+3) do
							table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",CRet[1],0x0,0,0)) -- -> VarX
						end
					end

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (Bit+4 ~ 2*Bit+4)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[3],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF);
							},
							flag = {Preserved}
						}
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
					CElseX()
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}
					CIfXEnd()

					FuncAlloc = FuncAlloc + 1
				else
					Bit = 31
					CIfX(PlayerID,CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000))
						Trigger { 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",FuncAlloc,0x15C+0x20*10,1,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",FuncAlloc,0x17C+0x20*10,1,SetTo,0xFFFFFFFF);
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
									SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}

						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",FuncAlloc,0x15C+0x20*10,1,Add,1);
									SetCtrig1X("X",FuncAlloc,0x17C+0x20*10,1,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
									SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}

						Trigger { 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
									CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					CIfX(PlayerID,{CtrigX(Dest[1],Dest[2],0x15C,Dest[3],AtLeast,0x80000000),CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x1)})
						Trigger { 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
								SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Dest[1],Dest[2],Dest[3]);
								},
								flag = {Preserved}
							}
					CIfXEnd()
					
					Trigger { --  (-2) /0 처리
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,0x0);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { --  (-1)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x4,2,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,2,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
								SetCtrig1X("X",FuncAlloc,0x15C,2,Add,0x970/2);
								SetCtrig1X("X",FuncAlloc,0x164,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x1A4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x1C4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x164+0x20*12,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184+0x20*12,1,SetTo,0x2,0x2);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x24,1,Bit+3);
								SetCtrigX("X",FuncAlloc,0x17C,1,SetTo,"X",FuncAlloc,0x15C,1,Bit+3);
							},
							flag = {Preserved}
						}

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {PlayerID},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (1)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X",FuncAlloc,0x24,1,Bit+3); -- Switch Action (Default = On)
								SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X",FuncAlloc,0x15C,1,Bit+3); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X","X",0x15C+0x20*10,1,0)), -- Switch Action (Default = Off)
								Disabled(SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X","X",0x17C+0x20*10,1,0)), -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1A4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1C4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,0,Subtract,0x970/8);
								SetCtrig1X("X","X",0x17C,0,Subtract,0x970/8);
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,0)); -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,1,Subtract,0x970/2);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var2 (2)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",FuncAlloc,0x15C+0x20*10,1,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (3 ~ Bit+3)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- Bit + 4
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,-2,SetTo,"X",FuncAlloc,0x0,0,-1);
							},
							flag = {Preserved}
						}

					CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF);
							},
							flag = {Preserved}
						}
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
					CElseX()
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}
					CIfXEnd()

					FuncAlloc = FuncAlloc + 1
				end
			else
				CiMod_InputData_Error()
			end

		else 
			if type(Source) == "number" then -- iMod Mem, 1 : Mem %= 1 / Read필요
				CiMod_InputData_Error()
			elseif Source[4] == "V" then -- Add Mem, X : Mem %= X / Read필요
				CiMod_InputData_Error()
			else
				CiMod_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Divisor) == "table" and Divisor[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Divisor)
			Divisor = TempRet
		end
		if type(Divisor) == "table" and Divisor[4] == "A" then
			CiMod_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CiMod_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CiMod_InputData_Error()
		end
		if type(Source) == "number" then -- iMod V, 0x58A364, 1 : V << 0x58A364 % 1 / Read필요
			if type(Divisor) == "number" then
				CiMod_InputData_Error()
			elseif Divisor[4] == "V" then -- iMod V, 0x58A364, X : V << 0x58A364 % X / Read필요
				CiMod_InputData_Error()
			else
				CiMod_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Divisor) == "number" then -- iMod V, Cp, 1 : V << Cp % 1 / Read필요 
				CiMod_InputData_Error()
			elseif Divisor[4] == "V" then -- iMod V, Cp, X : V << Cp % X / Read필요 
				CiMod_InputData_Error()
			else
				CiMod_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Divisor) == "number" then -- iMod V, X, 1 : V << X % 1
				CIfX(PlayerID,CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000))
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
							},
							flag = {Preserved}
						}
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
							},
							flag = {Preserved}
						}
				CElseX()
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
							},
							flag = {Preserved}
						}
				CIfXEnd()

				if bit32.band(Divisor,0xFFFFFFFF) >= 0x80000000 then
					Divisor = 0 - Divisor
				end
				local Block = 0
				for i = 0, Bit do
					local CBit = 2^i
					if  bit32.band(Divisor*CBit,0xFFFFFFFF) >= 0x80000000 then
						Block = i
						break
					end
				end
				for i = Block, 0, -1 do
					local CBit = 2^i
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
									CtrigX("X",CRet[2],0x15C,0,AtLeast,Divisor*CBit);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Subtract,Divisor*CBit);
									SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
								},
								flag = {Preserved}
							}
				end
				CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF,Mask);
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
				CElseX()
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}
				CIfXEnd()

			elseif Divisor[4] == "V" then -- iMod V, X, Y : V << X % Y
				if BitLimit ~= nil and BitLimit ~= "X" then
					CIfX(PlayerID,CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],AtLeast,0x80000000))
						Trigger { -- Y -> CRet[1] Act#1 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0xFFFFFFFF);
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x15C,1,0);
									SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,Subtract*16777216,0xFF000000);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}

						Trigger { -- Y -> CRet[1] Act#2 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x17C,1,0);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
									SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
									SetCtrig1X("X",CRet[1],0x17C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { -- Y -> CRet[1] Act#1 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x15C,1,0);
									SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}

						Trigger { -- Y -> CRet[1] Act#2 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x17C,1,0);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
									SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x168,0,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",CRet[1],0x180,0,SetTo,Add*16777216,0xFF000000);
									SetCtrig1X("X",CRet[1],0x184,0,SetTo,0,0x2);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					CIfX(PlayerID,CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000))
						Trigger { -- X -> CRet[2] (-2)
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
								},
								flag = {Preserved}
							}
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger { -- X -> CRet[2] (-1)
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x1BC,2,SetTo,"X",FuncAlloc,0x0,0,3); -- Init Var1 Act#4 Value
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2); --  Init Var2 -> Var1
								},
								flag = {Preserved}
							}
					CIfXEnd()

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,(Bit+4)+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,(Bit+4)+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {PlayerID},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}


					Trigger { -- local Var2 (1)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (2)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",CRet[1],0x17C,1,0);
								SetCtrig1X("X",FuncAlloc,0x1BC,2,Add,0x970);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						Trigger { -- (3 ~ Bit+3)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc,0x24,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x178,0,SetTo,"X",FuncAlloc,0x15C,1,2*Bit+4-i);
								SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x0,0,2*Bit+4-i);
							},
							flag = {Preserved}
						}
					end

					PlayerID = PlayerConvert(PlayerID)
					for k, P in pairs(PlayerID) do
						table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,3)) --> Create Local Var
						for i = 2, (Bit+3) do
							table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i,SetTo,"X",CRet[1],0x0,0,0)) -- -> VarX
						end
					end

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (Bit+4 ~ 2*Bit+4)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[3],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF);
							},
							flag = {Preserved}
						}
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
					CElseX()
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x178,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x17C,0,SetTo,0x0);
								SetCtrig1X("X",CRet[1],0x180,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",CRet[1],0x184,0,SetTo,0x2,0x2);
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}
					CIfXEnd()

					FuncAlloc = FuncAlloc + 1
				else
					Bit = 31
					CIfX(PlayerID,CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],AtLeast,0x80000000))
						Trigger { 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",FuncAlloc,0x15C+0x20*10,1,SetTo,0xFFFFFFFF);
									SetCtrig1X("X",FuncAlloc,0x17C+0x20*10,1,SetTo,0xFFFFFFFF);
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
									SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,Subtract*16777216,0xFF000000);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}

						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",FuncAlloc,0x15C+0x20*10,1,Add,1);
									SetCtrig1X("X",FuncAlloc,0x17C+0x20*10,1,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x15C+0x20*10,1,1);
									SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
									SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}

						Trigger { 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",FuncAlloc,0x17C+0x20*10,1,1);
									CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
								},
								flag = {Preserved}
							}
					CIfXEnd()

					CIfX(PlayerID,{CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000),CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],AtLeast,1)})
						Trigger { 
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,1); -- Sflag
								SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrig1X("X",CRet[2],0x15C,0,Add,1);
								},
								flag = {Preserved}
							}
					CElseX()
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
								SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0); -- Sflag
								SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
								SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
								SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways(Source[1],Source[2],Source[3]);
								},
								flag = {Preserved}
							}
					CIfXEnd()
					
					Trigger { --  (-2) /0 처리
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX(Divisor[1],Divisor[2],0x15C,Divisor[3],Exactly,0x0);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+4);
							},
							flag = {Preserved}
						}

					Trigger { --  (-1)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0); -- Clear Ret
								SetCtrigX("X",FuncAlloc,0x4,2,SetTo,"X",FuncAlloc,0x0,0,1);
								SetCtrigX("X",FuncAlloc,0x15C,2,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
								SetCtrig1X("X",FuncAlloc,0x15C,2,Add,0x970/2);
								SetCtrig1X("X",FuncAlloc,0x164,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x1A4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x1C4,1,SetTo,0x2,0x2);
								SetCtrig1X("X",FuncAlloc,0x164+0x20*12,1,SetTo,0x0,0x2);
								SetCtrig1X("X",FuncAlloc,0x184+0x20*12,1,SetTo,0x2,0x2);
								SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,"X",FuncAlloc,0x24,1,Bit+3);
								SetCtrigX("X",FuncAlloc,0x17C,1,SetTo,"X",FuncAlloc,0x15C,1,Bit+3);
							},
							flag = {Preserved}
						}

					local ClearValue = {}
					for i = 0, Bit do
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x24,3+i,SetTo,0))
						table.insert(ClearValue,SetCtrig1X("X",FuncAlloc,0x15C,3+i,SetTo,0))
					end

					Trigger { -- Clear Value 
							players = {PlayerID},
							conditions = {
								Label(FuncAlloc);
							},
							actions = {
								ClearValue,
							},
							flag = {Preserved}
						}

					Trigger { -- local Var1 (1)
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X",FuncAlloc,0x24,1,Bit+3); -- Switch Action (Default = On)
								SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X",FuncAlloc,0x15C,1,Bit+3); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x158+0x20*10,0,SetTo,"X","X",0x15C+0x20*10,1,0)), -- Switch Action (Default = Off)
								Disabled(SetCtrigX("X","X",0x178+0x20*10,0,SetTo,"X","X",0x17C+0x20*10,1,0)), -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1A4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x1C4,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,0,Subtract,0x970/8);
								SetCtrig1X("X","X",0x17C,0,Subtract,0x970/8);
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetMemoryX(0,Add,0,0xFFFFFFFF); -- Temp Variable
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1); -- Switch Action (Default = On)
								Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,0)); -- Switch Action (Default = Off)
								SetCtrig1X("X","X",0x164+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x184+0x20*12,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
								SetCtrig1X("X","X",0x15C,1,Subtract,0x970/2);
							},
							flag = {Preserved}
						}

					Trigger { -- local Var2 (2)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",FuncAlloc,0x15C+0x20*10,1,AtLeast,0x80000000);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,Bit+3);
							},
							flag = {Preserved}
						}

					for i = 0, Bit do
						local CBit = 2^(Bit-i)
						Trigger { -- (3 ~ Bit+3)
							players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX("X",CRet[2],0x15C,0,AtLeast,0);
							},
							actions = {
								SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0);
								SetCtrig1X("X",CRet[1],0x15C,0,Add,CBit);
							},
							flag = {Preserved}
						}
					end

					Trigger { -- Bit + 4
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",FuncAlloc,0x4,-2,SetTo,"X",FuncAlloc,0x0,0,-1);
							},
							flag = {Preserved}
						}

					CIfX(PlayerID,CtrigX("X",CRet[5],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF);
							},
							flag = {Preserved}
						}
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,1);
							},
							flag = {Preserved}
						}
					CElseX()
						Trigger { 
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
								SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",CRet[2],0);
							},
							flag = {Preserved}
						}
					CIfXEnd()

					FuncAlloc = FuncAlloc + 1
				end
			else
				CiMod_InputData_Error()
			end

		else 
			if type(Divisor) == "number" then -- iMod V, Mem, 1 : V << Mem % 1 / Read필요
				CiMod_InputData_Error()
			elseif Divisor[4] == "V" then -- iMod V, Mem, X : V << Mem % X / Read필요
				CiMod_InputData_Error()
			else
				CiMod_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CiMod_InputData_Error()
	end
end

function CNot(PlayerID,Dest,Source,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if Source == nil then
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
			MovX(PlayerID,Dest,PDest)
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CNot_InputData_Error()
		end

		if type(Dest) == "number" then -- Not 0x58A364 / Read필요
			CNot_InputData_Error()
		elseif Dest == "Cp" then -- Not Cp / Read필요
			CNot_InputData_Error()
		elseif Dest[4] == "V" then -- Not X : X << ~X
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Subtract*16777216,0xFF000000);
					SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);

					SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);

					CallLabelAlways2(Dest[1],Dest[2],Dest[3],"X",CRet[1],0);
				},
				flag = {Preserved}
			}
		else -- Neg Mem / Read필요
			CNot_InputData_Error()
		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CNot_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CNot_InputData_Error()
		end
		if type(Dest) == "number" then
			CNot_InputData_Error()
		elseif Dest == "Cp" then
			CNot_InputData_Error()
		elseif Dest[4] == "V" then
			if type(Source) == "number" then
				CNot_InputData_Error()
			elseif Source[4] == "V" then -- Not V, X : V << ~X
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Mask);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				CNot_InputData_Error()
			end
		else
			CNot_InputData_Error()
		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CNot_InputData_Error()
	end
end

function COr(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if Operand == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			COr_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			COr_InputData_Error()
		end
		if type(Dest) == "number" then -- Or 0x58A364, 1 : 0x58A364 |= 1
			if type(Source) == "number" then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetMemoryX(Dest,SetTo,0xFFFFFFFF,Source);
					},
					flag = {Preserved}
				}
			elseif Source[4] == "V" then -- Or 0x58A364, X : 0x58A364 |= X
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x148,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(Dest));

						CallLabelAlways2(Source[1],Source[2],Source[3],"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				COr_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- Or Cp, 1 : Cp |= 1
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeathsX(CurrentPlayer,SetTo,0xFFFFFFFF,0,Source);
					},
					flag = {Preserved}
				}
			elseif Source[4] == "V" then -- Or Cp, X : Cp |= X
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x148,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",CRet[1],0x158,0,SetTo,13);

						CallLabelAlways2(Source[1],Source[2],Source[3],"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				COr_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- Or X, 1 : X |= 1
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF,Source);
					},
					flag = {Preserved}
				}
			elseif Source[4] == "V" then -- Or X, Y : X |= Y
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x148,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);

						CallLabelAlways2(Source[1],Source[2],Source[3],"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				COr_InputData_Error()
			end

		else 
			if type(Source) == "number" then -- Or Mem, 1 : Mem |= 1
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,0xFFFFFFFF,Source);
					},
					flag = {Preserved}
				}
			elseif Source[4] == "V" then -- Or Mem, X : Mem |= X
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x148,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);

						CallLabelAlways2(Source[1],Source[2],Source[3],"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				COr_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Operand) == "table" and Operand[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Operand)
			Operand = TempRet
		end
		if type(Operand) == "table" and Operand[4] == "A" then
			COr_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			COr_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			COr_InputData_Error()
		end

		if type(Source) == "number" then -- Or V, 0x58A364, 1 : V << 0x58A364 | 1 / Read필요
			if type(Operand) == "number" then
				COr_InputData_Error()
			elseif Operand[4] == "V" then -- Or V, 0x58A364, X : V << 0x58A364 | X / Read필요
				COr_InputData_Error()
			else
				COr_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Operand) == "number" then -- Or V, Cp, 1 : V << Cp | 1 / Read필요 
				COr_InputData_Error()
			elseif Operand[4] == "V" then -- Or V, Cp, X : V << Cp | X / Read필요 
				COr_InputData_Error()
			else
				COr_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Operand) == "number" then -- Or V, X, 1 : V << X | 1
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF,Operand);
					},
					flag = {Preserved}
				}
			elseif Operand[4] == "V" then -- Or V, X, Y : V << X | Y
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",CRet[1],0x148,1,0);
						SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);

						CallLabelAlways3(Source[1],Source[2],Source[3],Operand[1],Operand[2],Operand[3],"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				COr_InputData_Error()
			end

		else 
			if type(Operand) == "number" then -- Or V, Mem, 1 : V << Mem | 1 / Read필요
				COr_InputData_Error()
			elseif Operand[4] == "V" then -- Or V, Mem, X : V << Mem | X / Read필요
				COr_InputData_Error()
			else
				COr_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		COr_InputData_Error()
	end
end

function CAnd(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if Operand == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CAnd_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CAnd_InputData_Error()
		end
		if type(Dest) == "number" then -- And 0x58A364, 1 : 0x58A364 &= 1
			if type(Source) == "number" then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetMemoryX(Dest,SetTo,0,(0xFFFFFFFF-Source));
					},
					flag = {Preserved}
				}
			elseif Source[4] == "V" then -- And 0x58A364, X : 0x58A364 &= X
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x148,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);

						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(Dest));

						CallLabelAlways2(Source[1],Source[2],Source[3],"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				CAnd_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- And Cp, 1 : Cp &= 1
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeathsX(CurrentPlayer,SetTo,0,0,(0xFFFFFFFF-Source));
					},
					flag = {Preserved}
				}
			elseif Source[4] == "V" then -- And Cp, X : Cp &= X
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x148,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);

						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",CRet[1],0x158,0,SetTo,13);

						CallLabelAlways2(Source[1],Source[2],Source[3],"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				CAnd_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- And X, 1 : X &= 1
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0,(0xFFFFFFFF-Source));
					},
					flag = {Preserved}
				}
			elseif Source[4] == "V" then -- And X, Y : X &= Y
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x148,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);

						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);

						CallLabelAlways2(Source[1],Source[2],Source[3],"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				CAnd_InputData_Error()
			end

		else 
			if type(Source) == "number" then -- And Mem, 1 : Mem &= 1
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,0,(0xFFFFFFFF-Source));
					},
					flag = {Preserved}
				}
			elseif Source[4] == "V" then -- And Mem, X : Mem &= X
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x148,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);

						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);

						CallLabelAlways2(Source[1],Source[2],Source[3],"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				CAnd_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Operand) == "table" and Operand[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Operand)
			Operand = TempRet
		end
		if type(Operand) == "table" and Operand[4] == "A" then
			CAnd_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CAnd_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CAnd_InputData_Error()
		end

		if type(Source) == "number" then -- And V, 0x58A364, 1 : V << 0x58A364 & 1 / Read필요
			if type(Operand) == "number" then
				CAnd_InputData_Error()
			elseif Operand[4] == "V" then -- And V, 0x58A364, X : V << 0x58A364 & X / Read필요
				CAnd_InputData_Error()
			else
				CAnd_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Operand) == "number" then -- And V, Cp, 1 : V << Cp & 1 / Read필요 
				CAnd_InputData_Error()
			elseif Operand[4] == "V" then -- And V, Cp, X : V << Cp & X / Read필요 
				CAnd_InputData_Error()
			else
				CAnd_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Operand) == "number" then -- And V, X, 1 : V << X & 1
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0,(0xFFFFFFFF-Operand));
					},
					flag = {Preserved}
				}
			elseif Operand[4] == "V" then -- And V, X, Y : V << X & Y
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",CRet[1],0x148,1,0);
						SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,Subtract*16777216,0xFF000000);

						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);

						CallLabelAlways3(Source[1],Source[2],Source[3],Operand[1],Operand[2],Operand[3],"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				CAnd_InputData_Error()
			end

		else 
			if type(Operand) == "number" then -- And V, Mem, 1 : V << Mem & 1 / Read필요
				CAnd_InputData_Error()
			elseif Operand[4] == "V" then -- And V, Mem, X : V << Mem & X / Read필요
				CAnd_InputData_Error()
			else
				CAnd_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CAnd_InputData_Error()
	end
end

function CXor(PlayerID,Dest,Source,Operand,Mask)
		STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	if Operand == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CXor_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CXor_InputData_Error()
		end
		if type(Dest) == "number" then -- Xor 0x58A364, 1 : 0x58A364 ^= 1 / Read필요
			if type(Source) == "number" then
				CXor_InputData_Error()
			elseif Source[4] == "V" then -- Xor 0x58A364, X : 0x58A364 ^= X / Read필요
				CXor_InputData_Error()
			else
				CXor_InputData_Error()
			end

		elseif Dest == "Cp" then
			if type(Source) == "number" then -- Xor Cp, 1 : Cp ^= 1 / Read필요
				CXor_InputData_Error()
			elseif Source[4] == "V" then -- Xor Cp, X : Cp ^= X / Read필요
				CXor_InputData_Error()
			else
				CXor_InputData_Error()
			end

		elseif Dest[4] == "V" then
			if type(Source) == "number" then -- Xor X, 1 : X ^= 1
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF,Source);
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0,(0xFFFFFFFF-Source));
						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
			elseif Source[4] == "V" then -- Xor X, Y : X ^= Y
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x148,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);

						CallLabelAlways3(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3],"X",CRet[2],0);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x148,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Subtract*16777216,0xFF000000);

						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
						SetCtrigX("X",CRet[2],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);

						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);

						CallLabelAlways3(Source[1],Source[2],Source[3],"X",CRet[2],0,"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				CXor_InputData_Error()
			end

		else 
			if type(Source) == "number" then -- Xor Mem, 1 : Mem ^= 1 / Read필요
				CXor_InputData_Error()
			elseif Source[4] == "V" then -- Xor Mem, X : Mem ^= X / Read필요
				CXor_InputData_Error()
			else
				CXor_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Operand) == "table" and Operand[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Operand)
			Operand = TempRet
		end
		if type(Operand) == "table" and Operand[4] == "A" then
			CXor_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CXor_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			CXor_InputData_Error()
		end
		if type(Source) == "number" then -- Xor V, 0x58A364, 1 : V << 0x58A364 ^ 1 / Read필요
			if type(Operand) == "number" then
				CXor_InputData_Error()
			elseif Operand[4] == "V" then -- Xor V, 0x58A364, X : V << 0x58A364 ^ X / Read필요
				CXor_InputData_Error()
			else
				CXor_InputData_Error()
			end

		elseif Source == "Cp" then
			if type(Operand) == "number" then -- Xor V, Cp, 1 : V << Cp ^ 1 / Read필요 
				CXor_InputData_Error()
			elseif Operand[4] == "V" then -- Xor V, Cp, X : V << Cp ^ X / Read필요 
				CXor_InputData_Error()
			else
				CXor_InputData_Error()
			end

		elseif Source[4] == "V" then
			if type(Operand) == "number" then -- Xor V, X, 1 : V << X ^ 1
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0xFFFFFFFF,Operand);
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0,(0xFFFFFFFF-Operand));
						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,Mask);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
			elseif Operand[4] == "V" then -- Xor V, X, Y : V << X ^ Y
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",CRet[2],0x148,1,0);
						SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);

						CallLabelAlways3(Source[1],Source[2],Source[3],Operand[1],Operand[2],Operand[3],"X",CRet[2],0);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",CRet[2],0x148,1,0);
						SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,Subtract*16777216,0xFF000000);

						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
						SetCtrigX("X",CRet[2],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);

						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,Mask);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);

						CallLabelAlways3(Operand[1],Operand[2],Operand[3],"X",CRet[2],0,"X",CRet[1],0);
					},
					flag = {Preserved}
				}
			else
				CXor_InputData_Error()
			end
		else 
			if type(Operand) == "number" then -- Xor V, Mem, 1 : V << Mem ^ 1 / Read필요
				CXor_InputData_Error()
			elseif Operand[4] == "V" then -- Xor V, Mem, X : V << Mem ^ X / Read필요
				CXor_InputData_Error()
			else
				CXor_InputData_Error()
			end

		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CXor_InputData_Error()
	end
end		


-- 함수 호출형 함수 정의 선언 (Include) -------------------------------------------------

function Include_CtrigPlib(Cycle,SeedSwitch)
	if CheckInclude_CtrigPlib == 0 then
		CheckInclude_CtrigPlib = 1
		Include_DataTransfer()
		Include_ArithMetic()
		Include_MatheMatics(Cycle)
		Include_MiscFunctions(SeedSwitch)
	end
end
FSHReadCall1 = 0
FSHReadCall2 = 0
FSHReadCheck = 0
FCUReadCall1 = 0
FCUReadCall2 = 0
FReadCall1 = 0
FEPDCall1 = 0
FReadCall2 = 0
FEPDCall2 = 0
FMEM = {}
FMEMCall0 = 0
FMEMCall1 = 0
FMEMCall2 = 0
FMEMCheck = 0
FMEMAlloc = 0
FMEME = {}
FMEMECall1 = 0
FMEMECall2 = 0
FMEMECheck = 0
FReadXCall0 = 0
FReadXCall1 = 0
FReadXCall2 = 0
FReadXCall3 = 0
FReadXCall4 = 0
FReadXCall5 = 0
FReadXCall6 = 0
FReadXCall7 = 0
FMOVE = {}
FMOVECall0 = 0
FMOVECall1 = 0
FMOVECall2 = 0
FMOVECheck = 0
FMOVEAlloc = 0 
FCONV = {}
FCONVCall0 = 0
FCONVCall1 = 0
FCONVCall2 = 0
FCONVCheck = 0
FCONVAlloc = 0
FBYTE = {}
FBYTECall0 = 0
FBYTECall1 = 0
FBYTECall2 = 0
FBYTECheck = 0
FBYTEAlloc = 0
FCOND = {}
FCONDCall0 = 0
FCONDCall1 = 0
FCONDCall2 = 0
FCONDCall3 = 0
FCONDCheck = 0
FCONDAlloc = 0
FCHAT = {}
FCHATCall1 = 0
FCHATCall2 = 0
FCHATCheck = 0
FCHATAlloc = 0
FMOVEArr = {}
FMEMEArr = {}
FMEMArr1 = {}
FMEMArr2 = {}
FCONVArr = {}
FBYTEArr = {}
FCONDArr = {}
FBWZCall1 = 0
FBWZCall2 = 0
FBWZCheck = 0
FBWXCall1 = 0
FBWXCall2 = 0
FBWXCheck = 0
FWWZCall1 = 0
FWWZCall2 = 0
FWWZCheck = 0
FWWXCall0 = 0
FWWXCall1 = 0
FWWXCall2 = 0
FWWXCheck = 0
FLINECall1 = 0
FLINECall2 = 0
FLINECheck = 0
FDINECall1 = 0
FDINECall2 = 0
FDINECheck = 0
FGINDXCall1 = 0
FGINDXCall2 = 0
FGINDXCheck = 0
FGINDX2Call1 = 0
FGINDX2Call2 = 0
FGINDX2Check = 0
FDISPCall1 = 0
FDISPCall2 = 0
FDISPCheck = 0
FDISPXCall1 = 0
FDISPXCall2 = 0
FDISPXCheck = 0
FSTRLCall1 = 0
FSTRLCall2 = 0
FSTRLCheck = 0
FCHATOCall = 0
FCHATOCheck = 0
FSCANV = {}
FSCANVCall1 = 0
FSCANVCall2 = 0
FSCANVCheck = 0
FSCANW = {}
FSCANWCall1 = 0
FSCANWCall2 = 0
FSCANWCheck = 0
FENCD = {}
FENCDCall1 = 0
FENCDCall2 = 0
FENCDCheck = 0

FBRZCall1 = 0
FBRZCall2 = 0
FBRZCheck = 0
FBRXCall1 = 0
FBRXCall2 = 0
FBRXCheck = 0
FWRZCall1 = 0
FWRZCall2 = 0
FWRZCheck = 0
FWRXCall0 = 0
FWRXCall1 = 0
FWRXCall2 = 0
FWRXCheck = 0
function Include_DataTransfer() -- f_Read / f_EPD / f_Memcpy
	if CheckInclude_DataTransfer == 0 then
		CheckInclude_DataTransfer = 1
	local IncludePlayer = IncludePlayerID

-- f_Read - Ret[1] : Input EPD / Ret[2] = Output / Ret[3] = EPD(Output)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
				SetCtrig1X("X",CRet[3],0x15C,0,SetTo,-1452249);
				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}
	

	for i = 0, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,Add,CBit);
				SetCtrig1X("X",CRet[3],0x15C,0,Add,CBit/4);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	FReadCall1 = FuncAlloc
	FReadCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2
-- f_CunitRead - Ret[1] : Input EPD / Ret[2] = PTROutput / Ret[3] = EPDOutput
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
				SetCtrig1X("X",CRet[3],0x15C,0,SetTo,-1452249);
				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}
	

	for i = 2, 22 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,Add,CBit);
				SetCtrig1X("X",CRet[3],0x15C,0,Add,CBit/4);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	FCUReadCall1 = FuncAlloc
	FCUReadCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_ReadX - Ret[1] : Input EPD / Ret[2] = Output / Ret[3] = EPD(Output)

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}
	Trigger { -- 1
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
			},
			flag = {Preserved}
		}

	FReadXCall0 = FuncAlloc
	FuncAlloc = FuncAlloc + 1
	local XLabel

-- *16777216 (0 -> 3)
	for i = 0, 7 do
		if i == 0  then
			XLabel = FuncAlloc
		else
			XLabel = 0
		end
		local CBit = 2^i
		Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(XLabel);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,Add,CBit*16777216);
				},
				flag = {Preserved}
			}
	end
	FReadXCall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

-- *65536 (01 -> 23)
	for i = 0, 15 do
		if i == 0  then
			XLabel = FuncAlloc
		else
			XLabel = 0
		end
		local CBit = 2^i
		Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(XLabel);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,Add,CBit*65536);
				},
				flag = {Preserved}
			}
	end
	FReadXCall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

-- *256 (012 -> 123)
	for i = 0, 23 do
		if i == 0  then
			XLabel = FuncAlloc
		else
			XLabel = 0
		end
		local CBit = 2^i
		Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(XLabel);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,Add,CBit*256);
				},
				flag = {Preserved}
			}
	end
	FReadXCall3 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

-- 1 (0123 -> 0123)
	for i = 0, 31 do
		if i == 0  then
			XLabel = FuncAlloc
		else
			XLabel = 0
		end
		local CBit = 2^i
		Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(XLabel);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,Add,CBit);
				},
				flag = {Preserved}
			}
	end
	FReadXCall4 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

-- /256 (123 -> 012)
	for i = 8, 31 do
		if i == 8  then
			XLabel = FuncAlloc
		else
			XLabel = 0
		end
		local CBit = 2^i
		Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(XLabel);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,Add,CBit/256);
				},
				flag = {Preserved}
			}
	end
	FReadXCall5 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

-- /65536 (23 -> 01)
	for i = 16, 31 do
		if i == 16  then
			XLabel = FuncAlloc
		else
			XLabel = 0
		end
		local CBit = 2^i
		Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(XLabel);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,Add,CBit/65536);
				},
				flag = {Preserved}
			}
	end
	FReadXCall6 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

-- /16777216 (3 -> 0)
	for i = 24, 31 do
		if i == 24  then
			XLabel = FuncAlloc
		else
			XLabel = 0
		end
		local CBit = 2^i
		Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(XLabel);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,Add,CBit/16777216);
				},
				flag = {Preserved}
			}
	end
	FReadXCall7 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

-- f_EPD - Ret[1] : Input X / Ret[2] = Output | Output = EPD(X)

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,SetTo,-1452249);
			},
			flag = {Preserved}
		}

	for i = 2, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	CtrigX("X",CRet[1],0x15C,0,Exactly,CBit,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[2],0x15C,0,Add,CBit/4);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	FEPDCall1 =	FuncAlloc
	FEPDCall2 =	FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_SHRead - Ret[1] : Input EPD / Ret[2] = Output
	FSHReadCall1 = FuncAlloc
	FSHReadCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2


-- f_BwriteX - Ret[1] : Input Offset / Ret[2] = Value / Ret[3] = EPD / Ret[4] = Value / Ret[5] = Mask
	FBWXCall1 =	FuncAlloc
	FBWXCall2 =	FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_BwriteZ - Ret[1] : Input Value / Ret[2] = Output / Ret[3] = Offset
	FBWZCall1 =	FuncAlloc
	FBWZCall2 =	FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_WwriteX - Ret[1] : Input Offset / Ret[2] = Value / Ret[3] = EPD / Ret[4] = Value / Ret[5] = Mask
	FWWXCall0 =	FuncAlloc
	FWWXCall1 =	FuncAlloc+1
	FWWXCall2 =	FuncAlloc+2
	FuncAlloc = FuncAlloc + 3

-- f_WwriteZ - Ret[1] : Input Value / Ret[2] = Output / Ret[3] = Offset
	FWWZCall1 =	FuncAlloc
	FWWZCall2 =	FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_BreadX - Ret[1] : Input Offset / Ret[2] = Value / Ret[3] = EPD / Ret[4] = Value / Ret[5] = Mask
	FBRXCall1 =	FuncAlloc
	FBRXCall2 =	FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_BreadZ - Ret[1] : Input Value / Ret[2] = Output / Ret[3] = Offset
	FBRZCall1 =	FuncAlloc
	FBRZCall2 =	FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_WreadX - Ret[1] : Input Offset / Ret[2] = Value / Ret[3] = EPD / Ret[4] = Value / Ret[5] = Mask
	FWRXCall0 =	FuncAlloc
	FWRXCall1 =	FuncAlloc+1
	FWRXCall2 =	FuncAlloc+2
	FuncAlloc = FuncAlloc + 3

-- f_WreadZ - Ret[1] : Input Value / Ret[2] = Output / Ret[3] = Offset
	FWRZCall1 =	FuncAlloc
	FWRZCall2 =	FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_Movcpy(EPD) - Ret[1] : Input Dest / Ret[2] : Source Offset / Ret[3] = Size / Ret[4] << Init Mask
	for i = 0, 3 do
		CVariable(IncludePlayer,FuncAlloc+i)
		table.insert(FMOVE,FuncAlloc+i)
	end
	FuncAlloc = FuncAlloc + 4

	FMOVEAlloc = FuncAlloc
	FMOVECall0 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

	FMOVECall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

	table.insert(FMOVEArr,{FuncAlloc,0x15C+0x20*12})
	FuncAlloc = FuncAlloc + 1

	table.insert(FMOVEArr,{FuncAlloc,0x15C+0x20*13})
	table.insert(FMOVEArr,{FuncAlloc,0x15C+0x20*14})
	FuncAlloc = FuncAlloc + 1

	FuncAlloc = FuncAlloc + 1
	
	FuncAlloc = FuncAlloc + 1
	
	FuncAlloc = FuncAlloc + 1
	
	FMOVECall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

-- f_MemcpyEPD - Ret[1] : Input Dest / Ret[2] = Source / Ret[3] = Size / Ret[4] = VAflag
	for i = 0, 3 do
		CVariable(IncludePlayer,FuncAlloc+i)
		table.insert(FMEME,FuncAlloc+i)
	end
	FuncAlloc = FuncAlloc + 4

	FMEMECall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1
		table.insert(FMEMEArr,{FuncAlloc,0x15C+0x20*0})
		table.insert(FMEMEArr,{FuncAlloc,0x15C+0x20*1})
		FuncAlloc = FuncAlloc + 1
	FMEMECall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

-- 	f_byteConvert - [1~4] : DestVA / [5] : Source / [6] : Size / [7] : SourceX
		for i = 0, 6 do
			CVariable(IncludePlayer,FuncAlloc+i)
			table.insert(FCONV,FuncAlloc+i)
		end
		FuncAlloc = FuncAlloc + 7

		FCONVCall0 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

		FCONVCall1 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

		FCONVAlloc = FuncAlloc
			FuncAlloc = FuncAlloc+4
			table.insert(FCONVArr,{FuncAlloc,0x15C})
			FuncAlloc = FuncAlloc+1

			FuncAlloc = FuncAlloc+4
			table.insert(FCONVArr,{FuncAlloc,0x15C})
			FuncAlloc = FuncAlloc+1
			
			FuncAlloc = FuncAlloc+3
			table.insert(FCONVArr,{FuncAlloc,0x15C})
			FuncAlloc = FuncAlloc+1

			FuncAlloc = FuncAlloc+3
			table.insert(FCONVArr,{FuncAlloc,0x15C})
			FuncAlloc = FuncAlloc+4
			
		FCONVCall2 = FuncAlloc
		FuncAlloc = FuncAlloc + 1


-- 	f_byteCpy - [1] : SourceVA Offset / [2] : Dest / [3] : Size / [4] : DestX
		for i = 0, 3 do
			CVariable(IncludePlayer,FuncAlloc+i)
			table.insert(FBYTE,FuncAlloc+i)
		end
		FuncAlloc = FuncAlloc + 4

		FBYTECall0 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

		FBYTECall1 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

		FBYTEAlloc = FuncAlloc

		table.insert(FBYTEArr,{FuncAlloc,0x15C+0x20*10})
		FuncAlloc = FuncAlloc+1

		table.insert(FBYTEArr,{FuncAlloc,0x15C+0x20*10})
		table.insert(FBYTEArr,{FuncAlloc,0x15C+0x20*14})
		FuncAlloc = FuncAlloc+1

		FuncAlloc = FuncAlloc+1

		FBYTECall2 = FuncAlloc
		FuncAlloc = FuncAlloc + 1


-- 	f_bytecmp - [1] : SourceVA Offset / [2] : Dest / [3] : Size / [4] : DestX
		for i = 0, 3 do
			CVariable(IncludePlayer,FuncAlloc+i)
			table.insert(FCOND,FuncAlloc+i)
		end
		FuncAlloc = FuncAlloc + 4

		FCONDCall0 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

		FCONDCall1 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

		FCONDAlloc = FuncAlloc

			table.insert(FCONDArr,{FuncAlloc,0x15C+0x20*1})
			FuncAlloc = FuncAlloc+1

			table.insert(FCONDArr,{FuncAlloc,0x15C+0x20*1})
			table.insert(FCONDArr,{FuncAlloc,0x15C+0x20*2})
			FuncAlloc = FuncAlloc+1

			FuncAlloc = FuncAlloc+1

		FCONDCall2 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

		FCONDCall3 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

		-- f_Encode - Ret[1] : Dest / Ret[2] : Source / Ret[3] : Size / Ret[4] : cp949flag / Ret[5] : Temp / Ret[6] : Ret
		for i = 0, 5 do
			CVariable(IncludePlayer,FuncAlloc+i)
			table.insert(FENCD,FuncAlloc+i)
		end
		FuncAlloc = FuncAlloc + 6

		FENCDCall1 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

		FENCDCall2 = FuncAlloc
		FuncAlloc = FuncAlloc + 1


		-- f_VtoI - Ret[1] : Base / Ret[2] : Sign / Ret[3] : Source / Ret[4] : V / Ret[5] : Output / Ret[6] : Temp / Ret[7] : Size
		for i = 0, 6 do
			CVariable(IncludePlayer,FuncAlloc+i)
			table.insert(FSCANV,FuncAlloc+i)
		end
		FuncAlloc = FuncAlloc + 7

		FSCANVCall1 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

		FSCANVCall2 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

	-- f_WtoI - Ret[1] : Base / Ret[2] : Sign / Ret[3] : Source / Ret[4] : W / Ret[5] : Output / Ret[6] : Temp / Ret[7] : Size
		for i = 0, 6 do
			if i == 3 then
				CWariable(IncludePlayer,FuncAlloc+i)
			else
				CVariable(IncludePlayer,FuncAlloc+i)
			end
			table.insert(FSCANW,FuncAlloc+i)
		end
		FuncAlloc = FuncAlloc + 7

		FSCANWCall1 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

		FSCANWCall2 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

	-- f_ItoChat - Ret[1] : Size / Ret[2] : Source / Ret[3] : SourceX / Ret[4] : Temp / Ret[5] : Dest / Ret[6] : Count / Ret[7] : Temp2
		for i = 0, 6 do
			CVariable(IncludePlayer,FuncAlloc+i)
			table.insert(FCHAT,FuncAlloc+i)
		end
		FuncAlloc = FuncAlloc + 7

		FCHATAlloc = FuncAlloc
		FCHATCall1 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

		FuncAlloc = FuncAlloc+1

		FuncAlloc = FuncAlloc+1

		FuncAlloc = FuncAlloc+1

		FuncAlloc = FuncAlloc+1

		FuncAlloc = FuncAlloc+2
----------------------------------------------------------------------------------
		FCHATCall2 = FuncAlloc
		FuncAlloc = FuncAlloc + 1

	-- f_strlen - Ret[1] : Line / Ret[2] = Output / Ret[3] : EPDXOutput / Ret[4] : len/cat 
	FSTRLCall1 = FuncAlloc
	FSTRLCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

	-- f_ChatOffset - Ret[1] : Line / Ret[2] = Offset / Ret[3] = Output 
	FCHATOCall = FuncAlloc
	FuncAlloc = FuncAlloc + 1

	-- f_Display - Ret[1] : Line / Ret[2] = Output 
	FDISPCall1 = FuncAlloc
	FDISPCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

	-- f_DisplayX - Ret[1] : Line / Ret[2] : Index / Ret[3] : Value / Ret[4] : Mask / Ret[5] = Output 
	FDISPXCall1 = FuncAlloc
	FDISPXCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

	-- f_GetIndex - Ret[1] : Index / Ret[2] = Output 
	FGINDXCall1 = FuncAlloc
	FGINDXCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

	-- f_GetIndex2 - Ret[1] : Index / Ret[2] : Line / Ret[3] = Output 
	FGINDX2Call1 = FuncAlloc
	FGINDX2Call2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2


	-- f_GetLine - Ret[1] : DisplayLine / Ret[2] = Output | Output = Line
	FLINECall1 = FuncAlloc
	FLINECall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

	-- f_GetDisplayLine - Ret[1] : Line / Ret[2] = Output | Output = DisplayLine
	FDINECall1 = FuncAlloc
	FDINECall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_Memcpy - Ret[1] : Input Dest / Ret[2] = Source / Ret[3] = DestX / Ret[4] = SourceX / Ret[5] = Size
		for i = 0, 5 do
			CVariable(IncludePlayer,FuncAlloc+i)
			table.insert(FMEM,FuncAlloc+i)
		end
		FuncAlloc = FuncAlloc + 6
				FMEMAlloc = FuncAlloc
				FMEMCall0 =	FuncAlloc
				FuncAlloc = FuncAlloc + 1
				FMEMCall1 =	FuncAlloc
				FuncAlloc = FuncAlloc + 1

					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*1})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*1})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*1})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*0})
					FuncAlloc = FuncAlloc + 1
					table.insert(FMEMArr2,{FuncAlloc,0x15C+0x20*0})
					table.insert(FMEMArr1,{FuncAlloc,0x15C+0x20*1})
					FuncAlloc = FuncAlloc + 1
		FMEMCall2 =	FuncAlloc
		FuncAlloc = FuncAlloc + 1
	end
end

FiMULCall1 = 0
FiMULCall2 = 0
FMULCall0 = 0
FMULCall1 = 0
FMULCall2 = 0
FDIVCall1 = 0
FDIVCall2 = 0
FDIVCall3 = 0
FMODCall1 = 0
FMODCall2 = 0
FMODCall3 = 0
FIDIVCall1 = 0
FIDIVCall2 = 0
FIDIVCall3 = 0
FIMODCall1 = 0
FIMODCall2 = 0
FIMODCall3 = 0
FABSCall1 = 0
FABSCall2 = 0
function Include_ArithMetic() -- f_Mul f_Div f_iDiv f_Mod f_iMod f_Abs
	if CheckInclude_ArithMetic == 0 then
		CheckInclude_ArithMetic = 1
	local IncludePlayer = IncludePlayerID

-- f_MulXX / f_iMulXX - FuncAlloc+2 : Input X / Ret[2] : Input Y / Ret[3] : Output | Ouput = X * Y (f_Mul 최적화 버젼)

	Trigger {
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc+3);
		},
		flag = {Preserved}
	}

	CIfX(IncludePlayer,CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000))
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[4],0x15C,0,SetTo,1); -- Sflag
						SetCtrig1X("X",CRet[1],0x15C,0,Add,-1);
						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
	CElseX()
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[4],0x15C,0,SetTo,0); -- Sflag
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
	CIfXEnd()

	Trigger {
		players = {IncludePlayer},
		conditions = { -- Ret = 0
			Label(FuncAlloc);
		},
		actions = {
			SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0);
			SetCtrig1X("X",FuncAlloc+2,0x184+0x20*3,0,SetTo,0x2,0x2); -- Reset Flag
			SetCtrigX("X",FuncAlloc+2,0x158,0,SetTo,"X",FuncAlloc+2,0x15C,1,0); 
			SetCtrigX("X",FuncAlloc+2,0x17C,0,SetTo,"X",FuncAlloc+2,0,0,2);
			SetCtrig1X("X",FuncAlloc+2,0x160+0x20*6,0,SetTo,0x0,0xFF0000);
		},
		flag = {Preserved}
	}

	for i = 31, 0, -1 do
		local CBit = 2^i
		Trigger { -- 1 ~ 32
			players = {IncludePlayer},
			conditions = { -- X Max Bit Check
				Label(0);
				CtrigX("X",CRet[2],0x15C,0,AtLeast,CBit);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+2,0,0,1); -- Jump Calc
				SetCtrigX("X",FuncAlloc+1,0x158,0,SetTo,"X","X",0x4,1,0); -- RecoverNext
				SetCtrigX("X",FuncAlloc+1,0x15C,0,SetTo,"X","X",0,0,1); -- RecoverNext
				SetCtrigX("X",FuncAlloc+2,0x158+0x20*3,0,SetTo,"X",FuncAlloc+2,0x164+0x20*4+0x20*i,1,0);
			},
			flag = {Preserved}
		}
	end
	Trigger { -- 0
			players = {IncludePlayer},
			conditions = { -- X Max Bit Check
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+1,0,0,0); -- Jump Calc
				SetCtrigX("X",FuncAlloc+1,0x158,0,SetTo,"X","X",0x4,1,0); -- RecoverNext
				SetCtrigX("X",FuncAlloc+1,0x15C,0,SetTo,"X","X",0,0,1); -- RecoverNext
			},
			flag = {Preserved}
		}

	Trigger { -- LoopX 
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+2);
			},
			actions = {
				SetMemoryX(0,Add,0,0xFFFFFFFF); -- Inline Variable X
				SetCtrig1X("X","X",0x4,0,SetTo,0);
				SetCtrig1X("X","X",0x17C,0,Add,0x970);
				SetDeathsX(0,SetTo,0x0,0,0x2); -- Timer Action
				Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+1,0,0,0)); -- Exit Action
				SetCtrig1X("X","X",0x158+0x20*3,0,Subtract,8); -- Run Tick
				-----------------------------------------------------------
				SetCtrigX("X",FuncAlloc+2,0x158,0,SetTo,"X",FuncAlloc+2,0x15C,1,0); -- X_epd -> X
				SetCtrig1X("X",FuncAlloc+2,0x164+0x20*1,0,SetTo,0,0x2); -- enable 
				SetCtrig1X("X",FuncAlloc+2,0x164+0x20*2,0,SetTo,0,0x2); -- enable 
				SetCtrig1X("X",FuncAlloc+2,0x160+0x20*6,0,SetTo,0x000000,0xFF0000);

			},
			flag = {Preserved}
		}

	for i = 0, 31 do
		local CBit = 2^i
		Trigger { -- 1 ~ 32
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CtrigX("X",CRet[2],0x15C,0,Exactly,CBit,CBit);
			},
			actions = {
				SetCtrigX("X",FuncAlloc+2,0x158,0,SetTo,"X",CRet[3],0x15C,1,0); -- X_epd -> Ret
				SetCtrig1X("X",FuncAlloc+2,0x164+0x20*1,0,SetTo,0x2,0x2); -- disable
				SetCtrig1X("X",FuncAlloc+2,0x164+0x20*2,0,SetTo,0x2,0x2); -- disable
				SetCtrig1X("X",FuncAlloc+2,0x160+0x20*6,0,SetTo,0x2D0000,0xFF0000);
				SetCtrigX("X",FuncAlloc+2,0x4,0,SetTo,"X",FuncAlloc+2,0x0,0,0);
				SetCtrig1X("X",FuncAlloc+2,0x158+0x20*3,0,Add,0x20/4);
			},
			flag = {Preserved}
		}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
				SetDeaths(0,SetTo,0,0); -- RecoverNext
			},
			flag = {Preserved}
		}


	CIfX(IncludePlayer,CtrigX("X",CRet[4],0x15C,0,Exactly,1))
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[3],0x15C,0,Add,-1);
						SetCtrig1X("X",CRet[4],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[3],0x158,0,SetTo,"X",CRet[4],0x15C,1,0);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
	CElseX()
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[3],0x158,0,SetTo,"X",CRet[4],0x15C,1,0);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
	CIfXEnd()

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+4);
			},
			flag = {Preserved}
		}

	local PlayerID = IncludePlayer
	PlayerID = PlayerConvert(PlayerID)
	for k, P in pairs(PlayerID) do
		for i = 1, 32 do
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc+2,0x4,i,SetTo,"X",FuncAlloc+2,0x0,0,0))
		end
	end


FMULCall0 = FuncAlloc+2
FMULCall1 = FuncAlloc
FMULCall2 = FuncAlloc+1
FiMULCall1 = FuncAlloc+3
FiMULCall2 = FuncAlloc+4
FuncAlloc = FuncAlloc+5
--------------------------------------------------------------------------------------------------------------------
--f_DivX/iDivX/ModX/iModX - Ret[2] : Input X / Ret[1] : Input Y / Ret[3],[2],[5] : Output | Ouput = X / Y (f_Div 최적화 버젼)
--------------------- f_iDiv-------------------------------------------------------
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- FIDIV1
				},
				flag = {Preserved}
			}
		CIfX(IncludePlayer,CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000))
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[4],0x15C,0,SetTo,1); -- Sflag
						SetCtrig1X("X",CRet[1],0x15C,0,Add,-1);
						SetCtrig1X("X",FuncAlloc+5,0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+5,0x15C,1,0);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+5,0x17C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+5,0x17C,1,0);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
		CElseX()
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[4],0x15C,0,SetTo,0); -- Sflag
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+5,0x15C,1,0);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+5,0x17C,1,0);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()

		CIfX(IncludePlayer,CtrigX("X",CRet[5],0x15C,0,AtLeast,0x80000000))
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[4],0x15C,0,Add,1); -- Sflag
						SetCtrig1X("X",CRet[5],0x15C,0,Add,-1);
						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[5],0x158,0,SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X("X",CRet[5],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[5],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",CRet[5],0);
					},
					flag = {Preserved}
				}
		CElseX()
			Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[5],0x158,0,SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X("X",CRet[5],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[5],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- FIDIV1
					CtrigX("X",CRet[1],0x15C,0,AtLeast,1);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+4,0x0,0,0); -- goto Div Calc Start
					SetCtrigX("X",FuncAlloc+6,0x4,0,SetTo,"X",FuncAlloc+11,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+6,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FuncAlloc+6,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- FIDIV1
					CtrigX("X",CRet[4],0x15C,0,Exactly,0,0x1);
				},
				actions = {
					SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0x7FFFFFFF); 
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- FIDIV1
					CtrigX("X",CRet[4],0x15C,0,Exactly,1,0x1);
				},
				actions = {
					SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0x80000000); 
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- /0
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+12,0x0,0,0); -- 분기점 -> End
				},
				flag = {Preserved}
			}
	FIDIVCall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1
--------------------- f_iMod-------------------------------------------------------

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- FIMOD1
				},
				flag = {Preserved}
			}

		CIfX(IncludePlayer,CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000))
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,Add,-1);
						SetCtrig1X("X",FuncAlloc+4,0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+4,0x15C,1,0);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc+4,0x17C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+4,0x17C,1,0);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
		CElseX()
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+4,0x15C,1,0);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+4,0x17C,1,0);
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()

		CIfX(IncludePlayer,CtrigX("X",CRet[5],0x15C,0,AtLeast,0x80000000))
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[4],0x15C,0,SetTo,1); -- Sflag
						SetCtrig1X("X",CRet[5],0x15C,0,Add,-1);
						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[5],0x158,0,SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X("X",CRet[5],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[5],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",CRet[5],0);
					},
					flag = {Preserved}
				}
		CElseX()
			Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[4],0x15C,0,SetTo,0); -- Sflag
						SetCtrigX("X",CRet[5],0x158,0,SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X("X",CRet[5],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[5],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,1);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+3,0x0,0,0); -- goto Mod Calc Start
					SetCtrigX("X",FuncAlloc+5,0x4,0,SetTo,"X",FuncAlloc+8,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+5,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FuncAlloc+5,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}
		Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
						CtrigX("X",CRet[4],0x15C,0,Exactly,1,0x1);
					},
					actions = {
						SetCtrig1X("X",CRet[5],0x15C,0,Add,1);
					},
					flag = {Preserved}
				}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- /0
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+9,0x0,0,0); -- 분기점 -> End
				},
				flag = {Preserved}
			}

	FIMODCall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

--------------------- f_Div-------------------------------------------------------
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- FDIV1
				},
				actions = {
					SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+3,0x15C,1,0);
					SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[1],0);
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,1);
				},
				actions = {
					SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+3,0x17C,1,0);
					SetCtrigX("X","X",0x4,0,SetTo,"X",CRet[1],0x0,0,0);
					SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc+2,0x0,0,0); -- goto Div Calc Start
					SetCtrigX("X",FuncAlloc+4,0x4,0,SetTo,"X",FuncAlloc+6,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+4,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FuncAlloc+4,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- /0
				},
				actions = {
					SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0xFFFFFFFF);
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+6,0x0,0,0); -- 분기점 -> End
				},
				flag = {Preserved}
			}

	FDIVCall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

--------------------- f_Mod-------------------------------------------------------
	Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- FMOD1
				},
				actions = {
					SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+2,0x15C,1,0);
					SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[1],0);
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,1);
				},
				actions = {
					SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+2,0x17C,1,0);
					SetCtrigX("X","X",0x4,0,SetTo,"X",CRet[1],0x0,0,0);
					SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc+1,0x0,0,0); -- goto Mod Calc Start
					SetCtrigX("X",FuncAlloc+3,0x4,0,SetTo,"X",FuncAlloc+4,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FuncAlloc+3,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FuncAlloc+3,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- /0
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+4,0x0,0,0); -- 분기점 -> End
				},
				flag = {Preserved}
			}

	FMODCall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

-------------------------------------------------------------------------------------------------------

		local ClearNext = {}
		for i = 1, 32 do
			table.insert(ClearNext,SetCtrigX("X",FuncAlloc+1,0x4,i,SetTo,"X",FuncAlloc+1,0,0,i+32)) -- B -> BF
		end

		Trigger { -- Clear Value
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				actions = {
					ClearNext,
					SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0);
					SetCtrigX("X",FuncAlloc+1,0x15C+0x20*2,0,SetTo,"X",FuncAlloc+1,0,0,1); -- X -> B+1
					SetCtrigX("X",FuncAlloc+1,0x158,0,SetTo,"X",FuncAlloc+1,0x15C,1,0); -- X_epd -> X
					SetCtrigX("X",FuncAlloc+1,0x178,0,SetTo,"X",FuncAlloc+1,0x17C,1,0); -- X_epd -> X
				},
				flag = {Preserved}
			}
	
		FuncAlloc = FuncAlloc + 1

		local ClearRet = {}
		for i = 0, 31 do
			table.insert(ClearRet,SetCtrig1X("X",FuncAlloc,0x24,65+i,SetTo,0))
			table.insert(ClearRet,SetCtrig1X("X",FuncAlloc,0x15C,65+i,SetTo,0))
		end

		Trigger { -- Clear Ret (-1)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					ClearRet,
				},
				flag = {Preserved}
			}

		Trigger { -- X (0)
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				actions = {
					SetMemoryX(0,Add,0,0xFFFFFFFF); -- 0x24
					SetMemoryX(0,Add,0,0xFFFFFFFF); -- 0x15C
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,1); -- X -> B+1
					--------------------------------
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,0); -- X -> X
					SetCtrigX("X",FuncAlloc,0x158,0,SetTo,"X",FuncAlloc,0x15C,1,0); -- X_epd -> X
					SetCtrigX("X",FuncAlloc,0x178,0,SetTo,"X",FuncAlloc,0x17C,1,0); -- X_epd -> X
					SetCtrig1X("X",FuncAlloc,0x15C+0x20*2,0,Add,0x970); -- X -> B+1 + i
					SetCtrig1X("X",FuncAlloc,0x160+0x20*3,0,SetTo,0x000000,0xFF0000); -- Close
				},
				flag = {Preserved}
			}

		for i = 0, 31 do
			Trigger { -- B (1~32)
					players = {IncludePlayer},
					conditions = {
						Label(0);
						CtrigX("X",FuncAlloc,0x15C,0,AtMost,0x7FFFFFFF);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,0); -- B -> X
						SetCtrigX("X",FuncAlloc,0x158,0,SetTo,"X",FuncAlloc,0x24,1,96-i); -- X_epd -> Ret
						SetCtrigX("X",FuncAlloc,0x178,0,SetTo,"X",FuncAlloc,0x15C,1,96-i); -- X_epd -> Ret
						SetCtrig1X("X",FuncAlloc,0x160+0x20*3,0,SetTo,0x2D0000,0xFF0000); -- Open
					},
					flag = {Preserved}
				}
		end

		for i = 0, 31 do
			Trigger { -- BF (33~64)
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",FuncAlloc,0x15C+0x20*2,0,SetTo,"X",FuncAlloc,0,0,96-i); -- X -> Ret
						SetCtrigX("X",FuncAlloc,0x158,0,SetTo,"X",FuncAlloc,0x24,1,96-i); -- X_epd -> Ret
						SetCtrigX("X",FuncAlloc,0x178,0,SetTo,"X",FuncAlloc,0x15C,1,96-i); -- X_epd -> Ret
					},
					flag = {Preserved}
				}
		end

		for i = 0, 31 do
			local CBit = 2^(31-i) -- 역행 2^31 -> 2^0
			Trigger { -- Ret (65~96)
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",CRet[2],0x15C,0,AtLeast,0); -- CRet[2] AtLeast X*2^i
				},
				actions = {
					SetCtrig1X("X",CRet[2],0x15C,0,Subtract,0); -- CRet[2] Subtract X*2^i
					SetCtrig1X("X",CRet[3],0x15C,0,Add,CBit); -- CRet[3] Add 2^i
				},
				flag = {Preserved}
			}
		end

		local PlayerID = IncludePlayer
		PlayerID = PlayerConvert(PlayerID)
		for k, P in pairs(PlayerID) do
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,-1,SetTo,"X",FuncAlloc,0x0,0,1)) -- Clear -> B1
			for i = 1, 32 do
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",FuncAlloc,0x4,i+32,SetTo,"X",FuncAlloc,0x0,0,0)) -- BF -> X
			end
		end

	FuncAlloc = FuncAlloc + 1

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- 분기점
				},
				actions = {
					SetMemory(0,SetTo,0);
				},
				flag = {Preserved}
			}
	FuncAlloc = FuncAlloc + 1
--------------------- f_Mod End-------------------------------------------------------
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- f_Mod End
				},
				flag = {Preserved}
			}
	FMODCall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1
--------------------- f_Div End-------------------------------------------------------
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- f_Div End
				},
				flag = {Preserved}
			}
	FDIVCall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

--------------------- f_iMod End-------------------------------------------------------
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- IMod End Start
				},
				flag = {Preserved}
			}

		CIfX(IncludePlayer,CtrigX("X",CRet[4],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[2],0x15C,0,Add,-1);
						SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[2],0x158,0,SetTo,"X",CRet[5],0x15C,1,0);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		CElseX()
			Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,"X",CRet[5],0x15C,1,0);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()
	
	FuncAlloc = FuncAlloc + 1

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- Exit Func
				},
				flag = {Preserved}
			}

	FIMODCall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

--------------------- f_iDiv End-------------------------------------------------------

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- IDiv End Start
				},
				flag = {Preserved}
			}

		CIfX(IncludePlayer,CtrigX("X",CRet[4],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[3],0x15C,0,Add,-1);
						SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",CRet[3],0x158,0,SetTo,"X",CRet[5],0x15C,1,0);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		CElseX()
			Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[3],0x158,0,SetTo,"X",CRet[5],0x15C,1,0);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()
	
	FuncAlloc = FuncAlloc + 1

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- Exit Func
				},
				flag = {Preserved}
			}

	FIDIVCall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1
------------------------------------------------------------------------------------------

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc); -- Exit Func
				},
				flag = {Preserved}
			}

		CIfX(IncludePlayer,CtrigX("X",CRet[1],0x15C,0,AtLeast,0x80000000))
			Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Add,-1);
					SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFFFFFF);
					SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[2],0x15C,1,0);
					SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
					CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
		CElseX()
			Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[2],0x15C,1,0);
					SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc+1); -- Exit Func
				},
				flag = {Preserved}
			}

	FABSCall1 = FuncAlloc
	FABSCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2
end
end


FSQRTCall1 = 0
FSQRTCall2 = 0
FSQRTCall3 = 0
FSQRTCheck = 0
FSQRT = {}
FLENGCall1 = 0
FLENGCall2 = 0
FLENGCheck = 0
FLENG = {}
FATANCall1 = 0
FATANCall2 = 0
FATANCheck = 0
FATAN = {}
FLOG2Call1 = 0
FLOG2Call2 = 0
FLOG2Check = 0
FLOG2 = {}
AngleCycle = 0
function Include_MatheMatics(Cycle) -- f_Sqrt / f_Lengthdir / f_Atan2 / f_log2 | Cycle = 2*pi, 4의 배수여야함
	if CheckInclude_MatheMatics == 0 then
		CheckInclude_MatheMatics = 1
	AngleCycle = Cycle
	local IncludePlayer = IncludePlayerID

-- f_Sqrt - Ret[1] : Input Value / Ret[2] = Output | Ret = √X 
	CVariable(IncludePlayer,FuncAlloc) -- Local Variable
	CVariable(IncludePlayer,FuncAlloc+1)
	FSQRT = {FuncAlloc,FuncAlloc+1}
	FuncAlloc = FuncAlloc + 2

	FSQRTCall1 = FuncAlloc
	FSQRTCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2
	FSQRTCall3 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

-- f_Lengthdir - Ret[1] : Input R  Ret[2] = Θ | Ret[3] = RCosΘ  Ret[4] = RSinΘ
	for i = 0, 7 do
		CVariable(IncludePlayer,FuncAlloc+i) -- Local Variable
		table.insert(FLENG,FuncAlloc+i)
	end
	FuncAlloc = FuncAlloc + 8

	FLENGCall1 = FuncAlloc
	FLENGCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_Atan2 - Ret[1] : Input Y  Ret[2] = X | Ret[3] = Θ  
	for i = 0, 3 do
		CVariable(IncludePlayer,FuncAlloc+i) -- Local Variable
		table.insert(FATAN,FuncAlloc+i)
	end
	FuncAlloc = FuncAlloc + 4

	FATANCall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1
	FATANCall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

	-- f_Log2 - Ret[1] : Input Value / Ret[2] = Output | Ret = log2(X) 
	CVariable(IncludePlayer,FuncAlloc) -- Local Variable
	CVariable(IncludePlayer,FuncAlloc+1)
	FLOG2 = {FuncAlloc,FuncAlloc+1}
	FuncAlloc = FuncAlloc + 2

	FLOG2Call1 = FuncAlloc
	FLOG2Call2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2
end
end

FRAND = 0
FRANDCall1 = 0
FRANDCall2 = 0
FPSTR = {}
FPSTRCall0 = 0
FPSTRCall1 = 0
FPSTRCall2 = 0
FPSTRCheck = 0
FPSTRX = {}
FPSTRXCall1 = 0
FPSTRXCall2 = 0
FPSTRXCheck = 0
FPTBL = {}
FPTBLCall0 = 0
FPTBLCall1 = 0
FPTBLCall2 = 0
FPTBLCheck = 0
ISTR = {}
ISTRCall1 = 0
ISTRCall2 = 0
ISTRCheck = 0
FISTRX = {}
FISTRXCall1 = 0
FISTRXCall2 = 0
FISTRXCheck = 0
ITBL = {}
ITBLCall1 = 0
ITBLCall2 = 0
ITBLCheck = 0
FCTACall0 = 0
FCTACall1 = 0
FCTACall2 = 0
FCTACheck = 0
FATCCall1 = 0
FATCCall2 = 0
FATCCheck = 0
FCGU = {}
FCGUCall1 = 0
FCGUCall2 = 0
FCGUCheck = 0
function Include_MiscFunctions(SeedSwitch) -- f_Rand 
	if CheckInclude_MiscFunctions == 0 then
		CheckInclude_MiscFunctions = 1
	local IncludePlayer = IncludePlayerID

	if SeedSwitch == "X" or SeedSwitch == nil then
		Need_SeedSwitch_Error()
	end
----------------------------------------------
-- f_Rand - Ret[1] : Output  
	CVariable(IncludePlayer,FuncAlloc)
	FRAND = FuncAlloc
	FuncAlloc = FuncAlloc + 1

	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetSwitch(SeedSwitch,Random);
				SetCVar("X",FRAND,SetTo,0);
			},
			flag = {Preserved}
		}
	for i = 31, 0, -1 do
		Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(0);
				Switch(SeedSwitch,Set);
			},
			actions = {
				SetCVar("X",FRAND,Add,2^i);
			},
			flag = {Preserved}
		}
		if i ~= 0 then
			Trigger { 
				players = {IncludePlayer},
				actions = {
					SetSwitch(SeedSwitch,Random);
				},
				flag = {Preserved}
			}
		end
	end
	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			flag = {Preserved}
		}

	FRANDCall1 = FuncAlloc
	FRANDCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2
-- f_CGive 
	FCGU = CreateVarArr(17,IncludePlayer)

	FCGUCall1 = FuncAlloc
	FCGUCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2
-- f_CunitToAlphaID 
	FCTACall0 = FuncAlloc
	FCTACall1 = FuncAlloc+1
	FCTACall2 = FuncAlloc+2
	FuncAlloc = FuncAlloc + 3
-- f_AlphaIDToCunit 
	FATCCall1 = FuncAlloc
	FATCCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2
-- f_GetStrptr
	for i = 0, 2 do
		CVariable(IncludePlayer,FuncAlloc+i) -- Local Variable
		table.insert(FPSTR,FuncAlloc+i)
	end
	FuncAlloc = FuncAlloc + 3

	FPSTRCall1 = FuncAlloc
	FPSTRCall2 = FuncAlloc+1
	FPSTRCall0 = FuncAlloc+2
	FuncAlloc = FuncAlloc + 3
-- f_GetStrXptr - Ret[1] : StringId | Ret[2] = Strptr  
	for i = 0, 1 do
		CVariable(IncludePlayer,FuncAlloc+i) -- Local Variable
		table.insert(FPSTRX,FuncAlloc+i)
	end
	FuncAlloc = FuncAlloc + 2

	FPSTRXCall1 = FuncAlloc
	FPSTRXCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2
-- f_GetTblptr - Ret[1] : Tbl Index  Ret[2] = Type | Ret[3] = Tblptr  
	for i = 0, 2 do
		CVariable(IncludePlayer,FuncAlloc+i) -- Local Variable
		table.insert(FPTBL,FuncAlloc+i)
	end
	FuncAlloc = FuncAlloc + 3

	FPTBLCall1 = FuncAlloc
	FPTBLCall2 = FuncAlloc+1
	FPTBLCall0 = FuncAlloc+2
	FuncAlloc = FuncAlloc + 3
-- f_GetiStrXepd - Ret[1] : StringId | Ret[2] = Strepd
	for i = 0, 1 do
		CVariable(IncludePlayer,FuncAlloc+i) -- Local Variable
		table.insert(FISTRX,FuncAlloc+i)
	end
	FuncAlloc = FuncAlloc + 2

	FISTRXCall1 = FuncAlloc
	FISTRXCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_InitiStrptr - Ret[1] : Offset , Ret[2] : EPD, Ret[3] : EPDX, Ret[4] : Size (4N+3), Ret[5] : EPD Backup
		for i = 0, 4 do
			CVariable(IncludePlayer,FuncAlloc+i)
			table.insert(ISTR,FuncAlloc+i)
		end
		FuncAlloc = FuncAlloc + 5

		ISTRCall1 =	FuncAlloc
		ISTRCall2 =	FuncAlloc+1
		FuncAlloc = FuncAlloc + 2
	-- f_InitiTblptr - Ret[1] : Offset , Ret[2] : EPD, Ret[3] : EPDX, Ret[4] : Size (4N+3), Ret[5] : EPD Backup, Ret[6] : PointerEPD, Ret[7] : PointerEPDX
		for i = 0, 6 do
			CVariable(IncludePlayer,FuncAlloc+i)
			table.insert(ITBL,FuncAlloc+i)
		end
		FuncAlloc = FuncAlloc + 7

		ITBLCall1 =	FuncAlloc
		ITBLCall2 =	FuncAlloc+1
		FuncAlloc = FuncAlloc + 2
	end
end

-- 함수 호출형 최종 연산 함수 (f_) ------------------------------------------------------

function f_Movcpy(PlayerID,Dest,SourceVA,Size,Distance) -- VA index = 상수 (CPRead)
	FMOVECheck = 1
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << Dest / CRet[2] << VAOffset / CRet[3] << Size (Offset)

	if type(Dest) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMOVE[1],0x15C,0,SetTo,Dest);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then
		local TempRet = {"X",FMOVE[1],0,"V"}
		MovX(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "A" then
		local TempRet = {"X",FMOVE[1],0,"V"}
		TMem(PlayerID,TempRet,Dest,nil,nil,1)
		Dest = TempRet
	elseif Dest[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FMOVE[1],0x15C,1,0);
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Dest[1],Dest[2],Dest[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMOVE[1],0x15C,0,SetTo,Dest[1],Dest[2],Dest[3],0,Dest[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMOVE[3],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FMOVE[3],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FMOVE[3],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if SourceVA[4] == "V" then -- ※ MovX는 CPRead방식으로 Cp값 변경하므로 Cp값 자체를 전달하는 SourceVA인자는 맨 밑에 있어야함
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig2X(0x6509B0,SetTo,SourceVA[1],SourceVA[2],0,1,SourceVA[3]); -- VArray Header +0x0
				SetCtrigX("X",FMOVE[2],0x15C,0,SetTo,SourceVA[1],SourceVA[2],0,0,SourceVA[3]);
			},
			flag = {Preserved}
		}
	elseif SourceVA[4] == "VA" then
		local TempRet = {"X",FMOVE[2],0,"V"}
		TMem(PlayerID,TempRet,SourceVA,0,0,1)
		Trigger {--(CPRead)로 값 출력
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0x6509B0,SetTo,SourceVA[5][1],SourceVA[5][2],0,1,SourceVA[5][3]); 
					SetMemory(0x6509B0,Add,SourceVA[6]);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x148,SourceVA[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x160,SourceVA[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x158,SourceVA[3],SetTo,EPD(0x6509B0)); 
					CallLabelAlways(SourceVA[1],SourceVA[2],SourceVA[3]);
				},
				flag = {Preserved}
		}
	end

	if Distance == nil then
		Distance = 1
	end
	-- Call f_Movcpy
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FMOVECall0,0x0,0,0);
					SetCtrigX("X",FMOVECall2,0x4,0,SetTo,"X","X",0x0,0,1);
					SetCtrig1X("X",FMOVEArr[1][1],FMOVEArr[1][2],0,SetTo,Distance);
					SetCtrig1X("X",FMOVEArr[2][1],FMOVEArr[2][2],0,SetTo,Distance);
					SetCtrig1X("X",FMOVEArr[3][1],FMOVEArr[3][2],0,SetTo,Distance);
				},
				flag = {Preserved}
			}
	if FMOVECall1 == 0 then
		Need_Include_DataTransfer()
	end

	RecoverCp(PlayerID)
end

function f_MovcpyEPD(PlayerID,Dest,SourceVA,Size,InitBytes,Distance) -- VA index = 상수 (CPRead)
	FMOVECheck = 1
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << Dest / CRet[2] << VAOffset / CRet[3] << Size (EPD)

	local InitMask
	if InitBytes == "X" or InitBytes == nil then
		InitBytes = 0
	end
	if InitBytes == 0 then 
		InitMask = 0xFFFFFFFF
	elseif InitBytes == 1 then
		InitMask = 0xFFFFFF00
	elseif InitBytes == 2 then
		InitMask = 0xFFFF0000
	elseif InitBytes == 3 then
		InitMask = 0xFF000000
	else
		f_MovcpyEPD_InputData_Error()
	end

	if type(Dest) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMOVE[1],0x15C,0,SetTo,Dest);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then
		local TempRet = {"X",FMOVE[1],0,"V"}
		MovX(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "A" then
		local TempRet = {"X",FMOVE[1],0,"V"}
		MovZ(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FMOVE[1],0x15C,1,0);
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Dest[1],Dest[2],Dest[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMOVE[1],0x15C,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMOVE[3],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FMOVE[3],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FMOVE[3],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if SourceVA[4] == "V" then -- ※ MovX는 CPRead방식으로 Cp값 변경하므로 Cp값 자체를 전달하는 SourceVA인자는 맨 밑에 있어야함
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig2X(0x6509B0,SetTo,SourceVA[1],SourceVA[2],0,1,SourceVA[3]); -- VArray Header +0x0
				SetCtrigX("X",FMOVE[2],0x15C,0,SetTo,SourceVA[1],SourceVA[2],0,0,SourceVA[3]);
				SetCtrig1X("X",FMOVE[4],0x15C,0,SetTo,InitMask);
			},
			flag = {Preserved}
		}
	elseif SourceVA[4] == "VA" then
		local TempRet = {"X",FMOVE[2],0,"V"}
		TMem(PlayerID,TempRet,SourceVA,0,0,1)
		Trigger {--(CPRead)로 값 출력
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[4],0x15C,0,SetTo,InitMask);
					SetCtrig2X(0x6509B0,SetTo,SourceVA[5][1],SourceVA[5][2],0,1,SourceVA[5][3]); 
					SetMemory(0x6509B0,Add,SourceVA[6]);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x148,SourceVA[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x160,SourceVA[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x158,SourceVA[3],SetTo,EPD(0x6509B0)); 
					CallLabelAlways(SourceVA[1],SourceVA[2],SourceVA[3]);
				},
				flag = {Preserved}
		}
	end

	if Distance == nil then
		Distance = 1
	end
	-- Call f_MovcpyEPD
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FMOVECall1,0x0,0,0);
					SetCtrigX("X",FMOVECall2,0x4,0,SetTo,"X","X",0x0,0,1);
					SetCtrig1X("X",FMOVEArr[1][1],FMOVEArr[1][2],0,SetTo,Distance);
					SetCtrig1X("X",FMOVEArr[2][1],FMOVEArr[2][2],0,SetTo,Distance);
					SetCtrig1X("X",FMOVEArr[3][1],FMOVEArr[3][2],0,SetTo,Distance);
				},
				flag = {Preserved}
			}
	if FMOVECall1 == 0 then
		Need_Include_DataTransfer()
	end

	RecoverCp(PlayerID)
end

function f_ReadcpyEPD(PlayerID,DestVA,Source,Size,Distance)
	FMEMECheck = 1
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << DestVA / CRet[2] << Source / CRet[3] << Size (EPD)
		
	if DestVA[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEME[1],0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]);
			},
			flag = {Preserved}
		}
	elseif DestVA[4] == "VA" then
		local TempRet = {"X",FMEME[1],0,"V"}
		MovZ(PlayerID,TempRet,DestVA,0x15C)
		DestVA = TempRet
	end

	if type(Source) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEME[2],0x15C,0,SetTo,Source);
			},
			flag = {Preserved}
		}
	elseif Source[4] == "VA" then
		local TempRet = {"X",FMEME[2],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "A" then
		local TempRet = {"X",FMEME[2],0,"V"}
		MovZ(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FMEME[2],0x15C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEME[2],0x15C,0,SetTo,Source[1],Source[2],Source[3],1,Source[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEME[3],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FMEME[3],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FMEME[3],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if Distance == nil then
		Distance = 1
	end
	-- Call f_MemcpyEPD
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FMEMECall1,0x0,0,0);
					SetCtrigX("X",FMEMECall2,0x4,0,SetTo,"X","X",0x0,0,1);
					SetCtrig1X("X",FMEMEArr[1][1],FMEMEArr[1][2],0,SetTo,Distance);
					SetCtrig1X("X",FMEMEArr[2][1],FMEMEArr[2][2],0,SetTo,604);
				},
				flag = {Preserved}
			}
	if FMEMECall1 == 0 then
		Need_Include_DataTransfer()
	end
end

function f_MemcpyEPD(PlayerID,Dest,Source,Size,DestDistance,SourceDistance) 
	FMEMECheck = 1
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << Dest / CRet[2] << Source / CRet[3] << Size (EPD)
	if type(Dest) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEME[1],0x15C,0,SetTo,Dest);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then
		local TempRet = {"X",FMEME[1],0,"V"}
		MovX(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "A" then
		local TempRet = {"X",FMEME[1],0,"V"}
		MovZ(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FMEME[1],0x15C,1,0);
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Dest[1],Dest[2],Dest[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEME[1],0x15C,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Source) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEME[2],0x15C,0,SetTo,Source);
			},
			flag = {Preserved}
		}
	elseif Source[4] == "VA" then
		local TempRet = {"X",FMEME[2],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "A" then
		local TempRet = {"X",FMEME[2],0,"V"}
		MovZ(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FMEME[2],0x15C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEME[2],0x15C,0,SetTo,Source[1],Source[2],Source[3],1,Source[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEME[3],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FMEME[3],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FMEME[3],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if DestDistance == nil then
		DestDistance = 1
	end
	if SourceDistance == nil then
		SourceDistance = 1
	end
	-- Call f_MemcpyEPD
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FMEMECall1,0x0,0,0);
					SetCtrigX("X",FMEMECall2,0x4,0,SetTo,"X","X",0x0,0,1);
					SetCtrig1X("X",FMEMEArr[1][1],FMEMEArr[1][2],0,SetTo,SourceDistance);
					SetCtrig1X("X",FMEMEArr[2][1],FMEMEArr[2][2],0,SetTo,DestDistance);
				},
				flag = {Preserved}
			}
	if FMEMECall1 == 0 then
		Need_Include_DataTransfer()
	end
end
--[[
function CbyteConvert(PlayerID,DestVA,Source) 
	STPopTrigArr(PlayerID)

	if DestVA[4] == "V" then
		local Temp = {}
		for k, v in pairs(Source) do
			table.insert(Temp,SetCtrig1X(DestVA[1],DestVA[2],0x15C,DestVA[3]+k-1,SetTo,v*0x01010101))
		end
		DoActions2X(PlayerID,Temp)
	elseif DestVA[4] == "VA" then
		local k = 1
		local Size = #Source

		while k <= Size do
			if Size - k + 1 >= 63 then
				local X = {}
				for i = 0, 62 do
					table.insert(X,TSetMemory(Vi(DestVA[2],{DestVA[5][1],DestVA[5][2],0x15C,DestVA[5][3]+k-1},DestVA[1],DestVA[3]),SetTo,Source[k]*0x01010101))
					k = k + 1
				end
				CDoActions(PlayerID,X)
			else
				local X = {}
				repeat
					table.insert(X,TSetMemory(Vi(DestVA[2],{DestVA[5][1],DestVA[5][2],0x15C,DestVA[5][3]+k-1},DestVA[1],DestVA[3]),SetTo,Source[k]*0x01010101))
					k = k + 1
				until k == Size + 1
				CDoActions(PlayerID,X)
			end
		end
	end
end
]]--
function CbyteConvert(PlayerID,DestVA,Source) 
	STPopTrigArr(PlayerID)

	if DestVA[4] == "V" then
		local Size = #Source
		local Temp = {{},{0},{0},{0}}
		local R
		for i = 1, Size do
			local t = (i-1)%4
			local u = math.floor((i-1)/4)+1
			local v = u+1
			if t == 0 then
				table.insert(Temp[1],0)
				Temp[1][u] = Temp[1][u] + Source[i]
				Temp[2][u] = Temp[2][u] + Source[i]*256
				Temp[3][u] = Temp[3][u] + Source[i]*65536
				Temp[4][u] = Temp[4][u] + Source[i]*16777216
			elseif t == 1 then
				if Temp[1][u] == nil then
					PushValueMsg(i)
				end
				table.insert(Temp[4],0)
				Temp[1][u] = Temp[1][u] + Source[i]*256
				Temp[2][u] = Temp[2][u] + Source[i]*65536
				Temp[3][u] = Temp[3][u] + Source[i]*16777216
				Temp[4][v] = Temp[4][v] + Source[i]
			elseif t == 2 then
				table.insert(Temp[3],0)
				Temp[1][u] = Temp[1][u] + Source[i]*65536
				Temp[2][u] = Temp[2][u] + Source[i]*16777216
				Temp[3][v] = Temp[3][v] + Source[i]
				Temp[4][v] = Temp[4][v] + Source[i]*256
			elseif t == 3 then
				table.insert(Temp[2],0)
				Temp[1][u] = Temp[1][u] + Source[i]*16777216
				Temp[2][v] = Temp[2][v] + Source[i]
				Temp[3][v] = Temp[3][v] + Source[i]*256
				Temp[4][v] = Temp[4][v] + Source[i]*65536
			end
			R = t
		end
		if R == 1 then
			table.insert(Temp[1],0)
			table.insert(Temp[2],0)
			table.insert(Temp[3],0)
		elseif R == 2 then
			table.insert(Temp[1],0)
			table.insert(Temp[2],0)
		elseif R == 3 then
			table.insert(Temp[1],0)
		end
		local n = #Temp[1]

		local X = {}
		for j = 1, n do
			for i = 1, 4 do
				table.insert(X,SetCtrig1X(DestVA[1],DestVA[2],0x15C,DestVA[3]+(j-1)*4+(i-1),SetTo,Temp[i][j]))
			end
		end

		DoActions2X(PlayerID,X)
	elseif DestVA[4] == "VA" then
		local Size = #Source
		local Temp = {{},{0},{0},{0}}
		local R
		for i = 1, Size do
			local t = (i-1)%4
			local u = math.floor((i-1)/4)+1
			local v = u+1
			if t == 0 then
				table.insert(Temp[1],0)
				Temp[1][u] = Temp[1][u] + Source[i]
				Temp[2][u] = Temp[2][u] + Source[i]*256
				Temp[3][u] = Temp[3][u] + Source[i]*65536
				Temp[4][u] = Temp[4][u] + Source[i]*16777216
			elseif t == 1 then
				table.insert(Temp[4],0)
				Temp[1][u] = Temp[1][u] + Source[i]*256
				Temp[2][u] = Temp[2][u] + Source[i]*65536
				Temp[3][u] = Temp[3][u] + Source[i]*16777216
				Temp[4][v] = Temp[4][v] + Source[i]
			elseif t == 2 then
				table.insert(Temp[3],0)
				Temp[1][u] = Temp[1][u] + Source[i]*65536
				Temp[2][u] = Temp[2][u] + Source[i]*16777216
				Temp[3][v] = Temp[3][v] + Source[i]
				Temp[4][v] = Temp[4][v] + Source[i]*256
			elseif t == 3 then
				table.insert(Temp[2],0)
				Temp[1][u] = Temp[1][u] + Source[i]*16777216
				Temp[2][v] = Temp[2][v] + Source[i]
				Temp[3][v] = Temp[3][v] + Source[i]*256
				Temp[4][v] = Temp[4][v] + Source[i]*65536
			end
			R = t
		end
		if R == 1 then
			table.insert(Temp[1],0)
			table.insert(Temp[2],0)
			table.insert(Temp[3],0)
		elseif R == 2 then
			table.insert(Temp[1],0)
			table.insert(Temp[2],0)
		elseif R == 3 then
			table.insert(Temp[1],0)
		end
		local n = #Temp[1]

		local k = 1
		local Size = #Temp[1]*4
		while k <= Size do
			if Size - k + 1 >= 60 then
				local X = {}
				for j = 0, 14 do
					for i = 1, 4 do
						local l = math.floor((k-1)/4+1)
						table.insert(X,TSetMemory(Vi(DestVA[2],{DestVA[5][1],DestVA[5][2],0x15C,DestVA[5][3]+4*(l-1)+(i-1)},DestVA[1],DestVA[3]),SetTo,Temp[i][l]))
						k = k + 1
					end
				end
				CDoActions(PlayerID,X)
			else
				local X = {}
				repeat
					for i = 1, 4 do
						local l = math.floor((k-1)/4+1)
						table.insert(X,TSetMemory(Vi(DestVA[2],{DestVA[5][1],DestVA[5][2],0x15C,DestVA[5][3]+4*(l-1)+(i-1)},DestVA[1],DestVA[3]),SetTo,Temp[i][l]))
						k = k + 1
					end
				until k == Size + 1
				CDoActions(PlayerID,X)
			end
		end
	end
end

function f_byteConvert(PlayerID,DestVA,Source,Size,Distance) -- 1 -> 4
	FCONVCheck = 1
	-- DestVA << VArray / Source <<  Offset / Size << Offset / Distance
	STPopTrigArr(PlayerID)
	if Distance == "X" then
		Distance = nil
	end
	if DestVA[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FCONV[1],0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]);
				SetCtrigX("X",FCONV[2],0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]+1);
				SetCtrigX("X",FCONV[3],0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]+2);
				SetCtrigX("X",FCONV[4],0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]+3);
			},
			flag = {Preserved}
		}
	elseif DestVA[4] == "VA" then
		MovZ(PlayerID,{"X",FCONV[1],0,"V"},DestVA,0x15C)
		MovZ(PlayerID,{"X",FCONV[2],0,"V"},DestVA,0x15C)
		MovZ(PlayerID,{"X",FCONV[3],0,"V"},DestVA,0x15C)
		MovZ(PlayerID,{"X",FCONV[4],0,"V"},DestVA,0x15C)
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCONV[2],0x15C,0,Add,0x970/4);
				SetCtrig1X("X",FCONV[3],0x15C,0,Add,0x970/2);
				SetCtrig1X("X",FCONV[4],0x15C,0,Add,3*0x970/4);
			},
			flag = {Preserved}
		}
	end

	if type(Source) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCONV[5],0x15C,0,SetTo,Source);
			},
			flag = {Preserved}
		}
	elseif Source[4] == "VA" then
		local TempRet = {"X",FCONV[5],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FCONV[5],0x15C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FCONV[5],0x15C,0,SetTo,Source[1],Source[2],Source[3],0,Source[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCONV[6],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FCONV[6],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FCONV[6],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if Distance == nil then
		Distance = 1
	end
	-- Call f_ByteConvert
	local Temp = {}
	for k, v in pairs(FCONVArr) do
		table.insert(Temp,SetCtrig1X("X",v[1],v[2],0,SetTo,Distance))
	end
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVCall0,0x0,0,0);
					SetCtrigX("X",FCONVCall2,0x4,0,SetTo,"X","X",0x0,0,1);
					Temp,
				},
				flag = {Preserved}
			}
	if FCONVCall1 == 0 then
		Need_Include_DataTransfer()
	end

	RecoverCp(PlayerID)
end

function f_byteConvertX(PlayerID,DestVA,Source,SourceX,Size,Distance)
	FCONVCheck = 1
	-- DestVA << VArray / Source << epd, SourceX << D / Size << Offset / Distance
	STPopTrigArr(PlayerID)
	if Distance == "X" then
		Distance = nil
	end
	if DestVA[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FCONV[1],0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]);
				SetCtrigX("X",FCONV[2],0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]+1);
				SetCtrigX("X",FCONV[3],0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]+2);
				SetCtrigX("X",FCONV[4],0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]+3);
			},
			flag = {Preserved}
		}
	elseif DestVA[4] == "VA" then
		MovZ(PlayerID,{"X",FCONV[1],0,"V"},DestVA,0x15C)
		MovZ(PlayerID,{"X",FCONV[2],0,"V"},DestVA,0x15C)
		MovZ(PlayerID,{"X",FCONV[3],0,"V"},DestVA,0x15C)
		MovZ(PlayerID,{"X",FCONV[4],0,"V"},DestVA,0x15C)
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCONV[2],0x15C,0,Add,0x970/4);
				SetCtrig1X("X",FCONV[3],0x15C,0,Add,0x970/2);
				SetCtrig1X("X",FCONV[4],0x15C,0,Add,3*0x970/4);
			},
			flag = {Preserved}
		}
	end

	if type(Source) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCONV[5],0x15C,0,SetTo,Source);
			},
			flag = {Preserved}
		}
	elseif Source[4] == "VA" then
		local TempRet = {"X",FCONV[5],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FCONV[5],0x15C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FCONV[5],0x15C,0,SetTo,Source[1],Source[2],Source[3],0,Source[4]);
			},
			flag = {Preserved}
		}
	end

	if type(SourceX) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCONV[7],0x15C,0,SetTo,SourceX);
			},
			flag = {Preserved}
		}
	elseif SourceX[4] == "VA" then
		local TempRet = {"X",FCONV[7],0,"V"}
		MovX(PlayerID,TempRet,SourceX)
		SourceX = TempRet
	elseif SourceX[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(SourceX[1],SourceX[2],0x158,SourceX[3],SetTo,"X",FCONV[7],0x15C,1,0);
				SetCtrig1X(SourceX[1],SourceX[2],0x148,SourceX[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(SourceX[1],SourceX[2],0x160,SourceX[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(SourceX[1],SourceX[2],SourceX[3]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCONV[6],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FCONV[6],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FCONV[6],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if Distance == nil then
		Distance = 1
	end
	-- Call f_ByteConvert
	local Temp = {}
	for k, v in pairs(FCONVArr) do
		table.insert(Temp,SetCtrig1X("X",v[1],v[2],0,SetTo,Distance))
	end
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVCall1,0x0,0,0);
					SetCtrigX("X",FCONVCall2,0x4,0,SetTo,"X","X",0x0,0,1);
					Temp,
				},
				flag = {Preserved}
			}
	if FCONVCall1 == 0 then
		Need_Include_DataTransfer()
	end

	RecoverCp(PlayerID)
end

function f_bytecpy(PlayerID,Dest,SourceVA,Size,Distance) 
	FBYTECheck = 1
	-- SourceVA << VArray / Dest <<  Offset / Size << Offset / Distance
	STPopTrigArr(PlayerID)

	if SourceVA[4] == "V" then -- ※ MovX는 CPRead방식으로 Cp값 변경하므로 Cp값 자체를 전달하는 SourceVA인자는 맨 밑에 있어야함
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig2X(0x6509B0,SetTo,SourceVA[1],SourceVA[2],0,1,SourceVA[3]); -- VArray Header +0x0
				SetCtrigX("X",FBYTE[1],0x15C,0,SetTo,SourceVA[1],SourceVA[2],0,0,SourceVA[3]);
			},
			flag = {Preserved}
		}
	elseif SourceVA[4] == "VA" then
		local TempRet = {"X",FBYTE[1],0,"V"}
		TMem(PlayerID,TempRet,SourceVA,0,0,1)
		Trigger {--(CPRead)로 값 출력
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0x6509B0,SetTo,SourceVA[5][1],SourceVA[5][2],0,1,SourceVA[5][3]); 
					SetMemory(0x6509B0,Add,SourceVA[6]);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x148,SourceVA[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x160,SourceVA[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x158,SourceVA[3],SetTo,EPD(0x6509B0)); 
					CallLabelAlways(SourceVA[1],SourceVA[2],SourceVA[3]);
				},
				flag = {Preserved}
		}
	end


	if type(Dest) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FBYTE[2],0x15C,0,SetTo,Dest);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then
		local TempRet = {"X",FBYTE[2],0,"V"}
		MovX(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FBYTE[2],0x15C,1,0);
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Dest[1],Dest[2],Dest[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FBYTE[2],0x15C,0,SetTo,Dest[1],Dest[2],Dest[3],0,Dest[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FBYTE[3],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FBYTE[3],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FBYTE[3],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if Distance == nil then
		Distance = 1
	end
	-- Call f_Bytecpy
	local Temp = {}
	for k, v in pairs(FBYTEArr) do
		table.insert(Temp,SetCtrig1X("X",v[1],v[2],0,SetTo,Distance))
	end
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FBYTECall0,0x0,0,0);
					SetCtrigX("X",FBYTECall2,0x4,0,SetTo,"X","X",0x0,0,1);
					Temp,
				},
				flag = {Preserved}
			}
	if FBYTECall1 == 0 then
		Need_Include_DataTransfer()
	end

	RecoverCp(PlayerID)
end

function f_bytecpyX(PlayerID,Dest,DestX,SourceVA,Size,Distance)
	FBYTECheck = 1
	STPopTrigArr(PlayerID)

	if SourceVA[4] == "V" then -- ※ MovX는 CPRead방식으로 Cp값 변경하므로 Cp값 자체를 전달하는 SourceVA인자는 맨 밑에 있어야함
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig2X(0x6509B0,SetTo,SourceVA[1],SourceVA[2],0,1,SourceVA[3]); -- VArray Header +0x0
				SetCtrigX("X",FBYTE[1],0x15C,0,SetTo,SourceVA[1],SourceVA[2],0,0,SourceVA[3]);
			},
			flag = {Preserved}
		}
	elseif SourceVA[4] == "VA" then
		local TempRet = {"X",FBYTE[1],0,"V"}
		TMem(PlayerID,TempRet,SourceVA,0,0,1)
		Trigger {--(CPRead)로 값 출력
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0x6509B0,SetTo,SourceVA[5][1],SourceVA[5][2],0,1,SourceVA[5][3]); 
					SetMemory(0x6509B0,Add,SourceVA[6]);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x148,SourceVA[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x160,SourceVA[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x158,SourceVA[3],SetTo,EPD(0x6509B0)); 
					CallLabelAlways(SourceVA[1],SourceVA[2],SourceVA[3]);
				},
				flag = {Preserved}
		}
	end

	if type(Dest) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FBYTE[2],0x15C,0,SetTo,Dest);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then
		local TempRet = {"X",FBYTE[2],0,"V"}
		MovX(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FBYTE[2],0x15C,1,0);
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Dest[1],Dest[2],Dest[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FBYTE[2],0x15C,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
			},
			flag = {Preserved}
		}
	end

	if type(DestX) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FBYTE[4],0x15C,0,SetTo,DestX);
			},
			flag = {Preserved}
		}
	elseif DestX[4] == "VA" then
		local TempRet = {"X",FBYTE[4],0,"V"}
		MovX(PlayerID,TempRet,DestX)
		DestX = TempRet
	elseif DestX[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(DestX[1],DestX[2],0x158,DestX[3],SetTo,"X",FBYTE[4],0x15C,1,0);
				SetCtrig1X(DestX[1],DestX[2],0x148,DestX[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(DestX[1],DestX[2],0x160,DestX[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(DestX[1],DestX[2],DestX[3]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FBYTE[3],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FBYTE[3],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FBYTE[3],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if Distance == nil then
		Distance = 1
	end
	-- Call f_Bytecpy
	local Temp = {}
	for k, v in pairs(FBYTEArr) do
		table.insert(Temp,SetCtrig1X("X",v[1],v[2],0,SetTo,Distance))
	end
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FBYTECall1,0x0,0,0);
					SetCtrigX("X",FBYTECall2,0x4,0,SetTo,"X","X",0x0,0,1);
					Temp,
				},
				flag = {Preserved}
			}
	if FBYTECall1 == 0 then
		Need_Include_DataTransfer()
	end

	RecoverCp(PlayerID)
end

function f_bytecmp(PlayerID,CFlag,Dest,SourceVA,Size,Distance)
	FCONDCheck = 1
	-- SourceVA << VArray / Dest <<  Offset / Size << Offset / Distance
	STPopTrigArr(PlayerID)
	if Distance == "X" then
		Distance = nil
	end
	if SourceVA[4] == "V" then -- ※ MovX는 CPRead방식으로 Cp값 변경하므로 Cp값 자체를 전달하는 SourceVA인자는 맨 밑에 있어야함
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig2X(0x6509B0,SetTo,SourceVA[1],SourceVA[2],0,1,SourceVA[3]); -- VArray Header +0x0
				SetCtrigX("X",FCOND[1],0x15C,0,SetTo,SourceVA[1],SourceVA[2],0,0,SourceVA[3]);
			},
			flag = {Preserved}
		}
	elseif SourceVA[4] == "VA" then
		local TempRet = {"X",FCOND[1],0,"V"}
		TMem(PlayerID,TempRet,SourceVA,0,0,1)
		Trigger {--(CPRead)로 값 출력
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0x6509B0,SetTo,SourceVA[5][1],SourceVA[5][2],0,1,SourceVA[5][3]); 
					SetMemory(0x6509B0,Add,SourceVA[6]);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x148,SourceVA[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x160,SourceVA[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x158,SourceVA[3],SetTo,EPD(0x6509B0)); 
					CallLabelAlways(SourceVA[1],SourceVA[2],SourceVA[3]);
				},
				flag = {Preserved}
		}
	end


	if type(Dest) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCOND[2],0x15C,0,SetTo,Dest);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then
		local TempRet = {"X",FCOND[2],0,"V"}
		MovX(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FCOND[2],0x15C,1,0);
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Dest[1],Dest[2],Dest[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FCOND[2],0x15C,0,SetTo,Dest[1],Dest[2],Dest[3],0,Dest[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCOND[3],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FCOND[3],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FCOND[3],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	local Clear = {}
	if type(CFlag) == "table" then
		CFlag = CFlag[1]
	else
		table.insert(Clear,SetCDeaths("X",SetTo,0,CFlag))
	end

	if Distance == nil then
		Distance = 1
	end
	-- Call f_Bytecmp
	local Temp = {}
	for k, v in pairs(FCONDArr) do
		table.insert(Temp,SetCtrig1X("X",v[1],v[2],0,SetTo,Distance))
	end
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					Clear,					
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCONDCall0,0x0,0,0);
					SetCtrigX("X",FCONDCall2,0x4,0,SetTo,"X","X",0x0,0,1); -- True
					SetCtrigX("X",FCONDCall3,0x4,0,SetTo,"X","X",0x0,0,2); -- False
					Temp,
				},
				flag = {Preserved}
			}
	if FCONDCall1 == 0 then
		Need_Include_DataTransfer()
	end

	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCDeaths("X",SetTo,1,CFlag);
				},
				flag = {Preserved}
			}

	RecoverCp(PlayerID)
end

function f_bytecmpX(PlayerID,CFlag,Dest,DestX,SourceVA,Size,Distance)
	FCONDCheck = 1
	STPopTrigArr(PlayerID)
	if Distance == "X" then
		Distance = nil
	end
	if SourceVA[4] == "V" then -- ※ MovX는 CPRead방식으로 Cp값 변경하므로 Cp값 자체를 전달하는 SourceVA인자는 맨 밑에 있어야함
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig2X(0x6509B0,SetTo,SourceVA[1],SourceVA[2],0,1,SourceVA[3]); -- VArray Header +0x0
				SetCtrigX("X",FCOND[1],0x15C,0,SetTo,SourceVA[1],SourceVA[2],0,0,SourceVA[3]);
			},
			flag = {Preserved}
		}
	elseif SourceVA[4] == "VA" then
		local TempRet = {"X",FCOND[1],0,"V"}
		TMem(PlayerID,TempRet,SourceVA,0,0,1)
		Trigger {--(CPRead)로 값 출력
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0x6509B0,SetTo,SourceVA[5][1],SourceVA[5][2],0,1,SourceVA[5][3]); 
					SetMemory(0x6509B0,Add,SourceVA[6]);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x148,SourceVA[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x160,SourceVA[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(SourceVA[1],SourceVA[2],0x158,SourceVA[3],SetTo,EPD(0x6509B0)); 
					CallLabelAlways(SourceVA[1],SourceVA[2],SourceVA[3]);
				},
				flag = {Preserved}
		}
	end

	if type(Dest) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCOND[2],0x15C,0,SetTo,Dest);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then
		local TempRet = {"X",FCOND[2],0,"V"}
		MovX(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FCOND[2],0x15C,1,0);
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Dest[1],Dest[2],Dest[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FCOND[2],0x15C,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
			},
			flag = {Preserved}
		}
	end

	if type(DestX) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCOND[4],0x15C,0,SetTo,DestX);
			},
			flag = {Preserved}
		}
	elseif DestX[4] == "VA" then
		local TempRet = {"X",FCOND[4],0,"V"}
		MovX(PlayerID,TempRet,DestX)
		DestX = TempRet
	elseif DestX[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(DestX[1],DestX[2],0x158,DestX[3],SetTo,"X",FCOND[4],0x15C,1,0);
				SetCtrig1X(DestX[1],DestX[2],0x148,DestX[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(DestX[1],DestX[2],0x160,DestX[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(DestX[1],DestX[2],DestX[3]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FCOND[3],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FCOND[3],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FCOND[3],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	local Clear = {}
	if type(CFlag) == "table" then
		CFlag = CFlag[1]
	else
		table.insert(Clear,SetCDeaths("X",SetTo,0,CFlag))
	end

	if Distance == nil then
		Distance = 1
	end
	-- Call f_Bytecpy
	local Temp = {}
	for k, v in pairs(FCONDArr) do
		table.insert(Temp,SetCtrig1X("X",v[1],v[2],0,SetTo,Distance))
	end
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					Clear,
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCONDCall1,0x0,0,0);
					SetCtrigX("X",FCONDCall2,0x4,0,SetTo,"X","X",0x0,0,1); -- True
					SetCtrigX("X",FCONDCall3,0x4,0,SetTo,"X","X",0x0,0,2); -- False
					Temp,
				},
				flag = {Preserved}
			}
	if FCONDCall1 == 0 then
		Need_Include_DataTransfer()
	end

	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCDeaths("X",SetTo,1,CFlag);
				},
				flag = {Preserved}
			}

	RecoverCp(PlayerID)
end

function f_Readcpy(PlayerID,DestVA,Source,Size,InitBytes,Distance) 
	FMEMCheck = 1
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << Dest / CRet[2] << Source / CRet[3] << Size (Offset)

	if InitBytes == nil or InitBytes == "X" then
		InitBytes = 0
	end
	if InitBytes >= 4 then
		f_Readcpy_InputData_Error()
	end
	if DestVA[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEM[1],0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]);
				SetCtrig1X("X",FMEM[3],0x15C,0,SetTo,InitBytes);
			},
			flag = {Preserved}
		}
	elseif DestVA[4] == "VA" then
		local TempRet = {"X",FMEM[1],0,"V"}
		MovZ(PlayerID,TempRet,DestVA,0x15C)
		DestVA = TempRet
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[3],0x15C,0,SetTo,InitBytes);
			},
			flag = {Preserved}
		}
	end

	if type(Source) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[2],0x15C,0,SetTo,Source);
			},
			flag = {Preserved}
		}
	elseif Source[4] == "VA" then
		local TempRet = {"X",FMEM[2],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "A" then
		local TempRet = {"X",FMEM[2],0,"V"}
		TMem(PlayerID,TempRet,Source,nil,nil,1)
		Source = TempRet
	elseif Source[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FMEM[2],0x15C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEM[2],0x15C,0,SetTo,Source[1],Source[2],Source[3],0,Source[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[5],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FMEM[5],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FMEM[5],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if Distance == nil then
		Distance = 1
	end
	-- Call f_Memcpy
	local Temp1 = {}
	for k, v in pairs(FMEMArr1) do
		table.insert(Temp1,SetCtrig1X("X",v[1],v[2],0,SetTo,604))
	end
	local Temp2 = {}
	for k, v in pairs(FMEMArr2) do
		table.insert(Temp2,SetCtrig1X("X",v[1],v[2],0,SetTo,Distance))
	end
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FMEMCall0,0x0,0,0);
					SetCtrigX("X",FMEMCall2,0x4,0,SetTo,"X","X",0x0,0,1);
					SetCtrig1X("X",FMEM[6],0x15C,0,SetTo,1);
					Temp1,
					Temp2,
				},
				flag = {Preserved}
			}
	if FMEMCall1 == 0 then
		Need_Include_DataTransferX()
	end
end

function f_ReadcpyX(PlayerID,DestVA,Source,SourceX,Size,InitBytes,Distance) 
	FMEMCheck = 1
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << Dest / CRet[2] << Source / CRet[3] << Size (Offset)
	if InitBytes == nil or InitBytes == "X" then
		InitBytes = 0
	end
	if InitBytes >= 4 then
		f_ReadcpyX_InputData_Error()
	end
	if DestVA[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEM[1],0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]);
				SetCtrig1X("X",FMEM[3],0x15C,0,SetTo,InitBytes);
			},
			flag = {Preserved}
		}
	elseif DestVA[4] == "VA" then
		local TempRet = {"X",FMEM[1],0,"V"}
		MovZ(PlayerID,TempRet,DestVA,0x15C)
		DestVA = TempRet
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[3],0x15C,0,SetTo,InitBytes);
			},
			flag = {Preserved}
		}
	end

	if type(Source) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[2],0x15C,0,SetTo,Source);
			},
			flag = {Preserved}
		}
	elseif Source[4] == "VA" then
		local TempRet = {"X",FMEM[2],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "A" then
		local TempRet = {"X",FMEM[2],0,"V"}
		MovZ(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FMEM[2],0x15C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEM[2],0x15C,0,SetTo,Source[1],Source[2],Source[3],1,Source[4]);
			},
			flag = {Preserved}
		}
	end

	if type(SourceX) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[4],0x15C,0,SetTo,SourceX);
			},
			flag = {Preserved}
		}
	elseif SourceX[4] == "VA" then
		local TempRet = {"X",FMEM[4],0,"V"}
		MovX(PlayerID,TempRet,SourceX)
		SourceX = TempRet
	elseif SourceX[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(SourceX[1],SourceX[2],0x158,SourceX[3],SetTo,"X",FMEM[4],0x15C,1,0);
				SetCtrig1X(SourceX[1],SourceX[2],0x148,SourceX[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(SourceX[1],SourceX[2],0x160,SourceX[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(SourceX[1],SourceX[2],SourceX[3]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[5],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FMEM[5],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FMEM[5],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if Distance == nil then
		Distance = 1
	end
	-- Call f_Memcpy
	local Temp1 = {}
	for k, v in pairs(FMEMArr1) do
		table.insert(Temp1,SetCtrig1X("X",v[1],v[2],0,SetTo,604))
	end
	local Temp2 = {}
	for k, v in pairs(FMEMArr2) do
		table.insert(Temp2,SetCtrig1X("X",v[1],v[2],0,SetTo,Distance))
	end
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FMEMCall1,0x0,0,0);
					SetCtrigX("X",FMEMCall2,0x4,0,SetTo,"X","X",0x0,0,1);
					SetCtrig1X("X",FMEM[6],0x15C,0,SetTo,1);
					Temp1,
					Temp2,
				},
				flag = {Preserved}
			}
	if FMEMCall1 == 0 then
		Need_Include_DataTransferX()
	end
end

function f_Memcpy(PlayerID,Dest,Source,Size,DestDistance,SourceDistance) 
	FMEMCheck = 1
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << Dest / CRet[2] << Source / CRet[3] << Size (Offset)
	if type(Dest) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[1],0x15C,0,SetTo,Dest);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then
		local TempRet = {"X",FMEM[1],0,"V"}
		MovX(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "A" then
		local TempRet = {"X",FMEM[1],0,"V"}
		TMem(PlayerID,TempRet,Dest,nil,nil,1)
		Dest = TempRet
	elseif Dest[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FMEM[1],0x15C,1,0);
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Dest[1],Dest[2],Dest[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEM[1],0x15C,0,SetTo,Dest[1],Dest[2],Dest[3],0,Dest[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Source) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[2],0x15C,0,SetTo,Source);
			},
			flag = {Preserved}
		}
	elseif Source[4] == "VA" then
		local TempRet = {"X",FMEM[2],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "A" then
		local TempRet = {"X",FMEM[2],0,"V"}
		TMem(PlayerID,TempRet,Source,nil,nil,1)
		Source = TempRet
	elseif Source[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FMEM[2],0x15C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEM[2],0x15C,0,SetTo,Source[1],Source[2],Source[3],0,Source[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[5],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FMEM[5],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FMEM[5],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if DestDistance == nil then
		DestDistance = 1
	end
	if SourceDistance == nil then
		SourceDistance = 1
	end
	-- Call f_Memcpy
	local Temp1 = {}
	for k, v in pairs(FMEMArr1) do
		table.insert(Temp1,SetCtrig1X("X",v[1],v[2],0,SetTo,DestDistance))
	end
	local Temp2 = {}
	for k, v in pairs(FMEMArr2) do
		table.insert(Temp2,SetCtrig1X("X",v[1],v[2],0,SetTo,SourceDistance))
	end
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FMEMCall0,0x0,0,0);
					SetCtrigX("X",FMEMCall2,0x4,0,SetTo,"X","X",0x0,0,1);
					SetCtrig1X("X",FMEM[6],0x15C,0,SetTo,0);
					Temp1,
					Temp2,
				},
				flag = {Preserved}
			}
	if FMEMCall1 == 0 then
		Need_Include_DataTransferX()
	end
end

function f_MemcpyX(PlayerID,Dest,DestX,Source,SourceX,Size,DestDistance,SourceDistance)
	FMEMCheck = 1
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << Dest / CRet[2] << Source / CRet[3] << Size (Offset)
	if type(Dest) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[1],0x15C,0,SetTo,Dest);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then
		local TempRet = {"X",FMEM[1],0,"V"}
		MovX(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "A" then
		local TempRet = {"X",FMEM[1],0,"V"}
		MovZ(PlayerID,TempRet,Dest)
		Dest = TempRet
	elseif Dest[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FMEM[1],0x15C,1,0);
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Dest[1],Dest[2],Dest[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEM[1],0x15C,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Source) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[2],0x15C,0,SetTo,Source);
			},
			flag = {Preserved}
		}
	elseif Source[4] == "VA" then
		local TempRet = {"X",FMEM[2],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "A" then
		local TempRet = {"X",FMEM[2],0,"V"}
		MovZ(PlayerID,TempRet,Source)
		Source = TempRet
	elseif Source[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FMEM[2],0x15C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	else -- Mem
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FMEM[2],0x15C,0,SetTo,Source[1],Source[2],Source[3],1,Source[4]);
			},
			flag = {Preserved}
		}
	end

	if type(DestX) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[3],0x15C,0,SetTo,DestX);
			},
			flag = {Preserved}
		}
	elseif DestX[4] == "VA" then
		local TempRet = {"X",FMEM[3],0,"V"}
		MovX(PlayerID,TempRet,DestX)
		DestX = TempRet
	elseif DestX[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(DestX[1],DestX[2],0x158,DestX[3],SetTo,"X",FMEM[3],0x15C,1,0);
				SetCtrig1X(DestX[1],DestX[2],0x148,DestX[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(DestX[1],DestX[2],0x160,DestX[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(DestX[1],DestX[2],DestX[3]);
			},
			flag = {Preserved}
		}
	end

	if type(SourceX) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[4],0x15C,0,SetTo,SourceX);
			},
			flag = {Preserved}
		}
	elseif SourceX[4] == "VA" then
		local TempRet = {"X",FMEM[4],0,"V"}
		MovX(PlayerID,TempRet,SourceX)
		SourceX = TempRet
	elseif SourceX[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(SourceX[1],SourceX[2],0x158,SourceX[3],SetTo,"X",FMEM[4],0x15C,1,0);
				SetCtrig1X(SourceX[1],SourceX[2],0x148,SourceX[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(SourceX[1],SourceX[2],0x160,SourceX[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(SourceX[1],SourceX[2],SourceX[3]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FMEM[5],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "VA" then
		local TempRet = {"X",FMEM[5],0,"V"}
		MovX(PlayerID,TempRet,Size)
		Size = TempRet
	elseif Size[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FMEM[5],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if DestDistance == nil then
		DestDistance = 1
	end
	if SourceDistance == nil then
		SourceDistance = 1
	end
	-- Call f_Memcpy
	local Temp1 = {}
	for k, v in pairs(FMEMArr1) do
		table.insert(Temp1,SetCtrig1X("X",v[1],v[2],0,SetTo,DestDistance))
	end
	local Temp2 = {}
	for k, v in pairs(FMEMArr2) do
		table.insert(Temp2,SetCtrig1X("X",v[1],v[2],0,SetTo,SourceDistance))
	end
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FMEMCall1,0x0,0,0);
					SetCtrigX("X",FMEMCall2,0x4,0,SetTo,"X","X",0x0,0,1);
					SetCtrig1X("X",FMEM[6],0x15C,0,SetTo,0);
					Temp1,
					Temp2,
				},
				flag = {Preserved}
			}
	if FMEMCall1 == 0 then
		Need_Include_DataTransferX()
	end
end

-- Include MiscFunc

function f_GetTblptr(PlayerID,Output,TBLIndex)
	FPTBLCheck = 1
	STPopTrigArr(PlayerID)

	-- Input Data CRet[1],CRet[2] << TBL Index
	if type(TBLIndex) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FPTBL[1],0x15C,0,SetTo,TBLIndex/2);
				SetCtrig1X("X",FPTBL[2],0x15C,0,SetTo,TBLIndex%2);
			},
			flag = {Preserved}
		}

		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FPTBLCall1,0x0,0,0);
				SetCtrigX("X",FPTBLCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}
	else
		if TBLIndex[4] == "VA" then
			local TempRet = {"X",FPTBL[2],0,"V"}
			MovX(PlayerID,TempRet,TBLIndex,SetTo,0xFFFF)
			TBLIndex = TempRet
		elseif TBLIndex[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(TBLIndex[1],TBLIndex[2],0x158,TBLIndex[3],SetTo,"X",FPTBL[2],0x15C,1,0);
					SetCtrig1X(TBLIndex[1],TBLIndex[2],0x148,TBLIndex[3],SetTo,0xFFFF);
					SetCtrig1X(TBLIndex[1],TBLIndex[2],0x160,TBLIndex[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(TBLIndex[1],TBLIndex[2],TBLIndex[3]);
				},
				flag = {Preserved}
			}
		end

		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FPTBLCall0,0x0,0,0);
				SetCtrigX("X",FPTBLCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}
	end
	
-- Call f_GetTBLptr
	if FPTBLCall1 == 0 then
		Need_Include_MiscFunc()
	end

	-- Output Data CRet[2] = Output 
	if type(Output) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",FPTBL[3],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",FPTBL[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FPTBL[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FPTBL[3],0);
						},
						flag = {Preserved}
					}
	else
		if Output[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FPTBL[3],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",FPTBL[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FPTBL[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FPTBL[3],0);
						},
						flag = {Preserved}
					}
		elseif Output[4] == "VA" then
				local TempRet = {"X",FPTBL[3],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,0xFFFFFFFF)
		elseif Output[4] == "A" then
				local TempRet = {"X",FPTBL[3],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FPTBL[3],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",FPTBL[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FPTBL[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FPTBL[3],0);
						},
						flag = {Preserved}
					}
		end
	end

	RecoverCp(PlayerID)
end

function f_GetiStrXepd(PlayerID,Output,StringId)
	STPopTrigArr(PlayerID)
	local StringKey
	-- Input Data CRet[1] << StringId
	if type(StringId) == "number" then
		StringKey = StringId
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FISTRX[1],0x15C,0,SetTo,StringKey);
			},
			flag = {Preserved}
		}
	elseif type(StringId) == "string" then
		StringKey = ParseString(StringId)
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				Disabled(DisplayText(StringKey,4));
				SetCtrig1X("X",FISTRX[1],0x15C,0,SetTo,StringKey);
			},
			flag = {Preserved}
		}
	else
		if StringId[4] == "VA" then
			local TempRet = {"X",FISTRX[1],0,"V"}
			MovX(PlayerID,TempRet,StringId)
			StringId = TempRet
		elseif StringId[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(StringId[1],StringId[2],0x158,StringId[3],SetTo,"X",FISTRX[1],0x15C,1,0);
					SetCtrig1X(StringId[1],StringId[2],0x148,StringId[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(StringId[1],StringId[2],0x160,StringId[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(StringId[1],StringId[2],StringId[3]);
				},
				flag = {Preserved}
			}
		end
	end

	
	
-- Call f_GetiStrXepd
	if FISTRXCall1 == 0 then
		Need_Include_MiscFunc()
	end

	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FISTRXCall1,0x0,0,0);
				SetCtrigX("X",FISTRXCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}
	FISTRXCheck = 1

	-- Output Data CRet[2] = Output 
	if type(Output) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",FISTRX[2],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",FISTRX[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FISTRX[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FISTRX[2],0);
						},
						flag = {Preserved}
					}
	else
		if Output[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FISTRX[2],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",FISTRX[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FISTRX[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FISTRX[2],0);
						},
						flag = {Preserved}
					}
		elseif Output[4] == "VA" then
				local TempRet = {"X",FISTRX[2],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,0xFFFFFFFF)
		elseif Output[4] == "A" then
				local TempRet = {"X",FISTRX[2],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FISTRX[2],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",FISTRX[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FISTRX[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FISTRX[2],0);
						},
						flag = {Preserved}
					}
		end
	end

	RecoverCp(PlayerID)
	return StringKey
end


function f_GetStrXptr(PlayerID,Output,StringId)
	FPSTRXCheck = 1
	STPopTrigArr(PlayerID)
	local StringKey
	-- Input Data CRet[1] << StringId
	if type(StringId) == "number" then
		StringKey = StringId
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FPSTRX[1],0x15C,0,SetTo,StringKey);
			},
			flag = {Preserved}
		}
	elseif type(StringId) == "string" then
		StringKey = ParseString(StringId)
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				Disabled(DisplayText(StringKey,4));
				SetCtrig1X("X",FPSTRX[1],0x15C,0,SetTo,StringKey);
			},
			flag = {Preserved}
		}
	else
		if StringId[4] == "VA" then
			local TempRet = {"X",FPSTRX[1],0,"V"}
			MovX(PlayerID,TempRet,StringId)
			StringId = TempRet
		elseif StringId[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(StringId[1],StringId[2],0x158,StringId[3],SetTo,"X",FPSTRX[1],0x15C,1,0);
					SetCtrig1X(StringId[1],StringId[2],0x148,StringId[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(StringId[1],StringId[2],0x160,StringId[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(StringId[1],StringId[2],StringId[3]);
				},
				flag = {Preserved}
			}
		end
	end

	
	
-- Call f_GetStrXptr
	if FPSTRXCall1 == 0 then
		Need_Include_MiscFunc()
	end

	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FPSTRXCall1,0x0,0,0);
				SetCtrigX("X",FPSTRXCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}

	-- Output Data CRet[2] = Output 
	if type(Output) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",FPSTRX[2],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",FPSTRX[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FPSTRX[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FPSTRX[2],0);
						},
						flag = {Preserved}
					}
	else
		if Output[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FPSTRX[2],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",FPSTRX[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FPSTRX[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FPSTRX[2],0);
						},
						flag = {Preserved}
					}
		elseif Output[4] == "VA" then
				local TempRet = {"X",FPSTRX[2],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,0xFFFFFFFF)
		elseif Output[4] == "A" then
				local TempRet = {"X",FPSTRX[2],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FPSTRX[2],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",FPSTRX[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FPSTRX[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FPSTRX[2],0);
						},
						flag = {Preserved}
					}
		end
	end

	RecoverCp(PlayerID)
	return StringKey
end

function f_GetStrptr(PlayerID,Output,StringId)
	FPSTRCheck = 1
	STPopTrigArr(PlayerID)
	local StringKey
	-- Input Data CRet[1],CRet[2] << StringId
	if type(StringId) == "number" then
		StringKey = StringId
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FPSTR[1],0x15C,0,SetTo,StringKey/2);
					SetCtrig1X("X",FPSTR[2],0x15C,0,SetTo,StringKey%2);
				},
				flag = {Preserved}
			}
	
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FPSTRCall1,0x0,0,0);
				SetCtrigX("X",FPSTRCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}
	elseif type(StringId) == "string" then
		StringKey = ParseString(StringId)
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					Disabled(DisplayText(StringKey,4));
					SetCtrig1X("X",FPSTR[1],0x15C,0,SetTo,StringKey/2);
					SetCtrig1X("X",FPSTR[2],0x15C,0,SetTo,StringKey%2);
				},
				flag = {Preserved}
			}
	
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FPSTRCall1,0x0,0,0);
				SetCtrigX("X",FPSTRCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}
	else
		if StringId[4] == "VA" then
			local TempRet = {"X",FPSTR[2],0,"V"}
			MovX(PlayerID,TempRet,StringId,SetTo,0xFFFF)
			StringId = TempRet
		elseif StringId[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(StringId[1],StringId[2],0x158,StringId[3],SetTo,"X",FPSTR[2],0x15C,1,0);
					SetCtrig1X(StringId[1],StringId[2],0x148,StringId[3],SetTo,0xFFFF);
					SetCtrig1X(StringId[1],StringId[2],0x160,StringId[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(StringId[1],StringId[2],StringId[3]);
				},
				flag = {Preserved}
			}
		end

		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FPSTRCall0,0x0,0,0);
				SetCtrigX("X",FPSTRCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}
	end
	
-- Call f_GetStrptr
	if FPSTRCall1 == 0 then
		Need_Include_MiscFunc()
	end

	-- Output Data CRet[3] = Output 
	if type(Output) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",FPSTR[3],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",FPSTR[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FPSTR[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FPSTR[3],0);
						},
						flag = {Preserved}
					}
	else
		if Output[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FPSTR[3],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",FPSTR[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FPSTR[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FPSTR[3],0);
						},
						flag = {Preserved}
					}
		elseif Output[4] == "VA" then
				local TempRet = {"X",FPSTR[3],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,0xFFFFFFFF)
		elseif Output[4] == "A" then
				local TempRet = {"X",FPSTR[3],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FPSTR[3],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",FPSTR[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FPSTR[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FPSTR[3],0);
						},
						flag = {Preserved}
					}
		end
	end

	RecoverCp(PlayerID)
	return StringKey
end

function f_GetiStrptr(PlayerID,Output,StringId)
	if STRXFlag == 0 then -- STR Table
		return f_GetStrptr(PlayerID,Output,StringId)
	else -- STRX Table
		return f_GetStrXptr(PlayerID,Output,StringId)
	end
end

function f_InitiStrptr(PlayerID,Output,StringOffset,Size)
	-- Input Data CRet[1],CRet[4] << StringOffset, Size
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",ISTR[4],0x15C,0,SetTo,Size);
				SetCtrigX(StringOffset[1],StringOffset[2],0x158,StringOffset[3],SetTo,"X",ISTR[1],0x15C,1,0);
				SetCtrig1X(StringOffset[1],StringOffset[2],0x148,StringOffset[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(StringOffset[1],StringOffset[2],0x160,StringOffset[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(StringOffset[1],StringOffset[2],StringOffset[3]);
			},
			flag = {Preserved}
		}

	------------------------------------------------------------

		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",ISTRCall1,0x0,0,0);
				SetCtrigX("X",ISTRCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}

	
    -- Call f_InitiStrptr
	if ISTRCall1 == 0 then
		Need_Include_MiscFunc()
	end

	-- Output Data CRet[5] = Output (StringEPD)
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",ISTR[5],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
				SetCtrig1X("X",ISTR[5],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",ISTR[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",ISTR[5],0);
			},
			flag = {Preserved}
		}
	ISTRCheck = 1
end

function f_InitiTblptr(PlayerID,Output,TBLOffset,Size,TBLIndex)
	-- Input Data CRet[1],CRet[4] << StringOffset, Size
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",ITBL[6],0x15C,0,SetTo,TBLIndex/2+0x62FE8BF);
				SetCtrig1X("X",ITBL[7],0x15C,0,SetTo,TBLIndex%2);
			},
			flag = {Preserved}
		}

		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",ITBL[4],0x15C,0,SetTo,Size);
				SetCtrigX(TBLOffset[1],TBLOffset[2],0x158,TBLOffset[3],SetTo,"X",ITBL[1],0x15C,1,0);
				SetCtrig1X(TBLOffset[1],TBLOffset[2],0x148,TBLOffset[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(TBLOffset[1],TBLOffset[2],0x160,TBLOffset[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(TBLOffset[1],TBLOffset[2],TBLOffset[3]);
			},
			flag = {Preserved}
		}

	------------------------------------------------------------

		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",ITBLCall1,0x0,0,0);
				SetCtrigX("X",ITBLCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}

	
    -- Call f_InitiStrptr
	if ITBLCall1 == 0 then
		Need_Include_MiscFunc()
	end

	-- Output Data CRet[5] = Output (TBLEPD), CRet[6] = PointerEPD, CRet[7] = PointerEPDX
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",ITBL[5],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
				SetCtrig1X("X",ITBL[5],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",ITBL[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",ITBL[5],0);
			},
			flag = {Preserved}
		}
	ITBLCheck = 1
end


function f_Rand(PlayerID,Dest,Mask)
	STPopTrigArr(PlayerID)
	if Mask == nil or "X" then
		Mask = 0xFFFFFFFF
	end

-- Call f_Rand
	if FRANDCall1 == 0 then
		Need_Include_MiscFunc()
	end

	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FRANDCall1,0x0,0,0);
				SetCtrigX("X",FRANDCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}

-- Output Data CRet[1] = Output 
	if type(Dest) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",FRAND,0x158,0,SetTo,EPD(Dest));
						SetCtrig1X("X",FRAND,0x148,0,SetTo,Mask);
						SetCtrig1X("X",FRAND,0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FRAND,0);
						},
						flag = {Preserved}
					}
	else
		if Dest[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FRAND,0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",FRAND,0x148,0,SetTo,Mask);
						SetCtrig1X("X",FRAND,0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FRAND,0);
						},
						flag = {Preserved}
					}
		elseif Dest[4] == "VA" then
				local TempRet = {"X",FRAND,0,"V"}
				MovX(PlayerID,Dest,TempRet,SetTo,Mask)
		elseif Dest[4] == "A" then
				local TempRet = {"X",FRAND,0,"V"}
				MovX(PlayerID,Dest,TempRet,SetTo,Mask)
		else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FRAND,0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
						SetCtrig1X("X",FRAND,0x148,0,SetTo,Mask);
						SetCtrig1X("X",FRAND,0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FRAND,0);
						},
						flag = {Preserved}
					}
		end
	end
end

-- Include MatheMatics

function f_Log2(PlayerID,Dest,Source)
	FLOG2Check = 1
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << X 
	if type(Source) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",FLOG2[1],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
	else
		if Source[4] == "VA" then
			local TempRet = {"X",FLOG2[1],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		elseif Source[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FLOG2[1],0x15C,1,0);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
		end
	end

-- Call f_Log2
	if FLOG2Call1 == 0 then
		Need_Include_MatheMatics()
	end
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FLOG2Call1,0x0,0,0);
				SetCtrigX("X",FLOG2Call2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}

-- Output Data CRet[2] = Output 
	if type(Dest) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",FLOG2[2],0x158,0,SetTo,EPD(Dest));
						SetCtrig1X("X",FLOG2[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLOG2[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FLOG2[2],0);
						},
						flag = {Preserved}
					}
	else
		if Dest[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FLOG2[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",FLOG2[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLOG2[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FLOG2[2],0);
						},
						flag = {Preserved}
					}
		elseif Dest[4] == "VA" then
				local TempRet = {"X",FLOG2[2],0,"V"}
				MovX(PlayerID,Dest,TempRet,SetTo,0xFFFFFFFF)
		elseif Dest[4] == "A" then
				local TempRet = {"X",FLOG2[2],0,"V"}
				MovX(PlayerID,Dest,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FLOG2[2],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
						SetCtrig1X("X",FLOG2[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLOG2[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FLOG2[2],0);
						},
						flag = {Preserved}
					}
		end
	end
end

function f_Atan2(PlayerID,DeltaY,DeltaX,AngleOutput) -- 0xFFFF8000 <= X, Y <= 0x7FFF (-32768~+32767)
	FATANCheck = 1
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << DeltaY
	if type(DeltaY) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FATAN[1],0x15C,0,SetTo,DeltaY);
			},
			flag = {Preserved}
		}
	elseif DeltaY[4] == "VA" then
		local TempRet = {"X",FATAN[1],0,"V"}
		MovX(PlayerID,TempRet,DeltaY)
		DeltaY = TempRet
	elseif DeltaY[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(DeltaY[1],DeltaY[2],0x158,DeltaY[3],SetTo,"X",FATAN[1],0x15C,1,0);
				SetCtrig1X(DeltaY[1],DeltaY[2],0x148,DeltaY[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(DeltaY[1],DeltaY[2],0x160,DeltaY[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(DeltaY[1],DeltaY[2],DeltaY[3]);
			},
			flag = {Preserved}
		}
	end

	-- Input Data CRet[2] << DeltaX 
	if type(DeltaX) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FATAN[2],0x15C,0,SetTo,DeltaX);
			},
			flag = {Preserved}
		}
	elseif DeltaX[4] == "VA" then
		local TempRet = {"X",FATAN[2],0,"V"}
		MovX(PlayerID,TempRet,DeltaX)
		DeltaX = TempRet
	elseif DeltaX[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(DeltaX[1],DeltaX[2],0x158,DeltaX[3],SetTo,"X",FATAN[2],0x15C,1,0);
				SetCtrig1X(DeltaX[1],DeltaX[2],0x148,DeltaX[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(DeltaX[1],DeltaX[2],0x160,DeltaX[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(DeltaX[1],DeltaX[2],DeltaX[3]);
			},
			flag = {Preserved}
		}
	end

-- Call f_Atan2
	if FATANCall1 == 0 then
		Need_Include_MatheMatics()
	end
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FATANCall1,0x0,0,0);
				SetCtrigX("X",FATANCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}

-- Output Data CRet[3] = AngleOutput 
	if type(AngleOutput) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",FATAN[3],0x158,0,SetTo,EPD(AngleOutput));
						SetCtrig1X("X",FATAN[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FATAN[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FATAN[3],0);
						},
						flag = {Preserved}
					}
	else
		if AngleOutput[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FATAN[3],0x158,0,SetTo,AngleOutput[1],AngleOutput[2],0x15C,1,AngleOutput[3]);
						SetCtrig1X("X",FATAN[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FATAN[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FATAN[3],0);
						},
						flag = {Preserved}
					}
		elseif AngleOutput[4] == "VA" then
				local TempRet = {"X",FATAN[3],0,"V"}
				MovX(PlayerID,AngleOutput,TempRet,SetTo,0xFFFFFFFF)
		elseif AngleOutput[4] == "A" then
				local TempRet = {"X",FATAN[3],0,"V"}
				MovX(PlayerID,AngleOutput,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FATAN[3],0x158,0,SetTo,AngleOutput[1],AngleOutput[2],AngleOutput[3],1,AngleOutput[4]);
						SetCtrig1X("X",FATAN[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FATAN[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FATAN[3],0);
						},
						flag = {Preserved}
					}
		end
	end
end

function f_Lengthdir(PlayerID,Radius,Angle,CosOutput,SinOutput) -- 0xFFFF8000 <= Radius <= 0x7FFF (-32768~+32767)
	FLENGCheck = 1
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << Radius 

	if type(Radius) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FLENG[1],0x15C,0,SetTo,Radius);
			},
			flag = {Preserved}
		}
	elseif Radius[4] == "VA" then
		local TempRet = {"X",FLENG[1],0,"V"}
		MovX(PlayerID,TempRet,Radius)
		Radius = TempRet
	elseif Radius[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Radius[1],Radius[2],0x158,Radius[3],SetTo,"X",FLENG[1],0x15C,1,0);
				SetCtrig1X(Radius[1],Radius[2],0x148,Radius[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Radius[1],Radius[2],0x160,Radius[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Radius[1],Radius[2],Radius[3]);
			},
			flag = {Preserved}
		}
	end
	-- Input Data CRet[2] << Angle 
	if type(Angle) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FLENG[2],0x15C,0,SetTo,Angle);
			},
			flag = {Preserved}
		}
	elseif Angle[4] == "VA" then
		local TempRet = {"X",FLENG[2],0,"V"}
		MovX(PlayerID,TempRet,Angle)
		Angle = TempRet
	elseif Angle[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Angle[1],Angle[2],0x158,Angle[3],SetTo,"X",FLENG[2],0x15C,1,0);
				SetCtrig1X(Angle[1],Angle[2],0x148,Angle[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Angle[1],Angle[2],0x160,Angle[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Angle[1],Angle[2],Angle[3]);
			},
			flag = {Preserved}
		}
	end

-- Call f_Lengthdir
	if FLENGCall1 == 0 then
		Need_Include_MatheMatics()
	end
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FLENGCall1,0x0,0,0);
				SetCtrigX("X",FLENGCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}

-- Output Data CRet[3] = CosOutput 
	if type(CosOutput) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",FLENG[3],0x158,0,SetTo,EPD(CosOutput));
						SetCtrig1X("X",FLENG[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLENG[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FLENG[3],0);
						},
						flag = {Preserved}
					}
	else
		if CosOutput[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FLENG[3],0x158,0,SetTo,CosOutput[1],CosOutput[2],0x15C,1,CosOutput[3]);
						SetCtrig1X("X",FLENG[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLENG[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FLENG[3],0);
						},
						flag = {Preserved}
					}
		elseif CosOutput[4] == "VA" then
				local TempRet = {"X",FLENG[3],0,"V"}
				MovX(PlayerID,CosOutput,TempRet,SetTo,0xFFFFFFFF)
		elseif CosOutput[4] == "A" then
				local TempRet = {"X",FLENG[3],0,"V"}
				MovX(PlayerID,CosOutput,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FLENG[3],0x158,0,SetTo,CosOutput[1],CosOutput[2],CosOutput[3],1,CosOutput[4]);
						SetCtrig1X("X",FLENG[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLENG[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FLENG[3],0);
						},
						flag = {Preserved}
					}
		end
	end
-- Output Data CRet[4] = SinOutput 
	if type(SinOutput) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",FLENG[4],0x158,0,SetTo,EPD(SinOutput));
						SetCtrig1X("X",FLENG[4],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLENG[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FLENG[4],0);
						},
						flag = {Preserved}
					}
	else
		if SinOutput[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FLENG[4],0x158,0,SetTo,SinOutput[1],SinOutput[2],0x15C,1,SinOutput[3]);
						SetCtrig1X("X",FLENG[4],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLENG[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FLENG[4],0);
						},
						flag = {Preserved}
					}
		elseif SinOutput[4] == "VA" then
				local TempRet = {"X",FLENG[4],0,"V"}
				MovX(PlayerID,SinOutput,TempRet,SetTo,0xFFFFFFFF)
		elseif SinOutput[4] == "A" then
				local TempRet = {"X",FLENG[4],0,"V"}
				MovX(PlayerID,SinOutput,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FLENG[4],0x158,0,SetTo,SinOutput[1],SinOutput[2],SinOutput[3],1,SinOutput[4]);
						SetCtrig1X("X",FLENG[4],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLENG[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FLENG[4],0);
						},
						flag = {Preserved}
					}
		end
	end
end

function f_Sqrt(PlayerID,Dest,Source)
	FSQRTCheck = 1
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << X 

	if type(Source) == "number" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FSQRT[1],0x15C,0,SetTo,Source);
				},
				flag = {Preserved}
			}
	else
		if Source[4] == "VA" then
			local TempRet = {"X",FSQRT[1],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		elseif Source[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FSQRT[1],0x15C,1,0);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
		end
	end

-- Call f_Sqrt
	if FSQRTCall1 == 0 then
		Need_Include_MatheMatics()
	end
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FSQRTCall1,0x0,0,0);
				SetCtrigX("X",FSQRTCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}

-- Output Data CRet[2] = Output 
	if type(Dest) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",FSQRT[2],0x158,0,SetTo,EPD(Dest));
						SetCtrig1X("X",FSQRT[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FSQRT[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FSQRT[2],0);
						},
						flag = {Preserved}
					}
	else
		if Dest[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FSQRT[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",FSQRT[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FSQRT[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FSQRT[2],0);
						},
						flag = {Preserved}
					}
		elseif Dest[4] == "VA" then
				local TempRet = {"X",FSQRT[2],0,"V"}
				MovX(PlayerID,Dest,TempRet,SetTo,0xFFFFFFFF)
		elseif Dest[4] == "A" then
				local TempRet = {"X",FSQRT[2],0,"V"}
				MovX(PlayerID,Dest,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",FSQRT[2],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
						SetCtrig1X("X",FSQRT[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FSQRT[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",FSQRT[2],0);
						},
						flag = {Preserved}
					}
		end
	end
end

-- Include DataTransfer

function f_EPD(PlayerID,Dest,Source)
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << X 

	if type(Source) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Source);
			},
			flag = {Preserved}
		}
	else
		if Source[4] == "VA" then
			local TempRet = {"X",CRet[1],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		elseif Source[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
		end
	end

-- Call f_EPD
	if FEPDCall1 == 0 then
		Need_Include_DataTransfer()
	end
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FEPDCall1,0x0,0,0);
				SetCtrigX("X",FEPDCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}

-- Output Data CRet[2] = Output
	if type(Dest) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(Dest));
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
	else
		if Dest[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
		elseif Dest[4] == "VA" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,Dest,TempRet,SetTo,0xFFFFFFFF)
		elseif Dest[4] == "A" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,Dest,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
		end
	end
end

function EPDX(Offset)
	return bit32.band(Offset,0x3)
end

function EPDF(Offset)
	return math.floor(EPD(Offset))
end

function FMemory(offset, comparison, number)
	return Deaths(EPDF(offset),comparison,number,0)
end
function FMemoryX(offset, comparison, number, mask)
	return DeathsX(EPDF(offset),comparison,number,0,mask)
end
function FSetMemory(offset, modtype, number)
	return SetDeaths(EPDF(offset),modtype,number,0)
end
function FSetMemoryX(offset, modtype, number, mask)
	return SetDeathsX(EPDF(offset),modtype,number,0,mask)
end

function SaveStrArr(Dest,StrArr,Distance)
	SaveAct = {}
	if type(Dest) == "number" then
		local Offset = Dest
		local Value = 0
		local t
		if Distance == nil then
			Distance = 4
		else
			Distance = Distance*4
		end
		for i = 1, #StrArr do
			t = i%4
			if t == 1 then
				Value = StrArr[i]
			elseif t == 2 then
				Value = Value + StrArr[i]*256
			elseif t == 3 then
				Value = Value + StrArr[i]*65536
			elseif t == 0 then
				Value = Value + StrArr[i]*16777216
				table.insert(SaveAct,FSetMemory(Offset,SetTo,Value))
				Offset = Offset+Distance
			end
		end	
		if t ~= 0 then
			table.insert(SaveAct,FSetMemory(Offset,SetTo,Value))
		end
	elseif Dest[4] == "V" then
		local Next = Dest[3]
		local Value = 0
		local t
		if Distance == nil then
			Distance = 1
		end
		for i = 1, #StrArr do
			t = i%4
			if t == 1 then
				Value = StrArr[i]
			elseif t == 2 then
				Value = Value + StrArr[i]*256
			elseif t == 3 then
				Value = Value + StrArr[i]*65536
			elseif t == 0 then
				Value = Value + StrArr[i]*16777216
				table.insert(SaveAct,SetCtrig1X(Dest[1],Dest[2],0x15C,Next,SetTo,Value))
				Next = Next+Distance
			end
		end	
		if t ~= 0 then
			table.insert(SaveAct,SetCtrig1X(Dest[1],Dest[2],0x15C,Next,SetTo,Value))
		end
	else
		local Offset = Dest[3]
		local Value = 0
		local t
		if Distance == nil then
			Distance = 4
		else
			Distance = Distance*4
		end
		for i = 1, #StrArr do
			t = i%4
			if t == 1 then
				Value = StrArr[i]
			elseif t == 2 then
				Value = Value + StrArr[i]*256
			elseif t == 3 then
				Value = Value + StrArr[i]*65536
			elseif t == 0 then
				Value = Value + StrArr[i]*16777216
				table.insert(SaveAct,SetCtrig1X(Dest[1],Dest[2],Offset,Dest[4],SetTo,Value))
				Offset = Offset+Distance
			end
		end	
		if t ~= 0 then
			table.insert(SaveAct,SetCtrig1X(Dest[1],Dest[2],Offset,Dest[4],SetTo,Value))
		end
	end

	return SaveAct
end

function f_EPDX(PlayerID,DestX,Source)
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << X 

	if type(Source) == "number" then
		if type(DestX) == "number" then
			Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(DestX,SetTo,0);
							SetMemoryX(DestX,SetTo,bit32.band(DestX,0x3),0x3);
						},
						flag = {Preserved}
					}
		elseif DestX[4] == "V" then
			Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(DestX[1],DestX[2],0x15C,DestX[3],SetTo,0);
							SetCtrig1X(DestX[1],DestX[2],0x15C,DestX[3],SetTo,bit32.band(DestX,0x3),0x3);
						},
						flag = {Preserved}
					}
		else
			Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(DestX[1],DestX[2],DestX[3],DestX[4],SetTo,0);
							SetCtrig1X(DestX[1],DestX[2],DestX[3],DestX[4],SetTo,bit32.band(DestX,0x3),0x3);
						},
						flag = {Preserved}
					}
		end
	elseif Source[4] == "V" then
		if type(DestX) == "number" then
			Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(DestX,SetTo,0);
						},
						flag = {Preserved}
					}
			Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
							CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,1,1);
						},
						actions = {
							SetMemoryX(DestX,SetTo,1,1);
						},
						flag = {Preserved}
					}
			Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
							CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,2,2);
						},
						actions = {
							SetMemoryX(DestX,SetTo,2,2);
						},
						flag = {Preserved}
					}
		elseif DestX[4] == "V" then
			Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(DestX[1],DestX[2],0x15C,DestX[3],SetTo,0);
						},
						flag = {Preserved}
					}
			Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
							CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,1,1);
						},
						actions = {
							SetCtrig1X(DestX[1],DestX[2],0x15C,DestX[3],SetTo,1,1);
						},
						flag = {Preserved}
					}
			Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
							CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,2,2);
						},
						actions = {
							SetCtrig1X(DestX[1],DestX[2],0x15C,DestX[3],SetTo,2,2);
						},
						flag = {Preserved}
					}
		else
			Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(DestX[1],DestX[2],DestX[3],DestX[4],SetTo,0);
						},
						flag = {Preserved}
					}
			Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
							CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,1,1);
						},
						actions = {
							SetCtrig1X(DestX[1],DestX[2],DestX[3],DestX[4],SetTo,1,1);
						},
						flag = {Preserved}
					}
			Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
							CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,2,2);
						},
						actions = {
							SetCtrig1X(DestX[1],DestX[2],DestX[3],DestX[4],SetTo,2,2);
						},
						flag = {Preserved}
					}
		end
	end
end

function f_SHRead(PlayerID,Input,Output,Mask,Clear) -- (CPRead) 방식으로 읽음
	FSHReadCheck = 1
	STPopTrigArr(PlayerID)
	if Mask == nil or Mask == "X" then
		Mask = 0xFFFFFFFF
	end
	if Output == "X" then
		Output = nil
	end
	-- Input Data CRet[1] << EPD 
	if type(Input) == "number" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetMemory(0x6509B0,SetTo,EPD(Input));
				},
				flag = {Preserved}
			}
	elseif Input[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X(Input[1],Input[2],0x158,Input[3],SetTo,EPD(0x6509B0));
				SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Input[1],Input[2],Input[3]);
			},
			flag = {Preserved}
		}
	elseif Input[4] == "VA" then
		local TempRet = {"X",CRet[1],0,"V"}
		MovX(PlayerID,TempRet,Input)
		CMov(PlayerID,0x6509B0,V(CRet[1]))
	elseif Input[4] == "A" then
		local TempRet = {"X",CRet[1],0,"V"}
		MovZ(PlayerID,TempRet,Input)
		CMov(PlayerID,0x6509B0,V(CRet[1]))
	else
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig2X(0x6509B0,SetTo,Input[1],Input[2],Input[3],1,Input[4]);
			},
			flag = {Preserved}
		}
	end

	-- Call f_SHRead
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
					SetCtrigX("X","X",0x4,0,SetTo,"X",FSHReadCall1,0x0,0,0);
					SetCtrigX("X",FSHReadCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FSHReadCall1 == 0 then
		Need_Include_DataTransfer()
	end

	
	-- Output Data CRet[2] = Output
	if Output ~= nil then
		local ClearAct = {}
		if Clear == 1 then
			ClearAct = {SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,0)}
		end
		if type(Output) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
		else
			if Output[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						ClearAct,
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
			elseif Output[4] == "VA" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,Mask)
			elseif Output[4] == "A" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,Mask)
			else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
			end
		end
	end
	
	-- Option : RecoverCp
	RecoverCp(PlayerID)
end

function f_CunitRead(PlayerID,Input,PTROutput,EPDOutput,Deviation)
	STPopTrigArr(PlayerID)
	if PTROutput == "X" then
		PTROutput = nil
	end
	if EPDOutput == "X" then
		EPDOutput = nil
	end

	if Deviation == nil then
		Deviation = 0
	end
	local Deviation4 = bit32.lshift(Deviation,2)

	-- Input Data CRet[1] << EPD 
	if type(Input) == "number" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,SetTo,EPD(Input));
				},
				flag = {Preserved}
			}
	elseif Input == "Cp" then
		f_Read_InputData_Error()
	elseif Input[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
				SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Input[1],Input[2],Input[3]);
			},
			flag = {Preserved}
		}
	elseif Input[4] == "VA" then
		local TempRet = {"X",CRet[1],0,"V"}
		MovX(PlayerID,TempRet,Input)
		Input = TempRet
	elseif Input[4] == "A" then
		local TempRet = {"X",CRet[1],0,"V"}
		MovZ(PlayerID,TempRet,Input)
		Input = TempRet
	else
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",CRet[1],0x15C,0,SetTo,Input[1],Input[2],Input[3],1,Input[4]);
			},
			flag = {Preserved}
		}
	end

	-- Call f_CunitRead
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCUReadCall1,0x0,0,0);
					SetCtrigX("X",FCUReadCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FCUReadCall1 == 0 then
		Need_Include_DataTransfer()
	end
	
	-- Output Data CRet[2] = PTROutput
	if PTROutput ~= nil then
		if type(PTROutput) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetMemory(PTROutput,SetTo,Deviation4);
						SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(PTROutput));
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,Add*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
		else
			if PTROutput[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X(PTROutput[1],PTROutput[2],0x15C,PTROutput[3],SetTo,Deviation4);
						SetCtrigX("X",CRet[2],0x158,0,SetTo,PTROutput[1],PTROutput[2],0x15C,1,PTROutput[3]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,Add*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
			elseif PTROutput[4] == "VA" then
				local TempRet = {"X",CRet[2],0,"V"}
				CMovX(PlayerID,PTROutput,TempRet,SetTo,0xFFFFFFFF,Deviation4)
			elseif PTROutput[4] == "A" then
				local TempRet = {"X",CRet[2],0,"V"}
				CMovX(PlayerID,PTROutput,TempRet,SetTo,0xFFFFFFFF,Deviation4)
			else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X(PTROutput[1],PTROutput[2],PTROutput[3],PTROutput[4],SetTo,Deviation4);
						SetCtrigX("X",CRet[2],0x158,0,SetTo,PTROutput[1],PTROutput[2],PTROutput[3],1,PTROutput[4]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,Add*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
			end
		end
	end
	
	-- Output Data CRet[3] = EPD(Output)
	if EPDOutput ~= nil then
		if type(EPDOutput) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetMemory(EPDOutput,SetTo,Deviation);
						SetCtrig1X("X",CRet[3],0x158,0,SetTo,EPD(EPDOutput));
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,Add*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
						},
						flag = {Preserved}
					}
		else
			if EPDOutput[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X(EPDOutput[1],EPDOutput[2],0x15C,EPDOutput[3],SetTo,Deviation);
						SetCtrigX("X",CRet[3],0x158,0,SetTo,EPDOutput[1],EPDOutput[2],0x15C,1,EPDOutput[3]);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,Add*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
						},
						flag = {Preserved}
					}
			elseif EPDOutput[4] == "VA" then
				local TempRet = {"X",CRet[3],0,"V"}
				CMovX(PlayerID,EPDOutput,TempRet,SetTo,0xFFFFFFFF,Deviation)
			elseif EPDOutput[4] == "A" then
				local TempRet = {"X",CRet[3],0,"V"}
				CMovX(PlayerID,EPDOutput,TempRet,SetTo,0xFFFFFFFF,Deviation)
			else
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrig1X(EPDOutput[1],EPDOutput[2],EPDOutput[3],EPDOutput[4],SetTo,Deviation);
					SetCtrigX("X",CRet[3],0x158,0,SetTo,EPDOutput[1],EPDOutput[2],EPDOutput[3],1,EPDOutput[4]);
					SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[3],0x160,0,SetTo,Add*16777216,0xFF000000);
					CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
			end
		end
	end
	
	-- Option : RecoverCp
	RecoverCp(PlayerID)
end

function f_Read(PlayerID,Input,Output,EPDOutput,Mask,Clear) -- (CPRead) 방식으로 읽음
	STPopTrigArr(PlayerID)
	if Mask == nil or Mask == "X" then
		Mask = 0xFFFFFFFF
	end
	if Output == "X" then
		Output = nil
	end
	if EPDOutput == "X" then
		EPDOutput = nil
	end

	-- Input Data CRet[1] << EPD 
	if type(Input) == "number" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,SetTo,EPD(Input));
				},
				flag = {Preserved}
			}
	elseif Input == "Cp" then
		f_Read_InputData_Error()
	elseif Input[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
				SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Input[1],Input[2],Input[3]);
			},
			flag = {Preserved}
		}
	elseif Input[4] == "VA" then
		local TempRet = {"X",CRet[1],0,"V"}
		MovX(PlayerID,TempRet,Input)
		Input = TempRet
	elseif Input[4] == "A" then
		local TempRet = {"X",CRet[1],0,"V"}
		MovZ(PlayerID,TempRet,Input)
		Input = TempRet
	else
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",CRet[1],0x15C,0,SetTo,Input[1],Input[2],Input[3],1,Input[4]);
			},
			flag = {Preserved}
		}
	end

	-- Call f_Read
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FReadCall1,0x0,0,0);
					SetCtrigX("X",FReadCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FReadCall1 == 0 then
		Need_Include_DataTransfer()
	end

	
	-- Output Data CRet[2] = Output
	if Output ~= nil then
		local ClearAct = {}
		if Clear == 1 then
			ClearAct = {SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,0)}
		end
		if type(Output) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
		else
			if Output[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						ClearAct,
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
			elseif Output[4] == "VA" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,Mask)
			elseif Output[4] == "A" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,Mask)
			else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
			end
		end
	end
	
	-- Output Data CRet[3] = EPD(Output)
	if EPDOutput ~= nil then
		if type(EPDOutput) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",CRet[3],0x158,0,SetTo,EPD(EPDOutput));
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
						},
						flag = {Preserved}
					}
		else
			if EPDOutput[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[3],0x158,0,SetTo,EPDOutput[1],EPDOutput[2],0x15C,1,EPDOutput[3]);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
						},
						flag = {Preserved}
					}
			elseif EPDOutput[4] == "VA" then
				local TempRet = {"X",CRet[3],0,"V"}
				MovX(PlayerID,EPDOutput,TempRet)
			elseif EPDOutput[4] == "A" then
				local TempRet = {"X",CRet[3],0,"V"}
				MovX(PlayerID,EPDOutput,TempRet)
			else
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[3],0x158,0,SetTo,EPDOutput[1],EPDOutput[2],EPDOutput[3],1,EPDOutput[4]);
					SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
			end
		end
	end
	
	-- Option : RecoverCp
	RecoverCp(PlayerID)
end


function f_ReadX(PlayerID,Input,Output,Multiplier,Mask,Clear) -- (CPRead) 방식으로 읽음
	STPopTrigArr(PlayerID)
	if Mask == nil or Mask == "X" then
		Mask = 0xFFFFFFFF
	end
	if Output == "X" then
		Output = nil
	end

	-- Input Data CRet[1] << EPD 
	if type(Input) == "number" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,SetTo,EPD(Input));
				},
				flag = {Preserved}
			}
	elseif Input == "Cp" then
		f_Read_InputData_Error()
	elseif Input[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
				SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Input[1],Input[2],Input[3]);
			},
			flag = {Preserved}
		}
	elseif Input[4] == "VA" then
		local TempRet = {"X",CRet[1],0,"V"}
		MovX(PlayerID,TempRet,Input)
		Input = TempRet
	elseif Input[4] == "A" then
		local TempRet = {"X",CRet[1],0,"V"}
		MovZ(PlayerID,TempRet,Input)
		Input = TempRet
	else
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",CRet[1],0x15C,0,SetTo,Input[1],Input[2],Input[3],1,Input[4]);
			},
			flag = {Preserved}
		}
	end

	-- Call f_ReadX
	local NextAct = {}
	local NextAct2 = {}
	local Mask2
	if Multiplier == "X" or Multiplier == nil then
		f_ReadX_InputData_Error()
	elseif Multiplier == 16777216 or Multiplier == "+3" then
		table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall1,0x0,0,0))
		table.insert(NextAct,SetCtrigX("X",FReadXCall1,0x4,7,SetTo,"X","X",0x0,0,1))
		Mask2 = bit32.band(Mask*16777216, 0xFFFFFFFF) 
	elseif Multiplier == 65536 or Multiplier == "+2" then
		if bit32.band(Mask, 0xFFFF) == 0x00FF then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall2,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall2,0x4,7,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall2,0x4,7,SetTo,"X",FReadXCall2,0x0,0,7+1))
		elseif bit32.band(Mask, 0xFFFF) == 0xFF00 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall2,0x0,0,8))
			table.insert(NextAct,SetCtrigX("X",FReadXCall2,0x4,15,SetTo,"X","X",0x0,0,1))
		else -- bit32.band(Mask, 0xFFFF) == 0xFFFF
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall2,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall2,0x4,15,SetTo,"X","X",0x0,0,1))
		end
		Mask2 = bit32.band(Mask*65536, 0xFFFFFFFF) 
	elseif Multiplier == 256 or Multiplier == "+1" then
		if bit32.band(Mask, 0xFFFFFF) == 0x0000FF then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall3,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall3,0x4,7,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall3,0x4,7,SetTo,"X",FReadXCall3,0x0,0,7+1))
		elseif bit32.band(Mask, 0xFFFFFF) == 0x00FF00 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall3,0x0,0,8))
			table.insert(NextAct,SetCtrigX("X",FReadXCall3,0x4,15,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall3,0x4,15,SetTo,"X",FReadXCall3,0x0,0,15+1))
		elseif bit32.band(Mask, 0xFFFFFF) == 0xFF0000 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall3,0x0,0,16))
			table.insert(NextAct,SetCtrigX("X",FReadXCall3,0x4,23,SetTo,"X","X",0x0,0,1))
		elseif bit32.band(Mask, 0xFFFFFF) == 0x00FFFF then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall3,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall3,0x4,15,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall3,0x4,15,SetTo,"X",FReadXCall3,0x0,0,15+1))
		elseif bit32.band(Mask, 0xFFFFFF) == 0xFFFF00 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall3,0x0,0,8))
			table.insert(NextAct,SetCtrigX("X",FReadXCall3,0x4,23,SetTo,"X","X",0x0,0,1))
		elseif bit32.band(Mask, 0xFFFFFF) == 0xFF00FF then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall3,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall3,0x4,7,SetTo,"X",FReadXCall3,0x0,0,16))
			table.insert(NextAct,SetCtrigX("X",FReadXCall3,0x4,23,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall3,0x4,7,SetTo,"X",FReadXCall3,0x0,0,7+1))
		else -- bit32.band(Mask, 0xFFFFFF) == 0xFFFFFF
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall3,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall3,0x4,23,SetTo,"X","X",0x0,0,1))
		end
		Mask2 = bit32.band(Mask*256, 0xFFFFFFFF) 
	elseif Multiplier == 1 or Multiplier == "0" then
		if bit32.band(Mask, 0xFFFFFFFF) == 0x000000FF then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,7,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall4,0x4,7,SetTo,"X",FReadXCall4,0x0,0,7+1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0x0000FF00 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,8))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,15,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall4,0x4,15,SetTo,"X",FReadXCall4,0x0,0,15+1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0x00FF0000 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,16))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,23,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall4,0x4,23,SetTo,"X",FReadXCall4,0x0,0,23+1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0xFF000000 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,24))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,31,SetTo,"X","X",0x0,0,1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0x0000FFFF then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,15,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall4,0x4,15,SetTo,"X",FReadXCall4,0x0,0,15+1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0x00FFFF00 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,8))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,23,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall4,0x4,23,SetTo,"X",FReadXCall4,0x0,0,23+1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0xFFFF0000 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,16))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,31,SetTo,"X","X",0x0,0,1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0x00FFFFFF then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,23,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall4,0x4,23,SetTo,"X",FReadXCall4,0x0,0,23+1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0xFFFFFF00 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,8))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,31,SetTo,"X","X",0x0,0,1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0x00FF00FF then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,7,SetTo,"X",FReadXCall4,0x0,0,16))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,23,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall4,0x4,7,SetTo,"X",FReadXCall4,0x0,0,7+1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0xFF00FF00 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,8))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,15,SetTo,"X",FReadXCall4,0x0,0,24))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,31,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall4,0x4,15,SetTo,"X",FReadXCall4,0x0,0,15+1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0xFF0000FF then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,7,SetTo,"X",FReadXCall4,0x0,0,24))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,31,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall4,0x4,7,SetTo,"X",FReadXCall4,0x0,0,7+1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0xFF00FFFF then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,15,SetTo,"X",FReadXCall4,0x0,0,24))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,31,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall4,0x4,15,SetTo,"X",FReadXCall4,0x0,0,15+1))
		elseif bit32.band(Mask, 0xFFFFFFFF) == 0xFFFF00FF then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,7,SetTo,"X",FReadXCall4,0x0,0,16))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,31,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall4,0x4,7,SetTo,"X",FReadXCall4,0x0,0,7+1))
		else -- bit32.band(Mask, 0xFFFFFFFF) == 0xFFFFFFFF
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall4,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall4,0x4,31,SetTo,"X","X",0x0,0,1))
		end
		Mask2 = bit32.band(Mask, 0xFFFFFFFF) 
	elseif Multiplier == 1/256 or Multiplier == "-1" then
		if bit32.band(Mask, 0xFFFFFF00) == 0x0000FF00 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall5,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall5,0x4,7,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall5,0x4,7,SetTo,"X",FReadXCall5,0x0,0,7+1))
		elseif bit32.band(Mask, 0xFFFFFF00) == 0x00FF0000 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall5,0x0,0,8))
			table.insert(NextAct,SetCtrigX("X",FReadXCall5,0x4,15,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall5,0x4,15,SetTo,"X",FReadXCall5,0x0,0,15+1))
		elseif bit32.band(Mask, 0xFFFFFF00) == 0xFF000000 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall5,0x0,0,16))
			table.insert(NextAct,SetCtrigX("X",FReadXCall5,0x4,23,SetTo,"X","X",0x0,0,1))
		elseif bit32.band(Mask, 0xFFFFFF00) == 0x00FFFF00 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall5,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall5,0x4,15,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall5,0x4,15,SetTo,"X",FReadXCall5,0x0,0,15+1))
		elseif bit32.band(Mask, 0xFFFFFF00) == 0xFFFF0000 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall5,0x0,0,8))
			table.insert(NextAct,SetCtrigX("X",FReadXCall5,0x4,23,SetTo,"X","X",0x0,0,1))
		elseif bit32.band(Mask, 0xFFFFFF00) == 0xFF00FF00 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall5,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall5,0x4,7,SetTo,"X",FReadXCall5,0x0,0,16))
			table.insert(NextAct,SetCtrigX("X",FReadXCall5,0x4,23,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall5,0x4,7,SetTo,"X",FReadXCall5,0x0,0,7+1))
		else -- bit32.band(Mask, 0xFFFFFF00) == 0xFFFFFF00
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall5,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall5,0x4,23,SetTo,"X","X",0x0,0,1))
		end
		Mask2 = bit32.band(Mask/256, 0xFFFFFFFF) 
	elseif Multiplier == 1/65536 or Multiplier == "-2" then
		if bit32.band(Mask, 0xFFFF0000) == 0x00FF0000 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall6,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall6,0x4,7,SetTo,"X","X",0x0,0,1))
			table.insert(NextAct2,SetCtrigX("X",FReadXCall6,0x4,7,SetTo,"X",FReadXCall6,0x0,0,7+1))
		elseif bit32.band(Mask, 0xFFFF0000) == 0xFF000000 then 
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall6,0x0,0,8))
			table.insert(NextAct,SetCtrigX("X",FReadXCall6,0x4,15,SetTo,"X","X",0x0,0,1))
		else -- bit32.band(Mask, 0xFFFF0000) == 0xFFFF0000
			table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall6,0x0,0,0))
			table.insert(NextAct,SetCtrigX("X",FReadXCall6,0x4,15,SetTo,"X","X",0x0,0,1))
		end
		Mask2 = bit32.band(Mask/65536, 0xFFFFFFFF) 
	elseif Multiplier == 1/16777216 or Multiplier == "-3" then
		table.insert(NextAct,SetCtrigX("X",FReadXCall0,0x4,1,SetTo,"X",FReadXCall7,0x0,0,0))
		table.insert(NextAct,SetCtrigX("X",FReadXCall7,0x4,7,SetTo,"X","X",0x0,0,1))
		Mask2 = bit32.band(Mask/16777216, 0xFFFFFFFF) 
	else
		f_ReadX_InputData_Error()
	end

	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FReadXCall0,0x0,0,0);
					NextAct,
				},
				flag = {Preserved}
			}
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					NextAct2,
				},
				flag = {Preserved}
			}
	if FReadXCall0 == 0 then
		Need_Include_DataTransfer()
	end

	-- Output Data CRet[2] = Output
	local ClearAct = {}
	if Clear == 1 then
		ClearAct = {SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,0)}
	end
	if Output ~= nil then
		if type(Output) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask2);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
		else
			if Output[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						ClearAct,
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask2);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
			elseif Output[4] == "VA" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,Mask2)
			elseif Output[4] == "A" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,Mask2)
			else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask2);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
			end
		end
	end
	

	-- Option : RecoverCp
	RecoverCp(PlayerID)
end

-- Include ArithMetic

function f_Abs(PlayerID,Dest,Source,Mask)
	STPopTrigArr(PlayerID)
	if Mask == nil or Mask == "X" then
		Mask = 0xFFFFFFFF
	end
	if Source == "X" then
		Source = nil
	end

	-- Input Data CRet[1] << X 
	local PDest = Dest
	if Source == nil then
		if Dest[4] == "VA" then
			local TempRet = {"X",CRet[1],0,"V"}
			MovX(PlayerID,TempRet,Dest)
			Dest = TempRet
		else
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Dest[1],Dest[2],Dest[3]);
				},
				flag = {Preserved}
			}
		end
	else
		if type(Source) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else
			if Source[4] == "VA" then
				local TempRet = {"X",CRet[1],0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
	end

	-- Call f_Abs
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FABSCall1,0x0,0,0);
					SetCtrigX("X",FABSCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FABSCall1 == 0 then
		Need_Include_ArithMetic()
	end

	-- Output Data CRet[2] = Output

	if type(PDest) == "number" then
		Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(PDest));
					SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
	else
		if PDest[4] == "V" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		elseif PDest[4] == "VA" then
			local TempRet = {"X",CRet[2],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		elseif PDest[4] == "A" then
			local TempRet = {"X",CRet[2],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
					SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		end
	end

end
function f_Mul(PlayerID,Dest,Source,Multiplier,Mask)
	STPopTrigArr(PlayerID)
	if Mask == nil or Mask == "X" then
		Mask = 0xFFFFFFFF
	end
	if Multiplier == "X" then
		Multiplier = nil
	end

	-- Input Data CRet[1] << X / CRet[2] << Y
		
	local PDest = Dest
	if Multiplier == nil then
		if Dest[4] == "VA" then
			local TempRet = {"X",FMULCall0,0,"V"}
			MovX(PlayerID,TempRet,Dest)
			Dest = TempRet
		else
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FMULCall0,0x15C,1,0);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Dest[1],Dest[2],Dest[3]);
				},
				flag = {Preserved}
			}
		end
		if type(Source) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else
			if Source[4] == "VA" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
	else
		if type(Source) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",FMULCall0,0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else	
			if Source[4] == "VA" then
				local TempRet = {"X",FMULCall0,0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FMULCall0,0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
		if type(Multiplier) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Multiplier);
					},
					flag = {Preserved}
				}
		else	
			if Multiplier[4] == "VA" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,TempRet,Multiplier)
				Multiplier = TempRet
			else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Multiplier[1],Multiplier[2],0x158,Multiplier[3],SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X(Multiplier[1],Multiplier[2],0x148,Multiplier[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Multiplier[1],Multiplier[2],0x160,Multiplier[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Multiplier[1],Multiplier[2],Multiplier[3]);
					},
					flag = {Preserved}
				}
			end
		end
	end

	-- Call f_Mul
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FMULCall1,0x0,0,0);
					SetCtrigX("X",FMULCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FMULCall1 == 0 then
		Need_Include_ArithMetic()
	end

	-- Output Data CRet[3] = Output

	if type(PDest) == "number" then
		Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrig1X("X",CRet[3],0x158,0,SetTo,EPD(PDest));
					SetCtrig1X("X",CRet[3],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
	else
		if PDest[4] == "V" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[3],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrig1X("X",CRet[3],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		elseif PDest[4] == "VA" then
			local TempRet = {"X",CRet[3],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		elseif PDest[4] == "A" then
			local TempRet = {"X",CRet[3],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[3],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
					SetCtrig1X("X",CRet[3],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		end
	end
end

function f_iMul(PlayerID,Dest,Source,Multiplier,Mask)
	STPopTrigArr(PlayerID)
	if Mask == nil or Mask == "X" then
		Mask = 0xFFFFFFFF
	end
	if Multiplier == "X" then
		Multiplier = nil
	end

	-- Input Data CRet[1] << X / CRet[2] << Y
		
	local PDest = Dest
	if Multiplier == nil then
		if Dest[4] == "VA" then
			local TempRet = {"X",FMulCall0,0,"V"}
			MovX(PlayerID,TempRet,Dest)
			Dest = TempRet
		else
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",FMulCall0,0x15C,1,0);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Dest[1],Dest[2],Dest[3]);
				},
				flag = {Preserved}
			}
		end
		if type(Source) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else
			if Source[4] == "VA" then
				local TempRet = {"X",CRet[1],0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
	else
		if type(Source) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",FMulCall0,0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else	
			if Source[4] == "VA" then
				local TempRet = {"X",FMulCall0,0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FMulCall0,0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
		if type(Multiplier) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Multiplier);
					},
					flag = {Preserved}
				}
		else	
			if Multiplier[4] == "VA" then
				local TempRet = {"X",CRet[1],0,"V"}
				MovX(PlayerID,TempRet,Multiplier)
				Multiplier = TempRet
			else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Multiplier[1],Multiplier[2],0x158,Multiplier[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Multiplier[1],Multiplier[2],0x148,Multiplier[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Multiplier[1],Multiplier[2],0x160,Multiplier[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Multiplier[1],Multiplier[2],Multiplier[3]);
					},
					flag = {Preserved}
				}
			end
		end
	end

	-- Call f_iMul
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FiMulCall1,0x0,0,0);
					SetCtrigX("X",FiMulCall2,0x4,0,SetTo,"X","X",0x0,0,1);
					SetCtrigX("X",FMulCall2,0x4,0,SetTo,"X",FMulCall2,0x0,0,1);
				},
				flag = {Preserved}
			}
	if FiMulCall1 == 0 then
		Need_Include_ArithMetic()
	end

	-- Output Data CRet[3] = Output

	if type(PDest) == "number" then
		Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrig1X("X",CRet[4],0x158,0,SetTo,EPD(PDest));
					SetCtrig1X("X",CRet[4],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[4],0);
					},
					flag = {Preserved}
				}
	else
		if PDest[4] == "V" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[4],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrig1X("X",CRet[4],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[4],0);
					},
					flag = {Preserved}
				}
		elseif PDest[4] == "VA" then
			local TempRet = {"X",CRet[4],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		elseif PDest[4] == "A" then
			local TempRet = {"X",CRet[4],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[4],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
					SetCtrig1X("X",CRet[4],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[4],0);
					},
					flag = {Preserved}
				}
		end
	end
end

function f_Div(PlayerID,Dest,Source,Divisor,Mask)
	STPopTrigArr(PlayerID)
	if Mask == nil or Mask == "X" then
		Mask = 0xFFFFFFFF
	end
	if Divisor == "X" then
		Divisor = nil
	end

	-- Input Data CRet[1] << X / CRet[2] << Y

	local PDest = Dest
	if Divisor == nil then
		if Dest[4] == "VA" then
			local TempRet = {"X",CRet[2],0,"V"}
			MovX(PlayerID,TempRet,Dest)
			Dest = TempRet
		else
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Dest[1],Dest[2],Dest[3]);
				},
				flag = {Preserved}
			}
		end
		if type(Source) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else
			if Source[4] == "VA" then
				local TempRet = {"X",CRet[1],0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
	else
		if type(Source) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else
			if Source[4] == "VA" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
		if type(Divisor) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Divisor);
					},
					flag = {Preserved}
				}
		else
			if Divisor[4] == "VA" then
				local TempRet = {"X",CRet[1],0,"V"}
				MovX(PlayerID,TempRet,Divisor)
				Divisor = TempRet
			else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
					},
					flag = {Preserved}
				}
			end
		end
	end

	-- Call f_Div
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FDIVCall1,0x0,0,0);
					SetCtrigX("X",FDIVCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FDIVCall1 == 0 then
		Need_Include_ArithMetic()
	end

	-- Output Data CRet[3] = Output
	if type(PDest) == "number" then
		Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrig1X("X",CRet[3],0x158,0,SetTo,EPD(PDest));
					SetCtrig1X("X",CRet[3],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
	else
		if PDest[4] == "V" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[3],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrig1X("X",CRet[3],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		elseif PDest[4] == "VA" then
			local TempRet = {"X",CRet[3],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		elseif PDest[4] == "A" then
			local TempRet = {"X",CRet[3],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[3],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
					SetCtrig1X("X",CRet[3],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		end
	end
end

function f_Mod(PlayerID,Dest,Source,Divisor,Mask)
	STPopTrigArr(PlayerID)
	if Mask == nil or Mask == "X" then
		Mask = 0xFFFFFFFF
	end
	if Divisor == "X" then
		Divisor = nil
	end

	-- Input Data CRet[1] << X / CRet[2] << Y
	local PDest = Dest
	if Divisor == nil then
		if Dest[4] == "VA" then
			local TempRet = {"X",CRet[2],0,"V"}
			MovX(PlayerID,TempRet,Dest)
			Dest = TempRet
		else
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[2],0x15C,1,0);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Dest[1],Dest[2],Dest[3]);
				},
				flag = {Preserved}
			}
		end
		if type(Source) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else
			if Source[4] == "VA" then
				local TempRet = {"X",CRet[1],0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
	else
		if type(Source) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else
			if Source[4] == "VA" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[2],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
		if type(Divisor) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Divisor);
					},
					flag = {Preserved}
				}
		else
			if Divisor[4] == "VA" then
				local TempRet = {"X",CRet[1],0,"V"}
				MovX(PlayerID,TempRet,Divisor)
				Divisor = TempRet
			else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
					},
					flag = {Preserved}
				}
			end
		end
	end

	-- Call f_Mod
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FMODCall1,0x0,0,0);
					SetCtrigX("X",FMODCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FMODCall1 == 0 then
		Need_Include_ArithMetic()
	end

	-- Output Data CRet[2] = Output
	if type(PDest) == "number" then
		Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(PDest));
					SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
	else
		if PDest[4] == "V" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		elseif PDest[4] == "VA" then
			local TempRet = {"X",CRet[2],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		elseif PDest[4] == "A" then
			local TempRet = {"X",CRet[2],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[2],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
					SetCtrig1X("X",CRet[2],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		end
	end
end

function f_iDiv(PlayerID,Dest,Source,Divisor,Mask)
	STPopTrigArr(PlayerID)
	if Mask == nil or Mask == "X" then
		Mask = 0xFFFFFFFF
	end
	if Divisor == "X" then
		Divisor = nil
	end

	-- Input Data CRet[1] << X / CRet[2] << Y

	local PDest = Dest
	if Divisor == nil then
		if Dest[4] == "VA" then
			local TempRet = {"X",CRet[5],0,"V"}
			MovX(PlayerID,TempRet,Dest)
			Dest = TempRet
		else
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[5],0x15C,1,0);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Dest[1],Dest[2],Dest[3]);
				},
				flag = {Preserved}
			}
		end
		if type(Source) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else
			if Source[4] == "VA" then
				local TempRet = {"X",CRet[1],0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
	else
		if type(Source) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[5],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else
			if Source[4] == "VA" then
				local TempRet = {"X",CRet[5],0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[5],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
		if type(Divisor) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Divisor);
					},
					flag = {Preserved}
				}
		else
			if Divisor[4] == "VA" then
				local TempRet = {"X",CRet[1],0,"V"}
				MovX(PlayerID,TempRet,Divisor)
				Divisor = TempRet
			else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
					},
					flag = {Preserved}
				}
			end
		end
	end

	-- Call f_iDiv
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FIDIVCall1,0x0,0,0);
					SetCtrigX("X",FIDIVCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FIDIVCall1 == 0 then
		Need_Include_ArithMetic()
	end

	-- Output Data CRet[3] = Output
	if type(PDest) == "number" then
		Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrig1X("X",CRet[5],0x158,0,SetTo,EPD(PDest));
					SetCtrig1X("X",CRet[5],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[5],0);
					},
					flag = {Preserved}
				}
	else
		if PDest[4] == "V" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[5],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrig1X("X",CRet[5],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[5],0);
					},
					flag = {Preserved}
				}
		elseif PDest[4] == "VA" then
			local TempRet = {"X",CRet[5],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		elseif PDest[4] == "A" then
			local TempRet = {"X",CRet[5],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[5],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
					SetCtrig1X("X",CRet[5],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[5],0);
					},
					flag = {Preserved}
				}
		end
	end
end

function f_iMod(PlayerID,Dest,Source,Divisor,Mask)
	STPopTrigArr(PlayerID)
	if Mask == nil or Mask == "X" then
		Mask = 0xFFFFFFFF
	end
	if Divisor == "X" then
		Divisor = nil
	end

	-- Input Data CRet[1] << X / CRet[2] << Y
	local PDest = Dest
	if Divisor == nil then
		if Dest[4] == "VA" then
			local TempRet = {"X",CRet[5],0,"V"}
			MovX(PlayerID,TempRet,Dest)
			Dest = TempRet
		else
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",CRet[5],0x15C,1,0);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Dest[1],Dest[2],Dest[3]);
				},
				flag = {Preserved}
			}
		end
		if type(Source) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else
			if Source[4] == "VA" then
				local TempRet = {"X",CRet[1],0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
	else
		if type(Source) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[5],0x15C,0,SetTo,Source);
					},
					flag = {Preserved}
				}
		else
			if Source[4] == "VA" then
				local TempRet = {"X",CRet[5],0,"V"}
				MovX(PlayerID,TempRet,Source)
				Source = TempRet
			else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",CRet[5],0x15C,1,0);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
		end
		if type(Divisor) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Divisor);
					},
					flag = {Preserved}
				}
		else
			if Divisor[4] == "VA" then
				local TempRet = {"X",CRet[1],0,"V"}
				MovX(PlayerID,TempRet,Divisor)
				Divisor = TempRet
			else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Divisor[1],Divisor[2],0x158,Divisor[3],SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X(Divisor[1],Divisor[2],0x148,Divisor[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Divisor[1],Divisor[2],0x160,Divisor[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Divisor[1],Divisor[2],Divisor[3]);
					},
					flag = {Preserved}
				}
			end
		end
	end

	-- Call f_Div
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FIMODCall1,0x0,0,0);
					SetCtrigX("X",FIMODCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FIMODCall1 == 0 then
		Need_Include_ArithMetic()
	end

	-- Output Data CRet[2] = Output
	if type(PDest) == "number" then
		Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrig1X("X",CRet[5],0x158,0,SetTo,EPD(PDest));
					SetCtrig1X("X",CRet[5],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[5],0);
					},
					flag = {Preserved}
				}
	else
		if PDest[4] == "V" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[5],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrig1X("X",CRet[5],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[5],0);
					},
					flag = {Preserved}
				}
		elseif PDest[4] == "VA" then
			local TempRet = {"X",CRet[5],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		elseif PDest[4] == "A" then
			local TempRet = {"X",CRet[5],0,"V"}
			MovX(PlayerID,PDest,TempRet)
		else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
					SetCtrigX("X",CRet[5],0x158,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
					SetCtrig1X("X",CRet[5],0x148,0,SetTo,Mask);
					SetCtrig1X("X",CRet[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[5],0);
					},
					flag = {Preserved}
				}
		end
	end
end

-- 내부 트리거 생성 관련 함수 (직접 사용X) -----------------------------------------------

function _TPopCondArr(PlayerID)
	if _TPopTrigLock == 0 and _TPushCondArr[1] ~= nil then
		if ORPushCondArr[1] ~= nil then
			_TPopCondArr_InputData_Error()
		end
		_TPopTrigLock = 1
		local BackupArr = {PushCondArr,CondLineArr,PushActArr,ActLineArr,STPushTrigArr,PushTrigArr,PushTrigStack,TTPushTrigArr,TTPushCondArr,TTFCodeArr,TTModeArr}
		PushCondArr = {}
		CondLineArr = {}
		PushActArr = {}
		ActLineArr = {}
		STPushTrigArr = {}
		PushTrigArr = {}
		PushTrigStack = 0
		TTPushTrigArr = {}
		TTPushCondArr = {}
		TTFCodeArr = {}
		TTModeArr = {}

		local _TF = _TFCodeArr[1]
		_TPopPlayerIDArr = PlayerID
		DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,_TF)})
		for i = 1, #_TPushCondArr[1] do -- <<1>,<2>,...,<n>>
			_TPopTrig(_TF,_TPushCondArr[1][i]) -- Pop _TCond
		end

		PushCondArr = BackupArr[1]
		CondLineArr = BackupArr[2]
		PushActArr = BackupArr[3]
		ActLineArr = BackupArr[4]
		STPushTrigArr = BackupArr[5]
		PushTrigArr = BackupArr[6]
		PushTrigStack = BackupArr[7]
		TTPushTrigArr = BackupArr[8]
		TTPushCondArr = BackupArr[9]
		TTFCodeArr = BackupArr[10]
		TTModeArr = BackupArr[11]
		_TPushCondArr = {}
		_TFCodeArr = {}
		_TPopTrigLock = 0
		_TPushVarXAlloc = {}
		_TPopPlayerIDArr = {}

		VarXAlloc = 0xFE00
		WarXAlloc = 0xFC00
		for j = 1, 32 do
			SVarXAlloc[j] = SVarXOrig[j]
		end
		VarXReleaseLock = 0
	end
end

function _TPopTrig(Flag,_TCond,Type,Value)
	PlayerID = _TPopPlayerIDArr
	if Type == nil then
		Type = Add
	end
	if Value == nil then
		Value = 1
	end

	if _TCond[1] == "X" then
		TriggerX(PlayerID,{_TCond[2]},{SetCDeaths("X",Type,Value,Flag)},{Preserved})
	elseif _TCond[1] == "T" or _TCond[1] == "TT" then
		local TCond
		local TFunc = _TCond[2]
		table.remove(_TCond,2)
		table.remove(_TCond,1)
		TCond = _G[TFunc](table.unpack(_TCond))
		CTrigger(PlayerID,{TCond},{SetCDeaths("X",Type,Value,Flag)},{Preserved})
	elseif _TCond[1] == "B" then
		local TCond = {}
		for i = 2, #_TCond do
			table.insert(TCond,_TPopBind(_TCond[i]))
		end
		CTrigger(PlayerID,{TCond},{SetCDeaths("X",Type,Value,Flag)},{Preserved})
	elseif _TCond[1] == "NOT" then
		local NFlag = FlagIndex(FlagAlloc)
		FlagAlloc = FlagAlloc + 1
		DoActionsX(PlayerID,{SetCDeaths("X",SetTo,1,NFlag)})
		_TPopTrig(NFlag,_TCond[2],SetTo,0)
		CTrigger(PlayerID,{CDeaths("X",Exactly,1,NFlag)},{SetCDeaths("X",Type,Value,Flag)},{Preserved})
	elseif _TCond[1] == "OR" then
		local NFlag = FlagIndex(FlagAlloc)
		FlagAlloc = FlagAlloc + 1
		DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,NFlag)})
		for i = 2, #_TCond do
			_TPopTrig(NFlag,_TCond[i],SetTo,1)
		end		
		CTrigger(PlayerID,{CDeaths("X",Exactly,1,NFlag)},{SetCDeaths("X",Type,Value,Flag)},{Preserved})
	elseif _TCond[1] == "AND" then
		local NFlag = FlagIndex(FlagAlloc)
		FlagAlloc = FlagAlloc + 1
		DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,NFlag)})
		for i = 2, #_TCond do
			_TPopTrig(NFlag,_TCond[i])
		end		
		CTrigger(PlayerID,{CDeaths("X",Exactly,#_TCond-1,NFlag)},{SetCDeaths("X",Type,Value,Flag)},{Preserved})
	end
end

function _TPopBind(_TCond)
	if _TCond[1] == "X" then
		local TCond = _TCond[2]
		return TCond
	elseif _TCond[1] == "T" or _TCond[1] == "TT" then
		local TFunc = _TCond[2]
		table.remove(_TCond,2)
		table.remove(_TCond,1)
		local TCond = _G[TFunc](table.unpack(_TCond))
		return TCond
	elseif _TCond[1] == "B" then
		_TPopBind_InputData_Error()
	elseif _TCond[1] == "NOT" then
		local NFlag = FlagIndex(FlagAlloc)
		FlagAlloc = FlagAlloc + 1
		DoActionsX(PlayerID,{SetCDeaths("X",SetTo,1,NFlag)})
		_TPopTrig(NFlag,_TCond[2],SetTo,0)
		local TCond = CDeaths("X",Exactly,1,NFlag)
		return TCond
	elseif _TCond[1] == "OR" then
		local NFlag = FlagIndex(FlagAlloc)
		FlagAlloc = FlagAlloc + 1
		DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,NFlag)})
		for i = 2, #_TCond do
			_TPopTrig(NFlag,_TCond[i],SetTo,1)
		end		
		local TCond = CDeaths("X",Exactly,1,NFlag)
		return TCond
	elseif _TCond[1] == "AND" then
		local NFlag = FlagIndex(FlagAlloc)
		FlagAlloc = FlagAlloc + 1
		DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,NFlag)})
		for i = 2, #_TCond do
			_TPopTrig(NFlag,_TCond[i])
		end		
		local TCond = CDeaths("X",Exactly,#_TCond-1,NFlag)
		return TCond
	end
end


function ORPopCondArr(PlayerID) -- 구버젼 호환용 함수
	if ORPopTrigLock == 0 and ORPushCondArr[1] ~= nil then
		ORPopTrigLock = 1
		local TempArr = PushCondArr
		local TempArr2 = CondLineArr
		local TempArr3 = PushActArr
		local TempArr4 = ActLineArr
		local TempArr5 = STPushTrigArr
		local TempArr6 = PushTrigArr
		local TempArr7 = PushTrigStack
		local TTempArr = TTPushTrigArr
		local TTempArr2 = TTPushCondArr
		local TTempArr3 = TTFCodeArr
		local TTempArr4 = TTModeArr
		PushCondArr = {}
		CondLineArr = {}
		PushActArr = {}
		ActLineArr = {}
		STPushTrigArr = {}
		PushTrigArr = {}
		PushTrigStack = 0
		TTPushTrigArr = {}
		TTPushCondArr = {}
		TTFCodeArr = {}
		TTModeArr = {}

		for i, ORCond in pairs(ORPushCondArr) do
			DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,ORFCodeArr[i])})
			for k, v in pairs(ORCond) do
				if v[1] == "T" then -- T조건
					if v[2] == "TMemoryX" then
						CTrigger(PlayerID,{TMemoryX(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TMemory" then
						CTrigger(PlayerID,{TMemory(v[3],v[4],v[5])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TCVar" then
						CTrigger(PlayerID,{TCVar(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TCVAar" then
						CTrigger(PlayerID,{TCVAar(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TVariableX" then
						CTrigger(PlayerID,{TVariableX(v[3],v[4],v[5],v[6],v[7],v[8])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TVariable" then
						CTrigger(PlayerID,{TVariable(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TVArrayX" then
						CTrigger(PlayerID,{TVArrayX(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TNDeathsX" then
						CTrigger(PlayerID,{TNDeathsX(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TNDeaths" then
						CTrigger(PlayerID,{TNDeaths(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TCDeathsX" then
						CTrigger(PlayerID,{TCDeathsX(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TCDeaths" then
						CTrigger(PlayerID,{TCDeaths(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TCtrigX" then
						CTrigger(PlayerID,{TCtrigX(v[3],v[4],v[5],v[6],v[7],v[8],v[9])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TDeaths" then
						CTrigger(PlayerID,{TDeaths(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TDeathsX" then
						CTrigger(PlayerID,{TDeathsX(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TCommand" then
						CTrigger(PlayerID,{TCommand(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TBring" then
						CTrigger(PlayerID,{TBring(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TAccumulate" then
						CTrigger(PlayerID,{TAccumulate(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TCountdownTimer" then
						CTrigger(PlayerID,{TCountdownTimer(v[3],v[4])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TElapsedTime" then
						CTrigger(PlayerID,{TElapsedTime(v[3],v[4])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TKills" then
						CTrigger(PlayerID,{TKills(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TScore" then
						CTrigger(PlayerID,{TScore(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TOpponents" then
						CTrigger(PlayerID,{TOpponents(v[3],v[4],v[5])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TWariableX" then
						CTrigger(PlayerID,{TWariableX(v[3],v[4],v[5],v[6],v[7],v[8])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TWariable" then
						CTrigger(PlayerID,{TWariable(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TWArrayX" then
						CTrigger(PlayerID,{TWArrayX(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TCWar" then
						CTrigger(PlayerID,{TCWar(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TNWar" then
						CTrigger(PlayerID,{TNWar(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TCWAar" then
						CTrigger(PlayerID,{TCWAar(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					end
				elseif v[1] == "TT" then -- TT조건
					if v[2] == "TTMemoryX" then
						CTrigger(PlayerID,{TTMemoryX(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTMemory" then
						CTrigger(PlayerID,{TTMemory(v[3],v[4],v[5])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTLMemoryX" then
						CTrigger(PlayerID,{TTLMemoryX(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTLMemory" then
						CTrigger(PlayerID,{TTLMemory(v[3],v[4],v[5])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTCVar" then
						CTrigger(PlayerID,{TTCVar(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTCVAar" then
						CTrigger(PlayerID,{TTCVAar(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTVariableX" then
						CTrigger(PlayerID,{TTVariableX(v[3],v[4],v[5],v[6],v[7],v[8])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTVariable" then
						CTrigger(PlayerID,{TTVariable(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTVArrayX" then
						CTrigger(PlayerID,{TTVArrayX(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTNDeathsX" then
						CTrigger(PlayerID,{TTNDeathsX(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTNDeaths" then
						CTrigger(PlayerID,{TTNDeaths(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTCDeathsX" then
						CTrigger(PlayerID,{TTCDeathsX(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTCDeaths" then
						CTrigger(PlayerID,{TTCDeaths(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTCtrigX" then
						CTrigger(PlayerID,{TTCtrigX(v[3],v[4],v[5],v[6],v[7],v[8],v[9])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTDeaths" then
						CTrigger(PlayerID,{TTDeaths(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTDeathsX" then
						CTrigger(PlayerID,{TTDeathsX(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTCommand" then
						CTrigger(PlayerID,{TTCommand(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTBring" then
						CTrigger(PlayerID,{TTBring(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTAccumulate" then
						CTrigger(PlayerID,{TTAccumulate(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTCountdownTimer" then
						CTrigger(PlayerID,{TTCountdownTimer(v[3],v[4])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTElapsedTime" then
						CTrigger(PlayerID,{TTElapsedTime(v[3],v[4])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTKills" then
						CTrigger(PlayerID,{TTKills(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTScore" then
						CTrigger(PlayerID,{TTScore(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTOpponents" then
						CTrigger(PlayerID,{TTOpponents(v[3],v[4],v[5])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTWariableX" then
						CTrigger(PlayerID,{TTWariableX(v[3],v[4],v[5],v[6],v[7],v[8])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTWariable" then
						CTrigger(PlayerID,{TTWariable(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTWArrayX" then
						CTrigger(PlayerID,{TTWArrayX(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTCWar" then
						CTrigger(PlayerID,{TTCWar(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTNWar" then
						CTrigger(PlayerID,{TTNWar(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTCWAar" then
						CTrigger(PlayerID,{TTCWAar(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTbytecmp" then
						CTrigger(PlayerID,{TTbytecmp(v[3],v[4],v[5],v[6])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					elseif v[2] == "TTbytecmpX" then
						CTrigger(PlayerID,{TTbytecmpX(v[3],v[4],v[5],v[6],v[7])},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
					end
				elseif v[1] == "AND" then -- AND조건
					local ANDCond = {}
					for p, q in pairs(v[2]) do
						if q[1] == "T" then -- T조건
							if q[2] == "TMemoryX" then
								table.insert(ANDCond,{TMemoryX(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TMemory" then
								table.insert(ANDCond,{TMemory(q[3],q[4],q[5])})
							elseif q[2] == "TCVar" then
								table.insert(ANDCond,{TCVar(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TCVAar" then
								table.insert(ANDCond,{TCVAar(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TVariableX" then
								table.insert(ANDCond,{TVariableX(q[3],q[4],q[5],q[6],q[7],q[8])})
							elseif q[2] == "TVariable" then
								table.insert(ANDCond,{TVariable(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TVArrayX" then
								table.insert(ANDCond,{TVArrayX(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TNDeathsX" then
								table.insert(ANDCond,{TNDeathsX(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TNDeaths" then
								table.insert(ANDCond,{TNDeaths(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TCDeathsX" then
								table.insert(ANDCond,{TCDeathsX(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TCDeaths" then
								table.insert(ANDCond,{TCDeaths(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TCtrigX" then
								table.insert(ANDCond,{TCtrigX(q[3],q[4],q[5],q[6],q[7],q[8],q[9])})
							elseif q[2] == "TDeaths" then
								table.insert(ANDCond,{TDeaths(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TDeathsX" then
								table.insert(ANDCond,{TDeathsX(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TCommand" then
								table.insert(ANDCond,{TCommand(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TBring" then
								table.insert(ANDCond,{TBring(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TAccumulate" then
								table.insert(ANDCond,{TAccumulate(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TCountdownTimer" then
								table.insert(ANDCond,{TCountdownTimer(q[3],q[4])})
							elseif q[2] == "TElapsedTime" then
								table.insert(ANDCond,{TElapsedTime(q[3],q[4])})
							elseif q[2] == "TKills" then
								table.insert(ANDCond,{TKills(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TScore" then
								table.insert(ANDCond,{TScore(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TOpponents" then
								table.insert(ANDCond,{TOpponents(q[3],q[4],q[5])})
							elseif q[2] == "TWariableX" then
								table.insert(ANDCond,{TWariableX(q[3],q[4],q[5],q[6],q[7],q[8])})
							elseif q[2] == "TWariable" then
								table.insert(ANDCond,{TWariable(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TWArrayX" then
								table.insert(ANDCond,{TWArrayX(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TCWar" then
								table.insert(ANDCond,{TCWar(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TNWar" then
								table.insert(ANDCond,{TNWar(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TCWAar" then
								table.insert(ANDCond,{TCWAar(q[3],q[4],q[5],q[6])})
							end
						elseif q[1] == "TT" then -- TT조건
							if q[2] == "TTMemoryX" then
								table.insert(ANDCond,{TTMemoryX(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTMemory" then
								table.insert(ANDCond,{TTMemory(q[3],q[4],q[5])})
							elseif q[2] == "TTLMemoryX" then
								table.insert(ANDCond,{TTLMemoryX(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTLMemory" then
								table.insert(ANDCond,{TTLMemory(q[3],q[4],q[5])})
							elseif q[2] == "TTCVar" then
								table.insert(ANDCond,{TTCVar(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TTCVAar" then
								table.insert(ANDCond,{TTCVAar(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTVariableX" then
								table.insert(ANDCond,{TTVariableX(q[3],q[4],q[5],q[6],q[7],q[8])})
							elseif q[2] == "TTVariable" then
								table.insert(ANDCond,{TTVariable(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TTVArrayX" then
								table.insert(ANDCond,{TTVArrayX(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TTNDeathsX" then
								table.insert(ANDCond,{TTNDeathsX(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TTNDeaths" then
								table.insert(ANDCond,{TTNDeaths(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTCDeathsX" then
								table.insert(ANDCond,{TTCDeathsX(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TTCDeaths" then
								table.insert(ANDCond,{TTCDeaths(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTCtrigX" then
								table.insert(ANDCond,{TTCtrigX(q[3],q[4],q[5],q[6],q[7],q[8],q[9])})
							elseif q[2] == "TTDeaths" then
								table.insert(ANDCond,{TTDeaths(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTDeathsX" then
								table.insert(ANDCond,{TTDeathsX(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TTCommand" then
								table.insert(ANDCond,{TTCommand(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTBring" then
								table.insert(ANDCond,{TTBring(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TTAccumulate" then
								table.insert(ANDCond,{TTAccumulate(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTCountdownTimer" then
								table.insert(ANDCond,{TTCountdownTimer(q[3],q[4])})
							elseif q[2] == "TTElapsedTime" then
								table.insert(ANDCond,{TTElapsedTime(q[3],q[4])})
							elseif q[2] == "TTKills" then
								table.insert(ANDCond,{TTKills(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTScore" then
								table.insert(ANDCond,{TTScore(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTOpponents" then
								table.insert(ANDCond,{TTOpponents(q[3],q[4],q[5])})
							elseif q[2] == "TTWariableX" then
								table.insert(ANDCond,{TTWariableX(q[3],q[4],q[5],q[6],q[7],q[8])})
							elseif q[2] == "TTWariable" then
								table.insert(ANDCond,{TTWariable(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TTWArrayX" then
								table.insert(ANDCond,{TTWArrayX(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TTCWar" then
								table.insert(ANDCond,{TTCWar(q[3],q[4],q[5],q[6],q[7])})
							elseif q[2] == "TTNWar" then
								table.insert(ANDCond,{TTNWar(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTCWAar" then
								table.insert(ANDCond,{TTCWAar(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTbytecmp" then
								table.insert(ANDCond,{TTbytecmp(q[3],q[4],q[5],q[6])})
							elseif q[2] == "TTbytecmpX" then
								table.insert(ANDCond,{TTbytecmpX(q[3],q[4],q[5],q[6],q[7])})
							end
						else -- 일반 조건
							table.insert(ANDCond,{q})
						end
					end
					CTrigger(PlayerID,{ANDCond},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
				else -- 일반 조건
					CTrigger(PlayerID,{v},{SetCDeaths("X",SetTo,1,ORFCodeArr[i])},{Preserved})
				end
			end
		end

		PushCondArr = TempArr
		CondLineArr = TempArr2
		PushActArr = TempArr3
		ActLineArr = TempArr4
		STPushTrigArr = TempArr5
		PushTrigArr = TempArr6
		PushTrigStack = TempArr7
		TTPushTrigArr = TTempArr
		TTPushCondArr = TTempArr2
		TTFCodeArr = TTempArr3
		TTModeArr = TTempArr4
		ORPushCondArr = {}
		ORFCodeArr = {}
		ORPopTrigLock = 0

		VarXAlloc = 0xFE00
		WarXAlloc = 0xFC00
		for j = 1, 32 do
			SVarXAlloc[j] = SVarXOrig[j]
		end
		VarXReleaseLock = 0
	end
end


function InitCtrig()
	for P = 1, 8 do

		local k = 1
		local Size = #CtrigInitArr[P]

		while k <= Size do
			if Size - k + 1 >= 64 then
				local X = {}
				for i = 0, 63 do
					table.insert(X, CtrigInitArr[P][k])
					k = k + 1
				end
				Trigger {
						players = {P-1},
						conditions = {
							Label(0);
						},
						actions = {
							X,
						},
					}
			else
				local X = {}
				repeat
					table.insert(X, CtrigInitArr[P][k])
					k = k + 1
				until k == Size + 1
				Trigger {
						players = {P-1},
						conditions = {
							Label(0);
						},
						actions = {
							X,
						},
					}
			end
		end
	end
end

function FlagIndex(FlagID)
	return (FlagID/480) + (FlagID%480)*0x100000 + FlagAllocBase
end
--[[
function PatchCond(Conditions)
	if Conditions == nil then Conditions = {} end
	if #Conditions == 8 and type(Conditions[6]) == "number" then
		Conditions = {Conditions}
	end

	local Size = #Conditions
	local Cond = {}
	for i = 1, Size do
		if type(Conditions[i]) == "table" then
			if type(Conditions[i][6]) == "number" then
				table.insert(Cond,Conditions[i])
			elseif Conditions[i][1] == "TCond" or (type(Conditions[i][1]) == "table" and type(Conditions[i][1][6]) == "number") then
				for j = 1, #Conditions[i] do
					table.insert(Cond,Conditions[i][j])
				end
			end
		elseif Conditions[i] == "TCond" then
			table.insert(Cond,Conditions[i])
		end
	end

	return Cond
end

function PatchAct(Actions)
	if Actions == nil then Actions = {} end
	if #Actions == 10 and type(Actions[8]) == "number" then
		Actions = {Actions}
	end

	local Size = #Actions
	local Act = {}
	for i = 1, Size do
		if type(Actions[i]) == "table" then
			if type(Actions[i][8]) == "number" then
				table.insert(Act,Actions[i])
			elseif Actions[i][1] == "TAct" or (type(Actions[i][1]) == "table" and type(Actions[i][1][8]) == "number") then
				for j = 1, #Actions[i] do
					table.insert(Act,Actions[i][j])
				end
			end
		elseif Actions[i] == "TAct" then
			table.insert(Act,Actions[i])
		end
	end

	return Act
end
]]--
function PopCondArr(Conditions)
	if TPopTrigLock == 0 then
		if Conditions ~= nil then
			StackArrptr = 0
			for i, Cond in pairs(Conditions) do
				if Cond == "TCond" then
					StackArrptr = StackArrptr + 1
					Conditions[i] = PushCondArr[StackArrptr]
					for k = 1, CondLineArr[StackArrptr] do
						table.insert(PushCondStack,i)
					end
				end
			end
			PushCondArr = {}
		end
	end
	return Conditions
end

function PopActArr(Actions)
	if TPopTrigLock == 0 then
		if Actions ~= nil then
			StackArrptr = 0
			for i, Act in pairs(Actions) do
				if Act == "TAct" then
					StackArrptr  = StackArrptr + 1
					Actions[i] = PushActArr[StackArrptr]
					for k = 1, ActLineArr[StackArrptr] do
						table.insert(PushActStack,i)
					end
				end
			end
			PushActArr = {}
		end
	end
	return Actions
end

function PopTrigArr(PlayerID,ActPushLine,CondPushLine)
	if TPopTrigLock == 0 then
		CondStackCount = 0
		for k, v in pairs(PushCondStack) do
			CondStackCount = CondStackCount + 1
		end
		for i, Act in pairs(PushTrigArr) do

			if CondPushLine == nil then
				CondPushLine = 0
			end
			if ActPushLine == nil then
				ActPushLine = 0
			end

			if Act[5][5] >= (0x128/4) then
				Act[4][6] = Act[4][6] + (ActPushLine + PushActStack[i-CondStackCount]) * (0x20/4)
				Act[5][5] = Act[5][5] + (ActPushLine + PushActStack[i-CondStackCount]) * (0x20/4)
			else 
				Act[4][6] = Act[4][6] + (CondPushLine + PushCondStack[i]) * (0x14/4)
				Act[5][5] = Act[5][5] + (CondPushLine + PushCondStack[i]) * (0x14/4)
			end

			Act[4][6] = Act[4][6] + (0x970/4) * PushTrigStack
			Act[5][5] = Act[5][5] + (0x970/4) * PushTrigStack

			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					Act,
				},
				flag = {Preserved}
			}

			PushTrigStack = PushTrigStack - 1
		end

		PushTrigArr = {}
		PushTrigStack = 0
		PushCondArr = {}
		PushCondStack = {}
		PushActArr = {}
		PushActStack = {}
		CondStackCount = 0
		StackArrptr = 0
		CondLineArr = {}
		ActLineArr = {}
	end
end

 
function TTPopTrigArr(PlayerID)

	if TTPopTrigLock == 0 then

		for i, TargetCond in pairs(TTPushCondArr) do
			local Size = 0
			if TTPushTrigArr[i] ~= nil then
				for k, v in pairs(TTPushTrigArr[i]) do
					Size = Size + 1
				end
			end
			local Stack = Size
			local FCode = TTFCodeArr[i]

			if TTModeArr[i] == 0 then
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,1,FCode),SetCtrig1X("X","X",0x28,Size+1,SetTo,Exactly*65536,0xFF0000)})

				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[4][6] = Act[4][6] + (0x970/4) * Stack
						Act[5][5] = Act[5][5] + (0x970/4) * Stack

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode);
					},
					flag = {Preserved}
				}
			elseif TTModeArr[i] == 1 then
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode),
							SetCtrigX("X","X",0x4,Size+1,SetTo,"X","X",0x0,0,Size+2),
							SetCtrig1X("X","X",0x15C,Size+1,SetTo,1),
							SetCtrig1X("X","X",0x28,Size+1,SetTo,AtLeast*65536,0xFF0000)})

				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[4][6] = Act[4][6] + (0x970/4) * Stack
						Act[5][5] = Act[5][5] + (0x970/4) * Stack

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}
				DoActionsX(PlayerID,{SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1),
									SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1),
									SetCtrig1X("X","X",0x15C,-1,SetTo,0),
									SetCtrig1X("X","X",0x28,-1,SetTo,Exactly*65536,0xFF0000)})
			elseif TTModeArr[i] == 2 then
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode),
							SetCtrigX("X","X",0x4,Size+1,SetTo,"X","X",0x0,0,Size+2),
							SetCtrig1X("X","X",0x15C,Size+1,SetTo,1),
							SetCtrig1X("X","X",0x28,Size+1,SetTo,AtMost*65536,0xFF0000)})

				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[4][6] = Act[4][6] + (0x970/4) * Stack
						Act[5][5] = Act[5][5] + (0x970/4) * Stack

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}
				DoActionsX(PlayerID,{SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1),
									SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1),
									SetCtrig1X("X","X",0x15C,-1,SetTo,0),
									SetCtrig1X("X","X",0x28,-1,SetTo,Exactly*65536,0xFF0000)})
			elseif TTModeArr[i] == 10 then -- iAtLeast
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode),
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,TargetCond[3],0x80000000);
				SetCtrigX("X","X",0x4,Size+1,SetTo,"X","X",0x0,0,Size+2);
				SetCtrigX("X","X",0x4,Size+2,SetTo,"X","X",0x0,0,Size+3);
				SetCtrig1X("X","X",0x28,Size+3,SetTo,AtLeast*65536,0xFF0000)})

				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[4][6] = Act[4][6] + (0x970/4) * Stack
						Act[5][5] = Act[5][5] + (0x970/4) * Stack

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[2],0x00000000,0,Exactly,0xF,0,0x80); -- X >= 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x80000000,0x80000000); -- Y < 0
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,3);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[2],0x80000000,0,Exactly,0xF,0,0x80); -- X < 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x00000000,0x80000000); -- Y >= 0
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}
			elseif TTModeArr[i] == 14 then -- CiAtLeast
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode),
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,TargetCond[3],0x80000000);
				SetCtrigX("X","X",0x4,Size+1,SetTo,"X","X",0x0,0,Size+2);
				SetCtrigX("X","X",0x4,Size+2,SetTo,"X","X",0x0,0,Size+3);
				SetCtrig1X("X","X",0x28,Size+3,SetTo,AtLeast*65536,0xFF0000)})

				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[4][6] = Act[4][6] + (0x970/4) * Stack
						Act[5][5] = Act[5][5] + (0x970/4) * Stack

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[2],0x00000000,TargetCond[4],Exactly,0xFF,TargetCond[7],0x80); -- X >= 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x80000000,0x80000000); -- Y < 0
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,3);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[2],0x80000000,TargetCond[4],Exactly,0xFF,TargetCond[7],0x80); -- X < 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x00000000,0x80000000); -- Y >= 0
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}
			elseif TTModeArr[i] == 11 then -- iAtMost
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode),
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,TargetCond[3],0x80000000);
				SetCtrigX("X","X",0x4,Size+1,SetTo,"X","X",0x0,0,Size+2);
				SetCtrigX("X","X",0x4,Size+2,SetTo,"X","X",0x0,0,Size+3);
				SetCtrig1X("X","X",0x28,Size+3,SetTo,AtMost*65536,0xFF0000)})

				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[4][6] = Act[4][6] + (0x970/4) * Stack
						Act[5][5] = Act[5][5] + (0x970/4) * Stack

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[2],0x00000000,0,Exactly,0xF,0,0x80); -- X >= 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x80000000,0x80000000); -- Y < 0
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,3);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[2],0x80000000,0,Exactly,0xF,0,0x80); -- X < 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x00000000,0x80000000); -- Y >= 0
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}
			elseif TTModeArr[i] == 15 then -- CiAtMost
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode),
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,TargetCond[3],0x80000000);
				SetCtrigX("X","X",0x4,Size+1,SetTo,"X","X",0x0,0,Size+2);
				SetCtrigX("X","X",0x4,Size+2,SetTo,"X","X",0x0,0,Size+3);
				SetCtrig1X("X","X",0x28,Size+3,SetTo,AtMost*65536,0xFF0000)})

				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[4][6] = Act[4][6] + (0x970/4) * Stack
						Act[5][5] = Act[5][5] + (0x970/4) * Stack

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[2],0x00000000,TargetCond[4],Exactly,0xFF,TargetCond[7],0x80); -- X >= 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x80000000,0x80000000); -- Y < 0
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,3);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[2],0x80000000,TargetCond[4],Exactly,0xFF,TargetCond[7],0x80); -- X < 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x00000000,0x80000000); -- Y >= 0
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}
			elseif TTModeArr[i] == 12 then -- iAbove
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode),
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,TargetCond[3],0x80000000);
				SetCtrigX("X","X",0x4,Size+1,SetTo,"X","X",0x0,0,Size+2);
				SetCtrigX("X","X",0x4,Size+2,SetTo,"X","X",0x0,0,Size+3);

				SetCtrigX("X","X",0x4,Size+3,SetTo,"X","X",0x0,0,Size+4),
				SetCtrig1X("X","X",0x15C,Size+3,SetTo,1),
				SetCtrig1X("X","X",0x28,Size+3,SetTo,AtLeast*65536,0xFF0000)})

				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[4][6] = Act[4][6] + (0x970/4) * Stack
						Act[5][5] = Act[5][5] + (0x970/4) * Stack

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[2],0x00000000,0,Exactly,0xF,0,0x80); -- X >= 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x80000000,0x80000000); -- Y < 0
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,3);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[2],0x80000000,0,Exactly,0xF,0,0x80); -- X < 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x00000000,0x80000000); -- Y >= 0
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}

				DoActionsX(PlayerID,{SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1),
									SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1),
									SetCtrig1X("X","X",0x15C,-1,SetTo,0),
									SetCtrig1X("X","X",0x28,-1,SetTo,Exactly*65536,0xFF0000)})
			elseif TTModeArr[i] == 16 then -- CiAbove
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode),
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,TargetCond[3],0x80000000);
				SetCtrigX("X","X",0x4,Size+1,SetTo,"X","X",0x0,0,Size+2);
				SetCtrigX("X","X",0x4,Size+2,SetTo,"X","X",0x0,0,Size+3);

				SetCtrigX("X","X",0x4,Size+3,SetTo,"X","X",0x0,0,Size+4),
				SetCtrig1X("X","X",0x15C,Size+3,SetTo,1),
				SetCtrig1X("X","X",0x28,Size+3,SetTo,AtLeast*65536,0xFF0000)})

				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[4][6] = Act[4][6] + (0x970/4) * Stack
						Act[5][5] = Act[5][5] + (0x970/4) * Stack

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[2],0x00000000,TargetCond[4],Exactly,0xFF,TargetCond[7],0x80); -- X >= 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x80000000,0x80000000); -- Y < 0
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,3);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[2],0x80000000,TargetCond[4],Exactly,0xFF,TargetCond[7],0x80); -- X < 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x00000000,0x80000000); -- Y >= 0
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}

				DoActionsX(PlayerID,{SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1),
									SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1),
									SetCtrig1X("X","X",0x15C,-1,SetTo,0),
									SetCtrig1X("X","X",0x28,-1,SetTo,Exactly*65536,0xFF0000)})
			elseif TTModeArr[i] == 13 then -- iBelow
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode),
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,TargetCond[3],0x80000000);
				SetCtrigX("X","X",0x4,Size+1,SetTo,"X","X",0x0,0,Size+2);
				SetCtrigX("X","X",0x4,Size+2,SetTo,"X","X",0x0,0,Size+3);

				SetCtrigX("X","X",0x4,Size+3,SetTo,"X","X",0x0,0,Size+4),
				SetCtrig1X("X","X",0x15C,Size+3,SetTo,1),
				SetCtrig1X("X","X",0x28,Size+3,SetTo,AtMost*65536,0xFF0000)})

				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[4][6] = Act[4][6] + (0x970/4) * Stack
						Act[5][5] = Act[5][5] + (0x970/4) * Stack

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[2],0x00000000,0,Exactly,0xF,0,0x80); -- X >= 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x80000000,0x80000000); -- Y < 0
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,3);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[2],0x80000000,0,Exactly,0xF,0,0x80); -- X < 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x00000000,0x80000000); -- Y >= 0
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}

				DoActionsX(PlayerID,{SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1),
									SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1),
									SetCtrig1X("X","X",0x15C,-1,SetTo,0),
									SetCtrig1X("X","X",0x28,-1,SetTo,Exactly*65536,0xFF0000)})
			elseif TTModeArr[i] == 17 then -- CiBelow
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode),
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,TargetCond[3],0x80000000);
				SetCtrigX("X","X",0x4,Size+1,SetTo,"X","X",0x0,0,Size+2);
				SetCtrigX("X","X",0x4,Size+2,SetTo,"X","X",0x0,0,Size+3);

				SetCtrigX("X","X",0x4,Size+3,SetTo,"X","X",0x0,0,Size+4),
				SetCtrig1X("X","X",0x15C,Size+3,SetTo,1),
				SetCtrig1X("X","X",0x28,Size+3,SetTo,AtMost*65536,0xFF0000)})

				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[4][6] = Act[4][6] + (0x970/4) * Stack
						Act[5][5] = Act[5][5] + (0x970/4) * Stack

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[2],0x00000000,TargetCond[4],Exactly,0xFF,TargetCond[7],0x80); -- X >= 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x80000000,0x80000000); -- Y < 0
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,3);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[2],0x80000000,TargetCond[4],Exactly,0xFF,TargetCond[7],0x80); -- X < 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x00000000,0x80000000); -- Y >= 0
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}

				DoActionsX(PlayerID,{SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1),
									SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1),
									SetCtrig1X("X","X",0x15C,-1,SetTo,0),
									SetCtrig1X("X","X",0x28,-1,SetTo,Exactly*65536,0xFF0000)})

			elseif TTModeArr[i] == 3 then -- LExactly
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode)})

				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[6][6] = Act[6][6] + (0x970/4) * Stack -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) * Stack -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) * Stack -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) * Stack -- EPD NEXT

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}

			elseif TTModeArr[i] == 4 then -- LNotSame
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,1,FCode)})

				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[6][6] = Act[6][6] + (0x970/4) * Stack -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) * Stack -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) * Stack -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) * Stack -- EPD NEXT

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode);
					},
					flag = {Preserved}
				}

			elseif TTModeArr[i] == 5 then -- LAtLeast
				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[6][6] = Act[6][6] + (0x970/4) * (2*Stack+1) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) * (2*Stack+1) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) * (2*Stack+1) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) * (2*Stack+1) -- EPD NEXT

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Act[6][6] = Act[6][6] + (0x970/4) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) -- EPD NEXT

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode),
					SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2),
					SetCtrig1X("X","X",0x28,1,SetTo,AtMost*65536,0xFF0000),
					SetCtrig1X("X","X",0x28+0x14,3,SetTo,AtLeast*65536,0xFF0000),
					SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,4),
				})

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond[1],
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCDeaths("X",SetTo,1,FCode);
						},
						flag = {Preserved}
					}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}
			elseif TTModeArr[i] == 25 then -- LiAtLeast
				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[6][6] = Act[6][6] + (0x970/4) * (2*Stack+4) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) * (2*Stack+4) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) * (2*Stack+4) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) * (2*Stack+4) -- EPD NEXT

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Act[6][6] = Act[6][6] + (0x970/4) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) -- EPD NEXT

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode),
					SetCtrigX("X","X",0x4,4,SetTo,"X","X",0x0,0,5),
					SetCtrig1X("X","X",0x28,4,SetTo,AtMost*65536,0xFF0000),
					SetCtrig1X("X","X",0x28+0x14,6,SetTo,AtLeast*65536,0xFF0000),
					SetCtrigX("X","X",0x4,5,SetTo,"X","X",0x0,0,7),
					SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,3);
					SetCtrigX("X","X",0x4,3,SetTo,"X","X",0x0,0,4);
					SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0,0x80000000);
				})

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX("X","X",0x24,3,Exactly,0x80000000,0x80000000);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0x80000000,0x80000000);
					},
					flag = {Preserved}
				}

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[1][2],0x00000000,0,Exactly,0xF,0,0x80); -- X >= 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x80000000,0x80000000); -- Y < 0
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,5);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[1][2],0x80000000,0,Exactly,0xF,0,0x80); -- X < 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x00000000,0x80000000); -- Y >= 0
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,4);
					},
					flag = {Preserved}
				}

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond[1],
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCDeaths("X",SetTo,1,FCode);
						},
						flag = {Preserved}
					}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}
			elseif TTModeArr[i] == 6 then -- LBelow
				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[6][6] = Act[6][6] + (0x970/4) * (2*Stack+1) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) * (2*Stack+1) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) * (2*Stack+1) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) * (2*Stack+1) -- EPD NEXT

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Act[6][6] = Act[6][6] + (0x970/4) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) -- EPD NEXT

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,1,FCode),
					SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2),
					SetCtrig1X("X","X",0x28,1,SetTo,AtMost*65536,0xFF0000),
					SetCtrig1X("X","X",0x28+0x14,3,SetTo,AtLeast*65536,0xFF0000),
					SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,4),
				})

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond[1],
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCDeaths("X",SetTo,0,FCode);
						},
						flag = {Preserved}
					}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode);
					},
					flag = {Preserved}
				}
			elseif TTModeArr[i] == 28 then -- LiBelow
				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[6][6] = Act[6][6] + (0x970/4) * (2*Stack+4) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) * (2*Stack+4) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) * (2*Stack+4) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) * (2*Stack+4) -- EPD NEXT

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Act[6][6] = Act[6][6] + (0x970/4) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) -- EPD NEXT

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,1,FCode),
					SetCtrigX("X","X",0x4,4,SetTo,"X","X",0x0,0,5),
					SetCtrig1X("X","X",0x28,4,SetTo,AtMost*65536,0xFF0000),
					SetCtrig1X("X","X",0x28+0x14,6,SetTo,AtLeast*65536,0xFF0000),
					SetCtrigX("X","X",0x4,5,SetTo,"X","X",0x0,0,7),
					SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,3);
					SetCtrigX("X","X",0x4,3,SetTo,"X","X",0x0,0,4);
					SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0,0x80000000);
				})

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX("X","X",0x24,3,Exactly,0x80000000,0x80000000);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0x80000000,0x80000000);
					},
					flag = {Preserved}
				}

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[1][2],0x00000000,0,Exactly,0xF,0,0x80); -- X >= 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x80000000,0x80000000); -- Y < 0
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,5);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[1][2],0x80000000,0,Exactly,0xF,0,0x80); -- X < 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x00000000,0x80000000); -- Y >= 0
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,4);
					},
					flag = {Preserved}
				}

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond[1],
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCDeaths("X",SetTo,0,FCode);
						},
						flag = {Preserved}
					}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode);
					},
					flag = {Preserved}
				}
			elseif TTModeArr[i] == 7 then -- LAtMost
				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[6][6] = Act[6][6] + (0x970/4) * (2*Stack+1) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) * (2*Stack+1) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) * (2*Stack+1) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) * (2*Stack+1) -- EPD NEXT

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Act[6][6] = Act[6][6] + (0x970/4) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) -- EPD NEXT

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode),
					SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2),
					SetCtrig1X("X","X",0x28,1,SetTo,AtLeast*65536,0xFF0000),
					SetCtrig1X("X","X",0x28+0x14,3,SetTo,AtMost*65536,0xFF0000),
					SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,4),
				})

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond[1],
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCDeaths("X",SetTo,1,FCode);
						},
						flag = {Preserved}
					}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}
			elseif TTModeArr[i] == 26 then -- LiAtMost
				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[6][6] = Act[6][6] + (0x970/4) * (2*Stack+4) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) * (2*Stack+4) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) * (2*Stack+4) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) * (2*Stack+4) -- EPD NEXT

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Act[6][6] = Act[6][6] + (0x970/4) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) -- EPD NEXT

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,0,FCode),
					SetCtrigX("X","X",0x4,4,SetTo,"X","X",0x0,0,5),
					SetCtrig1X("X","X",0x28,4,SetTo,AtLeast*65536,0xFF0000),
					SetCtrig1X("X","X",0x28+0x14,6,SetTo,AtMost*65536,0xFF0000),
					SetCtrigX("X","X",0x4,5,SetTo,"X","X",0x0,0,7),
					SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,3);
					SetCtrigX("X","X",0x4,3,SetTo,"X","X",0x0,0,4);
					SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0,0x80000000);
				})

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX("X","X",0x24,3,Exactly,0x80000000,0x80000000);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0x80000000,0x80000000);
					},
					flag = {Preserved}
				}

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[1][2],0x00000000,0,Exactly,0xF,0,0x80); -- X >= 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x80000000,0x80000000); -- Y < 0
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,5);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[1][2],0x80000000,0,Exactly,0xF,0,0x80); -- X < 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x00000000,0x80000000); -- Y >= 0
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,4);
					},
					flag = {Preserved}
				}

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond[1],
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCDeaths("X",SetTo,1,FCode);
						},
						flag = {Preserved}
					}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}
			elseif TTModeArr[i] == 8 then -- LAbove
				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[6][6] = Act[6][6] + (0x970/4) * (2*Stack+1) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) * (2*Stack+1) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) * (2*Stack+1) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) * (2*Stack+1) -- EPD NEXT

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Act[6][6] = Act[6][6] + (0x970/4) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) -- EPD NEXT

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,1,FCode),
					SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2),
					SetCtrig1X("X","X",0x28,1,SetTo,AtLeast*65536,0xFF0000),
					SetCtrig1X("X","X",0x28+0x14,3,SetTo,AtMost*65536,0xFF0000),
					SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,4),
				})

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond[1],
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCDeaths("X",SetTo,0,FCode);
						},
						flag = {Preserved}
					}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode);
					},
					flag = {Preserved}
				}
			elseif TTModeArr[i] == 27 then -- LiAbove
				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do

						Act[6][6] = Act[6][6] + (0x970/4) * (2*Stack+4) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) * (2*Stack+4) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) * (2*Stack+4) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) * (2*Stack+4) -- EPD NEXT

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Act[6][6] = Act[6][6] + (0x970/4) -- Value NEXT
						Act[7][6] = Act[7][6] + (0x970/4) -- Value NEXT
						Act[8][5] = Act[8][5] + (0x970/4) -- EPD NEXT
						Act[9][5] = Act[9][5] + (0x970/4) -- EPD NEXT

						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Act,
							},
							flag = {Preserved}
						}

						Stack = Stack - 1
					end
				end
				DoActionsX(PlayerID,{SetCDeaths("X",SetTo,1,FCode),
					SetCtrigX("X","X",0x4,4,SetTo,"X","X",0x0,0,5),
					SetCtrig1X("X","X",0x28,4,SetTo,AtLeast*65536,0xFF0000),
					SetCtrig1X("X","X",0x28+0x14,6,SetTo,AtMost*65536,0xFF0000),
					SetCtrigX("X","X",0x4,5,SetTo,"X","X",0x0,0,7),
					SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,3);
					SetCtrigX("X","X",0x4,3,SetTo,"X","X",0x0,0,4);
					SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0,0x80000000);
				})

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX("X","X",0x24,3,Exactly,0x80000000,0x80000000);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0x80000000,0x80000000);
					},
					flag = {Preserved}
				}

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[1][2],0x00000000,0,Exactly,0xF,0,0x80); -- X >= 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x80000000,0x80000000); -- Y < 0
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,5);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(0x80000000,TargetCond[1][2],0x80000000,0,Exactly,0xF,0,0x80); -- X < 0 
						CtrigX("X",CRet[1],0x15C,0,Exactly,0x00000000,0x80000000); -- Y >= 0
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode),
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,4);
					},
					flag = {Preserved}
				}

				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond[1],
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCDeaths("X",SetTo,0,FCode);
						},
						flag = {Preserved}
					}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond,
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode);
					},
					flag = {Preserved}
				}
			elseif TTModeArr[i] == 9 then -- bytecmp(X)
				local STTemp = STPopTrigLock
				STPopTrigLock = 1
				if TargetCond[1] == "bytecmp" then
					 f_bytecmp(PlayerID,FCode,TargetCond[2],TargetCond[3],TargetCond[4],TargetCond[5])
				else
					 f_bytecmpX(PlayerID,FCode,TargetCond[2],TargetCond[3],TargetCond[4],TargetCond[5],TargetCond[6])
				end
				STPopTrigLock = STTemp
			elseif TTModeArr[i] == 22 then -- epdcmp
				local STTemp = STPopTrigLock
				local TTTemp = TTPopTrigLock
				STPopTrigLock = 1
				TTPopTrigLock = 1
				CS__epdcmp(PlayerID,TargetCond[1],TargetCond[2],TargetCond[3],TargetCond[4],FCode)
				STPopTrigLock = STTemp
				TTPopTrigLock = TTTemp
			elseif TTModeArr[i] == 30 then -- TTFunc
				local STTemp = STPopTrigLock
				STPopTrigLock = 1
				
				CallCFuncX(PlayerID,TargetCond[1],TargetCond[2],{_Ccode("X",FCode)})

				STPopTrigLock = STTemp
			elseif TTModeArr[i] == 31 then -- TTVFunc
				local STTemp = STPopTrigLock
				STPopTrigLock = 1
				
				CallVFuncX(PlayerID,TargetCond[1],TargetCond[2],{_Ccode("X",FCode)})

				STPopTrigLock = STTemp
			elseif TTModeArr[i] == 20 then -- TTKeyDown
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Condition(TargetCond[1],TargetCond[2],0,0,Exactly,0xF,0,0x80); -- Key == 0
					},
					actions = {
						SetCtrig1X("X","X",0x17C,0,SetTo,0); -- Switch Clear
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX("X","X",0x17C,-1,Exactly,0); -- Switch Cleared
						TargetCond, -- Key == 1
					},
					actions = {
						SetCtrig1X("X","X",0x17C,-1,SetTo,1); -- Switch Set
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}
			elseif TTModeArr[i] == 21 then -- TTKeyUp
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCDeaths("X",SetTo,0,FCode);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond, -- Key == 1
					},
					actions = {
						SetCtrig1X("X","X",0x17C,0,SetTo,1); -- Switch Set
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX("X","X",0x17C,-1,Exactly,1); -- Switch Set
						Condition(TargetCond[1],TargetCond[2],0,0,Exactly,0xF,0,0x80); -- Key == 0
					},
					actions = {
						SetCtrig1X("X","X",0x17C,-1,SetTo,0); -- Switch Clear
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}
			elseif TTModeArr[i] == 23 then -- TTDisplay
				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do
						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCDeaths("X",SetTo,0,FCode);
								Act,
							},
							flag = {Preserved}
						}
						Stack = Stack - 1
					end
				end
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond, -- CRet[2] == 1
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}
			elseif TTModeArr[i] == 24 then -- TTDisplayX
				if TTPushTrigArr[i] ~= nil then
					for j, Act in pairs(TTPushTrigArr[i]) do
						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCDeaths("X",SetTo,0,FCode);
								Act,
							},
							flag = {Preserved}
						}
						Stack = Stack - 1
					end
				end
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						TargetCond, -- CRet[5] == 1
					},
					actions = {
						SetCDeaths("X",SetTo,1,FCode);
					},
					flag = {Preserved}
				}
			end
		end
		TTFCodeArr = {}
		TTModeArr = {}
		TTPushTrigArr = {}
		TTPushCondArr = {}
	end
end

function STPopTrigArr(PlayerID)
	if STPopTrigLock == 0 and STPushTrigArr[1] ~= nil then
		STPopTrigLock = 1
		local _TPopTrigLockTemp = _TPopTrigLock
		local ORPopTrigLockTemp = ORPopTrigLock
		_TPopTrigLock = 1
		ORPopTrigLock = 1
		TTPopTrigLock = 1
		TPopTrigLock = 1
		--[[
		local VarXArr = {}
		for i = 0xFF00, VarXAlloc-1 do
			table.insert(VarXArr,SetCtrig1X("X",i,0x15C,0,SetTo,0))
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				VarXArr,
			},
			flag = {Preserved}
		}

--[[ STPop Clear List
CMov
CMovX
CRead
CReadX
f_Read
f_ReadX

SCast
SMov
SMovX

f_Cast
LMov
LMovX
LRead
LReadX

MovX
MovW
MovS

Clear -> Mask2 = 0xFFFFFFFF
Set 0x15C -> Deviation (없을시 0), Mask2
Mov 0x15C -> Value, Mask
]]--
		for k, v in pairs(STPushTrigArr) do			
			local z = 0
			for y, _ in pairs(v) do
				if y > z+1 then
					for i = z+1, y-1 do
						v[i] = "X"
					end
				end
				z = y
			end

			local Func = v[1]
			table.remove(v,1)

			_G[Func](PlayerID,table.unpack(v))
		end
		STPopTrigLock = 0
		_TPopTrigLock = _TPopTrigLockTemp
		ORPopTrigLock = ORPopTrigLockTemp
		TTPopTrigLock = 0
		TPopTrigLock = 0
	end
	STPushTrigArr = {}
	if VarXReleaseLock == 0 then
		VarXAlloc = 0xFE00
		WarXAlloc = 0xFC00
		for j = 1, 32 do
			SVarXAlloc[j] = SVarXOrig[j]
		end
	elseif VarXReleaseLock == 2 then
		VarXAlloc = _TPushVarXAlloc[1]
		WarXAlloc = _TPushVarXAlloc[2]
		for j = 1, 32 do
			SVarXAlloc[j] = _TPushVarXAlloc[3][j]
		end
	end
end

function _Chat(Line,Offset)
	if type(Line) == "number" and type(Offset) == "number" then
		return MakeChatOffset(Line,Offset)
	else
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"V"}

		table.insert(STPushTrigArr,{"f_ChatOffset",Line,Offset,TempData}) 

		VarXAlloc = VarXAlloc + 1
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TempData
	end
end

function _GIndex(Index)
	if type(Index) == "number" then
		local Ret = 0
		if Index >= 54*11 then
			Index = 0
		end
		for i = 3, 0, -1 do
			local CBit = 2^i
			if Index >= 54*CBit then
				Index = Index - 54*CBit
				Ret = Ret+604*CBit
			end
		end
		for i = 5, 0, -1 do
			local CBit = 2^i
			if Index >= CBit then
				Index = Index - CBit
				Ret = Ret+8*CBit
			end
		end
		return Ret
	else
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"V"}

		table.insert(STPushTrigArr,{"CS__GetIndex",Index,TempData}) 

		VarXAlloc = VarXAlloc + 1
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TempData
	end
end

function _GIndex2(Line,Index)
	if type(Index) == "number" and type(Line) == "number" then
		local Ret = 0
		if Line >= 11 then
			Line = 0
		end
		if Index >= 54 then
			Index = 0
		end
		for i = 3, 0, -1 do
			local CBit = 2^i
			if Line >= CBit then
				Line = Line - CBit
				Ret = Ret+604*CBit
			end
		end
		for i = 5, 0, -1 do
			local CBit = 2^i
			if Index >= CBit then
				Index = Index - CBit
				Ret = Ret+8*CBit
			end
		end
		return Ret
	else
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"V"}

		table.insert(STPushTrigArr,{"CS__GetIndex2",Line,Index,TempData}) 

		VarXAlloc = VarXAlloc + 1
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TempData
	end
end

function _MIndex(Index)
	if type(Index) == "number" then
		local Ret = 0
		if Index >= 54*11 then
			Index = 0
		end
		for i = 3, 0, -1 do
			local CBit = 2^i
			if Index >= 54*CBit then
				Index = Index - 54*CBit
				Ret = Ret+604*CBit
			end
		end
		for i = 5, 0, -1 do
			local CBit = 2^i
			if Index >= CBit then
				Index = Index - CBit
				Ret = Ret+8*CBit
			end
		end
		Ret = Ret-5
		return Ret
	else
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"V"}

		table.insert(STPushTrigArr,{"CS__GetMask",Index,TempData}) 

		VarXAlloc = VarXAlloc + 1
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TempData
	end
end

function _MIndex2(Line,Index)
	if type(Index) == "number" and type(Line) == "number" then
		local Ret = 0
		if Line >= 11 then
			Line = 0
		end
		if Index >= 54 then
			Index = 0
		end
		for i = 3, 0, -1 do
			local CBit = 2^i
			if Line >= CBit then
				Line = Line - CBit
				Ret = Ret+604*CBit
			end
		end
		for i = 5, 0, -1 do
			local CBit = 2^i
			if Index >= CBit then
				Index = Index - CBit
				Ret = Ret+8*CBit
			end
		end
		Ret = Ret-5
		return Ret
	else
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"V"}

		table.insert(STPushTrigArr,{"CS__GetMask2",Line,Index,TempData}) 

		VarXAlloc = VarXAlloc + 1
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TempData
	end
end

function _Func(CFunction,Parameter)
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if Parameter == nil then
		Parameter = {}
	end

	table.insert(STPushTrigArr,{"CallCFuncX",CFunction,Parameter,{TempData}}) 

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _byteConvert(Source)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}
	local Size = #Source

	table.insert(STPushTrigArr,{"CbyteConvert",TempData,Source}) 

	VarXAlloc = VarXAlloc + 4*(math.ceil(Size/4)+1)
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _byteConvertF(Source,Size,Distance)
	if Source == nil then
		Source = "X"
	end
	if Size == nil then
		Size = "X"
	end
	if Distance == nil then
		Distance = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"f_byteConvert",TempData,Source,Size,Distance}) 

	if type(Size) ~= "number" then
		_byteConvertF_InputData_Error()
	end

	VarXAlloc = VarXAlloc + 4*(math.ceil(Size/4)+1)
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _byteConvertFX(Source,SourceX,Size,Distance)
	if Source == nil then
		Source = "X"
	end
	if SourceX == nil then
		SourceX = "X"
	end
	if Size == nil then
		Size = "X"
	end
	if Distance == nil then
		Distance = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"f_byteConvertX",TempData,Source,SourceX,Size,Distance}) 

	if type(Size) ~= "number" then
		_byteConvertFX_InputData_Error()
	end

	VarXAlloc = VarXAlloc + 4*(math.ceil(Size/4)+1)
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _MovS(Number,Source,Mode,Mask) -- SVA -> SV
	if Number == nil then
		Number = "X"
	end
	if Source == nil then
		Source = "X"
	end
	if Mode == nil then
		Mode = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Number < 1 or Number > 32 then
		_MovS_InputData_Error()
	end
	local Temp = SVarXAlloc[Number]
	local TempData = {"X",Temp,0,"SV",Number}

	table.insert(STPushTrigArr,{"MovS",TempData,Source,Mode,Mask,1})

	SVarXAlloc[Number] = SVarXAlloc[Number] + 1
	if SVarXAlloc[Number] > MAXSVAlloc[Number] then
		MAXSVAlloc[Number] = SVarXAlloc[Number]
	end
	return TempData
end

function _SMov(Number,Source,Mode,Deviation,Mask) -- _xN -> SV
	if Number == nil then
		Number = "X"
	end
	if Source == nil then
		Source = "X"
	end
	if Mode == nil then
		Mode = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Number < 1 or Number > 32 then
		_SMov_InputData_Error()
	end
	local Temp = SVarXAlloc[Number]
	local TempData = {"X",Temp,0,"SV",Number}

	table.insert(STPushTrigArr,{"SMov",TempData,Source,Mode,Deviation,Mask,1})

	SVarXAlloc[Number] = SVarXAlloc[Number] + 1
	if SVarXAlloc[Number] > MAXSVAlloc[Number] then
		MAXSVAlloc[Number] = SVarXAlloc[Number]
	end
	return TempData
end

function _SCopy(SVData,DestLine,SourceLine)-- SVData -> SVData
	if SVData == nil then
		SVData = "X"
	end
	if DestLine == nil then
		DestLine = "X"
	end
	if SourceLine == nil then
		SourceLine = "X"
	end
	table.insert(STPushTrigArr,{"SCopy",SVData,DestLine,SourceLine})
	return SVData
end

function _CastS(Number,Source,Deviation,Mask) -- V(A) -> SV
	if Number == nil then
		Number = "X"
	end
	if Source == nil then
		Source = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Number < 1 or Number > 32 or Source[4] == "SV" or Source[4] == "SVA" then
		_CastS_InputData_Error()
	end
	local Temp = SVarXAlloc[Number]
	local TempData = {"X",Temp,0,"SV",Number}

	table.insert(STPushTrigArr,{"SCast",TempData,Source,Deviation,Mask,1})

	SVarXAlloc[Number] = SVarXAlloc[Number] + 1
	if SVarXAlloc[Number] > MAXSVAlloc[Number] then
		MAXSVAlloc[Number] = SVarXAlloc[Number]
	end
	return TempData
end

function _SCast(Source,Deviation,Mask) -- SV(A) -> V
	if Source == nil then
		Source = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Source[4] == "V" or Source[4] == "VA" then
		_SCast_InputData_Error()
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"SCast",TempData,Source,Deviation,Mask,1})

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _TSMem(Source,Address,Next,OffsetFlag) -- SV(A)_EPD -> V
	if Source == nil then
		Source = "X"
	end
	if Address == nil then
		Address = "X"
	end
	if Next == nil then
		Next = "X"
	end
	if OffsetFlag == nil then
		OffsetFlag = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"TSMem",TempData,Source,Address,Next,OffsetFlag})

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

--------------------------------------------------------------------------------------

function _TLMem(Source,Address,Next,OffsetFlag)  
	if Source == nil then
		Source = "X"
	end
	if Address == nil then
		Address = "X"
	end
	if Next == nil then
		Next = "X"
	end
	if OffsetFlag == nil then
		OffsetFlag = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"TLMem",TempData,Source,Address,Next,OffsetFlag})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _Cast(Dest,Source,Deviation,Mask) -- W(A) -> V
	if Dest == nil then
		Dest = "X"
	end
	if Source == nil then
		Source = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Source[4] == "V" or Source[4] == "VA" then
		_Cast_InputData_Error()
	end

	if Dest ~= 0 and Dest ~= 1 then
		_Cast_InputData_Error()
	end

	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"f_Cast",{TempData,Dest},Source,Deviation,Mask,1})

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _CastW(Source,Deviation,Mask) -- V(A) -> W
	if Source == nil then
		Source = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Source[4] == "W" or Source[4] == "WA" then
		_CastW_InputData_Error()
	end

	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_Cast",TempData,Source,Deviation,Mask,1})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _iCast(Source) -- W(A) -> V
	if Source == nil then
		Source = "X"
	end
	if Source[4] == "V" or Source[4] == "VA" then
		_iCast_InputData_Error()
	end

	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"f_iCast",TempData,Source})

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _iCastW(Source) -- V(A) -> W
	if Source == nil then
		Source = "X"
	end
	if Source[4] == "W" or Source[4] == "WA" then
		_iCastW_InputData_Error()
	end

	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_iCast",TempData,Source})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LMovX(Source,Mode,Mask,Deviation) -- _x2 -> W
	if Source == nil then
		Source = "X"
	end
	if Mode == nil then
		Mode = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LMovX",TempData,Source,Mode,Mask,Deviation,1})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LMov(Source,Mask,Deviation) -- _x2 -> W
	if Source == nil then
		Source = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LMov",TempData,Source,Deviation,Mask,1})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LRead(Source,Mask) -- _x2 -> W
	if Source == nil then
		Source = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LRead",Source,TempData,Mask,1})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LReadX(Source,Multiplier,Mask) -- _x2 -> W
	if Source == nil then
		Source = "X"
	end
	if Multiplier == nil then
		Multiplier = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LReadX",Source,TempData,Multiplier,Mask,1})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LAdd(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LAdd",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LSub(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LSub",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LiSub(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LiSub",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LNeg(Source) 
	if Source == nil then
		Source = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LNeg",TempData,Source})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LAbs(Source) 
	if Source == nil then
		Source = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LAbs",TempData,Source})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LRand() 
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LRand",TempData})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LAnd(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LAnd",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LOr(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LOr",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LXor(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LXor",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LNot(Source) 
	if Source == nil then
		Source = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LNot",TempData,Source})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LlShift(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LlShift",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LMul(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LMul",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LiMul(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LiMul",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LDiv(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LDiv",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LiDiv(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LiDiv",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LMod(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LMod",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _LiMod(Source,Operand) 
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}

	table.insert(STPushTrigArr,{"f_LiMod",TempData,Source,Operand})

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end
-- 중간 연산 함수(_) -------------------------------------------------------------------

function _TMem(Source,Address,Next,OffsetFlag)  
	if Source == nil then
		Source = "X"
	end
	if Address == nil then
		Address = "X"
	end
	if Next == nil then
		Next = "X"
	end
	if OffsetFlag == nil then
		OffsetFlag = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"TMem",TempData,Source,Address,Next,OffsetFlag})

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _MovX(Source,Mode,Mask,Deviation)
	if Source == nil then
		Source = "X"
	end
	if Mode == nil then
		Mode = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"CMovX",TempData,Source,Mode,Mask,Deviation,1})

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Mov(Source,Mask,Deviation)
	if Source == nil then
		Source = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		table.insert(STPushTrigArr,{"CMov",TempData,Source,Deviation,Mask,1}) -- A << 1
	elseif Source == "Cp" then
		Mov_InputData_Error()
	elseif Source[4] == "V" then
		table.insert(STPushTrigArr,{"CMov",TempData,Source,Deviation,Mask,1}) -- A << X
	elseif Source[4] == "VA" then
		table.insert(STPushTrigArr,{"CMov",TempData,Source,Deviation,Mask,1}) -- A << VA
	elseif Source[4] == "A" then
		Mov_InputData_Error()
	else
		Mov_InputData_Error()
	end

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

--[[
function _Mov(Source,Mask,Deviation,Clear)
	if Source == nil then
		Source = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if Clear == nil then Clear = 1 end
	if type(Source) == "number" then
		table.insert(STPushTrigArr,{"CMov",TempData,Source,Deviation,Mask,Clear}) -- A << 1
	elseif Source == "Cp" then
		Mov_InputData_Error()
	elseif Source[4] == "V" then
		table.insert(STPushTrigArr,{"CMov",TempData,Source,Deviation,Mask,Clear}) -- A << X
	elseif Source[4] == "VA" then
		table.insert(STPushTrigArr,{"CMov",TempData,Source,Deviation,Mask,Clear}) -- A << VA
	elseif Source[4] == "A" then
		Mov_InputData_Error()
	else
		Mov_InputData_Error()
	end

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end
]]--

function _Read(Source,Mask,Deviation)
	if Source == nil then
		Source = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"CRead",TempData,Source,Deviation,Mask,"X",1}) -- A << 0x58A364, Cp, EPD(X), Mem

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _ReadX(Source,Mask,Multiplier,Deviation)
	if Source == nil then
		Source = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Multiplier == nil then
		Multiplier = "X"
	end
	if Deviation == nil then
		Deviation = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"CReadX",TempData,Source,Deviation,Mask,Multiplier,1}) -- A << 0x58A364, Cp, EPD(X), Mem

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _EPDRead(Source)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"CRead",TempData,Source,"X","X",1}) -- A << EPD(0x58A364, Cp, EPD(X), Mem)

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _SHRead(Source,Mask)
	if Source == nil then
		Source = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"f_SHRead",Source,TempData,Mask,1}) -- A << 0x58A364, Cp, EPD(X), Mem

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _CUnitEPD(Source,Deviation)
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"f_CunitRead",Source,nil,TempData,Deviation}) 

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _CUnitPTR(Source,Deviation)
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"f_CunitRead",Source,TempData,nil,Deviation}) 

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _ReadF(Source,Mask)
	if Source == nil then
		Source = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"f_Read",Source,TempData,nil,Mask,1}) -- A << 0x58A364, Cp, EPD(X), Mem

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _ReadFX(Source,Mask,Multiplier)
	if Source == nil then
		Source = "X"
	end
	if Mask == nil then
		Mask = "X"
	end
	if Multiplier == nil then
		Multiplier = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"f_ReadX",Source,TempData,Multiplier,Mask,1}) -- A << 0x58A364, Cp, EPD(X), Mem

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _EPDReadF(Source)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"f_Read",Source,nil,TempData,0xFFFFFFFF,1})-- A << EPD(0x58A364, Cp, EPD(X), Mem)

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _EPD(Source)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		EPD_InputData_Error()
	elseif Source == "Cp" then
		EPD_InputData_Error()
	elseif Source[4] == "V" then
		table.insert(STPushTrigArr,{"f_EPD",TempData,Source}) -- A << EPD(V)
	elseif Source[4] == "VA" then
		table.insert(STPushTrigArr,{"f_EPD",TempData,Source}) -- A << EPD(VA) 
	elseif Source[4] == "A" then
		EPD_InputData_Error()
	else
		EPD_InputData_Error()
	end

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _EPD2(Source,Deviation)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		EPD2_InputData_Error()
	elseif Source == "Cp" then
		EPD2_InputData_Error()
	elseif Source[4] == "V" then
		table.insert(STPushTrigArr,{"CEPD",TempData,Source,Deviation}) -- A << EPD(V)
	elseif Source[4] == "VA" then
		table.insert(STPushTrigArr,{"CEPD",TempData,Source,Deviation}) -- A << EPD(VA) 
	elseif Source[4] == "A" then
		EPD2_InputData_Error()
	else
		EPD2_InputData_Error()
	end

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _EPDX(Source)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		EPD_InputData_Error()
	elseif Source == "Cp" then
		EPD_InputData_Error()
	elseif Source[4] == "V" then
		table.insert(STPushTrigArr,{"f_EPDX",TempData,Source}) -- A << EPD(V)
	elseif Source[4] == "VA" then
		table.insert(STPushTrigArr,{"f_EPDX",TempData,Source}) -- A << EPD(VA) 
	elseif Source[4] == "A" then
		EPD_InputData_Error()
	else
		EPD_InputData_Error()
	end

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Add(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Add_InputData_Error()
	elseif Source == "Cp" then
		Add_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CAdd",TempData,Source,Operand}) -- A << X + 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CAdd",TempData,Source,Operand}) -- A << X + Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CAdd",TempData,Source,Operand}) -- A << X + VA
		elseif Operand[4] == "A" then
			Add_InputData_Error()
		else
			Add_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CAdd",TempData,Source,Operand}) -- A << VA + 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CAdd",TempData,Source,Operand}) -- A << VA + Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CAdd",TempData,Source,Operand}) -- A << VA + VA
		elseif Operand[4] == "A" then
			Add_InputData_Error()
		else
			Add_InputData_Error()
		end
	elseif Source[4] == "A" then
		Add_InputData_Error()
	else
		Add_InputData_Error()
	end

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Sub(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Sub_InputData_Error()
	elseif Source == "Cp" then
		Sub_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CSub",TempData,Source,Operand}) -- A << X - 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CSub",TempData,Source,Operand}) -- A << X - Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CSub",TempData,Source,Operand}) -- A << X - VA
		elseif Operand[4] == "A" then
			Sub_InputData_Error()
		else
			Sub_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CSub",TempData,Source,Operand}) -- A << VA - 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CSub",TempData,Source,Operand}) -- A << VA - Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CSub",TempData,Source,Operand}) -- A << VA - VA
		elseif Operand[4] == "A" then
			Sub_InputData_Error()
		else
			Sub_InputData_Error()
		end
	else
		Sub_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _iSub(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		iSub_InputData_Error()
	elseif Source == "Cp" then
		iSub_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CiSub",TempData,Source,Operand}) -- A << X - 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CiSub",TempData,Source,Operand}) -- A << X - Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CiSub",TempData,Source,Operand}) -- A << X - VA
		elseif Operand[4] == "A" then
			iSub_InputData_Error()
		else
			iSub_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CiSub",TempData,Source,Operand}) -- A << VA - 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CiSub",TempData,Source,Operand}) -- A << VA - Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CiSub",TempData,Source,Operand}) -- A << VA - VA
		elseif Operand[4] == "A" then
			iSub_InputData_Error()
		else
			iSub_InputData_Error()
		end
	else
		iSub_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Neg(Source)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Neg_InputData_Error()
	elseif Source == "Cp" then
		Neg_InputData_Error()
	elseif Source[4] == "V" then
		table.insert(STPushTrigArr,{"CNeg",TempData,Source}) -- A << -X 
	elseif Source[4] == "VA" then
		table.insert(STPushTrigArr,{"CNeg",TempData,Source}) -- A << -VA 
	elseif Source[4] == "A" then
		Neg_InputData_Error()
	else
		Neg_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Mul(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Mul_InputData_Error()
	elseif Source == "Cp" then
		Mul_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CMul",TempData,Source,Operand}) -- A << X * 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_Mul",TempData,Source,Operand}) -- A << X * Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_Mul",TempData,Source,Operand}) -- A << X * VA
		elseif Operand[4] == "A" then
			Mul_InputData_Error()
		else
			Mul_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CMul",TempData,Source,Operand}) -- A << VA * 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_Mul",TempData,Source,Operand}) -- A << VA * Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_Mul",TempData,Source,Operand}) -- A << VA * VA
		elseif Operand[4] == "A" then
			Mul_InputData_Error()
		else
			Mul_InputData_Error()
		end
	else
		Mul_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _MulX(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		MulX_InputData_Error()
	elseif Source == "Cp" then
		MulX_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_Mul",TempData,Source,Operand}) -- A << X * 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CMul",TempData,Source,Operand}) -- A << X * Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CMul",TempData,Source,Operand}) -- A << X * VA
		elseif Operand[4] == "A" then
			MulX_InputData_Error()
		else
			MulX_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_Mul",TempData,Source,Operand}) -- A << VA * 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CMul",TempData,Source,Operand}) -- A << VA * Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CMul",TempData,Source,Operand}) -- A << VA * VA
		elseif Operand[4] == "A" then
			MulX_InputData_Error()
		else
			MulX_InputData_Error()
		end
	else
		MulX_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _iMul(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		iMul_InputData_Error()
	elseif Source == "Cp" then
		iMul_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_iMul",TempData,Source,Operand}) -- A << X * 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_iMul",TempData,Source,Operand}) -- A << X * Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_iMul",TempData,Source,Operand}) -- A << X * VA
		elseif Operand[4] == "A" then
			iMul_InputData_Error()
		else
			iMul_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_iMul",TempData,Source,Operand}) -- A << VA * 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_iMul",TempData,Source,Operand}) -- A << VA * Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_iMul",TempData,Source,Operand}) -- A << VA * VA
		elseif Operand[4] == "A" then
			iMul_InputData_Error()
		else
			iMul_InputData_Error()
		end
	else
		iMul_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Div(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Div_InputData_Error()
	elseif Source == "Cp" then
		Div_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CDiv",TempData,Source,Operand}) -- A << X / 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_Div",TempData,Source,Operand}) -- A << X / Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_Div",TempData,Source,Operand}) -- A << X / VA
		elseif Operand[4] == "A" then
			Div_InputData_Error()
		else
			Div_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CDiv",TempData,Source,Operand}) -- A << VA / 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_Div",TempData,Source,Operand}) -- A << VA / Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_Div",TempData,Source,Operand}) -- A << VA / VA
		elseif Operand[4] == "A" then
			Div_InputData_Error()
		else
			Div_InputData_Error()
		end
	else
		Div_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _iDiv(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		iDiv_InputData_Error()
	elseif Source == "Cp" then
		iDiv_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CiDiv",TempData,Source,Operand}) -- A << X / 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_iDiv",TempData,Source,Operand}) -- A << X / Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_iDiv",TempData,Source,Operand}) -- A << X / VA
		elseif Operand[4] == "A" then
			iDiv_InputData_Error()
		else
			iDiv_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CiDiv",TempData,Source,Operand}) -- A << VA / 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_iDiv",TempData,Source,Operand}) -- A << VA / Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_iDiv",TempData,Source,Operand}) -- A << VA / VA
		elseif Operand[4] == "A" then
			iDiv_InputData_Error()
		else
			iDiv_InputData_Error()
		end
	else
		iDiv_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Mod(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Mod_InputData_Error()
	elseif Source == "Cp" then
		Mod_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CMod",TempData,Source,Operand}) -- A << X % 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_Mod",TempData,Source,Operand}) -- A << X % Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_Mod",TempData,Source,Operand}) -- A << X % VA
		elseif Operand[4] == "A" then
			Mod_InputData_Error()
		else
			Mod_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CMod",TempData,Source,Operand}) -- A << VA % 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_Mod",TempData,Source,Operand}) -- A << VA % Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_Mod",TempData,Source,Operand}) -- A << VA % VA
		elseif Operand[4] == "A" then
			Mod_InputData_Error()
		else
			Mod_InputData_Error()
		end
	else
		Mod_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _iMod(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		iMod_InputData_Error()
	elseif Source == "Cp" then
		iMod_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CiMod",TempData,Source,Operand}) -- A << X % 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_iMod",TempData,Source,Operand}) -- A << X % Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_iMod",TempData,Source,Operand}) -- A << X % VA
		elseif Operand[4] == "A" then
			iMod_InputData_Error()
		else
			iMod_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CiMod",TempData,Source,Operand}) -- A << VA % 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"f_iMod",TempData,Source,Operand}) -- A << VA % Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"f_iMod",TempData,Source,Operand}) -- A << VA % VA
		elseif Operand[4] == "A" then
			iMod_InputData_Error()
		else
			iMod_InputData_Error()
		end
	else
		iMod_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _DivX(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		DivX_InputData_Error()
	elseif Source == "Cp" then
		DivX_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_Div",TempData,Source,Operand}) -- A << X / 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CDiv",TempData,Source,Operand}) -- A << X / Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CDiv",TempData,Source,Operand}) -- A << X / VA
		elseif Operand[4] == "A" then
			DivX_InputData_Error()
		else
			DivX_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_Div",TempData,Source,Operand}) -- A << VA / 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CDiv",TempData,Source,Operand}) -- A << VA / Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CDiv",TempData,Source,Operand}) -- A << VA / VA
		elseif Operand[4] == "A" then
			DivX_InputData_Error()
		else
			DivX_InputData_Error()
		end
	else
		DivX_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _iDivX(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		iDivX_InputData_Error()
	elseif Source == "Cp" then
		iDivX_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_iDiv",TempData,Source,Operand}) -- A << X / 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CiDiv",TempData,Source,Operand}) -- A << X / Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CiDiv",TempData,Source,Operand}) -- A << X / VA
		elseif Operand[4] == "A" then
			iDivX_InputData_Error()
		else
			iDivX_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_iDiv",TempData,Source,Operand}) -- A << VA / 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CiDiv",TempData,Source,Operand}) -- A << VA / Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CiDiv",TempData,Source,Operand}) -- A << VA / VA
		elseif Operand[4] == "A" then
			iDivX_InputData_Error()
		else
			iDivX_InputData_Error()
		end
	else
		iDivX_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _ModX(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		ModX_InputData_Error()
	elseif Source == "Cp" then
		ModX_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_Mod",TempData,Source,Operand}) -- A << X % 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CMod",TempData,Source,Operand}) -- A << X % Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CMod",TempData,Source,Operand}) -- A << X % VA
		elseif Operand[4] == "A" then
			ModX_InputData_Error()
		else
			ModX_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_Mod",TempData,Source,Operand}) -- A << VA % 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CMod",TempData,Source,Operand}) -- A << VA % Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CMod",TempData,Source,Operand}) -- A << VA % VA
		elseif Operand[4] == "A" then
			ModX_InputData_Error()
		else
			ModX_InputData_Error()
		end
	else
		ModX_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _iModX(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		iModX_InputData_Error()
	elseif Source == "Cp" then
		iModX_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_iMod",TempData,Source,Operand}) -- A << X % 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CiMod",TempData,Source,Operand}) -- A << X % Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CiMod",TempData,Source,Operand}) -- A << X % VA
		elseif Operand[4] == "A" then
			iModX_InputData_Error()
		else
			iModX_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"f_iMod",TempData,Source,Operand}) -- A << VA % 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CiMod",TempData,Source,Operand}) -- A << VA % Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CiMod",TempData,Source,Operand}) -- A << VA % VA
		elseif Operand[4] == "A" then
			iModX_InputData_Error()
		else
			iModX_InputData_Error()
		end
	else
		iModX_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Not(Source)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Not_InputData_Error()
	elseif Source == "Cp" then
		Not_InputData_Error()
	elseif Source[4] == "V" then
		table.insert(STPushTrigArr,{"CNot",TempData,Source}) -- A << ~X 
	elseif Source[4] == "VA" then
		table.insert(STPushTrigArr,{"CNot",TempData,Source}) -- A << ~VA
	elseif Source[4] == "A" then
		Not_InputData_Error()
	else
		Not_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Or(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Or_InputData_Error()
	elseif Source == "Cp" then
		Or_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"COr",TempData,Source,Operand}) -- A << X | 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"COr",TempData,Source,Operand}) -- A << X | Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"COr",TempData,Source,Operand}) -- A << X | VA
		elseif Operand[4] == "A" then
			Or_InputData_Error()
		else
			Or_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"COr",TempData,Source,Operand}) -- A << VA | 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"COr",TempData,Source,Operand}) -- A << VA | Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"COr",TempData,Source,Operand}) -- A << VA | VA
		elseif Operand[4] == "A" then
			Or_InputData_Error()
		else
			Or_InputData_Error()
		end
	else
		Or_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _lShift(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		lShift_InputData_Error()
	elseif Source == "Cp" then
		lShift_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"ClShift",TempData,Source,Operand}) -- A << X & 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"ClShift",TempData,Source,Operand}) -- A << X & Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"ClShift",TempData,Source,Operand}) -- A << X & VA
		elseif Operand[4] == "A" then
			lShift_InputData_Error()
		else
			lShift_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"ClShift",TempData,Source,Operand}) -- A << VA & 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"ClShift",TempData,Source,Operand}) -- A << VA & Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"ClShift",TempData,Source,Operand}) -- A << VA & VA
		elseif Operand[4] == "A" then
			lShift_InputData_Error()
		else
			lShift_InputData_Error()
		end
	else
		lShift_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _And(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		And_InputData_Error()
	elseif Source == "Cp" then
		And_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CAnd",TempData,Source,Operand}) -- A << X & 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CAnd",TempData,Source,Operand}) -- A << X & Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CAnd",TempData,Source,Operand}) -- A << X & VA
		elseif Operand[4] == "A" then
			And_InputData_Error()
		else
			And_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CAnd",TempData,Source,Operand}) -- A << VA & 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CAnd",TempData,Source,Operand}) -- A << VA & Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CAnd",TempData,Source,Operand}) -- A << VA & VA
		elseif Operand[4] == "A" then
			And_InputData_Error()
		else
			And_InputData_Error()
		end
	else
		And_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Xor(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Xor_InputData_Error()
	elseif Source == "Cp" then
		Xor_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CXor",TempData,Source,Operand}) -- A << X ^ 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CXor",TempData,Source,Operand}) -- A << X ^ Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CXor",TempData,Source,Operand}) -- A << X ^ VA
		elseif Operand[4] == "A" then
			Xor_InputData_Error()
		else
			Xor_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CXor",TempData,Source,Operand}) -- A << VA ^ 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CXor",TempData,Source,Operand}) -- A << VA ^ Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CXor",TempData,Source,Operand}) -- A << VA ^ VA
		elseif Operand[4] == "A" then
			Xor_InputData_Error()
		else
			Xor_InputData_Error()
		end
	else
		Xor_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Abs(Source)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Abs_InputData_Error()
	elseif Source == "Cp" then
		Abs_InputData_Error()
	elseif Source[4] == "V" then
		table.insert(STPushTrigArr,{"f_Abs",TempData,Source}) -- A << |X|
	elseif Source[4] == "VA" then
		table.insert(STPushTrigArr,{"f_Abs",TempData,Source}) -- A << |VA|
	elseif Source[4] == "A" then
		Abs_InputData_Error()
	else
		Abs_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Sqrt(Source)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Sqrt_InputData_Error()
	elseif Source == "Cp" then
		Sqrt_InputData_Error()
	elseif Source[4] == "V" then
		table.insert(STPushTrigArr,{"f_Sqrt",TempData,Source}) -- A << √X
	elseif Source[4] == "VA" then
		table.insert(STPushTrigArr,{"f_Sqrt",TempData,Source}) -- A << √VA
	elseif Source[4] == "A" then
		Sqrt_InputData_Error()
	else
		Sqrt_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Log2(Source)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Log2_InputData_Error()
	elseif Source == "Cp" then
		Log2_InputData_Error()
	elseif Source[4] == "V" then
		table.insert(STPushTrigArr,{"f_Log2",TempData,Source}) -- A << Log2(X)
	elseif Source[4] == "VA" then
		table.insert(STPushTrigArr,{"f_Log2",TempData,Source}) -- A << Log2(VA)
	elseif Source[4] == "A" then
		Log2_InputData_Error()
	else
		Log2_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Atan2(DeltaY,DeltaX)
	if DeltaY == nil then
		DeltaY = "X"
	end
	if DeltaX == nil then
		DeltaX = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if DeltaY[4] == "V" and DeltaX[4] == "V" then
		table.insert(STPushTrigArr,{"f_Atan2",DeltaY,DeltaX,TempData})
	elseif DeltaY[4] == "VA" and DeltaX[4] == "V" then
		table.insert(STPushTrigArr,{"f_Atan2",DeltaY,DeltaX,TempData})
	elseif DeltaY[4] == "V" and DeltaX[4] == "VA" then
		table.insert(STPushTrigArr,{"f_Atan2",DeltaY,DeltaX,TempData})
	elseif DeltaY[4] == "VA" and DeltaX[4] == "VA" then
		table.insert(STPushTrigArr,{"f_Atan2",DeltaY,DeltaX,TempData})
	else
		Atan2_InputData_Error()
	end

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Lengthdir(Radius,Angle)
	if Radius == nil then
		Radius = "X"
	end
	if Angle == nil then
		Angle = "X"
	end
	local Temp = WarXAlloc
	local TempData = {"X",Temp,0,"W"}
	local CosTemp = {"X",Temp,0x15C,0}
	local SinTemp = {"X",Temp,0x19C,0}

	if Radius[4] == "V" and Angle[4] == "V" then
		table.insert(STPushTrigArr,{"f_Lengthdir",Radius,Angle,CosTemp,SinTemp})
	elseif Radius[4] == "VA" and Angle[4] == "V" then
		table.insert(STPushTrigArr,{"f_Lengthdir",Radius,Angle,CosTemp,SinTemp})
	elseif Radius[4] == "V" and Angle[4] == "VA" then
		table.insert(STPushTrigArr,{"f_Lengthdir",Radius,Angle,CosTemp,SinTemp})
	elseif Radius[4] == "VA" and Angle[4] == "VA" then
		table.insert(STPushTrigArr,{"f_Lengthdir",Radius,Angle,CosTemp,SinTemp})
	else
		Lengthdir_InputData_Error()
	end

	WarXAlloc = WarXAlloc + 1
	if WarXAlloc > MAXWAlloc then
		MAXWAlloc = WarXAlloc
	end
	return TempData
end

function _Rand()
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	table.insert(STPushTrigArr,{"f_Rand",TempData}) 

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

-- Misc 기타 함수들 ---------------------------------------------------------------------------------------------

function DisplayTextX(Text,AlwaysDisplay) -- Action(0,ParseString(Text),0,0,0,0,0,0x9,0,AlwaysDisplay)
	if AlwaysDisplay == nil then
		AlwaysDisplay = 4
	end
	return {"DisplayText",Text,AlwaysDisplay}
end
function PlayWAVX(WAVName) 
	return {"PlayWAV",WAVName}
end
function SetMissionObjectivesX(Text) 
	return {"SetMissionObjectives",Text}
end
function TransmissionX(Unit,Where,WAVName,TimeModifier,Time,Text,AlwaysDisplay)
	if AlwaysDisplay == nil then
		AlwaysDisplay = 4
	end
	return {"Transmission",Unit,Where,WAVName,TimeModifier,Time,Text,AlwaysDisplay}
end
function LeaderBoardKillsX(Unit,Label)
	return {"LeaderBoardKills",Unit,Label}
end
function LeaderBoardScoreX(ScoreType,Label)
	return {"LeaderBoardScore",ScoreType,Label}
end
function LeaderBoardResourcesX(ResourceType,Label)
	return {"LeaderBoardResources",ResourceType,Label}
end
function LeaderBoardControlX(Unit,Label)
	return {"LeaderBoardControl",Unit,Label}
end
function LeaderBoardControlAtX(Unit,Location,Label)
	return {"LeaderBoardControlAt",Unit,Location,Label}
end
function LeaderBoardGoalScoreX(Goal,ScoreType,Label)
	return {"LeaderBoardGoalScore",Goal,ScoreType,Label}
end
function LeaderBoardGoalKillsX(Goal,Unit,Label)
	return {"LeaderBoardGoalKills",Goal,Unit,Label}
end
function LeaderBoardGoalResourcesX(Goal,ReesourceType,Label)
	return {"LeaderBoardGoalResources",Goal,ReesourceType,Label}
end
function LeaderBoardGoalControlX(Goal,Unit,Label)
	return {"LeaderBoardGoalControl",Goal,Unit,Label}
end
function LeaderBoardGoalControlAtX(Goal,Unit,Location,Label)
	return {"LeaderBoardGoalControlAt",Goal,Unit,Location,Label}
end

function CopyCpAction(CpActions,Player,CurrentCp)
	local Data = {}
	Player = PlayerConvertX(Player)
	for i = 1, #Player do
		table.insert(Data,SetMemory(0x6509B0, SetTo, Player[i]))
		for k, v in pairs(CpActions) do	
			if type(v[1]) == "string" then
				local l = {}
				for j = 2, #v do
					if type(v[j]) == "table" and #v[j] > 0 then
						table.insert(l,v[j][i])	-- Player마다 다른 인자를 사용
					else
						table.insert(l,v[j])	
					end
				end
				local ret = _G[v[1]](table.unpack(l))
				table.insert(Data,ret)
			elseif v[8] == 4 or (v[8]>=7 and v[8]<=9) or (v[8]>=17 and v[8]<=21) or (v[8]>=33 and v[8]<=37) then
				CopyCpAction_InputError()
			else
				table.insert(Data,v)
			end
		end 
	end

	if CurrentCp ~= nil and CurrentCp ~= "X" then
		table.insert(Data,SetMemory(0x6509B0, SetTo, CurrentCp))
	end

	return Data
end

function CopyCpActionX(CpActions,Player,CurrentCp)
	local Data = {}
	Player = PlayerConvertX(Player)

	for i = 1, #Player do
		table.insert(Data,SetMemory(0x6509B0, SetTo, Player[i]))
		for k, v in pairs(CpActions) do
			if type(v[1]) == "string" then
				local l = {}
				for j = 2, #v do
					if type(v[j]) == "table" and #v[j] > 0 then
						if Player[i] <= 7 then
							table.insert(l,v[j][Player[i]+1])	
						else
							table.insert(l,v[j][Player[i]-119])	
						end
					else
						table.insert(l,v[j])	
					end
				end
				local ret = _G[v[1]](table.unpack(l))
				table.insert(Data,ret)
			elseif v[8] == 4 or (v[8]>=7 and v[8]<=9) or (v[8]>=17 and v[8]<=21) or (v[8]>=33 and v[8]<=37) then
				CopyCpAction_InputError()
			else
				table.insert(Data,v)
			end
		end 
	end

	if CurrentCp ~= nil and CurrentCp ~= "X" then
		table.insert(Data,SetMemory(0x6509B0, SetTo, CurrentCp))
	end

	return Data
end
function EUDTurbo(PlayerID)
	DoActions(PlayerID,SetMemory(0x6509A0,SetTo,0))
end

function _Void(Number)
	return VoidAreaOffset+Number*4
end
function Void(Number,Type,Value)
	return FMemory(VoidAreaOffset+Number*4,Type,Value)
end
function SetVoid(Number,Type,Value)
	return FSetMemory(VoidAreaOffset+Number*4,Type,Value)
end
function VoidX(Number,Type,Value,Mask)
	return FMemoryX(VoidAreaOffset+Number*4,Type,Value,Mask)
end
function SetVoidX(Number,Type,Value,Mask)
	return FSetMemoryX(VoidAreaOffset+Number*4,Type,Value,Mask)
end
function SetCp(Number)
	return SetMemory(0x6509B0,SetTo,Number)
end

function Loc(LocationId,Direction,Type,Value)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return FMemory(0x58DC60+LocationId*0x14+Direction,Type,Value)
end

function LocX(LocationId,Direction,Type,Value,Mask)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return FMemoryX(0x58DC60+LocationId*0x14+Direction,Type,Value,Mask)
end

function SetLoc(LocationId,Direction,Type,Value)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	elseif Direction == nil then
		return KillUnitAt(1,185,LocationId,P12)
	elseif type(Direction) == "table" then
		local A, B
		if Direction[1] == nil then
			A = 185
		else
			A = Direction[1]
		end
		if Direction[2] == nil then
			B = P12
		else
			B = Direction[2]
		end
		return KillUnitAt(1,A,LocationId,B)
	end
	return FSetMemory(0x58DC60+LocationId*0x14+Direction,Type,Value)
end

function SetLocX(LocationId,Direction,Type,Value,Mask)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	elseif Direction == nil then
		return KillUnitAt(1,185,LocationId,P12)
	elseif type(Direction) == "table" then
		local A, B
		if Direction[1] == nil then
			A = 185
		else
			A = Direction[1]
		end
		if Direction[2] == nil then
			B = P12
		else
			B = Direction[2]
		end
		return KillUnitAt(1,A,LocationId,B)
	end
	return FSetMemoryX(0x58DC60+LocationId*0x14+Direction,Type,Value,Mask)
end

function _TTLoc(LocationId,Direction,Type,Value)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return _TTMemory(0x58DC60+LocationId*0x14+Direction,Type,Value)
end

function _TTLocX(LocationId,Direction,Type,Value,Mask)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return _TTMemoryX(0x58DC60+LocationId*0x14+Direction,Type,Value,Mask)
end

function _TLoc(LocationId,Direction,Type,Value)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return _TMemory(0x58DC60+LocationId*0x14+Direction,Type,Value)
end

function _TLocX(LocationId,Direction,Type,Value,Mask)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return _TMemoryX(0x58DC60+LocationId*0x14+Direction,Type,Value,Mask)
end


function TTLoc(LocationId,Direction,Type,Value)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return TTMemory(0x58DC60+LocationId*0x14+Direction,Type,Value)
end

function TTLocX(LocationId,Direction,Type,Value,Mask)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return TTMemoryX(0x58DC60+LocationId*0x14+Direction,Type,Value,Mask)
end

function TLoc(LocationId,Direction,Type,Value)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return TMemory(0x58DC60+LocationId*0x14+Direction,Type,Value)
end

function TLocX(LocationId,Direction,Type,Value,Mask)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return TMemoryX(0x58DC60+LocationId*0x14+Direction,Type,Value,Mask)
end

function TSetLoc(LocationId,Direction,Type,Value)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return TSetMemory(0x58DC60+LocationId*0x14+Direction,Type,Value)
end

function TSetLocX(LocationId,Direction,Type,Value,Mask)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return TSetMemoryX(0x58DC60+LocationId*0x14+Direction,Type,Value,Mask)
end

function PlayerColor(Player,Type,Value)
	if Player >= 0 and Player <= 11 then
		return MemoryB(0x581D76+8*Player,Type,Value)
	else
		PlayerColor_InputData_Error()
	end
end

function SetPlayerColor(Player,Type,Value)
	if Player >= 0 and Player <= 11 then
		return SetMemoryB(0x581D76+8*Player,Type,Value)
	else
		SetPlayerColor_InputData_Error()
	end
end

function MinimapColor(Player,Type,Value)
	if Player >= 0 and Player <= 11 then
		return MemoryB(0x581DD6+Player,Type,Value)
	else
		MinimapColor_InputData_Error()
	end
end

function SetMinimapColor(Player,Type,Value)
	if Player >= 0 and Player <= 11 then
		return SetMemoryB(0x581DD6+Player,Type,Value)
	else
		SetMinimapColor_InputData_Error()
	end
end

function Speed(Type,Value)
	if Value == "#X0" then
		Value = 42
	elseif Value == "#X1" then
		Value = 36
	elseif Value == "#X2" then
		Value = 29
	elseif Value == "#X3" then
		Value = 21
	elseif Value == "#X4" then
		Value = 12
	elseif Value == "#X5" then
		Value = 1
	end
	return Memory(0x5124F0,Type,Value)
end

function SetSpeed(Type,Value)
	if Value == "#X0" then
		Value = 42
	elseif Value == "#X1" then
		Value = 36
	elseif Value == "#X2" then
		Value = 29
	elseif Value == "#X3" then
		Value = 21
	elseif Value == "#X4" then
		Value = 12
	elseif Value == "#X5" then
		Value = 1
	end
	return SetMemory(0x5124F0,Type,Value)
end

function LocalPlayerID(Player,Type)
	if Type == nil then
		Type = Exactly
	end
	if Player == "Ob1" then
		Player = 128
	elseif Player == "Ob2" then
		Player = 129
	elseif Player == "Ob3" then
		Player = 130
	elseif Player == "Ob4" then
		Player = 131
	end
	return Memory(0x512684,Type,Player)
end

function UnixTime(Type,Date) -- {year = , month = , day = , hour = , min = , sec = }
	return Memory(0x6D0F38,Type,os.time(Date))
end

function SetKills(Player, Modifier, Number, Unit)
	Unit = ParseUnit(Unit)
	if Unit <= 228 then
		return FSetMemory(0x5878A4+Unit*48+Player*4,Modifier,Number)
	elseif Unit == 229 then-- "Any unit"
		return FSetMemory(0x581EA4+Player*4,Modifier,Number)
	elseif Unit == 230 then-- "Men"
		SetKills_InputData_Error()
	elseif Unit == 231 then-- "Buildings"
		return FSetMemory(0x581FF4+Player*4,Modifier,Number)
	elseif Unit == 232 then-- "Factories"
		return FSetMemory(0x582114+Player*4,Modifier,Number)
	end
end

function TSetKills(Player, Modifier, Number, Unit)
	if type(Unit) == "number" then
		Unit = ParseUnit(Unit)
		if Unit <= 228 then
			if type(Player) == "number" then
				return TSetMemory(0x5878A4+Unit*48+Player*4,Modifier,Number)
			else
				return TSetDeaths(Vi(Player[2],EPD(0x5878A4),Player[1],Player[3]),Modifier,Number,Unit)
			end
		elseif Unit == 229 then-- "Any unit"
			if type(Player) == "number" then
				return TSetMemory(0x581EA4+Unit*48+Player*4,Modifier,Number)
			else
				return TSetMemory(Vi(Player[2],EPD(0x581EA4),Player[1],Player[3]),Modifier,Number)
			end
		elseif Unit == 230 then-- "Men"
			TSetKills_InputData_Error()
		elseif Unit == 231 then-- "Buildings"
			if type(Player) == "number" then
				return TSetMemory(0x581FF4+Unit*48+Player*4,Modifier,Number)
			else
				return TSetMemory(Vi(Player[2],EPD(0x581FF4),Player[1],Player[3]),Modifier,Number)
			end
		elseif Unit == 232 then-- "Factories"
			if type(Player) == "number" then
				return TSetMemory(0x582114+Unit*48+Player*4,Modifier,Number)
			else
				return TSetMemory(Vi(Player[2],EPD(0x582114),Player[1],Player[3]),Modifier,Number)
			end
		end
	else
		if type(Player) == "number" then
			return TSetDeaths(0x5878A4+Player*4,Modifier,Number,Unit)
		else
			return TSetDeaths(Vi(Player[2],EPD(0x5878A4),Player[1],Player[3]),Modifier,Number,Unit)
		end
	end
end

function KtoA(Player,UnitId) -- Convert(Kills -> OffSet)
	local KtoA
	UnitId = ParseUnit(UnitId)
	if UnitId <= 228 then
 		KtoA = 0x5878A4 + 0x30 * UnitId + 0x4 * Player
 	elseif UnitId == 229 then-- "Any unit"
		KtoA = 0x581EA4 + 0x4 * Player
	elseif UnitId == 230 then-- "Men"
		KtoA_InputData_Error()
	elseif UnitId == 231 then-- "Buildings"
		KtoA = 0x581FF4 + 0x4 * Player
	elseif UnitId == 232 then-- "Factories"
		KtoA = 0x582114 + 0x4 * Player
	end
 	return KtoA
end 

function MemoryW(Offset,Type,Value)
	local ret = bit32.band(Offset, 0xFFFFFFFF)%4
	if ret == 0 then
		Mask = 0xFFFF
	elseif ret == 2 then
		Mask = 0xFFFF0000
		Value = Value * 0x10000
	else
		MemoryW_InputData_Error()
	end
	return FMemoryX(Offset-ret,Type,Value,Mask)
end

function SetMemoryW(Offset,Type,Value)
	local ret = bit32.band(Offset, 0xFFFFFFFF)%4
	if ret == 0 then
		Mask = 0xFFFF
	elseif ret == 2 then
		Mask = 0xFFFF0000
		Value = Value * 0x10000
	else
		SetMemoryW_InputData_Error()
	end
	return FSetMemoryX(Offset-ret,Type,Value,Mask)
end

function MemoryB(Offset,Type,Value)
	local ret = bit32.band(Offset, 0xFFFFFFFF)%4
	if ret == 0 then
		Mask = 0xFF
	elseif ret == 1 then
		Mask = 0xFF00
		Value = Value * 0x100
	elseif ret == 2 then
		Mask = 0xFF0000
		Value = Value * 0x10000
	elseif ret == 3 then
		Mask = 0xFF000000
		Value = Value * 0x1000000
	end
	return FMemoryX(Offset-ret,Type,Value,Mask)
end

function SetMemoryB(Offset,Type,Value)
	local ret = bit32.band(Offset, 0xFFFFFFFF)%4
	if ret == 0 then
		Mask = 0xFF
	elseif ret == 1 then
		Mask = 0xFF00
		Value = Value * 0x100
	elseif ret == 2 then
		Mask = 0xFF0000
		Value = Value * 0x10000
	elseif ret == 3 then
		Mask = 0xFF000000
		Value = Value * 0x1000000
	end
	return FSetMemoryX(Offset-ret,Type,Value,Mask)
end

function _ConvertBwriteZ(PlayerID,Offset,Value,ValueOutput)
	FBWZCheck = 1
	-- Input Data CRet[1] << EPD 
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
				SetCtrig1X("X",CRet[3],0x15C,0,SetTo,Offset);
				SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X",CRet[1],0x15C,1,0);
				SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Value[1],Value[2],Value[3]);
			},
			flag = {Preserved}
		}

	-- Call f_BwriteZ
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FBWZCall1,0x0,0,0);
					SetCtrigX("X",FBWZCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FBWZCall1 == 0 then
		Need_Include_DataTransfer()
	end
	
	-- Output Data CRet[2] = Output
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",CRet[2],0x158,0,SetTo,ValueOutput[1],ValueOutput[2],0x15C,1,ValueOutput[3]);
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}
end

function _ConvertBwriteX(PlayerID,Offset,Value,EPDOutput,ValueOutput,MaskOutput)
	FBWXCheck = 1
	-- Input Data CRet[1] << EPD 
	if type(Value) == "number" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Value);
					SetCtrig1X("X",CRet[3],0x15C,0,SetTo,-1452249);
					SetCtrig1X("X",CRet[4],0x15C,0,SetTo,0);
					SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Offset[1],Offset[2],Offset[3]);
				},
				flag = {Preserved}
			}
	elseif Value[4] == "V" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[3],0x15C,0,SetTo,-1452249);
					SetCtrig1X("X",CRet[4],0x15C,0,SetTo,0);
					SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X",CRet[2],0x15C,1,0);
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways2(Offset[1],Offset[2],Offset[3],Value[1],Value[2],Value[3]);
				},
				flag = {Preserved}
			}
	end

	-- Call f_BwriteX
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FBWXCall1,0x0,0,0);
					SetCtrigX("X",FBWXCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FBWXCall1 == 0 then
		Need_Include_DataTransfer()
	end
	
	-- Output Data CRet[2] = Output
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",CRet[3],0x158,0,SetTo,EPDOutput[1],EPDOutput[2],0x15C,1,EPDOutput[3]);
				SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX("X",CRet[4],0x158,0,SetTo,ValueOutput[1],ValueOutput[2],0x15C,1,ValueOutput[3]);
				SetCtrig1X("X",CRet[4],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX("X",CRet[5],0x158,0,SetTo,MaskOutput[1],MaskOutput[2],0x15C,1,MaskOutput[3]);
				SetCtrig1X("X",CRet[5],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways3("X",CRet[3],0,"X",CRet[4],0,"X",CRet[5],0);
			},
			flag = {Preserved}
		}
end

function _ConvertBwrite(PlayerID,Base,Index,Value,EPDOutput,ValueOutput,MaskOutput)
	FBWXCheck = 1
	-- Input Data CRet[1] << EPD 
	if type(Value) == "number" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Value);
					SetCtrig1X("X",CRet[3],0x15C,0,SetTo,-1452249);
					SetCtrig1X("X",CRet[4],0x15C,0,SetTo,0);
					SetCtrigX(Index[1],Index[2],0x158,Index[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Index[1],Index[2],0x148,Index[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Index[1],Index[2],0x160,Index[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Index[1],Index[2],Index[3]);
				},
				flag = {Preserved}
			}
	elseif Value[4] == "V" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[3],0x15C,0,SetTo,-1452249);
					SetCtrig1X("X",CRet[4],0x15C,0,SetTo,0);
					SetCtrigX(Index[1],Index[2],0x158,Index[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Index[1],Index[2],0x148,Index[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Index[1],Index[2],0x160,Index[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X",CRet[2],0x15C,1,0);
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways2(Index[1],Index[2],Index[3],Value[1],Value[2],Value[3]);
				},
				flag = {Preserved}
			}
	end

	-- Call f_BwriteX
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FBWXCall1,0x0,0,23);
					SetCtrigX("X",FBWXCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FBWXCall1 == 0 then
		Need_Include_DataTransfer()
	end
	
	-- Output Data CRet[2] = Output
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCVar("X",CRet[3],Add,math.floor(Base/4));
				SetCtrigX("X",CRet[3],0x158,0,SetTo,EPDOutput[1],EPDOutput[2],0x15C,1,EPDOutput[3]);
				SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX("X",CRet[4],0x158,0,SetTo,ValueOutput[1],ValueOutput[2],0x15C,1,ValueOutput[3]);
				SetCtrig1X("X",CRet[4],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX("X",CRet[5],0x158,0,SetTo,MaskOutput[1],MaskOutput[2],0x15C,1,MaskOutput[3]);
				SetCtrig1X("X",CRet[5],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways3("X",CRet[3],0,"X",CRet[4],0,"X",CRet[5],0);
			},
			flag = {Preserved}
		}
end

function _ConvertWwriteZ(PlayerID,Offset,Value,ValueOutput)
	FWWZCheck = 1
	-- Input Data CRet[1] << EPD 
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
				SetCtrig1X("X",CRet[3],0x15C,0,SetTo,Offset);
				SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X",CRet[1],0x15C,1,0);
				SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Value[1],Value[2],Value[3]);
			},
			flag = {Preserved}
		}

	-- Call f_BwriteZ
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FWWZCall1,0x0,0,0);
					SetCtrigX("X",FWWZCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FWWZCall1 == 0 then
		Need_Include_DataTransfer()
	end
	
	-- Output Data CRet[2] = Output
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",CRet[2],0x158,0,SetTo,ValueOutput[1],ValueOutput[2],0x15C,1,ValueOutput[3]);
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}
end

function _ConvertWwriteX(PlayerID,Offset,Value,EPDOutput,ValueOutput,MaskOutput)
	FWWXCheck = 1
	-- Input Data CRet[1] << EPD 
	if type(Value) == "number" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Value);
					SetCtrig1X("X",CRet[3],0x15C,0,SetTo,-1452249);
					SetCtrig1X("X",CRet[4],0x15C,0,SetTo,0);
					SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Offset[1],Offset[2],Offset[3]);
				},
				flag = {Preserved}
			}
	elseif Value[4] == "V" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[3],0x15C,0,SetTo,-1452249);
					SetCtrig1X("X",CRet[4],0x15C,0,SetTo,0);
					SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X",CRet[2],0x15C,1,0);
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways2(Offset[1],Offset[2],Offset[3],Value[1],Value[2],Value[3]);
				},
				flag = {Preserved}
			}
	end

	-- Call f_BwriteX
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FWWXCall1,0x0,0,0);
					SetCtrigX("X",FWWXCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FWWXCall1 == 0 then
		Need_Include_DataTransfer()
	end
	
	-- Output Data CRet[2] = Output
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",CRet[3],0x158,0,SetTo,EPDOutput[1],EPDOutput[2],0x15C,1,EPDOutput[3]);
				SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX("X",CRet[4],0x158,0,SetTo,ValueOutput[1],ValueOutput[2],0x15C,1,ValueOutput[3]);
				SetCtrig1X("X",CRet[4],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX("X",CRet[5],0x158,0,SetTo,MaskOutput[1],MaskOutput[2],0x15C,1,MaskOutput[3]);
				SetCtrig1X("X",CRet[5],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways3("X",CRet[3],0,"X",CRet[4],0,"X",CRet[5],0);
			},
			flag = {Preserved}
		}
end

function _ConvertWwrite(PlayerID,Base,Index,Value,EPDOutput,ValueOutput,MaskOutput)
	FWWXCheck = 1
	-- Input Data CRet[1] << EPD 
	if type(Value) == "number" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Value);
					SetCtrig1X("X",CRet[3],0x15C,0,SetTo,-1452249);
					SetCtrig1X("X",CRet[4],0x15C,0,SetTo,0);
					SetCtrigX(Index[1],Index[2],0x158,Index[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Index[1],Index[2],0x148,Index[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Index[1],Index[2],0x160,Index[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Index[1],Index[2],Index[3]);
				},
				flag = {Preserved}
			}
	elseif Value[4] == "V" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[3],0x15C,0,SetTo,-1452249);
					SetCtrig1X("X",CRet[4],0x15C,0,SetTo,0);
					SetCtrigX(Index[1],Index[2],0x158,Index[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Index[1],Index[2],0x148,Index[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Index[1],Index[2],0x160,Index[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X",CRet[2],0x15C,1,0);
					SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways2(Index[1],Index[2],Index[3],Value[1],Value[2],Value[3]);
				},
				flag = {Preserved}
			}
	end

	-- Call f_BwriteX
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FWWXCall0,0x0,0,0);
					SetCtrigX("X",FWWXCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FWWXCall1 == 0 then
		Need_Include_DataTransfer()
	end
	
	-- Output Data CRet[2] = Output
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCVar("X",CRet[3],Add,math.floor(Base/4));
				SetCtrigX("X",CRet[3],0x158,0,SetTo,EPDOutput[1],EPDOutput[2],0x15C,1,EPDOutput[3]);
				SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX("X",CRet[4],0x158,0,SetTo,ValueOutput[1],ValueOutput[2],0x15C,1,ValueOutput[3]);
				SetCtrig1X("X",CRet[4],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX("X",CRet[5],0x158,0,SetTo,MaskOutput[1],MaskOutput[2],0x15C,1,MaskOutput[3]);
				SetCtrig1X("X",CRet[5],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways3("X",CRet[3],0,"X",CRet[4],0,"X",CRet[5],0);
			},
			flag = {Preserved}
		}
end

function _TMemoryB(Base,Index,Type,Value)
	return {"T","TMemoryB",Base,Index,Type,Value}
end

function _TTMemoryBX(Base,Index,Type,Value)
	return {"TT","TTMemoryBX",Base,Index,Type,Value}
end

function _TMemoryW(Base,Index,Type,Value)
	return {"T","TMemoryW",Base,Index,Type,Value}
end

function _TTMemoryWX(Base,Index,Type,Value)
	return {"TT","TTMemoryWX",Base,Index,Type,Value}
end

function _TMemoryDw(Base,Index,Type,Value)
	return {"T","TMemoryDw",Base,Index,Type,Value}
end

function _TTMemoryDw(Base,Index,Type,Value)
	return {"TT","TTMemoryDw",Base,Index,Type,Value}
end

function _TBread(Offset,Type,Value)
	return {"T","TBread",Offset,Type,Value}
end

function _TTBread(Offset,Type,Value)
	return {"TT","TTBread",Offset,Type,Value}
end

function _TWread(Offset,Type,Value)
	return {"T","TWread",Offset,Type,Value}
end

function _TTWread(Offset,Type,Value)
	return {"TT","TTWread",Offset,Type,Value}
end

function TMemoryB(Base,Index,Type,Value)
	if type(Index) == "number" then
		if type(Value) == "number" then
			TMemoryB_InputData_Error()
		end
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertBwriteZ",Index,Value,TempData})

		local Mask
		local ret = bit32.band(Index, 0xFFFFFFFF)%4
		if ret == 0 then
			Mask = 0xFF
		elseif ret == 1 then
			Mask = 0xFF00
		elseif ret == 2 then
			Mask = 0xFF0000
		elseif ret == 3 then
			Mask = 0xFF000000
		end

		VarXAlloc = VarXAlloc + 1
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TMemoryX(Base-ret+Index,Type,TempData,Mask)
	elseif Index[4] == "V" then
		local TempData1 = {"X",VarXAlloc,0,"V"}
		local TempData2 = {"X",VarXAlloc+1,0,"V"}
		local TempData3 = {"X",VarXAlloc+2,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertBwrite",Base,Index,Value,TempData1,TempData2,TempData3})

		VarXAlloc = VarXAlloc + 3
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TMemoryX(TempData1,Type,TempData2,TempData3)
	end	
end

function TSetMemoryB(Base,Index,Type,Value)
	if type(Index) == "number" then
		if type(Value) == "number" then
			TTSetMemoryB_InputData_Error()
		end
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertBwriteZ",Index,Value,TempData})

		local Mask
		local ret = bit32.band(Index, 0xFFFFFFFF)%4
		if ret == 0 then
			Mask = 0xFF
		elseif ret == 1 then
			Mask = 0xFF00
		elseif ret == 2 then
			Mask = 0xFF0000
		elseif ret == 3 then
			Mask = 0xFF000000
		end

		VarXAlloc = VarXAlloc + 1
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TSetMemoryX(Base-ret+Index,Type,TempData,Mask)
	elseif Index[4] == "V" then
		local TempData1 = {"X",VarXAlloc,0,"V"}
		local TempData2 = {"X",VarXAlloc+1,0,"V"}
		local TempData3 = {"X",VarXAlloc+2,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertBwrite",Base,Index,Value,TempData1,TempData2,TempData3})

		VarXAlloc = VarXAlloc + 3
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TSetMemoryX(TempData1,Type,TempData2,TempData3)
	end	
end

function TMemoryDw(Base,Index,Type,Value,Mask)
	if Mask == nil then Mask = 0xFFFFFFFF end
	if type(Index) == "number" then
		return TMemoryX(Base+Index*4,Type,Value,Mask)
	elseif Index[4] == "V" then
		if Index[5] == nil then
			Index[5] = 0
		end
		return TMemoryX(Vi(Index[2],EPD(Base)+Index[5],Index[1],Index[3]),Type,Value,Mask)
	end
end

function TSetMemoryDw(Base,Index,Type,Value,Mask)
	if Mask == nil then Mask = 0xFFFFFFFF end
	if type(Index) == "number" then
		return TSetMemoryX(Base+Index*4,Type,Value,Mask)
	elseif Index[4] == "V" then
		if Index[5] == nil then
			Index[5] = 0
		end
		return TSetMemoryX(Vi(Index[2],EPD(Base)+Index[5],Index[1],Index[3]),Type,Value,Mask)
	end
end

function TTMemoryDw(Base,Index,Type,Value,Mask)
	if Mask == nil then Mask = 0xFFFFFFFF end
	if type(Index) == "number" then
		return TTMemoryX(Base+Index*4,Type,Value,Mask)
	elseif Index[4] == "V" then
		if Index[5] == nil then
			Index[5] = 0
		end
		return TTMemoryX(Vi(Index[2],EPD(Base)+Index[5],Index[1],Index[3]),Type,Value,Mask)
	end
end

function TTMemoryBX(Base,Index,Type,Value)
	if type(Index) == "number" then
		if type(Value) == "number" then
			TTMemoryBX_InputData_Error()
		end
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertBwriteZ",Index,Value,TempData})

		local Mask
		local ret = bit32.band(Index, 0xFFFFFFFF)%4
		if ret == 0 then
			Mask = 0xFF
		elseif ret == 1 then
			Mask = 0xFF00
		elseif ret == 2 then
			Mask = 0xFF0000
		elseif ret == 3 then
			Mask = 0xFF000000
		end

		VarXAlloc = VarXAlloc + 1
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TTMemoryX(Base-ret+Index,Type,TempData,Mask)
	elseif Index[4] == "V" then
		local TempData1 = {"X",VarXAlloc,0,"V"}
		local TempData2 = {"X",VarXAlloc+1,0,"V"}
		local TempData3 = {"X",VarXAlloc+2,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertBwrite",Base,Index,Value,TempData1,TempData2,TempData3})

		VarXAlloc = VarXAlloc + 3
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TTMemoryX(TempData1,Type,TempData2,TempData3)
	end	
end

function TBread(Offset,Type,Value)
	if type(Offset) == "number" then
		if type(Value) == "number" then
			TBread_InputData_Error()
		end
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertBwriteZ",Offset,Value,TempData})

		local Mask
		local ret = bit32.band(Offset, 0xFFFFFFFF)%4
		if ret == 0 then
			Mask = 0xFF
		elseif ret == 1 then
			Mask = 0xFF00
		elseif ret == 2 then
			Mask = 0xFF0000
		elseif ret == 3 then
			Mask = 0xFF000000
		end

		VarXAlloc = VarXAlloc + 1
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TMemoryX(Offset-ret,Type,TempData,Mask)
	elseif Offset[4] == "V" then
		local TempData1 = {"X",VarXAlloc,0,"V"}
		local TempData2 = {"X",VarXAlloc+1,0,"V"}
		local TempData3 = {"X",VarXAlloc+2,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertBwriteX",Offset,Value,TempData1,TempData2,TempData3})

		VarXAlloc = VarXAlloc + 3
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TMemoryX(TempData1,Type,TempData2,TempData3)
	end	
end

function TBwrite(Offset,Type,Value)
	if type(Offset) == "number" then
		if type(Value) == "number" then
			TBwrite_InputData_Error()
		end
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertBwriteZ",Offset,Value,TempData})

		local Mask
		local ret = bit32.band(Offset, 0xFFFFFFFF)%4
		if ret == 0 then
			Mask = 0xFF
		elseif ret == 1 then
			Mask = 0xFF00
		elseif ret == 2 then
			Mask = 0xFF0000
		elseif ret == 3 then
			Mask = 0xFF000000
		end

		VarXAlloc = VarXAlloc + 1
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TSetMemoryX(Offset-ret,Type,TempData,Mask)
	elseif Offset[4] == "V" then
		local TempData1 = {"X",VarXAlloc,0,"V"}
		local TempData2 = {"X",VarXAlloc+1,0,"V"}
		local TempData3 = {"X",VarXAlloc+2,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertBwriteX",Offset,Value,TempData1,TempData2,TempData3})

		VarXAlloc = VarXAlloc + 3
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TSetMemoryX(TempData1,Type,TempData2,TempData3)
	end	
end

function TTBread(Offset,Type,Value)
	if type(Offset) == "number" then
		if type(Value) == "number" then
			TTBread_InputData_Error()
		end
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertBwriteZ",Offset,Value,TempData})

		local Mask
		local ret = bit32.band(Offset, 0xFFFFFFFF)%4
		if ret == 0 then
			Mask = 0xFF
		elseif ret == 1 then
			Mask = 0xFF00
		elseif ret == 2 then
			Mask = 0xFF0000
		elseif ret == 3 then
			Mask = 0xFF000000
		end

		VarXAlloc = VarXAlloc + 1
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TTMemoryX(Offset-ret,Type,TempData,Mask)
	elseif Offset[4] == "V" then
		local TempData1 = {"X",VarXAlloc,0,"V"}
		local TempData2 = {"X",VarXAlloc+1,0,"V"}
		local TempData3 = {"X",VarXAlloc+2,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertBwriteX",Offset,Value,TempData1,TempData2,TempData3})

		VarXAlloc = VarXAlloc + 3
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TTMemoryX(TempData1,Type,TempData2,TempData3)
	end	
end


function TMemoryW(Base,Index,Type,Value)
	if type(Index) == "number" then
		Index = Index+Index
		if type(Value) == "number" then
			TMemoryW_InputData_Error()
		end
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertWwriteZ",Index,Value,TempData})

		local Mask
		local ret = bit32.band(Index, 0xFFFFFFFF)%4
		if ret == 0 then
			Mask = 0xFFFF
		elseif ret == 2 then
			Mask = 0xFFFF0000
		end

		VarXAlloc = VarXAlloc + 1
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TMemoryX(Base-ret+Index,Type,TempData,Mask)
	elseif Index[4] == "V" then
		local TempData1 = {"X",VarXAlloc,0,"V"}
		local TempData2 = {"X",VarXAlloc+1,0,"V"}
		local TempData3 = {"X",VarXAlloc+2,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertWwrite",Base,Index,Value,TempData1,TempData2,TempData3})

		VarXAlloc = VarXAlloc + 3
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TMemoryX(TempData1,Type,TempData2,TempData3)
	end	
end

function TSetMemoryW(Base,Index,Type,Value)
	if type(Index) == "number" then
		Index = Index+Index
		if type(Value) == "number" then
			TTSetMemoryW_InputData_Error()
		end
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertWwriteZ",Index,Value,TempData})

		local Mask
		local ret = bit32.band(Index, 0xFFFFFFFF)%4
		if ret == 0 then
			Mask = 0xFFFF
		elseif ret == 2 then
			Mask = 0xFFFF0000
		end

		VarXAlloc = VarXAlloc + 1
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TSetMemoryX(Base-ret+Index,Type,TempData,Mask)
	elseif Index[4] == "V" then
		local TempData1 = {"X",VarXAlloc,0,"V"}
		local TempData2 = {"X",VarXAlloc+1,0,"V"}
		local TempData3 = {"X",VarXAlloc+2,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertWwrite",Base,Index,Value,TempData1,TempData2,TempData3})

		VarXAlloc = VarXAlloc + 3
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TSetMemoryX(TempData1,Type,TempData2,TempData3)
	end	
end

function TTMemoryWX(Base,Index,Type,Value)
	if type(Index) == "number" then
		Index = Index+Index
		if type(Value) == "number" then
			TTMemoryWX_InputData_Error()
		end
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertWwriteZ",Index,Value,TempData})

		local Mask
		local ret = bit32.band(Index, 0xFFFFFFFF)%4
		if ret == 0 then
			Mask = 0xFFFF
		elseif ret == 2 then
			Mask = 0xFFFF0000
		end

		VarXAlloc = VarXAlloc + 1
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TTMemoryX(Base-ret+Index,Type,TempData,Mask)
	elseif Index[4] == "V" then
		local TempData1 = {"X",VarXAlloc,0,"V"}
		local TempData2 = {"X",VarXAlloc+1,0,"V"}
		local TempData3 = {"X",VarXAlloc+2,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertWwrite",Base,Index,Value,TempData1,TempData2,TempData3})

		VarXAlloc = VarXAlloc + 3
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TTMemoryX(TempData1,Type,TempData2,TempData3)
	end	
end

function TWread(Offset,Type,Value)
	if type(Offset) == "number" then
		if type(Value) == "number" then
			TWread_InputData_Error()
		end
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertWwriteZ",Offset,Value,TempData})

		local Mask
		local ret = bit32.band(Offset, 0xFFFFFFFF)%4
		if ret == 0 then
			Mask = 0xFFFF
		elseif ret == 2 then
			Mask = 0xFFFF0000
		end

		VarXAlloc = VarXAlloc + 1
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TMemoryX(Offset-ret,Type,TempData,Mask)
	elseif Offset[4] == "V" then
		local TempData1 = {"X",VarXAlloc,0,"V"}
		local TempData2 = {"X",VarXAlloc+1,0,"V"}
		local TempData3 = {"X",VarXAlloc+2,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertWwriteX",Offset,Value,TempData1,TempData2,TempData3})

		VarXAlloc = VarXAlloc + 3
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TMemoryX(TempData1,Type,TempData2,TempData3)
	end	
end

function TWwrite(Offset,Type,Value)
	if type(Offset) == "number" then
		if type(Value) == "number" then
			TWwrite_InputData_Error()
		end
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertWwriteZ",Offset,Value,TempData})

		local Mask
		local ret = bit32.band(Offset, 0xFFFFFFFF)%4
		if ret == 0 then
			Mask = 0xFFFF
		elseif ret == 2 then
			Mask = 0xFFFF0000
		end

		VarXAlloc = VarXAlloc + 1
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TSetMemoryX(Offset-ret,Type,TempData,Mask)
	elseif Offset[4] == "V" then
		local TempData1 = {"X",VarXAlloc,0,"V"}
		local TempData2 = {"X",VarXAlloc+1,0,"V"}
		local TempData3 = {"X",VarXAlloc+2,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertWwriteX",Offset,Value,TempData1,TempData2,TempData3})

		VarXAlloc = VarXAlloc + 3
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TSetMemoryX(TempData1,Type,TempData2,TempData3)
	end	
end

function TTWread(Offset,Type,Value)
	if type(Offset) == "number" then
		if type(Value) == "number" then
			TTWread_InputData_Error()
		end
		local Temp = VarXAlloc
		local TempData = {"X",Temp,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertWwriteZ",Offset,Value,TempData})

		local Mask
		local ret = bit32.band(Offset, 0xFFFFFFFF)%4
		if ret == 0 then
			Mask = 0xFFFF
		elseif ret == 2 then
			Mask = 0xFFFF0000
		end

		VarXAlloc = VarXAlloc + 1
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TTMemoryX(Offset-ret,Type,TempData,Mask)
	elseif Offset[4] == "V" then
		local TempData1 = {"X",VarXAlloc,0,"V"}
		local TempData2 = {"X",VarXAlloc+1,0,"V"}
		local TempData3 = {"X",VarXAlloc+2,0,"V"}

		table.insert(STPushTrigArr,{"_ConvertWwriteX",Offset,Value,TempData1,TempData2,TempData3})

		VarXAlloc = VarXAlloc + 3
		if VarXAlloc > MAXVAlloc then
			MAXVAlloc = VarXAlloc
		end
		return TTMemoryX(TempData1,Type,TempData2,TempData3)
	end	
end

function f_Bread(PlayerID,Offset,Output,Multiplier)
	STPopTrigArr(PlayerID)
	if type(Offset) == "number" then
		if Multiplier == 16777216 or Multiplier == "+3" then
			Multiplier = 3
		elseif Multiplier == 65536 or Multiplier == "+2" then
			Multiplier = 2
		elseif Multiplier == 256 or Multiplier == "+1" then
			Multiplier = 1
		else
			Multiplier = 0
		end
		local Mask
		local ret = bit32.band(Offset, 0xFFFFFFFF)%4
		
		FBRZCheck = 1
		-- Call f_BwriteZ
		Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FBRZCall1,0x0,0,0);
						SetCtrigX("X",FBRZCall2,0x4,0,SetTo,"X","X",0x0,0,1);
						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
						SetCtrig1X("X",CRet[3],0x15C,0,SetTo,Offset);
						SetMemory(0x6509B0,SetTo,EPD(Offset-ret));
						SetCtrig1X("X",CRet[4],0x15C,0,SetTo,Multiplier);
					},
					flag = {Preserved}
				}
		if FBRZCall1 == 0 then
			Need_Include_DataTransfer()
		end
		
		-- Output Data CRet[2] = Output
		if type(Output) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		elseif Output[4] == "V" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		end
	elseif Offset[4] == "V" then
		if Multiplier == 16777216 or Multiplier == "+3" then
			Multiplier = 3
		elseif Multiplier == 65536 or Multiplier == "+2" then
			Multiplier = 2
		elseif Multiplier == 256 or Multiplier == "+1" then
			Multiplier = 1
		else
			Multiplier = 0
		end

		FBRXCheck = 1
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Offset[1],Offset[2],Offset[3]);
				},
				flag = {Preserved}
			}

		-- Call f_BwriteZ
		Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FBRXCall1,0x0,0,0);
						SetCtrigX("X",FBRXCall2,0x4,0,SetTo,"X","X",0x0,0,1);
						SetMemory(0x6509B0,SetTo,-1452249);
						SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0);
						SetCtrig1X("X",CRet[4],0x15C,0,SetTo,Multiplier);
					},
					flag = {Preserved}
				}
		if FBRXCall1 == 0 then
			Need_Include_DataTransfer()
		end
		
		-- Output Data CRet[2] = Output
		if type(Output) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[3],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		elseif Output[4] == "V" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[3],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[3],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		end
	end	

	RecoverCp(PlayerID)
end

function f_BreadX(PlayerID,Base,Index,Output,Multiplier)
	STPopTrigArr(PlayerID)
	if type(Index) == "number" then
		if Multiplier == 16777216 or Multiplier == "+3" then
			Multiplier = 3
		elseif Multiplier == 65536 or Multiplier == "+2" then
			Multiplier = 2
		elseif Multiplier == 256 or Multiplier == "+1" then
			Multiplier = 1
		else
			Multiplier = 0
		end
		local Mask
		local ret = bit32.band(Index, 0xFFFFFFFF)%4
		
		FBRZCheck = 1
		-- Call f_BwriteZ
		Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FBRZCall1,0x0,0,0);
						SetCtrigX("X",FBRZCall2,0x4,0,SetTo,"X","X",0x0,0,1);
						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
						SetCtrig1X("X",CRet[3],0x15C,0,SetTo,Index);
						SetMemory(0x6509B0,SetTo,EPD(Base-ret+Index));
						SetCtrig1X("X",CRet[4],0x15C,0,SetTo,Multiplier);
					},
					flag = {Preserved}
				}
		if FBRZCall1 == 0 then
			Need_Include_DataTransfer()
		end
		
		-- Output Data CRet[2] = Output
		if type(Output) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		elseif Output[4] == "V" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		end
	elseif Index[4] == "V" then
		if Multiplier == 16777216 or Multiplier == "+3" then
			Multiplier = 3
		elseif Multiplier == 65536 or Multiplier == "+2" then
			Multiplier = 2
		elseif Multiplier == 256 or Multiplier == "+1" then
			Multiplier = 1
		else
			Multiplier = 0
		end

		FBRXCheck = 1
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Index[1],Index[2],0x158,Index[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Index[1],Index[2],0x148,Index[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Index[1],Index[2],0x160,Index[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Index[1],Index[2],Index[3]);
				},
				flag = {Preserved}
			}

		-- Call f_BwriteZ
		Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FBRXCall1,0x0,0,23); -- 차이점
						SetCtrigX("X",FBRXCall2,0x4,0,SetTo,"X","X",0x0,0,1);
						SetMemory(0x6509B0,SetTo,EPD(Base));
						SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0);
						SetCtrig1X("X",CRet[4],0x15C,0,SetTo,Multiplier);
					},
					flag = {Preserved}
				}
		if FBRXCall1 == 0 then
			Need_Include_DataTransfer()
		end
		
		-- Output Data CRet[2] = Output
		if type(Output) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[3],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		elseif Output[4] == "V" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[3],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[3],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		end
 	end	

	RecoverCp(PlayerID)
end

function f_Bwrite(PlayerID,Offset,Type,Value)
	CDoActions(PlayerID,{TBwrite(Offset,Type,Value)})
end

function f_BwriteX(PlayerID,Base,Index,Type,Value)
	CDoActions(PlayerID,{TSetMemoryB(Base,Index,Type,Value)})
end

function f_Wread(PlayerID,Offset,Output,Multiplier)
	STPopTrigArr(PlayerID)
	if type(Offset) == "number" then
		if Multiplier == 65536 or Multiplier == "+1" then
			Multiplier = 1
		else
			Multiplier = 0
		end
		local Mask
		local ret = bit32.band(Offset, 0xFFFFFFFF)%4
		
		FWRZCheck = 1
		-- Call f_BwriteZ
		Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FWRZCall1,0x0,0,0);
						SetCtrigX("X",FWRZCall2,0x4,0,SetTo,"X","X",0x0,0,1);
						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
						SetCtrig1X("X",CRet[3],0x15C,0,SetTo,Offset);
						SetMemory(0x6509B0,SetTo,EPD(Offset-ret));
						SetCtrig1X("X",CRet[4],0x15C,0,SetTo,Multiplier);
					},
					flag = {Preserved}
				}
		if FWRZCall1 == 0 then
			Need_Include_DataTransfer()
		end
		
		-- Output Data CRet[2] = Output
		if type(Output) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		elseif Output[4] == "V" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		end
	elseif Offset[4] == "V" then
		if Multiplier == 65536 or Multiplier == "+1" then
			Multiplier = 1
		else
			Multiplier = 0
		end

		FWRXCheck = 1
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Offset[1],Offset[2],Offset[3]);
				},
				flag = {Preserved}
			}

		-- Call f_BwriteZ
		Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FWRXCall1,0x0,0,0);
						SetCtrigX("X",FWRXCall2,0x4,0,SetTo,"X","X",0x0,0,1);
						SetMemory(0x6509B0,SetTo,-1452249);
						SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0);
						SetCtrig1X("X",CRet[4],0x15C,0,SetTo,Multiplier);
					},
					flag = {Preserved}
				}
		if FWRXCall1 == 0 then
			Need_Include_DataTransfer()
		end
		
		-- Output Data CRet[2] = Output
		if type(Output) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[3],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		elseif Output[4] == "V" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[3],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[3],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		end
	end	

	RecoverCp(PlayerID)
end

function f_WreadX(PlayerID,Base,Index,Output,Multiplier)
	STPopTrigArr(PlayerID)
	if type(Index) == "number" then
		Index = Index+Index
		if Multiplier == 65536 or Multiplier == "+1" then
			Multiplier = 1
		else
			Multiplier = 0
		end
		local Mask
		local ret = bit32.band(Index, 0xFFFFFFFF)%4
		
		FWRZCheck = 1
		-- Call f_BwriteZ
		Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FWRZCall1,0x0,0,0);
						SetCtrigX("X",FWRZCall2,0x4,0,SetTo,"X","X",0x0,0,1);
						SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
						SetCtrig1X("X",CRet[3],0x15C,0,SetTo,Index);
						SetMemory(0x6509B0,SetTo,EPD(Base-ret+Index));
						SetCtrig1X("X",CRet[4],0x15C,0,SetTo,Multiplier);
					},
					flag = {Preserved}
				}
		if FWRZCall1 == 0 then
			Need_Include_DataTransfer()
		end
		
		-- Output Data CRet[2] = Output
		if type(Output) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		elseif Output[4] == "V" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
					},
					flag = {Preserved}
				}
		end
	elseif Index[4] == "V" then
		if Multiplier == 65536 or Multiplier == "+1" then
			Multiplier = 1
		else
			Multiplier = 0
		end

		FWRXCheck = 1
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Index[1],Index[2],0x158,Index[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Index[1],Index[2],0x148,Index[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Index[1],Index[2],0x160,Index[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Index[1],Index[2],Index[3]);
				},
				flag = {Preserved}
			}

		-- Call f_BwriteZ
		Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FWRXCall0,0x0,0,0); -- 차이점
						SetCtrigX("X",FWRXCall2,0x4,0,SetTo,"X","X",0x0,0,1);
						SetMemory(0x6509B0,SetTo,EPD(Base));
						SetCtrig1X("X",CRet[3],0x15C,0,SetTo,0);
						SetCtrig1X("X",CRet[4],0x15C,0,SetTo,Multiplier);
					},
					flag = {Preserved}
				}
		if FWRXCall1 == 0 then
			Need_Include_DataTransfer()
		end
		
		-- Output Data CRet[2] = Output
		if type(Output) == "number" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[3],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		elseif Output[4] == "V" then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[3],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[3],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
					},
					flag = {Preserved}
				}
		end
	end	

	RecoverCp(PlayerID)
end

function f_Wwrite(PlayerID,Offset,Type,Value)
	CDoActions(PlayerID,{TWwrite(Offset,Type,Value)})
end

function f_WwriteX(PlayerID,Base,Index,Type,Value)
	CDoActions(PlayerID,{TSetMemoryW(Base,Index,Type,Value)})
end

function f_Dwwrite(PlayerID,Offset,Type,Value,Mask)
	if type(Offset) == "number" then
		CDoActions(PlayerID,{TSetMemoryX(Offset,Type,Value,Mask)})
	else
		CDoActions(PlayerID,{TSetMemoryX(_EPD(Offset),Type,Value,Mask)})
	end
end

function f_DwwriteX(PlayerID,Base,Index,Type,Value,Mask)
	CDoActions(PlayerID,{TSetMemoryDw(Base,Index,Type,Value,Mask)})
end

function _TTMemoryW(Offset,Type,Value)
	local ret = bit32.band(Offset, 0xFFFFFFFF)%4
	if ret == 0 then
		Mask = 0xFFFF
	elseif ret == 2 then
		Mask = 0xFFFF0000
		Value = Value * 0x10000
	else
		_TTMemoryW_InputData_Error()
	end
	return _TTMemoryX(Offset-ret,Type,Value,Mask)
end

function TTMemoryW(Offset,Type,Value)
	local ret = bit32.band(Offset, 0xFFFFFFFF)%4
	if ret == 0 then
		Mask = 0xFFFF
	elseif ret == 2 then
		Mask = 0xFFFF0000
		Value = Value * 0x10000
	else
		TTMemoryW_InputData_Error()
	end
	return TTMemoryX(Offset-ret,Type,Value,Mask)
end

function _TTMemoryB(Offset,Type,Value)
	local ret = bit32.band(Offset, 0xFFFFFFFF)%4
	if ret == 0 then
		Mask = 0xFF
	elseif ret == 1 then
		Mask = 0xFF00
		Value = Value * 0x100
	elseif ret == 2 then
		Mask = 0xFF0000
		Value = Value * 0x10000
	elseif ret == 3 then
		Mask = 0xFF000000
		Value = Value * 0x1000000
	end
	return _TTMemoryX(Offset-ret,Type,Value,Mask)
end

function TTMemoryB(Offset,Type,Value)
	local ret = bit32.band(Offset, 0xFFFFFFFF)%4
	if ret == 0 then
		Mask = 0xFF
	elseif ret == 1 then
		Mask = 0xFF00
		Value = Value * 0x100
	elseif ret == 2 then
		Mask = 0xFF0000
		Value = Value * 0x10000
	elseif ret == 3 then
		Mask = 0xFF000000
		Value = Value * 0x1000000
	end
	return TTMemoryX(Offset-ret,Type,Value,Mask)
end

--PlayerCheckOffset = 0
function Enable_PlayerCheck(Offset)
	--[[
	if Offset == nil or Offset == "X" then
		Offset = 0x58F44C
	end
	PlayerCheckOffset = Offset
	DoActions(AllPlayers,{FSetMemory(Offset,SetTo,0)})

	for i = 0, 7 do
		Trigger {
			players = {AllPlayers},
			conditions = {
				FMemoryX(0x57EEE8 + 36*i,AtLeast,0x1,0xFF);
				FMemoryX(0x57EEE8 + 36*i,AtMost,0x7,0xFF);
			},
			actions = {
				FSetMemoryX(Offset,SetTo,2^i,2^i);
			},
			flag = {Preserved}
		}
	end
	]]--
end

function PlayerCheck(Player,Status)
	if Player >= 8  or Player < 0 then
		PlayerCheck_InputData_Error()
	end
	if Status == "X" or Status == 0 then
		return FMemory(0x51A284 + 12*Player,Exactly,0x51A284 + 12*Player)
	else
		return FMemory(0x51A284 + 12*Player,AtLeast,0x51A2E4)
	end
	
end

function NoAirCollisionX(PlayerID)

	f_Read(PlayerID,0x6D5CD8,"X",V(FuncAlloc))

	CVariable2(PlayerID,FuncAlloc,0x6509B0,SetTo,0)

	FuncAlloc = FuncAlloc + 1
	local RephArr = {}
	for i = 0, 609 do
		table.insert(RephArr,SetDeaths(CurrentPlayer,SetTo,0,i))
	end
	for j = 0, 1 do
		table.insert(RephArr,SetMemory(0x6509B0,Add,1))
		for i = 0, 609 do
			table.insert(RephArr,SetDeaths(CurrentPlayer,SetTo,0,i))
		end
	end
	for j = 0, 8 do
		table.insert(RephArr,SetMemory(0x6509B0,Add,1))
		for i = 0, 608 do
			table.insert(RephArr,SetDeaths(CurrentPlayer,SetTo,0,i))
		end
	end
	table.insert(RephArr,SetMemory(0x6509B0,SetTo,PlayerID))

	DoActions2(PlayerID,RephArr)

end

function utf8_from(t)
  local bytearr = {}
  for _, v in ipairs(t) do
    local utf8byte = v < 0 and (0xff + v + 1) or v
    table.insert(bytearr, string.char(utf8byte))
  end
  return table.concat(bytearr)
end

function ParseHotkey(String) -- N : NumberPad / C : Ctrl & A : Alt / S : Shift
	local HotkeyCodeDict = {
	    ['CA']= 1,['CB']= 2,['CSC']= 3,['CD']= 4,['CE']= 5,['CF']= 6,['CG']= 7,['CI']= 9,['Tab']= 9,
	    ['CEnter']= 10,['CJ']= 10,['CK']= 11,['CL']= 12,['Enter']= 13,['CSM']= 13,['CN']= 14,['CO']= 15,
	    ['CP']= 16,['CSQ']= 17,['CSR']= 18,['CSS']= 19,['CT']= 20,['CU']= 21,['CV']= 22,['CW']= 23,
	    ['CSX']= 24,['CY']= 25,['CZ']= 26,['ESC']= 27,['C[']= 27,['C\\']= 28,['C]']= 29,['C^']= 30,
	    ['C_']= 31,[' ']= 32,['Space']= 32,['\"']= 34,['\'']= 39,['N*']= 42,['+']= 43,['NS+']= 43,['NA+']= 43,
	    [',']= 44,['NS-']= 45,['NA-']= 45,['.']= 46,['/']= 47,['N0']= 48,['N1']= 49,['N2']= 50,['N3']= 51,
	    ['N4']= 52,['N5']= 53,['N6']= 54,['N7']= 55,['N8']= 56,['N9']= 57,[':']= 58,[';']= 59,['<']= 60,
	    ['>']= 62,['?']= 63,['[']= 91,['\\']= 92,[']']= 93,['_']= 95,["`"]= 96,['{']= 123,['|']= 124,['}']= 125,
		['~']= 126,['CBS']= 127,['None']= 8,['A']= 97,['a']= 97,['B']= 98,['b']= 98,['C']= 99,['c']= 99,
		['D']= 100,['d']= 100,['E']= 101,['e']= 101,['F']= 102,['f']= 102,['G']= 103,['g']= 103,['H']= 104,['h']= 104,
		['I']= 105,['i']= 105,['J']= 106,['j']= 106,['K']= 107,['k']= 107,['L']= 108,['l']= 108,['M']= 109,['m']= 109,
		['N']= 110,['n']= 110,['O']= 111,['o']= 111,['P']= 112,['p']= 112,['Q']= 113,['q']= 113,['R']= 114,['r']= 114,
		['S']= 115,['s']= 115,['T']= 116,['t']= 116,['U']= 117,['u']= 117,['V']= 118,['v']= 118,['W']= 119,['w']= 119,
		['X']= 120,['x']= 120,['Y']= 121,['y']= 121,['Z']= 122,['z']= 122,
	}
	local ret = HotkeyCodeDict[String]

	if ret == nil then
		if String == "CC" then
			PushErrorMsg("Ctrl+C Doesn't Exist. Try CSC")
		elseif String == "CH" then
			PushErrorMsg("Ctrl+H Doesn't Exist.")
		elseif String == "CM" then
			PushErrorMsg("Ctrl+M Doesn't Exist. Try CSM")
		elseif String == "CQ" then
			PushErrorMsg("Ctrl+Q Doesn't Exist. Try CSQ")
		elseif String == "CR" then
			PushErrorMsg("Ctrl+R Doesn't Exist. Try CSR")
		elseif String == "CS" then
			PushErrorMsg("Ctrl+S Doesn't Exist. Try CSS")
		elseif String == "CX" then
			PushErrorMsg("Ctrl+X Doesn't Exist. Try CSX")
		elseif String == "*" then
			PushErrorMsg("* Doesn't Exist. Try N*")
		elseif String == "N+" then
			PushErrorMsg("N+ Doesn't Exist. Try NS+ or NA+")
		elseif String == "N-" or String == "-" then
			PushErrorMsg(String.." Doesn't Exist. Try NS- or NA-")
		elseif  String == "0" or String == "1" or String == "2" or String == "3" or String == "4" or String == "5" or String == "6" or String == "7" or String == "8" or String == "9" then
			PushErrorMsg(String.." Doesn't Exist. Try N"..String)
		elseif String == "BS" then
			PushErrorMsg("BackSpace Doesn't Exist. Try CBS")
		else
			PushErrorMsg(String.." Doesn't Exist.")
		end
	end
	return ret
end

function ParseButtonType(String)
	local ButtonTypeCodeDict = {
		['\xC0\xCF\xB9\xDD\xB8\xED\xB7\xC9']= 0,['\xC0\xAF\xB4\xD6\xBB\xFD\xBB\xEA']= 1,['N\xBE\xF7\xB1\xD7\xB7\xB9\xC0\xCC\xB5\xE5']= 2,['\xBD\xBA\xC5\xB3\xBB\xE7\xBF\xEB']= 3,['\xC5\xD7\xC5\xA9\xBE\xF7\xB1\xD7\xB7\xB9\xC0\xCC\xB5\xE5']= 4,['\xC0\xAF\xB4\xD6\xBA\xAF\xC5\xC2']= 5,['None']= 8,
		-- ['일반명령']= 0,['유닛생산']= 1,['N업그레이드']= 2,['스킬사용']= 3,['테크업그레이드']= 4,['유닛변태']= 5,['None']= 8,
	}
	local Type = ButtonTypeCodeDict[String]
		if Type == nil then
		PushErrorMsg(String.." Doesn't Exist.")
	end
	return Type
end

function tbl_to_itbl(String,Type,Hotkey,Hexflag)
	local ret = {}
	for i = 1, #String do
		table.insert(ret,string.byte(String,i))
	end
	local itbl = ""

	-- \x01 02 03 04 05 06 07 08 0E 0F 10 11 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F = ColorCode (<0x20, 09,0A,0B,0C,0D,12,13)
	-- else (1byte) : C _ _ X / -- else (2byte) : C _ X X

	if type(Type) == "string" then
		Type = ParseButtonType(Type)
	end
	if Type < 0 or Type > 5 and Type ~= 8 then
		tbl_to_itbl_Type_Error()
	end

	if type(Hotkey) == "string" then
		Hotkey = ParseHotkey(Hotkey)
	end
	if Hotkey < 0 or Hotkey > 255 then
		tbl_to_itbl_Hotkey_Error()
	end

	if Hexflag == 1 then
		itbl = itbl.."<"..string.format("%X",Hotkey)..">"
		itbl = itbl.."<"..string.format("%X",Type)..">"
		local iret = {Hotkey,Type}
		itbl = itbl.."<D>"
		itbl = itbl.."<D>"
		itbl = itbl.."<D>"
		table.insert(iret,0xD)
		table.insert(iret,0xD)
		table.insert(iret,0xD)

		local prt = 0
		local i = 1
		local Null = 0
		while true do
			local v = ret[i]
			if v == 0x0 then
				if #iret%4 == 0 then
					itbl = itbl.."<0><0><0><0>"
					table.insert(iret,0x0)
					table.insert(iret,0x0)
					table.insert(iret,0x0)
					table.insert(iret,0x0)
				else
					itbl = itbl.."<0><0><0>"
					table.insert(iret,0x0)
					table.insert(iret,0x0)
					table.insert(iret,0x0)
				end
				Null = 1
				break
			elseif (v>=0x20 and v<=0x7F) or (v>=0x9 and v<=0xD) or (v>=0x12 and v<=0x13) then -- 1byte
				if prt == 0 then
					itbl = itbl.."<D>"
					table.insert(iret,0xD)
				end
				itbl = itbl.."<D>"
				itbl = itbl.."<D>"
				itbl = itbl.."<"..string.format("%X",v)..">"
				table.insert(iret,0xD)
				table.insert(iret,0xD)
				table.insert(iret,v)
				prt = 0
				i = i+1
			elseif v >= 0x80 then -- 2byte
				if prt == 0 then
					itbl = itbl.."<D>"
					table.insert(iret,0xD)
				end
				local w = ret[i+1]
				itbl = itbl.."<D>"
				itbl = itbl..string.char(v)
				itbl = itbl..string.char(w)
				table.insert(iret,0xD)
				table.insert(iret,v)
				table.insert(iret,w)
				prt = 0
				i = i+2
			else -- Colorcode
				local w = ret[i+1]
				if (w >= 0x1 and w <= 0x8) or (w >= 0xE and w <= 0x11) or (w >= 0x14 and w <= 0x1F) then -- ColorCode
					i = i+1 -- continue
				else
					itbl = itbl.."<"..string.format("%X",v)..">"
					table.insert(iret,v)
					prt = 1
					i = i+1
				end
			end
			if i > #ret then break end
		end
		local Size
		if Null == 0 then
			Size = math.floor((#iret-2)/4)
		else
			Size = math.floor((#iret-3)/4)
		end
		return itbl, Size
	else
		if Hotkey < 0x20 then
			itbl = itbl.."<"..Hotkey..">"
		else
			itbl = itbl..string.char(Hotkey)
		end
		itbl = itbl.."<"..Type..">"
		local iret = {Hotkey,Type}
		itbl = itbl.."<13>"
		itbl = itbl.."<13>"
		itbl = itbl.."<13>"
		table.insert(iret,0xD)
		table.insert(iret,0xD)
		table.insert(iret,0xD)

		local prt = 0
		local i = 1
		local Null = 0
		while true do
			local v = ret[i]
			if v == 0x0 then
				if #iret%4 == 0 then
					itbl = itbl.."<0><0><0><0>"
					table.insert(iret,0x0)
					table.insert(iret,0x0)
					table.insert(iret,0x0)
					table.insert(iret,0x0)
				else
					itbl = itbl.."<0><0><0>"
					table.insert(iret,0x0)
					table.insert(iret,0x0)
					table.insert(iret,0x0)
				end
				Null = 1
				break
			elseif (v>=0x20 and v<=0x7F) or (v>=0x9 and v<=0xD) or (v>=0x12 and v<=0x13) then -- 1byte
				if prt == 0 then
					itbl = itbl.."<13>"
					table.insert(iret,0xD)
				end
				itbl = itbl.."<13>"
				itbl = itbl.."<13>"
				if v < 0x20 then
					itbl = itbl.."<"..v..">"
				else
					itbl = itbl..string.char(v)
				end
				table.insert(iret,0xD)
				table.insert(iret,0xD)
				table.insert(iret,v)
				prt = 0
				i = i+1
			elseif v >= 0x80 then -- 2byte
				if prt == 0 then
					itbl = itbl.."<13>"
					table.insert(iret,0xD)
				end
				local w = ret[i+1]
				itbl = itbl.."<13>"
				itbl = itbl..string.char(v)
				itbl = itbl..string.char(w)
				table.insert(iret,0xD)
				table.insert(iret,v)
				table.insert(iret,w)
				prt = 0
				i = i+2
			else -- Colorcode
				local w = ret[i+1]
				if (w >= 0x1 and w <= 0x8) or (w >= 0xE and w <= 0x11) or (w >= 0x14 and w <= 0x1F) then -- ColorCode
					i = i+1 -- continue
				else
					itbl = itbl.."<"..v..">"
					table.insert(iret,v)
					prt = 1
					i = i+1
				end
			end
			if i > #ret then break end
		end
		local Size
		if Null == 0 then
			Size = math.floor((#iret-2)/4)
		else
			Size = math.floor((#iret-3)/4)
		end
		return itbl, Size
	end
end

function str_to_istr(String)
	local ret = {}
	for i = 1, #String do
		table.insert(ret,string.byte(String,i))
	end

	-- \x01 02 03 04 05 06 07 08 0E 0F 10 11 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F = ColorCode (<0x20, 09,0A,0B,0C,0D,12,13)
	-- else (1byte) : C _ _ X / -- else (2byte) : C _ X X

	local iret = {}
	if STRXFlag == 0 then
		iret = {0xD,0xD,0xD}
	end

	local prt = 0
	local i = 1
	local Null = 0
	while true do
		local v = ret[i]
		if v == 0x0 then
			if #iret%4 == 0 then
				table.insert(iret,0x0)
			end
			table.insert(iret,0x0)
			table.insert(iret,0x0)
			table.insert(iret,0x0)
			Null = 1
			break
		elseif (v>=0x20 and v<=0x7F) or (v>=0x9 and v<=0xD) or (v>=0x12 and v<=0x13) then -- 1byte
			if prt == 0 then
				table.insert(iret,0xD)
			end
			table.insert(iret,0xD)
			table.insert(iret,0xD)
			table.insert(iret,v)
			prt = 0
			i = i+1
		elseif v >= 0x80 then -- 2byte
			if prt == 0 then
				table.insert(iret,0xD)
			end
			local w = ret[i+1]
			table.insert(iret,0xD)
			table.insert(iret,v)
			table.insert(iret,w)
			prt = 0
			i = i+2
		else -- Colorcode
			local w = ret[i+1]
			if (w >= 0x1 and w <= 0x8) or (w >= 0xE and w <= 0x11) or (w >= 0x14 and w <= 0x1F) then -- ColorCode
				i = i+1 -- continue
			else
				table.insert(iret,v)
				prt = 1
				i = i+1
			end
		end
		if i > #ret then break end
	end
	local Size
	if Null == 0 then
		Size = math.floor(#iret/4)
	else
		Size = math.floor((#iret-1)/4)
	end
	iret = utf8_from(iret)
	return iret, Size
end

function str_to_iutf8(String,flag)
	local ret = cp949_to_utf8(String)
	table.remove(ret,#ret)

	-- \x01 02 03 04 05 06 07 08 0E 0F 10 11 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F = ColorCode (<0x20, 09,0A,0B,0C,0D,12,13)
	-- else (1byte) : C _ _ X / -- else (2byte) : C _ X X
	local iret 
	if flag == 1 then
		iret = {}
	else
		if STRXFlag == 0 then
			iret = {0xD,0xD,0xD}
		else
			iret ={}
		end
	end
	local prt = 0
	local i = 1
	local Null = 0
	while true do
		local v = ret[i]
		if v == 0x0 then
			if #iret%4 == 0 then
				table.insert(iret,0x0)
			end
			table.insert(iret,0x0)
			table.insert(iret,0x0)
			table.insert(iret,0x0)
			Null = 1
			break
		elseif (v>=0x20 and v<=0x7F) or (v>=0x9 and v<=0xD) or (v>=0x12 and v<=0x13) then -- 1byte
			if prt == 0 then
				table.insert(iret,0xD)
			end
			table.insert(iret,0xD)
			table.insert(iret,0xD)
			table.insert(iret,v)
			prt = 0
			i = i+1
		elseif v >= 0x80 then -- 3byte
			if prt == 0 then
				table.insert(iret,0xD)
			end
			local w = ret[i+1]
			local x = ret[i+2]
			table.insert(iret,v)
			table.insert(iret,w)
			table.insert(iret,x)
			prt = 0
			i = i+3
		else -- Colorcode
			local w = ret[i+1]
			if (w >= 0x1 and w <= 0x8) or (w >= 0xE and w <= 0x11) or (w >= 0x14 and w <= 0x1F) then -- ColorCode
				i = i+1 -- continue
			else
				table.insert(iret,v)
				prt = 1
				i = i+1
			end
		end
		if i > #ret then break end
	end
	local Size
	if Null == 0 then
		Size = math.floor(#iret/4)
	else
		Size = math.floor((#iret-1)/4)
	end
	return iret, Size
end

function str_to_icp949(String,flag)
	local ret = {}
	for i = 1, #String do
		table.insert(ret,string.byte(String,i))
	end

	-- \x01 02 03 04 05 06 07 08 0E 0F 10 11 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F = ColorCode (<0x20, 09,0A,0B,0C,0D,12,13)
	-- else (1byte) : C _ _ X / -- else (2byte) : C _ X X
	local iret 
	if flag == 1 then
		iret = {}
	else
		if STRXFlag == 0 then
			iret = {0xD,0xD,0xD}
		else
			iret ={}
		end
	end
	local prt = 0
	local i = 1
	local Null = 0
	while true do
		local v = ret[i]
		if v == 0x0 then
			if #iret%4 == 0 then
				table.insert(iret,0x0)
			end
			table.insert(iret,0x0)
			table.insert(iret,0x0)
			table.insert(iret,0x0)
			Null = 1
			break
		elseif (v>=0x20 and v<=0x7F) or (v>=0x9 and v<=0xD) or (v>=0x12 and v<=0x13) then -- 1byte
			if prt == 0 then
				table.insert(iret,0xD)
			end
			table.insert(iret,0xD)
			table.insert(iret,0xD)
			table.insert(iret,v)
			prt = 0
			i = i+1
		elseif v >= 0x80 then -- 2byte
			if prt == 0 then
				table.insert(iret,0xD)
			end
			local w = ret[i+1]
			table.insert(iret,0xD)
			table.insert(iret,v)
			table.insert(iret,w)
			prt = 0
			i = i+2
		else -- Colorcode
			local w = ret[i+1]
			if (w >= 0x1 and w <= 0x8) or (w >= 0xE and w <= 0x11) or (w >= 0x14 and w <= 0x1F) then -- ColorCode
				i = i+1 -- continue
			else
				table.insert(iret,v)
				prt = 1
				i = i+1
			end
		end
		if i > #ret then break end
	end
	local Size
	if Null == 0 then
		Size = math.floor(#iret/4)
	else
		Size = math.floor((#iret-1)/4)
	end
	return iret, Size
end

function GetiStrId(PlayerId,String)
	local Size
	String, Size = str_to_istr(String)
	StringKey = ParseString(String)
	table.insert(StringKeyArr,StringKey)
	local V = CreateVar(PlayerId)
	table.insert(iStringKeyArr,{StringKey,PlayerId,V,Size})
	return {V,StringKey,Size,String}
end

TBLStringTable = 0
function MakeiTblString(TBLIndex,Type,Hotkey,String,Name,Hexflag)
	if TBLStringTable == 0 then
		local FilePath = FileDirectory.."TBLString.txt"
		TBLStringTable = io.open(FilePath, "wb")
		if TBLStringTable == nil then
			PushErrorMsg(FilePath.."\nDoesn't Exist!")
		end
	end
	local Size
	String, Size = tbl_to_itbl(String,Type,Hotkey,Hexflag)
	local Fileptr = TBLStringTable
	if Hexflag == 1 then
		Fileptr:write("[EUDEditor 3] TBLIndex = "..TBLIndex.."  (".. Name ..") ====================\n")
	else
		Fileptr:write("[EUDEditor 2] TBLIndex = "..TBLIndex.."  (".. Name ..") ====================\n")
	end
	Fileptr:write(String)
	Fileptr:write("\n=====================================================\n")
	return Size
end

function GetiTblId(PlayerId,TBLIndex,Size)
	local V = CreateVar(PlayerId)
	table.insert(iTBLIndexArr,{TBLIndex,PlayerId,V,Size})
	return {V,TBLIndex,Size}
end

function GetiStrArr(cp949flag,String)
	if type(String) == "number" then
		String = DecodeString(String)
	end
	local Size = 0
	local Arr = {}
	if cp949flag == "X" or cp949flag == nil or cp949flag == 0 then -- iutf8 Size
		Arr, Size = str_to_iutf8(String,1)
	else -- icp949 Size
		Arr, Size = str_to_icp949(String,1)
	end
	return Arr, Size
end

function GetiStrSize(cp949flag,String)
	if type(String) == "number" then
		String = DecodeString(String)
	end
	local Size = 0
	local Arr = {}
	if cp949flag == "X" or cp949flag == nil or cp949flag == 0 then -- iutf8 Size
		Arr, Size = str_to_iutf8(String,1)
	else -- icp949 Size
		Arr, Size = str_to_icp949(String,1)
	end
	return Size
end

function CreateSVA32(iStrArr,Size,PlayerID)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	local PSize = Size
	Size = math.ceil(Size/32)
	table.insert(CreateVarPArr,{"SVA32",PlayerID,iStrArr,Size})
	local Ret = {"X",CreateVarXAlloc,0,"SVA32",Size,PSize}
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end

function CreateSVA32X(iStrArr,Size,PlayerID)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	local PSize = Size
	Size = math.ceil(Size/32)
	table.insert(CreateVarPArr,{"SVA32X",PlayerID,iStrArr,Size})
	local Ret = {"X",CreateVarXAlloc,0,"SVA32",Size,PSize}
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end

function CreateSVA1(iStrArr,Size,PlayerID)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"SVA1",PlayerID,iStrArr,Size})
	local Ret = {"X",CreateVarXAlloc,0,"V",0,Size}
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end

function SaveiStrArr(PlayerID,String,SVA32)
	local Arr, Size, ret
	Arr, Size = str_to_icp949(String,1)
	if SVA32 == 1 then
		ret = CreateSVA32(Arr,Size,PlayerID)
	else
		ret = CreateSVA1(Arr,Size,PlayerID)
	end
	return ret, Arr, Size
end

function SaveiStrptr(PlayerID,String,SVA32)
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	local Arr, Size, ret
	Arr, Size = str_to_icp949(String,1)
	if SVA32 == 1 then
		ret = f_GetFileSVArrptrN(PlayerID,Arr,1,32,"SVA32",1)
		return {ret[1],ret[2],ret[3],"SVA32",math.ceil(Size/32),Size}, Arr, Size
	else
		ret = f_GetFileVArrptrN(PlayerID,Arr,1,"SVA1",1)
		return {ret[1],ret[2],ret[3],"V",0,Size}, Arr, Size
	end
end

function SaveiStrFile(PlayerID,String)
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	local Arr, Size, ret
	Arr, Size = str_to_icp949(String,1)

	ret = f_GetFileArrptr(PlayerID,Arr,1,1)
	return ret, Arr, Size
end

function SaveiStrArrX(PlayerID,String,SVA32)
	local Arr, Size, ret
	Arr, Size = str_to_iutf8(String,1)
	if SVA32 == 1 then
		ret = CreateSVA32X(Arr,Size,PlayerID)
	else
		ret = CreateSVA1(Arr,Size,PlayerID)
	end
	return ret, Arr, Size
end

function SaveiStrptrX(PlayerID,String,SVA32)
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	local Arr, Size, ret
	Arr, Size = str_to_iutf8(String,1)
	if SVA32 == 1 then
		ret = f_GetFileSVArrptrN(PlayerID,Arr,1,32,"SVA32X",1)
		return {ret[1],ret[2],ret[3],"SVA32",math.ceil(Size/32),Size}, Arr, Size
	else
		ret = f_GetFileVArrptrN(PlayerID,Arr,1,"SVA1",1)
		return {ret[1],ret[2],ret[3],"V",0,Size}, Arr, Size
	end
end

function SaveiStrFileX(PlayerID,String)
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	local Arr, Size, ret
	Arr, Size = str_to_iutf8(String,1)

	ret = f_GetFileArrptr(PlayerID,Arr,1,1)
	return ret, Arr, Size
end

function DwSaveiStrArr(PlayerID,String,SVA32)
	local Arr, Size, ret
	Arr = {}
	Size = math.ceil(#String/4)
	for i = 1, #String do
		table.insert(Arr,string.byte(String,i))
	end
	if #String%4 == 3 then
		table.insert(Arr,0xD)
	elseif #String%4 == 2 then
		table.insert(Arr,0xD)
		table.insert(Arr,0xD)
	elseif #String%4 == 1 then
		table.insert(Arr,0xD)
		table.insert(Arr,0xD)
		table.insert(Arr,0xD)
	end
	if SVA32 == 1 then
		ret = CreateSVA32(Arr,Size,PlayerID)
	else
		ret = CreateSVA1(Arr,Size,PlayerID)
	end
	return ret, Arr, Size
end

function DwSaveiStrptr(PlayerID,String,SVA32)
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	local Arr, Size, ret
	Arr = {}
	Size = math.ceil(#String/4)
	for i = 1, #String do
		table.insert(Arr,string.byte(String,i))
	end
	if #String%4 == 3 then
		table.insert(Arr,0xD)
	elseif #String%4 == 2 then
		table.insert(Arr,0xD)
		table.insert(Arr,0xD)
	elseif #String%4 == 1 then
		table.insert(Arr,0xD)
		table.insert(Arr,0xD)
		table.insert(Arr,0xD)
	end
	if SVA32 == 1 then
		ret = f_GetFileSVArrptrN(PlayerID,Arr,1,32,"SVA32",1)
		return {ret[1],ret[2],ret[3],"SVA32",math.ceil(Size/32),Size}, Arr, Size
	else
		ret = f_GetFileVArrptrN(PlayerID,Arr,1,"SVA1",1)
		return {ret[1],ret[2],ret[3],"V",0,Size}, Arr, Size
	end
end

function DwSaveiStrFile(PlayerID,String)
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	local Arr, Size, ret
	Arr = {}
	Size = math.ceil(#String/4)
	for i = 1, #String do
		table.insert(Arr,string.byte(String,i))
	end
	if #String%4 == 3 then
		table.insert(Arr,0xD)
	elseif #String%4 == 2 then
		table.insert(Arr,0xD)
		table.insert(Arr,0xD)
	elseif #String%4 == 1 then
		table.insert(Arr,0xD)
		table.insert(Arr,0xD)
		table.insert(Arr,0xD)
	end

	ret = f_GetFileArrptr(PlayerID,Arr,1,1)
	return ret, Arr, Size
end

function DwSaveiStrArrX(PlayerID,String,SVA32)
	local Arr, Size, ret
	Arr = cp949_to_utf8(String)
	table.remove(Arr,#Arr)
	Size = math.ceil(#Arr/4)
	if #Arr%4 == 3 then
		table.insert(Arr,0xD)
	elseif #Arr%4 == 2 then
		table.insert(Arr,0xD)
		table.insert(Arr,0xD)
	elseif #Arr%4 == 1 then
		table.insert(Arr,0xD)
		table.insert(Arr,0xD)
		table.insert(Arr,0xD)
	end
	if SVA32 == 1 then
		ret = CreateSVA32X(Arr,Size,PlayerID)
	else
		ret = CreateSVA1(Arr,Size,PlayerID)
	end
	return ret, Arr, Size
end

function DwSaveiStrptrX(PlayerID,String,SVA32)
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	local Arr, Size, ret
	Arr = cp949_to_utf8(String)
	table.remove(Arr,#Arr)                                                                              
	Size = math.ceil(#Arr/4)
	if #Arr%4 == 3 then
		table.insert(Arr,0xD)
	elseif #Arr%4 == 2 then
		table.insert(Arr,0xD)
		table.insert(Arr,0xD)
	elseif #Arr%4 == 1 then
		table.insert(Arr,0xD)
		table.insert(Arr,0xD)
		table.insert(Arr,0xD)
	end
	if SVA32 == 1 then
		ret = f_GetFileSVArrptrN(PlayerID,Arr,1,32,"SVA32X",1)
		return {ret[1],ret[2],ret[3],"SVA32",math.ceil(Size/32),Size}, Arr, Size
	else
		ret = f_GetFileVArrptrN(PlayerID,Arr,1,"SVA1",1)
		return {ret[1],ret[2],ret[3],"V",0,Size}, Arr, Size
	end
end

function DwSaveiStrFileX(PlayerID,String)
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	local Arr, Size, ret
	Arr = cp949_to_utf8(String)
	table.remove(Arr,#Arr)                                                                              
	Size = math.ceil(#Arr/4)
	if #Arr%4 == 3 then
		table.insert(Arr,0xD)
	elseif #Arr%4 == 2 then
		table.insert(Arr,0xD)
		table.insert(Arr,0xD)
	elseif #Arr%4 == 1 then
		table.insert(Arr,0xD)
		table.insert(Arr,0xD)
		table.insert(Arr,0xD)
	end

	ret = f_GetFileArrptr(PlayerID,Arr,1,1)
	return ret, Arr, Size
end

function MakeiStrVoid(Size,flag)
	local Void = ""
	if flag == 0 or flag == "X" or flag == nil then
		for i = 1, Size do
			Void = Void.."\x0D"
		end
	else
		for i = 1, Size do
			Void = Void.."\x0D\x0D\x0D\x0D"
		end
	end
	return Void
end

function MakeiStrLetter(Letter,Size,flag)
	local Void = ""
	if flag == 0 or flag == "X" or flag == nil then
		for i = 1, Size do
			Void = Void..Letter
		end
	else
		local ret = {}
		for i = 1, #Letter do
			table.insert(ret,string.byte(Letter,i))
		end

		if (ret[1]>=0x20 and ret[1]<=0x7F) or (ret[1]>=0x9 and ret[1]<=0xD) or (ret[1]>=0x12 and ret[1]<=0x13) then -- 1byte
			for i = 1, Size do
				Void = Void..'\x0D'..'\x0D'..'\x0D'..Letter
			end
		elseif v >= 0x80 then -- 2byte
			for i = 1, Size do
				Void = Void..'\x0D'..'\x0D'..Letter
			end
		else -- Colorcode
			local w = ret[2]
			if (w >= 0x1 and w <= 0x8) or (w >= 0xE and w <= 0x11) or (w >= 0x14 and w <= 0x1F) then -- ColorCode
				MakeiStrLetter_InputData_Error()
			elseif (ret[1]>=0x20 and ret[1]<=0x7F) or (ret[1]>=0x9 and ret[1]<=0xD) or (ret[1]>=0x12 and ret[1]<=0x13) then -- 1byte
				for i = 1, Size do
					Void = Void..'\x0D'..'\x0D'..Letter
				end
			elseif v >= 0x80 then -- 2byte
				for i = 1, Size do
					Void = Void..'\x0D'..Letter
				end
			end
		end
	end
	return Void
end

function MakeiStrWord(String,Size)
	local Void = ""
	for i = 1, Size do
		Void = Void..String
	end
	return Void
end

function SVA1(SVA1,Index)
	local ret
	if type(Index) == "number" then
		ret = {SVA1[1],SVA1[2],SVA1[3],"V",Index,SVA1[6]}
	else
		ret = {SVA1[1],SVA1[2],SVA1[3],"VA",Index,SVA1[6]}
	end
	return ret
end

function CA__Input(Input,SVA1,Mask)
	if Mask == nil then
		Mask = 0xFFFF00FF
	end

	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	if SVA1[4] == "V" then
		if type(Input) == "number" then
			DoActionsX(PlayerID,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5],SetTo,Input,Mask))
		elseif Input[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label();
				},
				actions = {
					SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+SVA1[5]);
					SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,Mask);
					SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Input[1],Input[2],Input[3]);
				},
				flag = {Preserved}
			}
		end
	elseif SVA1[4] == "VA" then
		if SVA1[5][5] == nil then
			SVA1[5][5] = 0
		end
		if type(Input) == "number" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label();
				},
				actions = {
					SetCtrigX("X","X",0x158,1,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+SVA1[5][5]);
					SetCtrigX(SVA1[5][1],SVA1[5][2],0x158,SVA1[5][3],SetTo,"X","X",0x158,1,1);
					SetCtrig1X(SVA1[5][1],SVA1[5][2],0x148,SVA1[5][3],SetTo,0xFFFFFFFF);
					SetCtrig1X(SVA1[5][1],SVA1[5][2],0x160,SVA1[5][3],SetTo,Add*16777216,0xFF000000);
					CallLabelAlways(SVA1[5][1],SVA1[5][2],SVA1[5][3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label();
				},
				actions = {
					SetDeathsX(0,SetTo,Input,0,Mask);
				},
				flag = {Preserved}
			}
		elseif Input[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label();
				},
				actions = {
					SetCtrigX("X","X",0x158,1,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+SVA1[5][5]);
					SetCtrigX(SVA1[5][1],SVA1[5][2],0x158,SVA1[5][3],SetTo,"X","X",0x158,1,1);
					SetCtrig1X(SVA1[5][1],SVA1[5][2],0x148,SVA1[5][3],SetTo,0xFFFFFFFF);
					SetCtrig1X(SVA1[5][1],SVA1[5][2],0x160,SVA1[5][3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X","X",0x15C,1,1);
					SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways2(SVA1[5][1],SVA1[5][2],SVA1[5][3],Input[1],Input[2],Input[3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label();
				},
				actions = {
					SetDeathsX(0,SetTo,0,0,Mask);
				},
				flag = {Preserved}
			}
		end
	end
end
 
function CA__InputVA(Index,SVA1,Size,Mask,Start,End,SourceDistance) -- SVA1 -> iStr
	local BoxM = {}
	if Mask ~= nil then
		BoxM = {SetDeaths(0,SetTo,Mask,0)} -- Mask
	end

	if SourceDistance == nil then
		SourceDistance = 1
	end
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)
	local INVA = {CRet[1]} -- Size

	-- Input Var
	if type(Size) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",INVA[1],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "V" then
		if Size[5] == nil then
			Size[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",INVA[1],0x15C,0,SetTo,Size[5]);
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",INVA[1],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	-- Get Start Curindex
	if type(Index) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				FSetMemory(0x6509B0,SetTo,Index);
				SetCtrig1X(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,EPD(0x6509B0));
				SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(CB[1][1],CB[1][2],CB[1][3]);
			},
			flag = {Preserved}
		}
	elseif Index[4] == "V" then
		if Index[5] == nil then
			Index[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				FSetMemory(0x6509B0,SetTo,Index[5]);
				SetCtrig1X(Index[1],Index[2],0x158,Index[3],SetTo,EPD(0x6509B0));
				SetCtrig1X(Index[1],Index[2],0x148,Index[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Index[1],Index[2],0x160,Index[3],SetTo,Add*16777216,0xFF000000);
				SetCtrig1X(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,EPD(0x6509B0));
				SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways2(Index[1],Index[2],Index[3],CB[1][1],CB[1][2],CB[1][3]);
			},
			flag = {Preserved}
		}
	end

	-- Get Start & END
	if type(Start) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FuncAlloc,0x24,0,SetTo,Start);
				SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X",FuncAlloc,0x24,1,0);
				SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(CB[1][1],CB[1][2],CB[1][3]);
			},
			flag = {Preserved}
		}
	elseif Start[4] == "V" then
		if Start[5] == nil then
			Start[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FuncAlloc,0x24,0,SetTo,Start[5]);
				SetCtrigX(Start[1],Start[2],0x158,Start[3],SetTo,"X",FuncAlloc,0x24,1,0);
				SetCtrig1X(Start[1],Start[2],0x148,Start[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Start[1],Start[2],0x160,Start[3],SetTo,Add*16777216,0xFF000000);
				SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X",FuncAlloc,0x24,1,0);
				SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways2(Start[1],Start[2],Start[3],CB[1][1],CB[1][2],CB[1][3]);
			},
			flag = {Preserved}
		}
	end

	if type(End) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FuncAlloc,0x38,0,SetTo,End);
				SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X",FuncAlloc,0x38,1,0);
				SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(CB[1][1],CB[1][2],CB[1][3]);
			},
			flag = {Preserved}
		}
	elseif End[4] == "V" then
		if End[5] == nil then
			End[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FuncAlloc,0x38,0,SetTo,End[5]);
				SetCtrigX(End[1],End[2],0x158,End[3],SetTo,"X",FuncAlloc,0x38,1,0);
				SetCtrig1X(End[1],End[2],0x148,End[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(End[1],End[2],0x160,End[3],SetTo,Add*16777216,0xFF000000);
				SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X",FuncAlloc,0x38,1,0);
				SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways2(End[1],End[2],End[3],CB[1][1],CB[1][2],CB[1][3]);
			},
			flag = {Preserved}
		}
	end

	-- Set Call VA
	if SVA1[4] == "V" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FuncAlloc,0x158,0,SetTo,SVA1[1],SVA1[2],0x164,1,SVA1[3]); 
					SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,SVA1[1],SVA1[2],0,0,SVA1[3]); 
					SetCtrigX("X",FuncAlloc,0x178,1,SetTo,SVA1[1],SVA1[2],0x4,1,SVA1[3]);
					SetCtrigX("X",FuncAlloc,0x178,0,SetTo,SVA1[1],SVA1[2],0x148,1,SVA1[3]);  
					SetCtrig1X("X",FuncAlloc,0x158,0,Add,SVA1[5]*604);
					SetCtrig1X("X",FuncAlloc,0x15C,1,Add,SVA1[5]*0x970);
					SetCtrig1X("X",FuncAlloc,0x178,1,Add,SVA1[5]*604);
					SetCtrig1X("X",FuncAlloc,0x178,0,Add,SVA1[5]*604);
				},
				flag = {Preserved}
			}
	elseif SVA1[4] == "VA" then -- SVA1[5]604
		if SVA1[5][5] == nil then
			SVA1[5][5] = 0
		end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FuncAlloc,0x158,0,SetTo,SVA1[1],SVA1[2],0x164,1,SVA1[3]); 
					SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,SVA1[1],SVA1[2],0,0,SVA1[3]); 
					SetCtrigX("X",FuncAlloc,0x178,1,SetTo,SVA1[1],SVA1[2],0x4,1,SVA1[3]); 
					SetCtrigX("X",FuncAlloc,0x178,0,SetTo,SVA1[1],SVA1[2],0x148,1,SVA1[3]); 
					SetCtrig1X("X",FuncAlloc,0x158,0,Add,SVA1[5][5]*604);
					SetCtrig1X("X",FuncAlloc,0x15C,1,Add,SVA1[5][5]*0x970);
					SetCtrig1X("X",FuncAlloc,0x178,1,Add,SVA1[5][5]*604);
					SetCtrig1X("X",FuncAlloc,0x178,0,Add,SVA1[5][5]*604);
					SetCtrigX(SVA1[5][1],SVA1[5][2],0x158,SVA1[5][3],SetTo,"X","X",0x15C,1,1);
					SetCtrig1X(SVA1[5][1],SVA1[5][2],0x148,SVA1[5][3],SetTo,0xFFFFFFFF);
					SetCtrig1X(SVA1[5][1],SVA1[5][2],0x160,SVA1[5][3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(SVA1[5][1],SVA1[5][2],SVA1[5][3]);
					SetCtrigX("X","X",0x158,1,SetTo,"X","X",0x17C,1,1);
					SetCtrig1X("X","X",0x178,1,SetTo,0);
					SetCtrig1X("X","X",0x17C,1,SetTo,0);
					SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetDeaths(0,Add,0,0);
					SetDeaths(0,Add,0,0);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x158,-1,SetTo,"X",FuncAlloc,0x158,1,0);
					SetCtrigX("X","X",0x178,-1,SetTo,"X","X",0x17C,1,-1);
					SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1);
					SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x158,-2,SetTo,"X",FuncAlloc,0x178,1,1);
					SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-2);
					SetCtrigX("X","X",0x4,-2,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x158,-3,SetTo,"X",FuncAlloc,0x178,1,0);
					SetCtrigX("X","X",0x178,-3,SetTo,"X",FuncAlloc,0x15C,1,1);
					SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-3);
					SetCtrigX("X","X",0x4,-3,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
		--[[
		for i = 0, 11 do
			local CBit = 2^i
			if SVA1[6] >= CBit then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX(SVA1[5][1],SVA1[5][2],0x15C,SVA1[5][3],Exactly,CBit,CBit);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc,0x158,0,Add,CBit*604);
						SetCtrig1X("X",FuncAlloc,0x15C,1,Add,CBit*2416);
						SetCtrig1X("X",FuncAlloc,0x178,1,Add,CBit*604);
						SetCtrig1X("X",FuncAlloc,0x178,0,Add,CBit*604);
					},
					flag = {Preserved}
				}
			end
		end
		]]--
	end

	CWhile(PlayerID,{CVar("X",INVA[1],AtLeast,1)},{SetCVar("X",INVA[1],Subtract,1)})
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(FuncAlloc);
					FMemory(0x6509B0,AtLeast,0); -- Cp >= Start+CB[1]
					FMemory(0x6509B0,AtMost,0); -- Cp <= End+CB[1]
				},
				actions = {
					SetDeathsX(0,SetTo,0,0,0x2); -- Enable
					BoxM,
				},
				flag = {Preserved}
			}

		-- Ctrig->Ctrig->Ctrig Version : Cp사용 X
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- "X"->VA
					SetCtrig2X(0,SetTo,"X","X",0,0,1); -- VA->"X"+1
				},
				flag = {Preserved}
			}
	CWhileEnd({SetCtrig1X("X",FuncAlloc,0x158,0,Add,604*SourceDistance),SetCtrig1X("X",FuncAlloc,0x15C,1,Add,0x970*SourceDistance),SetCtrig1X("X",FuncAlloc,0x178,1,Add,604*SourceDistance),SetCtrig1X("X",FuncAlloc,0x178,0,Add,604*SourceDistance)})
	FuncAlloc = FuncAlloc + 1
	-- RecoverCp
	RecoverCp(PlayerID)
end

function CA__epdcmp(Dest,Source,Size,Mask,CFlag)
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local INVA = {CRet[1]} -- Size

	-- Get Size
	if type(Size) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",INVA[1],0x15C,0,SetTo,Size);
				SetCDeaths("X",SetTo,1,CFlag);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "V" then
		if Size[5] == nil then
			Size[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",INVA[1],0x15C,0,SetTo,Size[5]);
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",INVA[1],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
				SetCDeaths("X",SetTo,1,CFlag);
			},
			flag = {Preserved}
		}
	end

	-- Get Dest Cp
	if Dest[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",CRet[2],0x15C,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrig1X("X",CRet[2],0x15C,0,Add,604*Dest[5]);

				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then -- Dest[5]604
		if Dest[5][5] == nil then
			Dest[5][5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",CRet[2],0x15C,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrig1X("X",CRet[2],0x15C,0,Add,604*Dest[5][5]);
				SetCtrigX(Dest[5][1],Dest[5][2],0x158,Dest[5][3],SetTo,"X",CRet[2],0x15C,1,0);
				SetCtrig1X(Dest[5][1],Dest[5][2],0x148,Dest[5][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[5][1],Dest[5][2],0x160,Dest[5][3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Dest[5][1],Dest[5][2],Dest[5][3]);

				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
			},
			flag = {Preserved}
		}
	end

	-- Set Call VA
	if Source[4] == "V" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FuncAlloc,0x158,0,SetTo,Source[1],Source[2],0x164,1,Source[3]); 
					SetCtrigX("X",FuncAlloc,0x178,0,SetTo,Source[1],Source[2],0x148,1,Source[3]);  
					SetCtrigX("X",FuncAlloc,0x19C,0,SetTo,Source[1],Source[2],0,0,Source[3]); 
					SetCtrigX("X",FuncAlloc,0x1B8,0,SetTo,Source[1],Source[2],0x4,1,Source[3]);
					
					SetCtrig1X("X",FuncAlloc,0x158,0,Add,Source[5]*604);
					SetCtrig1X("X",FuncAlloc,0x178,0,Add,Source[5]*604);
					SetCtrig1X("X",FuncAlloc,0x19C,0,Add,Source[5]*0x970);
					SetCtrig1X("X",FuncAlloc,0x1B8,0,Add,Source[5]*604);
				},
				flag = {Preserved}
			}
	elseif Source[4] == "VA" then -- Source[5]604
		if Source[5][5] == nil then
			Source[5][5] = 0
		end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FuncAlloc,0x158,0,SetTo,Source[1],Source[2],0x164,1,Source[3]); 
					SetCtrigX("X",FuncAlloc,0x178,0,SetTo,Source[1],Source[2],0x148,1,Source[3]); 
					SetCtrigX("X",FuncAlloc,0x19C,0,SetTo,Source[1],Source[2],0,0,Source[3]); 
					SetCtrigX("X",FuncAlloc,0x1B8,0,SetTo,Source[1],Source[2],0x4,1,Source[3]); 
					
					SetCtrig1X("X",FuncAlloc,0x158,0,Add,Source[5][5]*604);
					SetCtrig1X("X",FuncAlloc,0x178,0,Add,Source[5][5]*604);
					SetCtrig1X("X",FuncAlloc,0x19C,0,Add,Source[5][5]*0x970);
					SetCtrig1X("X",FuncAlloc,0x1B8,0,Add,Source[5][5]*604);
					
					SetCtrigX(Source[5][1],Source[5][2],0x158,Source[5][3],SetTo,"X","X",0x15C,1,1);
					SetCtrig1X(Source[5][1],Source[5][2],0x148,Source[5][3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[5][1],Source[5][2],0x160,Source[5][3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Source[5][1],Source[5][2],Source[5][3]);
					SetCtrigX("X","X",0x158,1,SetTo,"X","X",0x17C,1,1);
					SetCtrig1X("X","X",0x178,1,SetTo,0);
					SetCtrig1X("X","X",0x17C,1,SetTo,0);
					SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetDeaths(0,Add,0,0);
					SetDeaths(0,Add,0,0);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x158,-1,SetTo,"X",FuncAlloc,0x158,1,0);
					SetCtrigX("X","X",0x178,-1,SetTo,"X","X",0x17C,1,-1);
					SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1);
					SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x158,-2,SetTo,"X",FuncAlloc,0x178,1,0);
					SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-2);
					SetCtrigX("X","X",0x4,-2,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x158,-3,SetTo,"X",FuncAlloc,0x1B8,1,0);
					SetCtrigX("X","X",0x178,-3,SetTo,"X",FuncAlloc,0x19C,1,0);
					SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-3);
					SetCtrigX("X","X",0x4,-3,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	end
	NWhile(PlayerID,{CVar("X",INVA[1],AtLeast,1)})
		-- Ctrig->Ctrig->Ctrig Version : Cp사용 X
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(FuncAlloc);
				},
				actions = {
					SetDeathsX(0,SetTo,0,0,0x2); -- Enable
					SetDeaths(0,SetTo,Mask,0);
					SetCtrig1X("X","X",0x4,0,SetTo,0);
					SetCtrig2X(0,SetTo,"X",CRet[2],0,0,0); -- VA->"X"+1
					SetCtrigX("X",CRet[2],0x4,0,SetTo,"X","X",0,0,1); -- VA->"X"+1
					SetCtrig2X(0x6509B0,SetTo,"X",FuncAlloc,0x24,1,1);
					SetCtrigX("X","X",0x4,1,SetTo,"X",FuncAlloc+1,0x0,0,0);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label();
					DeathsX(CurrentPlayer,Exactly,0,0,Mask);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}

	NWhileEnd({SetCVar("X",INVA[1],Subtract,1),SetCtrig1X("X",CRet[2],0x15C,0,Add,604),SetCtrig1X("X",FuncAlloc,0x158,0,Add,604),SetCtrig1X("X",FuncAlloc,0x178,0,Add,604),SetCtrig1X("X",FuncAlloc,0x19C,0,Add,0x970),SetCtrig1X("X",FuncAlloc,0x1B8,0,Add,604)})
	FuncAlloc = FuncAlloc + 1

	Trigger {
			players = {PlayerID},
			conditions = {
				Label(FuncAlloc);
				CVar("X",INVA[1],AtLeast,1);
			},
			actions = {
				SetCDeaths("X",SetTo,0,CFlag);
			},
			flag = {Preserved}
		}
	FuncAlloc = FuncAlloc+1
	-- RecoverCp
	RecoverCp(PlayerID)
end

function CA__InputSVA1(Dest,Source,Size,Mask,Start,End,Next,DestDistance,SourceDistance) -- SVA1 -> SVA1
	local BoxM = {}
	if Mask ~= nil then
		BoxM = {SetDeaths(0,SetTo,Mask,0)} -- Mask
	end
	if DestDistance == nil then
		DestDistance = 1
	end
	if SourceDistance == nil then
		SourceDistance = 1
	end
	local DestCpAdd = 604*DestDistance-1
	if Next == 1 then
		DestCpAdd = 604*DestDistance
	end
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)
	local INVA = {CRet[1]} -- Size

	-- Get Size
	if type(Size) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",INVA[1],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "V" then
		if Size[5] == nil then
			Size[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",INVA[1],0x15C,0,SetTo,Size[5]);
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",INVA[1],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	-- Get Dest Cp
	if Dest[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig2X(0x6509B0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				FSetMemory(0x6509B0,Add,604*Dest[5]);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then -- Dest[5]604
		if Dest[5][5] == nil then
			Dest[5][5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig2X(0x6509B0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				FSetMemory(0x6509B0,Add,604*Dest[5][5]);
				SetCtrig1X(Dest[5][1],Dest[5][2],0x158,Dest[5][3],SetTo,EPD(0x6509B0));
				SetCtrig1X(Dest[5][1],Dest[5][2],0x148,Dest[5][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[5][1],Dest[5][2],0x160,Dest[5][3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Dest[5][1],Dest[5][2],Dest[5][3]);
			},
			flag = {Preserved}
		}
		--[[
		for i = 0, 31 do
			local CBit = 2^i
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX(Dest[5][1],Dest[5][2],0x15C,Dest[5][3],Exactly,CBit,CBit);
					},
					actions = {
						FSetMemory(0x6509B0,Add,604*CBit);
					},
					flag = {Preserved}
				}
		end
		]]--
	end

	-- Get Start & END
	if type(Start) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FuncAlloc,0x24,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrig1X("X",FuncAlloc,0x24,0,Add,Start*604);
			},
			flag = {Preserved}
		}
	elseif Start[4] == "V" then -- Start604
		if Start[5] == nil then
			Start[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FuncAlloc,0x24,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrig1X("X",FuncAlloc,0x24,0,Add,Start[5]*604);
				SetCtrigX(Start[1],Start[2],0x158,Start[3],SetTo,"X",FuncAlloc,0x24,1,0);
				SetCtrig1X(Start[1],Start[2],0x148,Start[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Start[1],Start[2],0x160,Start[3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Start[1],Start[2],Start[3]);
			},
			flag = {Preserved}
		}
		--[[
		for i = 0, 11 do
			local CBit = 2^i
			if Dest[6] >= CBit then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX(Start[1],Start[2],0x15C,Start[3],Exactly,CBit,CBit);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc,0x24,0,Add,604*CBit);
					},
					flag = {Preserved}
				}
			end
		end
		]]--
	end

	if type(End) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FuncAlloc,0x38,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrig1X("X",FuncAlloc,0x38,0,Add,End*604);
			},
			flag = {Preserved}
		}
	elseif End[4] == "V" then -- End604
		if End[5] == nil then
			End[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FuncAlloc,0x38,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrig1X("X",FuncAlloc,0x38,0,Add,End[5]*604);
				SetCtrigX(End[1],End[2],0x158,End[3],SetTo,"X",FuncAlloc,0x38,1,0);
				SetCtrig1X(End[1],End[2],0x148,End[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(End[1],End[2],0x160,End[3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(End[1],End[2],End[3]);
			},
			flag = {Preserved}
		}
		--[[
		for i = 0, 11 do
			local CBit = 2^i
			if Dest[6] >= CBit then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX(End[1],End[2],0x15C,End[3],Exactly,CBit,CBit);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc,0x38,0,Add,604*CBit);
					},
					flag = {Preserved}
				}
			end
		end
		]]--
	end

	-- Set Call VA
	if Source[4] == "V" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FuncAlloc,0x158,0,SetTo,Source[1],Source[2],0x164,1,Source[3]); 
					SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,Source[1],Source[2],0,0,Source[3]); 
					SetCtrigX("X",FuncAlloc,0x178,1,SetTo,Source[1],Source[2],0x4,1,Source[3]);
					SetCtrigX("X",FuncAlloc,0x178,0,SetTo,Source[1],Source[2],0x148,1,Source[3]);  
					SetCtrig1X("X",FuncAlloc,0x158,0,Add,Source[5]*604);
					SetCtrig1X("X",FuncAlloc,0x15C,1,Add,Source[5]*0x970);
					SetCtrig1X("X",FuncAlloc,0x178,1,Add,Source[5]*604);
					SetCtrig1X("X",FuncAlloc,0x178,0,Add,Source[5]*604);
				},
				flag = {Preserved}
			}
	elseif Source[4] == "VA" then -- Source[5]604
		if Source[5][5] == nil then
			Source[5][5] = 0
		end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FuncAlloc,0x158,0,SetTo,Source[1],Source[2],0x164,1,Source[3]); 
					SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,Source[1],Source[2],0,0,Source[3]); 
					SetCtrigX("X",FuncAlloc,0x178,1,SetTo,Source[1],Source[2],0x4,1,Source[3]); 
					SetCtrigX("X",FuncAlloc,0x178,0,SetTo,Source[1],Source[2],0x148,1,Source[3]); 
					SetCtrig1X("X",FuncAlloc,0x158,0,Add,Source[5][5]*604);
					SetCtrig1X("X",FuncAlloc,0x15C,1,Add,Source[5][5]*0x970);
					SetCtrig1X("X",FuncAlloc,0x178,1,Add,Source[5][5]*604);
					SetCtrig1X("X",FuncAlloc,0x178,0,Add,Source[5][5]*604);
					SetCtrigX(Source[5][1],Source[5][2],0x158,Source[5][3],SetTo,"X","X",0x15C,1,1);
					SetCtrig1X(Source[5][1],Source[5][2],0x148,Source[5][3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[5][1],Source[5][2],0x160,Source[5][3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Source[5][1],Source[5][2],Source[5][3]);
					SetCtrigX("X","X",0x158,1,SetTo,"X","X",0x17C,1,1);
					SetCtrig1X("X","X",0x178,1,SetTo,0);
					SetCtrig1X("X","X",0x17C,1,SetTo,0);
					SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetDeaths(0,Add,0,0);
					SetDeaths(0,Add,0,0);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x158,-1,SetTo,"X",FuncAlloc,0x158,1,0);
					SetCtrigX("X","X",0x178,-1,SetTo,"X","X",0x17C,1,-1);
					SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1);
					SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x158,-2,SetTo,"X",FuncAlloc,0x178,1,1);
					SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-2);
					SetCtrigX("X","X",0x4,-2,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x158,-3,SetTo,"X",FuncAlloc,0x178,1,0);
					SetCtrigX("X","X",0x178,-3,SetTo,"X",FuncAlloc,0x15C,1,1);
					SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-3);
					SetCtrigX("X","X",0x4,-3,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
		--[[
		for i = 0, 11 do
			local CBit = 2^i
			if Source[6] >= CBit then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX(Source[5][1],Source[5][2],0x15C,Source[5][3],Exactly,CBit,CBit);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc,0x158,0,Add,CBit*604);
						SetCtrig1X("X",FuncAlloc,0x15C,1,Add,CBit*2416);
						SetCtrig1X("X",FuncAlloc,0x178,1,Add,CBit*604);
						SetCtrig1X("X",FuncAlloc,0x178,0,Add,CBit*604);
					},
					flag = {Preserved}
				}
			end
		end
		]]--
	end

	CWhile(PlayerID,{CVar("X",INVA[1],AtLeast,1)},{SetCVar("X",INVA[1],Subtract,1)})
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(FuncAlloc);
					FMemory(0x6509B0,AtLeast,0); -- Cp >= Start+CB[1]
					FMemory(0x6509B0,AtMost,0); -- Cp <= End+CB[1]
				},
				actions = {
					SetDeathsX(0,SetTo,0,0,0x2); -- Enable
					BoxM,
				},
				flag = {Preserved}
			}

		-- Ctrig->Ctrig->Ctrig Version : Cp사용 X
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- "X"->VA
					SetCtrig2X(0,SetTo,"X","X",0,0,1); -- VA->"X"+1
				},
				flag = {Preserved}
			}
	CWhileEnd({FSetMemory(0x6509B0,Add,DestCpAdd),SetCtrig1X("X",FuncAlloc,0x158,0,Add,604*SourceDistance),SetCtrig1X("X",FuncAlloc,0x15C,1,Add,0x970*SourceDistance),SetCtrig1X("X",FuncAlloc,0x178,1,Add,604*SourceDistance),SetCtrig1X("X",FuncAlloc,0x178,0,Add,604*SourceDistance)})
	FuncAlloc = FuncAlloc + 1
	-- RecoverCp
	RecoverCp(PlayerID)
end

function CA__InputSVA1X(Dest,Source,Size,Mask,DestMask,Start,End,Next,DestDistance,SourceDistance) -- SVA1 -> SVA1 (With DestMask)
	local BoxM = {}
	if Mask ~= nil then
		BoxM = {SetDeaths(0,SetTo,Mask,0)} -- Mask
	else
		BoxM = {Disabled(SetDeaths(0,SetTo,0,0))} -- Mask
	end
	if DestDistance == nil then
		DestDistance = 1
	end
	if SourceDistance == nil then
		SourceDistance = 1
	end
	local DestCpAdd = 604*DestDistance-1
	if Next == 1 then
		DestCpAdd = 604*DestDistance
	end
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	local INVA = {CRet[1]} -- Size

	-- Get Size
	if type(Size) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",INVA[1],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "V" then
		if Size[5] == nil then
			Size[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",INVA[1],0x15C,0,SetTo,Size[5]);
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",INVA[1],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	-- Get Dest Cp
	if Dest[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig2X(0x6509B0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				FSetMemory(0x6509B0,Add,604*Dest[5]);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then -- Dest[5]604
		if Dest[5][5] == nil then
			Dest[5][5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig2X(0x6509B0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				FSetMemory(0x6509B0,Add,604*Dest[5][5]);
				SetCtrig1X(Dest[5][1],Dest[5][2],0x158,Dest[5][3],SetTo,EPD(0x6509B0));
				SetCtrig1X(Dest[5][1],Dest[5][2],0x148,Dest[5][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[5][1],Dest[5][2],0x160,Dest[5][3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Dest[5][1],Dest[5][2],Dest[5][3]);
			},
			flag = {Preserved}
		}
		--[[
		for i = 0, 31 do
			local CBit = 2^i
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX(Dest[5][1],Dest[5][2],0x15C,Dest[5][3],Exactly,CBit,CBit);
					},
					actions = {
						FSetMemory(0x6509B0,Add,604*CBit);
					},
					flag = {Preserved}
				}
		end
		]]--
	end

	-- Get Start & END
	if type(Start) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FuncAlloc,0x24,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrig1X("X",FuncAlloc,0x24,0,Add,Start*604);
			},
			flag = {Preserved}
		}
	elseif Start[4] == "V" then -- Start604
		if Start[5] == nil then
			Start[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FuncAlloc,0x24,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrig1X("X",FuncAlloc,0x24,0,Add,Start[5]*604);
				SetCtrigX(Start[1],Start[2],0x158,Start[3],SetTo,"X",FuncAlloc,0x24,1,0);
				SetCtrig1X(Start[1],Start[2],0x148,Start[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Start[1],Start[2],0x160,Start[3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Start[1],Start[2],Start[3]);
			},
			flag = {Preserved}
		}
		--[[
		for i = 0, 11 do
			local CBit = 2^i
			if Dest[6] >= CBit then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX(Start[1],Start[2],0x15C,Start[3],Exactly,CBit,CBit);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc,0x24,0,Add,604*CBit);
					},
					flag = {Preserved}
				}
			end
		end
		]]--
	end

	if type(End) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FuncAlloc,0x38,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrig1X("X",FuncAlloc,0x38,0,Add,End*604);
			},
			flag = {Preserved}
		}
	elseif End[4] == "V" then -- End604
		if End[5] == nil then
			End[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FuncAlloc,0x38,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrig1X("X",FuncAlloc,0x38,0,Add,End[5]*604);
				SetCtrigX(End[1],End[2],0x158,End[3],SetTo,"X",FuncAlloc,0x38,1,0);
				SetCtrig1X(End[1],End[2],0x148,End[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(End[1],End[2],0x160,End[3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(End[1],End[2],End[3]);
			},
			flag = {Preserved}
		}
		--[[
		for i = 0, 11 do
			local CBit = 2^i
			if Dest[6] >= CBit then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX(End[1],End[2],0x15C,End[3],Exactly,CBit,CBit);
					},
					actions = {
						SetCtrig1X("X",FuncAlloc,0x38,0,Add,604*CBit);
					},
					flag = {Preserved}
				}
			end
		end
		]]--
	end

	-- Set Call VA
	if Source[4] == "V" then
		if Mask == nil then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FuncAlloc,0x158,0,SetTo,Source[1],Source[2],0x164,1,Source[3]); 
					SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,Source[1],Source[2],0,0,Source[3]); 
					SetCtrigX("X",FuncAlloc,0x178,1,SetTo,Source[1],Source[2],0x4,1,Source[3]);
					SetCtrigX("X",FuncAlloc,0x48,0,SetTo,Source[1],Source[2],0x148,1,Source[3]);  
					SetCtrig1X("X",FuncAlloc,0x158,0,Add,Source[5]*604);
					SetCtrig1X("X",FuncAlloc,0x15C,1,Add,Source[5]*0x970);
					SetCtrig1X("X",FuncAlloc,0x178,1,Add,Source[5]*604);
					SetCtrig1X("X",FuncAlloc,0x48,0,Add,Source[5]*604);
				},
				flag = {Preserved}
			}
		else
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FuncAlloc,0x158,0,SetTo,Source[1],Source[2],0x164,1,Source[3]); 
					SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,Source[1],Source[2],0,0,Source[3]); 
					SetCtrigX("X",FuncAlloc,0x178,1,SetTo,Source[1],Source[2],0x4,1,Source[3]);
					SetCtrigX("X",FuncAlloc,0x178,0,SetTo,Source[1],Source[2],0x148,1,Source[3]);  
					SetCtrig1X("X",FuncAlloc,0x158,0,Add,Source[5]*604);
					SetCtrig1X("X",FuncAlloc,0x15C,1,Add,Source[5]*0x970);
					SetCtrig1X("X",FuncAlloc,0x178,1,Add,Source[5]*604);
					SetCtrig1X("X",FuncAlloc,0x178,0,Add,Source[5]*604);
				},
				flag = {Preserved}
			}
		end
	elseif Source[4] == "VA" then -- Source[5]604
		if Source[5][5] == nil then
			Source[5][5] = 0
		end
		if Mask == nil then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",FuncAlloc,0x158,0,SetTo,Source[1],Source[2],0x164,1,Source[3]); 
						SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,Source[1],Source[2],0,0,Source[3]); 
						SetCtrigX("X",FuncAlloc,0x178,1,SetTo,Source[1],Source[2],0x4,1,Source[3]); 
						SetCtrigX("X",FuncAlloc,0x48,0,SetTo,Source[1],Source[2],0x148,1,Source[3]); 
						SetCtrig1X("X",FuncAlloc,0x158,0,Add,Source[5][5]*604);
						SetCtrig1X("X",FuncAlloc,0x15C,1,Add,Source[5][5]*0x970);
						SetCtrig1X("X",FuncAlloc,0x178,1,Add,Source[5][5]*604);
						SetCtrig1X("X",FuncAlloc,0x48,0,Add,Source[5][5]*604);
						SetCtrigX(Source[5][1],Source[5][2],0x158,Source[5][3],SetTo,"X","X",0x15C,1,1);
						SetCtrig1X(Source[5][1],Source[5][2],0x148,Source[5][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[5][1],Source[5][2],0x160,Source[5][3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[5][1],Source[5][2],Source[5][3]);
						SetCtrigX("X","X",0x158,1,SetTo,"X","X",0x17C,1,1);
						SetCtrig1X("X","X",0x178,1,SetTo,0);
						SetCtrig1X("X","X",0x17C,1,SetTo,0);
						SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeaths(0,Add,0,0);
						SetDeaths(0,Add,0,0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x158,-1,SetTo,"X",FuncAlloc,0x158,1,0);
						SetCtrigX("X","X",0x178,-1,SetTo,"X","X",0x17C,1,-1);
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1);
						SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x158,-2,SetTo,"X",FuncAlloc,0x178,1,1);
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-2);
						SetCtrigX("X","X",0x4,-2,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x158,-3,SetTo,"X",FuncAlloc,0x48,1,0);
						SetCtrigX("X","X",0x178,-3,SetTo,"X",FuncAlloc,0x15C,1,1);
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-3);
						SetCtrigX("X","X",0x4,-3,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
		else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",FuncAlloc,0x158,0,SetTo,Source[1],Source[2],0x164,1,Source[3]); 
						SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,Source[1],Source[2],0,0,Source[3]); 
						SetCtrigX("X",FuncAlloc,0x178,1,SetTo,Source[1],Source[2],0x4,1,Source[3]); 
						SetCtrigX("X",FuncAlloc,0x178,0,SetTo,Source[1],Source[2],0x148,1,Source[3]); 
						SetCtrig1X("X",FuncAlloc,0x158,0,Add,Source[5][5]*604);
						SetCtrig1X("X",FuncAlloc,0x15C,1,Add,Source[5][5]*0x970);
						SetCtrig1X("X",FuncAlloc,0x178,1,Add,Source[5][5]*604);
						SetCtrig1X("X",FuncAlloc,0x178,0,Add,Source[5][5]*604);
						SetCtrigX(Source[5][1],Source[5][2],0x158,Source[5][3],SetTo,"X","X",0x15C,1,1);
						SetCtrig1X(Source[5][1],Source[5][2],0x148,Source[5][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[5][1],Source[5][2],0x160,Source[5][3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[5][1],Source[5][2],Source[5][3]);
						SetCtrigX("X","X",0x158,1,SetTo,"X","X",0x17C,1,1);
						SetCtrig1X("X","X",0x178,1,SetTo,0);
						SetCtrig1X("X","X",0x17C,1,SetTo,0);
						SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeaths(0,Add,0,0);
						SetDeaths(0,Add,0,0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x158,-1,SetTo,"X",FuncAlloc,0x158,1,0);
						SetCtrigX("X","X",0x178,-1,SetTo,"X","X",0x17C,1,-1);
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1);
						SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x158,-2,SetTo,"X",FuncAlloc,0x178,1,1);
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-2);
						SetCtrigX("X","X",0x4,-2,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x158,-3,SetTo,"X",FuncAlloc,0x178,1,0);
						SetCtrigX("X","X",0x178,-3,SetTo,"X",FuncAlloc,0x15C,1,1);
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-3);
						SetCtrigX("X","X",0x4,-3,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
		end
	end

	CWhile(PlayerID,{CVar("X",INVA[1],AtLeast,1)},{SetCVar("X",INVA[1],Subtract,1)})
		if Mask == nil then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(FuncAlloc);
					FMemory(0x6509B0,AtLeast,0); -- Cp >= Start+CB[1]
					FMemory(0x6509B0,AtMost,0); -- Cp <= End+CB[1]
					Deaths(0,AtLeast,1,0);
				},
				actions = {
					SetDeathsX(0,SetTo,0,0,0x2); -- Enable
					BoxM,
					SetCtrig1X("X",FuncAlloc,0x164+0x20*3,1,SetTo,0x0,0x2);
				},
				flag = {Preserved}
			}
		else
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(FuncAlloc);
					FMemory(0x6509B0,AtLeast,0); -- Cp >= Start+CB[1]
					FMemory(0x6509B0,AtMost,0); -- Cp <= End+CB[1]
				},
				actions = {
					SetDeathsX(0,SetTo,0,0,0x2); -- Enable
					BoxM,
					SetCtrig1X("X",FuncAlloc,0x164+0x20*3,1,SetTo,0x0,0x2);
				},
				flag = {Preserved}
			}
		end
		-- Ctrig->Ctrig->Ctrig Version : Cp사용 X
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- "X"->VA
					SetCtrig2X(0,SetTo,"X","X",0,0,1); -- VA->"X"+1
					FSetMemory(0x6509B0,Subtract,5);
					Disabled(SetDeaths(CurrentPlayer,SetTo,DestMask,0));
					FSetMemory(0x6509B0,Add,5);
					SetCtrig1X("X","X",0x164+0x20*3,0,SetTo,0x2,0x2);
				},
				flag = {Preserved}
			}
	if Mask == nil then
		CWhileEnd({FSetMemory(0x6509B0,Add,DestCpAdd),SetCtrig1X("X",FuncAlloc,0x158,0,Add,604*SourceDistance),SetCtrig1X("X",FuncAlloc,0x15C,1,Add,0x970*SourceDistance),SetCtrig1X("X",FuncAlloc,0x178,1,Add,604*SourceDistance),SetCtrig1X("X",FuncAlloc,0x48,0,Add,604*SourceDistance)})
	else
		CWhileEnd({FSetMemory(0x6509B0,Add,DestCpAdd),SetCtrig1X("X",FuncAlloc,0x158,0,Add,604*SourceDistance),SetCtrig1X("X",FuncAlloc,0x15C,1,Add,0x970*SourceDistance),SetCtrig1X("X",FuncAlloc,0x178,1,Add,604*SourceDistance),SetCtrig1X("X",FuncAlloc,0x178,0,Add,604*SourceDistance)})
	end
	FuncAlloc = FuncAlloc + 1
	-- RecoverCp
	RecoverCp(PlayerID)
end

function CA__SetValue(SVA1,String,Mask,Index,Preserve,utf8flag)
	local Arr, Size

	if utf8flag == 1 then
		Arr, Size = str_to_iutf8(String,1)
	else
		Arr, Size = str_to_icp949(String,1)
	end

	if Mask == nil then
		if utf8flag == 1 then
			Mask = 0xFFFFFFFF
		else
			Mask = 0xFFFF00FF
		end
	end
	if Index == nil then
		Index = 0
	end

	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	local Box = {}
	if type(Index) == "number" then
		if SVA1[6] < Index+Size then
			CA__SetValue_StringSize_Overflow()
		end
		local n = 1
		local i = 0
		while true do
			table.insert(Box,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+i+Index,SetTo,Arr[n]+Arr[n+1]*256+Arr[n+2]*65536+Arr[n+3]*16777216,Mask))
			n = n+4
			i = i+1
			if n > #Arr then break end
		end

		if Preserve == 0 then
			DoActions2X(PlayerID,Box,{})
		else
			DoActions2X(PlayerID,Box)
		end
	else
		if SVA1[6]+1 < Size then
			CA__SetValue_StringSize_Overflow()
		end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(FuncAlloc);
					NVar(Index,AtLeast,(SVA1[6]-Size+1)*604);
				},
				actions = {
					SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc+1,0x0,0,0);
				},
				flag = {Preserved}
			}

		if Index[5] == nil then
			Index[5] = 0
		end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0x6509B0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+Index[5]);
					SetCtrig1X(Index[1],Index[2],0x158,Index[3],SetTo,EPD(0x6509B0));
					SetCtrig1X(Index[1],Index[2],0x148,Index[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Index[1],Index[2],0x160,Index[3],SetTo,Add*16777216,0xFF000000);
					CallLabelAlways(Index[1],Index[2],Index[3]);
				},
				flag = {Preserved}
			}

		local n = 1
		local i = 0
		while true do
			table.insert(Box,SetDeathsX(CurrentPlayer,SetTo,Arr[n]+Arr[n+1]*256+Arr[n+2]*65536+Arr[n+3]*16777216,0,Mask))
			table.insert(Box,SetMemory(0x6509B0,Add,604))
			n = n+4
			i = i+1
			if n > #Arr then break end
		end

		if Preserve == 0 then
			DoActions2X(PlayerID,Box,{})
		else
			DoActions2X(PlayerID,Box)
		end

		RecoverCp(PlayerID)

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(FuncAlloc+1);
				},
				actions = {
					SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
				},
				flag = {Preserved}
			}
		FuncAlloc = FuncAlloc+2
	end
end

function CA__DwSetValue(SVA1,String,Index,Preserve,utf8flag)
	local Arr, Size, Mask, Max

	if utf8flag == 1 then
		Arr = cp949_to_utf8(String)
		table.remove(Arr,#Arr)
		Size = #Arr
		Max = math.ceil(Size/4)-1
	else
		Arr = {}
		Size = #String
		for i = 1, #String do
			table.insert(Arr,string.byte(String,i))
		end
		Max = math.ceil(Size/4)-1
	end

	if Index == nil then
		Index = 0
	end

	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	local Box = {}
	if type(Index) == "number" then
		if SVA1[6] < Index+Max then
			CA__DwSetValue_StringSize_Overflow()
		end
		local n = 1
		local i = 0
		while true do
			if Arr[n+1] == nil then
				Arr[n+1] = 0xD
			end
			if Arr[n+2] == nil then
				Arr[n+2] = 0xD
			end
			if Arr[n+3] == nil then
				Arr[n+3] = 0xD
			end
			table.insert(Box,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+i+Index,SetTo,Arr[n]+bit32.lshift(Arr[n+1],8)+bit32.lshift(Arr[n+2],16)+bit32.lshift(Arr[n+3],24)))
			n = n+4
			i = i+1
			if n > #Arr then break end
		end

		if Preserve == 0 then
			DoActions2X(PlayerID,Box,{})
		else
			DoActions2X(PlayerID,Box)
		end
	else
		if SVA1[6]+1 < math.ceil(Size/4) then
			CA__SetValue_StringSize_Overflow()
		end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(FuncAlloc);
					NVar(Index,AtLeast,(SVA1[6]-math.ceil(Size/4)+1)*604);
				},
				actions = {
					SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc+1,0x0,0,0);
				},
				flag = {Preserved}
			}

		if Index[5] == nil then
			Index[5] = 0
		end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0x6509B0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+Index[5]);
					SetCtrig1X(Index[1],Index[2],0x158,Index[3],SetTo,EPD(0x6509B0));
					SetCtrig1X(Index[1],Index[2],0x148,Index[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Index[1],Index[2],0x160,Index[3],SetTo,Add*16777216,0xFF000000);
					CallLabelAlways(Index[1],Index[2],Index[3]);
				},
				flag = {Preserved}
			}

		local n = 1
		local i = 0
		while true do
			if Arr[n+1] == nil then
				Arr[n+1] = 0xD
			end
			if Arr[n+2] == nil then
				Arr[n+2] = 0xD
			end
			if Arr[n+3] == nil then
				Arr[n+3] = 0xD
			end
			table.insert(Box,SetDeathsX(CurrentPlayer,SetTo,Arr[n]+bit32.lshift(Arr[n+1],8)+bit32.lshift(Arr[n+2],16)+bit32.lshift(Arr[n+3],24),0))
			table.insert(Box,SetMemory(0x6509B0,Add,604))
			n = n+4
			i = i+1
			if n > #Arr then break end
		end

		if Preserve == 0 then
			DoActions2X(PlayerID,Box,{})
		else
			DoActions2X(PlayerID,Box)
		end

		RecoverCp(PlayerID)

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(FuncAlloc+1);
				},
				actions = {
					SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
				},
				flag = {Preserved}
			}
		FuncAlloc = FuncAlloc+2
	end
end

function CA__SetMask(SVA1,Mask,Start,End,Preserve)
	if Mask == nil then
		Mask = 0xFFFF00FF
	end
	if Start == nil then
		Start = 0
	end
	if End == nil then
		End = SVA1[6]-1
	end

	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	local Box = {}
	if type(Start) == "number" and type(End) == "number" then
		for i = Start, End do
			table.insert(Box,SetCtrig1X(SVA1[1],SVA1[2],0x148,SVA1[3]+i,SetTo,Mask))
		end
		if Preserve == 0 then
			DoActions2X(PlayerID,Box,{})
		else
			DoActions2X(PlayerID,Box)
		end
	else
		if type(Start) == "number" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0x6509B0,SetTo,SVA1[1],SVA1[2],0x148,1,SVA1[3]+Start);
				},
				flag = {Preserved}
			}
		elseif Start[4] == "V" then -- Start604
			if Start[5] == nil then
				Start[5] = 0
			end
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0x6509B0,SetTo,SVA1[1],SVA1[2],0x148,1,SVA1[3]+Start[5]);
					SetCtrig1X(Start[1],Start[2],0x158,Start[3],SetTo,EPD(0x6509B0));
					SetCtrig1X(Start[1],Start[2],0x148,Start[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Start[1],Start[2],0x160,Start[3],SetTo,Add*16777216,0xFF000000);
					CallLabelAlways(Start[1],Start[2],Start[3]);
				},
				flag = {Preserved}
			}
		end
		if type(End) == "number" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x24,1,SetTo,SVA1[1],SVA1[2],0x148,1,SVA1[3]+End);
				},
				flag = {Preserved}
			}
		elseif End[4] == "V" then -- End604
			if End[5] == nil then
				End[5] = 0
			end
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x24,1,SetTo,SVA1[1],SVA1[2],0x148,1,SVA1[3]+End[5]);
					SetCtrigX(End[1],End[2],0x158,End[3],SetTo,"X","X",0x24,1,1);
					SetCtrig1X(End[1],End[2],0x148,End[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(End[1],End[2],0x160,End[3],SetTo,Add*16777216,0xFF000000);
					CallLabelAlways(End[1],End[2],End[3]);
				},
				flag = {Preserved}
			}
		end

		CWhile(PlayerID,{FMemory(0x6509B0,AtMost,0)},{SetDeaths(CurrentPlayer,SetTo,Mask,0)})
		CWhileEnd({FSetMemory(0x6509B0,Add,604)})

		RecoverCp(PlayerID)
	end
end

function CA__epdcpy(SVA1,Value,Mask,Start,End,Preserve)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	if Start == nil then
		Start = 0
	end
	if End == nil then
		End = SVA1[6]-1
	end

	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	local Box = {}
	if type(Start) == "number" and type(End) == "number" then
		for i = Start, End do
			table.insert(Box,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+i,SetTo,Value,Mask))
		end
		if Preserve == 0 then
			DoActions2X(PlayerID,Box,{})
		else
			DoActions2X(PlayerID,Box)
		end
	else
		if type(Start) == "number" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0x6509B0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+Start);
				},
				flag = {Preserved}
			}
		elseif Start[4] == "V" then -- Start604
			if Start[5] == nil then
				Start[5] = 0
			end
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0x6509B0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+Start[5]);
					SetCtrig1X(Start[1],Start[2],0x158,Start[3],SetTo,EPD(0x6509B0));
					SetCtrig1X(Start[1],Start[2],0x148,Start[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Start[1],Start[2],0x160,Start[3],SetTo,Add*16777216,0xFF000000);
					CallLabelAlways(Start[1],Start[2],Start[3]);
				},
				flag = {Preserved}
			}
		end
		if type(End) == "number" then
			if type(Value) == "number" then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x24,1,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+End);
						SetCtrig1X("X","X",0x17C,1,SetTo,Value);
					},
					flag = {Preserved}
				}
			elseif Value[4] == "V" then
				if Value[5] == nil then
					Value[5] = 0
				end
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x24,1,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+End);
						SetCtrig1X("X","X",0x17C,1,SetTo,Value[5]);
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x17C,1,1);
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000);
						CallLabelAlways(Value[1],Value[2],Value[3]);
					},
					flag = {Preserved}
				}
			end
		elseif End[4] == "V" then -- End604
			if type(Value) == "number" then
				if End[5] == nil then
					End[5] = 0
				end
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x17C,1,SetTo,Value);
						SetCtrigX("X","X",0x24,1,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+End[5]);
						SetCtrigX(End[1],End[2],0x158,End[3],SetTo,"X","X",0x24,1,1);
						SetCtrig1X(End[1],End[2],0x148,End[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(End[1],End[2],0x160,End[3],SetTo,Add*16777216,0xFF000000);
						CallLabelAlways(End[1],End[2],End[3]);
					},
					flag = {Preserved}
				}
			elseif Value[4] == "V" then
				if Value[5] == nil then
					Value[5] = 0
				end
				if End[5] == nil then
					End[5] = 0
				end
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x17C,1,SetTo,Value[5]);
						SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x17C,1,1);
						SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX("X","X",0x24,1,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+End[5]);
						SetCtrigX(End[1],End[2],0x158,End[3],SetTo,"X","X",0x24,1,1);
						SetCtrig1X(End[1],End[2],0x148,End[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(End[1],End[2],0x160,End[3],SetTo,Add*16777216,0xFF000000);
						CallLabelAlways2(End[1],End[2],End[3],Value[1],Value[2],Value[3]);
					},
					flag = {Preserved}
				}
			end
		end

		CWhile(PlayerID,{FMemory(0x6509B0,AtMost,0)},{SetDeaths(CurrentPlayer,SetTo,0,0,Mask)})
		CWhileEnd({FSetMemory(0x6509B0,Add,604)})

		RecoverCp(PlayerID)
	end
end

function CA__SetNext(SVA1,DestDistance,Mode,Start,End,Preserve)
	if DestDistance == nil then
		DestDistance = 1
	end
	if Mode == nil then
		Mode = SetTo
	end
	if Start == nil then
		Start = 0
	end
	if End == nil then
		End = SVA1[6]-1
	end

	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	local Box = {}
	if type(Start) == "number" and type(End) == "number" then
		if type(DestDistance) == "number" then
			for i = Start, End do
				table.insert(Box,SetCtrig1X(SVA1[1],SVA1[2],0x17C,SVA1[3]+i,Mode,DestDistance))
			end
			if Preserve == 0 then
				DoActions2X(PlayerID,Box,{})
			else
				DoActions2X(PlayerID,Box)
			end
		elseif DestDistance[4] == "V" then
			if Preserve == 0 then
				CIfOnce(PlayerID)
			end

			if DestDistance[5] == nil then
				DestDistance[5] = 0
			end
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCVar("X",CRet[1],SetTo,Start);
					SetCtrigX("X","X",0x178,1,SetTo,SVA1[1],SVA1[2],0x17C,1,SVA1[3]+Start);
					SetCtrig1X("X","X",0x17C,1,SetTo,DestDistance[5]);
					SetCtrigX(DestDistance[1],DestDistance[2],0x158,DestDistance[3],SetTo,"X","X",0x17C,1,1);
					SetCtrig1X(DestDistance[1],DestDistance[2],0x148,DestDistance[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(DestDistance[1],DestDistance[2],0x160,DestDistance[3],SetTo,Add*16777216,0xFF000000);
					CallLabelAlways(DestDistance[1],DestDistance[2],DestDistance[3]);
				},
				flag = {Preserved}
			}

			CWhile(PlayerID,{CVar("X",CRet[1],AtMost,End)},{SetDeaths(0,Mode,0,0),SetCVar("X",CRet[1],Add,1)})
			CWhileEnd({SetCtrig1X("X","X",0x178,-2,Add,604)})

			if Preserve == 0 then
				CIfEnd()
			end
		end
	else
		if Preserve == 0 then
			CIfOnce(PlayerID)
		end
		local PerAct
		if type(DestDistance) == "number" then
			PerAct = {SetDeaths(CurrentPlayer,Mode,DestDistance,0)}
		elseif DestDistance[4] == "V" then
			if DestDistance[5] == nil then
				DestDistance[5] = 0
			end
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",IndexAlloc,0x17C,0,SetTo,DestDistance[5]);
					SetCtrigX(DestDistance[1],DestDistance[2],0x158,DestDistance[3],SetTo,"X",IndexAlloc,0x17C,1,0);
					SetCtrig1X(DestDistance[1],DestDistance[2],0x148,DestDistance[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(DestDistance[1],DestDistance[2],0x160,DestDistance[3],SetTo,Add*16777216,0xFF000000);
					CallLabelAlways(DestDistance[1],DestDistance[2],DestDistance[3]);
				},
				flag = {Preserved}
			}
			PerAct = {SetDeaths(CurrentPlayer,Mode,0,0)}
		end 

		if type(Start) == "number" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0x6509B0,SetTo,SVA1[1],SVA1[2],0x17C,1,SVA1[3]+Start);
				},
				flag = {Preserved}
			}
		elseif Start[4] == "V" then -- Start604
			if Start[5] == nil then
				Start[5] = 0
			end
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0x6509B0,SetTo,SVA1[1],SVA1[2],0x17C,1,SVA1[3]+Start[5]);
					SetCtrig1X(Start[1],Start[2],0x158,Start[3],SetTo,EPD(0x6509B0));
					SetCtrig1X(Start[1],Start[2],0x148,Start[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Start[1],Start[2],0x160,Start[3],SetTo,Add*16777216,0xFF000000);
					CallLabelAlways(Start[1],Start[2],Start[3]);
				},
				flag = {Preserved}
			}
		end
		if type(End) == "number" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",IndexAlloc,0x24,0,SetTo,SVA1[1],SVA1[2],0x17C,1,SVA1[3]+End);
				},
				flag = {Preserved}
			}
		elseif End[4] == "V" then -- End604
			if End[5] == nil then
				End[5] = 0
			end
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",IndexAlloc,0x24,0,SetTo,SVA1[1],SVA1[2],0x17C,1,SVA1[3]+End[5]);
					SetCtrigX(End[1],End[2],0x158,End[3],SetTo,"X",IndexAlloc,0x24,1,0);
					SetCtrig1X(End[1],End[2],0x148,End[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(End[1],End[2],0x160,End[3],SetTo,Add*16777216,0xFF000000);
					CallLabelAlways(End[1],End[2],End[3]);
				},
				flag = {Preserved}
			}
		end
		
		CWhile(PlayerID,{FMemory(0x6509B0,AtMost,0)},{PerAct})
		CWhileEnd({FSetMemory(0x6509B0,Add,604)})

		RecoverCp(PlayerID)

		if Preserve == 0 then
			CIfEnd()
		end
	end
end

function CA__MoveXY(SVA1,Line,Mul,Mode,Fix,PathData,Preserve)
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)
	local pk = 1
	if Mul == 1 then
		pk = 604
	end
	if Mode == nil then
		Mode = Add
	end

	local XYMode = 0
	if Line == nil then
		XYMode = 1
	end

	local Box = {}
	local Check = 0
	if Preserve == 0 then
		CIfOnce(PlayerID)
	end
	local RetArr = {}
	if Fix == 1 then
		local Temp = 0
		local Prev = 0
		for k, v in pairs(PathData) do
			if #v == 3 and XYMode == 0 then
				if type(v[2]) == "number" and type(v[3]) == "number" then
					local Ret = v[2]+(Line)*v[3]
					Temp = Ret - Prev
					Prev = Ret
					table.insert(RetArr,Temp)
					if type(v[1]) == "number" then
						table.insert(Box,SetCtrig1X(SVA1[1],SVA1[2],0x17C,SVA1[3]+v[1],Mode,(Temp)*pk))
						Check = 1
					else
						if v[1][5] == nil then
							v[1][5] = 0
						end
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX("X","X",0x158,1,SetTo,SVA1[1],SVA1[2],0x17C,1,SVA1[3]+v[1][5]);
									SetCtrigX(v[1][1],v[1][2],0x158,v[1][3],SetTo,"X","X",0x158,1,1);
									SetCtrig1X(v[1][1],v[1][2],0x148,v[1][3],SetTo,0xFFFFFFFF);
									SetCtrig1X(v[1][1],v[1][2],0x160,v[1][3],SetTo,Add*16777216,0xFF000000);
									CallLabelAlways(v[1][1],v[1][2],v[1][3]);
								},
								flag = {Preserved}
							}

						Trigger {
							players = {PlayerID},
							conditions = {
								Label();
							},
							actions = {
								SetDeaths(0,Mode,(Temp)*pk,0);
							},
							flag = {Preserved}
						}
					end
				else
					CA__MoveXY_InputData_Error()
				end
			elseif #v == 2 then
				local Ret = v[2]
				Temp = Ret - Prev
				Prev = Ret
				table.insert(RetArr,Temp)
				if type(v[1]) == "number" and type(v[2]) == "number" then
					table.insert(Box,SetCtrig1X(SVA1[1],SVA1[2],0x17C,SVA1[3]+v[1],Mode,Temp*pk))
					Check = 1
				else
					if type(v[1]) == "number" then
						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x158,1,SetTo,SVA1[1],SVA1[2],0x17C,1,SVA1[3]+v[1]);
							},
							flag = Pflag
						}
					elseif v[1][4] == "V" then -- v[1]604
						if v[1][5] == nil then
							v[1][5] = 0
						end
						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x158,1,SetTo,SVA1[1],SVA1[2],0x17C,1,SVA1[3]+v[1][5]);
								SetCtrigX(v[1][1],v[1][2],0x158,v[1][3],SetTo,"X","X",0x158,1,1);
								SetCtrig1X(v[1][1],v[1][2],0x148,v[1][3],SetTo,0xFFFFFFFF);
								SetCtrig1X(v[1][1],v[1][2],0x160,v[1][3],SetTo,Add*16777216,0xFF000000);
								CallLabelAlways(v[1][1],v[1][2],v[1][3]);
							},
							flag = {Preserved}
						}
					end

					Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetDeaths(0,Mode,Temp*pk,0);
						},
						flag = {Preserved}
					}
					FuncAlloc = FuncAlloc+1
				end
			else
				CA__MoveXY_InputData_Error()
			end
		end
	else
		for k, v in pairs(PathData) do
			if #v == 3 and XYMode == 0 then
				if type(v[2]) == "number" and type(v[3]) == "number" then
					if type(v[1]) == "number" then
						table.insert(Box,SetCtrig1X(SVA1[1],SVA1[2],0x17C,SVA1[3]+v[1],Mode,(v[2]+(Line)*v[3])*pk))
						Check = 1
					else
						if v[1][5] == nil then
							v[1][5] = 0
						end
						Trigger {
								players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX("X","X",0x158,1,SetTo,SVA1[1],SVA1[2],0x17C,1,SVA1[3]+v[1][5]);
									SetCtrigX(v[1][1],v[1][2],0x158,v[1][3],SetTo,"X","X",0x158,1,1);
									SetCtrig1X(v[1][1],v[1][2],0x148,v[1][3],SetTo,0xFFFFFFFF);
									SetCtrig1X(v[1][1],v[1][2],0x160,v[1][3],SetTo,Add*16777216,0xFF000000);
									CallLabelAlways(v[1][1],v[1][2],v[1][3]);
								},
								flag = {Preserved}
							}

						Trigger {
							players = {PlayerID},
							conditions = {
								Label();
							},
							actions = {
								SetDeaths(0,Mode,(v[2]+(Line)*v[3])*pk,0);
							},
							flag = {Preserved}
						}
					end
				else
					CA__MoveXY_InputData_Error()
				end
			elseif #v == 2 then
				if type(v[1]) == "number" and type(v[2]) == "number" then
					table.insert(Box,SetCtrig1X(SVA1[1],SVA1[2],0x17C,SVA1[3]+v[1],Mode,v[2]*pk))
					Check = 1
				else
					if type(v[1]) == "number" then
						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x158,2,SetTo,SVA1[1],SVA1[2],0x17C,1,SVA1[3]+v[1]);
							},
							flag = Pflag
						}
					elseif v[1][4] == "V" then -- v[1]604
						if v[1][5] == nil then
							v[1][5] = 0
						end
						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x158,2,SetTo,SVA1[1],SVA1[2],0x17C,1,SVA1[3]+v[1][5]);
								SetCtrigX(v[1][1],v[1][2],0x158,v[1][3],SetTo,"X","X",0x158,1,2);
								SetCtrig1X(v[1][1],v[1][2],0x148,v[1][3],SetTo,0xFFFFFFFF);
								SetCtrig1X(v[1][1],v[1][2],0x160,v[1][3],SetTo,Add*16777216,0xFF000000);
								CallLabelAlways(v[1][1],v[1][2],v[1][3]);
							},
							flag = {Preserved}
						}
					end

					if type(v[2]) == "number" then
						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X","X",0x15C,1,SetTo,v[2]*pk);
							},
							flag = {Preserved}
						}
					elseif v[2][4] == "V" then
						if v[2][5] == nil then
							v[2][5] = 0
						end
						Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X","X",0x15C,1,SetTo,v[2][5]);
								SetCtrigX(v[2][1],v[2][2],0x158,v[2][3],SetTo,"X","X",0x15C,1,1);
								SetCtrig1X(v[2][1],v[2][2],0x148,v[2][3],SetTo,0xFFFFFFFF);
								SetCtrig1X(v[2][1],v[2][2],0x160,v[2][3],SetTo,Add*16777216,0xFF000000);
								CallLabelAlways(v[2][1],v[2][2],v[2][3]);
							},
							flag = {Preserved}
						}
					end

					Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetDeaths(0,Mode,0,0);
						},
						flag = {Preserved}
					}
					FuncAlloc = FuncAlloc+1
				end
			else
				CA__MoveXY_InputData_Error()
			end
		end
	end
	if Check == 1 then
		if Preserve == 0 then
			DoActions2X(PlayerID,Box,{})
		else
			DoActions2X(PlayerID,Box)
		end
	end

	if Preserve == 0 then
		CIfEnd()
	end
	return RetArr
end

function CA__Read(Index,Output,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr

	f_Read(PlayerID,_Add(CB[1],Index),Output,nil,Mask)
end

function CA__ReadX(Index,Output,Multiplier,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr

	f_ReadX(PlayerID,_Add(CB[1],Index),Output,Multiplier,Mask)
end

function CA__Mov(SVA1,Output,Mask,RecoverMask)
	if Mask == nil then
		Mask  = 0xFFFFFFFF
	end
	if RecoverMask == nil then
		RecoverMask = 0xFFFF00FF
	end
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	if SVA1[4] == "V" then
		if type(Output) == "number" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label();
				},
				actions = {
					SetCtrig1X(SVA1[1],SVA1[2],0x164,SVA1[3]+SVA1[5],SetTo,0,0x2);
					SetCtrig1X(SVA1[1],SVA1[2],0x180,SVA1[3]+SVA1[5],SetTo,0,0xFF0000);
					SetCtrig1X(SVA1[1],SVA1[2],0x158,SVA1[3]+SVA1[5],SetTo,EPD(Output));
					SetCtrig1X(SVA1[1],SVA1[2],0x148,SVA1[3]+SVA1[5],SetTo,Mask);
					CallLabelAlways(SVA1[1],SVA1[2],SVA1[3]+SVA1[5]);
				},
				flag = {Preserved}
			}
		elseif Output[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label();
				},
				actions = {
					SetCtrig1X(SVA1[1],SVA1[2],0x164,SVA1[3]+SVA1[5],SetTo,0,0x2);
					SetCtrig1X(SVA1[1],SVA1[2],0x180,SVA1[3]+SVA1[5],SetTo,0,0xFF0000);
					SetCtrigX(SVA1[1],SVA1[2],0x158,SVA1[3]+SVA1[5],SetTo,Output[1],Output[2],0x15C,1,Output[3]);
					SetCtrig1X(SVA1[1],SVA1[2],0x148,SVA1[3]+SVA1[5],SetTo,Mask);
					CallLabelAlways(SVA1[1],SVA1[2],SVA1[3]+SVA1[5]);
				},
				flag = {Preserved}
			}
		else
			Trigger {
				players = {PlayerID},
				conditions = {
					Label();
				},
				actions = {
					SetCtrig1X(SVA1[1],SVA1[2],0x164,SVA1[3]+SVA1[5],SetTo,0,0x2);
					SetCtrig1X(SVA1[1],SVA1[2],0x180,SVA1[3]+SVA1[5],SetTo,0,0xFF0000);
					SetCtrigX(SVA1[1],SVA1[2],0x158,SVA1[3]+SVA1[5],SetTo,Output[1],Output[2],Output[3],1,Output[4]);
					SetCtrig1X(SVA1[1],SVA1[2],0x148,SVA1[3]+SVA1[5],SetTo,Mask);
					CallLabelAlways(SVA1[1],SVA1[2],SVA1[3]+SVA1[5]);
				},
				flag = {Preserved}
			}
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrig1X(SVA1[1],SVA1[2],0x164,SVA1[3]+SVA1[5],SetTo,0x2,0x2);
				SetCtrig1X(SVA1[1],SVA1[2],0x180,SVA1[3]+SVA1[5],SetTo,0x2D0000,0xFF0000);
				SetCtrig1X(SVA1[1],SVA1[2],0x158,SVA1[3]+SVA1[5],SetTo,13);
				SetCtrig1X(SVA1[1],SVA1[2],0x148,SVA1[3]+SVA1[5],SetTo,RecoverMask);
			},
			flag = {Preserved}
		}
	elseif SVA1[4] == "VA" then
		if SVA1[5][5] == nil then
			SVA1[5][5] = 0
		end
		Trigger {--(CPRead)로 값 출력
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(SVA1[5][1],SVA1[5][2],0x148,SVA1[5][3],SetTo,0xFFFFFFFF);
					SetCtrig1X(SVA1[5][1],SVA1[5][2],0x160,SVA1[5][3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(SVA1[5][1],SVA1[5][2],0x158,SVA1[5][3],SetTo,"X",CRet[1],0x15C,1,0); 
					SetCtrig1X("X",CRet[1],0x15C,0,SetTo,SVA1[5][5]*604);
					SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
					SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0); 
					CallLabelAlways2(SVA1[5][1],SVA1[5][2],SVA1[5][3],"X",CRet[1],0);
				},
				flag = {Preserved}
			}
		Trigger {--(CPRead)로 값 출력
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabelAlways("X",CRet[1],0);
				},
				flag = {Preserved}
			}
		Trigger {--(CPRead)로 값 출력
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x15C,1,SetTo,SVA1[1],SVA1[2],0,0,SVA1[3]); 
					SetCtrig2X(0x6509B0,SetTo,SVA1[1],SVA1[2],0,1,SVA1[3]); 
					SetMemory(0x6509B0,Add,SVA1[5][5]*604);

					SetCtrig1X(SVA1[5][1],SVA1[5][2],0x148,SVA1[5][3],SetTo,0xFFFFFFFF);
					SetCtrig1X(SVA1[5][1],SVA1[5][2],0x160,SVA1[5][3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(SVA1[5][1],SVA1[5][2],0x158,SVA1[5][3],SetTo,EPD(0x6509B0)); 

					SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
					SetCtrigX("X",CRet[1],0x158,0,SetTo,"X","X",0x15C,1,1); 
					CallLabelAlways2(SVA1[5][1],SVA1[5][2],SVA1[5][3],"X",CRet[1],0);
				},
				flag = {Preserved}
			}
		if type(Output) == "number" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
					SetMemory(0x6509B0,Add,(0x164-0x0)/4);
					SetDeathsX(CurrentPlayer,SetTo,0,0,0x2);
					SetMemory(0x6509B0,Add,(0x158-0x164)/4);
					SetDeaths(CurrentPlayer,SetTo,EPD(Output),0); -- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x180-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,0,0,0xFF0000);
				},
				flag = {Preserved}
			}
		elseif Output[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
					SetMemory(0x6509B0,Add,(0x164-0x0)/4);
					SetDeathsX(CurrentPlayer,SetTo,0,0,0x2);
					SetMemory(0x6509B0,Add,(0x158-0x164)/4);
					SetCtrig2X("Cp",SetTo,Output[1],Output[2],0x15C,1,Output[3]); -- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x180-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,0,0,0xFF0000);
				},
				flag = {Preserved}
			}
		else
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
					SetMemory(0x6509B0,Add,(0x164-0x0)/4);
					SetDeathsX(CurrentPlayer,SetTo,0,0,0x2);
					SetMemory(0x6509B0,Add,(0x158-0x164)/4);
					SetCtrig2X("Cp",SetTo,Output[1],Output[2],Output[3],1,Output[4]); -- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x180-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,0,0,0xFF0000);
				},
				flag = {Preserved}
			}
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetDeathsX(CurrentPlayer,SetTo,0x2D0000,0,0xFF0000);
				SetMemory(0x6509B0,Add,(0x164-0x180)/4);
				SetDeathsX(CurrentPlayer,SetTo,0x2,0,0x2);
				SetMemory(0x6509B0,Add,(0x148-0x164)/4);
				SetDeaths(CurrentPlayer,SetTo,RecoverMask,0);
				SetMemory(0x6509B0,Add,(0x158-0x148)/4);
				SetDeaths(CurrentPlayer,SetTo,13,0);
			},
			flag = {Preserved}
		}
		RecoverCp(PlayerID)
	end
end

function CA__Movcpy(SVA1,Output,Size,Mask,RecoverMask,DestDistance)
	if Mask == nil then
		Mask = 0xFFFF00FF
	end
	if RecoverMask == nil then
		RecoverMask = 0xFFFF00FF
	end
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	if DestDistance == nil then
		DestDistance = 1
	end

	if type(Output) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FuncAlloc,0x19C,0,SetTo,EPD(Output));
			},
			flag = {Preserved}
		}
	elseif Output[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FuncAlloc,0x19C,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
			},
			flag = {Preserved}
		}
		DestDistance = DestDistance*604
	else -- Mem
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FuncAlloc,0x19C,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "V" then
		if Size[5] == nil then
			Size[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Size[5]);
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",CRet[1],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end
	
	if SVA1[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FuncAlloc,0x15C,0,SetTo,SVA1[1],SVA1[2],0x0,0,SVA1[3]+SVA1[5]);
				SetCtrig2X(0x6509B0,SetTo,SVA1[1],SVA1[2],0x0,1,SVA1[3]+SVA1[5]);
			},
			flag = {Preserved}
		}
	elseif SVA1[4] == "VA" then
		if SVA1[5][5] == nil then
			SVA1[5][5] = 0 
		end

		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FuncAlloc,0x15C,0,SetTo,SVA1[1],SVA1[2],0x0,0,SVA1[3]+SVA1[5][5]);
				SetCtrig2X(0x6509B0,SetTo,SVA1[1],SVA1[2],0x0,1,SVA1[3]+SVA1[5][5]);
				SetCtrigX(SVA1[5][1],SVA1[5][2],0x158,SVA1[5][3],SetTo,"X",CRet[2],0x15C,1,0);
				SetCtrig1X(SVA1[5][1],SVA1[5][2],0x148,SVA1[5][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(SVA1[5][1],SVA1[5][2],0x160,SVA1[5][3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,Add*16777216,0xFF000000);
				CallLabelAlways2(SVA1[5][1],SVA1[5][2],SVA1[5][3],"X",CRet[2],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",CRet[2],0x158,0,SetTo,"X",CRet[2],0x15C,1,0);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",CRet[2],0x158,0,SetTo,"X",CRet[2],0x15C,1,0);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",CRet[2],0x158,0,SetTo,"X",FuncAlloc,0x15C,1,0);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}
	end

	CWhile(PlayerID,CVar("X",CRet[1],AtLeast,1),SetCVar("X",CRet[1],Subtract,1))
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(FuncAlloc);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]); 0x0 (A)
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrig1X(VA[1],VA[2],0x158,VA[3],SetTo,EPD(Dest)); EPD 0x158 (B)
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1); EPD 0x4
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF); EPD 0x148 
					SetMemory(0x6509B0,Add,(0x164-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,0,0,0x2);
					SetMemory(0x6509B0,Add,(0x180-0x164)/4);
					SetDeathsX(CurrentPlayer,SetTo,0,0,0xFF0000);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label();
				},
				actions = {
					SetDeathsX(CurrentPlayer,SetTo,0x2D0000,0,0xFF0000);
					SetMemory(0x6509B0,Add,(0x158-0x180)/4);
					SetDeaths(CurrentPlayer,SetTo,13,0);	-- SetCtrig1X(VA[1],VA[2],0x158,VA[3],SetTo,EPD(Dest)); EPD 0x158 (B)
					SetMemory(0x6509B0,Add,(0x164-0x158)/4);
					SetDeathsX(CurrentPlayer,SetTo,0x2,0,0x2);
					SetMemory(0x6509B0,Add,(0x148-0x164)/4);
					SetDeaths(CurrentPlayer,SetTo,RecoverMask,0);
					SetMemory(0x6509B0,Add,(0x0-0x148)/4);
					SetMemory(0x6509B0,Add,(0x970)/4);
					SetCtrig1X("X",FuncAlloc,0x15C,0,Add,0x970);
					SetCtrig1X("X",FuncAlloc,0x19C,0,Add,DestDistance);
				},
				flag = {Preserved}
			}
	CWhileEnd()
	FuncAlloc = FuncAlloc+1

	RecoverCp(PlayerID)
end

function CA__OverWrite(SVA32,Index,Null,Preserve)
	if SVA32[4] ~= "SVA32" or SVA32[6] == 0 then
		CA__OverWrite_InputData_Error()
	end
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	if type(Index) == "number" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCVar("X",CRet[1],SetTo,0);
					SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2);
					SetMemory(0x6509B0,SetTo,Index);
					SetCtrig1X(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,EPD(0x6509B0));
					SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
					SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,Add*16777216,0xFF000000);
					CallLabelAlways(CB[1][1],CB[1][2],CB[1][3]);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					NVar(CB[2],AtMost,Index+SVA32[6]-1); -- Strid Size < SVA32 Size + Index
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,1); -- Pass
				},
				flag = {Preserved}
			}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					NVar(CB[2],Exactly,Index+SVA32[6]); -- Strid Size == SVA32 Size + Index [SameSize]
				},
				actions = {
					SetCVar("X",CRet[1],SetTo,1); -- Null = 0
				},
				flag = {Preserved}
			}
	elseif Index[4] == "V" then
		if Index[5] == nil then
			Index[5] = 0
		end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCVar("X",CRet[1],SetTo,0);
					SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
					SetMemory(0x6509B0,SetTo,Index[5]);
					SetCtrig1X(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,EPD(0x6509B0));
					SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
					SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Index[1],Index[2],0x158,Index[3],SetTo,EPD(0x6509B0));
					SetCtrig1X(Index[1],Index[2],0x148,Index[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Index[1],Index[2],0x160,Index[3],SetTo,Add*16777216,0xFF000000);
					CallLabelAlways2(CB[1][1],CB[1][2],CB[1][3],Index[1],Index[2],Index[3]);
				},
				flag = {Preserved}
			}
		CTrigger(PlayerID,{TTNVar(CB[2],Below,Vi(Index[2],SVA32[6],Index[1],Index[3]))},{SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc+1,0x0,0,1)},{Preserved},FuncAlloc)
		CTrigger(PlayerID,{TNVar(CB[2],Exactly,Vi(Index[2],SVA32[6],Index[1],Index[3]))},{SetCVar("X",CRet[1],SetTo,1)},{Preserved})
		FuncAlloc = FuncAlloc+1
	end

	local SVA32Arr = {}
	local Size = SVA32[5]
	for i = 0, Size-1 do
		table.insert(SVA32Arr,{SVA32[1],SVA32[2],SVA32[3]+i})
	end

	if Preserve == 0 then
		CIfOnce(PlayerID,Condition,Action)
	end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabelAlwaysN(table.unpack(SVA32Arr));
				},
				flag = {Preserved}
			}
		
		local NullAct = {}
		if Null == 1 then
			NullAct = {SetDeaths(CurrentPlayer,SetTo,0,0)}
		end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(FuncAlloc);
					CVar("X",CRet[1],Exactly,0);
				},
				actions = {
					NullAct;
				},
				flag = {Preserved}
			}
		FuncAlloc = FuncAlloc+1

		RecoverCp(PlayerID)
	if Preserve == 0 then
		CIfEnd()
	end
end

function MakeiStrData(Letter,Fill) -- X for CA__ConvertLetter
	local Temp
	local A = {}
	for i = 1, #Letter do
		table.insert(A,string.byte(Letter,i))
	end
	if Fill == 1 then
		if #A == 1 then
			Temp = A[1]*16777216+0x0D0D0D
		elseif #A == 2 then
			if (A[1]>=0x20) or (A[1]>=0x9 and A[1]<=0xD) or (A[1]>=0x12 and A[1]<=0x13) then -- 1byte
				Temp = A[1]*65536+A[2]*16777216+0x0D0D
			else
				Temp = A[1]+A[2]*16777216+0x0D0D00
			end
		elseif #A == 3 then
			Temp = A[1]+A[2]*65536+A[3]*16777216+0x0D00
		end
	else
		if #A == 1 then
			Temp = A[1]*16777216
		elseif #A == 2 then
			if (A[1]>=0x20) or (A[1]>=0x9 and A[1]<=0xD) or (A[1]>=0x12 and A[1]<=0x13) then -- 1byte
				Temp = A[1]*65536+A[2]*16777216
			else
				Temp = A[1]+A[2]*16777216
			end
		elseif #A == 3 then
			Temp = A[1]+A[2]*65536+A[3]*16777216
		end
	end

	return Temp
end

function MakeiStrDiff(Start,End) -- B-A for CA__ConvertLetter
	local A = {}
	for i = 1, #Start do
		table.insert(A,string.byte(Start,i))
	end
	local B = {}
	for i = 1, #End do
		table.insert(B,string.byte(End,i))
	end
	local X, Y 
	if #A == 1 then
		X = A[1]*16777216 + 0x0D0000
	elseif #A == 2 then
		X = A[1]*65536 + A[2]*16777216
	end
	if #B == 1 then
		Y = B[1]*16777216 + 0x0D0000
	elseif #B == 2 then
		Y = B[1]*65536 + B[2]*16777216
	end
	local ret = Y-X
	return ret
end

function MakeiStrDataX(Letter,Fill) -- X for CA__ConvertLetter
	local Temp
	local A = cp949_to_utf8(Letter)
	table.remove(A,#A)
	if Fill == 1 then
		if #A == 1 then -- 1
			Temp = A[1]*16777216+0x0D0D0D
		elseif #A == 2 then -- 1+1
			Temp = A[1]+A[2]*16777216+0x0D0D00
		elseif #A == 3 then -- 3
			Temp = A[1]*256+A[2]*65536+A[3]*16777216+0x0D
		elseif #A == 4 then -- 1+3
			Temp = A[1]+A[2]*256+A[3]*65536+A[4]*16777216
		end
	else
		if #A == 1 then -- 1
			Temp = A[1]*16777216
		elseif #A == 2 then -- 1+1
			Temp = A[1]+A[2]*16777216
		elseif #A == 3 then -- 3
			Temp = A[1]*256+A[2]*65536+A[3]*16777216
		elseif #A == 4 then -- 1+3
			Temp = A[1]+A[2]*256+A[3]*65536+A[4]*16777216
		end
	end

	return Temp
end

function MakeiStrDiffX(Start,End) -- B-A for CA__ConvertLetter
	local A = cp949_to_utf8(Start)
	local B = cp949_to_utf8(End)
	table.remove(A,#A)
	table.remove(B,#B)
	local X, Y 
	if #A == 1 then
		X = A[1]*16777216 + 0x0D0D00
	elseif #A == 3 then
		X = A[1]*256 + A[2]*65536 + A[3]*16777216
	end
	if #B == 1 then
		Y = B[1]*16777216 + 0x0D0D00
	elseif #B == 3 then
		Y = B[1]*256 + B[2]*65536 + B[3]*16777216
	end
	local ret = Y-X
	return ret
end

function MakeChatOffset(Line,Offset)
	return 0x640B60+Line*218+Offset
end

function f_ChatOffset(PlayerID,Line,Offset,Output)
	FCHATOCheck = 1
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << X 

	if type(Line) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Line);
			},
			flag = {Preserved}
		}
	else
		if Line[4] == "VA" then
			local TempRet = {"X",CRet[1],0,"V"}
			MovX(PlayerID,TempRet,Line)
			Line = TempRet
		elseif Line[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Line[1],Line[2],0x158,Line[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Line[1],Line[2],0x148,Line[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Line[1],Line[2],0x160,Line[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Line[1],Line[2],Line[3]);
				},
				flag = {Preserved}
			}
		end
	end

	if type(Offset) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Offset);
			},
			flag = {Preserved}
		}
	else
		if Offset[4] == "VA" then
			local TempRet = {"X",CRet[2],0,"V"}
			MovX(PlayerID,TempRet,Offset)
			Offset = TempRet
		elseif Offset[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X",CRet[2],0x15C,1,0);
					SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Offset[1],Offset[2],Offset[3]);
				},
				flag = {Preserved}
			}
		end
	end

-- Call f_ChatOffset
	if FCHATOCall == 0 then
		Need_Include_DataTransfer()
	end
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FCHATOCall,0x0,0,0);
				SetCtrigX("X",FCHATOCall,0x4,4,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}

	-- Output Data CRet[2] = Output
	if Output ~= nil then
		if type(Output) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",CRet[3],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
						},
						flag = {Preserved}
					}

		elseif Output[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[3],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
						},
						flag = {Preserved}
					}
		else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[3],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
						},
						flag = {Preserved}
					}
		end
	end
end

function Display(Line,Status)
	if Status == "On" then
		if Line%2 == 0 then
			return MemoryX(0x640B60+Line*218,AtLeast,1,0xFF)
		else
			return MemoryX(0x640B60+Line*218-2,AtLeast,65536,0xFF0000)
		end  
	else
		if Line%2 == 0 then
			return MemoryX(0x640B60+Line*218,Exactly,0,0xFF)
		else
			return MemoryX(0x640B60+Line*218-2,Exactly,0,0xFF0000)
		end 
	end
end

function DisplayX(Line,Index,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	if Index >= 54 then
		Index = 53
	end
	if Line%2 == 0 then
		return MemoryX(0x640B60+Line*218+4*Index,Exactly,Value,Mask)
	else
		return MemoryX(0x640B62+Line*218+4*Index,Exactly,Value,Mask)
	end  
end

function TTDisplay(Line,Status)
	FDISPCheck = 1
	if FDISPCall1 == 0 then
		Need_Include_DataTransfer()
	end
	local Mode = 23
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
				
	local TTDisplay = CVar("X",CRet[2],Exactly,1)

	if Line[4] == "V" then
		if Line[5] == nil then
			Line[5] = 0
		end
		local X = {
				SetCtrigX("X","X",0x4,0,SetTo,Line[1],Line[2],0x0,0,Line[3]);
				SetCtrigX(Line[1],Line[2],0x4,Line[3],SetTo,"X",FDISPCall1,0x0,0,0);
				SetCtrigX("X",FDISPCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				SetCtrig1X(Line[1],Line[2],0x148,Line[3],SetTo,0xFFFFFFFF),
				SetCtrig1X(Line[1],Line[2],0x160,Line[3],SetTo,Add*16777216,0xFF000000),
				SetCtrigX(Line[1],Line[2],0x158,Line[3],SetTo,"X",CRet[1],0x15C,1,0),
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Line[5])}
		table.insert(Y,X)
	end

	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,TTDisplay)
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	if Status == "On" then
		local TTDisplay = CDeaths("X",Exactly,0,FCode)
		return TTDisplay
	else
		local TTDisplay = CDeaths("X",Exactly,1,FCode)
		return TTDisplay
	end
end

function TTDisplayX(Line,Index,Type,Value,Mask)
	FDISPXCheck = 1
	if FDISPXCall1 == 0 then
		Need_Include_DataTransfer()
	end
	local TTDisplayX
	if Type == Exactly then
		TTDisplayX = CVar("X",CRet[5],Exactly,1)
	elseif Type == NotSame or Type == "!=" then
		TTDisplayX = CVar("X",CRet[5],Exactly,0)
	else
		TTDisplayX_InputData_Error()
	end
	local Mode = 24
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	local Z = 0				
	local Next = {}
	local X = {}
	if type(Line) == "number" then
		table.insert(X,{SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Line)})
	elseif Line[4] == "V" then
		if Line[5] == nil then
			Line[5] = 0
		end
		table.insert(X,{
				SetCtrig1X(Line[1],Line[2],0x148,Line[3],SetTo,0xFFFFFFFF),
				SetCtrig1X(Line[1],Line[2],0x160,Line[3],SetTo,Add*16777216,0xFF000000),
				SetCtrigX(Line[1],Line[2],0x158,Line[3],SetTo,"X",CRet[1],0x15C,1,0),
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Line[5])})
		table.insert(Next,Line)
		Z = Z + 1
	end
	if type(Index) == "number" then
		table.insert(X,{SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Index)})
	elseif Index[4] == "V" then
		if Index[5] == nil then
			Index[5] = 0
		end
		table.insert(X,{
				SetCtrig1X(Index[1],Index[2],0x148,Index[3],SetTo,0xFFFFFFFF),
				SetCtrig1X(Index[1],Index[2],0x160,Index[3],SetTo,Add*16777216,0xFF000000),
				SetCtrigX(Index[1],Index[2],0x158,Index[3],SetTo,"X",CRet[2],0x15C,1,0),
				SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Index[5])})
		table.insert(Next,Index)
		Z = Z + 1
	end
	if type(Value) == "number" then
		table.insert(X,{SetCtrig1X("X",CRet[3],0x15C,0,SetTo,Value)})
	elseif Value[4] == "V" then
		if Value[5] == nil then
			Value[5] = 0
		end
		table.insert(X,{
				SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF),
				SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000),
				SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X",CRet[3],0x15C,1,0),
				SetCtrig1X("X",CRet[3],0x15C,0,SetTo,Value[5])})
		table.insert(Next,Value)
		Z = Z + 1
	end
	if type(Mask) == "number" then
		table.insert(X,{SetCtrig1X("X",CRet[4],0x15C,0,SetTo,Mask)})
	elseif Mask[4] == "V" then
		if Mask[5] == nil then
			Mask[5] = 0
		end
		table.insert(X,{
				SetCtrig1X(Mask[1],Mask[2],0x148,Mask[3],SetTo,0xFFFFFFFF),
				SetCtrig1X(Mask[1],Mask[2],0x160,Mask[3],SetTo,Add*16777216,0xFF000000),
				SetCtrigX(Mask[1],Mask[2],0x158,Mask[3],SetTo,"X",CRet[4],0x15C,1,0),
				SetCtrig1X("X",CRet[4],0x15C,0,SetTo,Mask[5])})
		table.insert(Next,Mask)
		Z = Z + 1
	end

	if Z == 1 then
		table.insert(X,{SetCtrigX("X","X",0x4,0,SetTo,Next[1][1],Next[1][2],0x0,0,Next[1][3]),
				SetCtrigX(Next[1][1],Next[1][2],0x4,Next[1][3],SetTo,"X",FDISPXCall1,0x0,0,0),
				SetCtrigX("X",FDISPXCall2,0x4,0,SetTo,"X","X",0x0,0,1)})
	elseif Z == 2 then
			table.insert(X,{SetCtrigX("X","X",0x4,0,SetTo,Next[1][1],Next[1][2],0x0,0,Next[1][3]),
				SetCtrigX(Next[1][1],Next[1][2],0x4,Next[1][3],SetTo,Next[2][1],Next[2][2],0x0,0,Next[2][3]),
				SetCtrigX(Next[2][1],Next[2][2],0x4,Next[2][3],SetTo,"X",FDISPXCall1,0x0,0,0),
				SetCtrigX("X",FDISPXCall2,0x4,0,SetTo,"X","X",0x0,0,1)})
	elseif Z == 3 then
		table.insert(X,{SetCtrigX("X","X",0x4,0,SetTo,Next[1][1],Next[1][2],0x0,0,Next[1][3]),
				SetCtrigX(Next[1][1],Next[1][2],0x4,Next[1][3],SetTo,Next[2][1],Next[2][2],0x0,0,Next[2][3]),
				SetCtrigX(Next[2][1],Next[2][2],0x4,Next[2][3],SetTo,Next[3][1],Next[3][2],0x0,0,Next[3][3]),
				SetCtrigX(Next[3][1],Next[3][2],0x4,Next[3][3],SetTo,"X",FDISPXCall1,0x0,0,0),
				SetCtrigX("X",FDISPXCall2,0x4,0,SetTo,"X","X",0x0,0,1)})
	elseif Z == 4 then
		table.insert(X,{SetCtrigX("X","X",0x4,0,SetTo,Next[1][1],Next[1][2],0x0,0,Next[1][3]),
				SetCtrigX(Next[1][1],Next[1][2],0x4,Next[1][3],SetTo,Next[2][1],Next[2][2],0x0,0,Next[2][3]),
				SetCtrigX(Next[2][1],Next[2][2],0x4,Next[2][3],SetTo,Next[3][1],Next[3][2],0x0,0,Next[3][3]),
				SetCtrigX(Next[3][1],Next[3][2],0x4,Next[3][3],SetTo,Next[4][1],Next[4][2],0x0,0,Next[4][3]),
				SetCtrigX(Next[4][1],Next[4][2],0x4,Next[4][3],SetTo,"X",FDISPXCall1,0x0,0,0),
				SetCtrigX("X",FDISPXCall2,0x4,0,SetTo,"X","X",0x0,0,1)})
	else
		TTDisplayX_InputData_Error()
	end
	table.insert(Y,X)

	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,TTDisplayX)
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTDisplayX = CDeaths("X",Exactly,1,FCode)
	return TTDisplayX
end

function f_Strlen(PlayerID,Line,Output,EPDXOutput)
	FSTRLCheck = 1
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << X 

	if type(Line) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Line);
			},
			flag = {Preserved}
		}
	else
		if Line[4] == "VA" then
			local TempRet = {"X",CRet[1],0,"V"}
			MovX(PlayerID,TempRet,Line)
			Line = TempRet
		elseif Line[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Line[1],Line[2],0x158,Line[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Line[1],Line[2],0x148,Line[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Line[1],Line[2],0x160,Line[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Line[1],Line[2],Line[3]);
				},
				flag = {Preserved}
			}
		end
	end

-- Call f_strlen
	if FSTRLCall1 == 0 then
		Need_Include_DataTransfer()
	end
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FSTRLCall1,0x0,0,0);
				SetCtrigX("X",FSTRLCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				SetCVar("X",CRet[4],0,SetTo,0);
			},
			flag = {Preserved}
		}

	-- Output Data CRet[2] = Output
	if Output ~= nil then
		if type(Output) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}

		elseif Output[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
		else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
		end
	end
	if EPDXOutput ~= nil then
		if type(EPDXOutput) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",CRet[3],0x158,0,SetTo,EPD(EPDXOutput));
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
						},
						flag = {Preserved}
					}
	
		elseif EPDXOutput[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[3],0x158,0,SetTo,EPDXOutput[1],EPDXOutput[2],0x15C,1,EPDXOutput[3]);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
						},
						flag = {Preserved}
					}
		else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[3],0x158,0,SetTo,EPDXOutput[1],EPDXOutput[2],EPDXOutput[3],1,EPDXOutput[4]);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
						},
						flag = {Preserved}
					}
		end
	end
	RecoverCp(PlayerID)
end
--[[
function f_Strcat(PlayerID,Line,Output)
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << X 

	if type(Line) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Line);
			},
			flag = {Preserved}
		}
	else
		if Line[4] == "VA" then
			local TempRet = {"X",CRet[1],0,"V"}
			MovX(PlayerID,TempRet,Line)
			Line = TempRet
		elseif Line[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Line[1],Line[2],0x158,Line[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Line[1],Line[2],0x148,Line[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Line[1],Line[2],0x160,Line[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Line[1],Line[2],Line[3]);
				},
				flag = {Preserved}
			}
		end
	end

-- Call f_strcat
	if FSTRLCall1 == 0 then
		Need_Include_DataTransfer()
	end
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FSTRLCall1,0x0,0,0);
				SetCtrigX("X",FSTRLCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				SetCVar("X",CRet[4],0,SetTo,1);
			},
			flag = {Preserved}
		}

	-- Output Data CRet[2] = Output
	if Output ~= nil then
		if type(Output) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}

		elseif Output[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
		else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
		end
	end
	RecoverCp(PlayerID)
end
]]--
function CA__ConvertColor(SVA1,ConvertData,MaskData,Start,End) -- <A,B> : A->B
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	if MaskData == nil then
		MaskData = {}
	end
	if Start == nil then
		Start = 0
	end
	if End == nil then
		End = SVA1[6]-1
	end

	if type(Start) == "number" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0x6509B0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+Start);
				},
				flag = {Preserved}
			}
	elseif Start[4] == "V" then -- Start604
		if Start[5] == nil then
			Start[5] = 0
		end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0x6509B0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+Start[5]);
					SetCtrig1X(Start[1],Start[2],0x158,Start[3],SetTo,EPD(0x6509B0));
					SetCtrig1X(Start[1],Start[2],0x148,Start[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Start[1],Start[2],0x160,Start[3],SetTo,Add*16777216,0xFF000000);
					CallLabelAlways(Start[1],Start[2],Start[3]);
				},
				flag = {Preserved}
			}
	end
	if type(End) == "number" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",IndexAlloc,0x24,0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+End);
				},
				flag = {Preserved}
			}
	elseif End[4] == "V" then -- End604
		if End[5] == nil then
			End[5] = 0
		end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",IndexAlloc,0x24,0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+End[5]);
					SetCtrigX(End[1],End[2],0x158,End[3],SetTo,"X",IndexAlloc,0x24,1,0);
					SetCtrig1X(End[1],End[2],0x148,End[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(End[1],End[2],0x160,End[3],SetTo,Add*16777216,0xFF000000);
					CallLabelAlways(End[1],End[2],End[3]);
				},
				flag = {Preserved}
			}
	end
	local ColorCode = {} 
	local SetColorCode = {}
	local SectorCond = {}
	local Data = {}
	for k, v in pairs(ConvertData) do
			local MaskArr = {}
			if MaskData[k] ~= nil then
				MaskArr = MaskData[k]
			end
			local Mask1 = 0xFF
			local Mask2 = 0xFF
			if MaskArr[1] ~= nil then Mask1 = MaskArr[1] end
			if MaskArr[2] ~= nil then Mask2 = MaskArr[2] end
			if type(v[1]) == "number" then
				table.insert(ColorCode,bit32.band(v[1], Mask1))
			elseif v[1][4] == "V" then
				table.insert(ColorCode,0)
				if v[1][5] == nil then
					v[1][5] = 0
				end
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",FuncAlloc,0x24,0,SetTo,v[1][5]);
							SetCtrigX(v[1][1],v[1][2],0x158,v[1][3],SetTo,"X",FuncAlloc,0x24,1,0);
							SetCtrig1X(v[1][1],v[1][2],0x148,v[1][3],SetTo,Mask1);
							SetCtrig1X(v[1][1],v[1][2],0x160,v[1][3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways(v[1][1],v[1][2],v[1][3]);
						},
						flag = {Preserved}
					}
			end
			if type(v[2]) == "number" then
				table.insert(SetColorCode,bit32.band(v[2],Mask2))
			elseif v[2][4] == "V" then
				table.insert(SetColorCode,0)
				if v[2][5] == nil then
					v[2][5] = 0
				end
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",FuncAlloc,0x15C,0,SetTo,v[2][5]);
							SetCtrigX(v[2][1],v[2][2],0x158,v[2][3],SetTo,"X",FuncAlloc,0x15C,1,0);
							SetCtrig1X(v[2][1],v[2][2],0x148,v[2][3],SetTo,Mask2);
							SetCtrig1X(v[2][1],v[2][2],0x160,v[2][3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways(v[2][1],v[2][2],v[2][3]);
						},
						flag = {Preserved}
					}
				
			end
			if type(v[3]) == "table" and #v[3] == 2 then
				if type(v[3][1]) == "number" then
					table.insert(SectorCond,DeathsX(CurrentPlayer,Exactly,bit32.band(v[3][1],v[3][2]),0,v[3][2]))
				elseif v[3][1][4] == "V" then
					table.insert(SectorCond,DeathsX(CurrentPlayer,Exactly,0,0,v[3][2]))
					if v[3][1][5] == nil then
						v[3][1][5] = 0
					end
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",FuncAlloc,0x38,0,SetTo,v[3][1][5]);
								SetCtrigX(v[3][1][1],v[3][1][2],0x158,v[3][1][3],SetTo,"X",FuncAlloc,0x38,1,0);
								SetCtrig1X(v[3][1][1],v[3][1][2],0x148,v[3][1][3],SetTo,v[3][2]);
								SetCtrig1X(v[3][1][1],v[3][1][2],0x160,v[3][1][3],SetTo,Add*16777216,0xFF000000);
								CallLabelAlways(v[3][1][1],v[3][1][2],v[3][1][3]);
							},
							flag = {Preserved}
						}
				else 
					Temp = bit32.band(MakeiStrData(v[3][1],1),v[3][2])
					table.insert(SectorCond,DeathsX(CurrentPlayer,Exactly,Temp,0,v[3][2]))
				end
			else
				table.insert(SectorCond,{})
			end
		table.insert(Data,FuncAlloc)
		FuncAlloc = FuncAlloc+1
	end

	CWhile(PlayerID,{FMemory(0x6509B0,AtMost,0)})
		for k, v in pairs(ConvertData) do
			local MaskArr = {}
			if MaskData[k] ~= nil then
				MaskArr = MaskData[k]
			end
			local Mask1 = 0xFF
			local Mask2 = 0xFF
			local Mask3 = SetTo
			if MaskArr[1] ~= nil then Mask1 = MaskArr[1] end
			if MaskArr[2] ~= nil then Mask2 = MaskArr[2] end
			if MaskArr[3] ~= nil then Mask3 = MaskArr[3] end
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(Data[k]);
					DeathsX(CurrentPlayer,Exactly,ColorCode[k],0,Mask1);
					SectorCond[k],
				},
				actions = {
					SetDeathsX(CurrentPlayer,Mask3,SetColorCode[k],0,Mask2); -- Change Color

					SetCtrigX("X","X",0x4,0,SetTo,"X",IndexAlloc-1,0,0,0);
					SetCtrigX("X",IndexAlloc-1,0x198,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",IndexAlloc-1,0x19C,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
		end
	CWhileEnd({FSetMemory(0x6509B0,Add,604),SetDeaths(0,SetTo,0,0)}) -- RecoverNext
	RecoverCp(PlayerID)
end

function CA__ConvertLetter(SVA1,ConvertData,MaskData,Start,End,utf8flag) -- <<A,B>,<C,D>> : A~B->+D-C
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	if MaskData == nil then
		MaskData = {}
	end
	if Start == nil then
		Start = 0
	end
	if End == nil then
		End = SVA1[6]-1
	end

	if type(Start) == "number" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0x6509B0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+Start);
				},
				flag = {Preserved}
			}
	elseif Start[4] == "V" then -- Start604
		if Start[5] == nil then
			Start[5] = 0
		end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig2X(0x6509B0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+Start[5]);
					SetCtrig1X(Start[1],Start[2],0x158,Start[3],SetTo,EPD(0x6509B0));
					SetCtrig1X(Start[1],Start[2],0x148,Start[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Start[1],Start[2],0x160,Start[3],SetTo,Add*16777216,0xFF000000);
					CallLabelAlways(Start[1],Start[2],Start[3]);
				},
				flag = {Preserved}
			}
	end
	if type(End) == "number" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",IndexAlloc,0x24,0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+End);
				},
				flag = {Preserved}
			}
	elseif End[4] == "V" then -- End604
		if End[5] == nil then
			End[5] = 0
		end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",IndexAlloc,0x24,0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+End[5]);
					SetCtrigX(End[1],End[2],0x158,End[3],SetTo,"X",IndexAlloc,0x24,1,0);
					SetCtrig1X(End[1],End[2],0x148,End[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(End[1],End[2],0x160,End[3],SetTo,Add*16777216,0xFF000000);
					CallLabelAlways(End[1],End[2],End[3]);
				},
				flag = {Preserved}
			}
	end
	local ColorCode1 = {}
	local ColorCode2 = {} 
	local ColorCode3 = {}
	local SetColorCode = {}
	local ColorType = {}
	local SectorCond = {}
	local Data = {}
	local Temp
	local CondType
	for k, v in pairs(ConvertData) do
			local MaskArr = {}
			if MaskData[k] ~= nil then
				MaskArr = MaskData[k]
			end
			local Mask1 
			local Mask2 
			if utf8flag == 1 then
				Mask1 = 0xFFFFFF00
				Mask2 = 0xFFFFFF00
			else
				Mask1 = 0xFFFF0000
				Mask2 = 0xFFFF0000
			end
			if MaskArr[1] ~= nil then Mask1 = MaskArr[1] end
			if MaskArr[2] ~= nil then Mask2 = MaskArr[2] end
			if type(v[1]) == "table" and #v[1] == 2 then
				table.insert(ColorType,0) CondType = 0x4C
				table.insert(ColorCode3,0)
				if type(v[1][1]) == "number" then
					Temp = bit32.band(v[1][1], Mask1)
					table.insert(ColorCode1,Temp)
				elseif v[1][1][4] == "V" then
					table.insert(ColorCode1,0)
					if v[1][1][5] == nil then
						v[1][1][5] = 0
					end
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",FuncAlloc,0x24,0,SetTo,v[1][1][5]);
								SetCtrigX(v[1][1][1],v[1][1][2],0x158,v[1][1][3],SetTo,"X",FuncAlloc,0x24,1,0);
								SetCtrig1X(v[1][1][1],v[1][1][2],0x148,v[1][1][3],SetTo,Mask1);
								SetCtrig1X(v[1][1][1],v[1][1][2],0x160,v[1][1][3],SetTo,Add*16777216,0xFF000000);
								CallLabelAlways(v[1][1][1],v[1][1][2],v[1][1][3]);
							},
							flag = {Preserved}
						}
				else
					if utf8flag == 1 then
						Temp = bit32.band(MakeiStrDataX(v[1][1],1), Mask1)
					else
						Temp = bit32.band(MakeiStrData(v[1][1],1), Mask1)
					end
					table.insert(ColorCode1,Temp)
				end
				if type(v[1][2]) == "number" then
					Temp = bit32.band(v[1][2], Mask1)
					table.insert(ColorCode2,Temp)
				elseif v[1][2][4] == "V" then
					table.insert(ColorCode2,0)
					if v[1][2][5] == nil then
						v[1][2][5] = 0
					end
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",FuncAlloc,0x38,0,SetTo,v[1][2][5]);
								SetCtrigX(v[1][2][1],v[1][2][2],0x158,v[1][2][3],SetTo,"X",FuncAlloc,0x38,1,0);
								SetCtrig1X(v[1][2][1],v[1][2][2],0x148,v[1][2][3],SetTo,Mask1);
								SetCtrig1X(v[1][2][1],v[1][2][2],0x160,v[1][2][3],SetTo,Add*16777216,0xFF000000);
								CallLabelAlways(v[1][2][1],v[1][2][2],v[1][2][3]);
							},
							flag = {Preserved}
						}
				else
					if utf8flag == 1 then
						Temp = bit32.band(MakeiStrDataX(v[1][2],1), Mask1)
					else
						Temp = bit32.band(MakeiStrData(v[1][2],1), Mask1)
					end
					table.insert(ColorCode2,Temp)
				end
			else
				table.insert(ColorType,1) CondType = 0x38
				table.insert(ColorCode1,0)
				table.insert(ColorCode2,0)
				if type(v[1]) == "number" then
					table.insert(ColorCode3,bit32.band(v[1], Mask1))
				elseif v[1][4] == "V" then
					table.insert(ColorCode3,0)
					if v[1][5] == nil then
						v[1][5] = 0
					end
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",FuncAlloc,0x24,0,SetTo,v[1][5]);
								SetCtrigX(v[1][1],v[1][2],0x158,v[1][3],SetTo,"X",FuncAlloc,0x24,1,0);
								SetCtrig1X(v[1][1],v[1][2],0x148,v[1][3],SetTo,Mask1);
								SetCtrig1X(v[1][1],v[1][2],0x160,v[1][3],SetTo,Add*16777216,0xFF000000);
								CallLabelAlways(v[1][1],v[1][2],v[1][3]);
							},
							flag = {Preserved}
						}
				else
					if utf8flag == 1 then
						Temp = bit32.band(MakeiStrDataX(v[1],1), Mask1)
					else
						Temp = bit32.band(MakeiStrData(v[1],1), Mask1)
					end
					table.insert(ColorCode3,Temp)
				end
			end
			if type(v[2]) == "number" then
				table.insert(SetColorCode,bit32.band(v[2], Mask2))
			elseif v[2][4] == "V" then
				table.insert(SetColorCode,0)
				if v[2][5] == nil then
					v[2][5] = 0
				end
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",FuncAlloc,0x15C,0,SetTo,v[2][5]);
							SetCtrigX(v[2][1],v[2][2],0x158,v[2][3],SetTo,"X",FuncAlloc,0x15C,1,0);
							SetCtrig1X(v[2][1],v[2][2],0x148,v[2][3],SetTo,Mask2);
							SetCtrig1X(v[2][1],v[2][2],0x160,v[2][3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways(v[2][1],v[2][2],v[2][3]);
						},
						flag = {Preserved}
					}
			else -- {C,D}
				if CondType == 0x4C then
					if utf8flag == 1 then
						Temp = bit32.band(MakeiStrDiffX(v[2][1],v[2][2]), Mask2)
					else
						Temp = bit32.band(MakeiStrDiff(v[2][1],v[2][2]), Mask2)
					end
					table.insert(SetColorCode,Temp)
				else
					if utf8flag == 1 then
						Temp = bit32.band(MakeiStrDataX(v[2],1), Mask2)
					else
						Temp = bit32.band(MakeiStrData(v[2],1), Mask2)
					end
					table.insert(SetColorCode,Temp)
				end
			end
			if type(v[3]) == "table" and #v[3] == 2 then
				if type(v[3][1]) == "number" then
					table.insert(SectorCond,DeathsX(CurrentPlayer,Exactly,bit32.band(v[3][1],v[3][2]),0,v[3][2]))
				elseif v[3][1][4] == "V" then
					table.insert(SectorCond,DeathsX(CurrentPlayer,Exactly,0,0,v[3][2]))
					if v[3][1][5] == nil then
						v[3][1][5] = 0
					end
					Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",FuncAlloc,CondType,0,SetTo,v[3][1][5]);
								SetCtrigX(v[3][1][1],v[3][1][2],0x158,v[3][1][3],SetTo,"X",FuncAlloc,CondType,1,0);
								SetCtrig1X(v[3][1][1],v[3][1][2],0x148,v[3][1][3],SetTo,v[3][2]);
								SetCtrig1X(v[3][1][1],v[3][1][2],0x160,v[3][1][3],SetTo,Add*16777216,0xFF000000);
								CallLabelAlways(v[3][1][1],v[3][1][2],v[3][1][3]);
							},
							flag = {Preserved}
						}
				else 
					if utf8flag == 1 then
						Temp = bit32.band(MakeiStrDataX(v[3][1],1),v[3][2])
					else
						Temp = bit32.band(MakeiStrData(v[3][1],1),v[3][2])
					end
					table.insert(SectorCond,DeathsX(CurrentPlayer,Exactly,Temp,0,v[3][2]))
				end
			elseif type(v[3]) == "number" then
				
				if utf8flag == 1 then
					Temp = bit32.band(MakeiStrDataX(v[1][1],1), v[3])
				else
					Temp = bit32.band(MakeiStrData(v[1][1],1), v[3])
				end
				table.insert(SectorCond,DeathsX(CurrentPlayer,Exactly,Temp,0,v[3]))
			else
				table.insert(SectorCond,{})
			end
		table.insert(Data,FuncAlloc)
		FuncAlloc = FuncAlloc+1
	end

	CWhile(PlayerID,{FMemory(0x6509B0,AtMost,0)})
		for k, v in pairs(ConvertData) do
			local MaskArr = {}
			if MaskData[k] ~= nil then
				MaskArr = MaskData[k]
			end
			local Mask1 
			local Mask2 
			if utf8flag == 1 then
				Mask1 = 0xFFFFFF00
				Mask2 = 0xFFFFFF00
			else
				Mask1 = 0xFFFF0000
				Mask2 = 0xFFFF0000
			end
			if MaskArr[1] ~= nil then Mask1 = MaskArr[1] end
			if MaskArr[2] ~= nil then Mask2 = MaskArr[2] end
			if ColorType[k] == 0 then
				local Mask3 = Add
				if MaskArr[3] ~= nil then Mask3 = MaskArr[3] end
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(Data[k]);
						DeathsX(CurrentPlayer,AtLeast,ColorCode1[k],0,Mask1);
						DeathsX(CurrentPlayer,AtMost,ColorCode2[k],0,Mask1);
						SectorCond[k],
					},
					actions = {
						SetDeathsX(CurrentPlayer,Mask3,SetColorCode[k],0,Mask2); -- Change Color

						SetCtrigX("X","X",0x4,0,SetTo,"X",IndexAlloc-1,0,0,0);
						SetCtrigX("X",IndexAlloc-1,0x198,0,SetTo,"X","X",0x4,1,0);
						SetCtrigX("X",IndexAlloc-1,0x19C,0,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
			else
				local Mask3 = SetTo
				if MaskArr[3] ~= nil then Mask3 = MaskArr[3] end
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(Data[k]);
						DeathsX(CurrentPlayer,Exactly,ColorCode3[k],0,Mask1);
						SectorCond[k],
					},
					actions = {
						SetDeathsX(CurrentPlayer,Mask3,SetColorCode[k],0,Mask2); -- Change Color

						SetCtrigX("X","X",0x4,0,SetTo,"X",IndexAlloc-1,0,0,0);
						SetCtrigX("X",IndexAlloc-1,0x198,0,SetTo,"X","X",0x4,1,0);
						SetCtrigX("X",IndexAlloc-1,0x19C,0,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
			end
		end
	CWhileEnd({FSetMemory(0x6509B0,Add,604),SetDeaths(0,SetTo,0,0)}) -- RecoverNext
	RecoverCp(PlayerID)
end

function CA__ItoCustom(SVA1,Input,Output,Mask,Base,Length,Init,Sign,ColorArr,IndexArr,DataArr,ClearArr,utf8flag)
	-- SVA1 : 상수 only / Input : 변환할 V / Output : 채워진 Max 자릿수 반환 V
	-- Base : k진법 (2~2^32)
	-- Zero : 0 표시 방법 선택 (0 = 그대로 표시 / " " = 대신 표시할 문자)
	-- Sign : 부호 추가 / 부호없음 (0) / 부호추가 {+기호,-기호} - String 지원
	-- ColorArr : 컬러코드 추가 / 0x01 ~ 0x1F (기본 0x0D) / 맨 앞부터 적용 (오직 변수 숫자만) - 0x0 입력시 적용X & DataArr가 있다면 덮어씌워짐
	-- IndexArr : 삽입위치 결정 / 0 ~ SVA1[6]-1 (기본 0부터 Size만큼) 
	-- DataArr : 변환 문자 설정 / 0 ~ SVA1[6]-1 / {A,B} -> A = n : Exactly, A = {a,b} : A AtLeast a, A AtMost b 
	-- / B = n : SetTo n, B = {n} : Add n, B = " " : SetTo " ", B = {" "} : SetTo " "(나머지) + Add " "(Last) 
	-- Resetflag : 1 체크시 삽입 Start ~ End 사이에 존재하는 모든 비삽입 위치를 Clear함 (Max 자릿수만큼)
	if Mask == nil then
		if utf8flag == 1 then
			Mask = 0xFFFFFFFF
		else
			Mask = 0xFFFF00FF
		end
	end

	if Length == nil then
		Length = 1
	end

	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	if Input[5] == nil then
		Input[5] = 0
	end
	Trigger {
		players = {PlayerID},
		conditions = {
			Label();
		},
		actions = {
			SetCtrig1X("X",CRet[6],0x15C,0,SetTo,0); -- Bitflag
			SetCtrig1X("X",CRet[4],0x15C,0,SetTo,0);
			SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
			SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Input[5]);
			SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
			SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
			SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,Add*16777216,0xFF000000);
			CallLabelAlways(Input[1],Input[2],Input[3]);
		},
		flag = {Preserved}
	}

	local Max
	if type(Base) == "table" then
		Max = math.floor(Base[2])-1
		Base = Base[1]
	end
	if Base >= 2 then
		Base = math.floor(Base)
	else
		CA__ItoCustom_InputData_Error()
	end

	local n = math.ceil(32*math.log(2)/math.log(Base))-1
	local m = math.floor(math.log(Base)/math.log(2))
	
	if Max ~= nil and Max <= n then
		n = Max
	end

	if type(IndexArr) ~= "table" then
		IndexArr = {}
	end

	if DataArr == nil then
		if Base > 10 then
			DataArr = {{{0,9},{"0",0x1000000}},{{10,15},{"\x37",0x1000000}}} -- 0x37 + 0xA = 0x41 ("A")
		else
			DataArr = {{{0,9},{"0",0x1000000}}}
		end
	end

	local Arr1, Size1 = 0
	local Arr2, Size2 = 0
	local Arr3, Size3 = 0
	local SizeM = 0
	if type(Sign) == "string" then
		if utf8flag == 1 then
			Arr3, Size3 = str_to_iutf8(Sign,1)
		else
			Arr3, Size3 = str_to_icp949(Sign,1)
		end
		
		SizeM = Size3

		for i = 1, #IndexArr do
			IndexArr[i] = IndexArr[i]+SizeM
		end

		local Box5 = {}
		for i = 1, SizeM do
			table.insert(Box5,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+i-1,SetTo,0x0D0D0D0D,Mask))
		end
		DoActionsX(PlayerID,Box5)
		
		if Size3 == 1 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CVar("X",CRet[1],Exactly,0);
					},
					actions = {
						SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5],SetTo,Arr3[1]+Arr3[2]*256+Arr3[3]*65536+Arr3[4]*16777216,Mask);
					},
					flag = {Preserved}
				}
		else
				local Box4 = {}
				local p = 1
				local q = 0
				while true do
					table.insert(Box4,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+q,SetTo,Arr3[p]+Arr3[p+1]*256+Arr3[p+2]*65536+Arr3[p+3]*16777216,Mask))
					p = p+4
					q = q+1
					if p > #Arr3 then break end
				end
				Trigger2X(PlayerID,{CVar("X",CRet[1],Exactly,0)},Box4,{Preserved})
		end
	elseif type(Sign) == "table" then
		if Sign[1] == nil or Sign[1] == 0 then
			Sign[1] = "\x0D"
		end
		if Sign[2] == nil or Sign[2] == 0 then
			Sign[2] = "\x0D"
		end
		if Sign[3] == nil or Sign[3] == 0 then
			Sign[3] = "\x0D"
		end

		if type(Sign[1]) == "string" then
			if utf8flag == 1 then
				Arr1, Size1 = str_to_iutf8(Sign[1],1) -- +
			else
				Arr1, Size1 = str_to_icp949(Sign[1],1) -- +
			end
		end
		if type(Sign[2]) == "string" then
			if utf8flag == 1 then
				Arr2, Size2 = str_to_iutf8(Sign[2],1) -- -
			else
				Arr2, Size2 = str_to_icp949(Sign[2],1) -- -
			end
		end
		if type(Sign[3]) == "string" then
			if utf8flag == 1 then
				Arr3, Size3 = str_to_iutf8(Sign[3],1) -- 0
			else
				Arr3, Size3 = str_to_icp949(Sign[3],1) -- 0
			end
		end

		if Size1 >= Size2 then
			if Size1 >= Size3 then
				SizeM = Size1
			else
				SizeM = Size3
			end
		else
			if Size2 >= Size3 then
				SizeM = Size2
			else
				SizeM = Size3
			end
		end

		for i = 1, #IndexArr do
			IndexArr[i] = IndexArr[i]+SizeM
		end

		local Box5 = {}
		for i = 1, SizeM do
			table.insert(Box5,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+i-1,SetTo,0x0D0D0D0D,Mask))
		end
		DoActionsX(PlayerID,Box5)

		if type(Sign[1]) == "string" then
			if Size1 == 1 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CVar("X",CRet[1],Exactly,0,0x80000000);
						CVar("X",CRet[1],AtLeast,1);
					},
					actions = {
						SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5],SetTo,Arr1[1]+Arr1[2]*256+Arr1[3]*65536+Arr1[4]*16777216,Mask);
					},
					flag = {Preserved}
				}
			else
				local Box4 = {}
				local p = 1
				local q = 0
				while true do
					table.insert(Box4,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+q,SetTo,Arr1[p]+Arr1[p+1]*256+Arr1[p+2]*65536+Arr1[p+3]*16777216,Mask))
					p = p+4
					q = q+1
					if p > #Arr1 then break end
				end
				Trigger2X(PlayerID,{CVar("X",CRet[1],Exactly,0,0x80000000),CVar("X",CRet[1],AtLeast,1)},Box4,{Preserved})
			end
		end
		if type(Sign[2]) == "string" then
			if Size2 == 1 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CVar("X",CRet[1],Exactly,0x80000000,0x80000000);
					},
					actions = {
						SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5],SetTo,Arr2[1]+Arr2[2]*256+Arr2[3]*65536+Arr2[4]*16777216,Mask);
					},
					flag = {Preserved}
				}
			else
				local Box4 = {}
				local p = 1
				local q = 0
				while true do
					table.insert(Box4,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+q,SetTo,Arr2[p]+Arr2[p+1]*256+Arr2[p+2]*65536+Arr2[p+3]*16777216,Mask))
					p = p+4
					q = q+1
					if p > #Arr2 then break end
				end
				Trigger2X(PlayerID,{CVar("X",CRet[1],Exactly,0x80000000,0x80000000)},Box4,{Preserved})
			end
		end
		if type(Sign[3]) == "string" then
			if Size3 == 1 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CVar("X",CRet[1],Exactly,0);
					},
					actions = {
						SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5],SetTo,Arr3[1]+Arr3[2]*256+Arr3[3]*65536+Arr3[4]*16777216,Mask);
					},
					flag = {Preserved}
				}
			else
				local Box4 = {}
				local p = 1
				local q = 0
				while true do
					table.insert(Box4,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+q,SetTo,Arr3[p]+Arr3[p+1]*256+Arr3[p+2]*65536+Arr3[p+3]*16777216,Mask))
					p = p+4
					q = q+1
					if p > #Arr3 then break end
				end
				Trigger2X(PlayerID,{CVar("X",CRet[1],Exactly,0)},Box4,{Preserved})
			end
		end
		CIf(PlayerID,CVar("X",CRet[1],AtLeast,0x80000000))
			Trigger {
				players = {PlayerID},
				conditions = {
					Label();
				},
				actions = {
					SetCtrig1X("X",CRet[5],0x15C,0,SetTo,0xFFFFFFFF);
					SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[5],0x15C,1,0);
					SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
					CallLabelAlways("X",CRet[1],0);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label();
				},
				actions = {
					SetCtrig1X("X",CRet[5],0x15C,0,Add,1);
					SetCtrigX("X",CRet[5],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X("X",CRet[5],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",CRet[5],0);
				},
				flag = {Preserved}
			}
		CIfEnd()
	end

	local ITemp = SizeM
	for i = 1, n+1 do
		if IndexArr[i] == nil then
			IndexArr[i] = ITemp+Length
			ITemp = ITemp + Length
		else
			ITemp = IndexArr[i]
		end
	end

	local Color, ColorCheck
	if ColorArr == nil then
		ColorArr = 0 
		ColorCheck = 1
	end
	if type(ColorArr) == "number" then
		Color = ColorArr
		ColorArr = {}
		for i = 1, n+1 do
			ColorArr[i] = Color
		end
	end

	if Init == nil then
		Init = ""
		for w = 1, Length do
			Init = Init.."\x0D"
		end
	end
	local Box3 = {}
	local Arr0, Size0
	if type(Init) == "table" then
		for i = n, 0, -1 do
			local k = n-i+1
			if Init[k] == nil or Init[k] == 0 then
				Init[k] = ""
				for w = 1, Length do
					Init[k] = Init[k].."\x0D"
				end
			end
			if utf8flag == 1 then
				Arr0, Size0 = str_to_iutf8(Init[k],1)
			else
				Arr0, Size0 = str_to_icp949(Init[k],1)
			end
			if Size0 == 1 then
				table.insert(Box3,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k],SetTo,Arr0[1]+Arr0[2]*256+Arr0[3]*65536+Arr0[4]*16777216,Mask))
			else
				local p = 1
				local q = 0
				while true do
					table.insert(Box3,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k]+q,SetTo,Arr0[p]+Arr0[p+1]*256+Arr0[p+2]*65536+Arr0[p+3]*16777216,Mask))
					p = p+4
					q = q+1
					if p > #Arr0 then break end
				end
			end
		end
	else
		if utf8flag == 1 then
			Arr0, Size0 = str_to_iutf8(Init,1)
		else
			Arr0, Size0 = str_to_icp949(Init,1)
		end
		for i = n, 0, -1 do
			local k = n-i+1
			if Size0 == 1 then
				table.insert(Box3,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k],SetTo,Arr0[1]+Arr0[2]*256+Arr0[3]*65536+Arr0[4]*16777216,Mask))
			else
				local p = 1
				local q = 0
				while true do
					table.insert(Box3,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k]+q,SetTo,Arr0[p]+Arr0[p+1]*256+Arr0[p+2]*65536+Arr0[p+3]*16777216,Mask))
					p = p+4
					q = q+1
					if p > #Arr0 then break end
				end
			end
		end
	end

	if Output ~= nil then
		if type(Output) == "number" then
			table.insert(Box3,SetMemory(Output,SetTo,IndexArr[n+1]+Length))
		elseif Output[4] == "V" then
			table.insert(Box3,SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,IndexArr[n+1]+Length))
		elseif Output ~= nil then
			table.insert(Box3,SetCtrig1X(Output[1],Output[2],Output[3],Output[4],SetTo,IndexArr[n+1]+Length))
		end
	end

	if #Box3 > 0 then
		DoActions2X(PlayerID,Box3)
	end

	for i = n, 0, -1 do
		local k = n-i+1
		local FBit = bit32.lshift(1,k-1)
		local CBit = Base^i
		local Arr, Size

		local iBox = {}
		local PBox = {}
		for u, v in pairs(DataArr) do
			if type(v[1]) == "table" and type(v[2]) == "table" then
				table.insert(iBox,{FuncAlloc,v[2][2]})
				if type(v[2][2]) == "number" then
					table.insert(PBox,{SetCtrig1X("X",FuncAlloc,0x15C,0,SetTo,0)})
				else
					local z = 0
					for w = 1, #v[2][2] do
						if type(v[2][2][w]) == "number" and v[2][2][w] ~= 0 then
							table.insert(PBox,{SetCtrig1X("X",FuncAlloc,0x15C+0x20*z,0,SetTo,0)})
							z = z + 1
						end
					end
				end
				FuncAlloc = FuncAlloc+1
			end
		end
		if #PBox > 0 then
			DoActions2X(PlayerID,PBox)
		end

		local Box2 = {}
		if Output ~= nil then
			if type(Output) == "number" then
				table.insert(Box2,SetMemory(Output,SetTo,IndexArr[k]))
			elseif Output[4] == "V" then
				table.insert(Box2,SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,IndexArr[k]))
			elseif Output ~= nil then
				table.insert(Box2,SetCtrig1X(Output[1],Output[2],Output[3],Output[4],SetTo,IndexArr[k]))
			end

			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CVar("X",CRet[2],Exactly,0);
						CVar("X",CRet[1],AtLeast,CBit);
					},
					actions = {
						SetCVar("X",CRet[2],SetTo,1);
						Box2,
					},
					flag = {Preserved}
				}
		end

		DoActionsX(PlayerID,SetCVar("X",CRet[3],SetTo,0))
		for j = m, 0 ,-1 do
			local NBit = 2^j
			local TempX = NBit*CBit
			if TempX < 4294967296.0 then
				local TBox = {}
				for l = 1, #iBox do
					if type(iBox[l][2]) == "number" then
						table.insert(TBox,SetCtrig1X("X",iBox[l][1],0x15C,0,Add,NBit*iBox[l][2]))
					else
						local z = 0
						for w = 1, #iBox[l][2] do
							if type(iBox[l][2][w]) == "number" and iBox[l][2][w] ~= 0 then
								table.insert(TBox,SetCtrig1X("X",iBox[l][1],0x15C+0x20*z,0,Add,NBit*iBox[l][2][w]))
								z = z + 1
							end
						end
					end
				end
				Trigger2X(PlayerID,{CVar("X",CRet[1],AtLeast,TempX)},{TBox,SetCVar("X",CRet[3],Add,NBit),SetCVar("X",CRet[1],Subtract,TempX),SetCVar("X",CRet[6],SetTo,FBit,FBit)},{Preserved})
			end
		end

		local CBox = {}
		if ColorArr[k] ~= 0 and ColorArr[k] ~= nil then
			if type(ColorArr[k]) == "table" then
				for p = 1, #ColorArr[k] do
					if ColorArr[k][p] ~= 0 and ColorArr[k][p] ~= nil then
						table.insert(CBox,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k]+p-1,SetTo,ColorArr[k][p],0xFF))
					end
				end
			else
				table.insert(CBox,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k],SetTo,ColorArr[k],0xFF))
			end
		end	
		TriggerX(PlayerID,{CVar("X",CRet[3],AtLeast,1)},{SetCVar("X",CRet[4],SetTo,1)},{Preserved})
		CIf(PlayerID,{CVar("X",CRet[4],Exactly,1)})
		if ColorCheck ~= 1 then
			DoActions2X(PlayerID,CBox)
		end
		local ptr = 1
		local Mask2
		local CMask = bit32.band(Mask,0xFFFFFF00)
		for u, v in pairs(DataArr) do
			if type(v[1]) == "number" then
				if type(v[2]) == "string" then
					if utf8flag == 1 then
						Arr, Size = str_to_iutf8(v[2],1)
					else
						Arr, Size = str_to_icp949(v[2],1)
					end
					if Size == 1 then
						if ColorCheck == 1 then
							Mask2 = Mask
						elseif Arr[1] == 0x0D then
							Mask2 = CMask
						else 
							Mask2 = Mask
						end
						TriggerX(PlayerID,{CVar("X",CRet[3],Exactly,v[1])},{SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k],SetTo,Arr[1]+Arr[2]*256+Arr[3]*65536+Arr[4]*16777216,Mask2)},{Preserved})
					else
						local Box = {}
						local p = 1
						local q = 0.
						while true do
							if ColorCheck == 1 then
								Mask2 = Mask
							elseif Arr[p] == 0x0D then
								Mask2 = CMask
							else 
								Mask2 = Mask
							end
							table.insert(Box,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k]+q,SetTo,Arr[p]+Arr[p+1]*256+Arr[p+2]*65536+Arr[p+3]*16777216,Mask2))
							p = p+4
							q = q+1
							if p > #Arr then break end
						end
						Trigger2X(PlayerID,{CVar("X",CRet[3],Exactly,v[1])},Box,{Preserved})
					end
				else -- table/add
					if utf8flag == 1 then
						Arr, Size = str_to_iutf8(v[2][1],1)
					else
						Arr, Size = str_to_icp949(v[2][1],1)
					end
					if Size == 1 then
						if ColorCheck == 1 then
							Mask2 = Mask
						elseif Arr[1] == 0x0D then
							Mask2 = CMask
						else 
							Mask2 = Mask
						end
						TriggerX(PlayerID,{CVar("X",CRet[3],Exactly,v[1])},{SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k],SetTo,v[1]*v[2][2]+Arr[1]+Arr[2]*256+Arr[3]*65536+Arr[4]*16777216,Mask2)},{Preserved})
					else
						local Box = {}
						local p = 1
						local q = 0
						while true do
							if ColorCheck == 1 then
								Mask2 = Mask
							elseif Arr[p] == 0x0D then
								Mask2 = CMask
							else 
								Mask2 = Mask
							end
							if v[2][2][q+1] ~= nil then
								table.insert(Box,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k]+q,SetTo,v[1]*v[2][2][q+1]+Arr[p]+Arr[p+1]*256+Arr[p+2]*65536+Arr[p+3]*16777216,Mask2))
							else
								table.insert(Box,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k]+q,SetTo,Arr[p]+Arr[p+1]*256+Arr[p+2]*65536+Arr[p+3]*16777216,Mask2))
							end
							p = p+4
							q = q+1
							if p > #Arr then break end
						end
						Trigger2X(PlayerID,{CVar("X",CRet[3],Exactly,v[1])},Box,{Preserved})
					end
				end
			else
				if type(v[2]) == "string" then
					if utf8flag == 1 then
						Arr, Size = str_to_iutf8(v[2],1)
					else
						Arr, Size = str_to_icp949(v[2],1)
					end
					if Size == 1 then
						if ColorCheck == 1 then
							Mask2 = Mask
						elseif Arr[1] == 0x0D then
							Mask2 = CMask
						else 
							Mask2 = Mask
						end
						TriggerX(PlayerID,{CVar("X",CRet[3],AtLeast,v[1][1]),CVar("X",CRet[3],AtMost,v[1][2])},{SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k],SetTo,Arr[1]+Arr[2]*256+Arr[3]*65536+Arr[4]*16777216,Mask2)},{Preserved})
					else
						local Box = {}
						local p = 1
						local q = 0
						while true do
							if ColorCheck == 1 then
								Mask2 = Mask
							elseif Arr[p] == 0x0D then
								Mask2 = CMask
							else 
								Mask2 = Mask
							end
							table.insert(Box,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k]+q,SetTo,Arr[p]+Arr[p+1]*256+Arr[p+2]*65536+Arr[p+3]*16777216,Mask2))
							p = p+4
							q = q+1
							if p > #Arr then break end
						end
						Trigger2X(PlayerID,{CVar("X",CRet[3],AtLeast,v[1][1]),CVar("X",CRet[3],AtMost,v[1][2])},Box,{Preserved})
					end
				else -- table/add
					if utf8flag == 1 then
						Arr, Size = str_to_iutf8(v[2][1],1)
					else
						Arr, Size = str_to_icp949(v[2][1],1)
					end
					if Size == 1 then
						if ColorCheck == 1 then
							Mask2 = Mask
						elseif Arr[1] == 0x0D then
							Mask2 = CMask
						else 
							Mask2 = Mask
						end
						TriggerX(PlayerID,{CVar("X",CRet[3],AtLeast,v[1][1]),CVar("X",CRet[3],AtMost,v[1][2])},{SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k],SetTo,Arr[1]+Arr[2]*256+Arr[3]*65536+Arr[4]*16777216,Mask2)},{Preserved})
						Trigger {
							players = {PlayerID},
							conditions = {
								Label(iBox[ptr][1]);
								CVar("X",CRet[3],AtLeast,v[1][1]);
								CVar("X",CRet[3],AtMost,v[1][2]);
							},
							actions = {
								SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k],Add,0,Mask);
							},
							flag = {Preserved}
						}
						ptr = ptr+1
					else
						local WBox = {}
						local Box = {}
						local p = 1
						local q = 0
						while true do
							if ColorCheck == 1 then
								Mask2 = Mask
							elseif Arr[p] == 0x0D then
								Mask2 = CMask
							else 
								Mask2 = Mask
							end
							table.insert(Box,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k]+q,SetTo,Arr[p]+Arr[p+1]*256+Arr[p+2]*65536+Arr[p+3]*16777216,Mask2))
							if type(v[2][2][q+1]) == "number" and v[2][2][q+1] ~= 0 then
								table.insert(WBox,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k]+q,Add,0,Mask))
							end
							p = p+4
							q = q+1
							if p > #Arr then break end
						end
						Trigger2X(PlayerID,{CVar("X",CRet[3],AtLeast,v[1][1]),CVar("X",CRet[3],AtMost,v[1][2])},Box,{Preserved})
						Trigger {
							players = {PlayerID},
							conditions = {
								Label(iBox[ptr][1]);
								CVar("X",CRet[3],AtLeast,v[1][1]);
								CVar("X",CRet[3],AtMost,v[1][2]);
							},
							actions = {
								WBox;
							},
							flag = {Preserved}
						}
						ptr = ptr+1
					end
				end
			end
		end
		CIfEnd()
	end

	if ClearArr ~= nil then
		for k = 1, n do
			if type(ClearArr[k]) == "table" then
				local RBox = {}
				for l = IndexArr[k]+Length, IndexArr[k+1]-1 do
					table.insert(RBox,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+l,SetTo,0x0D0D0D0D,Mask))
				end
				local CBox = {}
				local CCheck = 0
				local FCheck = 0
				for l = 1, #ClearArr[k] do
					if ClearArr[k][l] == 0 then
						CCheck = 1
					else
						FCheck = bit32.bor(FCheck,bit32.lshift(1,ClearArr[k][l]-1))
					end
				end
				if CCheck == 1 then
					for w = 1, k do
						FCheck = bit32.bor(FCheck,bit32.lshift(1,w-1))
					end
				end
				if FCheck ~= 0 then
					table.insert(CBox,CVar("X",CRet[6],Exactly,0,FCheck))
				end
				if #RBox > 0 then
					Trigger2X(PlayerID,CBox,RBox,{Preserved})
				end
			end
		end
	end
end


function CA__lItoCustom(SVA1,Input,Output,Mask,Base,Length,Init,Sign,ColorArr,IndexArr,DataArr,ClearArr,utf8flag)
	-- SVA1 : 상수 only / Input : 변환할 V / Output : 채워진 Max 자릿수 반환 V
	-- Base : k진법 (2~2^32)
	-- Zero : 0 표시 방법 선택 (0 = 그대로 표시 / " " = 대신 표시할 문자)
	-- Sign : 부호 추가 / 부호없음 (0) / 부호추가 {+기호,-기호} - String 지원
	-- ColorArr : 컬러코드 추가 / 0x01 ~ 0x1F (기본 0x0D) / 맨 앞부터 적용 (오직 변수 숫자만) - 0x0 입력시 적용X & DataArr가 있다면 덮어씌워짐
	-- IndexArr : 삽입위치 결정 / 0 ~ SVA1[6]-1 (기본 0부터 Size만큼) 
	-- DataArr : 변환 문자 설정 / 0 ~ SVA1[6]-1 / {A,B} -> A = n : Exactly, A = {a,b} : A AtLeast a, A AtMost b 
	-- / B = n : SetTo n, B = {n} : Add n, B = " " : SetTo " ", B = {" "} : SetTo " "(나머지) + Add " "(Last) 
	-- Resetflag : 1 체크시 삽입 Start ~ End 사이에 존재하는 모든 비삽입 위치를 Clear함 (Max 자릿수만큼)
	if Mask == nil then
		if utf8flag == 1 then
			Mask = 0xFFFFFFFF
		else
			Mask = 0xFFFF00FF
		end
	end

	if Length == nil then
		Length = 1
	end

	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	if Input[5] == nil then
		Input[5] = {0,0}
	else
		Input[5] = I64(Input[5])
	end
	Trigger {
		players = {PlayerID},
		conditions = {
			Label();
		},
		actions = {
			SetCtrig1X("X",WRet[4],0x15C,0,SetTo,0);
			SetCtrig1X("X",WRet[4],0x19C,0,SetTo,0);
			SetCtrig1X("X",CRet[4],0x15C,0,SetTo,0);
			SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0);
			SetCtrig1X("X",WRet[1],0x15C,0,SetTo,Input[5][1]);
			SetCtrig1X("X",WRet[1],0x19C,0,SetTo,Input[5][2]);
			SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",WRet[1],0x15C,1,0);
			SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
			SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,Add*16777216,0xFF000000);
			SetCtrigX(Input[1],Input[2],0x198,Input[3],SetTo,"X",WRet[1],0x19C,1,0);
			SetCtrig1X(Input[1],Input[2],0x188,Input[3],SetTo,0xFFFFFFFF);
			SetCtrig1X(Input[1],Input[2],0x1A0,Input[3],SetTo,Add*16777216,0xFF000000);
			CallLabelAlways(Input[1],Input[2],Input[3]);
		},
		flag = {Preserved}
	}

	local Max
	if type(Base) == "table" then
		Max = math.floor(Base[2])-1
		Base = Base[1]
	end

	if Base >= 2 then
		Base = math.floor(Base)
	else
		CA__ItoCustom_InputData_Error()
	end

	local n = math.ceil(64*math.log(2)/math.log(Base))-1
	local m = math.floor(math.log(Base)/math.log(2))

	if Max ~= nil and Max <= n then
		n = Max
	end

	if type(IndexArr) ~= "table" then
		IndexArr = {}
	end

	if DataArr == nil then
		if Base > 10 then
			DataArr = {{{0,9},{"0",0x1000000}},{{10,15},{"\x37",0x1000000}}} -- 0x37 + 0xA = 0x41 ("A")
		else
			DataArr = {{{0,9},{"0",0x1000000}}}
		end
	end

	local Arr1, Size1 = 0
	local Arr2, Size2 = 0
	local Arr3, Size3 = 0
	local SizeM = 0
	if type(Sign) == "string" then
		if utf8flag == 1 then
			Arr3, Size3 = str_to_iutf8(Sign,1)
		else
			Arr3, Size3 = str_to_icp949(Sign,1)
		end

		SizeM = Size3

		for i = 1, #IndexArr do
			IndexArr[i] = IndexArr[i]+SizeM
		end

		local Box5 = {}
		for i = 1, SizeM do
			table.insert(Box5,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+i-1,SetTo,0x0D0D0D0D,Mask))
		end
		DoActionsX(PlayerID,Box5)
		
		if Size3 == 1 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CWar("X",WRet[1],Exactly,0);
						CWar("X",WRet[1],Exactly,{0});
					},
					actions = {
						SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5],SetTo,Arr3[1]+Arr3[2]*256+Arr3[3]*65536+Arr3[4]*16777216,Mask);
					},
					flag = {Preserved}
				}
		else
				local Box4 = {}
				local p = 1
				local q = 0
				while true do
					table.insert(Box4,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+q,SetTo,Arr3[p]+Arr3[p+1]*256+Arr3[p+2]*65536+Arr3[p+3]*16777216,Mask))
					p = p+4
					q = q+1
					if p > #Arr3 then break end
				end
				Trigger2X(PlayerID,{CWar("X",WRet[1],Exactly,0),CWar("X",WRet[1],Exactly,{0})},Box4,{Preserved})
		end
	elseif type(Sign) == "table" then
		if Sign[1] == nil or Sign[1] == 0 then
			Sign[1] = "\x0D"
		end
		if Sign[2] == nil or Sign[2] == 0 then
			Sign[2] = "\x0D"
		end
		if Sign[3] == nil or Sign[3] == 0 then
			Sign[3] = "\x0D"
		end

		if type(Sign[1]) == "string" then
			if utf8flag == 1 then
				Arr1, Size1 = str_to_iutf8(Sign[1],1) -- +
			else
				Arr1, Size1 = str_to_icp949(Sign[1],1) -- +
			end
		end
		if type(Sign[2]) == "string" then
			if utf8flag == 1 then
				Arr2, Size2 = str_to_iutf8(Sign[2],1) -- -
			else
				Arr2, Size2 = str_to_icp949(Sign[2],1) -- -
			end
		end
		if type(Sign[3]) == "string" then
			if utf8flag == 1 then
				Arr3, Size3 = str_to_iutf8(Sign[3],1) -- 0
			else
				Arr3, Size3 = str_to_icp949(Sign[3],1) -- 0
			end
		end

		if Size1 >= Size2 then
			if Size1 >= Size3 then
				SizeM = Size1
			else
				SizeM = Size3
			end
		else
			if Size2 >= Size3 then
				SizeM = Size2
			else
				SizeM = Size3
			end
		end

		for i = 1, #IndexArr do
			IndexArr[i] = IndexArr[i]+SizeM
		end

		local Box5 = {}
		for i = 1, SizeM do
			table.insert(Box5,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+i-1,SetTo,0x0D0D0D0D,Mask))
		end
		DoActionsX(PlayerID,Box5)

		if type(Sign[1]) == "string" then
			if Size1 == 1 then
				DoActionsX(PlayerID,SetCVar("X",CRet[1],SetTo,1))
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CWar("X",WRet[1],Exactly,0);
						CWar("X",WRet[1],Exactly,{0});
					},
					actions = {
						SetCVar("X",CRet[1],SetTo,0);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CWar("X",WRet[1],Exactly,{0},0x80000000);
						CVar("X",CRet[1],Exactly,1);
					},
					actions = {
						SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5],SetTo,Arr1[1]+Arr1[2]*256+Arr1[3]*65536+Arr1[4]*16777216,Mask);
					},
					flag = {Preserved}
				}
			else
				local Box4 = {}
				local p = 1
				local q = 0
				while true do
					table.insert(Box4,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+q,SetTo,Arr1[p]+Arr1[p+1]*256+Arr1[p+2]*65536+Arr1[p+3]*16777216,Mask))
					p = p+4
					q = q+1
					if p > #Arr1 then break end
				end
				DoActionsX(PlayerID,SetCVar("X",CRet[1],SetTo,1))
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CWar("X",WRet[1],Exactly,0);
						CWar("X",WRet[1],Exactly,{0});
					},
					actions = {
						SetCVar("X",CRet[1],SetTo,0);
					},
					flag = {Preserved}
				}
				Trigger2X(PlayerID,{CWar("X",WRet[1],Exactly,{0},0x80000000),CVar("X",CRet[1],Exactly,1)},Box4,{Preserved})
			end
		end
		if type(Sign[2]) == "string" then
			if Size2 == 1 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CWar("X",WRet[1],Exactly,{0x80000000},0x80000000);
					},
					actions = {
						SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5],SetTo,Arr2[1]+Arr2[2]*256+Arr2[3]*65536+Arr2[4]*16777216,Mask);
					},
					flag = {Preserved}
				}
			else
				local Box4 = {}
				local p = 1
				local q = 0
				while true do
					table.insert(Box4,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+q,SetTo,Arr2[p]+Arr2[p+1]*256+Arr2[p+2]*65536+Arr2[p+3]*16777216,Mask))
					p = p+4
					q = q+1
					if p > #Arr2 then break end
				end
				Trigger2X(PlayerID,{CWar("X",WRet[1],Exactly,{0x80000000},0x80000000)},Box4,{Preserved})
			end
		end
		if type(Sign[3]) == "string" then
			if Size3 == 1 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CWar("X",WRet[1],Exactly,0);
						CWar("X",WRet[1],Exactly,{0});
					},
					actions = {
						SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5],SetTo,Arr3[1]+Arr3[2]*256+Arr3[3]*65536+Arr3[4]*16777216,Mask);
					},
					flag = {Preserved}
				}
			else
				local Box4 = {}
				local p = 1
				local q = 0
				while true do
					table.insert(Box4,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+q,SetTo,Arr3[p]+Arr3[p+1]*256+Arr3[p+2]*65536+Arr3[p+3]*16777216,Mask))
					p = p+4
					q = q+1
					if p > #Arr3 then break end
				end
				Trigger2X(PlayerID,{CWar("X",WRet[1],Exactly,0),CWar("X",WRet[1],Exactly,{0})},Box4,{Preserved})
			end
		end
		CIf(PlayerID,CWar("X",WRet[1],Exactly,{0x80000000},0x80000000))
			Trigger {
					players = {PlayerID},
					conditions = {
						Label();
					},
					actions = {
						SetCtrig1X("X",WRet[2],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[2],0x19C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",WRet[1],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
						SetCtrigX("X",WRet[1],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
						SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[1],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",WRet[1],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label();
						CtrigX("X",WRet[2],0x15C,0,Exactly,0xFFFFFFFF);
					},
					actions = {
						SetCtrig1X("X",WRet[2],0x19C,0,Add,1);
					},
					flag = {Preserved}
				}	
			Trigger {
					players = {PlayerID},
					conditions = {
						Label();
					},
					actions = {
						SetCtrig1X("X",WRet[2],0x15C,0,Add,1);
						SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[1],0x15C,1,0);
						SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[1],0x19C,1,0);
						SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",WRet[2],0);
					},
					flag = {Preserved}
				}
		CIfEnd()
	end

	local ITemp = SizeM
	for i = 1, n+1 do
		if IndexArr[i] == nil then
			IndexArr[i] = ITemp+Length
			ITemp = ITemp + Length
		else
			ITemp = IndexArr[i]
		end
	end

	local Color, ColorCheck
	if ColorArr == nil then
		ColorArr = 0 
		ColorCheck = 1
	end
	if type(ColorArr) == "number" then
		Color = ColorArr
		ColorArr = {}
		for i = 1, n+1 do
			ColorArr[i] = Color
		end
	end

	if Init == nil then
		Init = ""
		for w = 1, Length do
			Init = Init.."\x0D"
		end
	end
	local Box3 = {}
	local Arr0, Size0
	if type(Init) == "table" then
		for i = n, 0, -1 do
			local k = n-i+1
			if Init[k] == nil or Init[k] == 0 then
				Init[k] = ""
				for w = 1, Length do
					Init[k] = Init[k].."\x0D"
				end
			end
			if utf8flag == 1 then
				Arr0, Size0 = str_to_iutf8(Init[k],1)
			else
				Arr0, Size0 = str_to_icp949(Init[k],1)
			end
			if Size0 == 1 then
				table.insert(Box3,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k],SetTo,Arr0[1]+Arr0[2]*256+Arr0[3]*65536+Arr0[4]*16777216,Mask))
			else
				local p = 1
				local q = 0
				while true do
					table.insert(Box3,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k]+q,SetTo,Arr0[p]+Arr0[p+1]*256+Arr0[p+2]*65536+Arr0[p+3]*16777216,Mask))
					p = p+4
					q = q+1
					if p > #Arr0 then break end
				end
			end
		end
	else
		if utf8flag == 1 then
			Arr0, Size0 = str_to_iutf8(Init,1)
		else
			Arr0, Size0 = str_to_icp949(Init,1)
		end

		for i = n, 0, -1 do
			local k = n-i+1
			if Size0 == 1 then
				table.insert(Box3,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k],SetTo,Arr0[1]+Arr0[2]*256+Arr0[3]*65536+Arr0[4]*16777216,Mask))
			else
				local p = 1
				local q = 0
				while true do
					table.insert(Box3,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k]+q,SetTo,Arr0[p]+Arr0[p+1]*256+Arr0[p+2]*65536+Arr0[p+3]*16777216,Mask))
					p = p+4
					q = q+1
					if p > #Arr0 then break end
				end
			end
		end
	end

	if Output ~= nil then
		if type(Output) == "number" then
			table.insert(Box3,SetMemory(Output,SetTo,IndexArr[n+1]+Length))
		elseif Output[4] == "V" then
			table.insert(Box3,SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,IndexArr[n+1]+Length))
		elseif Output ~= nil then
			table.insert(Box3,SetCtrig1X(Output[1],Output[2],Output[3],Output[4],SetTo,IndexArr[n+1]+Length))
		end
	end

	if #Box3 > 0 then
		DoActions2X(PlayerID,Box3)
	end

	local CBit = {0,1}
	local CBitArr = {CBit}
	for y = 1, n do
		CBit = I64Mul(CBit[1],CBit[2],0,Base)
		table.insert(CBitArr,CBit)
	end

	for i = n, 0, -1 do
		local k = n-i+1
		local CBit = CBitArr[i+1]
		local Arr, Size

		local iBox = {}
		local PBox = {}
		for u, v in pairs(DataArr) do
			if type(v[1]) == "table" and type(v[2]) == "table" then
				table.insert(iBox,{FuncAlloc,v[2][2]})
				if type(v[2][2]) == "number" then
					table.insert(PBox,{SetCtrig1X("X",FuncAlloc,0x15C,0,SetTo,0)})
				else
					local z = 0
					for w = 1, #v[2][2] do
						if type(v[2][2][w]) == "number" and v[2][2][w] ~= 0 then
							table.insert(PBox,{SetCtrig1X("X",FuncAlloc,0x15C+0x20*z,0,SetTo,0)})
							z = z + 1
						end
					end
				end
				FuncAlloc = FuncAlloc+1
			end
		end
		if #PBox > 0 then
			DoActions2X(PlayerID,PBox)
		end
		local FBit 
		local XBox = {}
		if k > 32 then -- 33~64
			FBit = bit32.lshift(1,k-33)
			table.insert(XBox,SetCWar("X",WRet[4],SetTo,{FBit},FBit))
		else -- 1~32
			FBit = bit32.lshift(1,k-1)
			table.insert(XBox,SetCWar("X",WRet[4],SetTo,FBit,FBit))
		end
		DoActionsX(PlayerID,SetCVar("X",CRet[3],SetTo,0))
		for j = m, 0 ,-1 do
			local NBit = 2^j
			local Temp = I64Mul(CBit[1],CBit[2],0,NBit)
			if Temp[1] < 4294967296.0 then
				local TBox = {}
				for l = 1, #iBox do
					if type(iBox[l][2]) == "number" then
						table.insert(TBox,SetCtrig1X("X",iBox[l][1],0x15C,0,Add,NBit*iBox[l][2]))
					else
						local z = 0
						for w = 1, #iBox[l][2] do
							if type(iBox[l][2][w]) == "number" and iBox[l][2][w] ~= 0 then
								table.insert(TBox,SetCtrig1X("X",iBox[l][1],0x15C+0x20*z,0,Add,NBit*iBox[l][2][w]))
								z = z + 1
							end
						end
					end
				end
				CIf(PlayerID,{TTCWar("X",WRet[1],AtLeast,{Temp[2],Temp[1]})},{SetCVar("X",CRet[3],Add,NBit),XBox})
					if #TBox > 0 then
						DoActions2X(PlayerID,TBox)
					end
					f_LSub(PlayerID,W(WRet[1]),W(WRet[1]),{Temp[2],Temp[1]})
				CIfEnd()
			end
		end

		local Box2 = {}
		if Output ~= nil then
			if type(Output) == "number" then
				table.insert(Box2,SetMemory(Output,SetTo,IndexArr[k]))
			elseif Output[4] == "V" then
				table.insert(Box2,SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,IndexArr[k]))
			elseif Output ~= nil then
				table.insert(Box2,SetCtrig1X(Output[1],Output[2],Output[3],Output[4],SetTo,IndexArr[k]))
			end

			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CVar("X",CRet[2],Exactly,0);
						CVar("X",CRet[3],AtLeast,1);
					},
					actions = {
						SetCVar("X",CRet[2],SetTo,1);
						Box2,
					},
					flag = {Preserved}
				}
		end		

		local CBox = {}
		if ColorArr[k] ~= 0 and ColorArr[k] ~= nil then
			if type(ColorArr[k]) == "table" then
				for p = 1, #ColorArr[k] do
					if ColorArr[k][p] ~= 0 and ColorArr[k][p] ~= nil then
						table.insert(CBox,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k]+p-1,SetTo,ColorArr[k][p],0xFF))
					end
				end
			else
				table.insert(CBox,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k],SetTo,ColorArr[k],0xFF))
			end
		end	
		TriggerX(PlayerID,{CVar("X",CRet[3],AtLeast,1)},{SetCVar("X",CRet[4],SetTo,1)},{Preserved})
		CIf(PlayerID,{CVar("X",CRet[4],Exactly,1)})
		if ColorCheck ~= 1 then
			DoActions2X(PlayerID,CBox)
		end
		local ptr = 1
		local Mask2
		local CMask = bit32.band(Mask,0xFFFFFF00)
		for u, v in pairs(DataArr) do
			if type(v[1]) == "number" then
				if type(v[2]) == "string" then
					if utf8flag == 1 then
						Arr, Size = str_to_iutf8(v[2],1)
					else
						Arr, Size = str_to_icp949(v[2],1)
					end
					
					if Size == 1 then
						if ColorCheck == 1 then
							Mask2 = Mask
						elseif Arr[1] == 0x0D then
							Mask2 = CMask
						else 
							Mask2 = Mask
						end
						TriggerX(PlayerID,{CVar("X",CRet[3],Exactly,v[1])},{SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k],SetTo,Arr[1]+Arr[2]*256+Arr[3]*65536+Arr[4]*16777216,Mask2)},{Preserved})
					else
						local Box = {}
						local p = 1
						local q = 0.
						while true do
							if ColorCheck == 1 then
								Mask2 = Mask
							elseif Arr[p] == 0x0D then
								Mask2 = CMask
							else 
								Mask2 = Mask
							end
							table.insert(Box,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k]+q,SetTo,Arr[p]+Arr[p+1]*256+Arr[p+2]*65536+Arr[p+3]*16777216,Mask2))
							p = p+4
							q = q+1
							if p > #Arr then break end
						end
						Trigger2X(PlayerID,{CVar("X",CRet[3],Exactly,v[1])},Box,{Preserved})
					end
				else -- table/add
					if utf8flag == 1 then
						Arr, Size = str_to_iutf8(v[2][1],1)
					else
						Arr, Size = str_to_icp949(v[2][1],1)
					end
					
					if Size == 1 then
						if ColorCheck == 1 then
							Mask2 = Mask
						elseif Arr[1] == 0x0D then
							Mask2 = CMask
						else 
							Mask2 = Mask
						end
						TriggerX(PlayerID,{CVar("X",CRet[3],Exactly,v[1])},{SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k],SetTo,v[1]*v[2][2]+Arr[1]+Arr[2]*256+Arr[3]*65536+Arr[4]*16777216,Mask2)},{Preserved})
					else
						local Box = {}
						local p = 1
						local q = 0
						while true do
							if ColorCheck == 1 then
								Mask2 = Mask
							elseif Arr[p] == 0x0D then
								Mask2 = CMask
							else 
								Mask2 = Mask
							end
							if v[2][2][q+1] ~= nil then
								table.insert(Box,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k]+q,SetTo,v[1]*v[2][2][q+1]+Arr[p]+Arr[p+1]*256+Arr[p+2]*65536+Arr[p+3]*16777216,Mask2))
							else
								table.insert(Box,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k]+q,SetTo,Arr[p]+Arr[p+1]*256+Arr[p+2]*65536+Arr[p+3]*16777216,Mask2))
							end
							p = p+4
							q = q+1
							if p > #Arr then break end
						end
						Trigger2X(PlayerID,{CVar("X",CRet[3],Exactly,v[1])},Box,{Preserved})
					end
				end
			else
				if type(v[2]) == "string" then
					if utf8flag == 1 then
						Arr, Size = str_to_iutf8(v[2],1)
					else
						Arr, Size = str_to_icp949(v[2],1)
					end
					
					if Size == 1 then
						if ColorCheck == 1 then
							Mask2 = Mask
						elseif Arr[1] == 0x0D then
							Mask2 = CMask
						else 
							Mask2 = Mask
						end
						TriggerX(PlayerID,{CVar("X",CRet[3],AtLeast,v[1][1]),CVar("X",CRet[3],AtMost,v[1][2])},{SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k],SetTo,Arr[1]+Arr[2]*256+Arr[3]*65536+Arr[4]*16777216,Mask2)},{Preserved})
					else
						local Box = {}
						local p = 1
						local q = 0
						while true do
							if ColorCheck == 1 then
								Mask2 = Mask
							elseif Arr[p] == 0x0D then
								Mask2 = CMask
							else 
								Mask2 = Mask
							end
							table.insert(Box,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k]+q,SetTo,Arr[p]+Arr[p+1]*256+Arr[p+2]*65536+Arr[p+3]*16777216,Mask2))
							p = p+4
							q = q+1
							if p > #Arr then break end
						end
						Trigger2X(PlayerID,{CVar("X",CRet[3],AtLeast,v[1][1]),CVar("X",CRet[3],AtMost,v[1][2])},Box,{Preserved})
					end
				else -- table/add
					if utf8flag == 1 then
						Arr, Size = str_to_iutf8(v[2][1],1)
					else
						Arr, Size = str_to_icp949(v[2][1],1)
					end
					
					if Size == 1 then
						if ColorCheck == 1 then
							Mask2 = Mask
						elseif Arr[1] == 0x0D then
							Mask2 = CMask
						else 
							Mask2 = Mask
						end
						TriggerX(PlayerID,{CVar("X",CRet[3],AtLeast,v[1][1]),CVar("X",CRet[3],AtMost,v[1][2])},{SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k],SetTo,Arr[1]+Arr[2]*256+Arr[3]*65536+Arr[4]*16777216,Mask2)},{Preserved})
						Trigger {
							players = {PlayerID},
							conditions = {
								Label(iBox[ptr][1]);
								CVar("X",CRet[3],AtLeast,v[1][1]);
								CVar("X",CRet[3],AtMost,v[1][2]);
							},
							actions = {
								SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k],Add,0,Mask);
							},
							flag = {Preserved}
						}
						ptr = ptr+1
					else
						local WBox = {}
						local Box = {}
						local p = 1
						local q = 0
						while true do
							if ColorCheck == 1 then
								Mask2 = Mask
							elseif Arr[p] == 0x0D then
								Mask2 = CMask
							else 
								Mask2 = Mask
							end
							table.insert(Box,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k]+q,SetTo,Arr[p]+Arr[p+1]*256+Arr[p+2]*65536+Arr[p+3]*16777216,Mask2))
							if type(v[2][2][q+1]) == "number" and v[2][2][q+1] ~= 0 then
								table.insert(WBox,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+IndexArr[k]+q,Add,0,Mask))
							end
							p = p+4
							q = q+1
							if p > #Arr then break end
						end
						Trigger2X(PlayerID,{CVar("X",CRet[3],AtLeast,v[1][1]),CVar("X",CRet[3],AtMost,v[1][2])},Box,{Preserved})
						Trigger {
							players = {PlayerID},
							conditions = {
								Label(iBox[ptr][1]);
								CVar("X",CRet[3],AtLeast,v[1][1]);
								CVar("X",CRet[3],AtMost,v[1][2]);
							},
							actions = {
								WBox;
							},
							flag = {Preserved}
						}
						ptr = ptr+1
					end
				end
			end
		end
		CIfEnd()
	end

	if ClearArr ~= nil then
		for k = 1, n do
			if type(ClearArr[k]) == "table" then
				local RBox = {}
				for l = IndexArr[k]+Length, IndexArr[k+1]-1 do
					table.insert(RBox,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+l,SetTo,0x0D0D0D0D,Mask))
				end
				local CBox = {}
				local CCheck = 0
				local FCheck1 = 0
				local FCheck2 = 0
				for l = 1, #ClearArr[k] do
					if ClearArr[k][l] == 0 then
						CCheck = 1
					elseif ClearArr[k][l] > 32 then -- 33~64
						FCheck2 = bit32.bor(FCheck2,bit32.lshift(1,ClearArr[k][l]-33))
					else -- 1~32
						FCheck1 = bit32.bor(FCheck1,bit32.lshift(1,ClearArr[k][l]-1))
					end
				end
				if CCheck == 1 then
					for w = 1, k do
						if w > 32 then -- 33~64
							FCheck2 = bit32.bor(FCheck2,bit32.lshift(1,w-33))
						else -- 1~32
							FCheck1 = bit32.bor(FCheck1,bit32.lshift(1,w-1))
						end
					end
				end
				if FCheck1 ~= 0 then
					table.insert(CBox,CWar("X",WRet[4],Exactly,0,FCheck1))
				end
				if FCheck2 ~= 0 then
					table.insert(CBox,CWar("X",WRet[4],Exactly,{0},FCheck2))
				end

				if #RBox > 0 then
					Trigger2X(PlayerID,CBox,RBox,{Preserved})
				end
			end
		end
	end
end

--[[ FullWidth Code (byteArr →)
+Set A1A1
0xA1A1 :  (0x20)
+0xA380
0xA3A1 ~ 0xA3AF : !"#$%&'()*+,-./ (0x21~0x2F)
0xA3B0 ~ 0xA3B9 : ０１２３４５６７８９ (0x30~0x39)
0xA3BA ~ 0xA3C0 : :;<=>?@ (0x3A~0x40)
0xA3C1 ~ 0xA3DA : Ａ～Ｚ (0x41~0x5A)
0xA3DB ~ 0xA3E0 : [\]^_` (0x5B~0x60)
0xA3E1 ~ 0xA3FA : ａ～ｚ (0x61~0x7A)
0xA3FB ~ 0xA3FE : {|}~ (0x7B~0x7E)
+0
0x7F : ]]--

function CA__ItoName(SVA1,TargetPlayer,Output,Init,ColorArr,FullWidth,utf8flag)
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)
	local Base
	if TargetPlayer == "Host" then
		Base = 0x6D0F78
	else
		Base = 0x6D0FDC+0x24*TargetPlayer
	end

	local Color
	if ColorArr == nil then
		ColorArr = 0
	end
	if type(ColorArr) == "number" then
		Color = ColorArr
		ColorArr = {}
		for i = 1, 16 do
			ColorArr[i] = Color
		end
	end

	if Init == nil then
		Init = "\x0D"
	end
	local Box = {}
	local Mask
	local ZeroData
	if utf8flag == 1 then
		Mask = {0xFFFFFFFF,0x00FFFFFF,0xFFFFFF00,0x00FFFF00,0x0D0D00,0x8080E300,0x60AFE200}
		ZeroData = bit32.band(MakeiStrDataX(Init,1),0xFFFFFF00)
	else
		Mask = {0xFFFF00FF,0x00FF00FF,0xFFFF0000,0x00FF0000,0x0D0000,0xA1A10000,0x80960000}
		ZeroData = bit32.band(MakeiStrData(Init,1),0xFFFF0000)
	end

	for i = 0, 15 do
		local Temp = i%4
		local Next = math.floor(i/4)
		if Temp == 0 then
			f_ReadX(PlayerID,Base +0x4*Next,{SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+i},"+3",0xFF) -- 0->3
		elseif Temp == 1 then
			f_ReadX(PlayerID,Base +0x4*Next,{SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+i},"+2",0xFF00) -- 1->3
		elseif Temp == 2 then
			f_ReadX(PlayerID,Base +0x4*Next,{SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+i},"+1",0xFF0000) -- 2->3
		else
			f_ReadX(PlayerID,Base +0x4*Next,{SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+i},"0",0xFF000000) -- 3->3
		end

		local Box2 = {}
		if Output ~= nil then
			if type(Output) == "number" then
				table.insert(Box2,SetMemory(Output,SetTo,i+1))
			elseif Output[4] == "V" then
				table.insert(Box2,SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,i+1))
			else
				table.insert(Box2,SetCtrig1X(Output[1],Output[2],Output[3],Output[4],SetTo,i+1))
			end
		end
		local Box1 = {} 
		local Box0 = {}
		if ColorArr[i+1] ~= 0 and ColorArr[i+1] ~= nil then
			table.insert(Box0,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+i,SetTo,ZeroData+ColorArr[i+1],Mask[1]))
			table.insert(Box1,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+i,SetTo,Mask[5]+ColorArr[i+1],Mask[2]))
		else
			table.insert(Box0,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+i,SetTo,ZeroData,Mask[3]))
			table.insert(Box1,SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+i,SetTo,Mask[5],Mask[4]))
		end
		
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					MemoryB(Base+i,Exactly,0);
				},
				actions = {
					Box0,
				},
				flag = {Preserved}
		}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					MemoryB(Base+i,AtLeast,1);
				},
				actions = {
					Box1,
					Box2,
				},
				flag = {Preserved}
		}

		if FullWidth == 1 then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					MemoryB(Base+i,AtLeast,1);
					CtrigX(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+i,Exactly,0x20000000,0xFF000000);
				},
				actions = {
					SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+i,SetTo,Mask[6],Mask[3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					MemoryB(Base+i,AtLeast,1);
					CtrigX(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+i,AtLeast,0x21000000,0xFF000000);
					CtrigX(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+i,AtMost,0x7E000000,0xFF000000);
				},
				actions = {
					SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+i,Add,Mask[7],Mask[3]);
				},
				flag = {Preserved}
			}
		end
	end
end

function CA__DwItoName(SVA1,TargetPlayer,Output,Init,Color)
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)
	local Base
	if TargetPlayer == "Host" then
		Base = 0x6D0F78
	else
		Base = 0x6D0FDC+0x24*TargetPlayer
	end

	if Color == nil then
		Color = 0x0D
	end

	if Init == nil then
		Init = "\x0D"
	end
	Init = string.byte(Init,1)

	local Box1 = {}
	if Output ~= nil then
		if type(Output) == "number" then
			table.insert(Box1,SetMemory(Output,SetTo,0))
		elseif Output[4] == "V" then
			table.insert(Box1,SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,0))
		else
			table.insert(Box1,SetCtrig1X(Output[1],Output[2],Output[3],Output[4],SetTo,0))
		end
	end
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5],SetTo,Color,0xFF);
			Box1;
		},
		flag = {Preserved}
	}				

	for i = 1, 15 do
		local Temp = i%4
		local Next = math.floor(i/4)
		local Mask, InitX
		if Temp == 0 then
			Mask = 0xFF
			InitX = Init
			f_ReadX(PlayerID,Base +0x4*(Next-1),{SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+Next},"-3",0xFF000000)
		elseif Temp == 1 then
			Mask = 0xFF00
			InitX = bit32.lshift(Init,8)
			f_ReadX(PlayerID,Base +0x4*Next,{SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+Next},"+1",0xFF)
		elseif Temp == 2 then
			Mask = 0xFF0000
			InitX = bit32.lshift(Init,16)
			f_ReadX(PlayerID,Base +0x4*Next,{SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+Next},"+1",0xFF00)
		else
			Mask = 0xFF000000
			InitX = bit32.lshift(Init,24)
			f_ReadX(PlayerID,Base +0x4*Next,{SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+Next},"+1",0xFF0000)
		end

		local Box2 = {}
		if Output ~= nil then
			if type(Output) == "number" then
				table.insert(Box2,SetMemory(Output,SetTo,i))
			elseif Output[4] == "V" then
				table.insert(Box2,SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,i))
			else
				table.insert(Box2,SetCtrig1X(Output[1],Output[2],Output[3],Output[4],SetTo,i))
			end
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					MemoryB(Base+i-1,AtLeast,1);
				},
				actions = {
					Box2,
				},
				flag = {Preserved}
			}
		end

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					MemoryB(Base+i-1,Exactly,0);
				},
				actions = {
					SetCtrig1X(SVA1[1],SVA1[2],0x15C,SVA1[3]+SVA1[5]+Next,SetTo,InitX,Mask);
				},
				flag = {Preserved}
		}
	end
end

EncodeTable = 0
function CA__Encode(Dest,Source,Size,cp949flag) -- 1 : ->cp949 / 0 : ->utf8
	FENCDCheck = 1
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	if EncodeTable == 0 then
		EncodeTable = {"X",0xF001,0x970,0}
	end

	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	if type(Size) == "number" then
		DoActionsX(PlayerID,{SetCVar("X",FENCD[3],SetTo,Size)})
	elseif Size[4] == "V" then
		if Size[5] == nil then
			Size[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrig1X("X",FENCD[3],0x15C,0,SetTo,Size[5]);
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FENCD[3],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end
	
	if Dest[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FENCD[1],0x15C,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]+Dest[5]);
			},
			flag = {Preserved}
		}
	
	elseif Dest[4] == "VA" then -- Dest[5]604
		if Dest[5][5] == nil then
			Dest[5][5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FENCD[1],0x15C,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]+Dest[5][5]);
				SetCtrigX(Dest[5][1],Dest[5][2],0x158,Dest[5][3],SetTo,"X",FENCD[1],0x15C,1,0);
				SetCtrig1X(Dest[5][1],Dest[5][2],0x148,Dest[5][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[5][1],Dest[5][2],0x160,Dest[5][3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Dest[5][1],Dest[5][2],Dest[5][3]);
			},
			flag = {Preserved}
		}
	end

	if Source[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FENCD[2],0x15C,0,SetTo,Source[1],Source[2],0x15C,1,Source[3]+Source[5]);
			},
			flag = {Preserved}
		}
	
	elseif Source[4] == "VA" then -- Source[5]604
		if Source[5][5] == nil then
			Source[5][5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FENCD[2],0x15C,0,SetTo,Source[1],Source[2],0x15C,1,Source[3]+Source[5][5]);
				SetCtrigX(Source[5][1],Source[5][2],0x158,Source[5][3],SetTo,"X",FENCD[2],0x15C,1,0);
				SetCtrig1X(Source[5][1],Source[5][2],0x148,Source[5][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[5][1],Source[5][2],0x160,Source[5][3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Source[5][1],Source[5][2],Source[5][3]);
			},
			flag = {Preserved}
		}
	end

	if FENCDCall1 == 0 then
		Need_Include_DataTransfer()
	end
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCVar("X",FENCD[4],SetTo,cp949flag);
					SetCtrigX("X","X",0x4,0,SetTo,"X",FENCDCall1,0x0,0,0);
					SetCtrigX("X",FENCDCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}

	RecoverCp(PlayerID)
end

function CDPrint(Line,Size,Init,DisplayPlayer,Preset,CDfunc,PlayerID,Condition,PerAction,Action)
-- Preset(CA) : Line / wait(가변) / wait adder / loop counter(가변) / loop limit / Size(줄수) / Delay(가변) / Delay Adder
-- 내부변수(CB) : SV54 epd(+0x15C) / SV54 Size = 54 / DisplayLine (0x640B58) / display off 

CIf(PlayerID,Condition,Action)
	
	local CA = {} -- 8-1
	local CB = {} -- 4
	local CTemp

	if Preset[2] == nil then
		Preset[2] = 0
	end
	if Preset[3] == nil then
		Preset[3] = 0
	end
	if Preset[4] == nil then
		Preset[4] = 0
	end
	if Preset[5] == nil or Preset[5] == 0 then
		Preset[5] = 1
	end
	if Preset[7] == nil then
		Preset[7] = 0
	end
	if Preset[8] == nil then
		Preset[8] = 0
	end

	for i = 1, 8 do -- CA : Preset
		if i ~= 6 and i ~= 1 then
			if type(Preset[i]) == "number" then 
				CTemp = CreateVar2(PlayerID,nil,SetTo,Preset[i])
			else
				CTemp = CreateVar(PlayerID)
			end
		else
			CTemp = CreateVar(PlayerID)
		end
		table.insert(CA,CTemp)
	end
	CB = CreateVarArr(4,PlayerID)
	-------- Preset Limit --------------------------------
	for i = 1, 8 do
		if i ~= 6 and i ~= 1 then
			if type(Preset[i]) ~= "number" then
				CMov(PlayerID,CA[i],Preset[i])
			end
		end
	end

	DoActionsX(PlayerID,{SetNVar(CB[3],SetTo,0),SetNVar(CB[2],SetTo,604*11)})
	for i = 0, 3 do
		local CBit = 2^i
		Trigger {players = {PlayerID},conditions = {Label(),MemoryX(0x640B58,Exactly,CBit,CBit)},actions = {SetNVar(CB[3],Add,CBit)},flag = {Preserved}}
	end

	CAPrintPlayerID = PlayerID
	CAPrintDataArr = CA
	CAPrintCreateArr = CB

	if type(Line) == "number" then
		if Line < 0  or Line > 10 then
			CDPrint__InputData_Error()
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetNVar(CA[1],SetTo,Line);
				SetCtrigX(CB[1][1],CB[1][2],0x15C,CB[1][3],SetTo,ARet[1],ARet[2],0x15C,1,ARet[3]+1+Line);
			},
			flag = {Preserved}
		}
	elseif Line[4] == "V" then -- 0 ~ 10
		if Line[5] == nil then
			Line[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetNVar(CA[1],SetTo,Line[5]);
				SetCtrigX(CB[1][1],CB[1][2],0x15C,CB[1][3],SetTo,ARet[1],ARet[2],0x15C,1,ARet[3]+1);
				SetCtrigX(Line[1],Line[2],0x158,Line[3],SetTo,CA[1][1],CA[1][2],0x15C,1,CA[1][3]);
				SetCtrig1X(Line[1],Line[2],0x148,Line[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Line[1],Line[2],0x160,Line[3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Line[1],Line[2],Line[3]);
			},
			flag = {Preserved}
		}

		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
				NVar(CA[1],AtLeast,11);
			},
			actions = {
				SetNVar(CA[1],SetTo,10);
			},
			flag = {Preserved}
		}

		for i = 0, 3 do
			local CBit = 2^i
			Trigger {players = {PlayerID},conditions = {Label(),NVar(CA[1],Exactly,CBit,CBit)},actions = {SetNVar(CB[1],Add,CBit*604)},flag = {Preserved}}
		end
	else -- DisplayLine Mode
		CD__GetLine(Line[1],CA[1])
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrigX(CB[1][1],CB[1][2],0x15C,CB[1][3],SetTo,ARet[1],ARet[2],0x15C,1,ARet[3]+1);
			},
			flag = {Preserved}
		}
		for i = 0, 3 do
			local CBit = 2^i
			Trigger {players = {PlayerID},conditions = {Label(),NVar(CA[1],Exactly,CBit,CBit)},actions = {SetNVar(CB[1],Add,CBit*604)},flag = {Preserved}}
		end
	end

	if type(Size) == "number" then
		if Size < 1 or Size > 11 then
			CDPrint__InputData_Error()
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetNVar(CA[6],SetTo,Size);
				SetCVar("X",CRet[1],SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetNVar(CA[6],SetTo,Size[5]);
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,CA[6][1],CA[6][2],0x15C,1,CA[6][3]);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
		Trigger {players = {PlayerID},conditions = {Label(),NVar(CA[6],AtLeast,12)},actions = {SetNVar(CA[6],SetTo,11)},flag = {Preserved}}
		Trigger {players = {PlayerID},conditions = {Label(),NVar(CA[6],Exactly,0)},actions = {SetNVar(CA[6],SetTo,1)},flag = {Preserved}}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrigX(CA[6][1],CA[6][2],0x158,CA[6][3],SetTo,"X",CRet[1],0x15C,1,0);
				SetCtrig1X(CA[6][1],CA[6][2],0x148,CA[6][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(CA[6][1],CA[6][2],0x160,CA[6][3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(CA[6][1],CA[6][2],CA[6][3]);
			},
			flag = {Preserved}
		}
	end

	-- Clear SVA54
	Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrig1X(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,EPD(0x6509B0));
				SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(CB[1][1],CB[1][2],CB[1][3]);
			},
			flag = {Preserved}
		}
	local Arr, Length, CValue, CMask
	if type(Init[1]) == "string" then
		Arr, Length = GetiStrArr(0,Init[1])
		CValue = Arr[1]+Arr[2]*256+Arr[3]*65536+Arr[4]*16777216
	else
		CValue = Init[1]
	end
	CMask = Init[2]
	local SMask = Init[3]
	local SMaskAct = {}
	if SMask ~= nil then
		SMaskAct = {
			SetMemory(0x6509B0,Add,-5),
			SetDeaths(CurrentPlayer,SetTo,SMask,0),
			SetMemory(0x6509B0,Add,5),
		}
	end
	CWhile(PlayerID,CVar("X",CRet[1],AtLeast,1))
		local Box = {}
		for i = 0, 15 do
			table.insert(Box,{SetDeaths(CurrentPlayer,SetTo,CValue,0),
							SetMemory(0x6509B0,Add,-5),
							SetDeaths(CurrentPlayer,SetTo,CMask,0),
							SetMemory(0x6509B0,Add,13)})
		end
		for i = 0, 2 do
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					Box,
				},
				flag = {Preserved}
			}
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetDeaths(CurrentPlayer,SetTo,CValue,0),
				SetMemory(0x6509B0,Add,-5),
				SetDeaths(CurrentPlayer,SetTo,CMask,0),
				SetMemory(0x6509B0,Add,13),
				SetDeaths(CurrentPlayer,SetTo,CValue,0),
				SetMemory(0x6509B0,Add,-5),
				SetDeaths(CurrentPlayer,SetTo,CMask,0),
				SetMemory(0x6509B0,Add,13),
				SetDeaths(CurrentPlayer,SetTo,CValue,0),
				SetMemory(0x6509B0,Add,-5),
				SetDeaths(CurrentPlayer,SetTo,CMask,0),
				SetMemory(0x6509B0,Add,13),
				SetDeaths(CurrentPlayer,SetTo,CValue,0),
				SetMemory(0x6509B0,Add,-5),
				SetDeaths(CurrentPlayer,SetTo,CMask,0),
				SetMemory(0x6509B0,Add,13),
				SetDeaths(CurrentPlayer,SetTo,CValue,0),
				SetMemory(0x6509B0,Add,-5),
				SetDeaths(CurrentPlayer,SetTo,CMask,0),
				SetMemory(0x6509B0,Add,13),

				SetDeaths(CurrentPlayer,SetTo,0,0); -- Null
				SetMemory(0x6509B0,Add,-5);
				SetDeaths(CurrentPlayer,SetTo,0xFFFFFFFF,0),
				SetMemory(0x6509B0,Add,13),

				SMaskAct,
			},
			flag = {Preserved}
		}
	CWhileEnd({SetCVar("X",CRet[1],Subtract,1),SetMemory(0x6509B0,Add,604-432)})
	RecoverCp(PlayerID)

		NWhile(PlayerID,{NVar(CA[2],Exactly,0)})
			NIfX(PlayerID,{TNVar(CA[4],AtMost,Vi(CA[5][2],-1))})
		-------------------------------------------------------------------------
				if CDfunc ~= nil then
					_G[CDfunc]()
				end
		-------------------------------------------------------------------------
				if PerAction == nil then PerAction = {} end
				table.insert(PerAction,SetNVar(CA[4],Add,1))
				CDoActionsX(PlayerID,PerAction)
			NElseX()
				CDoActions(PlayerID,{TSetNVar(CA[2],SetTo,CA[3]),SetNVar(CA[4],SetTo,0),SetNext("X",CAPrintVarAlloc)})
			NIfXEnd()
		NWhileEnd()
		Trigger {players = {PlayerID},conditions = {Label(CAPrintVarAlloc)},flag = {Preserved}}
		CAPrintVarAlloc = CAPrintVarAlloc + 1

		CIf(PlayerID,{NVar(CB[4],Exactly,0),NVar(CA[7],Exactly,0)},{TSetNVar(CA[7],SetTo,CA[8])})
			Trigger {
				players = {PlayerID},
				conditions = {
					Label();
				},
				actions = {
					SetCVar("X",CRet[1],SetTo,0);
					SetCtrig1X("X",FuncAlloc,0x178,0,SetTo,-86);
					SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X",FuncAlloc,0x178,1,0);
					SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
					SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,Add*16777216,0xFF000000);
					CallLabelAlways(CB[1][1],CB[1][2],CB[1][3]);
					SetCtrigX("X",FuncAlloc,0x15C,0,SetTo,ARet[1],ARet[2],0x0,0,ARet[3]+1);
				},
				flag = {Preserved}
			}
			for i = 0, 3 do
				local CBit = 2^i
				Trigger {players = {PlayerID},conditions = {Label(),NVar(CA[1],Exactly,CBit,CBit)},actions = {SetCtrig1X("X",FuncAlloc,0x15C,0,Add,CBit*0x970)},flag = {Preserved}}
			end

			local VariableTrig = {}
			local DisplayPlayers = {}
			if DisplayPlayer ~= nil then
				for k, v in pairs(DisplayPlayer) do
					if type(v) == "table" and v[4] == "V" then
						table.insert(VariableTrig,v)
					else
						table.insert(DisplayPlayers,v)
					end
				end
			end

			for k, v in pairs(VariableTrig) do
				CTrigger(PlayerID,{TMemory(0x512684,Exactly,v)},{SetCVar("X",CRet[1],SetTo,1)},{Preserved})
			end

			local Input = PlayerConvert2X(DisplayPlayers)
			for i = 1, 12 do
				if Input[i] == 1 then
					if i <= 8 then
						Trigger {
								players = {PlayerID},
								conditions = {
									Label();
									LocalPlayerID(i-1);
								},
								actions = {
									SetCVar("X",CRet[1],SetTo,1);
								},
								flag = {Preserved}
							}
					else
						local k = i-8
						Trigger {
								players = {PlayerID},
								conditions = {
									Label();
									LocalPlayerID("Ob"..k);
								},
								actions = {
									SetCVar("X",CRet[1],SetTo,1);
								},
								flag = {Preserved}
							}
					end
				end
			end

			Trigger {
				players = {PlayerID},
				conditions = {
					Label();
					CVar("X",CRet[1],Exactly,1);
				},
				actions = {
					SetCtrigX(CA[6][1],CA[6][2],0x158,CA[6][3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(CA[6][1],CA[6][2],0x148,CA[6][3],SetTo,0xFFFFFFFF);
					SetCtrig1X(CA[6][1],CA[6][2],0x160,CA[6][3],SetTo,SetTo*16777216,0xFF000000);
					CallLabel1(CA[6][1],CA[6][2],CA[6][3]);
				},
				flag = {Preserved}
			}

			Trigger {
				players = {PlayerID},
				conditions = {
					Label();
				},
				actions = {
					CallLabel2(CA[6][1],CA[6][2],CA[6][3]);
				},
				flag = {Preserved}
			}

			CWhile(PlayerID,CVar("X",CRet[1],AtLeast,1),SetCVar("X",CRet[1],Subtract,1))
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(FuncAlloc);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0);
						SetCtrig2X(0,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}	
			CWhileEnd({SetCtrig1X("X",FuncAlloc,0x15C,0,Add,0x970),SetCtrig1X("X",FuncAlloc,0x178,0,Add,604)})
			FuncAlloc = FuncAlloc+1
		CIfEnd()
	CIfEnd()
	DoActionsX(PlayerID,{SetNVar(CA[2],Subtract,1),SetNVar(CA[7],Subtract,1)})

	local Ret = CA, CB
	CAPrintPlayerID = {}
	CAPrintDataArr = {}
	CAPrintCreateArr = {}
	return Ret
end

function CD__GetLine(DisplayLine,Output)
	local PlayerID = CAPrintPlayerID
	CS__GetLine(PlayerID,DisplayLine,Output) 
end

function CD__GetDisplayLine(Line,Output)
	local PlayerID = CAPrintPlayerID
	CS__GetDisplayLine(PlayerID,Line,Output)
end

function CD__GetIndex(Index,Output)
	local PlayerID = CAPrintPlayerID
	CS__GetIndex(PlayerID,Index,Output) 
end

function CD__GetIndex2(Line,Index,Output)
	local PlayerID = CAPrintPlayerID
	CS__GetIndex2(PlayerID,Line,Index,Output) 
end

function CD__GetMask(Index,Output)
	local PlayerID = CAPrintPlayerID
	CS__GetMask(PlayerID,Index,Output) 
end

function CD__GetMask2(Line,Index,Output)
	local PlayerID = CAPrintPlayerID
	CS__GetMask2(PlayerID,Line,Index,Output) 
end
--[[
function CD__SetMemoryX(index,Line,Value,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	if type(Value) == "string" then
		Value = GetiStrArr(0,Value)

		if #Value == 4 then
			Value = Value[4] * 16777216 + Value[3] * 65536 + Value[2] * 256 + Value[1]
		else
			Value_Size_Overflow()
		end
	end

	if type(index) == "number" then
		if index < 0 then
			CD__SetMemoryX_InputData_Error()
		end
		if type(Line) == "number" then
			if Line < 1 or Line > 11 then
				CD__SetMemoryX_InputData_Error()
			end
			CDoActions(PlayerID,{TSetMemoryX(Vi(CB[1][2],index*8+Line*604),SetTo,Value,Mask)})
		else
			if Line[5] == nil then
				Line[5] = 0
			end
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Line[5]*604);
						},
						flag = {Preserved}
					}
				for i = 0, 3 do
					local CBit = 2^i
					Trigger {players = {PlayerID},conditions = {Label(),NVar(Line,Exactly,CBit,CBit)},actions = {SetCVar("X",CRet[2],Add,CBit*604)},flag = {Preserved}}
				end
				Trigger {players = {PlayerID},conditions = {Label(),CVar("X",CRet[2],AtLeast,12*604)},actions = {SetCVar("X",CRet[2],SetTo,11*604)},flag = {Preserved}}
				Trigger {players = {PlayerID},conditions = {Label(),CVar("X",CRet[2],Exactly,0)},actions = {SetCVar("X",CRet[2],SetTo,1*604)},flag = {Preserved}}

				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX("X",CRet[2],0x158,0,SetTo,"X","X",0x158,1,1);
							SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[2],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrig1X("X","X",0x158,1,SetTo,index*8);
							CallLabelAlways2(CB[1][1],CB[1][2],CB[1][3],"X",CRet[2],0);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetDeathsX(0,SetTo,Value,0,Mask);
						},
						flag = {Preserved}
					}
		end
	else
		local Deviation = index[5]
		if Deviation == nil then
			Deviation = 0
		end
		if type(Value) == "number" then
			if type(Line) == "number" then
				if Line < 1 or Line > 11 then
					CD__SetMemoryX_InputData_Error()
				end
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X("X","X",0x158,4,SetTo,Line*604);
							SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Deviation);
							SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X","X",0x158,1,4);
							SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(index[1],index[2],0x158,index[3],SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X(index[1],index[2],0x148,index[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(index[1],index[2],0x160,index[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							CallLabelAlways3(CB[1][1],CB[1][2],CB[1][3],index[1],index[2],index[3],"X",CRet[1],0)
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrigX("X",CRet[1],0x158,0,SetTo,"X","X",0x158,1,1);
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}

				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
							NVar(index,AtMost,53);
						},
						actions = {
							SetDeathsX(0,SetTo,Value,0,Mask);
						},
						flag = {Preserved}
					}
			else
				if Line[5] == nil then
					Line[5] = 0
				end
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Line[5]*604);
						},
						flag = {Preserved}
					}
				for i = 0, 3 do
					local CBit = 2^i
					Trigger {players = {PlayerID},conditions = {Label(),NVar(Line,Exactly,CBit,CBit)},actions = {SetCVar("X",CRet[2],Add,CBit*604)},flag = {Preserved}}
				end
				Trigger {players = {PlayerID},conditions = {Label(),CVar("X",CRet[2],AtLeast,12*604)},actions = {SetCVar("X",CRet[2],SetTo,11*604)},flag = {Preserved}}
				Trigger {players = {PlayerID},conditions = {Label(),CVar("X",CRet[2],Exactly,0)},actions = {SetCVar("X",CRet[2],SetTo,1*604)},flag = {Preserved}}

				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Deviation);
							SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X","X",0x158,1,4);
							SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX(index[1],index[2],0x158,index[3],SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X(index[1],index[2],0x148,index[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(index[1],index[2],0x160,index[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrigX("X",CRet[2],0x158,0,SetTo,"X","X",0x158,1,4);
							SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[2],0x160,0,SetTo,Add*16777216,0xFF000000);
							CallLabelAlways4(CB[1][1],CB[1][2],CB[1][3],index[1],index[2],index[3],"X",CRet[1],0,"X",CRet[2],0);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrigX("X",CRet[1],0x158,0,SetTo,"X","X",0x158,1,1);
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}

				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
							NVar(index,AtMost,53);
						},
						actions = {
							SetDeathsX(0,SetTo,Value,0,Mask);
						},
						flag = {Preserved}
					}
			end
		else
			local CDeviation = Value[5]
			if CDeviation == nil then
				CDeviation = 0
			end
			if type(Line) == "number" then
				if Line < 1 or Line > 11 then
					CD__SetMemoryX_InputData_Error()
				end
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X("X","X",0x158,4,SetTo,Line*604);
							SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Deviation);
							SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X","X",0x158,1,4);
							SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(index[1],index[2],0x158,index[3],SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X(index[1],index[2],0x148,index[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(index[1],index[2],0x160,index[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							CallLabelAlways3(CB[1][1],CB[1][2],CB[1][3],index[1],index[2],index[3],"X",CRet[1],0)
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrigX("X",CRet[1],0x158,0,SetTo,"X","X",0x158,1,1);
							SetCtrig1X("X","X",0x15C,1,SetTo,CDeviation);
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x15C,1,1);
							SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways2("X",CRet[1],0,Value[1],Value[2],Value[3]);
						},
						flag = {Preserved}
					}

				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
							NVar(index,AtMost,53);
						},
						actions = {
							SetDeathsX(0,SetTo,0,0,Mask);
						},
						flag = {Preserved}
					}
			else
				if Line[5] == nil then
					Line[5] = 0
				end
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Line[5]*604);
						},
						flag = {Preserved}
					}
				for i = 0, 3 do
					local CBit = 2^i
					Trigger {players = {PlayerID},conditions = {Label(),NVar(Line,Exactly,CBit,CBit)},actions = {SetCVar("X",CRet[2],Add,CBit*604)},flag = {Preserved}}
				end
				Trigger {players = {PlayerID},conditions = {Label(),CVar("X",CRet[2],AtLeast,12*604)},actions = {SetCVar("X",CRet[2],SetTo,11*604)},flag = {Preserved}}
				Trigger {players = {PlayerID},conditions = {Label(),CVar("X",CRet[2],Exactly,0)},actions = {SetCVar("X",CRet[2],SetTo,1*604)},flag = {Preserved}}

				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Deviation);
							SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X","X",0x158,1,4);
							SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX(index[1],index[2],0x158,index[3],SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X(index[1],index[2],0x148,index[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(index[1],index[2],0x160,index[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrigX("X",CRet[2],0x158,0,SetTo,"X","X",0x158,1,4);
							SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[2],0x160,0,SetTo,Add*16777216,0xFF000000);
							CallLabelAlways4(CB[1][1],CB[1][2],CB[1][3],index[1],index[2],index[3],"X",CRet[1],0,"X",CRet[2],0);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							CallLabelAlways("X",CRet[1],0);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrigX("X",CRet[1],0x158,0,SetTo,"X","X",0x158,1,1);
							SetCtrig1X("X","X",0x15C,1,SetTo,CDeviation);
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x15C,1,1);
							SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways2("X",CRet[1],0,Value[1],Value[2],Value[3]);
						},
						flag = {Preserved}
					}

				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
							NVar(index,AtMost,53);
						},
						actions = {
							SetDeathsX(0,SetTo,0,0,Mask);
						},
						flag = {Preserved}
					}
			end
		end
	end
end

function CD__Read(Index,Line,Output,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	if type(Line) == "number" then
		if Line < 1 or Line > 11 then
			CD__Read_InputData_Error()
		end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label();
				},
				actions = {
					SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Line*604);
				},
				flag = {Preserved}
			}
	else
		if Line[5] == nil then
			Line[5] = 0
		end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label();
				},
				actions = {
					SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Line[5]*604);
				},
				flag = {Preserved}
			}
		for i = 0, 3 do
			local CBit = 2^i
			Trigger {players = {PlayerID},conditions = {Label(),NVar(Line,Exactly,CBit,CBit)},actions = {SetCVar("X",CRet[2],Add,CBit*604)},flag = {Preserved}}
		end
		Trigger {players = {PlayerID},conditions = {Label(),CVar("X",CRet[2],AtLeast,12*604)},actions = {SetCVar("X",CRet[2],SetTo,11*604)},flag = {Preserved}}
		Trigger {players = {PlayerID},conditions = {Label(),CVar("X",CRet[2],Exactly,0)},actions = {SetCVar("X",CRet[2],SetTo,1*604)},flag = {Preserved}}
	end

	f_Read(PlayerID,_Add(_Add(CB[1],_lShift(Index,3)),V(CRet[2])),Output,nil,Mask)
end

function CD__ReadX(Index,Line,Output,Multiplier,Mask)
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	if type(Line) == "number" then
		if Line < 1 or Line > 11 then
			CD__ReadX_InputData_Error()
		end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label();
				},
				actions = {
					SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Line*604);
				},
				flag = {Preserved}
			}
	else
		if Line[5] == nil then
			Line[5] = 0
		end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label();
				},
				actions = {
					SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Line[5]*604);
				},
				flag = {Preserved}
			}
		for i = 0, 3 do
			local CBit = 2^i
			Trigger {players = {PlayerID},conditions = {Label(),NVar(Line,Exactly,CBit,CBit)},actions = {SetCVar("X",CRet[2],Add,CBit*604)},flag = {Preserved}}
		end
		Trigger {players = {PlayerID},conditions = {Label(),CVar("X",CRet[2],AtLeast,12*604)},actions = {SetCVar("X",CRet[2],SetTo,11*604)},flag = {Preserved}}
		Trigger {players = {PlayerID},conditions = {Label(),CVar("X",CRet[2],Exactly,0)},actions = {SetCVar("X",CRet[2],SetTo,1*604)},flag = {Preserved}}
	end

	f_ReadX(PlayerID,_Add(_Add(CB[1],_lShift(Index,3)),V(CRet[2])),Output,Multiplier,Mask)
end
]]--

function CD__InputVAX(Index,SVA1,Size,Mask,DestMask,Start,End,SourceDistance) -- SVA1 -> SVA32/54 (With DestMask)
	local BoxM = {}
	if Mask ~= nil then
		BoxM = {SetDeaths(0,SetTo,Mask,0)} -- Mask
	else
		BoxM = {Disabled(SetDeaths(0,SetTo,0,0))} -- Mask
	end

	if SourceDistance == nil then
		SourceDistance = 1
	end
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)
	local INVA = {CRet[1]} -- Size

	-- Input Var
	if type(Size) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",INVA[1],0x15C,0,SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "V" then
		if Size[5] == nil then
			Size[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",INVA[1],0x15C,0,SetTo,Size[5]);
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",INVA[1],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	-- Get Start Curindex
	if type(Index) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				FSetMemory(0x6509B0,SetTo,Index);
				SetCtrig1X(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,EPD(0x6509B0));
				SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(CB[1][1],CB[1][2],CB[1][3]);
			},
			flag = {Preserved}
		}
	elseif Index[4] == "V" then
		if Index[5] == nil then
			Index[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				FSetMemory(0x6509B0,SetTo,Index[5]);
				SetCtrig1X(Index[1],Index[2],0x158,Index[3],SetTo,EPD(0x6509B0));
				SetCtrig1X(Index[1],Index[2],0x148,Index[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Index[1],Index[2],0x160,Index[3],SetTo,Add*16777216,0xFF000000);
				SetCtrig1X(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,EPD(0x6509B0));
				SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways2(Index[1],Index[2],Index[3],CB[1][1],CB[1][2],CB[1][3]);
			},
			flag = {Preserved}
		}
	end

	-- Get Start & END
	if type(Start) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FuncAlloc,0x24,0,SetTo,Start);
				SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X",FuncAlloc,0x24,1,0);
				SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(CB[1][1],CB[1][2],CB[1][3]);
			},
			flag = {Preserved}
		}
	elseif Start[4] == "V" then
		if Start[5] == nil then
			Start[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FuncAlloc,0x24,0,SetTo,Start[5]);
				SetCtrigX(Start[1],Start[2],0x158,Start[3],SetTo,"X",FuncAlloc,0x24,1,0);
				SetCtrig1X(Start[1],Start[2],0x148,Start[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Start[1],Start[2],0x160,Start[3],SetTo,Add*16777216,0xFF000000);
				SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X",FuncAlloc,0x24,1,0);
				SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways2(Start[1],Start[2],Start[3],CB[1][1],CB[1][2],CB[1][3]);
			},
			flag = {Preserved}
		}
	end

	if type(End) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FuncAlloc,0x38,0,SetTo,End);
				SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X",FuncAlloc,0x38,1,0);
				SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(CB[1][1],CB[1][2],CB[1][3]);
			},
			flag = {Preserved}
		}
	elseif End[4] == "V" then
		if End[5] == nil then
			End[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FuncAlloc,0x38,0,SetTo,End[5]);
				SetCtrigX(End[1],End[2],0x158,End[3],SetTo,"X",FuncAlloc,0x38,1,0);
				SetCtrig1X(End[1],End[2],0x148,End[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(End[1],End[2],0x160,End[3],SetTo,Add*16777216,0xFF000000);
				SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X",FuncAlloc,0x38,1,0);
				SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways2(End[1],End[2],End[3],CB[1][1],CB[1][2],CB[1][3]);
			},
			flag = {Preserved}
		}
	end

	-- Set Call VA
	if SVA1[4] == "V" then
		if Mask == nil then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FuncAlloc,0x158,0,SetTo,SVA1[1],SVA1[2],0x164,1,SVA1[3]); 
					SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,SVA1[1],SVA1[2],0,0,SVA1[3]); 
					SetCtrigX("X",FuncAlloc,0x178,1,SetTo,SVA1[1],SVA1[2],0x4,1,SVA1[3]);
					SetCtrigX("X",FuncAlloc,0x48,0,SetTo,SVA1[1],SVA1[2],0x148,1,SVA1[3]);  
					SetCtrig1X("X",FuncAlloc,0x158,0,Add,SVA1[5]*604);
					SetCtrig1X("X",FuncAlloc,0x15C,1,Add,SVA1[5]*0x970);
					SetCtrig1X("X",FuncAlloc,0x178,1,Add,SVA1[5]*604);
					SetCtrig1X("X",FuncAlloc,0x48,0,Add,SVA1[5]*604);
				},
				flag = {Preserved}
			}
		else
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FuncAlloc,0x158,0,SetTo,SVA1[1],SVA1[2],0x164,1,SVA1[3]); 
					SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,SVA1[1],SVA1[2],0,0,SVA1[3]); 
					SetCtrigX("X",FuncAlloc,0x178,1,SetTo,SVA1[1],SVA1[2],0x4,1,SVA1[3]);
					SetCtrigX("X",FuncAlloc,0x178,0,SetTo,SVA1[1],SVA1[2],0x148,1,SVA1[3]);  
					SetCtrig1X("X",FuncAlloc,0x158,0,Add,SVA1[5]*604);
					SetCtrig1X("X",FuncAlloc,0x15C,1,Add,SVA1[5]*0x970);
					SetCtrig1X("X",FuncAlloc,0x178,1,Add,SVA1[5]*604);
					SetCtrig1X("X",FuncAlloc,0x178,0,Add,SVA1[5]*604);
				},
				flag = {Preserved}
			}
		end
	elseif SVA1[4] == "VA" then -- SVA1[5]604
		if SVA1[5][5] == nil then
			SVA1[5][5] = 0
		end
		if Mask == nil then
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",FuncAlloc,0x158,0,SetTo,SVA1[1],SVA1[2],0x164,1,SVA1[3]); 
						SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,SVA1[1],SVA1[2],0,0,SVA1[3]); 
						SetCtrigX("X",FuncAlloc,0x178,1,SetTo,SVA1[1],SVA1[2],0x4,1,SVA1[3]); 
						SetCtrigX("X",FuncAlloc,0x48,0,SetTo,SVA1[1],SVA1[2],0x148,1,SVA1[3]); 
						SetCtrig1X("X",FuncAlloc,0x158,0,Add,SVA1[5][5]*604);
						SetCtrig1X("X",FuncAlloc,0x15C,1,Add,SVA1[5][5]*0x970);
						SetCtrig1X("X",FuncAlloc,0x178,1,Add,SVA1[5][5]*604);
						SetCtrig1X("X",FuncAlloc,0x48,0,Add,SVA1[5][5]*604);
						SetCtrigX(SVA1[5][1],SVA1[5][2],0x158,SVA1[5][3],SetTo,"X","X",0x15C,1,1);
						SetCtrig1X(SVA1[5][1],SVA1[5][2],0x148,SVA1[5][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(SVA1[5][1],SVA1[5][2],0x160,SVA1[5][3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(SVA1[5][1],SVA1[5][2],SVA1[5][3]);
						SetCtrigX("X","X",0x158,1,SetTo,"X","X",0x17C,1,1);
						SetCtrig1X("X","X",0x178,1,SetTo,0);
						SetCtrig1X("X","X",0x17C,1,SetTo,0);
						SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeaths(0,Add,0,0);
						SetDeaths(0,Add,0,0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x158,-1,SetTo,"X",FuncAlloc,0x158,1,0);
						SetCtrigX("X","X",0x178,-1,SetTo,"X","X",0x17C,1,-1);
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1);
						SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x158,-2,SetTo,"X",FuncAlloc,0x178,1,1);
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-2);
						SetCtrigX("X","X",0x4,-2,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x158,-3,SetTo,"X",FuncAlloc,0x48,1,0);
						SetCtrigX("X","X",0x178,-3,SetTo,"X",FuncAlloc,0x15C,1,1);
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-3);
						SetCtrigX("X","X",0x4,-3,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
		else
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",FuncAlloc,0x158,0,SetTo,SVA1[1],SVA1[2],0x164,1,SVA1[3]); 
						SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,SVA1[1],SVA1[2],0,0,SVA1[3]); 
						SetCtrigX("X",FuncAlloc,0x178,1,SetTo,SVA1[1],SVA1[2],0x4,1,SVA1[3]); 
						SetCtrigX("X",FuncAlloc,0x178,0,SetTo,SVA1[1],SVA1[2],0x148,1,SVA1[3]); 
						SetCtrig1X("X",FuncAlloc,0x158,0,Add,SVA1[5][5]*604);
						SetCtrig1X("X",FuncAlloc,0x15C,1,Add,SVA1[5][5]*0x970);
						SetCtrig1X("X",FuncAlloc,0x178,1,Add,SVA1[5][5]*604);
						SetCtrig1X("X",FuncAlloc,0x178,0,Add,SVA1[5][5]*604);
						SetCtrigX(SVA1[5][1],SVA1[5][2],0x158,SVA1[5][3],SetTo,"X","X",0x15C,1,1);
						SetCtrig1X(SVA1[5][1],SVA1[5][2],0x148,SVA1[5][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(SVA1[5][1],SVA1[5][2],0x160,SVA1[5][3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(SVA1[5][1],SVA1[5][2],SVA1[5][3]);
						SetCtrigX("X","X",0x158,1,SetTo,"X","X",0x17C,1,1);
						SetCtrig1X("X","X",0x178,1,SetTo,0);
						SetCtrig1X("X","X",0x17C,1,SetTo,0);
						SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeaths(0,Add,0,0);
						SetDeaths(0,Add,0,0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x158,-1,SetTo,"X",FuncAlloc,0x158,1,0);
						SetCtrigX("X","X",0x178,-1,SetTo,"X","X",0x17C,1,-1);
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-1);
						SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x158,-2,SetTo,"X",FuncAlloc,0x178,1,1);
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-2);
						SetCtrigX("X","X",0x4,-2,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x158,-3,SetTo,"X",FuncAlloc,0x178,1,0);
						SetCtrigX("X","X",0x178,-3,SetTo,"X",FuncAlloc,0x15C,1,1);
						SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,-3);
						SetCtrigX("X","X",0x4,-3,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
		end
	end

	CWhile(PlayerID,{CVar("X",INVA[1],AtLeast,1)},{SetCVar("X",INVA[1],Subtract,1)})
		if Mask == nil then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(FuncAlloc);
					FMemory(0x6509B0,AtLeast,0); -- Cp >= Start+CB[1]
					FMemory(0x6509B0,AtMost,0); -- Cp <= End+CB[1]
					Deaths(0,AtLeast,1,0);
					
				},
				actions = {
					SetDeathsX(0,SetTo,0,0,0x2); -- Enable
					BoxM,
					SetCtrig1X("X",FuncAlloc,0x164+0x20*3,1,SetTo,0x0,0x2);
				},
				flag = {Preserved}
			}
		else
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(FuncAlloc);
					FMemory(0x6509B0,AtLeast,0); -- Cp >= Start+CB[1]
					FMemory(0x6509B0,AtMost,0); -- Cp <= End+CB[1]
				},
				actions = {
					SetDeathsX(0,SetTo,0,0,0x2); -- Enable
					BoxM,
					SetCtrig1X("X",FuncAlloc,0x164+0x20*3,1,SetTo,0x0,0x2);
				},
				flag = {Preserved}
			}
		end
		-- Ctrig->Ctrig->Ctrig Version : Cp사용 X
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- "X"->VA
					SetCtrig2X(0,SetTo,"X","X",0,0,1); -- VA->"X"+1
					FSetMemory(0x6509B0,Subtract,5);
					Disabled(SetDeaths(CurrentPlayer,SetTo,DestMask,0));
					FSetMemory(0x6509B0,Add,5);
					SetCtrig1X("X","X",0x164+0x20*3,0,SetTo,0x2,0x2);
				},
				flag = {Preserved}
			}
	if Mask == nil then
		CWhileEnd({SetCtrig1X("X",FuncAlloc,0x158,0,Add,604*SourceDistance),SetCtrig1X("X",FuncAlloc,0x15C,1,Add,0x970*SourceDistance),SetCtrig1X("X",FuncAlloc,0x178,1,Add,604*SourceDistance),SetCtrig1X("X",FuncAlloc,0x48,0,Add,604*SourceDistance)})
	else
		CWhileEnd({SetCtrig1X("X",FuncAlloc,0x158,0,Add,604*SourceDistance),SetCtrig1X("X",FuncAlloc,0x15C,1,Add,0x970*SourceDistance),SetCtrig1X("X",FuncAlloc,0x178,1,Add,604*SourceDistance),SetCtrig1X("X",FuncAlloc,0x178,0,Add,604*SourceDistance)})
	end
	FuncAlloc = FuncAlloc + 1
	-- RecoverCp
	RecoverCp(PlayerID)
end

function CD__InputMask(Line,Mask,Start,End)
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrig1X(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,EPD(0x6509B0));
				SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(CB[1][1],CB[1][2],CB[1][3]);
			},
			flag = {Preserved}
		}
	Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X",IndexAlloc,0x24,1,0);
				SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(CB[1][1],CB[1][2],CB[1][3]);
			},
			flag = {Preserved}
		}
		if type(Line) == "number" then
			if Line > 10 then
				CD__InputMask_Error()
			end
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetMemory(0x6509B0,Add,Line*604);
					SetCtrig1X("X",IndexAlloc,0x24,0,Add,Line*604);
				},
				flag = {Preserved}
			}
		elseif Line[4] == "V" then 
			for i = 0, 3 do
				local CBit = 2^i
				local NBit = CBit*604
				Trigger {players = {PlayerID},conditions = {Label(),NVar(Line,Exactly,CBit,CBit)}
					,actions = {SetMemory(0x6509B0,Add,NBit),SetCtrig1X("X",IndexAlloc,0x24,0,Add,NBit)},flag = {Preserved}}
			end
		end

		if type(Start) == "number" then
			if Start > 53 then
				CD__InputMask_Error()
			end
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetMemory(0x6509B0,Add,Start*8-5);
				},
				flag = {Preserved}
			}
		elseif Start[4] == "V" then -- Start8
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Start[1],Start[2],0x158,Start[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Start[1],Start[2],0x148,Start[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Start[1],Start[2],0x160,Start[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
					CallLabelAlways2(Start[1],Start[2],Start[3],"X",CRet[1],0);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabelAlways("X",CRet[1],0);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabelAlways("X",CRet[1],0);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Add,-5);
					SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
					SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
					CallLabelAlways("X",CRet[1],0);
				},
				flag = {Preserved}
			}
		end
		if type(End) == "number" then
			if End > 53 then
				CD__InputMask_Error()
			end
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",IndexAlloc,0x24,0,Add,End*8-5);
				},
				flag = {Preserved}
			}
		elseif End[4] == "V" then -- End8
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(End[1],End[2],0x158,End[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(End[1],End[2],0x148,End[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(End[1],End[2],0x160,End[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
					CallLabelAlways2(End[1],End[2],End[3],"X",CRet[1],0);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabelAlways("X",CRet[1],0);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabelAlways("X",CRet[1],0);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Add,-5);
					SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",IndexAlloc,0x24,1,0);
					SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
					CallLabelAlways("X",CRet[1],0);
				},
				flag = {Preserved}
			}
		end
		if type(Mask) == "number" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",IndexAlloc,0x17C,0,SetTo,Mask);
				},
				flag = {Preserved}
			}
		elseif Mask[4] == "V" then -- Mask
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Mask[1],Mask[2],0x158,Mask[3],SetTo,"X",IndexAlloc,0x17C,1,0);
					SetCtrig1X(Mask[1],Mask[2],0x148,Mask[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Mask[1],Mask[2],0x160,Mask[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Mask[1],Mask[2],Mask[3]);
				},
				flag = {Preserved}
			}
		end
		CWhile(PlayerID,{FMemory(0x6509B0,AtMost,0)},{SetDeaths(CurrentPlayer,SetTo,0,0)})
		CWhileEnd({FSetMemory(0x6509B0,Add,8)})

		RecoverCp(PlayerID)
end

function CD__Resize(Line,Status) -- 0x0D0D0A -> Letter
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)
	if Status == "On" or Status == 1 then
		CA__SetMemoryX(_GIndex2(Line,0),0x0A0D0D0D,0xFFFFFFFF)
	elseif Status == "Off" or Status == 0 then
		CA__SetMemoryX(_GIndex2(Line,0),0x0D0D0D0D,0xFFFFFFFF)
	elseif Status[4] == "V" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label();
					NVar(Status,Exactly,0);
				},
				actions = {
					SetCVar("X",CRet[10],SetTo,0x0D0D0D0D);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {PlayerID},
				conditions = {
					Label();
					NVar(Status,AtLeast,1);
				},
				actions = {
					SetCVar("X",CRet[10],SetTo,0x0A0D0D0D);
				},
				flag = {Preserved}
			}
		CA__SetMemoryX(_GIndex2(Line,0),V(CRet[10]),0xFFFFFFFF)
	else
		CD__Resize_InputData_Error()
	end
end

function CD__SetMaskX(index,Mask)
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	if type(index) == "number" then
		if index < 0 then
			CD__SetMaskX_InputData_Error()
		end
		CTrigger(PlayerID,{NVar(CB[2],AtLeast,index+1)},{TSetMemory(Vi(CB[1][2],index-5),SetTo,Mask)},{Preserved})
	else
		local Deviation = index[5]
		if Deviation == nil then
			Deviation = 0
		end
		if type(Mask) == "number" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X(index[1],index[2],0x15C,index[3],Add,Deviation);
							SetCtrig1X("X","X",0x24,1,SetTo,-1);
							SetCtrig1X("X","X",0x158,1,SetTo,-5);
							SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(index[1],index[2],0x158,index[3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(index[1],index[2],0x148,index[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(index[1],index[2],0x160,index[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(CB[2][1],CB[2][2],0x158,CB[2][3],SetTo,"X","X",0x24,1,1);
							SetCtrig1X(CB[2][1],CB[2][2],0x148,CB[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[2][1],CB[2][2],0x160,CB[2][3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways3(CB[1][1],CB[1][2],CB[1][3],index[1],index[2],index[3],CB[2][1],CB[2][2],CB[2][3])
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
							NVar(index,AtMost,0);
						},
						actions = {
							SetDeaths(0,SetTo,Mask,0);
						},
						flag = {Preserved}
					}
				DoActionsX(PlayerID,SetCtrig1X(index[1],index[2],0x15C,index[3],Add,-Deviation))
		else
			local CDeviation = Mask[5]
			if CDeviation == nil then
				CDeviation = 0
			end
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X(index[1],index[2],0x15C,index[3],Add,Deviation);
							SetCtrig1X("X","X",0x24,1,SetTo,-1);
							SetCtrig1X("X","X",0x158,1,SetTo,-5);
							SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(index[1],index[2],0x158,index[3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(index[1],index[2],0x148,index[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(index[1],index[2],0x160,index[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(CB[2][1],CB[2][2],0x158,CB[2][3],SetTo,"X","X",0x24,1,1);
							SetCtrig1X(CB[2][1],CB[2][2],0x148,CB[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[2][1],CB[2][2],0x160,CB[2][3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X("X","X",0x15C,1,SetTo,CDeviation);
							SetCtrigX(Mask[1],Mask[2],0x158,Mask[3],SetTo,"X","X",0x15C,1,1);
							SetCtrig1X(Mask[1],Mask[2],0x148,Mask[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Mask[1],Mask[2],0x160,Mask[3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways4(CB[1][1],CB[1][2],CB[1][3],index[1],index[2],index[3],CB[2][1],CB[2][2],CB[2][3],Mask[1],Mask[2],Mask[3])
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
							NVar(index,AtMost,0);
						},
						actions = {
							SetDeaths(0,SetTo,0,0);
						},
						flag = {Preserved}
					}
				DoActionsX(PlayerID,SetCtrig1X(index[1],index[2],0x15C,index[3],Add,-Deviation))
		end
	end
end

function CD__ScanV(SVA1,Size,Variable,Output,Base,Sign) -- iutf8(SVA1) -> V
	FSCANVCheck = 1
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	if type(Size) == "number" then
		DoActionsX(PlayerID,{SetCVar("X",FSCANV[7],SetTo,Size)})
	elseif Size[4] == "V" then
		if Size[5] == nil then
			Size[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrig1X("X",FSCANV[7],0x15C,0,SetTo,Size[5]);
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FSCANV[7],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if type(Base) == "number" then
		DoActionsX(PlayerID,{SetCVar("X",FSCANV[1],SetTo,Base)})
	elseif Base[4] == "V" then
		if Base[5] == nil then
			Base[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrig1X("X",FSCANV[1],0x15C,0,SetTo,Base[5]);
				SetCtrigX(Base[1],Base[2],0x158,Base[3],SetTo,"X",FSCANV[1],0x15C,1,0);
				SetCtrig1X(Base[1],Base[2],0x148,Base[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Base[1],Base[2],0x160,Base[3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Base[1],Base[2],Base[3]);
			},
			flag = {Preserved}
		}
	end
	
	if type(Sign) == "number" then
		DoActionsX(PlayerID,{SetCVar("X",FSCANV[2],SetTo,Sign)})
	elseif Sign[4] == "V" then
		if Sign[5] == nil then
			Sign[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrig1X("X",FSCANV[2],0x15C,0,SetTo,Sign[5]);
				SetCtrigX(Sign[1],Sign[2],0x158,Sign[3],SetTo,"X",FSCANV[2],0x15C,1,0);
				SetCtrig1X(Sign[1],Sign[2],0x148,Sign[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Sign[1],Sign[2],0x160,Sign[3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Sign[1],Sign[2],Sign[3]);
			},
			flag = {Preserved}
		}
	end

	if SVA1[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FSCANV[3],0x15C,0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+SVA1[5]);
				SetCVar("X",FSCANV[5],SetTo,SVA1[5]*604+604);
			},
			flag = {Preserved}
		}
	
	elseif SVA1[4] == "VA" then -- SVA1[5]604
		if SVA1[5][5] == nil then
			SVA1[5][5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FSCANV[3],0x15C,0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+SVA1[5][5]);
				SetCtrigX(SVA1[5][1],SVA1[5][2],0x158,SVA1[5][3],SetTo,"X",FSCANV[3],0x15C,1,0);
				SetCtrig1X(SVA1[5][1],SVA1[5][2],0x148,SVA1[5][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(SVA1[5][1],SVA1[5][2],0x160,SVA1[5][3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(SVA1[5][1],SVA1[5][2],SVA1[5][3]);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCVar("X",FSCANV[5],SetTo,SVA1[5][5]*604+604);
				SetCtrigX(SVA1[5][1],SVA1[5][2],0x158,SVA1[5][3],SetTo,"X",FSCANV[5],0x15C,1,0);
				CallLabelAlways(SVA1[5][1],SVA1[5][2],SVA1[5][3]);
			},
			flag = {Preserved}
		}
	end

	if FSCANVCall1 == 0 then
		Need_Include_DataTransfer()
	end
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FSCANVCall1,0x0,0,0);
					SetCtrigX("X",FSCANVCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	

		local Box = {}
		if type(Variable) == "number" then
			table.insert(Box,SetCtrig1X("X",FSCANV[4],0x158,0,SetTo,EPD(Variable)))
		elseif Variable[4] == "V" then
			table.insert(Box,SetCtrigX("X",FSCANV[4],0x158,0,SetTo,Variable[1],Variable[2],0x15C,1,Variable[3]))
		else
			table.insert(Box,SetCtrigX("X",FSCANV[4],0x158,0,SetTo,Variable[1],Variable[2],Variable[3],1,Variable[4]))
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				Box;
				SetCtrig1X("X",FSCANV[4],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",FSCANV[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",FSCANV[4],0);
			},
			flag = {Preserved}
		}

	if Output ~= nil then
		local Box = {}
		if type(Output) == "number" then
			table.insert(Box,SetCtrig1X("X",FSCANV[5],0x158,0,SetTo,EPD(Output)))
		elseif Output[4] == "V" then
			table.insert(Box,SetCtrigX("X",FSCANV[5],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]))
		else
			table.insert(Box,SetCtrigX("X",FSCANV[5],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]))
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				Box;
				SetCtrig1X("X",FSCANV[5],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",FSCANV[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",FSCANV[5],0);
			},
			flag = {Preserved}
		}
	end

	RecoverCp(PlayerID)
end

function CD__ScanW(SVA1,Size,Wariable,Output,Base,Sign) -- iutf8(SVA1) -> W
	FSCANWCheck = 1
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	if type(Size) == "number" then
		DoActionsX(PlayerID,{SetCVar("X",FSCANW[7],SetTo,Size)})
	elseif Size[4] == "V" then
		if Size[5] == nil then
			Size[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrig1X("X",FSCANW[7],0x15C,0,SetTo,Size[5]);
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FSCANW[7],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if type(Base) == "number" then
		DoActionsX(PlayerID,{SetCVar("X",FSCANW[1],SetTo,Base)})
	elseif Base[4] == "V" then
		if Base[5] == nil then
			Base[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrig1X("X",FSCANW[1],0x15C,0,SetTo,Base[5]);
				SetCtrigX(Base[1],Base[2],0x158,Base[3],SetTo,"X",FSCANW[1],0x15C,1,0);
				SetCtrig1X(Base[1],Base[2],0x148,Base[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Base[1],Base[2],0x160,Base[3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Base[1],Base[2],Base[3]);
			},
			flag = {Preserved}
		}
	end
	
	if type(Sign) == "number" then
		DoActionsX(PlayerID,{SetCVar("X",FSCANW[2],SetTo,Sign)})
	elseif Sign[4] == "V" then
		if Sign[5] == nil then
			Sign[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrig1X("X",FSCANW[2],0x15C,0,SetTo,Sign[5]);
				SetCtrigX(Sign[1],Sign[2],0x158,Sign[3],SetTo,"X",FSCANW[2],0x15C,1,0);
				SetCtrig1X(Sign[1],Sign[2],0x148,Sign[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Sign[1],Sign[2],0x160,Sign[3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Sign[1],Sign[2],Sign[3]);
			},
			flag = {Preserved}
		}
	end

	if SVA1[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FSCANW[3],0x15C,0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+SVA1[5]);
				SetCVar("X",FSCANW[5],SetTo,SVA1[5]*604+604);
			},
			flag = {Preserved}
		}
	
	elseif SVA1[4] == "VA" then -- SVA1[5]604
		if SVA1[5][5] == nil then
			SVA1[5][5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FSCANW[3],0x15C,0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+SVA1[5][5]);
				SetCtrigX(SVA1[5][1],SVA1[5][2],0x158,SVA1[5][3],SetTo,"X",FSCANW[3],0x15C,1,0);
				SetCtrig1X(SVA1[5][1],SVA1[5][2],0x148,SVA1[5][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(SVA1[5][1],SVA1[5][2],0x160,SVA1[5][3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(SVA1[5][1],SVA1[5][2],SVA1[5][3]);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCVar("X",FSCANW[5],SetTo,SVA1[5][5]*604+604);
				SetCtrigX(SVA1[5][1],SVA1[5][2],0x158,SVA1[5][3],SetTo,"X",FSCANW[5],0x15C,1,0);
				CallLabelAlways(SVA1[5][1],SVA1[5][2],SVA1[5][3]);
			},
			flag = {Preserved}
		}
	end

	if FSCANWCall1 == 0 then
		Need_Include_DataTransfer()
	end
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FSCANWCall1,0x0,0,0);
					SetCtrigX("X",FSCANWCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrigX("X",FSCANW[4],0x158,0,SetTo,Wariable[1],Wariable[2],0x15C,1,Wariable[3]);
				SetCtrigX("X",FSCANW[4],0x198,0,SetTo,Wariable[1],Wariable[2],0x19C,1,Wariable[3]);
				SetCtrig1X("X",FSCANW[4],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",FSCANW[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",FSCANW[4],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",FSCANW[4],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",FSCANW[4],0);
			},
			flag = {Preserved}
		}

	if Output ~= nil then
		local Box = {}
		if type(Output) == "number" then
			table.insert(Box,SetCtrig1X("X",FSCANW[5],0x158,0,SetTo,EPD(Output)))
		elseif Output[4] == "V" then
			table.insert(Box,SetCtrigX("X",FSCANW[5],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]))
		else
			table.insert(Box,SetCtrigX("X",FSCANW[5],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]))
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				Box;
				SetCtrig1X("X",FSCANW[5],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",FSCANW[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",FSCANW[5],0);
			},
			flag = {Preserved}
		}
	end

	RecoverCp(PlayerID)
end
--[[
function CD__ScanName(SVA1,Size,Output,Dest,DestDistance) -- icp949 -> cp949(Letter)
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	if SVA1[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCVar("X",FNAME[5],SetTo,SVA1[5]*604);
				SetCtrig2X(0x6509B0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+SVA1[5]);
			},
			flag = {Preserved}
		}
	elseif SVA1[4] == "VA" then
		if SVA1[5][5] == nil then
			SVA1[5][5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCVar("X",FNAME[5],SetTo,SVA1[5][5]*604);
				SetCtrigX(SVA1[5][1],SVA1[5][2],0x158,SVA1[5][3],SetTo,"X",FNAME[5],0x15C,1,0);
				SetCtrig1X(SVA1[5][1],SVA1[5][2],0x148,SVA1[5][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(SVA1[5][1],SVA1[5][2],0x160,SVA1[5][3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(SVA1[5][1],SVA1[5][3],SVA1[5][3]);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrig2X(0x6509B0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+SVA1[5][5]);
				SetCtrig1X(SVA1[5][1],SVA1[5][2],0x158,SVA1[5][3],SetTo,EPD(0x6509B0));
				SetCtrig1X(SVA1[5][1],SVA1[5][2],0x148,SVA1[5][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(SVA1[5][1],SVA1[5][2],0x160,SVA1[5][3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(SVA1[5][1],SVA1[5][3],SVA1[5][3]);
			},
			flag = {Preserved}
		}
	end

	if type(Size) == "number" then
		if Size > 25 then
			Size = 25
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCVar("X",FNAME[4],SetTo,0);
				SetCVar("X",FNAME[2],SetTo,3);
				SetCVar("X",FNAME[1],SetTo,Size);
			},
			flag = {Preserved}
		}
	elseif Size[4] == "V" then
 		if Size[5] == nil then
			Size[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCVar("X",FNAME[4],SetTo,0);
				SetCVar("X",FNAME[2],SetTo,3);
				SetCVar("X",FNAME[1],SetTo,Size[5]);
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FNAME[1],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[3],Size[3]);
			},
			flag = {Preserved}
		}
		Trigger {players = {PlayerID},conditions = {Label(),CVar("X",FNAME[1],AtLeast,25)},actions = {SetCVar("X",FNAME[1],SetTo,25)},flag = {Preserved}}
	end

	if DestDistance == nil then
		DestDistance = 1
	end
	if type(Dest) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrig1X("X",FNAME[3],0x15C,0,SetTo,EPD(Dest));
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrigX("X",FNAME[3],0x15C,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
			},
			flag = {Preserved}
		}
		DestDistance = 604*DestDistance
	else
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrigX("X",FNAME[3],0x15C,0,SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
			},
			flag = {Preserved}
		}
	end

	-- Call f_ScanName
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FNAMECall1,0x0,0,0);
					SetCtrigX("X",FNAMECall2,0x4,0,SetTo,"X","X",0x0,0,1);
					SetCtrig1X("X",FNAMEArr[1],0x15C,0,SetTo,DestDistance);
					SetCtrig1X("X",FNAMEArr[2],0x15C,0,SetTo,DestDistance);
				},
				flag = {Preserved}
			}
	if FNAMECall1 == 0 then
		Need_Include_DataTransfer()
	end

	Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrigX("X",FNAME[5],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
				SetCtrig1X("X",FNAME[5],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",FNAME[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",FNAME[5],0);
			},
			flag = {Preserved}
		}
	RecoverCp(PlayerID)
end
]]--
function CA__GetName(SVA1,TargetPlayer,Output)
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)
	if TargetPlayer == "Host" then
		CD__ScanChat(SVA1,0x6D0F78,16,Output)
	elseif type(TargetPlayer) == "number" then
		CD__ScanChat(SVA1,0x6D0FDC + 0x24*TargetPlayer,16,Output)
	elseif TargetPlayer[4] == "V" then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCVar("X",NRet[16],SetTo,0x6D0FDC);
				},
				flag = {Preserved}
			}
		for i = 0, 2 do
			local CBit = 2^i
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						NVar(TargetPlayer,Exactly,CBit,CBit);
					},
					actions = {
						SetCVar("X",NRet[16],Add,0x24*CBit);
					},
					flag = {Preserved}
				}
		end
		CD__ScanChat(SVA1,V(NRet[16]),16,Output)
	end
end

function CD__ScanChat(SVA1,Offset,Size,Output,Null,SkipInit) -- utf8(Offset) -> iutf8(SVA1) 
	FCHATCheck = 1
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	if type(Offset) == "number" then
		DoActionsX(PlayerID,{SetCVar("X",FCHAT[2],SetTo,Offset)})
	elseif Offset[4] == "V" then
		if Offset[5] == nil then
			Offset[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrig1X("X",FCHAT[2],0x15C,0,SetTo,Offset[5]);
				SetCtrigX(Offset[1],Offset[2],0x158,Offset[3],SetTo,"X",FCHAT[2],0x15C,1,0);
				SetCtrig1X(Offset[1],Offset[2],0x148,Offset[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Offset[1],Offset[2],0x160,Offset[3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Offset[1],Offset[2],Offset[3]);
			},
			flag = {Preserved}
		}
	end
	
	if type(Size) == "number" then
		DoActionsX(PlayerID,{SetCVar("X",FCHAT[1],SetTo,Size)})
	elseif Size[4] == "V" then
		if Size[5] == nil then
			Size[5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				SetCtrig1X("X",FCHAT[1],0x15C,0,SetTo,Size[5]);
				SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,"X",FCHAT[1],0x15C,1,0);
				SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(Size[1],Size[2],Size[3]);
			},
			flag = {Preserved}
		}
	end

	if SVA1[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FCHAT[5],0x15C,0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+SVA1[5]);
			},
			flag = {Preserved}
		}
	elseif SVA1[4] == "VA" then -- SVA1[5]604
		if SVA1[5][5] == nil then
			SVA1[5][5] = 0
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",FCHAT[5],0x15C,0,SetTo,SVA1[1],SVA1[2],0x15C,1,SVA1[3]+SVA1[5][5]);
				SetCtrigX(SVA1[5][1],SVA1[5][2],0x158,SVA1[5][3],SetTo,"X",FCHAT[5],0x15C,1,0);
				SetCtrig1X(SVA1[5][1],SVA1[5][2],0x148,SVA1[5][3],SetTo,0xFFFFFFFF);
				SetCtrig1X(SVA1[5][1],SVA1[5][2],0x160,SVA1[5][3],SetTo,Add*16777216,0xFF000000);
				CallLabelAlways(SVA1[5][1],SVA1[5][2],SVA1[5][3]);
			},
			flag = {Preserved}
		}
	end

	if FCHATCall1 == 0 then
		Need_Include_DataTransfer()
	end
	local Nullv = 0
	if Null == 1 then
		Nullv = 32
	end
	local Skip = 0
	if SkipInit == 1 then
		Skip = 16
	end
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCVar("X",FCHAT[7],SetTo,Nullv+Skip);
					SetCVar("X",FCHAT[6],SetTo,0);
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCHATCall1,0x0,0,0);
					SetCtrigX("X",FCHATCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	

	if Output ~= nil then
		local Box = {}
		if type(Output) == "number" then
			table.insert(Box,SetCtrig1X("X",FCHAT[6],0x158,0,SetTo,EPD(Output)))
		elseif Output[4] == "V" then
			table.insert(Box,SetCtrigX("X",FCHAT[6],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]))
		else
			table.insert(Box,SetCtrigX("X",FCHAT[6],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]))
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				Box;
				SetCtrig1X("X",FCHAT[6],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",FCHAT[6],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",FCHAT[6],0);
			},
			flag = {Preserved}
		}
	end

	RecoverCp(PlayerID)
end

function Timer(PlayerID,Index,Init,Start,End,Step,Order,InitAction,StepCondition,StepAction,ResetCondtion,ResetAction)
	if Order == "RS" then
		Order = 1
	end
	local Type, Type2, CC=0
	if type(Step) == "number" then
		if Step > 0 then
			Type = AtLeast
			Type2 = Add
		elseif Step < 0 then
			if Start * End >= 0 then
				Type = AtMost
				Type2 = Subtract
				Step = -Step
			else
				Type = AtMost
				Type2 = Add
			end
		else
			Timer_InputData_Error()
		end

		if Init == nil then
			Init = Start
		end
		if InitAction == nil then InitAction = {} end
		if StepAction == nil then StepAction = {} end
		if ResetCondtion == nil then ResetCondtion = {} end
		if ResetAction == nil then ResetAction = {} end
		if Start * End >= 0 then
			if type(Index) == "number" then
				if InitAction == nil then
					InitAction = {SetMemory(Index,SetTo,Init)}
				elseif InitAction.__trg_magic == "action" then
					InitAction = {SetMemory(Index,SetTo,Init),InitAction}
				else
					if InitAction[1] == "X" then
						table.remove(InitAction,1)
					else
						InitAction = {SetMemory(Index,SetTo,Init),table.unpack(InitAction)}
					end
				end

				if ResetCondtion == nil then
					ResetCondtion = {Memory(Index,Type,End)}
				elseif ResetCondtion.__trg_magic == "condition" then
					ResetCondtion = {Memory(Index,Type,End),ResetCondtion}
				else
					if ResetCondtion[1] == "X" then
						table.remove(ResetCondtion,1)
					else
						ResetCondtion = {Memory(Index,Type,End),table.unpack(ResetCondtion)}
					end
				end

				if ResetAction == nil then
					ResetAction = {SetMemory(Index,SetTo,Start)}
				elseif ResetAction.__trg_magic == "action" then
					ResetAction = {SetMemory(Index,SetTo,Start),ResetAction}
				else
					if ResetAction[1] == "X" then
						table.remove(ResetAction,1)
					else
						ResetAction = {SetMemory(Index,SetTo,Start),table.unpack(ResetAction)}
					end
				end

				if StepAction == nil then
					StepAction = {SetMemory(Index,Type2,Step)}
				elseif StepAction.__trg_magic == "action" then
					StepAction = {SetMemory(Index,Type2,Step),StepAction}
				else
					if StepAction[1] == "X" then
						table.remove(StepAction,1)
					else
						StepAction = {SetMemory(Index,Type2,Step),table.unpack(StepAction)}
					end
				end
			elseif Index == nil then
				CC = CreateCcode()
				if InitAction == nil then
					InitAction = {SetCDeaths("X",SetTo,Init,CC)}
				elseif InitAction.__trg_magic == "action" then
					InitAction = {SetCDeaths("X",SetTo,Init,CC),InitAction}
				else
					if InitAction[1] == "X" then
						table.remove(InitAction,1)
					else
						InitAction = {SetCDeaths("X",SetTo,Init,CC),table.unpack(InitAction)}
					end
				end

				if ResetCondtion == nil then
					ResetCondtion = {CDeaths("X",Type,End,CC)}
				elseif ResetCondtion.__trg_magic == "condition" then
					ResetCondtion = {CDeaths("X",Type,End,CC),ResetCondtion}
				else
					if ResetCondtion[1] == "X" then
						table.remove(ResetCondtion,1)
					else
						ResetCondtion = {CDeaths("X",Type,End,CC),table.unpack(ResetCondtion)}
					end
				end

				if ResetAction == nil then
					ResetAction = {SetCDeaths("X",SetTo,Start,CC)}
				elseif ResetAction.__trg_magic == "action" then
					ResetAction = {SetCDeaths("X",SetTo,Start,CC),ResetAction}
				else
					if ResetAction[1] == "X" then
						table.remove(ResetAction,1)
					else
						ResetAction = {SetCDeaths("X",SetTo,Start,CC),table.unpack(ResetAction)}
					end
				end

				if StepAction == nil then
					StepAction = {SetCDeaths("X",Type2,Step,CC)}
				elseif StepAction.__trg_magic == "action" then
					StepAction = {SetCDeaths("X",Type2,Step,CC),StepAction}
				else
					if StepAction[1] == "X" then
						table.remove(StepAction,1)
					else
						StepAction = {SetCDeaths("X",Type2,Step,CC),table.unpack(StepAction)}
					end
				end
			elseif Index[4] == "V" then
				if InitAction == nil then
					InitAction = {SetNVar(Index,SetTo,Init)}
				elseif InitAction.__trg_magic == "action" then
					InitAction = {SetNVar(Index,SetTo,Init),InitAction}
				else
					if InitAction[1] == "X" then
						table.remove(InitAction,1)
					else
						InitAction = {SetNVar(Index,SetTo,Init),table.unpack(InitAction)}
					end
				end

				if ResetCondtion == nil then
					ResetCondtion = {NVar(Index,Type,End)}
				elseif ResetCondtion.__trg_magic == "condition" then
					ResetCondtion = {NVar(Index,Type,End),ResetCondtion}
				else
					if ResetCondtion[1] == "X" then
						table.remove(ResetCondtion,1)
					else
						ResetCondtion = {NVar(Index,Type,End),table.unpack(ResetCondtion)}
					end
				end

				if ResetAction == nil then
					ResetAction = {SetNVar(Index,SetTo,Start)}
				elseif ResetAction.__trg_magic == "action" then
					ResetAction = {SetNVar(Index,SetTo,Start),ResetAction}
				else
					if ResetAction[1] == "X" then
						table.remove(ResetAction,1)
					else
						ResetAction = {SetNVar(Index,SetTo,Start),table.unpack(ResetAction)}
					end
				end

				if StepAction == nil then
					StepAction = {SetNVar(Index,Type2,Step)}
				elseif StepAction.__trg_magic == "action" then
					StepAction = {SetNVar(Index,Type2,Step),StepAction}
				else
					if StepAction[1] == "X" then
						table.remove(StepAction,1)
					else
						StepAction = {SetNVar(Index,Type2,Step),table.unpack(StepAction)}
					end
				end
			else
				if InitAction == nil then
					InitAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Init)}
				elseif InitAction.__trg_magic == "action" then
					InitAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Init),InitAction}
				else
					if InitAction[1] == "X" then
						table.remove(InitAction,1)
					else
						InitAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Init),table.unpack(InitAction)}
					end
				end

				if ResetCondtion == nil then
					ResetCondtion = {CtrigX(Index[1],Index[2],Index[3],Index[4],Type,End)}
				elseif ResetCondtion.__trg_magic == "condition" then
					ResetCondtion = {CtrigX(Index[1],Index[2],Index[3],Index[4],Type,End),ResetCondtion}
				else
					if ResetCondtion[1] == "X" then
						table.remove(ResetCondtion,1)
					else
						ResetCondtion = {CtrigX(Index[1],Index[2],Index[3],Index[4],Type,End),table.unpack(ResetCondtion)}
					end
				end

				if ResetAction == nil then
					ResetAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Start)}
				elseif ResetAction.__trg_magic == "action" then
					ResetAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Start),ResetAction}
				else
					if ResetAction[1] == "X" then
						table.remove(ResetAction,1)
					else
						ResetAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Start),table.unpack(ResetAction)}
					end
				end

				if StepAction == nil then
					StepAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],Type2,Step)}
				elseif StepAction.__trg_magic == "action" then
					StepAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],Type2,Step),StepAction}
				else
					if StepAction[1] == "X" then
						table.remove(StepAction,1)
					else
						StepAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],Type2,Step),table.unpack(StepAction)}
					end
				end
			end

			if Order == 1 then
				CTriggerX(PlayerID,nil,InitAction) -- Init
				CTriggerX(PlayerID,ResetCondtion,ResetAction,{Preserved}) -- Reset
				CTriggerX(PlayerID,StepCondition,StepAction,{Preserved}) -- Step
			else
				CTriggerX(PlayerID,nil,InitAction) -- Init
				CTriggerX(PlayerID,StepCondition,StepAction,{Preserved}) -- Step
				CTriggerX(PlayerID,ResetCondtion,ResetAction,{Preserved}) -- Reset
			end
		else
			if Type == AtLeast then
				Type = iAtLeast
			elseif Type == AtMost then
				Type = iAtMost
			end

			if type(Index) == "number" then
				if InitAction == nil then
					InitAction = {SetMemory(Index,SetTo,Init)}
				elseif InitAction.__trg_magic == "action" then
					InitAction = {SetMemory(Index,SetTo,Init),InitAction}
				else
					if InitAction[1] == "X" then
						table.remove(InitAction,1)
					else
						InitAction = {SetMemory(Index,SetTo,Init),table.unpack(InitAction)}
					end
				end

				if ResetCondtion == nil then
					ResetCondtion = {{TTMemory,Index,Type,End}}
				elseif ResetCondtion.__trg_magic == "condition" then
					ResetCondtion = {{TTMemory,Index,Type,End},ResetCondtion}
				else
					if ResetCondtion[1] == "X" then
						table.remove(ResetCondtion,1)
					else
						ResetCondtion = {{TTMemory,Index,Type,End},table.unpack(ResetCondtion)}
					end
				end

				if ResetAction == nil then
					ResetAction = {SetMemory(Index,SetTo,Start)}
				elseif ResetAction.__trg_magic == "action" then
					ResetAction = {SetMemory(Index,SetTo,Start),ResetAction}
				else
					if ResetAction[1] == "X" then
						table.remove(ResetAction,1)
					else
						ResetAction = {SetMemory(Index,SetTo,Start),table.unpack(ResetAction)}
					end
				end

				if StepAction == nil then
					StepAction = {SetMemory(Index,Type2,Step)}
				elseif StepAction.__trg_magic == "action" then
					StepAction = {SetMemory(Index,Type2,Step),StepAction}
				else
					if StepAction[1] == "X" then
						table.remove(StepAction,1)
					else
						StepAction = {SetMemory(Index,Type2,Step),table.unpack(StepAction)}
					end
				end
			elseif Index == nil then
				CC = CreateCcode()
				if InitAction == nil then
					InitAction = {SetCDeaths("X",SetTo,Init,CC)}
				elseif InitAction.__trg_magic == "action" then
					InitAction = {SetCDeaths("X",SetTo,Init,CC),InitAction}
				else
					if InitAction[1] == "X" then
						table.remove(InitAction,1)
					else
						InitAction = {SetCDeaths("X",SetTo,Init,CC),table.unpack(InitAction)}
					end
				end

				if ResetCondtion == nil then
					ResetCondtion = {{TTCDeaths,"X",Type,End,CC}}
				elseif ResetCondtion.__trg_magic == "condition" then
					ResetCondtion = {{TTCDeaths,"X",Type,End,CC},ResetCondtion}
				else
					if ResetCondtion[1] == "X" then
						table.remove(ResetCondtion,1)
					else
						ResetCondtion = {{TTCDeaths,"X",Type,End,CC},table.unpack(ResetCondtion)}
					end
				end

				if ResetAction == nil then
					ResetAction = {SetCDeaths("X",SetTo,Start,CC)}
				elseif ResetAction.__trg_magic == "action" then
					ResetAction = {SetCDeaths("X",SetTo,Start,CC),ResetAction}
				else
					if ResetAction[1] == "X" then
						table.remove(ResetAction,1)
					else
						ResetAction = {SetCDeaths("X",SetTo,Start,CC),table.unpack(ResetAction)}
					end
				end

				if StepAction == nil then
					StepAction = {SetCDeaths("X",Type2,Step,CC)}
				elseif StepAction.__trg_magic == "action" then
					StepAction = {SetCDeaths("X",Type2,Step,CC),StepAction}
				else
					if StepAction[1] == "X" then
						table.remove(StepAction,1)
					else
						StepAction = {SetCDeaths("X",Type2,Step,CC),table.unpack(StepAction)}
					end
				end
			elseif Index[4] == "V" then
				if InitAction == nil then
					InitAction = {SetNVar(Index,SetTo,Init)}
				elseif InitAction.__trg_magic == "action" then
					InitAction = {SetNVar(Index,SetTo,Init),InitAction}
				else
					if InitAction[1] == "X" then
						table.remove(InitAction,1)
					else
						InitAction = {SetNVar(Index,SetTo,Init),table.unpack(InitAction)}
					end
				end

				if ResetCondtion == nil then
					ResetCondtion = {{TTNVar,Index,Type,End}}
				elseif ResetCondtion.__trg_magic == "condition" then
					ResetCondtion = {{TTNVar,Index,Type,End},ResetCondtion}
				else
					if ResetCondtion[1] == "X" then
						table.remove(ResetCondtion,1)
					else
						ResetCondtion = {{TTNVar,Index,Type,End},table.unpack(ResetCondtion)}
					end
				end

				if ResetAction == nil then
					ResetAction = {SetNVar(Index,SetTo,Start)}
				elseif ResetAction.__trg_magic == "action" then
					ResetAction = {SetNVar(Index,SetTo,Start),ResetAction}
				else
					if ResetAction[1] == "X" then
						table.remove(ResetAction,1)
					else
						ResetAction = {SetNVar(Index,SetTo,Start),table.unpack(ResetAction)}
					end
				end

				if StepAction == nil then
					StepAction = {SetNVar(Index,Type2,Step)}
				elseif StepAction.__trg_magic == "action" then
					StepAction = {SetNVar(Index,Type2,Step),StepAction}
				else
					if StepAction[1] == "X" then
						table.remove(StepAction,1)
					else
						StepAction = {SetNVar(Index,Type2,Step),table.unpack(StepAction)}
					end
				end
			else
				if InitAction == nil then
					InitAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Init)}
				elseif InitAction.__trg_magic == "action" then
					InitAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Init),InitAction}
				else
					if InitAction[1] == "X" then
						table.remove(InitAction,1)
					else
						InitAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Init),table.unpack(InitAction)}
					end
				end

				if ResetCondtion == nil then
					ResetCondtion = {{TTCtrigX,Index[1],Index[2],Index[3],Index[4],Type,End}}
				elseif ResetCondtion.__trg_magic == "condition" then
					ResetCondtion = {{TTCtrigX,Index[1],Index[2],Index[3],Index[4],Type,End},ResetCondtion}
				else
					if ResetCondtion[1] == "X" then
						table.remove(ResetCondtion,1)
					else
						ResetCondtion = {{TTCtrigX,Index[1],Index[2],Index[3],Index[4],Type,End},table.unpack(ResetCondtion)}
					end
				end

				if ResetAction == nil then
					ResetAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Start)}
				elseif ResetAction.__trg_magic == "action" then
					ResetAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Start),ResetAction}
				else
					if ResetAction[1] == "X" then
						table.remove(ResetAction,1)
					else
						ResetAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Start),table.unpack(ResetAction)}
					end
				end

				if StepAction == nil then
					StepAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],Type2,Step)}
				elseif StepAction.__trg_magic == "action" then
					StepAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],Type2,Step),StepAction}
				else
					if StepAction[1] == "X" then
						table.remove(StepAction,1)
					else
						StepAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],Type2,Step),table.unpack(StepAction)}
					end
				end
			end
		
			if Order == 1 then
				CTriggerX(PlayerID,nil,InitAction) -- Init
				CTriggerX(PlayerID,ResetCondtion,ResetAction,{Preserved}) -- Reset
				CTriggerX(PlayerID,StepCondition,StepAction,{Preserved}) -- Step
			else
				CTriggerX(PlayerID,nil,InitAction) -- Init
				CTriggerX(PlayerID,StepCondition,StepAction,{Preserved}) -- Step
				CTriggerX(PlayerID,ResetCondtion,ResetAction,{Preserved}) -- Reset
			end
		end
	else
		Timer_InputData_Error()
	end
	return CC
end

function TimerX(PlayerID,Index,Repeat,Init,Start,End,Step,Ratio,Order,InitAction,ResetCondtion,ResetAction,StepCondition,StepAction)
	if Order == "RS" then
		Order = 1
	end
	local Reverse, Type, Type2, CC=0
	local Count = 0
	local Step2 = Step
	if type(Step) == "number" then
		if Step > 0 then
			Type = AtLeast
			Type2 = Add
			Reverse = 1
		elseif Step < 0 then
			if Start * End >= 0 then
				Type = AtMost
				Type2 = Subtract
				Step = -Step
			else
				Type = AtMost
				Type2 = Add
			end
			Reverse = -1
		else
			TimerX_InputData_Error()
		end

		if Init == nil then
			Init = Start
		end
		if InitAction == nil then InitAction = {} end
		if StepAction == nil then StepAction = {} end
		if ResetCondtion == nil then ResetCondtion = {} end
		if ResetAction == nil then ResetAction = {} end
		if Start * End >= 0 then			
			if type(Index) == "number" then
				if InitAction == nil then
					InitAction = {SetMemory(Index,SetTo,Init)}
				elseif InitAction.__trg_magic == "action" then
					InitAction = {SetMemory(Index,SetTo,Init),InitAction}
				else
					if InitAction[1] == "X" then
						table.remove(InitAction,1)
					else
						InitAction = {SetMemory(Index,SetTo,Init),table.unpack(InitAction)}
					end
				end

				if ResetCondtion == nil then
					ResetCondtion = {Memory(Index,Type,End)}
				elseif ResetCondtion.__trg_magic == "condition" then
					ResetCondtion = {Memory(Index,Type,End),ResetCondtion}
				else
					if ResetCondtion[1] == "X" then
						table.remove(ResetCondtion,1)
					else
						ResetCondtion = {Memory(Index,Type,End),table.unpack(ResetCondtion)}
					end
				end

				if ResetAction == nil then
					ResetAction = {SetMemory(Index,SetTo,Start)}
				elseif ResetAction.__trg_magic == "action" then
					ResetAction = {SetMemory(Index,SetTo,Start),ResetAction}
				else
					if ResetAction[1] == "X" then
						table.remove(ResetAction,1)
					else
						ResetAction = {SetMemory(Index,SetTo,Start),table.unpack(ResetAction)}
					end
				end

				if StepAction == nil then
					StepAction = {SetMemory(Index,Type2,Step)}
				elseif StepAction.__trg_magic == "action" then
					StepAction = {SetMemory(Index,Type2,Step),StepAction}
				else
					if StepAction[1] == "X" then
						table.remove(StepAction,1)
					else
						StepAction = {SetMemory(Index,Type2,Step),table.unpack(StepAction)}
					end
				end
			elseif Index == nil then
				CC = CreateCcode()
				if InitAction == nil then
					InitAction = {SetCDeaths("X",SetTo,Init,CC)}
				elseif InitAction.__trg_magic == "action" then
					InitAction = {SetCDeaths("X",SetTo,Init,CC),InitAction}
				else
					if InitAction[1] == "X" then
						table.remove(InitAction,1)
					else
						InitAction = {SetCDeaths("X",SetTo,Init,CC),table.unpack(InitAction)}
					end
				end

				if ResetCondtion == nil then
					ResetCondtion = {CDeaths("X",Type,End,CC)}
				elseif ResetCondtion.__trg_magic == "condition" then
					ResetCondtion = {CDeaths("X",Type,End,CC),ResetCondtion}
				else
					if ResetCondtion[1] == "X" then
						table.remove(ResetCondtion,1)
					else
						ResetCondtion = {CDeaths("X",Type,End,CC),table.unpack(ResetCondtion)}
					end
				end

				if ResetAction == nil then
					ResetAction = {SetCDeaths("X",SetTo,Start,CC)}
				elseif ResetAction.__trg_magic == "action" then
					ResetAction = {SetCDeaths("X",SetTo,Start,CC),ResetAction}
				else
					if ResetAction[1] == "X" then
						table.remove(ResetAction,1)
					else
						ResetAction = {SetCDeaths("X",SetTo,Start,CC),table.unpack(ResetAction)}
					end
				end

				if StepAction == nil then
					StepAction = {SetCDeaths("X",Type2,Step,CC)}
				elseif StepAction.__trg_magic == "action" then
					StepAction = {SetCDeaths("X",Type2,Step,CC),StepAction}
				else
					if StepAction[1] == "X" then
						table.remove(StepAction,1)
					else
						StepAction = {SetCDeaths("X",Type2,Step,CC),table.unpack(StepAction)}
					end
				end
			elseif Index[4] == "V" then
				if InitAction == nil then
					InitAction = {SetNVar(Index,SetTo,Init)}
				elseif InitAction.__trg_magic == "action" then
					InitAction = {SetNVar(Index,SetTo,Init),InitAction}
				else
					if InitAction[1] == "X" then
						table.remove(InitAction,1)
					else
						InitAction = {SetNVar(Index,SetTo,Init),table.unpack(InitAction)}
					end
				end

				if ResetCondtion == nil then
					ResetCondtion = {NVar(Index,Type,End)}
				elseif ResetCondtion.__trg_magic == "condition" then
					ResetCondtion = {NVar(Index,Type,End),ResetCondtion}
				else
					if ResetCondtion[1] == "X" then
						table.remove(ResetCondtion,1)
					else
						ResetCondtion = {NVar(Index,Type,End),table.unpack(ResetCondtion)}
					end
				end

				if ResetAction == nil then
					ResetAction = {SetNVar(Index,SetTo,Start)}
				elseif ResetAction.__trg_magic == "action" then
					ResetAction = {SetNVar(Index,SetTo,Start),ResetAction}
				else
					if ResetAction[1] == "X" then
						table.remove(ResetAction,1)
					else
						ResetAction = {SetNVar(Index,SetTo,Start),table.unpack(ResetAction)}
					end
				end

				if StepAction == nil then
					StepAction = {SetNVar(Index,Type2,Step)}
				elseif StepAction.__trg_magic == "action" then
					StepAction = {SetNVar(Index,Type2,Step),StepAction}
				else
					if StepAction[1] == "X" then
						table.remove(StepAction,1)
					else
						StepAction = {SetNVar(Index,Type2,Step),table.unpack(StepAction)}
					end
				end
			else
				if InitAction == nil then
					InitAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Init)}
				elseif InitAction.__trg_magic == "action" then
					InitAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Init),InitAction}
				else
					if InitAction[1] == "X" then
						table.remove(InitAction,1)
					else
						InitAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Init),table.unpack(InitAction)}
					end
				end

				if ResetCondtion == nil then
					ResetCondtion = {CtrigX(Index[1],Index[2],Index[3],Index[4],Type,End)}
				elseif ResetCondtion.__trg_magic == "condition" then
					ResetCondtion = {CtrigX(Index[1],Index[2],Index[3],Index[4],Type,End),ResetCondtion}
				else
					if ResetCondtion[1] == "X" then
						table.remove(ResetCondtion,1)
					else
						ResetCondtion = {CtrigX(Index[1],Index[2],Index[3],Index[4],Type,End),table.unpack(ResetCondtion)}
					end
				end

				if ResetAction == nil then
					ResetAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Start)}
				elseif ResetAction.__trg_magic == "action" then
					ResetAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Start),ResetAction}
				else
					if ResetAction[1] == "X" then
						table.remove(ResetAction,1)
					else
						ResetAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Start),table.unpack(ResetAction)}
					end
				end

				if StepAction == nil then
					StepAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],Type2,Step)}
				elseif StepAction.__trg_magic == "action" then
					StepAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],Type2,Step),StepAction}
				else
					if StepAction[1] == "X" then
						table.remove(StepAction,1)
					else
						StepAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],Type2,Step),table.unpack(StepAction)}
					end
				end
			end

			if Order == 1 then
				CTriggerX(PlayerID,nil,InitAction) -- Init
				CTriggerX(PlayerID,ResetCondtion,ResetAction,{Preserved}) -- Reset
				CTriggerX(PlayerID,StepCondition,StepAction,{Preserved}) -- Step

				-- Loop (Start+Step ~ End)
				local A = math.abs(Ratio[1])
				local B = Ratio[2]
				local Q = math.floor(A/B)
				local R = A - B*Q
				local Ret = {}
				for i = 1, B do
					if i <= R then
						table.insert(Ret,Q+1)
					else
						table.insert(Ret,Q)
					end
				end
				local Test = math.abs(End-Start)/Ratio[2]
				local CountX = math.floor(Test)-1
				if CountX < 0 or CountX ~= math.ceil(Test)-1 then
					TimerX_InputData_Error()
				end
				if Repeat == nil then
					Count = CreateCcode()
				end
				for k = 0, CountX do
					local Temp, IndexT
					for j = 0, 2 do
						for k, v in pairs(Ret) do
							IndexT = math.random(1,#Ret)
							Temp = v
							Ret[k] = Ret[IndexT]
							Ret[IndexT] = Temp
						end
					end

					for i = 1, #Ret do
						local LoopCond, LoopAct
						if type(Index) == "number" then
							LoopCond = Memory(Index,Exactly,Start+Step2*(i)+Ratio[2]*k*Reverse)
						elseif Index == nil then
							LoopCond = CDeaths("X",Exactly,Start+Step2*(i)+Ratio[2]*k*Reverse,CC)
						elseif Index[4] == "V" then
							LoopCond = NVar(Index,Exactly,Start+Step2*(i)+Ratio[2]*k*Reverse)
						else
							LoopCond = CtrigX(Index[1],Index[2],Index[3],Index[4],Exactly,Start+Step2*(i)+Ratio[2]*k*Reverse)
						end

						if type(Repeat) == "number" then
							LoopAct = SetMemory(Repeat,SetTo,Ret[i])
						elseif Repeat == nil then
							LoopAct = SetCDeaths("X",SetTo,Ret[i],Count)
						elseif Repeat[4] == "V" then
							LoopAct = SetNVar(Repeat,SetTo,Ret[i])
						else
							LoopAct = SetCtrigX(Repeat[1],Repeat[2],Repeat[3],Repeat[4],SetTo,Ret[i])
						end

						if Ret[i] >= 1 then
							Trigger { -- Loop
								players = {PlayerID},
									conditions = {
										Label();
										LoopCond,
									},
									actions = {
										LoopAct,
									},
									flag = {Preserved}
								}
						end
					end
				end
			else
				CTriggerX(PlayerID,nil,InitAction) -- Init
				CTriggerX(PlayerID,StepCondition,StepAction,{Preserved}) -- Step
				CTriggerX(PlayerID,ResetCondtion,ResetAction,{Preserved}) -- Reset

				-- Loop (Start ~ End-Step)
				local A = math.abs(Ratio[1])
				local B = Ratio[2]
				local Q = math.floor(A/B)
				local R = A - B*Q
				local Ret = {}
				for i = 1, B do
					if i <= R then
						table.insert(Ret,Q+1)
					else
						table.insert(Ret,Q)
					end
				end
				local Test = math.abs(End-Start)/Ratio[2]
				local CountX = math.floor(Test)-1
				if CountX < 0 or CountX ~= math.ceil(Test)-1 then
					TimerX_InputData_Error()
				end
				if Repeat == nil then
					Count = CreateCcode()
				end
				for k = 0, CountX do
					local Temp, IndexT
					for j = 0, 2 do
						for k, v in pairs(Ret) do
							IndexT = math.random(1,#Ret)
							Temp = v
							Ret[k] = Ret[IndexT]
							Ret[IndexT] = Temp
						end
					end

					for i = 1, #Ret do
						local LoopCond, LoopAct
						if type(Index) == "number" then
							LoopCond = Memory(Index,Exactly,Start+Step2*(i-1)+Ratio[2]*k*Reverse)
						elseif Index == nil then
							LoopCond = CDeaths("X",Exactly,Start+Step2*(i-1)+Ratio[2]*k*Reverse,CC)
						elseif Index[4] == "V" then
							LoopCond = NVar(Index,Exactly,Start+Step2*(i-1)+Ratio[2]*k*Reverse)
						else
							LoopCond = CtrigX(Index[1],Index[2],Index[3],Index[4],Exactly,Start+Step2*(i-1)+Ratio[2]*k*Reverse)
						end

						if type(Repeat) == "number" then
							LoopAct = SetMemory(Repeat,SetTo,Ret[i])
						elseif Repeat == nil then
							LoopAct = SetCDeaths("X",SetTo,Ret[i],Count)
						elseif Repeat[4] == "V" then
							LoopAct = SetNVar(Repeat,SetTo,Ret[i])
						else
							LoopAct = SetCtrigX(Repeat[1],Repeat[2],Repeat[3],Repeat[4],SetTo,Ret[i])
						end
						if Ret[i] >= 1 then
							Trigger { -- Loop
								players = {PlayerID},
									conditions = {
										Label();
										LoopCond,
									},
									actions = {
										LoopAct,
									},
									flag = {Preserved}
								}
						end
					end
				end
			end
		else
			if Type == AtLeast then
				Type = iAtLeast
			elseif Type == AtMost then
				Type = iAtMost
			end

			if type(Index) == "number" then
				if InitAction == nil then
					InitAction = {SetMemory(Index,SetTo,Init)}
				elseif InitAction.__trg_magic == "action" then
					InitAction = {SetMemory(Index,SetTo,Init),InitAction}
				else
					if InitAction[1] == "X" then
						table.remove(InitAction,1)
					else
						InitAction = {SetMemory(Index,SetTo,Init),table.unpack(InitAction)}
					end
				end

				if ResetCondtion == nil then
					ResetCondtion = {{TTMemory,Index,Type,End}}
				elseif ResetCondtion.__trg_magic == "condition" then
					ResetCondtion = {{TTMemory,Index,Type,End},ResetCondtion}
				else
					if ResetCondtion[1] == "X" then
						table.remove(ResetCondtion,1)
					else
						ResetCondtion = {{TTMemory,Index,Type,End},table.unpack(ResetCondtion)}
					end
				end

				if ResetAction == nil then
					ResetAction = {SetMemory(Index,SetTo,Start)}
				elseif ResetAction.__trg_magic == "action" then
					ResetAction = {SetMemory(Index,SetTo,Start),ResetAction}
				else
					if ResetAction[1] == "X" then
						table.remove(ResetAction,1)
					else
						ResetAction = {SetMemory(Index,SetTo,Start),table.unpack(ResetAction)}
					end
				end

				if StepAction == nil then
					StepAction = {SetMemory(Index,Type2,Step)}
				elseif StepAction.__trg_magic == "action" then
					StepAction = {SetMemory(Index,Type2,Step),StepAction}
				else
					if StepAction[1] == "X" then
						table.remove(StepAction,1)
					else
						StepAction = {SetMemory(Index,Type2,Step),table.unpack(StepAction)}
					end
				end
			elseif Index == nil then
				CC = CreateCcode()
				if InitAction == nil then
					InitAction = {SetCDeaths("X",SetTo,Init,CC)}
				elseif InitAction.__trg_magic == "action" then
					InitAction = {SetCDeaths("X",SetTo,Init,CC),InitAction}
				else
					if InitAction[1] == "X" then
						table.remove(InitAction,1)
					else
						InitAction = {SetCDeaths("X",SetTo,Init,CC),table.unpack(InitAction)}
					end
				end

				if ResetCondtion == nil then
					ResetCondtion = {{TTCDeaths,"X",Type,End,CC}}
				elseif ResetCondtion.__trg_magic == "condition" then
					ResetCondtion = {{TTCDeaths,"X",Type,End,CC},ResetCondtion}
				else
					if ResetCondtion[1] == "X" then
						table.remove(ResetCondtion,1)
					else
						ResetCondtion = {{TTCDeaths,"X",Type,End,CC},table.unpack(ResetCondtion)}
					end
				end

				if ResetAction == nil then
					ResetAction = {SetCDeaths("X",SetTo,Start,CC)}
				elseif ResetAction.__trg_magic == "action" then
					ResetAction = {SetCDeaths("X",SetTo,Start,CC),ResetAction}
				else
					if ResetAction[1] == "X" then
						table.remove(ResetAction,1)
					else
						ResetAction = {SetCDeaths("X",SetTo,Start,CC),table.unpack(ResetAction)}
					end
				end

				if StepAction == nil then
					StepAction = {SetCDeaths("X",Type2,Step,CC)}
				elseif StepAction.__trg_magic == "action" then
					StepAction = {SetCDeaths("X",Type2,Step,CC),StepAction}
				else
					if StepAction[1] == "X" then
						table.remove(StepAction,1)
					else
						StepAction = {SetCDeaths("X",Type2,Step,CC),table.unpack(StepAction)}
					end
				end
			elseif Index[4] == "V" then
				if InitAction == nil then
					InitAction = {SetNVar(Index,SetTo,Init)}
				elseif InitAction.__trg_magic == "action" then
					InitAction = {SetNVar(Index,SetTo,Init),InitAction}
				else
					if InitAction[1] == "X" then
						table.remove(InitAction,1)
					else
						InitAction = {SetNVar(Index,SetTo,Init),table.unpack(InitAction)}
					end
				end

				if ResetCondtion == nil then
					ResetCondtion = {{TTNVar,Index,Type,End}}
				elseif ResetCondtion.__trg_magic == "condition" then
					ResetCondtion = {{TTNVar,Index,Type,End},ResetCondtion}
				else
					if ResetCondtion[1] == "X" then
						table.remove(ResetCondtion,1)
					else
						ResetCondtion = {{TTNVar,Index,Type,End},table.unpack(ResetCondtion)}
					end
				end

				if ResetAction == nil then
					ResetAction = {SetNVar(Index,SetTo,Start)}
				elseif ResetAction.__trg_magic == "action" then
					ResetAction = {SetNVar(Index,SetTo,Start),ResetAction}
				else
					if ResetAction[1] == "X" then
						table.remove(ResetAction,1)
					else
						ResetAction = {SetNVar(Index,SetTo,Start),table.unpack(ResetAction)}
					end
				end

				if StepAction == nil then
					StepAction = {SetNVar(Index,Type2,Step)}
				elseif StepAction.__trg_magic == "action" then
					StepAction = {SetNVar(Index,Type2,Step),StepAction}
				else
					if StepAction[1] == "X" then
						table.remove(StepAction,1)
					else
						StepAction = {SetNVar(Index,Type2,Step),table.unpack(StepAction)}
					end
				end
			else
				if InitAction == nil then
					InitAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Init)}
				elseif InitAction.__trg_magic == "action" then
					InitAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Init),InitAction}
				else
					if InitAction[1] == "X" then
						table.remove(InitAction,1)
					else
						InitAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Init),table.unpack(InitAction)}
					end
				end

				if ResetCondtion == nil then
					ResetCondtion = {{TTCtrigX,Index[1],Index[2],Index[3],Index[4],Type,End}}
				elseif ResetCondtion.__trg_magic == "condition" then
					ResetCondtion = {{TTCtrigX,Index[1],Index[2],Index[3],Index[4],Type,End},ResetCondtion}
				else
					if ResetCondtion[1] == "X" then
						table.remove(ResetCondtion,1)
					else
						ResetCondtion = {{TTCtrigX,Index[1],Index[2],Index[3],Index[4],Type,End},table.unpack(ResetCondtion)}
					end
				end

				if ResetAction == nil then
					ResetAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Start)}
				elseif ResetAction.__trg_magic == "action" then
					ResetAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Start),ResetAction}
				else
					if ResetAction[1] == "X" then
						table.remove(ResetAction,1)
					else
						ResetAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],SetTo,Start),table.unpack(ResetAction)}
					end
				end

				if StepAction == nil then
					StepAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],Type2,Step)}
				elseif StepAction.__trg_magic == "action" then
					StepAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],Type2,Step),StepAction}
				else
					if StepAction[1] == "X" then
						table.remove(StepAction,1)
					else
						StepAction = {SetCtrig1X(Index[1],Index[2],Index[3],Index[4],Type2,Step),table.unpack(StepAction)}
					end
				end
			end

			if Order == 1 then
				CTriggerX(PlayerID,nil,InitAction) -- Init
				CTriggerX(PlayerID,ResetCondtion,ResetAction,{Preserved}) -- Reset
				CTriggerX(PlayerID,StepCondition,StepAction,{Preserved}) -- Step

				-- Loop (Start+Step ~ End)
				local A = math.abs(Ratio[1])
				local B = Ratio[2]
				local Q = math.floor(A/B)
				local R = A - B*Q
				local Ret = {}
				for i = 1, B do
					if i <= R then
						table.insert(Ret,Q+1)
					else
						table.insert(Ret,Q)
					end
				end
				local Test = math.abs(End-Start)/Ratio[2]
				local CountX = math.floor(Test)-1
				if CountX < 0 or CountX ~= math.ceil(Test)-1 then
					TimerX_InputData_Error()
				end
				if Repeat == nil then
					Count = CreateCcode()
				end

				for k = 0, CountX do
					local Temp, IndexT
					for j = 0, 2 do
						for k, v in pairs(Ret) do
							IndexT = math.random(1,#Ret)
							Temp = v
							Ret[k] = Ret[IndexT]
							Ret[IndexT] = Temp
						end
					end
					
					for i = 1, #Ret do
						local LoopCond, LoopAct
						if type(Index) == "number" then
							LoopCond = Memory(Index,Exactly,Start+Step2*(i)+Ratio[2]*k*Reverse)
						elseif Index == nil then
							LoopCond = CDeaths("X",Exactly,Start+Step2*(i)+Ratio[2]*k*Reverse,CC)
						elseif Index[4] == "V" then
							LoopCond = NVar(Index,Exactly,Start+Step2*(i)+Ratio[2]*k*Reverse)
						else
							LoopCond = CtrigX(Index[1],Index[2],Index[3],Index[4],Exactly,Start+Step2*(i)+Ratio[2]*k*Reverse)
						end

						if type(Repeat) == "number" then
							LoopAct = SetMemory(Repeat,SetTo,Ret[i])
						elseif Repeat == nil then
							LoopAct = SetCDeaths("X",SetTo,Ret[i],Count)
						elseif Repeat[4] == "V" then
							LoopAct = SetNVar(Repeat,SetTo,Ret[i])
						else
							LoopAct = SetCtrigX(Repeat[1],Repeat[2],Repeat[3],Repeat[4],SetTo,Ret[i])
						end
						if Ret[i] >= 1 then
							Trigger { -- Loop
								players = {PlayerID},
									conditions = {
										Label();
										LoopCond,
									},
									actions = {
										LoopAct,
									},
									flag = {Preserved}
								}
						end
					end
				end
			else
				CTriggerX(PlayerID,nil,InitAction) -- Init
				CTriggerX(PlayerID,StepCondition,StepAction,{Preserved}) -- Step
				CTriggerX(PlayerID,ResetCondtion,ResetAction,{Preserved}) -- Reset

				-- Loop (Start ~ End-Step)
				local A = math.abs(Ratio[1])
				local B = Ratio[2]
				local Q = math.floor(A/B)
				local R = A - B*Q
				local Ret = {}
				for i = 1, B do
					if i <= R then
						table.insert(Ret,Q+1)
					else
						table.insert(Ret,Q)
					end
				end
				local Test = math.abs(End-Start)/Ratio[2]
				local CountX = math.floor(Test)-1
				if CountX < 0 or CountX ~= math.ceil(Test)-1 then
					TimerX_InputData_Error()
				end
				if Repeat == nil then
					Count = CreateCcode()
				end

				for k = 0, CountX do
					local Temp, IndexT
					for j = 0, 2 do
						for k, v in pairs(Ret) do
							IndexT = math.random(1,#Ret)
							Temp = v
							Ret[k] = Ret[IndexT]
							Ret[IndexT] = Temp
						end
					end
					
					for i = 1, #Ret do
						local LoopCond, LoopAct
						if type(Index) == "number" then
							LoopCond = Memory(Index,Exactly,Start+Step2*(i-1)+Ratio[2]*k*Reverse)
						elseif Index == nil then
							LoopCond = CDeaths("X",Exactly,Start+Step2*(i-1)+Ratio[2]*k*Reverse,CC)
						elseif Index[4] == "V" then
							LoopCond = NVar(Index,Exactly,Start+Step2*(i-1)+Ratio[2]*k*Reverse)
						else
							LoopCond = CtrigX(Index[1],Index[2],Index[3],Index[4],Exactly,Start+Step2*(i-1)+Ratio[2]*k*Reverse)
						end

						if type(Repeat) == "number" then
							LoopAct = SetMemory(Repeat,SetTo,Ret[i])
						elseif Repeat == nil then
							LoopAct = SetCDeaths("X",SetTo,Ret[i],Count)
						elseif Repeat[4] == "V" then
							LoopAct = SetNVar(Repeat,SetTo,Ret[i])
						else
							LoopAct = SetCtrigX(Repeat[1],Repeat[2],Repeat[3],Repeat[4],SetTo,Ret[i])
						end
						if Ret[i] >= 1 then
							Trigger { -- Loop
								players = {PlayerID},
									conditions = {
										Label();
										LoopCond,
									},
									actions = {
										LoopAct,
									},
									flag = {Preserved}
								}
						end
					end
				end
			end
		end
	end

	return {CC,Count}
end

function CA__SetMemoryX(index,Value,Mask,utf8flag)
	if Mask == nil then
		if utf8flag == 1 then
			Mask = 0xFFFFFFFF
		else
			Mask = 0xFFFF00FF
		end
	end
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	if type(Value) == "string" then
		if utf8flag == 1 then
			Value = MakeiStrDataX(Value,1)
		else
			Value = MakeiStrData(Value,1)
		end
	end

	if type(index) == "number" then
		if index < 0 then
			CA__SetMemoryX_InputData_Error()
		end
		CTrigger(PlayerID,{NVar(CB[2],AtLeast,index+1)},{TSetMemoryX(Vi(CB[1][2],index),SetTo,Value,Mask)},{Preserved})
	else
		local Deviation = index[5]
		if Deviation == nil then
			Deviation = 0
		end
		if type(Value) == "number" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X(index[1],index[2],0x15C,index[3],Add,Deviation);
							SetCtrig1X("X","X",0x24,1,SetTo,-1);
							SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX(index[1],index[2],0x158,index[3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(index[1],index[2],0x148,index[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(index[1],index[2],0x160,index[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(CB[2][1],CB[2][2],0x158,CB[2][3],SetTo,"X","X",0x24,1,1);
							SetCtrig1X(CB[2][1],CB[2][2],0x148,CB[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[2][1],CB[2][2],0x160,CB[2][3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways3(CB[1][1],CB[1][2],CB[1][3],index[1],index[2],index[3],CB[2][1],CB[2][2],CB[2][3])
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
							NVar(index,AtMost,0);
						},
						actions = {
							SetDeathsX(0,SetTo,Value,0,Mask);
						},
						flag = {Preserved}
					}
				DoActionsX(PlayerID,SetCtrig1X(index[1],index[2],0x15C,index[3],Add,-Deviation))
			--[[
				DoActionsX(PlayerID,SetCtrig1X(index[1],index[2],0x15C,index[3],Add,Deviation))
				f_iMod(PlayerID,V(NRet[1]),index,CB[2])
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",NRet[1],0x158,0,SetTo,"X","X",0x158,1,1);
							SetCtrig1X("X",NRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",NRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							CallLabelAlways2(CB[1][1],CB[1][2],CB[1][3],"X",NRet[1],0)
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetDeathsX(0,SetTo,Value,0,Mask);
							SetCtrig1X(index[1],index[2],0x15C,index[3],Add,-Deviation);
						},
						flag = {Preserved}
					}
			]]--
		else
			local CDeviation = Value[5]
			if CDeviation == nil then
				CDeviation = 0
			end
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X(index[1],index[2],0x15C,index[3],Add,Deviation);
							SetCtrig1X("X","X",0x24,1,SetTo,-1);
							SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX(index[1],index[2],0x158,index[3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(index[1],index[2],0x148,index[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(index[1],index[2],0x160,index[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(CB[2][1],CB[2][2],0x158,CB[2][3],SetTo,"X","X",0x24,1,1);
							SetCtrig1X(CB[2][1],CB[2][2],0x148,CB[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[2][1],CB[2][2],0x160,CB[2][3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X("X","X",0x15C,1,SetTo,CDeviation);
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x15C,1,1);
							SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways4(CB[1][1],CB[1][2],CB[1][3],index[1],index[2],index[3],CB[2][1],CB[2][2],CB[2][3],Value[1],Value[2],Value[3])
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
							NVar(index,AtMost,0);
						},
						actions = {
							SetDeathsX(0,SetTo,0,0,Mask);
						},
						flag = {Preserved}
					}
				DoActionsX(PlayerID,SetCtrig1X(index[1],index[2],0x15C,index[3],Add,-Deviation))
			--[[
				DoActionsX(PlayerID,SetCtrig1X(index[1],index[2],0x15C,index[3],Add,Deviation))
				f_iMod(PlayerID,V(NRet[1]),index,CB[2])
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",NRet[1],0x158,0,SetTo,"X","X",0x158,1,1);
							SetCtrig1X("X",NRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",NRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrig1X("X","X",0x15C,1,SetTo,CDeviation);
							SetCtrigX(Value[1],Value[2],0x158,Value[3],SetTo,"X","X",0x15C,1,1);
							SetCtrig1X(Value[1],Value[2],0x148,Value[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Value[1],Value[2],0x160,Value[3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways3(CB[1][1],CB[1][2],CB[1][3],"X",NRet[1],0,Value[1],Value[2],Value[3])
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetDeathsX(0,SetTo,0,0,Mask);
							SetCtrig1X(index[1],index[2],0x15C,index[3],Add,-Deviation);
						},
						flag = {Preserved}
					}
			]]--
		end
	end
end

function CA__SetLetter(index,Letter,utf8flag)
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	local Mask
	if utf8flag == 1 then
		Mask = 0xFFFFFF00
	else
		Mask = 0xFFFF0000
	end

	if type(Letter) == "string" then
		if utf8flag == 1 then
			Letter = MakeiStrDataX(Letter,1)
		else
			Letter = MakeiStrData(Letter,1)
		end
	end

	if type(index) == "number" then
		if index < 0 then
			CA__Letter_InputData_Error()
		end
		CTrigger(PlayerID,{NVar(CB[2],AtLeast,index+1)},{TSetMemoryX(Vi(CB[1][2],index),SetTo,Letter,Mask)},{Preserved})
	else
		local Deviation = index[5]
		if Deviation == nil then
			Deviation = 0
		end
		if type(Letter) == "number" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X(index[1],index[2],0x15C,index[3],Add,Deviation);
							SetCtrig1X("X","X",0x24,1,SetTo,-1);
							SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX(index[1],index[2],0x158,index[3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(index[1],index[2],0x148,index[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(index[1],index[2],0x160,index[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(CB[2][1],CB[2][2],0x158,CB[2][3],SetTo,"X","X",0x24,1,1);
							SetCtrig1X(CB[2][1],CB[2][2],0x148,CB[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[2][1],CB[2][2],0x160,CB[2][3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways3(CB[1][1],CB[1][2],CB[1][3],index[1],index[2],index[3],CB[2][1],CB[2][2],CB[2][3])
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
							NVar(index,AtMost,0);
						},
						actions = {
							SetDeathsX(0,SetTo,Letter,0,Mask);
						},
						flag = {Preserved}
					}
				DoActionsX(PlayerID,SetCtrig1X(index[1],index[2],0x15C,index[3],Add,-Deviation))
			--[[
				DoActionsX(PlayerID,SetCtrig1X(index[1],index[2],0x15C,index[3],Add,Deviation))
				f_iMod(PlayerID,V(NRet[1]),index,CB[2])
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",NRet[1],0x158,0,SetTo,"X","X",0x158,1,1);
							SetCtrig1X("X",NRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",NRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							CallLabelAlways2(CB[1][1],CB[1][2],CB[1][3],"X",NRet[1],0)
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetDeathsX(0,SetTo,Letter,0,0xFFFF0000);
							SetCtrig1X(index[1],index[2],0x15C,index[3],Add,-Deviation);
						},
						flag = {Preserved}
					}
			]]--
		else
			local CDeviation = Letter[5]
			if CDeviation == nil then
				CDeviation = 0
			end
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X(index[1],index[2],0x15C,index[3],Add,Deviation);
							SetCtrig1X("X","X",0x24,1,SetTo,-1);
							SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX(index[1],index[2],0x158,index[3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(index[1],index[2],0x148,index[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(index[1],index[2],0x160,index[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(CB[2][1],CB[2][2],0x158,CB[2][3],SetTo,"X","X",0x24,1,1);
							SetCtrig1X(CB[2][1],CB[2][2],0x148,CB[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[2][1],CB[2][2],0x160,CB[2][3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X("X","X",0x15C,1,SetTo,CDeviation);
							SetCtrigX(Letter[1],Letter[2],0x158,Letter[3],SetTo,"X","X",0x15C,1,1);
							SetCtrig1X(Letter[1],Letter[2],0x148,Letter[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Letter[1],Letter[2],0x160,Letter[3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways4(CB[1][1],CB[1][2],CB[1][3],index[1],index[2],index[3],CB[2][1],CB[2][2],CB[2][3],Letter[1],Letter[2],Letter[3])
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
							NVar(index,AtMost,0);
						},
						actions = {
							SetDeathsX(0,SetTo,0,0,Mask);
						},
						flag = {Preserved}
					}
				DoActionsX(PlayerID,SetCtrig1X(index[1],index[2],0x15C,index[3],Add,-Deviation))
			--[[
				DoActionsX(PlayerID,SetCtrig1X(index[1],index[2],0x15C,index[3],Add,Deviation))
				f_iMod(PlayerID,V(NRet[1]),index,CB[2])
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",NRet[1],0x158,0,SetTo,"X","X",0x158,1,1);
							SetCtrig1X("X",NRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",NRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrig1X("X","X",0x15C,1,SetTo,CDeviation);
							SetCtrigX(Letter[1],Letter[2],0x158,Letter[3],SetTo,"X","X",0x15C,1,1);
							SetCtrig1X(Letter[1],Letter[2],0x148,Letter[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Letter[1],Letter[2],0x160,Letter[3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways3(CB[1][1],CB[1][2],CB[1][3],"X",NRet[1],0,Letter[1],Letter[2],Letter[3])
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetDeathsX(0,SetTo,0,0,0xFFFF0000);
							SetCtrig1X(index[1],index[2],0x15C,index[3],Add,-Deviation);
						},
						flag = {Preserved}
					}
			]]--
		end
	end
end

function CA__SetColor(index,ColorCode)
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)
	if type(index) == "number" then
		if index < 0 then
			CA__SetColor_InputData_Error()
		end
		CTrigger(PlayerID,{NVar(CB[2],AtLeast,index+1)},{TSetMemoryX(Vi(CB[1][2],index),SetTo,ColorCode,0xFF)},{Preserved})
	else
		local Deviation = index[5]
		if Deviation == nil then
			Deviation = 0
		end
		if type(ColorCode) == "number" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X(index[1],index[2],0x15C,index[3],Add,Deviation);
							SetCtrig1X("X","X",0x24,1,SetTo,-1);
							SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX(index[1],index[2],0x158,index[3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(index[1],index[2],0x148,index[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(index[1],index[2],0x160,index[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(CB[2][1],CB[2][2],0x158,CB[2][3],SetTo,"X","X",0x24,1,1);
							SetCtrig1X(CB[2][1],CB[2][2],0x148,CB[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[2][1],CB[2][2],0x160,CB[2][3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways3(CB[1][1],CB[1][2],CB[1][3],index[1],index[2],index[3],CB[2][1],CB[2][2],CB[2][3])
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
							NVar(index,AtMost,0);
						},
						actions = {
							SetDeathsX(0,SetTo,ColorCode,0,0xFF);
						},
						flag = {Preserved}
					}
				DoActionsX(PlayerID,SetCtrig1X(index[1],index[2],0x15C,index[3],Add,-Deviation))
			--[[
				DoActionsX(PlayerID,SetCtrig1X(index[1],index[2],0x15C,index[3],Add,Deviation))
				f_iMod(PlayerID,V(NRet[1]),index,CB[2])
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",NRet[1],0x158,0,SetTo,"X","X",0x158,1,1);
							SetCtrig1X("X",NRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",NRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							CallLabelAlways2(CB[1][1],CB[1][2],CB[1][3],"X",NRet[1],0)
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetDeathsX(0,SetTo,ColorCode,0,0xFF);
							SetCtrig1X(index[1],index[2],0x15C,index[3],Add,-Deviation);
						},
						flag = {Preserved}
					}
			]]--
		else
			local CDeviation = ColorCode[5]
			if CDeviation == nil then
				CDeviation = 0
			end

				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X(index[1],index[2],0x15C,index[3],Add,Deviation);
							SetCtrig1X("X","X",0x24,1,SetTo,-1);
							SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX(index[1],index[2],0x158,index[3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(index[1],index[2],0x148,index[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(index[1],index[2],0x160,index[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(CB[2][1],CB[2][2],0x158,CB[2][3],SetTo,"X","X",0x24,1,1);
							SetCtrig1X(CB[2][1],CB[2][2],0x148,CB[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[2][1],CB[2][2],0x160,CB[2][3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X("X","X",0x15C,1,SetTo,CDeviation);
							SetCtrigX(ColorCode[1],ColorCode[2],0x158,ColorCode[3],SetTo,"X","X",0x15C,1,1);
							SetCtrig1X(ColorCode[1],ColorCode[2],0x148,ColorCode[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(ColorCode[1],ColorCode[2],0x160,ColorCode[3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways4(CB[1][1],CB[1][2],CB[1][3],index[1],index[2],index[3],CB[2][1],CB[2][2],CB[2][3],ColorCode[1],ColorCode[2],ColorCode[3])
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
							NVar(index,AtMost,0);
						},
						actions = {
							SetDeathsX(0,SetTo,0,0,0xFF);
						},
						flag = {Preserved}
					}
				DoActionsX(PlayerID,SetCtrig1X(index[1],index[2],0x15C,index[3],Add,-Deviation))
			--[[
				DoActionsX(PlayerID,SetCtrig1X(index[1],index[2],0x15C,index[3],Add,Deviation))
				f_iMod(PlayerID,V(NRet[1]),index,CB[2])
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",NRet[1],0x158,0,SetTo,"X","X",0x158,1,1);
							SetCtrig1X("X",NRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",NRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrig1X("X","X",0x15C,1,SetTo,CDeviation);
							SetCtrigX(ColorCode[1],ColorCode[2],0x158,ColorCode[3],SetTo,"X","X",0x15C,1,1);
							SetCtrig1X(ColorCode[1],ColorCode[2],0x148,ColorCode[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(ColorCode[1],ColorCode[2],0x160,ColorCode[3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways3(CB[1][1],CB[1][2],CB[1][3],"X",NRet[1],0,ColorCode[1],ColorCode[2],ColorCode[3])
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetDeathsX(0,SetTo,0,0,0xFF);
							SetCtrig1X(index[1],index[2],0x15C,index[3],Add,-Deviation);
						},
						flag = {Preserved}
					}
			]]--
		end
	end
end
--[[
			Trigger {
					players = {PlayerID},
					conditions = {
						Label();
					},
					actions = {
						SetCtrig1X(index[1],index[2],0x15C,index[3],Add,Deviation);
						SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X","X",0x158,1,3);
						SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX(index[1],index[2],0x158,index[3],SetTo,"X","X",0x158,1,3);
						SetCtrig1X(index[1],index[2],0x148,index[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(index[1],index[2],0x160,index[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(CB[2][1],CB[2][2],0x158,CB[2][3],SetTo,"X","X",0x15C,1,2);
						SetCtrig1X(CB[2][1],CB[2][2],0x148,CB[2][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(CB[2][1],CB[2][2],0x160,CB[2][3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways3(CB[1][1],CB[1][2],CB[1][3],index[1],index[2],index[3],CB[2][1],CB[2][2],CB[2][3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label();
					},
					actions = {
						SetCtrigX(CB[2][1],CB[2][2],0x158,CB[2][3],SetTo,"X","X",0x24,1,1);
						SetCtrig1X(CB[2][1],CB[2][2],0x148,CB[2][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(CB[2][1],CB[2][2],0x160,CB[2][3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(CB[2][1],CB[2][2],CB[2][3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label();
						NVar(index,AtLeast,0);
					},
					actions = {
						SetCtrig1X("X","X",0x158,1,Subtract,0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label();
					},
					actions = {
						SetDeathsX(0,SetTo,ColorCode,0,0xFF);
						SetCtrig1X(index[1],index[2],0x15C,index[3],Add,-Deviation);
					},
					flag = {Preserved}
				}
]]--

function CB__SetHotkey(Value)
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	if type(Value) == "number" then
		if Value >= 65536 then 
			Value = math.floor(Value/65536)
		end
		CDoActions(PlayerID,{TSetMemoryX(Vi(CB[1][2],-1),SetTo,Value*65536,0xFF0000)})
	elseif type(Value) == "string" then
		Value = ParseHotkey(Value)
		CDoActions(PlayerID,{TSetMemoryX(Vi(CB[1][2],-1),SetTo,Value*65536,0xFF0000)})
	elseif Value[4] == "V" then
		CDoActions(PlayerID,{TSetMemoryX(Vi(CB[1][2],-1),SetTo,Value,0xFF0000)})
	end
end

function MakeHotkeyValue(String)
	String = ParseHotkey(String)
	return String*65536 
end

function MakeButtonTypeValue(String)
	String = ParseButtonType(String)
	return String*16777216
end

function CB__SetButtonType(Value)
	local PlayerID = CAPrintPlayerID
	local CA = CAPrintDataArr
	local CB = CAPrintCreateArr
	STPopTrigArr(PlayerID)

	if type(Value) == "number" then
		if Value >= 16777216 then 
			Value = math.floor(Value/16777216)
		end
		CDoActions(PlayerID,{TSetMemoryX(Vi(CB[1][2],-1),SetTo,Value*16777216,0xFF000000)})
	elseif type(Value) == "string" then
		Value = ParseButtonType(Value)
		CDoActions(PlayerID,{TSetMemoryX(Vi(CB[1][2],-1),SetTo,Value*16777216,0xFF000000)})
	elseif Value[4] == "V" then
		CDoActions(PlayerID,{TSetMemoryX(Vi(CB[1][2],-1),SetTo,Value,0xFF000000)})
	end
end

ARet = {"X",0xF000,0,"V"} -- FixText Temp
CAPrintVarAlloc = 0xF002
CAPrintVarLimit = 0xF300
CAPrintPlayerID = {}
CAPrintDataArr = {}
CAPrintCreateArr = {}

function CAPrintAllocCheck()
	if CAPrintVarAlloc >= CAPrintVarLimit then
		CAPrintAllocation_Overflow()
	end
end 
--{V,StringKey,Size,String}
function CAPrint(iStrid,DisplayPlayer,Preset,CAfunc,PlayerID,Condition,PerAction,CpAction,Action)
	if CpAction == nil then
		CpAction = {}
	elseif CpAction.__trg_magic == "action" then
		CpAction = {CpAction}
	end

-- Preset(CA) : str select / wait(가변) / wait adder / loop counter(가변) / loop limit / FixText / Delay(가변) / Delay Adder
-- 내부변수(CB) : str epd / str size / str id / display off 
	
	CIf(PlayerID,Condition,Action)

	if iStrid == nil then
		CA_InputError()
	end

	local CA = {} -- 8
	local CB = {} -- 4
	local CTemp

	if Preset[1] == nil or Preset[1] == 0 then
		Preset[1] = 1
	end
	if Preset[2] == nil then
		Preset[2] = 0
	end
	if Preset[3] == nil then
		Preset[3] = 0
	end
	if Preset[4] == nil then
		Preset[4] = 0
	end
	if Preset[5] == nil or Preset[5] == 0 then
		Preset[5] = 1
	end
	if Preset[6] == nil then
		Preset[6] = 0
	end
	if Preset[7] == nil then
		Preset[7] = 0
	end
	if Preset[8] == nil then
		Preset[8] = 0
	end

	for i = 1, 8 do -- CA : Preset
		if type(Preset[i]) == "number" then 
			CTemp = CreateVar2(PlayerID,nil,SetTo,Preset[i])
		else
			CTemp = CreateVar(PlayerID)
		end
		table.insert(CA,CTemp)
	end
	CB = CreateVarArr(4,PlayerID)
	-------- Preset Limit --------------------------------
	for i = 1, 8 do
		if type(Preset[i]) ~= "number" then
			CMov(PlayerID,CA[i],Preset[i])
		end
	end

	CIf(PlayerID,NVar(CA[1],AtLeast,1))
		if iStrid[1][4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label();
				},
				actions = {
					SetNVar(CA[1],SetTo,0);
					SetCtrig1X(CB[2][1],CB[2][2],0x15C,CB[2][3],SetTo,iStrid[3]);
					SetCtrig1X(CB[3][1],CB[3][2],0x15C,CB[3][3],SetTo,iStrid[2]);
					SetCtrigX(iStrid[1][1],iStrid[1][2],0x158,iStrid[1][3],SetTo,CB[1][1],CB[1][2],0x15C,1,CB[1][3]);
					SetCtrig1X(iStrid[1][1],iStrid[1][2],0x148,iStrid[1][3],SetTo,0xFFFFFFFF);
					SetCtrig1X(iStrid[1][1],iStrid[1][2],0x160,iStrid[1][3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(iStrid[1][1],iStrid[1][2],iStrid[1][3]);
				},
				flag = {Preserved}
			}
		else
			for i = 1, #iStrid do
				Trigger {
					players = {PlayerID},
					conditions = {
						Label();
						NVar(CA[1],Exactly,i);
					},
					actions = {
						SetNVar(CA[1],SetTo,0);
						SetCtrig1X(CB[2][1],CB[2][2],0x15C,CB[2][3],SetTo,iStrid[i][3]);
						SetCtrig1X(CB[3][1],CB[3][2],0x15C,CB[3][3],SetTo,iStrid[i][2]);
						SetCtrigX(iStrid[i][1][1],iStrid[i][1][2],0x158,iStrid[i][1][3],SetTo,CB[1][1],CB[1][2],0x15C,1,CB[1][3]);
						SetCtrig1X(iStrid[i][1][1],iStrid[i][1][2],0x148,iStrid[i][1][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(iStrid[i][1][1],iStrid[i][1][2],0x160,iStrid[i][1][3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(iStrid[i][1][1],iStrid[i][1][2],iStrid[i][1][3]);
					},
					flag = {Preserved}
				}
			end
		end
	CIfEnd()

		NWhile(PlayerID,{NVar(CA[2],Exactly,0)})
			NIfX(PlayerID,{TNVar(CA[4],AtMost,Vi(CA[5][2],-1))})
		-------------------------------------------------------------------------
				CAPrintPlayerID = PlayerID
				CAPrintDataArr = CA
				CAPrintCreateArr = CB

				if CAfunc ~= nil then
					_G[CAfunc]()
				end
		-------------------------------------------------------------------------
				if PerAction == nil then PerAction = {} end
				table.insert(PerAction,SetNVar(CA[4],Add,1))
				CDoActionsX(PlayerID,PerAction)
			NElseX()
				CDoActions(PlayerID,{TSetNVar(CA[2],SetTo,CA[3]),SetNVar(CA[4],SetTo,0),SetNext("X",CAPrintVarAlloc)})
			NIfXEnd()
		NWhileEnd()
		Trigger {players = {PlayerID},conditions = {Label(CAPrintVarAlloc)},flag = {Preserved}}
		CAPrintVarAlloc = CAPrintVarAlloc + 1

		CIf(PlayerID,NVar(CA[6],Exactly,0x1,0x1),SetNVar(ARet,SetTo,0)) -- 0x1 : Save Line
			for i = 0, 3 do
				local CBit = 2^i
				Trigger {players = {PlayerID},conditions = {Label(),MemoryX(0x640B58,Exactly,CBit,CBit)},actions = {SetNVar(ARet,Add,CBit)},flag = {Preserved}}
			end
		CIfEnd()

		local VariableTrig = {{TSetNVar,CA[7],SetTo,CA[8]}}
		local DisplayPlayers = {}
		if DisplayPlayer ~= nil then
			for k, v in pairs(DisplayPlayer) do
				if type(v) == "table" and v[4] == "V" then
					table.insert(VariableTrig,{TSetMemory,0x6509B0,SetTo,v})
					table.insert(VariableTrig,{TDisplayText,CB[3],4})
				else
					table.insert(DisplayPlayers,v)
				end
			end
		end

		if #VariableTrig <= 1 then
			local CpActions = {{"TDisplayText",{CB[3],CB[3],CB[3],CB[3],CB[3],CB[3],CB[3],CB[3],CB[3],CB[3],CB[3],CB[3]},4},table.unpack(CpAction)}
			CTrigger(PlayerID,{NVar(CB[4],Exactly,0),NVar(CA[7],Exactly,0)},{TSetNVar(CA[7],SetTo,CA[8]),table.unpack(CopyCpActionX(CpActions,DisplayPlayer))},{Preserved})
		else
			if #DisplayPlayers ~= 0  then
				table.insert(VariableTrig,{CopyCpActionX,{{"TDisplayText",{CB[3],CB[3],CB[3],CB[3],CB[3],CB[3],CB[3],CB[3],CB[3],CB[3],CB[3],CB[3]},4}},DisplayPlayers})
			end
			CTriggerX(PlayerID,{NVar(CB[4],Exactly,0),NVar(CA[7],Exactly,0)},VariableTrig,{Preserved})
		end
		
		RecoverCp(PlayerID)

		CTrigger(PlayerID,{NVar(CA[6],Exactly,0x2,0x2)},{TSetMemory(0x640B58,SetTo,ARet)},{Preserved}) -- 0x2 : Recover Line
	CIfEnd()
	DoActionsX(PlayerID,{SetNVar(CA[2],Subtract,1),SetNVar(CA[7],Subtract,1)})

	local Ret = CA, CB
	CAPrintPlayerID = {}
	CAPrintDataArr = {}
	CAPrintCreateArr = {}
	return Ret
end

--{V,TBLIndex,Size}
function CBPrint(iTblid,Preset,CBfunc,PlayerID,Condition,PerAction,Action)
-- Preset(CA) : tbl select / wait(가변) / wait adder / loop counter(가변) / loop limit / - / - / -
-- 내부변수(CB) : tbl epd / tbl size / tbl id / -
-- 포인터 (CC) : tbl pointer epd / tbl pointer epdx
	
	CIf(PlayerID,Condition,Action)

	if iTblid == nil then
		CB_InputError()
	end

	local CA = {} -- 8 -3
	local CB = {} -- 4 -1
	local CTemp

	if Preset[1] == nil or Preset[1] == 0 then
		Preset[1] = 1
	end
	if Preset[2] == nil then
		Preset[2] = 0
	end
	if Preset[3] == nil then
		Preset[3] = 0
	end
	if Preset[4] == nil then
		Preset[4] = 0
	end
	if Preset[5] == nil or Preset[5] == 0 then
		Preset[5] = 1
	end

	for i = 1, 8 do -- CA : Preset
		if i < 6 then
			if type(Preset[i]) == "number" then 
				CTemp = CreateVar2(PlayerID,nil,SetTo,Preset[i])
			else
				CTemp = CreateVar(PlayerID)
			end
		else
			CTemp = 0
		end
		table.insert(CA,CTemp)
	end
	CB = CreateVarArr(3,PlayerID)
	table.insert(CB,0)
	-------- Preset Limit --------------------------------
	for i = 1, 8 do
		if i < 6 then
			if type(Preset[i]) ~= "number" then
				CMov(PlayerID,CA[i],Preset[i])
			end
		end
	end

	CIf(PlayerID,NVar(CA[1],AtLeast,1))
		if iTblid[1][4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label();
				},
				actions = {
					SetNVar(CA[1],SetTo,0);
					SetCtrig1X(CB[2][1],CB[2][2],0x15C,CB[2][3],SetTo,iTblid[3]);
					SetCtrig1X(CB[3][1],CB[3][2],0x15C,CB[3][3],SetTo,iTblid[2]);
					SetCtrigX(iTblid[1][1],iTblid[1][2],0x158,iTblid[1][3],SetTo,CB[1][1],CB[1][2],0x15C,1,CB[1][3]);
					SetCtrig1X(iTblid[1][1],iTblid[1][2],0x148,iTblid[1][3],SetTo,0xFFFFFFFF);
					SetCtrig1X(iTblid[1][1],iTblid[1][2],0x160,iTblid[1][3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(iTblid[1][1],iTblid[1][2],iTblid[1][3]);
				},
				flag = {Preserved}
			}
		else
			for i = 1, #iTblid do
				Trigger {
					players = {PlayerID},
					conditions = {
						Label();
						NVar(CA[1],Exactly,i);
					},
					actions = {
						SetNVar(CA[1],SetTo,0);
						SetCtrig1X(CB[2][1],CB[2][2],0x15C,CB[2][3],SetTo,iTblid[i][3]);
						SetCtrig1X(CB[3][1],CB[3][2],0x15C,CB[3][3],SetTo,iTblid[i][2]);
						SetCtrigX(iTblid[i][1][1],iTblid[i][1][2],0x158,iTblid[i][1][3],SetTo,CB[1][1],CB[1][2],0x15C,1,CB[1][3]);
						SetCtrig1X(iTblid[i][1][1],iTblid[i][1][2],0x148,iTblid[i][1][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(iTblid[i][1][1],iTblid[i][1][2],0x160,iTblid[i][1][3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(iTblid[i][1][1],iTblid[i][1][2],iTblid[i][1][3]);
					},
					flag = {Preserved}
				}
			end
		end
	CIfEnd()

		NWhile(PlayerID,{NVar(CA[2],Exactly,0)})
			NIfX(PlayerID,{TNVar(CA[4],AtMost,Vi(CA[5][2],-1))})
		-------------------------------------------------------------------------
				CAPrintPlayerID = PlayerID
				CAPrintDataArr = CA
				CAPrintCreateArr = CB

				if CBfunc ~= nil then
					_G[CBfunc]()
				end
		-------------------------------------------------------------------------
				if PerAction == nil then PerAction = {} end
				table.insert(PerAction,SetNVar(CA[4],Add,1))
				CDoActionsX(PlayerID,PerAction)
			NElseX()
				CDoActions(PlayerID,{TSetNVar(CA[2],SetTo,CA[3]),SetNVar(CA[4],SetTo,0),SetNext("X",CAPrintVarAlloc)})
			NIfXEnd()
		NWhileEnd()
		Trigger {players = {PlayerID},conditions = {Label(CAPrintVarAlloc)},flag = {Preserved}}
		CAPrintVarAlloc = CAPrintVarAlloc + 1

	CIfEnd()
	DoActionsX(PlayerID,{SetNVar(CA[2],Subtract,1)})

	local Ret = CA, CB
	CAPrintPlayerID = {}
	CAPrintDataArr = {}
	CAPrintCreateArr = {}
	return Ret
end

function FixText(PlayerID,Preset)
	if bit32.band(Preset, 1) == 1 then -- 0x1 : Save Line
		DoActionsX(PlayerID,SetNVar(ARet,SetTo,0))
		for i = 0, 3 do
			local CBit = 2^i
			Trigger {players = {PlayerID},conditions = {Label(),MemoryX(0x640B58,Exactly,CBit,CBit)},actions = {SetNVar(ARet,Add,CBit)},flag = {Preserved}}
		end
	end

	if bit32.band(Preset, 2) == 2 then -- 0x2 : Recover Line
		Trigger {players = {PlayerID},conditions = {Label()},actions = {
			SetCtrig1X(ARet[1],ARet[2],0x158,ARet[3],SetTo,EPD(0x640B58));
			SetCtrig1X(ARet[1],ARet[2],0x148,ARet[3],SetTo,0xFFFFFFFF);
			SetCtrig1X(ARet[1],ARet[2],0x160,ARet[3],SetTo,SetTo*16777216,0xFF000000);
			CallLabelAlwaysX(ARet);
		},flag = {Preserved}}
	end
end

function CSPrint(iStrid,SVA32,DisplayPlayer,FixText,PlayerID,Condition,CpAction,Action,Preserve)
	if CpAction == nil then
		CpAction = {}
	elseif CpAction.__trg_magic == "action" then
		CpAction = {CpAction}
	end

	if SVA32[4] ~= "SVA32" then
		CSPrint_InputData_Error()
	end
	if iStrid[3] < SVA32[6] then
		CSPrint_StringSize_Overflow()
	end
	local SameSize = 0
	if iStrid[3] == SVA32[6] then
		SameSize = 1
	end
	local flag
	if Preserve == nil or Preserve == 0 or Preserve == "X" then
		flag = 0
	else
		flag = 1
	end

	local SVA32Arr = {}
	local Size = SVA32[5]
	for i = 0, Size-1 do
		table.insert(SVA32Arr,{SVA32[1],SVA32[2],SVA32[3]+i})
	end

	if FixText == 1 or FixText == 3 then
		DoActionsX(PlayerID,SetNVar(ARet,SetTo,0))
		for i = 0, 3 do
			local CBit = 2^i
			Trigger {players = {PlayerID},conditions = {Label(),MemoryX(0x640B58,Exactly,CBit,CBit)},actions = {SetNVar(ARet,Add,CBit)},flag = {Preserved}}
		end
	end

	if flag == 0 then
		CIfOnce(PlayerID,Condition,Action)
	else
		CIf(PlayerID,Condition,Action)
	end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(iStrid[1][1],iStrid[1][2],0x158,iStrid[1][3],SetTo,EPD(0x6509B0));
					SetCtrig1X(iStrid[1][1],iStrid[1][2],0x148,iStrid[1][3],SetTo,0xFFFFFFFF);
					SetCtrig1X(iStrid[1][1],iStrid[1][2],0x160,iStrid[1][3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlwaysN(iStrid[1],table.unpack(SVA32Arr));
				},
				flag = {Preserved}
			}
		local CpActions = {DisplayTextX(iStrid[4],4),table.unpack(CpAction)}
		local DisplayTrig = {}
		local VariableTrig = {}
		if SameSize == 0 then
			table.insert(DisplayTrig,SetDeaths(CurrentPlayer,SetTo,0,0))
			table.insert(VariableTrig,SetDeaths(CurrentPlayer,SetTo,0,0))
		end

		local DisplayPlayers = {}
		if DisplayPlayer ~= nil then
			for k, v in pairs(DisplayPlayer) do
				if type(v) == "table" and v[4] == "V" then
					table.insert(VariableTrig,{TSetMemory,0x6509B0,SetTo,v})
					table.insert(VariableTrig,DisplayText(iStrid[4],4))
				else
					table.insert(DisplayPlayers,v)
				end
			end
		end
		if #VariableTrig <= 1 then
			if DisplayPlayer ~= nil then
				table.insert(DisplayTrig,CopyCpActionX(CpActions,DisplayPlayers))
			end
			DoActions2X(PlayerID,{DisplayTrig})
		else
			if #DisplayPlayers ~= 0  then
				table.insert(VariableTrig,CopyCpActionX({DisplayTextX(iStrid[4],4)},DisplayPlayers))
			end
			CDoActionsX(PlayerID,VariableTrig)
		end
		RecoverCp(PlayerID)
	CIfEnd()
	if FixText == 2 or FixText == 3 then
		CDoActions(PlayerID,{TSetMemory(0x640B58,SetTo,ARet)})
	end
end

function GetStrId(String)
	StringKey = ParseString(String)
	table.insert(StringKeyArr,StringKey)
	return StringKey
end

function GetStrSize(cp949flag,String,Null)
	if type(String) == "number" then
		String = DecodeString(String)
	end
	local Size = 0
	if Null == nil then
		Null = 0
	else
		Null = 1
	end
	if cp949flag == "X" or cp949flag == nil or cp949flag == 0 then -- utf8 Size
		String = cp949_to_utf8(String)
		Size = #String-1+Null
	else -- cp949 Size
		Size = #String+Null
	end
	return Size
end

function GetStrArr(cp949flag,String,Null)
	if type(String) == "number" then
		String = DecodeString(String)
	end
	local Size = 0
	local Arr = {}
	if Null == nil then
		Null = 0
	else
		Null = 1
	end
	if cp949flag == "X" or cp949flag == nil or cp949flag == 0 then -- utf8 Size
		if Null == 0 then
			Arr = cp949_to_utf8(String)
			table.remove(Arr,#Arr)
		else
			Arr = cp949_to_utf8(String)
		end
	else -- cp949 Size
		for i = 1, #String do
			table.insert(Arr,string.byte(String,i))
		end
		if Null ~= 0 then
			table.insert(Arr,0)
		end
	end
	return Arr
end

function Print_String(PlayerID, Dest, String, InitBytes) -- EPD / CPRead
	STPopTrigArr(PlayerID)
	if type(Dest) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,SetTo,Dest);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X(Dest[1],Dest[2],0x158,Dest[3],SetTo,EPD(0x6509B0));
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Dest[1],Dest[2],Dest[3]);
			},
			flag = {Preserved}
		}
	elseif Dest[4] == "VA" then
		local TempRet = {"X",CRet[1],0,"V"}
		MovX(PlayerID,TempRet,Dest)
		Dest = TempRet
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X(Dest[1],Dest[2],0x158,Dest[3],SetTo,EPD(0x6509B0));
				SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Dest[1],Dest[2],Dest[3]);
			},
			flag = {Preserved}
		}
	end

	local Mask1
	if InitBytes == 0 then
		Mask1 = 0xFFFFFFFF
	elseif InitBytes == 1 then
		Mask1 = 0xFFFFFF00
	elseif InitBytes == 2 then
		Mask1 = 0xFFFF0000 
	elseif InitBytes == 3 then
		Mask1 = 0xFF000000 
	else
		print_String_InputData_Error()
	end

    local ret = {}
    if type(String) == "string" then
        local str = String
        local n = 1

        if InitBytes == "X" or InitBytes == nil then
        	InitBytes = 0
        end

        if InitBytes == 1 then
            str = '\0'..str 
        elseif InitBytes == 2 then
        	str = '\0\0'..str 
       	elseif InitBytes == 3 then
       		str = '\0\0\x0D'..str 
        end

        local t = cp949_to_utf8(str)

        while n <= #t do
        	if n+4 > #t then
        		local M = #t - n
        		if M == 1 then 
        			table.insert(ret,SetDeathsX(CurrentPlayer, SetTo, _dw(t, n),0,0xFF))
        		elseif M == 2 then
        			table.insert(ret,SetDeathsX(CurrentPlayer, SetTo, _dw(t, n),0,0xFFFF))
        		elseif M == 3 then
        			table.insert(ret,SetDeathsX(CurrentPlayer, SetTo, _dw(t, n),0,0xFFFFFF))
        		end
        	else
	        	if n == 1 then
	        		table.insert(ret,SetDeathsX(CurrentPlayer, SetTo, _dw(t, n),0,Mask1))
	            	table.insert(ret,SetMemory(0x6509B0,Add,1))
	            else
	            	table.insert(ret,SetDeaths(CurrentPlayer, SetTo, _dw(t, n),0))
	            	table.insert(ret,SetMemory(0x6509B0,Add,1))
	           	end
            end
            n = n + 4
        end
    else
    	print_String_InputData_Error()
    end
    DoActions2X(PlayerID,ret)
    RecoverCp(PlayerID)
end

function Print_StringX(PlayerID, DestVA, String, InitBytes) -- EPD / CPRead
	STPopTrigArr(PlayerID)
	if DestVA[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig2X(0x6509B0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]);
			},
			flag = {Preserved}
		}
	elseif DestVA[4] == "VA" then
		local TempRet = {"X",CRet[1],0,"V"}
		MovZ(PlayerID,TempRet,DestVA,0x15C)
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}
	end

	local Mask1
	if InitBytes == 0 then
		Mask1 = 0xFFFFFFFF
	elseif InitBytes == 1 then
		Mask1 = 0xFFFFFF00
	elseif InitBytes == 2 then
		Mask1 = 0xFFFF0000 
	elseif InitBytes == 3 then
		Mask1 = 0xFF000000 
	else
		print_String_InputData_Error()
	end

    local ret = {}
    if type(String) == "string" then
        local str = String
        local n = 1

        if InitBytes == "X" or InitBytes == nil then
        	InitBytes = 0
        end

        if InitBytes == 1 then
            str = '\0'..str 
        elseif InitBytes == 2 then
        	str = '\0\0'..str 
       	elseif InitBytes == 3 then
       		str = '\0\0\x0D'..str 
        end

        local t = cp949_to_utf8(str)

        while n <= #t do
        	if n+4 > #t then
        		local M = #t - n
        		if M == 1 then 
        			table.insert(ret,SetDeathsX(CurrentPlayer, SetTo, _dw(t, n),0,0xFF))
        		elseif M == 2 then
        			table.insert(ret,SetDeathsX(CurrentPlayer, SetTo, _dw(t, n),0,0xFFFF))
        		elseif M == 3 then
        			table.insert(ret,SetDeathsX(CurrentPlayer, SetTo, _dw(t, n),0,0xFFFFFF))
        		end
        	else
	        	if n == 1 then
	        		table.insert(ret,SetDeathsX(CurrentPlayer, SetTo, _dw(t, n),0,Mask1))
	            	table.insert(ret,SetMemory(0x6509B0,Add,604))
	            else
	            	table.insert(ret,SetDeaths(CurrentPlayer, SetTo, _dw(t, n),0))
	            	table.insert(ret,SetMemory(0x6509B0,Add,604))
	           	end
            end
            n = n + 4
        end
    else
    	print_String_InputData_Error()
    end
    DoActions2X(PlayerID,ret)
    RecoverCp(PlayerID)
end

function Print_13(PlayerID,DisplayPlayer,String)
	STPopTrigArr(PlayerID)
	local X = {SetMemory(0x628438,SetTo,0)}
	local Y = {}
	if type(DisplayPlayer) == "number" then
		temp = {DisplayPlayer}
		DisplayPlayer = temp
	end
	for k, P in pairs(DisplayPlayer) do
		if type(P) == "number" then
			table.insert(X,CreateUnit(1,0,"Anywhere",P))
		elseif P[4] == "V" then
			if P[5] == nil then
				P[5] = 0
			end
			table.insert(X,{TCreateUnit,1,0,"Anywhere",P})
		end
 	end
	if String ~= nil then
		table.insert(Y,print_utf8(12, 0, String))
	end
	CIf(PlayerID,Memory(0x628438,AtLeast,1))
		f_ReadX(PlayerID,0x628438,V(FuncAlloc),1,0xFFFFFF) 
		CDoActionsX(PlayerID,X)
		for k, P in pairs(DisplayPlayer) do
			if type(P) == "number" then
				CTrigger(PlayerID,{Memory(0x512684,Exactly,P)},{print_utf8(12, 0,"								"),Y},{Preserved})
			elseif P[4] == "V" then
				CTrigger(PlayerID,{TMemory(0x512684,Exactly,P)},{print_utf8(12, 0,"								"),Y},{Preserved})
			end
		end
		CVariable2(PlayerID,FuncAlloc,0x628438,SetTo,0)
	CIfEnd()
	FuncAlloc = FuncAlloc + 1
end

function GetPlayerName(PlayerID,TargetPlayer,OutputVA,InitBytes) -- VA[1~5] 사용
	if InitBytes == nil then
		InitBytes = 0
	end
	GetNameVArr = GetVArray(OutputVA)
	DoActionsX(PlayerID,{SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x0D0D0D0D),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D)})
	if InitBytes == 0 then
		for i = 0, 3 do
			f_ReadX(PlayerID,0x6D0FDC + 0x24*TargetPlayer+0x4*i,VArr(GetNameVArr,0+i),1,0xFFFFFFFF) -- 0123 -> 0123
		end
	elseif InitBytes == 1 then
		for i = 0, 3 do
			f_ReadX(PlayerID,0x6D0FDC + 0x24*TargetPlayer+0x4*i,VArr(GetNameVArr,0+i),256,0xFFFFFF) -- 012->123 / 3->0 
			f_ReadX(PlayerID,0x6D0FDC + 0x24*TargetPlayer+0x4*i,VArr(GetNameVArr,1+i),1/16777216,0xFF000000)
		end
	elseif InitBytes == 2 then
		for i = 0, 3 do
			f_ReadX(PlayerID,0x6D0FDC + 0x24*TargetPlayer+0x4*i,VArr(GetNameVArr,0+i),65536,0xFFFF) -- 01->23 / 23->01 
			f_ReadX(PlayerID,0x6D0FDC + 0x24*TargetPlayer+0x4*i,VArr(GetNameVArr,1+i),1/65536,0xFFFF0000)
		end
	elseif InitBytes == 3 then
		for i = 0, 3 do
			f_ReadX(PlayerID,0x6D0FDC + 0x24*TargetPlayer+0x4*i,VArr(GetNameVArr,0+i),16777216,0xFF) -- 0->3 / 123->012 
			f_ReadX(PlayerID,0x6D0FDC + 0x24*TargetPlayer+0x4*i,VArr(GetNameVArr,1+i),1/256,0xFFFFFF00)
		end
	end
end

function GetPlayerLength(PlayerID,TargetPlayer,Output,Multiplier)
	if Multiplier == nil then
		Multiplier = 1
	end
	for i = 2, 15 do
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				MemoryB(0x6D0FDC+i+0x24*TargetPlayer,AtLeast,1);
			},
			actions = {
				SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,(i+1)*Multiplier);
			},
			flag = {Preserved}
		}
	end
end

function ItoX(PlayerID,Input,OutputVA,Color) -- VA[0~3]
	if Color == nil or Color == "X" or Color == 0 then
 		Color = 0x0D
 	end
 	if type(Color) == "number" then
 		local TempColor = Color
 		Color = {}
 		for i = 1, 4 do
 			table.insert(Color,TempColor)
 		end
	end
	for i = 1, 4 do
		if Color[i] == nil or Color[i] == "X" or Color[i] == 0 then
			Color[i] = 0xD
		end
	end

	if type(OutputVA[4]) == "string" and OutputVA[4] ~= "X" then -- VArray 0 ~ 3 / 1234 -> １２３４

		DoActionsX(PlayerID,{SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x60BCEF00+Color[1]),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x60BCEF00+Color[2]),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x60BCEF00+Color[3]),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x60BCEF00+Color[4])})

		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x60*1,0xFF);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7E*1,0xFF);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x20BD0000,0xFFFF0000);
			},
			flag = {Preserved}
		}
		for i = 7, 0, -1 do -- 1 -> １
 			CBit = 2^i 
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,CBit,CBit);
				},
				actions = {
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x5C*1,0xFF);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0xA6BFEF00,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x20*0x1,0xFF);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x8080E300,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x1F*1,0xFF);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x0D0D0D00,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x7F*1,0xFF);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x0D0D0D00,0xFFFFFF00);
			},
			flag = {Preserved}
		}

		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x60*0x100,0xFF00);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7E*0x100,0xFF00);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x20BD0000,0xFFFF0000);
			},
			flag = {Preserved}
		}
		for i = 15, 8, -1 do -- 2 -> ２
 			CBit = 2^i 
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,CBit,CBit);
				},
				actions = {
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,2^i*0x010000);
				},
				flag = {Preserved}
			}
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x60*0x100,0xFF00);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x00BD0000,0x00FF0000);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x5C*0x100,0xFF00);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0xA6BFEF00,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x20*0x100,0xFF00);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x8080E300,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x1F*0x100,0xFF00);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D00,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x7F*0x100,0xFF00);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D00,0xFFFFFF00);
			},
			flag = {Preserved}
		}


		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x60*0x10000,0xFF0000);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7E*0x10000,0xFF0000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x20BD0000,0xFFFF0000);
			},
			flag = {Preserved}
		}
		for i = 23, 16, -1 do -- 3 -> ３
 			CBit = 2^i 
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,CBit,CBit);
				},
				actions = {
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,2^i*0x0100);
				},
				flag = {Preserved}
			}
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x60*0x10000,0xFF0000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x00BD0000,0x00FF0000);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x5C*0x10000,0xFF0000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0xA6BFEF00,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x20*0x10000,0xFF0000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x8080E300,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x1F*0x10000,0xFF0000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D00,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x7F*0x10000,0xFF0000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D00,0xFFFFFF00);
			},
			flag = {Preserved}
		}


		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x60*0x1000000,0xFF000000);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7E*0x1000000,0xFF000000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x20BD0000,0xFFFF0000);
			},
			flag = {Preserved}
		}
		for i = 31, 24, -1 do -- 4 -> ４
 			CBit = 2^i 
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,CBit,CBit);
				},
				actions = {
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,Add,2^i*0x01);
				},
				flag = {Preserved}
			}
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x60*0x1000000,0xFF000000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x00BD0000,0x00FF0000);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x5C*0x1000000,0xFF000000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0xA6BFEF00,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x20*0x1000000,0xFF000000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x8080E300,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x1F*0x1000000,0xFF000000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D00,0xFFFFFF00);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x7F*0x1000000,0xFF000000);
			},
			actions = {
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D00,0xFFFFFF00);
			},
			flag = {Preserved}
		}

	else -- 선택 1234->１２３４
		if OutputVA[1] ~= nil or OutputVA[1] ~= "X" then
			DoActionsX(PlayerID,{SetCtrig1X(OutputVA[1][1],OutputVA[1][2],0x15C,OutputVA[1][3],SetTo,0x60BCEF00+Color[1])})

			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x60*1,0xFF);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7E*1,0xFF);
				},
				actions = {
					SetCtrig1X(OutputVA[1][1],OutputVA[1][2],0x15C,OutputVA[1][3],SetTo,0x20BD0000,0xFFFF0000);
				},
				flag = {Preserved}
			}
			for i = 7, 0, -1 do -- 1 -> １
	 			CBit = 2^i 
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,CBit,CBit);
					},
					actions = {
						SetCtrig1X(OutputVA[1][1],OutputVA[1][2],0x15C,OutputVA[1][3],Add,2^i*0x01000000);
					},
					flag = {Preserved}
				}
			end
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x5C*1,0xFF);
				},
				actions = {
					SetCtrig1X(OutputVA[1][1],OutputVA[1][2],0x15C,OutputVA[1][3],SetTo,0xA6BFEF00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x20*0x1,0xFF);
				},
				actions = {
					SetCtrig1X(OutputVA[1][1],OutputVA[1][2],0x15C,OutputVA[1][3],SetTo,0x8080E300,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x1F*0x1,0xFF);
				},
				actions = {
					SetCtrig1X(OutputVA[1][1],OutputVA[1][2],0x15C,OutputVA[1][3],SetTo,0x0D0D0D00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x7F*0x1,0xFF);
				},
				actions = {
					SetCtrig1X(OutputVA[1][1],OutputVA[1][2],0x15C,OutputVA[1][3],SetTo,0x0D0D0D00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
		end

		if OutputVA[2] ~= nil or OutputVA[2] ~= "X" then
			DoActionsX(PlayerID,{SetCtrig1X(OutputVA[2][1],OutputVA[2][2],0x15C,OutputVA[2][3],SetTo,0x60BCEF00+Color[2])})

			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x60*0x100,0xFF00);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7E*0x100,0xFF00);
				},
				actions = {
					SetCtrig1X(OutputVA[2][1],OutputVA[2][2],0x15C,OutputVA[2][3],SetTo,0x20BD0000,0xFFFF0000);
				},
				flag = {Preserved}
			}
			for i = 15, 8, -1 do -- 1 -> １
	 			CBit = 2^i 
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,CBit,CBit);
					},
					actions = {
						SetCtrig1X(OutputVA[2][1],OutputVA[2][2],0x15C,OutputVA[2][3],Add,2^i*0x010000);
					},
					flag = {Preserved}
				}
			end
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x5C*0x100,0xFF00);
				},
				actions = {
					SetCtrig1X(OutputVA[2][1],OutputVA[2][2],0x15C,OutputVA[2][3],SetTo,0xA6BFEF00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x20*0x100,0xFF00);
				},
				actions = {
					SetCtrig1X(OutputVA[2][1],OutputVA[2][2],0x15C,OutputVA[2][3],SetTo,0x8080E300,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x1F*0x100,0xFF00);
				},
				actions = {
					SetCtrig1X(OutputVA[2][1],OutputVA[2][2],0x15C,OutputVA[2][3],SetTo,0x0D0D0D00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x7F*0x100,0xFF00);
				},
				actions = {
					SetCtrig1X(OutputVA[2][1],OutputVA[2][2],0x15C,OutputVA[2][3],SetTo,0x0D0D0D00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
		end

		if OutputVA[3] ~= nil or OutputVA[3] ~= "X" then
			DoActionsX(PlayerID,{SetCtrig1X(OutputVA[3][1],OutputVA[3][2],0x15C,OutputVA[3][3],SetTo,0x60BCEF00+Color[3])})

			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x60*0x10000,0xFF0000);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7E*0x10000,0xFF0000);
				},
				actions = {
					SetCtrig1X(OutputVA[3][1],OutputVA[3][2],0x15C,OutputVA[3][3],SetTo,0x20BD0000,0xFFFF0000);
				},
				flag = {Preserved}
			}
			for i = 23, 16, -1 do -- 1 -> １
	 			CBit = 2^i 
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,CBit,CBit);
					},
					actions = {
						SetCtrig1X(OutputVA[3][1],OutputVA[3][2],0x15C,OutputVA[3][3],Add,2^i*0x0100);
					},
					flag = {Preserved}
				}
			end
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x5C*0x10000,0xFF0000);
				},
				actions = {
					SetCtrig1X(OutputVA[3][1],OutputVA[3][2],0x15C,OutputVA[3][3],SetTo,0xA6BFEF00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x20*0x10000,0xFF0000);
				},
				actions = {
					SetCtrig1X(OutputVA[3][1],OutputVA[3][2],0x15C,OutputVA[3][3],SetTo,0x8080E300,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x1F*0x10000,0xFF0000);
				},
				actions = {
					SetCtrig1X(OutputVA[3][1],OutputVA[3][2],0x15C,OutputVA[3][3],SetTo,0x0D0D0D00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x7F*0x10000,0xFF0000);
				},
				actions = {
					SetCtrig1X(OutputVA[3][1],OutputVA[3][2],0x15C,OutputVA[3][3],SetTo,0x0D0D0D00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
		end

		if OutputVA[4] ~= nil or OutputVA[4] ~= "X" then
			DoActionsX(PlayerID,{SetCtrig1X(OutputVA[4][1],OutputVA[4][2],0x15C,OutputVA[4][3],SetTo,0x60BCEF00+Color[4])})

			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x60*0x1000000,0xFF000000);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7E*0x1000000,0xFF000000);
				},
				actions = {
					SetCtrig1X(OutputVA[4][1],OutputVA[4][2],0x15C,OutputVA[4][3],SetTo,0x20BD0000,0xFFFF0000);
				},
				flag = {Preserved}
			}
			for i = 31, 24, -1 do -- 1 -> １
	 			CBit = 2^i 
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,CBit,CBit);
					},
					actions = {
						SetCtrig1X(OutputVA[4][1],OutputVA[4][2],0x15C,OutputVA[4][3],Add,2^i*0x01);
					},
					flag = {Preserved}
				}
			end
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x5C*0x1000000,0xFF000000);
				},
				actions = {
					SetCtrig1X(OutputVA[4][1],OutputVA[4][2],0x15C,OutputVA[4][3],SetTo,0xA6BFEF00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],Exactly,0x20*0x1000000,0xFF000000);
				},
				actions = {
					SetCtrig1X(OutputVA[4][1],OutputVA[4][2],0x15C,OutputVA[4][3],SetTo,0x8080E300,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x1F*0x1000000,0xFF000000);
				},
				actions = {
					SetCtrig1X(OutputVA[4][1],OutputVA[4][2],0x15C,OutputVA[4][3],SetTo,0x0D0D0D00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x7F*0x1000000,0xFF000000);
				},
				actions = {
					SetCtrig1X(OutputVA[4][1],OutputVA[4][2],0x15C,OutputVA[4][3],SetTo,0x0D0D0D00,0xFFFFFF00);
				},
				flag = {Preserved}
			}
		end
	end
end

function ItoName(PlayerID,TargetPlayer,OutputVA,Color) -- VA[0~4]
	if Color == nil or Color == "X" or Color == 0 then
 		Color = 0x0D
 	end
	GetNameVArr = GetVArray(OutputVA)
	DoActionsX(PlayerID,{SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x000D0D0D + Color*0x01000000),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D)})
	for i = 0, 3 do
		f_ReadX(PlayerID,0x6D0FDC + 0x24*TargetPlayer+0x4*i,VArr(GetNameVArr,1+i),1,0xFFFFFFFF) -- 0123->0123
	end
end

function ItoHost(PlayerID,OutputVA,Color) -- VA[0~4]
	if Color == nil or Color == "X" or Color == 0 then
 		Color = 0x0D
 	end
	GetNameVArr = GetVArray(OutputVA)
	DoActionsX(PlayerID,{SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x000D0D0D + Color*0x01000000),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D)})
	for i = 0, 3 do
		f_ReadX(PlayerID,0x6D0F78 +0x4*i,VArr(GetNameVArr,1+i),1,0xFFFFFFFF) -- 0123->0123
	end
end
function ItoDec(PlayerID,Input,OutputVA,ZeroMode,Color,Sign,DigitMax,DigitMin) -- VA index = 상수 / Int -> Dec VA[0~3]
	STPopTrigArr(PlayerID)
-- B = 0x20, C = ColorCod, S = Sign, 0~9 = Number, X = 0x0D
-- ZeroMode : 0 표시 방법 선택 / 0 (0) / Space (1) / 0x0D (2)
-- Color : 컬러코드 추가 / 0x01 ~ 0x1F (기본 0x0D)
-- Sign : 부호 추가 / 부호없음 (0) / 부호추가(1) / 부호추가 +Space (2)
-- DigitMax : 시작 자리수 (기본 10) / DigitMin : 끝 자리수 (기본1)
 	if Sign == nil or Sign == "X" then
 		Sign = 0
 	end
 	if Color == nil or Color == "X" or Color == 0 then
 		Color = 0x0D
 	end
 	if ZeroMode == nil or ZeroMode == "X" then
 		ZeroMode = 0
 	end
 	if ZeroMode == 0 then
 		ZeroMode = 0x30
 	elseif ZeroMode == 1 then
 		ZeroMode = 0x20
 	elseif ZeroMode == 2 then
 		ZeroMode = 0x0D
 	end
 	if DigitMax == nil or DigitMax == "X" then
 		DigitMax = 10
 	end
 	if DigitMin == nil or DigitMin == "X" then
 		DigitMin = 1
 	end

 	local X = {}
 	if Sign == 0 then
	 	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
				CallLabelAlways(Input[1],Input[2],Input[3]);
			},
			flag = {Preserved}
		}
	else
		CIfX(PlayerID, CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7FFFFFFF))
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
					CallLabelAlways(Input[1],Input[2],Input[3]);
				},
				flag = {Preserved}
			}
		CElseX()
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
					SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,Subtract*16777216,0xFF000000);
					SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
					CallLabelAlways(Input[1],Input[2],Input[3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
				},
				flag = {Preserved}
			}
		CIfXEnd()
	end
 	-- XXXX[0] 90SC[1] 5678[2] 1234[3] / CXXX[0] 90BS[1] 5678[2] 1234[3]
 	if Sign == 0 then
	 	DoActionsX(PlayerID,{SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x0D0D0D0D),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x30*0x01010000 + 0x00000D00 + Color*0x00000001),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x30*0x01010101),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x30*0x01010101)})
	 elseif Sign == 1 then
	 	DoActionsX(PlayerID,{SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x0D0D0D0D),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x30*0x01010000 + 0x00000D00 + Color*0x00000001),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x30*0x01010101),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x30*0x01010101)})
	 	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7FFFFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x00002B00,0x0000FF00)},flag = {Preserved}}
	 	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x80000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x00002D00,0x0000FF00)},flag = {Preserved}}
	 elseif Sign == 2 then
	 	DoActionsX(PlayerID,{SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x000D0D0D + Color * 0x01000000),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x30*0x01010000 + 0x0000200D),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x30*0x01010101),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x30*0x01010101)})
	 	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7FFFFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0000002B,0x000000FF)},flag = {Preserved}}
	 	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x80000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0000002D,0x000000FF)},flag = {Preserved}}
	 end

	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,999999999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x00010000*ZeroMode,0x00FF0000)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,99999999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x01000000*ZeroMode,0xFF000000)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,9999999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x00000001*ZeroMode,0x000000FF)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,999999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x00000100*ZeroMode,0x0000FF00)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,99999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x00010000*ZeroMode,0x00FF0000)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,9999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x01000000*ZeroMode,0xFF000000)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x00000001*ZeroMode,0x000000FF)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,99);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x00000100*ZeroMode,0x0000FF00)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,9);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x00010000*ZeroMode,0x00FF0000)},flag = {Preserved}}
	 	
 	for i = 2, 0, -1 do
 			CBit = 2^i * 1000000000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,2^i*0x010000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 100000000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 10000000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,2^i*0x00000001);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 1000000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,2^i*0x0100);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 100000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,2^i*0x010000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 10000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 1000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,Add,2^i*0x01);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 100
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,Add,2^i*0x0100);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 10
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,Add,2^i*0x010000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 1
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	if DigitMax == 9 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0x00FF0000))
	 elseif DigitMax == 8 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFF0000))
	 elseif DigitMax == 7 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFF0000))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0x000000FF))
	 elseif DigitMax == 6 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFF0000))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0x0000FFFF))
	 elseif DigitMax == 5 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFF0000))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0x00FFFFFF))
	 elseif DigitMax == 4 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFF0000))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 elseif DigitMax == 3 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFF0000))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0x000000FF))
	 elseif DigitMax == 2 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFF0000))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0x0000FFFF))
	 elseif DigitMax == 1 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFF0000))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0x00FFFFFF))
	 end

	 if DigitMin == 2 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFF000000))
	 elseif DigitMin == 3 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFF0000))
	 elseif DigitMin == 4 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 5 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 elseif DigitMin == 6 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFF000000))
	 elseif DigitMin == 7 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFF0000))
	 elseif DigitMin == 8 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 9 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 elseif DigitMin == 10 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFF000000))
	 end
	 DoActionsX(PlayerID,X)
end

function ItoHex(PlayerID,Input,OutputVA,ZeroMode,Color,Case,DigitMax,DigitMin) -- VA index = 상수 / Int -> Hex VA[0~2]
	STPopTrigArr(PlayerID)
-- B = 0x20, C = ColorCod, 1~8 = Number, X = 0x0D
-- ZeroMode : 0 표시 방법 선택 / 0 (0) / Space (1) / 0x0D (2)
-- Color : 컬러코드 추가 / 0x01 ~ 0x1F (기본 0x0D)
-- DigitMax : 시작 자리수 (기본 8) / DigitMin : 끝 자리수 (기본1)
-- Case : 대소문자 / 대문자(0) / 소문자(1)
	if Case == nil or Case == "X" then
		Case = 0
	end
	if Case == 0 then
		Case = 0x7
	elseif Case == 1 then
		Case = 0x27
	end
 	if Color == nil or Color == "X" or Color == 0 then
 		Color = 0x0D
 	end
 	if ZeroMode == nil or ZeroMode == "X" then
 		ZeroMode = 0
 	end
 	if ZeroMode == 0 then
 		ZeroMode = 0x30
 	elseif ZeroMode == 1 then
 		ZeroMode = 0x20
 	elseif ZeroMode == 2 then
 		ZeroMode = 0x0D
 	end
 	if DigitMax == nil or DigitMax == "X" then
 		DigitMax = 8
 	end
 	if DigitMin == nil or DigitMin == "X" then
 		DigitMin = 1
 	end

 	local X = {}
 	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
				CallLabelAlways(Input[1],Input[2],Input[3]);
			},
			flag = {Preserved}
		}

 	-- CXXX[0] 5678[1] 1234[2]
 	DoActionsX(PlayerID,{SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x000D0D0D + Color*0x01000000),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x30*0x01010101),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x30*0x01010101)})

	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFFFFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x00000001*ZeroMode,0x000000FF)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFFFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x00000100*ZeroMode,0x0000FF00)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x00010000*ZeroMode,0x00FF0000)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x01000000*ZeroMode,0xFF000000)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x00000001*ZeroMode,0x000000FF)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x00000100*ZeroMode,0x0000FF00)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x00010000*ZeroMode,0x00FF0000)},flag = {Preserved}}
	 	
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x10000000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,2^i*0x00000001);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,AtLeast,0xA,0x0000000F);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,0x00000001*Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x1000000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,2^i*0x0100);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,AtLeast,0xA00,0x00000F00);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,0x00000100*Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x100000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,2^i*0x010000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,AtLeast,0xA0000,0x000F0000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,0x00010000*Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x10000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,AtLeast,0xA000000,0x0F000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,0x01000000*Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x1000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,2^i*0x01);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,AtLeast,0xA,0x0000000F);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,0x00000001*Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x100
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,2^i*0x0100);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,AtLeast,0xA00,0x00000F00);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,0x00000100*Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x10
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,2^i*0x010000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,AtLeast,0xA0000,0x000F0000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,0x00010000*Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x1
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,AtLeast,0xA000000,0x0F000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,0x01000000*Case)},flag = {Preserved}}
	if DigitMax == 7 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0x000000FF))
	 elseif DigitMax == 6 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0x0000FFFF))
	 elseif DigitMax == 5 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0x00FFFFFF))
	 elseif DigitMax == 4 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 elseif DigitMax == 3 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0x000000FF))
	 elseif DigitMax == 2 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0x0000FFFF))
	 elseif DigitMax == 1 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0x00FFFFFF))
	 end

	 if DigitMin == 2 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFF000000))
	 elseif DigitMin == 3 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFF0000))
	 elseif DigitMin == 4 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 5 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 elseif DigitMin == 6 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFF000000))
	 elseif DigitMin == 7 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFF0000))
	 elseif DigitMin == 8 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFFFF))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 end
	 DoActionsX(PlayerID,X)
end
--[[ 3Bytes Code
0x90BCEF00 ~ 0x99BCEF00 : ０１２３４５６７８９
0x8BBCEF00 : ＋
0x8DBCEF00 : －
0x8080E300 : 　(Space)
0xA1BCEF00 ~ 0xBABCEF00 : Ａ～Ｚ
0x78BDEF00 ~ 0x93BDEF00 : ａ～ｚ
]]--
function ItoDecX(PlayerID,Input,OutputVA,ZeroMode,Color,Sign,DigitMax,DigitMin) -- VA index = 상수 / Int -> DecX VA[0~11] 
	STPopTrigArr(PlayerID)
-- B = 0x20, C = ColorCod, S = Sign, 0~9 = Number, X = 0x0D
-- ZeroMode : 0 표시 방법 선택 / 0 (0) / Space (1) / 0x0D (2)
-- Color : 컬러코드 추가 / 0x01 ~ 0x1F (기본 0x0D) : 맨뒤부터 적용
-- Sign : 부호 추가 / 부호없음 (0) / 부호추가(1) / 부호추가 +Space (2)
-- DigitMax : 시작 자리수 (기본 10) / DigitMin : 끝 자리수 (기본1)
 	if Sign == nil or Sign == "X" then
 		Sign = 0
 	end
 	if Color == nil or Color == "X" or Color == 0 then
 		Color = 0x0D
 	end
 	if type(Color) == "number" then
 		local TempColor = Color
 		Color = {}
 		for i = 1, 11 do
 			table.insert(Color,TempColor)
 		end
	end
	for i = 1, 11 do
		if Color[i] == nil or Color[i] == "X" or Color[i] == 0 then
			Color[i] = 0xD
		end
	end
 	if ZeroMode == nil or ZeroMode == "X" then
 		ZeroMode = 0
 	end
 	if ZeroMode == 0 then
 		ZeroMode = 0x90BCEF00
 	elseif ZeroMode == 1 then
 		ZeroMode = 0x8080E300
 	elseif ZeroMode == 2 then
 		ZeroMode = 0x0D0D0D00
 	end
 	if DigitMax == nil or DigitMax == "X" then
 		DigitMax = 10
 	end
 	if DigitMin == nil or DigitMin == "X" then
 		DigitMin = 1
 	end

 	local X = {}
 	if Sign == 0 then
	 	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
				CallLabelAlways(Input[1],Input[2],Input[3]);
			},
			flag = {Preserved}
		}
	else
		CIfX(PlayerID, CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7FFFFFFF))
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
					CallLabelAlways(Input[1],Input[2],Input[3]);
				},
				flag = {Preserved}
			}
		CElseX()
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
					SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,Subtract*16777216,0xFF000000);
					SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
					CallLabelAlways(Input[1],Input[2],Input[3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
				},
				flag = {Preserved}
			}
		CIfXEnd()
	end
	
	-- CXXX[0] BS-S[1] 0-0C[2] 9-9C[3] 8-8C[4] 7-7C[5] 6-6C[6] 5-5C[7] 4-4C[8] 3-3C[9] 2-2C[10] 1-1C[11] Sign == 2
 	-- XXXX[0] S-SC[1] 0-0C[2] 9-9C[3] 8-8C[4] 7-7C[5] 6-6C[6] 5-5C[7] 4-4C[8] 3-3C[9] 2-2C[10] 1-1C[11] Sign == 1
 	-- XXXX[0] XXXC[1] 0-0C[2] 9-9C[3] 8-8C[4] 7-7C[5] 6-6C[6] 5-5C[7] 4-4C[8] 3-3C[9] 2-2C[10] 1-1C[11] Sign == 0
 	if Sign == 0 then
	 	DoActionsX(PlayerID,{
	 			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+0,SetTo, 0x0D0D0D0D),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo, 0x0D0D0D00+Color[11]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo, 0x90BCEF00+Color[10]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo, 0x90BCEF00+Color[9]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo, 0x90BCEF00+Color[8]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo, 0x90BCEF00+Color[7]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo, 0x90BCEF00+Color[6]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo, 0x90BCEF00+Color[5]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo, 0x90BCEF00+Color[4]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo, 0x90BCEF00+Color[3]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x90BCEF00+Color[2]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x90BCEF00+Color[1])})
	 elseif Sign == 1 then
	 	DoActionsX(PlayerID,{
	 			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+0,SetTo, 0x0D0D0D0D),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo, 0x0D0D0D00+Color[11]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo, 0x90BCEF00+Color[10]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo, 0x90BCEF00+Color[9]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo, 0x90BCEF00+Color[8]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo, 0x90BCEF00+Color[7]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo, 0x90BCEF00+Color[6]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo, 0x90BCEF00+Color[5]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo, 0x90BCEF00+Color[4]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo, 0x90BCEF00+Color[3]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x90BCEF00+Color[2]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x90BCEF00+Color[1])})
	 	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7FFFFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x8BBCEF00,0xFFFFFF00)},flag = {Preserved}}
	 	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x80000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x8DBCEF00,0xFFFFFF00)},flag = {Preserved}}
	 elseif Sign == 2 then
	 	DoActionsX(PlayerID,{
	 			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+0,SetTo, 0x000D0D0D+Color[11]*0x01000000),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo, 0x200D0D0D),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo, 0x90BCEF00+Color[10]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo, 0x90BCEF00+Color[9]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo, 0x90BCEF00+Color[8]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo, 0x90BCEF00+Color[7]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo, 0x90BCEF00+Color[6]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo, 0x90BCEF00+Color[5]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo, 0x90BCEF00+Color[4]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo, 0x90BCEF00+Color[3]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x90BCEF00+Color[2]),
				SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x90BCEF00+Color[1])})
	 	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(Input[1],Input[2],0x15C,Input[3],AtMost,0x7FFFFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x008BBCEF,0x00FFFFFF)},flag = {Preserved}}
	 	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(Input[1],Input[2],0x15C,Input[3],AtLeast,0x80000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x008DBCEF,0x00FFFFFF)},flag = {Preserved}}
	 end
	
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,999999999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,99999999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,9999999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,999999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,99999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,9999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,999);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,99);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,9);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	
 	for i = 2, 0, -1 do
 			CBit = 2^i * 1000000000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 100000000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 10000000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 1000000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 100000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 10000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 1000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 100
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 10
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	for i = 3, 0, -1 do
 			CBit = 2^i * 1
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end

	if DigitMax == 9 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 8 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 7 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 6 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 5 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 4 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 3 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 2 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 1 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 end

	 if DigitMin == 2 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 3 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 4 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 5 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 6 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 7 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 8 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 9 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 10 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+11,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+10,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+9,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 end
	 DoActionsX(PlayerID,X)
end

function ItoHexX(PlayerID,Input,OutputVA,ZeroMode,Color,Case,DigitMax,DigitMin) -- VA index = 상수 / Int -> DecX VA[0~8] 
	STPopTrigArr(PlayerID)
-- B = 0x20, C = ColorCod,  1~8 = Number, X = 0x0D
-- ZeroMode : 0 표시 방법 선택 / 0 (0) / Space (1) / 0x0D (2)
-- Color : 컬러코드 추가 / 0x01 ~ 0x1F (기본 0x0D) : 맨뒤부터 적용
-- Case : 대소문자 / 대문자(0) / 소문자(1)
-- DigitMax : 시작 자리수 (기본 10) / DigitMin : 끝 자리수 (기본1)
 	if Case == nil or Case == "X" then
 		Case = 0
 	end
 	if Case == 0 then
		Case = 0x07000000
	elseif Case == 1 then
		Case = 0xE7010000
	end
 	if Color == nil or Color == "X" or Color == 0 then
 		Color = 0x0D
 	end
 	if type(Color) == "number" then
 		local TempColor = Color
 		Color = {}
 		for i = 1, 8 do
 			table.insert(Color,TempColor)
 		end
	end
	for i = 1, 8 do
		if Color[i] == nil or Color[i] == "X" or Color[i] == 0 then
			Color[i] = 0xD
		end
	end
 	if ZeroMode == nil or ZeroMode == "X" then
 		ZeroMode = 0
 	end
 	if ZeroMode == 0 then
 		ZeroMode = 0x90BCEF00
 	elseif ZeroMode == 1 then
 		ZeroMode = 0x8080E300
 	elseif ZeroMode == 2 then
 		ZeroMode = 0x0D0D0D00
 	end
 	if DigitMax == nil or DigitMax == "X" then
 		DigitMax = 8
 	end
 	if DigitMin == nil or DigitMin == "X" then
 		DigitMin = 1
 	end

 	local X = {}
 	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
				CallLabelAlways(Input[1],Input[2],Input[3]);
			},
			flag = {Preserved}
		}

	-- XXXX[0] 8-8C[1] 7-7C[2] 6-6C[3] 5-5C[4] 4-4C[5] 3-3C[6] 2-2C[7] 1-1C[8]
	 DoActionsX(PlayerID,{
	 		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+0,SetTo, 0x0D0D0D0D),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo, 0x90BCEF00+Color[8]),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo, 0x90BCEF00+Color[7]),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo, 0x90BCEF00+Color[6]),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo, 0x90BCEF00+Color[5]),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo, 0x90BCEF00+Color[4]),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo, 0x90BCEF00+Color[3]),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo, 0x90BCEF00+Color[2]),
			SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo, 0x90BCEF00+Color[1])})
	
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFFFFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFFFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xFF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	 Trigger {players = {PlayerID},conditions = {Label(0);CtrigX("X",CRet[1],0x15C,0,AtMost,0xF);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,ZeroMode,0xFFFFFF00)},flag = {Preserved}}
	
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x10000000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,AtLeast,0x0A000000,0x0F000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,Add,Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x1000000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,AtLeast,0x0A000000,0x0F000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,Add,Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x100000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,AtLeast,0x0A000000,0x0F000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,Add,Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x10000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,AtLeast,0x0A000000,0x0F000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,Add,Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x1000
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,AtLeast,0x0A000000,0x0F000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,Add,Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x100
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,AtLeast,0x0A000000,0x0F000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,Add,Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x10
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,AtLeast,0x0A000000,0x0F000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,Add,Case)},flag = {Preserved}}
	for i = 3, 0, -1 do
 			CBit = 2^i * 0x1
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX("X",CRet[1],0x15C,0,AtLeast,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,Subtract,CBit);
					SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,Add,2^i*0x01000000);
				},
				flag = {Preserved}
			}
	end
	Trigger {players = {PlayerID},conditions = {Label(0);CtrigX(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,AtLeast,0x0A000000,0x0F000000);},actions = {SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,Add,Case)},flag = {Preserved}}
	if DigitMax == 7 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 6 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 5 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 4 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 3 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 2 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMax == 1 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 end

	 if DigitMin == 2 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 3 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 4 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 5 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 6 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 7 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 elseif DigitMin == 8 then
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+8,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+7,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+6,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+5,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 	table.insert(X,SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D,0xFFFFFF00))
	 end
	 DoActionsX(PlayerID,X)
end


-- 64비트 정수 입력용 내부 함수 -------------------------------------------------------------------------------------------------------------------------

function I64(Number)
	local Ret1, Ret2
	if type(Number) == "number" then -- I32
		return Number
	elseif type(Number) == "table" then
		return Number
	elseif type(Number) == "string" then
		local Check = string.sub(Number,1,2) 
		if Check == "0x" or Check == "0X" then -- Hex
			local str1, str2, lenT, len1, len2
			lenT = string.len(Number)
			if lenT >= 19 or lenT <= 2 then
				I64_InputError()
			end
			len1 = 0
			len2 = lenT-2
			if len2 >= 9 then
				len2 = 8
				len1 = lenT - 10
			end
			
			if len1 == 0 then
				str2 = string.sub(Number,1,lenT) 
				Ret1 = 0
				Ret2 = tonumber(str2)
			else
				str1 = string.sub(Number,1,2+len1) 
				str2 = "0x"..string.sub(Number,3+len1,lenT) 
				Ret1 = tonumber(str1)
				Ret2 = tonumber(str2)
			end
			return {Ret2, Ret1}
		else -- Dec
			local str1, str2, lenT, len1, len2
			lenT = string.len(Number)
			local Neg = 0
			if string.sub(Number,1,1) == "-" then
				Neg = 1
				Number = string.sub(Number,2,lenT)
				lenT = lenT - 1
			end 
			if lenT >= 21 or lenT == 0 then
				I64_InputError()
			end
			len1 = 0
			len2 = lenT
			if len2 >= 11 then
				len2 = 10
				len1 = lenT - 10
			end
			local pt1, pt2
			if len1 == 0 then
				str2 = string.sub(Number,1,lenT) 
				pt1 = 0.0
				pt2 = tonumber(str2)
			else
				str1 = string.sub(Number,1,len1) 
				str2 = string.sub(Number,1+len1,lenT) 
				pt1 = tonumber(str1)
				pt2 = tonumber(str2)
			end

			if Neg == 1 then
				local Ret = I64Neg(pt1,pt2)
				pt1 = Ret[1]
				pt2 = Ret[2]
			end

			local Top = {
			922337203.0,
			461168601.0,
			230584300.0,
			115292150.0,
			57646075.0,
			28823037.0,
			14411518.0,
			7205759.0,

			3602879.0,
			1801439.0,
			900719.0,
			450359.0,
			225179.0,
			112589.0,
			56294.0,
			28147.0,

			14073.0,
			7036.0,
			3518.0,
			1759.0,
			879.0,
			439.0,
			219.0,
			109.0,

			54.0,
			27.0,
			13.0,
			6.0,
			3.0,
			1.0,
			0.0,
			0.0,

			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,

			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,

			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,

			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0,
			0.0
			}
			local Bottom = {
			6854775808.0,
			8427387904.0,
			9213693952.0,
			4606846976.0,
			2303423488.0,
			6151711744.0,
			8075855872.0,
			4037927936.0,

			7018963968.0,
			8509481984.0,
			9254740992.0,
			9627370496.0,
			9813685248.0,
			9906842624.0,
			9953421312.0,
			4976710656.0,

			7488355328.0,
			8744177664.0,
			4372088832.0,
			2186044416.0,
			6093022208.0,
			8046511104.0,
			9023255552.0,
			9511627776.0,

			9755813888.0,
			4877906944.0,
			7438953472.0,
			8719476736.0,
			4359738368.0,
			7179869184.0,
			8589934592.0,
			4294967296.0,

			2147483648.0,
			1073741824.0,
			536870912.0,
			268435456.0,
			134217728.0,
			67108864.0,
			33554432.0,
			16777216.0,

			8388608.0,
			4194304.0,
			2097152.0,
			1048576.0,
			524288.0,
			262144.0,
			131072.0,
			65536.0,

			32768.0,
			16384.0,
			8192.0,
			4096.0,
			2048.0,
			1024.0,
			512.0,
			256.0,

			128.0,
			64.0,
			32.0,
			16.0,
			8.0,
			4.0,
			2.0,
			1.0
			}

			local Bit = {
			0x80000000,
			0x40000000,
			0x20000000,
			0x10000000,
			0x8000000,
			0x4000000,
			0x2000000,
			0x1000000,

			0x800000,
			0x400000,
			0x200000,
			0x100000,
			0x80000,
			0x40000,
			0x20000,
			0x10000,

			0x8000,
			0x4000,
			0x2000,
			0x1000,
			0x800,
			0x400,
			0x200,
			0x100,

			0x80,
			0x40,
			0x20,
			0x10,
			0x8,
			0x4,
			0x2,
			0x1,
			}
			Ret1 = 0
			Ret2 = 0
			for i = 63, 32, -1 do
				local index = 64-i 
				local Ret = I64Sub(pt1,pt2,Top[index],Bottom[index])
				if Ret ~= 0 then
					pt1 = Ret[1]
					pt2 = Ret[2]
					Ret1 = Ret1 + Bit[index]
				end
			end

			for i = 31, 0, -1 do
				local index = 64-i
				local Ret = I64Sub(pt1,pt2,Top[index],Bottom[index])
				if Ret ~= 0 then
					pt1 = Ret[1]
					pt2 = Ret[2]
					Ret2 = Ret2 + Bit[32-i]
				end
			end

			return {Ret2, Ret1}
		end
	else
		I64_InputError()
	end
end

function I64Sub(a,b,c,d)
	local Ret1, Ret2
	if a < c then
		return 0
	else
		Ret1 = a - c
		if b >= d then
			Ret2 = b - d
			return {Ret1, Ret2}
		elseif Ret1 >= 1 then
			Ret1 = Ret1 - 1
			Ret2 = b - d + 10000000000
			return {Ret1, Ret2}
		else
			return 0
		end
	end
end

function I64Sub2(a,b,c,d)
	local Ret1, Ret2
	if a < c then
		return {0,0}
	else
		Ret1 = a - c
		if b >= d then
			Ret2 = b - d
			return {Ret1, Ret2}
		elseif Ret1 >= 1 then
			Ret1 = Ret1 - 1
			Ret2 = b - d + 10000000000
			return {Ret1, Ret2}
		else
			return {0,0}
		end
	end
end

function I64Neg(a,b)
	local Ret	
	Ret = I64Sub(1844674407,3709551616,a,b)
	if Ret[1] == 1844674407 and Ret[2] == 3709551616 then
		Ret[1] = 0
		Ret[2] = 0
	end
	return Ret
end

function I64Add(a,b,c,d)
	local Ret1, Ret2
	Ret1 = a+c
	Ret2 = b+d
	if Ret2 >= 4294967296 then
		Ret2 = Ret2 - 4294967296
		Ret1 = Ret1 + 1
	end
	return {Ret1, Ret2}
end

function I64Mul(a,b,c,d)
	local Ret = {0,0}
	local Temp = {a,b}
	for i = 0, 31 do
		local CBit = 2^i
		if bit32.band(d, CBit) == CBit then
			Ret = I64Add(Ret[1],Ret[2],Temp[1],Temp[2])
		end
		Temp = I64Add(Temp[1],Temp[2],Temp[1],Temp[2])
	end
	if c ~= 0 then
		for i = 0, 31 do
			local CBit = 2^i
			if bit32.band(c, CBit) == CBit then
				Ret = I64Add(Ret[1],Ret[2],Temp[1],Temp[2])
			end
			Temp = I64Add(Temp[1],Temp[2],Temp[1],Temp[2])
		end
	end
	return Ret
end

function I64Pow(a,b,c)
	local Ret = {a,b}
	if c == 0 then
		Ret = {0,1}
	else
		for i = 1, c-1 do
			Ret = I64Mul(Ret[1],Ret[2],a,b)
		end
	end
	return Ret
end

function I64Zero(Number,Digit)
	if Digit < 0  then
		I64Zero_InputError()
	end
	local Temp = 1
	local Str = ""
	for i = 2, Digit do
		Temp = Temp * 10
		if Number < Temp then
			Str = Str.."0"
		end
	end
	local Ret = Str..Number
	return Ret
end

function PushErrorMsg(Message)
	_G["\n"..Message.."\n"]() 
end

function PushRecoverCpMsg(Flag)
	if Flag == nil or Flag == 1 then
		DetectRecoverCp = 1
	else
		DetectRecoverCp = 0
	end
end

function PushValueMsg(...)
	local Message = "\n"
	local arg = table.pack(...)
	for k = 1, arg.n do
		if type(arg[k]) == "string" then
			Message = Message..arg[k].."\n"
		elseif type(arg[k]) == "function" then
			Message = Message.."function".."\n"
		elseif type(arg[k]) == "table" then
			if type(arg[k][1]) == "table" then
				for i = 1, #arg[k][1] do
					if type(arg[k][1][i]) == "string" then
						Message = Message..arg[k][1][i].."  "
					elseif type(arg[k][1][i]) == "function" then
						Message = Message.."function".."  "
					elseif type(arg[k][1][i]) == "number" then
						if arg[k][2] == "X" or arg[k][2] == "x" then
							Message = Message..string.format("%X",arg[k][1][i]).."  "
						elseif arg[k][2] == "F" or arg[k][2] == "f"  then
							Message = Message..string.format("%f",arg[k][1][i]).."  "
						else
							Message = Message..string.format("%d",math.floor(arg[k][1][i])).."  "
						end
					elseif arg[k][1][i] == nil then
						Message = Message.."nil".."  "
					elseif type(arg[k][1][i]) == "table" then
						Message = Message.."table".."  "
					else
						PushValueMsg_InputError()
					end
				end
				Message = Message.."\n"
			elseif arg[k][2] == "X" or arg[k][2] == "x" then
				Message = Message..string.format("%X",arg[k][1]).."\n"
			elseif arg[k][2] == "F" or arg[k][2] == "f"  then
				Message = Message..string.format("%f",arg[k][1]).."\n"
			else
				Message = Message..string.format("%d",math.floor(arg[k][1])).."\n"
			end
		elseif type(arg[k]) == "number" then
			Message = Message..string.format("%d",math.floor(arg[k])).."\n"
		elseif arg[k] == nil then
			Message = Message.."nil".."\n"
		else
			PushValueMsg_InputError()
		end 
	end
	_G["\n"..Message.."\n"]() 
end

function f_LMov(PlayerID,Dest,Source,Deviation,Mask,Clear) -- << (매크로형)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end
	if Deviation == "X" then
		Deviation = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LMov_InputData_Error()
	end
	if Deviation == nil then
		Deviation = {0,0}
	elseif type(Deviation) == "string" then -- Value "8"
		Deviation = I64(Deviation)
	elseif type(Deviation) == "number" then -- Value {4,4}만 허용
		LMov_InputData_Error()
	end

	local Mask2 = Mask
	if Clear == 1 then
		Mask2 = {0xFFFFFFFF,0xFFFFFFFF}
	end

	-- Value : "8bytes" / {4bytes,4bytes}
	-- Offset(epd) : 4bytes = {4bytes,4bytes+4(1)} / {4bytes,4bytes} / {4bytes,{Size}} = {4bytes,4bytes+Size}
	-- Dest : W ← Ax2, VAx2, WA / Source : W ← VAx2, WA (MovW)
	-- W << WA, LA / V << VA, A 
	
	if type(Source) == "table" and #Source == 2 then
		if type(Source[1]) == "table" and Source[1][4] == "A" then
			LMov_InputData_Error()
		end
		if type(Source[2]) == "table" and Source[2][4] == "A" then
			LMov_InputData_Error()
		end
		if type(Source[1]) == "table" and Source[1][4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source[1])
			Source[1] = TempRet
		end
		if type(Source[2]) == "table" and Source[2][4] == "VA" then
			local TempRet = {"X",NRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source[2])
			Source[2] = TempRet
		end
	end
	if type(Source) == "table" and Source[4] == "WA" then
		local TempRet = {"X",WRet[7],0,"W"}
		MovW(PlayerID,TempRet,Source)
		Source = TempRet
	end
	if type(Source) == "table" and Source[4] == "LA_V" then
		LMov_InputData_Error()
	end
	if type(Source) == "table" and Source[4] == "LA_W" then
		LMov_InputData_Error()
	end

	local PDest, PDest2, PDest1
	if type(Dest) == "table" and #Dest == 2 then
		if type(Dest[1]) == "table" and Dest[1][4] == "A" then
			PDest1 = Dest[1]
			Dest[1] = {"X",CRet[8],0,"V"}
		end
		if type(Dest[2]) == "table" and Dest[2][4] == "A" then
			PDest2 = Dest[2]
			Dest[2] = {"X",NRet[8],0,"V"}
		end
		if type(Dest[1]) == "table" and Dest[1][4] == "VA" then
			PDest1 = Dest[1]
			Dest[1] = {"X",CRet[8],0,"V"}
		end
		if type(Dest[2]) == "table" and Dest[2][4] == "VA" then
			PDest2 = Dest[2]
			Dest[2] = {"X",NRet[8],0,"V"}
		end
	end
	if type(Dest) == "table" and Dest[4] == "WA" then
		PDest = Dest
		Dest = {"X",WRet[8],0,"W"}
	end
	if type(Dest) == "table" and Dest[4] == "LA_V" then
		PDest = Dest
		Dest = {"X",WRet[8],0,"W"}
	end
	if type(Dest) == "table" and Dest[4] == "LA_W" then
		PDest = Dest
		Dest = {"X",WRet[8],0,"W"}
	end
	



	--[[ Source All Cases
	"8" → {4,4}
	W → W
	{4,4} → {4,4}
	{4,V} → {4,V}
	{V,4} → {V,4}
	{V,V} → {V,V} 
	Ret = W, {4,4}, {4,V}, {V,V}, {V,4} ]]--
	local SourceArr = {}
	if type(Source) == "string" then -- Value "8"
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			for i = 1, 2 do
				if type(Source[i]) == "number" then -- {4, }
					table.insert(SourceArr,4)
				elseif Source[i][4] == "V" then -- {V, }
					table.insert(SourceArr,"V")
				else
					LMov_InputData_Error()
				end
			end
		else
			LMov_InputData_Error()
		end
	elseif type(Source) == "number" then
		Source = {Source,0}
		SourceArr = {4,4}
	else
		LMov_InputData_Error()
	end

	--[[ Dest All Cases
	"Cp" → {Cp,1}
	{"Cp",{4}} → {Cp,4}
	W → W
	4 → {4,4+0x4}
	{4,4} → {4,4}
	{4,{Size}} → {4,4+Size}
	{4,V} → {4,Mem}
	{4,Mem} → {4,Mem}
	{V,4} → {Mem,4}
	{V,V} → {Mem,Mem}
	{V,Mem} → {Mem,Mem}
	Mem → {Mem,Mem+0x4}
	{Mem,4} → {Mem,4}
	{Mem,{Size}} → {Mem,Mem+Size}
	{Mem,V} → {Mem,Mem}
	{Mem,Mem} → {Mem,Mem}
	Ret = {Cp,4}, W, {4,4}, {4,Mem}, {Mem,Mem}, {Mem,4} ]]--
	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						local Temp = {Dest[2][1],Dest[2][2],0x15C,Dest[2][3]}
						Dest = {Dest[1]}
						table.insert(Dest,Temp)
						DestArr = {4,"Mem"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						local Temp = {Dest[1][1],Dest[1][2],0x15C,Dest[1][3]}
						local Temp2 = Dest[2]
						Dest = {}
						table.insert(Dest,Temp)
						table.insert(Dest,Temp2)
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							local Temp = {Dest[1][1],Dest[1][2],0x15C,Dest[1][3]}
							local Temp2 = {Dest[2][1],Dest[2][2],0x15C,Dest[2][3]}
							Dest = {}
							table.insert(Dest,Temp)
							table.insert(Dest,Temp2)
							DestArr = {"Mem","Mem"}
						else -- {V,Mem}
							local Temp = {Dest[1][1],Dest[1][2],0x15C,Dest[1][3]}
							local Temp2 = Dest[2]
							Dest = {}
							table.insert(Dest,Temp)
							table.insert(Dest,Temp2)
							DestArr = {"Mem","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							local Temp = {Dest[2][1],Dest[2][2],0x15C,Dest[2][3]}
							local Temp2 = Dest[1]
							Dest = {}
							table.insert(Dest,Temp2)
							table.insert(Dest,Temp)
							DestArr = {"Mem","Mem"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LMov_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LMov_InputData_Error()
		end
	else
		LMov_InputData_Error()
	end

	--Source = W, {4,4}, {4,V}, {V,V}, {V,4} --
	--Dest = {Cp,4}, W, {4,4}, {4,Mem}, {Mem,Mem}, {Mem,4} --
	if SourceArr == "W" then -- 8bytes 
		if DestArr == "W" then -- 8 << 8
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation[1],Mask2[1]);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Deviation[2],Mask2[2]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
						SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
		elseif DestArr[1] == "Cp" then -- Cp << 8
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeathsX(CurrentPlayer,SetTo,Deviation[1],0,Mask[1]);
						SetMemory(0x6509B0,Add,Dest[2]);
						SetDeathsX(CurrentPlayer,SetTo,Deviation[2],0,Mask[2]);
						SetMemory(0x6509B0,Subtract,Dest[2]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
						SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,13);
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,13);
						SetCtrig1X(Source[1],Source[2],0x17C,Source[3],SetTo,Dest[2]); -- Cp Add Setting
						SetCtrig1X(Source[1],Source[2],0x184,Source[3],SetTo,0x0,0x2); -- Cp Add enable
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetMemory(0x6509B0,Subtract,Dest[2]);
						SetCtrig1X(Source[1],Source[2],0x17C,Source[3],SetTo,1); -- Cp Add Setting
						SetCtrig1X(Source[1],Source[2],0x184,Source[3],SetTo,0x2,0x2); -- Cp Add Disable
					},
					flag = {Preserved}
				}
		else -- {4/Mem,4/Mem} << 8
			local Box = {}
			for i = 1, 2 do
				if type(DestArr[i]) == "number" then
					table.insert(Box,SetMemoryX(Dest[i],SetTo,Deviation[i],Mask[i]))
					table.insert(Box,SetCtrig1X(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,EPD(Dest[i])))
				elseif DestArr[i] == "Mem" then
					table.insert(Box,SetCtrig1X(Dest[i][1],Dest[i][2],Dest[i][3],Dest[i][4],SetTo,Deviation[i],Mask[i]))
					table.insert(Box,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[i][1],Dest[i][2],Dest[i][3],1,Dest[i][4]))
				end
			end
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						Box,
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
						SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Add*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
		end
	else -- 4bytes x 2
		if type(SourceArr[1]) == "number" then -- 4/Mem << 4
			if type(SourceArr[2]) == "number" then -- 4/Mem << {4,4}
				local Box = {}
				if DestArr == "W" then
					table.insert(Box,SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Mask2[1]))
					table.insert(Box,SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[2],Mask2[2]))
				else
					for i = 1, 2 do
						if type(DestArr[i]) == "number" then
							table.insert(Box,SetMemoryX(Dest[i],SetTo,Source[i],Mask[i]))
						elseif DestArr[i] == "Mem" then
							table.insert(Box,SetCtrig1X(Dest[i][1],Dest[i][2],Dest[i][3],Dest[i][4],SetTo,Source[i],Mask[i]))
						end
					end
				end
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Box,
						},
						flag = {Preserved}
					}
			else -- 4/Mem << {4,V}
				local Box = {}
				if DestArr == "W" then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Mask2[1]);
							SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Deviation[2],Mask2[2]);
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,Mask[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways(Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
				else
					if type(DestArr[1]) == "number" then
						table.insert(Box,SetMemoryX(Dest[1],SetTo,Source[1],Mask[1]))
					elseif DestArr[1] == "Mem" then
						table.insert(Box,SetCtrig1X(Dest[1][1],Dest[1][2],Dest[1][3],Dest[1][4],SetTo,Source[1],Mask[1]))
					end
					if type(DestArr[2]) == "number" then
						table.insert(Box,SetMemoryX(Dest[2],SetTo,Deviation[2],Mask[2]))
						table.insert(Box,SetCtrig1X(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,EPD(Dest[2])))
					elseif DestArr[2] == "Mem" then
						table.insert(Box,SetCtrig1X(Dest[2][1],Dest[2][2],Dest[2][3],Dest[2][4],SetTo,Deviation[2],Mask[2]))
						table.insert(Box,SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,Dest[2][1],Dest[2][2],Dest[2][3],1,Dest[2][4]))
					end
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Box,
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,Mask[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways(Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
				end
			end
		else -- 4/Mem << V
			if type(SourceArr[2]) == "number" then -- 4/Mem << {V,4}
				local Box = {}
				if DestArr == "W" then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation[1],Mask2[1]);
							SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Source[2],Mask2[2]);
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,Mask[2]);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways(Source[1][1],Source[1][2],Source[1][3]);
						},
						flag = {Preserved}
					}
				else
					if type(DestArr[1]) == "number" then
						table.insert(Box,SetMemoryX(Dest[1],SetTo,Deviation[1],Mask[1]))
						table.insert(Box,SetCtrig1X(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,EPD(Dest[1])))
					elseif DestArr[1] == "Mem" then
						table.insert(Box,SetCtrig1X(Dest[1][1],Dest[1][2],Dest[1][3],Dest[1][4],SetTo,Deviation[1],Mask[1]))
						table.insert(Box,SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,Dest[1][1],Dest[1][2],Dest[1][3],1,Dest[1][4]))
					end
					if type(DestArr[2]) == "number" then
						table.insert(Box,SetMemoryX(Dest[2],SetTo,Source[2],Mask[2]))
					elseif DestArr[2] == "Mem" then
						table.insert(Box,SetCtrig1X(Dest[2][1],Dest[2][2],Dest[2][3],Dest[2][4],SetTo,Source[2],Mask[2]))
					end
					
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Box,
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,Mask[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways(Source[1][1],Source[1][2],Source[1][3]);
						},
						flag = {Preserved}
					}
				end
			else -- 4/Mem << {v,V}
				local Box = {}
				if DestArr == "W" then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation[1],Mask2[1]);
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,Mask[2]);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Deviation[2],Mask2[2]);
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,Mask[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways2(Source[1][1],Source[1][2],Source[1][3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
				else
					if type(DestArr[1]) == "number" then
						table.insert(Box,SetMemoryX(Dest[1],SetTo,Deviation[1],Mask[1]))
						table.insert(Box,SetCtrig1X(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,EPD(Dest[1])))
					elseif DestArr[1] == "Mem" then
						table.insert(Box,SetCtrig1X(Dest[1][1],Dest[1][2],Dest[1][3],Dest[1][4],SetTo,Deviation[1],Mask[1]))
						table.insert(Box,SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,Dest[1][1],Dest[1][2],Dest[1][3],1,Dest[1][4]))
					end
					if type(DestArr[2]) == "number" then
						table.insert(Box,SetMemoryX(Dest[2],SetTo,Deviation[2],Mask[2]))
						table.insert(Box,SetCtrig1X(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,EPD(Dest[2])))
					elseif DestArr[2] == "Mem" then
						table.insert(Box,SetCtrig1X(Dest[2][1],Dest[2][2],Dest[2][3],Dest[2][4],SetTo,Deviation[2],Mask2[2]))
						table.insert(Box,SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,Dest[2][1],Dest[2][2],Dest[2][3],1,Dest[2][4]))
					end
					
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Box,
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,Mask[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,Mask[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways2(Source[1][1],Source[1][2],Source[1][3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
				end
			end
		end
	end

	if PDest ~= nil then
		MovW(PlayerID,PDest,{"X",WRet[8],0,"W"})
	end
	if PDest1 ~= nil then
		MovX(PlayerID,PDest1,{"X",CRet[8],0,"V"})
	end
	if PDest2 ~= nil then
		MovX(PlayerID,PDest2,{"X",NRet[8],0,"V"})
	end
end

function MovW(PlayerID,Dest,Source,Mode,Mask,Clear) -- W << WA / WA,LA << W (Value) / 내부함수 (사용 권장X)
	--STPopTrigArr(PlayerID)
	if Mode == "X" or Mode == nil then
		Mode = SetTo
	end
	if Mask == "X" or Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	end

	local Mask2 = Mask
	if Clear == 1 then
		Mask2 = {0xFFFFFFFF,0xFFFFFFFF}
	end

	local Box0 = {}
	if Dest[4] == "W" and Source[4] == "WA" then -- Mov W, WA / {Index[1],Index[2],Index[3],"WA",WArray(WAPlayer,WAIndex,0),Index[5]}
		if Clear == 1 then
			table.insert(Box0,SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0,Mask2))
			table.insert(Box0,SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,0,Mask2))
		end
		Trigger {--(CPRead)로 값 출력
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					Box0,
					SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

					SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
					SetMemory(0x6509B0,Add,Source[6]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
					SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 

					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
					SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 
					CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x40/4));
					SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,Mask[1],0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x40/4));
					SetDeaths(CurrentPlayer,SetTo,Mask[2],0); -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
					SetMemory(0x6509B0,Add,(0x40/4));
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
				},
				flag = {Preserved}
			}

		RecoverCp(PlayerID)
	elseif #Dest == 2 and Dest[1][4] == "V" and Dest[2][4] == "V" and Source[4] == "WA" then -- Mov Vx2, WA / {Index[1],Index[2],Index[3],"WA",WArray(WAPlayer,WAIndex,0),Index[5]}
		Trigger {--(CPRead)로 값 출력
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

					SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
					SetMemory(0x6509B0,Add,Source[6]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
					SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 

					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
					SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 
					CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetCtrig2X("Cp",SetTo,Dest[1][1],Dest[1][2],0x15C,1,Dest[1][3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x40/4));
					SetCtrig2X("Cp",SetTo,Dest[2][1],Dest[2][2],0x15C,1,Dest[2][3]);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,Mask[1],0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x40/4));
					SetDeaths(CurrentPlayer,SetTo,Mask[2],0); -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
					SetMemory(0x6509B0,Add,(0x40/4));
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
				},
				flag = {Preserved}
			}

		RecoverCp(PlayerID)
	elseif #Dest == 2 and Source[4] == "WA" then -- Mov Memx2, WA / {Index[1],Index[2],Index[3],"WA",WArray(WAPlayer,WAIndex,0),Index[5]}
		Trigger {--(CPRead)로 값 출력
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

					SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
					SetMemory(0x6509B0,Add,Source[6]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
					SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 

					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
					SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 
					CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetCtrig2X("Cp",SetTo,Dest[1][1],Dest[1][2],Dest[1][3],1,Dest[1][4]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x40/4));
					SetCtrig2X("Cp",SetTo,Dest[2][1],Dest[2][2],Dest[2][3],1,Dest[2][4]);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
					SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,Mask[1],0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x40/4));
					SetDeaths(CurrentPlayer,SetTo,Mask[2],0); -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
					SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
					SetMemory(0x6509B0,Add,(0x40/4));
					SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
				},
				flag = {Preserved}
			}

		RecoverCp(PlayerID)
	elseif Dest[4] == "WA" and Source[4] == "W" then -- Mov WA, W 
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
					SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[5][1],Dest[5][2],0x19C,1,Dest[5][3]); 
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],Add,Dest[6]);
					SetCtrig1X(Source[1],Source[2],0x198,Source[3],Add,Dest[6]);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
					SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Source[1],Source[2],0x198,1,Source[3]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Mode*16777216,0xFF000000);
					CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	elseif Dest[4] == "LA_V" and Source[4] == "W" then -- Mov LA_V, W 
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
					CallLabelAlways(Dest[1],Dest[2],Dest[3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x198,1,Source[3]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Mode*16777216,0xFF000000);
					CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}

	elseif Dest[4] == "LA_W" and Source[4] == "W" then -- Mov LA_W, W 
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
					SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
					SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Source[1],Source[2],0x198,1,Source[3]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Mode*16777216,0xFF000000);
					CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	else
		MovW_InputData_Error()
	end
end

function f_LMovX(PlayerID,Dest,Source,Mode,Mask,Deviation,Clear) -- W,Cp,{4/Mem,4/Mem} << WA / WA,LA << W/{4/V,4/V} (Value)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end
	if Deviation == "X" then
		Deviation = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LMovX_InputData_Error()
	end
	if Deviation == nil then
		Deviation = {0,0}
	elseif type(Deviation) == "string" then -- Value "8"
		Deviation = I64(Deviation)
	elseif type(Deviation) == "number" then -- Value {4,4}만 허용
		LMovX_InputData_Error()
	end

	local Mask2 = Mask
	if Clear == 1 then
		Mask2 = {0xFFFFFFFF,0xFFFFFFFF}
	end
	if Mode == nil then
		Mode = SetTo
	end
	--[[ Source All Cases
	"8" → {4,4}
	W → W
	{4,4} → {4,4}
	{4,V} → {4,V}
	{V,4} → {V,4}
	{V,V} → {V,V} 
	Ret = W, {4,4}, {4,V}, {V,V}, {V,4} ]]--


	local SourceArr = {}
	local DestArr = {}

	if type(Dest) == "table" and type(Source) == "table" then
		if Source[4] == "WA" then
			if Dest[4] == "WA" or Dest[4] == "LA_V" or Dest[4] == "LA_W" then
				SourceArr = "WA"
				DestArr = Dest[4]
				goto LMovXTypeCheckEnd
			end
		end
	end

	if type(Dest) == "table" and (Dest[4] == "WA" or Dest[4] == "LA_V" or Dest[4] == "LA_W") then
		DestArr = Dest[4]
		if type(Source) == "string" then -- Value "8"
			Source = I64(Source)
			SourceArr = {4,4}
		elseif type(Source) == "table" then
			if Source[4] == "W" then -- W
				SourceArr = "W"
			elseif #Source == 2 then
				for i = 1, 2 do
					if type(Source[i]) == "number" then -- {4, }
						table.insert(SourceArr,4)
					elseif Source[i][4] == "V" then -- {V, }
						table.insert(SourceArr,"V")
					else
						LMovX_InputData_Error()
					end
				end
			else
				LMovX_InputData_Error()
			end
		elseif type(Source) == "number" then
			Source = {Source,0}
			SourceArr = {4,4}
		else
			LMovX_InputData_Error()
		end
		goto LMovXTypeCheckEnd
	end

	--[[ Dest All Cases
	"Cp" → {Cp,1}
	{"Cp",{4}} → {Cp,4}
	W → W
	4 → {4,4+0x4}
	{4,4} → {4,4}
	{4,{Size}} → {4,4+Size}
	{4,V} → {4,Mem}
	{4,Mem} → {4,Mem}
	{V,4} → {Mem,4}
	{V,V} → {Mem,Mem}
	{V,Mem} → {Mem,Mem}
	Mem → {Mem,Mem+0x4}
	{Mem,4} → {Mem,4}
	{Mem,{Size}} → {Mem,Mem+Size}
	{Mem,V} → {Mem,Mem}
	{Mem,Mem} → {Mem,Mem}
	Ret = {Cp,4}, W, {4,4}, {4,Mem}, {Mem,Mem}, {Mem,4} ]]--
	
	if type(Source) == "table" and (Source[4] == "WA") then
		SourceArr = "WA"
		if Dest == "Cp" then -- Cp
			Dest = {"Cp",1}
			DestArr = "Cp"
		elseif type(Dest) == "number" then -- Offset 4
			Dest = {Dest,Dest+4}
			DestArr = {4,4}
		elseif type(Dest) == "table" then
			if Dest[4] == "W" then -- W
				DestArr = "W"
			elseif #Dest == 2 then
				if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
					Dest = {"Cp",Dest[2][1]}
					DestArr = "Cp"
				elseif type(Dest[1]) == "number" then -- Offset {4, } 
					if type(Dest[2]) == "number" then -- Offset {4,4}
						DestArr = {4,4}
					elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
						if #Dest[2] == 1 then -- Offset {4,{Size}}
							Dest = {Dest[1],Dest[1]+Dest[2][1]}
							DestArr = {4,4}
						elseif Dest[2][4] == "V" then -- Offset {4,V}
							local Temp = {Dest[2][1],Dest[2][2],0x15C,Dest[2][3]}
							Dest = {Dest[1]}
							table.insert(Dest,Temp)
							DestArr = {4,"Mem"}
						else -- Offset {4,Mem}
							DestArr = {4,"Mem"}
						end
					end
				elseif type(Dest[1]) == "table" then
					if Dest[1][4] == "V" then -- {V, } 
						if type(Dest[2]) == "number" then -- {V,4}
							local Temp = {Dest[1][1],Dest[1][2],0x15C,Dest[1][3]}
							local Temp2 = Dest[2]
							Dest = {}
							table.insert(Dest,Temp)
							table.insert(Dest,Temp2)
							DestArr = {"Mem",4}
						elseif type(Dest[2]) == "table" then
							if Dest[2][4] == "V" then -- {V,V}
								local Temp = {Dest[1][1],Dest[1][2],0x15C,Dest[1][3]}
								local Temp2 = {Dest[2][1],Dest[2][2],0x15C,Dest[2][3]}
								Dest = {}
								table.insert(Dest,Temp)
								table.insert(Dest,Temp2)
								DestArr = {"Mem","Mem"}
							else -- {V,Mem}
								local Temp = {Dest[1][1],Dest[1][2],0x15C,Dest[1][3]}
								local Temp2 = Dest[2]
								Dest = {}
								table.insert(Dest,Temp)
								table.insert(Dest,Temp2)
								DestArr = {"Mem","Mem"}
							end
						end
					elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
						if type(Dest[2]) == "number" then -- {Mem,4}
							DestArr = {"Mem",4}
						elseif type(Dest[2]) == "table" then -- {Mem,{}}
							if #Dest[2] == 1 then -- {Mem,{Size}}
								local Temp = Dest
								Dest = {}
								table.insert(Dest,Temp[1])
								Temp[1][3] = Temp[1][3] + Dest[2][1]
								table.insert(Dest,Temp[1])
								DestArr = {"Mem","Mem"}
							elseif Dest[2][4] == "V" then -- {Mem,V}
								local Temp = {Dest[2][1],Dest[2][2],0x15C,Dest[2][3]}
								local Temp2 = Dest[1]
								Dest = {}
								table.insert(Dest,Temp2)
								table.insert(Dest,Temp)
								DestArr = {"Mem","Mem"}
							else -- {Mem,Mem}
								DestArr = {"Mem","Mem"}
							end	
						end
					end
				else
					LMovX_InputData_Error()
				end
			elseif type(Dest[4]) ~= "string" then -- Mem 4 
				local Temp = Dest
				Dest = {}
				table.insert(Dest,Temp)
				Temp[3] = Temp[3] + 4
				table.insert(Dest,Temp)
				DestArr = {"Mem","Mem"}
			else
				LMovX_InputData_Error()
			end
		else
			LMovX_InputData_Error()
		end
	end

	::LMovXTypeCheckEnd::

	if SourceArr == "WA" then -- 8bytes 
		if DestArr == "W" then -- 8 << 8
			Trigger {--(CPRead)로 값 출력
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation[1],Mask2[1]);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,Deviation[2],Mask2[2]);
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
						SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 
						CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
					},
					flag = {Preserved}
				}

			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,Mask[1],0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeaths(CurrentPlayer,SetTo,Mask[2],0); -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
					},
					flag = {Preserved}
				}
		elseif DestArr == "WA" then -- WA << WA
			Trigger {--(CPRead)로 값 출력
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
						SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 

						SetCtrigX("X","X",0x19C,1,SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
						SetCtrigX("X","X",0x1DC,1,SetTo,Dest[5][1],Dest[5][2],0x19C,1,Dest[5][3]); 
						SetCtrig1X("X","X",0x19C,1,Add,Dest[6]);
						SetCtrig1X("X","X",0x1DC,1,Add,Dest[6]);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x19C,1,1);
						SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x1DC,1,1);
						CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}

			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,Mask[1],0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeaths(CurrentPlayer,SetTo,Mask[2],0); -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x15C-0x160-0x40)/4);
						SetDeaths(CurrentPlayer,Add,Deviation[1],0);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeaths(CurrentPlayer,Add,Deviation[2],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeaths(CurrentPlayer,Add,-Deviation[2],0);
						SetMemory(0x6509B0,Add,(-0x40/4));
						SetDeaths(CurrentPlayer,Add,-Deviation[1],0);
					},
					flag = {Preserved}
				}
		elseif DestArr == "LA_V" then -- LA_V << WA
			Trigger {--(CPRead)로 값 출력
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x19C,2,SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x19C,1,2);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}

			Trigger {--(CPRead)로 값 출력
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
						SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 

						SetCtrigX("X","X",0x1DC,1,SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x1DC,1,1);
						CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}

			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,Mask[1],0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeaths(CurrentPlayer,SetTo,Mask[2],0); -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x15C-0x160-0x40)/4);
						SetDeaths(CurrentPlayer,Add,Deviation[1],0);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeaths(CurrentPlayer,Add,Deviation[2],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeaths(CurrentPlayer,Add,-Deviation[2],0);
						SetMemory(0x6509B0,Add,(-0x40/4));
						SetDeaths(CurrentPlayer,Add,-Deviation[1],0);
					},
					flag = {Preserved}
				}
		elseif DestArr == "LA_W" then -- LA_W << WA
			Trigger {--(CPRead)로 값 출력
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
						SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 

						SetCtrigX("X","X",0x19C,1,SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
						SetCtrigX("X","X",0x1DC,1,SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x19C,1,1);
						SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x1DC,1,1);
						CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}

			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,Mask[1],0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeaths(CurrentPlayer,SetTo,Mask[2],0); -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x15C-0x160-0x40)/4);
						SetDeaths(CurrentPlayer,Add,Deviation[1],0);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeaths(CurrentPlayer,Add,Deviation[2],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeaths(CurrentPlayer,Add,-Deviation[2],0);
						SetMemory(0x6509B0,Add,(-0x40/4));
						SetDeaths(CurrentPlayer,Add,-Deviation[1],0);
					},
					flag = {Preserved}
				}
		elseif DestArr[1] == "Cp" then -- Cp << 8
			LMovX_InputData_Error()
		else -- {4/Mem,4/Mem} << 8
			local Box0 = {}
			local Box1 = {}
			if type(DestArr[1]) == "number" then
				table.insert(Box0,SetMemoryX(Dest[1],SetTo,Deviation[1],Mask[1]))
				table.insert(Box1,SetDeaths(CurrentPlayer,SetTo,EPD(Dest[1]),0))
			elseif DestArr[1] == "Mem" then
				table.insert(Box0,SetCtrig1X(Dest[1][1],Dest[1][2],Dest[1][3],Dest[1][4],SetTo,Deviation[1],Mask[1]))
				table.insert(Box1,SetCtrig2X("Cp",SetTo,Dest[1][1],Dest[1][2],Dest[1][3],1,Dest[1][4]))
			end
			local Box2 = {}
			if type(DestArr[2]) == "number" then
				table.insert(Box0,SetMemoryX(Dest[2],SetTo,Deviation[2],Mask[2]))
				table.insert(Box2,SetDeaths(CurrentPlayer,SetTo,EPD(Dest[2]),0))
			elseif DestArr[2] == "Mem" then
				table.insert(Box0,SetCtrig1X(Dest[2][1],Dest[2][2],Dest[2][3],Dest[2][4],SetTo,Deviation[2],Mask[2]))
				table.insert(Box2,SetCtrig2X("Cp",SetTo,Dest[2][1],Dest[2][2],Dest[2][3],1,Dest[2][4]))
			end

			Trigger {--(CPRead)로 값 출력
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						Box0,
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
						SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 
						CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						Box1,	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x40/4));
						Box2,	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,Mask[1],0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeaths(CurrentPlayer,SetTo,Mask[2],0); -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x40/4));
						SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
					},
					flag = {Preserved}
				}
		end
		RecoverCp(PlayerID)
	elseif SourceArr == "W" then
		if DestArr == "WA" then -- Mov WA, W 
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
					SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[5][1],Dest[5][2],0x19C,1,Dest[5][3]); 
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],Add,Dest[6]);
					SetCtrig1X(Source[1],Source[2],0x198,Source[3],Add,Dest[6]);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
					SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Source[1],Source[2],0x198,1,Source[3]);

					SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,Deviation[1]);
					SetCtrig1X(Source[1],Source[2],0x19C,Source[3],Add,Deviation[2]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Mode*16777216,0xFF000000);
					CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,-Deviation[1]);
							SetCtrig1X(Source[1],Source[2],0x19C,Source[3],Add,-Deviation[2]);
						},
						flag = {Preserved}
				}
		elseif DestArr == "LA_V" then-- Mov LA_V, W 
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
					CallLabelAlways(Dest[1],Dest[2],Dest[3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x198,1,Source[3]);
					SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,Deviation[1]);
					SetCtrig1X(Source[1],Source[2],0x19C,Source[3],Add,Deviation[2]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Mode*16777216,0xFF000000);
					CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,-Deviation[1]);
							SetCtrig1X(Source[1],Source[2],0x19C,Source[3],Add,-Deviation[2]);
						},
						flag = {Preserved}
				}
		elseif DestArr == "LA_W" then -- Mov LA_W, W 
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
					SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
					SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Source[1],Source[2],0x198,1,Source[3]);

					SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,Deviation[1]);
					SetCtrig1X(Source[1],Source[2],0x19C,Source[3],Add,Deviation[2]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Mode*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Mode*16777216,0xFF000000);
					CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,-Deviation[1]);
							SetCtrig1X(Source[1],Source[2],0x19C,Source[3],Add,-Deviation[2]);
						},
						flag = {Preserved}
				}
		end
	else -- 4bytes x 2
		if type(SourceArr[1]) == "number" then -- 4/Mem << 4
			if type(SourceArr[2]) == "number" then -- 4/Mem << {4,4}
				if DestArr == "WA" then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x158,1,SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
							SetCtrigX("X","X",0x178,1,SetTo,Dest[5][1],Dest[5][2],0x19C,1,Dest[5][3]); 
							SetCtrig1X("X","X",0x158,1,Add,Dest[6]);
							SetCtrig1X("X","X",0x178,1,Add,Dest[6]);
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x178,1,1);
							CallLabelAlways(Dest[1],Dest[2],Dest[3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemoryX(0,Mode,Source[1],Mask[1]);
							SetMemoryX(0,Mode,Source[2],Mask[2]);
						},
						flag = {Preserved}
					}
				elseif DestArr == "LA_V" then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x158,2,SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,2);
							CallLabelAlways(Dest[1],Dest[2],Dest[3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x178,1,SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x178,1,1);
							CallLabelAlways(Dest[1],Dest[2],Dest[3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemoryX(0,Mode,Source[1],Mask[1]);
							SetMemoryX(0,Mode,Source[2],Mask[2]);
						},
						flag = {Preserved}
					}
				elseif DestArr == "LA_W" then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x158,1,SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
							SetCtrigX("X","X",0x178,1,SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x178,1,1);
							CallLabelAlways(Dest[1],Dest[2],Dest[3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemoryX(0,Mode,Source[1],Mask[1]);
							SetMemoryX(0,Mode,Source[2],Mask[2]);
						},
						flag = {Preserved}
					}
				end
			else -- 4/Mem << {4,V}
				if DestArr == "WA" then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x158,1,SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,Dest[5][1],Dest[5][2],0x19C,1,Dest[5][3]); 
							SetCtrig1X("X","X",0x158,1,Add,Dest[6]);
							SetCtrig1X(Source[2][1],Source[2][2],0x158,Source[2][3],Add,Dest[6]);
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Source[2][1],Source[2][2],0x158,1,Source[2][3]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,Deviation[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,Mask[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Mode*16777216,0xFF000000);
							CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemoryX(0,Mode,Source[1],Mask[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,-Deviation[2]);
						},
						flag = {Preserved}
					}
				elseif DestArr == "LA_V" then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x158,2,SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,2);
							CallLabelAlways(Dest[1],Dest[2],Dest[3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[2][1],Source[2][2],0x158,1,Source[2][3]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,Deviation[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,Mask[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Mode*16777216,0xFF000000);
							CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemoryX(0,Mode,Source[1],Mask[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,-Deviation[2]);
						},
						flag = {Preserved}
					}
				elseif DestArr == "LA_W" then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x158,1,SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Source[2][1],Source[2][2],0x158,1,Source[2][3]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,Deviation[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,Mask[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Mode*16777216,0xFF000000);
							CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemoryX(0,Mode,Source[1],Mask[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,-Deviation[2]);
						},
						flag = {Preserved}
					}
				end
			end
		else -- 4/Mem << V
			if type(SourceArr[2]) == "number" then -- 4/Mem << {V,4}
				if DestArr == "WA" then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
							SetCtrigX("X","X",0x178,1,SetTo,Dest[5][1],Dest[5][2],0x19C,1,Dest[5][3]); 
							SetCtrig1X(Source[1][1],Source[1][2],0x158,Source[1][3],Add,Dest[6]);
							SetCtrig1X("X","X",0x178,1,Add,Dest[6]);
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1][1],Source[1][2],0x158,1,Source[1][3]);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x178,1,1);
							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,Deviation[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,Mask[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Mode*16777216,0xFF000000);
							CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1][1],Source[1][2],Source[1][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,-Deviation[1]);
							SetMemoryX(0,Mode,Source[2],Mask[2]);
						},
						flag = {Preserved}
					}
				elseif DestArr == "LA_V" then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1][1],Source[1][2],0x158,1,Source[1][3]);
							CallLabelAlways(Dest[1],Dest[2],Dest[3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x178,1,SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x178,1,1);
							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,Deviation[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,Mask[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Mode*16777216,0xFF000000);
							CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1][1],Source[1][2],Source[1][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,-Deviation[1]);
							SetMemoryX(0,Mode,Source[2],Mask[2]); 
						},
						flag = {Preserved}
					}
				elseif DestArr == "LA_W" then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
							SetCtrigX("X","X",0x178,1,SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1][1],Source[1][2],0x158,1,Source[1][3]);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x178,1,1);
							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,Deviation[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,Mask[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Mode*16777216,0xFF000000);
							CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1][1],Source[1][2],Source[1][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,-Deviation[1]);
							SetMemoryX(0,Mode,Source[2],Mask[2]); 
						},
						flag = {Preserved}
					}
				end
			else -- 4/Mem << {v,V}
				if DestArr == "WA" then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,Dest[5][1],Dest[5][2],0x19C,1,Dest[5][3]); 
							SetCtrig1X(Source[1][1],Source[1][2],0x158,Source[1][3],Add,Dest[6]);
							SetCtrig1X(Source[2][1],Source[2][2],0x158,Source[2][3],Add,Dest[6]);
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1][1],Source[1][2],0x158,1,Source[1][3]);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Source[2][1],Source[2][2],0x158,1,Source[2][3]);

							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,Deviation[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,Deviation[2]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,Mask[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,Mask[2]);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Mode*16777216,0xFF000000);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Mode*16777216,0xFF000000);
							CallLabelAlways3(Dest[1],Dest[2],Dest[3],Source[1][1],Source[1][2],Source[1][3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,-Deviation[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,-Deviation[2]);
						},
						flag = {Preserved}
					}
				elseif DestArr == "LA_V" then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1][1],Source[1][2],0x158,1,Source[1][3]);
							CallLabelAlways(Dest[1],Dest[2],Dest[3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[2][1],Source[2][2],0x158,1,Source[2][3]);

							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,Deviation[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,Deviation[2]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,Mask[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,Mask[2]);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Mode*16777216,0xFF000000);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Mode*16777216,0xFF000000);
							CallLabelAlways3(Dest[1],Dest[2],Dest[3],Source[1][1],Source[1][2],Source[1][3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,-Deviation[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,-Deviation[2]);
						},
						flag = {Preserved}
					}
				elseif DestArr == "LA_W" then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3],1,0); 
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,Dest[5][1],Dest[5][2],Dest[5][3]+0x4,1,0); 
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1][1],Source[1][2],0x158,1,Source[1][3]);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,Source[2][1],Source[2][2],0x158,1,Source[2][3]);

							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,Deviation[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,Deviation[2]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,Mask[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,Mask[2]);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Mode*16777216,0xFF000000);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Mode*16777216,0xFF000000);
							CallLabelAlways3(Dest[1],Dest[2],Dest[3],Source[1][1],Source[1][2],Source[1][3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1][1],Source[1][2],0x15C,Source[1][3],Add,-Deviation[1]);
							SetCtrig1X(Source[2][1],Source[2][2],0x15C,Source[2][3],Add,-Deviation[2]);
						},
						flag = {Preserved}
					}
				end
			end
		end
	end
end

function f_Cast(PlayerID,Dest,Source,Deviation,Mask,Clear) -- V ↔ W Type Casting
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end
	if Deviation == "X" or Deviation == nil then
		Deviation = 0
	end

	local Mask2
	if Source[4] == "V" or Source[4] == "VA" then
		if Mask == nil then
			Mask = 0xFFFFFFFF
		elseif type(Mask) == "string" then -- Value "8"
			LMov_InputData_Error()
		end
		
		if Clear == 1 then
			Mask2 = 0xFFFFFFFF
		else
			Mask2 = Mask
		end
	else
		if Mask == nil then
			Mask = {0xFFFFFFFF,0xFFFFFFFF}
		elseif type(Mask) == "string" then -- Value "8"
			Mask = I64(Mask)
		elseif type(Mask) == "number" then -- Value {4,4}만 허용
			LMov_InputData_Error()
		end
		
		if Clear == 1 then
			Mask2 = {0xFFFFFFFF,0xFFFFFFFF}
		else 
			Mask2 = Mask
		end
	end

	

 	--[[
 	W → V
 	W → VA
 	WA → V
 	WA → VA
 	V → W
 	VA → W
 	V → WA
 	VA → WA
 	]]--
	if Source[4] == "W" then -- W -> V 
		if Dest[1][4] == "V" then 
			if Dest[2] == 0 then -- lower 32bit
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1][1],Dest[1][2],0x15C,Dest[1][3],SetTo,Deviation,Mask2[1]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1][1],Dest[1][2],0x15C,1,Dest[1][3]);
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			elseif Dest[2] == 1 then -- upper 32bit
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1][1],Dest[1][2],0x15C,Dest[1][3],SetTo,Deviation,Mask2[2]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[2]);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[1][1],Dest[1][2],0x15C,1,Dest[1][3]);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,0);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				Cast_InputData_Error()
			end
		elseif Dest[1][4] == "VA" then -- W -> VA
			if Dest[2] == 0 then -- lower 32bit
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1][5][1],Dest[1][5][2],0x15C,1,Dest[1][5][3]); 
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],Add,Dest[1][6]);
						SetCtrig1X(Dest[1][1],Dest[1][2],0x148,Dest[1][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1][1],Dest[1][2],0x160,Dest[1][3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1][1],Dest[1][2],0x158,Dest[1][3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,Deviation);
						CallLabelAlways2(Dest[1][1],Dest[1][2],Dest[1][3],Source[1],Source[2],Source[3]);
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,-Deviation); 
					},
					flag = {Preserved}
				}
			elseif Dest[2] == 1 then -- upper 32bit
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[1][5][1],Dest[1][5][2],0x15C,1,Dest[1][5][3]); 
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],Add,Dest[1][6]);
						SetCtrig1X(Dest[1][1],Dest[1][2],0x148,Dest[1][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1][1],Dest[1][2],0x160,Dest[1][3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1][1],Dest[1][2],0x158,Dest[1][3],SetTo,Source[1],Source[2],0x198,1,Source[3]);
						SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
						SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x19C,Source[3],Add,Deviation);
						CallLabelAlways2(Dest[1][1],Dest[1][2],Dest[1][3],Source[1],Source[2],Source[3]);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,0);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Source[1],Source[2],0x19C,Source[3],Add,-Deviation); 
					},
					flag = {Preserved}
				}
			else
				Cast_InputData_Error()
			end
		else
			Cast_InputData_Error()
		end
	elseif Source[4] == "WA" then -- WA -> V
		if Dest[1][4] == "V" then 
			if Dest[2] == 0 then -- lower 32bit
				Trigger {--(CPRead)로 값 출력
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1][1],Dest[1][2],0x15C,Dest[1][3],SetTo,Deviation,Mask2[1]);
							SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
							SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
							SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
							SetMemory(0x6509B0,Add,Source[6]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
							SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 
							SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
							SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 
							CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
						},
						flag = {Preserved}
					}

				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
							SetMemory(0x6509B0,Add,(0x158-0x0)/4);
							SetCtrig2X("Cp",SetTo,Dest[1][1],Dest[1][2],0x15C,1,Dest[1][3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x40/4));
							SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
							SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
							SetMemory(0x6509B0,Add,(0x148-0x4)/4);
							SetDeaths(CurrentPlayer,SetTo,Mask[1],0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x40/4));
							 -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
							SetDeathsX(CurrentPlayer,SetTo,Add*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
							SetMemory(0x6509B0,Add,(0x40/4));
							 -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
						},
						flag = {Preserved}
					}
				RecoverCp(PlayerID)
			elseif Dest[2] == 1 then -- upper 32bit
				Trigger {--(CPRead)로 값 출력
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1][1],Dest[1][2],0x15C,Dest[1][3],SetTo,Deviation,Mask2[2]);
							SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
							SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
							SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
							SetMemory(0x6509B0,Add,Source[6]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
							SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 
							SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
							SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 
							CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
						},
						flag = {Preserved}
					}

				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
							SetMemory(0x6509B0,Add,(0x158-0x0)/4);
							SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x40/4));
							SetCtrig2X("Cp",SetTo,Dest[1][1],Dest[1][2],0x15C,1,Dest[1][3]);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
							SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
							SetMemory(0x6509B0,Add,(0x148-0x4)/4);
							 -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x40/4));
							SetDeaths(CurrentPlayer,SetTo,Mask[2],0); -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
							 -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
							SetMemory(0x6509B0,Add,(0x40/4));
							SetDeathsX(CurrentPlayer,SetTo,Add*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
						},
						flag = {Preserved}
					}
				RecoverCp(PlayerID)
			else
				Cast_InputData_Error()
			end
		elseif Dest[1][4] == "VA" then -- WA -> VA
			if Dest[2] == 0 then -- lower 32bit
				Trigger {--(CPRead)로 값 출력
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
							SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
							SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
							SetMemory(0x6509B0,Add,Source[6]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
							SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 
							SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
							SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 
							
							SetCtrigX("X","X",0x19C,1,SetTo,Dest[1][5][1],Dest[1][5][2],0x15C,1,Dest[1][5][3]); 
							SetCtrig1X("X","X",0x19C,1,Add,Dest[1][6]);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x148,Dest[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x160,Dest[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1][1],Dest[1][2],0x158,Dest[1][3],SetTo,"X","X",0x19C,1,1);
							CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1][1],Dest[1][2],Dest[1][3]);
						},
						flag = {Preserved}
					}

				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
							SetMemory(0x6509B0,Add,(0x158-0x0)/4);
							SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x40/4));
							SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
							SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
							SetMemory(0x6509B0,Add,(0x148-0x4)/4);
							SetDeaths(CurrentPlayer,SetTo,Mask[1],0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x40/4));
							 -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
							SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
							SetMemory(0x6509B0,Add,(0x40/4));
							 -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
							SetMemory(0x6509B0,Add,(0x15C-0x160-0x40/4));
							SetDeaths(CurrentPlayer,Add,Deviation,0); 
							SetMemory(0x6509B0,Add,(0x40/4));

						},
						flag = {Preserved}
					}

				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							
							SetMemory(0x6509B0,Add,(-0x40/4));
							SetDeaths(CurrentPlayer,Add,-Deviation,0);
						},
						flag = {Preserved}
					}
				RecoverCp(PlayerID)
			elseif Dest[2] == 1 then -- upper 32bit
				Trigger {--(CPRead)로 값 출력
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
							SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
							SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
							SetMemory(0x6509B0,Add,Source[6]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
							SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 
							SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
							SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 
							
							SetCtrigX("X","X",0x1DC,1,SetTo,Dest[1][5][1],Dest[1][5][2],0x15C,1,Dest[1][5][3]); 
							SetCtrig1X("X","X",0x1DC,1,Add,Dest[1][6]);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x148,Dest[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x160,Dest[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1][1],Dest[1][2],0x158,Dest[1][3],SetTo,"X","X",0x1DC,1,1);
							CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1][1],Dest[1][2],Dest[1][3]);
						},
						flag = {Preserved}
					}

				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
							SetMemory(0x6509B0,Add,(0x158-0x0)/4);
							SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x40/4));
							SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
							SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
							SetMemory(0x6509B0,Add,(0x148-0x4)/4);
							--SetDeaths(CurrentPlayer,SetTo,Mask[2],0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x40/4));
							SetDeaths(CurrentPlayer,SetTo,Mask[2],0); -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
							-- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
							SetMemory(0x6509B0,Add,(0x40/4));
							SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
							SetMemory(0x6509B0,Add,(0x15C-0x160-0x40/4));
							
							SetMemory(0x6509B0,Add,(0x40/4));
							SetDeaths(CurrentPlayer,Add,Deviation,0); 
						},
						flag = {Preserved}
					}

				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetDeaths(CurrentPlayer,Add,-Deviation,0);
							SetMemory(0x6509B0,Add,(-0x40/4));
							
						},
						flag = {Preserved}
					}
			else
				Cast_InputData_Error()
			end
		else
			Cast_InputData_Error()
		end
	elseif Source[4] == "V" then -- V -> W  
		if Dest[4] == "W" then 
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);

						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x198,Dest[3],SetTo,0);
						CallLabelAlways2(Source[1],Source[2],Source[3],Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
		elseif Dest[4] == "WA" then -- V -> WA 
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],Add,Dest[6]);
						SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,Deviation);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x198,Dest[3],SetTo,0);
						CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],Add,0x40/4); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,-Deviation);
					},
					flag = {Preserved}
				}
		else
			Cast_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if Dest[4] == "W" then -- VA -> W
			Trigger {--(CPRead)로 값 출력
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
						CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
					},
					flag = {Preserved}
				}

			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158)/4);
						SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x0,0,Dest[3]); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148)/4);
						SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]); 
						SetCtrig1X(Dest[1],Dest[2],0x198,Dest[3],SetTo,0); 
						SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X","X",0,0,1);
					},
					flag = {Preserved}
				}

			RecoverCp(PlayerID)
		elseif Dest[4] == "WA" then -- VA -> WA 
			Trigger {--(CPRead)로 값 출력
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 						

						SetCtrigX("X","X",0x19C,1,SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
						SetCtrig1X("X","X",0x19C,1,Add,Dest[6]);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x19C,1,1);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x198,Dest[3],SetTo,0);

						CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158)/4);
						SetCtrig2X("Cp",SetTo,Source[7],Source[8],0x0,0,Source[9]); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148)/4);
						SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x15C-0x160)/4);
						SetDeaths(CurrentPlayer,Add,Deviation,0);

						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
						SetCtrigX(Source[7],Source[8],0x4,Source[9],SetTo,"X","X",0,0,1);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x15C)/4);
						SetDeaths(CurrentPlayer,Add,0x40/4,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetMemory(0x6509B0,Add,(0x15C-0x4)/4);
						SetDeaths(CurrentPlayer,Add,-Deviation,0);
					},
					flag = {Preserved}
				}

			RecoverCp(PlayerID)
		else
			Cast_InputData_Error()
		end
	else
		Cast_InputData_Error()
	end
end

function f_iCast(PlayerID,Dest,Source) -- V ↔ W Type iCasting (Signed Number)
	STPopTrigArr(PlayerID)
	
 	--[[
 	W → V
 	W → VA
 	WA → V
 	WA → VA
 	V → W
 	VA → W
 	V → WA
 	VA → WA
 	]]--
	if Source[4] == "W" then -- W -> V 
		if Dest[4] == "V" then 
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
		elseif Dest[4] == "VA" then -- W -> VA
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],Add,Dest[6]);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
		else
			iCast_InputData_Error()
		end
	elseif Source[4] == "WA" then -- WA -> V
		if Dest[4] == "V" then 
				Trigger {--(CPRead)로 값 출력
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
							SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
							SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
							SetMemory(0x6509B0,Add,Source[6]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
							SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 
							SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
							SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 
							CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
						},
						flag = {Preserved}
					}

				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
							SetMemory(0x6509B0,Add,(0x158-0x0)/4);
							SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x40/4));
							SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
							SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
							SetMemory(0x6509B0,Add,(0x148-0x4)/4);
							SetDeaths(CurrentPlayer,SetTo,0xFFFFFFFF,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x40/4));
							 -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
							SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
							SetMemory(0x6509B0,Add,(0x40/4));
							 -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
						},
						flag = {Preserved}
					}
				RecoverCp(PlayerID)
		elseif Dest[4] == "VA" then -- WA -> VA
				Trigger {--(CPRead)로 값 출력
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
							SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
							SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
							SetMemory(0x6509B0,Add,Source[6]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
							SetCtrig1X(Source[1],Source[2],0x198,Source[3],SetTo,0); 
							SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
							SetCtrig1X(Source[7],Source[8],0x198,Source[9],SetTo,0); 
							
							SetCtrigX("X","X",0x19C,1,SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
							SetCtrig1X("X","X",0x19C,1,Add,Dest[6]);
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x19C,1,1);
							CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1],Dest[2],Dest[3]);
						},
						flag = {Preserved}
					}

				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
							SetMemory(0x6509B0,Add,(0x158-0x0)/4);
							SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x40/4));
							SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x198,VA[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
							SetMemory(0x6509B0,Add,(0x4-0x158-0x40)/4);
							SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
							SetMemory(0x6509B0,Add,(0x148-0x4)/4);
							SetDeaths(CurrentPlayer,SetTo,0xFFFFFFFF,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x40/4));
							 -- SetCtrig1X(VA[1],VA[2],0x188,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x160-0x148-0x40)/4);
							SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
							SetMemory(0x6509B0,Add,(0x40/4));
							 -- SetCtrig1X(VA[1],VA[2],0x1A0,VA[3],SetTo,SetTo*16777216,0xFF000000);
						},
						flag = {Preserved}
					}
				RecoverCp(PlayerID)
		else
			iCast_InputData_Error()
		end
	elseif Source[4] == "V" then -- V -> W  
		if Dest[4] == "W" then 
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,0);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,0xFFFFFFFF);
					},
					flag = {Preserved}
				}
		elseif Dest[4] == "WA" then -- V -> WA 
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],Add,Dest[6]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX("X","X",0x158,2,SetTo,Dest[5][1],Dest[5][2],0x19C,1,Dest[5][3]); 
						SetCtrig1X("X","X",0x158,2,Add,Dest[6]);
						SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x158,1,2);
						SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X("X","X",0x15C,2,SetTo,0);
						CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX(Source[1],Source[2],0x15C,Source[3],AtLeast,0x80000000);
					},
					actions = {
						SetCtrig1X("X","X",0x15C,1,SetTo,0xFFFFFFFF);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetMemory(0,SetTo,0);
					},
					flag = {Preserved}
				}
		else
			iCast_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if Dest[4] == "W" then -- VA -> W
			Trigger {--(CPRead)로 값 출력
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
						CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
					},
					flag = {Preserved}
				}

			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0x0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,0xFFFFFFFF,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148)/4);
						SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,0);
					},
					flag = {Preserved}
				}

			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX(Dest[1],Dest[2],0x15C,Dest[3],AtLeast,0x80000000);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,0xFFFFFFFF);
					},
					flag = {Preserved}
				}

			RecoverCp(PlayerID)
		elseif Dest[4] == "WA" then -- VA -> WA 
			Trigger {--(CPRead)로 값 출력
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 

						SetCtrigX("X","X",0x19C,1,SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
						SetCtrig1X("X","X",0x19C,1,Add,Dest[6]);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x19C,1,1);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x198,Dest[3],SetTo,0);
						CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,0xFFFFFFFF,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148)/4);
						SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x19C-0x160)/4);
						SetDeaths(CurrentPlayer,SetTo,0,0);
						SetMemory(0x6509B0,Add,(-0x40)/4);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						Deaths(CurrentPlayer,AtLeast,0x80000000,0);
					},
					actions = {
						SetMemory(0x6509B0,Add,(0x19C-0x15C)/4);
						SetDeaths(CurrentPlayer,SetTo,0xFFFFFFFF,0);
					},
					flag = {Preserved}
				}

			RecoverCp(PlayerID)
		else
			iCast_InputData_Error()
		end
	else
		iCast_InputData_Error()
	end
end

function f_LWrite(PlayerID,Dest,Source,Deviation,Mask) -- << (CRead 대응)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end
	if Deviation == "X" then
		Deviation = nil
	end
	if Dest[5] == "X" then
		Dest[5] = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LMovX_InputData_Error()
	end
	if Deviation == nil then
		Deviation = {0,0}
	elseif type(Deviation) == "string" then -- Value "8"
		Deviation = I64(Deviation)
	elseif type(Deviation) == "number" then -- Value {4,4}만 허용
		LMovX_InputData_Error()
	end
	local Deviation2
	if Dest[5] == nil or Dest[4] == "WA" then
		Deviation2 = {0,0}
	elseif type(Dest[5]) == "string" then -- Value "8"
		Deviation2 = I64(Dest[5])
	elseif type(Dest[5]) == "number" then -- Value {4,4}만 허용
		LMovX_InputData_Error()
	else
		Deviation2 = Dest[5]
	end

	if type(Dest) == "table" and #Dest == 2 then
		if type(Dest[1]) == "table" and Dest[1][4] == "VA" then
			local TempRet = {"X",CRet[6],0,"V"}
			MovX(PlayerID,TempRet,Dest[1])
			Dest[1] = TempRet
		end
		if type(Dest[2]) == "table" and Dest[2][4] == "VA" then
			local TempRet = {"X",NRet[6],0,"V"}
			MovX(PlayerID,TempRet,Dest[2])
			Dest[2] = TempRet
		end
	end

	if type(Dest) == "table" and Dest[4] == "WA" then
		local TempRet = {"X",WRet[6],0,"W"}
		MovW(PlayerID,TempRet,Dest)
		Dest = TempRet
	end

	if type(Source) == "table" and #Source == 2 then
		if type(Source[1]) == "table" and Source[1][4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source[1])
			Source[1] = TempRet
		end
		if type(Source[2]) == "table" and Source[2][4] == "VA" then
			local TempRet = {"X",NRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source[2])
			Source[2] = TempRet
		end
	end

	if type(Source) == "table" and Source[4] == "WA" then
		local TempRet = {"X",WRet[7],0,"W"}
		MovW(PlayerID,TempRet,Source)
		Source = TempRet
	end

	--[[ Source All Cases
	"8" → {4,4}
	W → W
	{4,4} → {4,4}
	{4,V} → {4,V}
	{V,4} → {V,4}
	{V,V} → {V,V} 
	Ret = W, {4,4}, {4,V}, {V,V}, {V,4} ]]--
	local SourceArr = {}
	if type(Source) == "string" then -- Value "8"
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			for i = 1, 2 do
				if type(Source[i]) == "number" then -- {4, }
					table.insert(SourceArr,4)
				elseif Source[i][4] == "V" then -- {V, }
					table.insert(SourceArr,"V")
				else
					LWrite_InputData_Error()
				end
			end
		else
			LWrite_InputData_Error()
		end
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	else
		LWrite_InputData_Error()
	end
	
	--[[ Dest All Cases
	"8" → {4,4}
	W → W
	{V,V} → {V,V} 
	Ret = W, {4,4}, {4,V}, {V,V}, {V,4} ]]--
	local DestArr = {}
	if type(Dest) == "string" then -- Value "8"
		LWrite_InputData_Error()
	elseif type(Dest) == "table" then
		if Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			for i = 1, 2 do
				if type(Dest[i]) == "number" then -- {4, }
					LWrite_InputData_Error()
				elseif Dest[i][4] == "V" then -- {V, }
					table.insert(DestArr,"V")
				else
					LWrite_InputData_Error()
				end
			end
			if Dest[1][5] == "X" or Dest[1][5] == nil then
				Dest[1][5] = 0
			end
			if Dest[2][5] == "X" or Dest[2][5] == nil then
				Dest[2][5] = 0
			end
		else
			LWrite_InputData_Error()
		end
	else
		LWrite_InputData_Error()
	end

	if DestArr == "W" then
		if SourceArr == "W" then -- Write  W, W : EPD(W) << W

			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x15C,1,SetTo,Deviation[1]);
						SetCtrig1X("X","X",0x17C,1,SetTo,Deviation[2]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x15C,1,1);
						SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X","X",0x17C,1,1);

						SetCtrig1X("X","X",0x158,1,SetTo,Deviation2[1]);
						SetCtrig1X("X","X",0x178,1,SetTo,Deviation2[2]);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
						SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x178,1,1);
						CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						FSetMemoryX(0,SetTo,0,Mask[1]);
						FSetMemoryX(0,SetTo,0,Mask[2]);
					},
					flag = {Preserved}
				}
		else  -- Write X, 1 : EPD(X) << 1
			if type(SourceArr[1]) == "number" then
				if type(SourceArr[2]) == "number" then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x158,1,SetTo,Deviation2[1]);
							SetCtrig1X("X","X",0x178,1,SetTo,Deviation2[2]);
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x178,1,1);
							CallLabelAlways(Dest[1],Dest[2],Dest[3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							FSetMemoryX(0,SetTo,Source[1],Mask[1]);
							FSetMemoryX(0,SetTo,Source[2],Mask[2]);
						},
						flag = {Preserved}
					}
				else
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x17C,1,SetTo,Deviation[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,"X","X",0x17C,1,1);

							SetCtrig1X("X","X",0x158,1,SetTo,Deviation2[1]);
							SetCtrig1X("X","X",0x178,1,SetTo,Deviation2[2]);
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x178,1,1);
							CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							FSetMemoryX(0,SetTo,Source[1],Mask[1]);
							FSetMemoryX(0,SetTo,0,Mask[2]);
						},
						flag = {Preserved}
					}
				end
			else
				if type(SourceArr[2]) == "number" then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x15C,1,SetTo,Deviation[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,"X","X",0x15C,1,1);

							SetCtrig1X("X","X",0x158,1,SetTo,Deviation2[1]);
							SetCtrig1X("X","X",0x178,1,SetTo,Deviation2[2]);
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x178,1,1);
							CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1][1],Source[1][2],Source[1][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							FSetMemoryX(0,SetTo,0,Mask[1]);
							FSetMemoryX(0,SetTo,Source[2],Mask[2]);
						},
						flag = {Preserved}
					}
				else
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x15C,1,SetTo,Deviation[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,"X","X",0x15C,1,1);
							SetCtrig1X("X","X",0x17C,1,SetTo,Deviation[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,"X","X",0x17C,1,1);

							SetCtrig1X("X","X",0x158,1,SetTo,Deviation2[1]);
							SetCtrig1X("X","X",0x178,1,SetTo,Deviation2[2]);
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x188,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Dest[1],Dest[2],0x1A0,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x158,1,1);
							SetCtrigX(Dest[1],Dest[2],0x198,Dest[3],SetTo,"X","X",0x178,1,1);
							CallLabelAlways3(Dest[1],Dest[2],Dest[3],Source[1][1],Source[1][2],Source[1][3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							FSetMemoryX(0,SetTo,0,Mask[1]);
							FSetMemoryX(0,SetTo,0,Mask[2]);
						},
						flag = {Preserved}
					}
				end
			end
		end
	else -- {V,V}
		if SourceArr == "W" then -- Write  Vx2, W : EPD(Vx2) << W
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x15C,1,SetTo,Deviation[1]);
						SetCtrig1X("X","X",0x17C,1,SetTo,Deviation[2]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x15C,1,1);
						SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X","X",0x17C,1,1);

						SetCtrig1X("X","X",0x158,1,SetTo,Dest[1][5]);
						SetCtrig1X(Dest[1][1],Dest[1][2],0x148,Dest[1][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1][1],Dest[1][2],0x160,Dest[1][3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1][1],Dest[1][2],0x158,Dest[1][3],SetTo,"X","X",0x158,1,1);
						SetCtrig1X("X","X",0x178,1,SetTo,Dest[2][5]);
						SetCtrig1X(Dest[2][1],Dest[2][2],0x148,Dest[2][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[2][1],Dest[2][2],0x160,Dest[2][3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[2][1],Dest[2][2],0x158,Dest[2][3],SetTo,"X","X",0x178,1,1);
						CallLabelAlways3(Dest[1][1],Dest[1][2],Dest[1][3],Dest[2][1],Dest[2][2],Dest[2][3],Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						FSetMemoryX(0,SetTo,0,Mask[1]);
						FSetMemoryX(0,SetTo,0,Mask[2]);
					},
					flag = {Preserved}
				}
		else  -- Write X, 1 : EPD(X) << 1
			if type(SourceArr[1]) == "number" then
				if type(SourceArr[2]) == "number" then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x158,1,SetTo,Dest[1][5]);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x148,Dest[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x160,Dest[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1][1],Dest[1][2],0x158,Dest[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X("X","X",0x178,1,SetTo,Dest[2][5]);
							SetCtrig1X(Dest[2][1],Dest[2][2],0x148,Dest[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[2][1],Dest[2][2],0x160,Dest[2][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[2][1],Dest[2][2],0x158,Dest[2][3],SetTo,"X","X",0x178,1,1);
							CallLabelAlways2(Dest[1][1],Dest[1][2],Dest[1][3],Dest[2][1],Dest[2][2],Dest[2][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							FSetMemoryX(0,SetTo,Source[1],Mask[1]);
							FSetMemoryX(0,SetTo,Source[2],Mask[2]);
						},
						flag = {Preserved}
					}
				else
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x17C,1,SetTo,Deviation[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,"X","X",0x17C,1,1);

							SetCtrig1X("X","X",0x158,1,SetTo,Dest[1][5]);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x148,Dest[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x160,Dest[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1][1],Dest[1][2],0x158,Dest[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X("X","X",0x178,1,SetTo,Dest[2][5]);
							SetCtrig1X(Dest[2][1],Dest[2][2],0x148,Dest[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[2][1],Dest[2][2],0x160,Dest[2][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[2][1],Dest[2][2],0x158,Dest[2][3],SetTo,"X","X",0x178,1,1);
							CallLabelAlways3(Dest[1][1],Dest[1][2],Dest[1][3],Dest[2][1],Dest[2][2],Dest[2][3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							FSetMemoryX(0,SetTo,Source[1],Mask[1]);
							FSetMemoryX(0,SetTo,0,Mask[2]);
						},
						flag = {Preserved}
					}
				end
			else
				if type(SourceArr[2]) == "number" then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x15C,1,SetTo,Deviation[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,"X","X",0x15C,1,1);

							SetCtrig1X("X","X",0x158,1,SetTo,Dest[1][5]);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x148,Dest[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x160,Dest[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1][1],Dest[1][2],0x158,Dest[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X("X","X",0x178,1,SetTo,Dest[2][5]);
							SetCtrig1X(Dest[2][1],Dest[2][2],0x148,Dest[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[2][1],Dest[2][2],0x160,Dest[2][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[2][1],Dest[2][2],0x158,Dest[2][3],SetTo,"X","X",0x178,1,1);
							CallLabelAlways3(Dest[1][1],Dest[1][2],Dest[1][3],Dest[2][1],Dest[2][2],Dest[2][3],Source[1][1],Source[1][2],Source[1][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							FSetMemoryX(0,SetTo,0,Mask[1]);
							FSetMemoryX(0,SetTo,Source[2],Mask[2]);
						},
						flag = {Preserved}
					}
				else
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x15C,1,SetTo,Deviation[1]);
							SetCtrig1X(Source[1][1],Source[1][2],0x148,Source[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1][1],Source[1][2],0x160,Source[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[1][1],Source[1][2],0x158,Source[1][3],SetTo,"X","X",0x15C,1,1);
							SetCtrig1X("X","X",0x17C,1,SetTo,Deviation[2]);
							SetCtrig1X(Source[2][1],Source[2][2],0x148,Source[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[2][1],Source[2][2],0x160,Source[2][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[2][1],Source[2][2],0x158,Source[2][3],SetTo,"X","X",0x17C,1,1);

							SetCtrig1X("X","X",0x158,1,SetTo,Dest[1][5]);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x148,Dest[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1][1],Dest[1][2],0x160,Dest[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1][1],Dest[1][2],0x158,Dest[1][3],SetTo,"X","X",0x158,1,1);
							SetCtrig1X("X","X",0x178,1,SetTo,Dest[2][5]);
							SetCtrig1X(Dest[2][1],Dest[2][2],0x148,Dest[2][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[2][1],Dest[2][2],0x160,Dest[2][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[2][1],Dest[2][2],0x158,Dest[2][3],SetTo,"X","X",0x178,1,1);
							CallLabelAlways4(Dest[1][1],Dest[1][2],Dest[1][3],Dest[2][1],Dest[2][2],Dest[2][3],Source[1][1],Source[1][2],Source[1][3],Source[2][1],Source[2][2],Source[2][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							FSetMemoryX(0,SetTo,0,Mask[1]);
							FSetMemoryX(0,SetTo,0,Mask[2]);
						},
						flag = {Preserved}
					}
				end
			end
		end
	end
end


function f_LRead(PlayerID,Input,Output,Mask,Clear) -- (CPRead) 방식으로 읽음
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LRead_InputData_Error()
	end

	local InputArr = {}
	if Input == "Cp" then -- Cp
		LRead_InputData_Error()
	elseif type(Input) == "number" then -- Offset 4
		Input = {Input,Input+4}
		InputArr = {4,4}
	elseif type(Input) == "table" then
		if Input[4] == "WA" then -- W
			InputArr = "WA"
		elseif Input[4] == "LA_V" then -- W
			InputArr = "LA_V"
		elseif Input[4] == "LA_W" then
			InputArr = "LA_W" 
		elseif Input[4] == "W" then -- W
			InputArr = "W"
		elseif #Input == 2 then
			if Input[1] == "Cp" and type(Input[2][1]) == "number" then -- Cp + Diff(epd)
				LRead_InputData_Error()
			elseif type(Input[1]) == "number" then -- Offset {4, } 
				if type(Input[2]) == "number" then -- Offset {4,4}
					InputArr = {4,4}
				elseif type(Input[2]) == "table" then -- Offset {4,{ }}
					if #Input[2] == 1 then -- Offset {4,{Size}}
						Input = {Input[1],Input[1]+Input[2][1]}
						InputArr = {4,4}
					elseif Input[2][4] == "V" then -- Offset {4,V}
						InputArr = {4,"V"}
					elseif Input[2][4] == "VA" then
						InputArr = {4,"VA"}
					elseif Input[2][4] == "A" then
						InputArr = {4,"A"}
					else -- Offset {4,Mem}
						InputArr = {4,"Mem"}
					end
				end
			elseif type(Input[1]) == "table" then
				if Input[1][4] == "V" then -- {V, } 
					if type(Input[2]) == "number" then -- {V,4}
						InputArr = {"V",4}
					elseif type(Input[2]) == "table" then
						if Input[2][4] == "V" then -- {V,V}
							InputArr = {"V","V"}
						elseif Input[2][4] == "VA" then
							InputArr = {"V","VA"}
						elseif Input[2][4] == "A" then
							InputArr = {"V","A"}
						else -- {V,Mem}
							InputArr = {"V","Mem"}
						end
					end
				elseif Input[1][4] == "VA" then -- {V, } 
					if type(Input[2]) == "number" then -- {V,4}
						InputArr = {"VA",4}
					elseif type(Input[2]) == "table" then
						if Input[2][4] == "V" then -- {V,V}
							InputArr = {"VA","V"}
						elseif Input[2][4] == "VA" then
							InputArr = {"VA","VA"}
						elseif Input[2][4] == "A" then
							InputArr = {"VA","A"}
						else -- {V,Mem}
							InputArr = {"VA","Mem"}
						end
					end
				elseif Input[1][4] == "A" then -- {V, } 
					if type(Input[2]) == "number" then -- {V,4}
						InputArr = {"A",4}
					elseif type(Input[2]) == "table" then
						if Input[2][4] == "V" then -- {V,V}
							InputArr = {"A","V"}
						elseif Input[2][4] == "VA" then
							InputArr = {"A","VA"}
						elseif Input[2][4] == "A" then
							InputArr = {"A","A"}
						else -- {V,Mem}
							InputArr = {"A","Mem"}
						end
					end
				elseif type(Input[1][4]) ~= "string" then -- {Mem, }
					if type(Input[2]) == "number" then -- {Mem,4}
						InputArr = {"Mem",4}
					elseif type(Input[2]) == "table" then -- {Mem,{}}
						if #Input[2] == 1 then -- {Mem,{Size}}
							local Temp = Input
							Input = {}
							table.insert(Input,Temp[1])
							Temp[1][3] = Temp[1][3] + Input[2][1]
							table.insert(Input,Temp[1])
							InputArr = {"Mem","Mem"}
						elseif Input[2][4] == "V" then -- {Mem,V}
							InputArr = {"Mem","V"}
						elseif Input[2][4] == "VA" then
							InputArr = {"Mem","VA"}
						elseif Input[2][4] == "A" then
							InputArr = {"Mem","A"}
						else -- {Mem,Mem}
							InputArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LRead_InputData_Error()
			end
		elseif type(Input[4]) ~= "string" then -- Mem 4 
			local Temp = Input
			Input = {}
			table.insert(Input,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Input,Temp)
			InputArr = {"Mem","Mem"}
		else
			LRead_InputData_Error()
		end
	else
		LRead_InputData_Error()
	end

	local OutputArr = {}
	if Output == "Cp" then -- Cp
		LRead_OutputData_Error()
	elseif type(Output) == "number" then -- Offset 4
		Output = {Output,Output+4}
		OutputArr = {4,4}
	elseif type(Output) == "table" then
		if Output[4] == "WA" then -- W
			OutputArr = "WA"
		elseif Output[4] == "LA_V" then -- W
			OutputArr = "LA_V"
		elseif Output[4] == "LA_W" then
			OutputArr = "LA_W" 
		elseif Output[4] == "W" then -- W
			OutputArr = "W"
		elseif #Output == 2 then
			if Output[1] == "Cp" and type(Output[2][1]) == "number" then -- Cp + Diff(epd)
				LRead_OutputData_Error()
			elseif type(Output[1]) == "number" then -- Offset {4, } 
				if type(Output[2]) == "number" then -- Offset {4,4}
					OutputArr = {4,4}
				elseif type(Output[2]) == "table" then -- Offset {4,{ }}
					if #Output[2] == 1 then -- Offset {4,{Size}}
						Output = {Output[1],Output[1]+Output[2][1]}
						OutputArr = {4,4}
					elseif Output[2][4] == "V" then -- Offset {4,V}
						OutputArr = {4,"V"}
					elseif Output[2][4] == "VA" then
						OutputArr = {4,"VA"}
					elseif Output[2][4] == "A" then
						OutputArr = {4,"A"}
					else -- Offset {4,Mem}
						OutputArr = {4,"Mem"}
					end
				end
			elseif type(Output[1]) == "table" then
				if Output[1][4] == "V" then -- {V, } 
					if type(Output[2]) == "number" then -- {V,4}
						OutputArr = {"V",4}
					elseif type(Output[2]) == "table" then
						if Output[2][4] == "V" then -- {V,V}
							OutputArr = {"V","V"}
						elseif Output[2][4] == "VA" then
							OutputArr = {"V","VA"}
						elseif Output[2][4] == "A" then
							OutputArr = {"V","A"}
						else -- {V,Mem}
							OutputArr = {"V","Mem"}
						end
					end
				elseif Output[1][4] == "VA" then -- {V, } 
					if type(Output[2]) == "number" then -- {V,4}
						OutputArr = {"VA",4}
					elseif type(Output[2]) == "table" then
						if Output[2][4] == "V" then -- {V,V}
							OutputArr = {"VA","V"}
						elseif Output[2][4] == "VA" then
							OutputArr = {"VA","VA"}
						elseif Output[2][4] == "A" then
							OutputArr = {"VA","A"}
						else -- {V,Mem}
							OutputArr = {"VA","Mem"}
						end
					end
				elseif Output[1][4] == "A" then -- {V, } 
					if type(Output[2]) == "number" then -- {V,4}
						OutputArr = {"A",4}
					elseif type(Output[2]) == "table" then
						if Output[2][4] == "V" then -- {V,V}
							OutputArr = {"A","V"}
						elseif Output[2][4] == "VA" then
							OutputArr = {"A","VA"}
						elseif Output[2][4] == "A" then
							OutputArr = {"A","A"}
						else -- {V,Mem}
							OutputArr = {"A","Mem"}
						end
					end
				elseif type(Output[1][4]) ~= "string" then -- {Mem, }
					if type(Output[2]) == "number" then -- {Mem,4}
						OutputArr = {"Mem",4}
					elseif type(Output[2]) == "table" then -- {Mem,{}}
						if #Output[2] == 1 then -- {Mem,{Size}}
							local Temp = Output
							Output = {}
							table.insert(Output,Temp[1])
							Temp[1][3] = Temp[1][3] + Output[2][1]
							table.insert(Output,Temp[1])
							OutputArr = {"Mem","Mem"}
						elseif Output[2][4] == "V" then -- {Mem,V}
							OutputArr = {"Mem","V"}
						elseif Output[2][4] == "VA" then
							OutputArr = {"Mem","VA"}
						elseif Output[2][4] == "A" then
							OutputArr = {"Mem","A"}
						else -- {Mem,Mem}
							OutputArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LRead_OutputData_Error()
			end
		elseif type(Output[4]) ~= "string" then -- Mem 4 
			local Temp = Output
			Output = {}
			table.insert(Output,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Output,Temp)
			OutputArr = {"Mem","Mem"}
		else
			LRead_OutputData_Error()
		end
	else
		LRead_OutputData_Error()
	end

	-- Input Data CRet[1],CRet[2] << EPD 
	if InputArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
				SetCtrigX(Input[1],Input[2],0x198,Input[3],SetTo,"X",CRet[2],0x15C,1,0);
				SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x188,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Input[1],Input[2],0x1A0,Input[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Input[1],Input[2],Input[3]);
			},
			flag = {Preserved}
		}
	elseif InputArr == "WA" then
		MovW(PlayerID,{{"X",CRet[1],0,"V"},{"X",CRet[2],0,"V"}},Input)
	elseif InputArr == "LA_V" then
		MovZ(PlayerID,{{"X",CRet[1],0,"V"},{"X",CRet[2],0,"V"}},Input)
	elseif InputArr == "LA_W" then
		MovZ(PlayerID,{{"X",CRet[1],0,"V"},{"X",CRet[2],0,"V"}},Input)
	else
		for i = 1, 2 do
			if type(InputArr[i]) == "number" then
				Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SetCtrig1X("X",CRet[i],0x15C,0,SetTo,EPD(Input[i]));
					},
					flag = {Preserved}
				}
			elseif InputArr[i] == "Mem" then
				Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SetCtrigX("X",CRet[i],0x15C,0,SetTo,Input[i][1],Input[i][2],Input[i][3],1,Input[i][4]);
					},
					flag = {Preserved}
				}
			elseif InputArr[i] == "V" then
				Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SetCtrigX(Input[i][1],Input[i][2],0x158,Input[i][3],SetTo,"X",CRet[i],0x15C,1,0);
						SetCtrig1X(Input[i][1],Input[i][2],0x148,Input[i][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Input[i][1],Input[i][2],0x160,Input[i][3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Input[i][1],Input[i][2],Input[i][3]);
					},
					flag = {Preserved}
				}
			elseif InputArr[i] == "A" then
				MovZ(PlayerID,{"X",CRet[i],0,"V"},Input[i]) 
			elseif InputArr[i] == "VA" then
				MovX(PlayerID,{"X",CRet[i],0,"V"},Input[i]) 
			end
		end
	end

	-- Call f_LRead
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadCall1,0x0,0,0);
					SetCtrigX("X",FLReadCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLReadCall1 == 0 then
		Need_Include_64BitLibrary()
	end
	FLReadCheck = 1
	-- Output Data WRet[1] = Output
	
	if OutputArr == "W" then
		local ClearAct = {}
		if Clear == 1 then
			table.insert(ClearAct,SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,0))
			table.insert(ClearAct,SetCtrig1X(Output[1],Output[2],0x19C,Output[3],SetTo,0))
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				ClearAct,
				SetCtrigX("X",WRet[1],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,Output[1],Output[2],0x19C,1,Output[3]);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
	elseif OutputArr == "WA" then
		MovW(PlayerID,Output,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif OutputArr == "LA_V" then
		MovW(PlayerID,Output,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif OutputArr == "LA_W" then
		MovW(PlayerID,Output,{"X",WRet[1],0,"W"},SetTo,Mask)
	else
		MovY(PlayerID,Output,{"X",WRet[1],0,"W"},OutputArr,Mask)
	end
	
	-- Option : RecoverCp
	RecoverCp(PlayerID)
end

function f_LReadX(PlayerID,Input,Output,Multiplier,Mask,Clear) -- (CPRead) 방식으로 읽음
	STPopTrigArr(PlayerID)
	if Multiplier == "X" or Multiplier == nil then
		Multiplier = 0
	end
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LRead_InputData_Error()
	end

	local InputArr = {}
	if Input == "Cp" then -- Cp
		LRead_InputData_Error()
	elseif type(Input) == "number" then -- Offset 4
		Input = {Input,Input+4}
		InputArr = {4,4}
	elseif type(Input) == "table" then
		if Input[4] == "WA" then -- W
			InputArr = "WA"
		elseif Input[4] == "LA_V" then -- W
			InputArr = "LA_V"
		elseif Input[4] == "LA_W" then
			InputArr = "LA_W" 
		elseif Input[4] == "W" then -- W
			InputArr = "W"
		elseif #Input == 2 then
			if Input[1] == "Cp" and type(Input[2][1]) == "number" then -- Cp + Diff(epd)
				LRead_InputData_Error()
			elseif type(Input[1]) == "number" then -- Offset {4, } 
				if type(Input[2]) == "number" then -- Offset {4,4}
					InputArr = {4,4}
				elseif type(Input[2]) == "table" then -- Offset {4,{ }}
					if #Input[2] == 1 then -- Offset {4,{Size}}
						Input = {Input[1],Input[1]+Input[2][1]}
						InputArr = {4,4}
					elseif Input[2][4] == "V" then -- Offset {4,V}
						InputArr = {4,"V"}
					elseif Input[2][4] == "VA" then
						InputArr = {4,"VA"}
					elseif Input[2][4] == "A" then
						InputArr = {4,"A"}
					else -- Offset {4,Mem}
						InputArr = {4,"Mem"}
					end
				end
			elseif type(Input[1]) == "table" then
				if Input[1][4] == "V" then -- {V, } 
					if type(Input[2]) == "number" then -- {V,4}
						InputArr = {"V",4}
					elseif type(Input[2]) == "table" then
						if Input[2][4] == "V" then -- {V,V}
							InputArr = {"V","V"}
						elseif Input[2][4] == "VA" then
							InputArr = {"V","VA"}
						elseif Input[2][4] == "A" then
							InputArr = {"V","A"}
						else -- {V,Mem}
							InputArr = {"V","Mem"}
						end
					end
				elseif Input[1][4] == "VA" then -- {V, } 
					if type(Input[2]) == "number" then -- {V,4}
						InputArr = {"VA",4}
					elseif type(Input[2]) == "table" then
						if Input[2][4] == "V" then -- {V,V}
							InputArr = {"VA","V"}
						elseif Input[2][4] == "VA" then
							InputArr = {"VA","VA"}
						elseif Input[2][4] == "A" then
							InputArr = {"VA","A"}
						else -- {V,Mem}
							InputArr = {"VA","Mem"}
						end
					end
				elseif Input[1][4] == "A" then -- {V, } 
					if type(Input[2]) == "number" then -- {V,4}
						InputArr = {"A",4}
					elseif type(Input[2]) == "table" then
						if Input[2][4] == "V" then -- {V,V}
							InputArr = {"A","V"}
						elseif Input[2][4] == "VA" then
							InputArr = {"A","VA"}
						elseif Input[2][4] == "A" then
							InputArr = {"A","A"}
						else -- {V,Mem}
							InputArr = {"A","Mem"}
						end
					end
				elseif type(Input[1][4]) ~= "string" then -- {Mem, }
					if type(Input[2]) == "number" then -- {Mem,4}
						InputArr = {"Mem",4}
					elseif type(Input[2]) == "table" then -- {Mem,{}}
						if #Input[2] == 1 then -- {Mem,{Size}}
							local Temp = Input
							Input = {}
							table.insert(Input,Temp[1])
							Temp[1][3] = Temp[1][3] + Input[2][1]
							table.insert(Input,Temp[1])
							InputArr = {"Mem","Mem"}
						elseif Input[2][4] == "V" then -- {Mem,V}
							InputArr = {"Mem","V"}
						elseif Input[2][4] == "VA" then
							InputArr = {"Mem","VA"}
						elseif Input[2][4] == "A" then
							InputArr = {"Mem","A"}
						else -- {Mem,Mem}
							InputArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LReadX_InputData_Error()
			end
		elseif type(Input[4]) ~= "string" then -- Mem 4 
			local Temp = Input
			Input = {}
			table.insert(Input,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Input,Temp)
			InputArr = {"Mem","Mem"}
		else
			LReadX_InputData_Error()
		end
	else
		LReadX_InputData_Error()
	end

	local OutputArr = {}
	if Output == "Cp" then -- Cp
		LRead_OutputData_Error()
	elseif type(Output) == "number" then -- Offset 4
		Output = {Output,Output+4}
		OutputArr = {4,4}
	elseif type(Output) == "table" then
		if Output[4] == "WA" then -- W
			OutputArr = "WA"
		elseif Output[4] == "LA_V" then -- W
			OutputArr = "LA_V"
		elseif Output[4] == "LA_W" then
			OutputArr = "LA_W" 
		elseif Output[4] == "W" then -- W
			OutputArr = "W"
		elseif #Output == 2 then
			if Output[1] == "Cp" and type(Output[2][1]) == "number" then -- Cp + Diff(epd)
				LRead_OutputData_Error()
			elseif type(Output[1]) == "number" then -- Offset {4, } 
				if type(Output[2]) == "number" then -- Offset {4,4}
					OutputArr = {4,4}
				elseif type(Output[2]) == "table" then -- Offset {4,{ }}
					if #Output[2] == 1 then -- Offset {4,{Size}}
						Output = {Output[1],Output[1]+Output[2][1]}
						OutputArr = {4,4}
					elseif Output[2][4] == "V" then -- Offset {4,V}
						OutputArr = {4,"V"}
					elseif Output[2][4] == "VA" then
						OutputArr = {4,"VA"}
					elseif Output[2][4] == "A" then
						OutputArr = {4,"A"}
					else -- Offset {4,Mem}
						OutputArr = {4,"Mem"}
					end
				end
			elseif type(Output[1]) == "table" then
				if Output[1][4] == "V" then -- {V, } 
					if type(Output[2]) == "number" then -- {V,4}
						OutputArr = {"V",4}
					elseif type(Output[2]) == "table" then
						if Output[2][4] == "V" then -- {V,V}
							OutputArr = {"V","V"}
						elseif Output[2][4] == "VA" then
							OutputArr = {"V","VA"}
						elseif Output[2][4] == "A" then
							OutputArr = {"V","A"}
						else -- {V,Mem}
							OutputArr = {"V","Mem"}
						end
					end
				elseif Output[1][4] == "VA" then -- {V, } 
					if type(Output[2]) == "number" then -- {V,4}
						OutputArr = {"VA",4}
					elseif type(Output[2]) == "table" then
						if Output[2][4] == "V" then -- {V,V}
							OutputArr = {"VA","V"}
						elseif Output[2][4] == "VA" then
							OutputArr = {"VA","VA"}
						elseif Output[2][4] == "A" then
							OutputArr = {"VA","A"}
						else -- {V,Mem}
							OutputArr = {"VA","Mem"}
						end
					end
				elseif Output[1][4] == "A" then -- {V, } 
					if type(Output[2]) == "number" then -- {V,4}
						OutputArr = {"A",4}
					elseif type(Output[2]) == "table" then
						if Output[2][4] == "V" then -- {V,V}
							OutputArr = {"A","V"}
						elseif Output[2][4] == "VA" then
							OutputArr = {"A","VA"}
						elseif Output[2][4] == "A" then
							OutputArr = {"A","A"}
						else -- {V,Mem}
							OutputArr = {"A","Mem"}
						end
					end
				elseif type(Output[1][4]) ~= "string" then -- {Mem, }
					if type(Output[2]) == "number" then -- {Mem,4}
						OutputArr = {"Mem",4}
					elseif type(Output[2]) == "table" then -- {Mem,{}}
						if #Output[2] == 1 then -- {Mem,{Size}}
							local Temp = Output
							Output = {}
							table.insert(Output,Temp[1])
							Temp[1][3] = Temp[1][3] + Output[2][1]
							table.insert(Output,Temp[1])
							OutputArr = {"Mem","Mem"}
						elseif Output[2][4] == "V" then -- {Mem,V}
							OutputArr = {"Mem","V"}
						elseif Output[2][4] == "VA" then
							OutputArr = {"Mem","VA"}
						elseif Output[2][4] == "A" then
							OutputArr = {"Mem","A"}
						else -- {Mem,Mem}
							OutputArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LReadX_InputData_Error()
			end
		elseif type(Output[4]) ~= "string" then -- Mem 4 
			local Temp = Output
			Output = {}
			table.insert(Output,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Output,Temp)
			OutputArr = {"Mem","Mem"}
		else
			LReadX_InputData_Error()
		end
	else
		LReadX_InputData_Error()
	end

	-- Input Data CRet[1],CRet[2] << EPD 
	if InputArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",CRet[1],0x15C,1,0);
				SetCtrigX(Input[1],Input[2],0x198,Input[3],SetTo,"X",CRet[2],0x15C,1,0);
				SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x188,Input[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Input[1],Input[2],0x1A0,Input[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Input[1],Input[2],Input[3]);
			},
			flag = {Preserved}
		}
	elseif InputArr == "WA" then
		MovW(PlayerID,{{"X",CRet[1],0,"V"},{"X",CRet[2],0,"V"}},Input)
	elseif InputArr == "LA_V" then
		MovZ(PlayerID,{{"X",CRet[1],0,"V"},{"X",CRet[2],0,"V"}},Input)
	elseif InputArr == "LA_W" then
		MovZ(PlayerID,{{"X",CRet[1],0,"V"},{"X",CRet[2],0,"V"}},Input)
	else
		for i = 1, 2 do
			if type(InputArr[i]) == "number" then
				Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SetCtrig1X("X",CRet[i],0x15C,0,SetTo,EPD(Input[i]));
					},
					flag = {Preserved}
				}
			elseif InputArr[i] == "Mem" then
				Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SetCtrigX("X",CRet[i],0x15C,0,SetTo,Input[i][1],Input[i][2],Input[i][3],1,Input[i][4]);
					},
					flag = {Preserved}
				}
			elseif InputArr[i] == "V" then
				Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SetCtrigX(Input[i][1],Input[i][2],0x158,Input[i][3],SetTo,"X",CRet[i],0x15C,1,0);
						SetCtrig1X(Input[i][1],Input[i][2],0x148,Input[i][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Input[i][1],Input[i][2],0x160,Input[i][3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Input[i][1],Input[i][2],Input[i][3]);
					},
					flag = {Preserved}
				}
			elseif InputArr[i] == "A" then
				MovZ(PlayerID,{"X",CRet[i],0,"V"},Input[i]) 
			elseif InputArr[i] == "VA" then
				MovX(PlayerID,{"X",CRet[i],0,"V"},Input[i]) 
			end
		end
	end

	-- Call f_LReadX
	FLReadXCheck = 1
	if Multiplier == 0 then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[1],0x0,0,0);
					SetCtrigX("X",FLReadXCall[2],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == 1 then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[3],0x0,0,0);
					SetCtrigX("X",FLReadXCall[4],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == 2 then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[5],0x0,0,0);
					SetCtrigX("X",FLReadXCall[6],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == 3 then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[7],0x0,0,0);
					SetCtrigX("X",FLReadXCall[8],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == 4 then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[9],0x0,0,0);
					SetCtrigX("X",FLReadXCall[10],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == 5 then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[11],0x0,0,0);
					SetCtrigX("X",FLReadXCall[12],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == 6 then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[13],0x0,0,0);
					SetCtrigX("X",FLReadXCall[14],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == 7 then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[15],0x0,0,0);
					SetCtrigX("X",FLReadXCall[16],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == -1 then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[17],0x0,0,0);
					SetCtrigX("X",FLReadXCall[18],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == -2 then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[19],0x0,0,0);
					SetCtrigX("X",FLReadXCall[20],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == -3 then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[21],0x0,0,0);
					SetCtrigX("X",FLReadXCall[22],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == -4 then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[23],0x0,0,0);
					SetCtrigX("X",FLReadXCall[24],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == -5 then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[25],0x0,0,0);
					SetCtrigX("X",FLReadXCall[26],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == -6 then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[27],0x0,0,0);
					SetCtrigX("X",FLReadXCall[28],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	elseif Multiplier == -7 then
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLReadXCall[29],0x0,0,0);
					SetCtrigX("X",FLReadXCall[30],0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	else
		LReadX_InputData_Error()
	end

	if FLReadXCall[1] == nil then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[1] = Output
	
	if OutputArr == "W" then
		local ClearAct = {}
		if Clear == 1 then
			table.insert(ClearAct,SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,0))
			table.insert(ClearAct,SetCtrig1X(Output[1],Output[2],0x19C,Output[3],SetTo,0))
		end
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				ClearAct,
				SetCtrigX("X",WRet[1],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,Output[1],Output[2],0x19C,1,Output[3]);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
	elseif OutputArr == "WA" then
		MovW(PlayerID,Output,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif OutputArr == "LA_V" then
		MovW(PlayerID,Output,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif OutputArr == "LA_W" then
		MovW(PlayerID,Output,{"X",WRet[1],0,"W"},SetTo,Mask)
	else
		MovY(PlayerID,Output,{"X",WRet[1],0,"W"},OutputArr,Mask)
	end
	
	-- Option : RecoverCp
	RecoverCp(PlayerID)
end

function f_LAnd(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LAnd_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LAnd_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LAnd_InputData_Error()
		end
	else
		LAnd_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LAnd_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LAnd_InputData_Error()
		elseif Source[4] == "LA_W" then
			LAnd_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LAnd_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LAnd_InputData_Error()
					else -- Offset {4,Mem}
						LAnd_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LAnd_InputData_Error()
						else -- {V,Mem}
							LAnd_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LAnd_InputData_Error()
						else -- {V,Mem}
							LAnd_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LAnd_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LAnd_InputData_Error()
				end
			else
				LAnd_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LAnd_InputData_Error()
		else
			LAnd_InputData_Error()
		end
	else
		LAnd_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LAnd_InputData_Error()
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LAnd_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LAnd_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LAnd_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LAnd_InputData_Error()
					else -- Offset {4,Mem}
						LAnd_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LAnd_InputData_Error()
						else -- {V,Mem}
							LAnd_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LAnd_InputData_Error()
						else -- {V,Mem}
							LAnd_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LAnd_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LAnd_InputData_Error()
				end
			else
				LAnd_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LAnd_InputData_Error()
		else
			LAnd_InputData_Error()
		end
	else
		LAnd_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end
	-- Input Data WRet[3] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[3],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[3],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[3],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[3],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LAnd
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLAndCall1,0x0,0,0);
					SetCtrigX("X",FLAndCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLAndCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[2] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[2],0,"W"},DestArr,Mask)
	end
end

function f_LOr(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LOr_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LOr_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LOr_InputData_Error()
		end
	else
		LOr_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LOr_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LOr_InputData_Error()
		elseif Source[4] == "LA_W" then
			LOr_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LOr_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LOr_InputData_Error()
					else -- Offset {4,Mem}
						LOr_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LOr_InputData_Error()
						else -- {V,Mem}
							LOr_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LOr_InputData_Error()
						else -- {V,Mem}
							LOr_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LOr_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LOr_InputData_Error()
				end
			else
				LOr_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LOr_InputData_Error()
		else
			LOr_InputData_Error()
		end
	else
		LOr_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LOr_InputData_Error()
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LOr_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LOr_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LOr_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LOr_InputData_Error()
					else -- Offset {4,Mem}
						LOr_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LOr_InputData_Error()
						else -- {V,Mem}
							LOr_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LOr_InputData_Error()
						else -- {V,Mem}
							LOr_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LOr_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LOr_InputData_Error()
				end
			else
				LOr_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LOr_InputData_Error()
		else
			LOr_InputData_Error()
		end
	else
		LOr_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end
	-- Input Data WRet[3] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[3],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[3],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[3],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[3],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LOr
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLOrCall1,0x0,0,0);
					SetCtrigX("X",FLOrCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLOrCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[2] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[2],0,"W"},DestArr,Mask)
	end
end

function f_LXor(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LXor_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LXor_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LXor_InputData_Error()
		end
	else
		LXor_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LXor_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LXor_InputData_Error()
		elseif Source[4] == "LA_W" then
			LXor_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LXor_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LXor_InputData_Error()
					else -- Offset {4,Mem}
						LXor_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LXor_InputData_Error()
						else -- {V,Mem}
							LXor_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LXor_InputData_Error()
						else -- {V,Mem}
							LXor_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LXor_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LXor_InputData_Error()
				end
			else
				LXor_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LXor_InputData_Error()
		else
			LXor_InputData_Error()
		end
	else
		LXor_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LXor_InputData_Error()
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LXor_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LXor_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LXor_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LXor_InputData_Error()
					else -- Offset {4,Mem}
						LXor_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LXor_InputData_Error()
						else -- {V,Mem}
							LXor_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LXor_InputData_Error()
						else -- {V,Mem}
							LXor_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LXor_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LXor_InputData_Error()
				end
			else
				LXor_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LXor_InputData_Error()
		else
			LXor_InputData_Error()
		end
	else
		LXor_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end
	-- Input Data WRet[3] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[3],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[3],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[3],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[3],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LXor
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLXorCall1,0x0,0,0);
					SetCtrigX("X",FLXorCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLXorCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[2] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[2],0,"W"},DestArr,Mask)
	end
end

function f_LNot(PlayerID,Dest,Source,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LNot_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LNot_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LNot_InputData_Error()
		end
	else
		LNot_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LNot_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LNot_InputData_Error()
		elseif Source[4] == "LA_W" then
			LNot_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LNot_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LNot_InputData_Error()
					else -- Offset {4,Mem}
						LNot_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LNot_InputData_Error()
						else -- {V,Mem}
							LNot_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LNot_InputData_Error()
						else -- {V,Mem}
							LNot_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LNot_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LNot_InputData_Error()
				end
			else
				LNot_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LNot_InputData_Error()
		else
			LNot_InputData_Error()
		end
	else
		LNot_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LNot
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLNotCall1,0x0,0,0);
					SetCtrigX("X",FLNotCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLNotCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[1] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[1],0,"W"},DestArr,Mask)
	end
end

function f_LAdd(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LAdd_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LAdd_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LAdd_InputData_Error()
		end
	else
		LAdd_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LAdd_InputData_Error()
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LAdd_InputData_Error()
		elseif Source[4] == "LA_W" then
			LAdd_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LAdd_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LAdd_InputData_Error()
					else -- Offset {4,Mem}
						LAdd_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LAdd_InputData_Error()
						else -- {V,Mem}
							LAdd_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LAdd_InputData_Error()
						else -- {V,Mem}
							LAdd_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LAdd_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LAdd_InputData_Error()
				end
			else
				LAdd_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LAdd_InputData_Error()
		else
			LAdd_InputData_Error()
		end
	else
		LAdd_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LAdd_InputData_Error()
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LAdd_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LAdd_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LAdd_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LAdd_InputData_Error()
					else -- Offset {4,Mem}
						LAdd_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LAdd_InputData_Error()
						else -- {V,Mem}
							LAdd_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LAdd_InputData_Error()
						else -- {V,Mem}
							LAdd_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LAdd_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LAdd_InputData_Error()
				end
			else
				LAdd_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LAdd_InputData_Error()
		else
			LAdd_InputData_Error()
		end
	else
		LAdd_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end
	-- Input Data WRet[3] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[3],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[3],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[3],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[3],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LAdd
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLAddCall1,0x0,0,0);
					SetCtrigX("X",FLAddCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLAddCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[2] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[2],0,"W"},DestArr,Mask)
	end
end

function f_LSub(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LSub_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LSub_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LSub_InputData_Error()
		end
	else
		LSub_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LSub_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LSub_InputData_Error()
		elseif Source[4] == "LA_W" then
			LSub_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LSub_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LSub_InputData_Error()
					else -- Offset {4,Mem}
						LSub_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LSub_InputData_Error()
						else -- {V,Mem}
							LSub_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LSub_InputData_Error()
						else -- {V,Mem}
							LSub_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LSub_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LSub_InputData_Error()
				end
			else
				LSub_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LSub_InputData_Error()
		else
			LSub_InputData_Error()
		end
	else
		LSub_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LSub_InputData_Error()
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LSub_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LSub_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LSub_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LSub_InputData_Error()
					else -- Offset {4,Mem}
						LSub_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LSub_InputData_Error()
						else -- {V,Mem}
							LSub_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LSub_InputData_Error()
						else -- {V,Mem}
							LSub_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LSub_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LSub_InputData_Error()
				end
			else
				LSub_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LSub_InputData_Error()
		else
			LSub_InputData_Error()
		end
	else
		LSub_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end
	-- Input Data WRet[3] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[3],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[3],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[3],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[3],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LSub
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLSubCall1,0x0,0,0);
					SetCtrigX("X",FLSubCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLSubCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[2] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[2],0,"W"},DestArr,Mask)
	end
end

function f_LNeg(PlayerID,Dest,Source,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LNeg_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LNeg_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LNeg_InputData_Error()
		end
	else
		LNeg_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LNeg_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LNeg_InputData_Error()
		elseif Source[4] == "LA_W" then
			LNeg_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LNeg_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LNeg_InputData_Error()
					else -- Offset {4,Mem}
						LNeg_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LNeg_InputData_Error()
						else -- {V,Mem}
							LNeg_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LNeg_InputData_Error()
						else -- {V,Mem}
							LNeg_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LNeg_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LNeg_InputData_Error()
				end
			else
				LNeg_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LNeg_InputData_Error()
		else
			LNeg_InputData_Error()
		end
	else
		LNeg_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LNeg
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLNegCall1,0x0,0,0);
					SetCtrigX("X",FLNegCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLNegCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[1] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[1],0,"W"},DestArr,Mask)
	end
end

function f_LiSub(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LiSub_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LiSub_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LiSub_InputData_Error()
		end
	else
		LiSub_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LiSub_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LiSub_InputData_Error()
		elseif Source[4] == "LA_W" then
			LiSub_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LiSub_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LiSub_InputData_Error()
					else -- Offset {4,Mem}
						LiSub_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LiSub_InputData_Error()
						else -- {V,Mem}
							LiSub_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LiSub_InputData_Error()
						else -- {V,Mem}
							LiSub_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LiSub_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LiSub_InputData_Error()
				end
			else
				LiSub_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LiSub_InputData_Error()
		else
			LiSub_InputData_Error()
		end
	else
		LiSub_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LiSub_InputData_Error()
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LiSub_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LiSub_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LiSub_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LiSub_InputData_Error()
					else -- Offset {4,Mem}
						LiSub_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LiSub_InputData_Error()
						else -- {V,Mem}
							LiSub_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LiSub_InputData_Error()
						else -- {V,Mem}
							LiSub_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LiSub_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LiSub_InputData_Error()
				end
			else
				LiSub_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LiSub_InputData_Error()
		else
			LiSub_InputData_Error()
		end
	else
		LiSub_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end
	-- Input Data WRet[3] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[3],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[3],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[3],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[3],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LiSub
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLiSubCall1,0x0,0,0);
					SetCtrigX("X",FLiSubCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLiSubCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[1] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[1],0,"W"},DestArr,Mask)
	end
end

function f_LAbs(PlayerID,Dest,Source,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LAbs_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LAbs_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LAbs_InputData_Error()
		end
	else
		LAbs_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LAbs_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LAbs_InputData_Error()
		elseif Source[4] == "LA_W" then
			LAbs_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LAbs_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LAbs_InputData_Error()
					else -- Offset {4,Mem}
						LAbs_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LAbs_InputData_Error()
						else -- {V,Mem}
							LAbs_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LAbs_InputData_Error()
						else -- {V,Mem}
							LAbs_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LAbs_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LAbs_InputData_Error()
				end
			else
				LAbs_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LAbs_InputData_Error()
		else
			LAbs_InputData_Error()
		end
	else
		LAbs_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LAbs
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLAbsCall1,0x0,0,0);
					SetCtrigX("X",FLAbsCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLAbsCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[1] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[1],0,"W"},DestArr,Mask)
	end
end

function f_LRand(PlayerID,Dest,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LRand_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LRand_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LRand_InputData_Error()
		end
	else
		LRand_InputData_Error()
	end

	-- Call f_LRand
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLRandCall1,0x0,0,0);
					SetCtrigX("X",FLRandCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLRandCall1 == 0 then
		Need_Include_64BitLibrary()
	end
	FLRandCheck = 1
	-- Output Data WRet[1] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[1],0,"W"},DestArr,Mask)
	end
end


function f_LlShift(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LlShift_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LlShift_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LlShift_InputData_Error()
		end
	else
		LlShift_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LlShift_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LlShift_InputData_Error()
		elseif Source[4] == "LA_W" then
			LlShift_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LlShift_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LlShift_InputData_Error()
					else -- Offset {4,Mem}
						LlShift_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LlShift_InputData_Error()
						else -- {V,Mem}
							LlShift_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LlShift_InputData_Error()
						else -- {V,Mem}
							LlShift_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LlShift_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LlShift_InputData_Error()
				end
			else
				LlShift_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LlShift_InputData_Error()
		else
			LlShift_InputData_Error()
		end
	else
		LlShift_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Input Data CRet[1] << Value
	if type(Operand) == "number" then
		Trigger {
				players = {PlayerID},
				conditions = {Label(0);},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Operand,0x3F);
				},
				flag = {Preserved}
			}
	elseif Operand[4] == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",CRet[1],0x15C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x198,Operand[3],SetTo,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0x3F);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif Operand[4] == "WA" then
		f_Cast(PlayerID,{{"X",CRet[1],0,"V"},0},Operand,0,{0x3F,0})
	elseif Operand[4] == "V" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",CRet[1],0x15C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0x3F);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif Operand[4] == "VA" then
		MovX(PlayerID,{"X",CRet[1],0,"V"},Operand,SetTo,0x3F)
	end

	-- Call f_LlShift
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0,0xFFFFFFFF-0x3F);
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLlShiftCall1,0x0,0,0);
					SetCtrigX("X",FLlShiftCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLlShiftCall1 == 0 then
		Need_Include_64BitLibrary()
	end

	-- Output Data WRet[2] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[2],0,"W"},DestArr,Mask)
	end
end



function f_LDiv(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LDiv_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LDiv_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LDiv_InputData_Error()
		end
	else
		LDiv_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LDiv_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LDiv_InputData_Error()
		elseif Source[4] == "LA_W" then
			LDiv_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LDiv_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LDiv_InputData_Error()
					else -- Offset {4,Mem}
						LDiv_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LDiv_InputData_Error()
						else -- {V,Mem}
							LDiv_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LDiv_InputData_Error()
						else -- {V,Mem}
							LDiv_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LDiv_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LDiv_InputData_Error()
				end
			else
				LDiv_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LDiv_InputData_Error()
		else
			LDiv_InputData_Error()
		end
	else
		LDiv_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LDiv_InputData_Error()
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LDiv_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LDiv_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LDiv_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LDiv_InputData_Error()
					else -- Offset {4,Mem}
						LDiv_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LDiv_InputData_Error()
						else -- {V,Mem}
							LDiv_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LDiv_InputData_Error()
						else -- {V,Mem}
							LDiv_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LDiv_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LDiv_InputData_Error()
				end
			else
				LDiv_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LDiv_InputData_Error()
		else
			LDiv_InputData_Error()
		end
	else
		LDiv_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Input Data WRet[3] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[3],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[3],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[3],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[3],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LDiv
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLDivCall1,0x0,0,0);
					SetCtrigX("X",FLDivCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLDivCall1 == 0 then
		Need_Include_64BitLibrary()
	end
	FLDivCheck = 1

	-- Output Data WRet[1] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[1],0,"W"},DestArr,Mask)
	end
end


function f_LMod(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LMod_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LMod_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LMod_InputData_Error()
		end
	else
		LMod_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LMod_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LMod_InputData_Error()
		elseif Source[4] == "LA_W" then
			LMod_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LMod_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LMod_InputData_Error()
					else -- Offset {4,Mem}
						LMod_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LMod_InputData_Error()
						else -- {V,Mem}
							LMod_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LMod_InputData_Error()
						else -- {V,Mem}
							LMod_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LMod_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LMod_InputData_Error()
				end
			else
				LMod_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LMod_InputData_Error()
		else
			LMod_InputData_Error()
		end
	else
		LMod_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LMod_InputData_Error()
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LMod_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LMod_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LMod_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LMod_InputData_Error()
					else -- Offset {4,Mem}
						LMod_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LMod_InputData_Error()
						else -- {V,Mem}
							LMod_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LMod_InputData_Error()
						else -- {V,Mem}
							LMod_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LMod_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LMod_InputData_Error()
				end
			else
				LMod_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LMod_InputData_Error()
		else
			LMod_InputData_Error()
		end
	else
		LMod_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Input Data WRet[3] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[3],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[3],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[3],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[3],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LMod
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLModCall1,0x0,0,0);
					SetCtrigX("X",FLModCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLModCall1 == 0 then
		Need_Include_64BitLibrary()
	end
	FLDivCheck = 1

	-- Output Data WRet[2] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[2],0,"W"},DestArr,Mask)
	end
end



function f_LiDiv(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LiDiv_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LiDiv_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LiDiv_InputData_Error()
		end
	else
		LiDiv_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LiDiv_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LiDiv_InputData_Error()
		elseif Source[4] == "LA_W" then
			LiDiv_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LiDiv_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LiDiv_InputData_Error()
					else -- Offset {4,Mem}
						LiDiv_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LiDiv_InputData_Error()
						else -- {V,Mem}
							LiDiv_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LiDiv_InputData_Error()
						else -- {V,Mem}
							LiDiv_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LiDiv_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LiDiv_InputData_Error()
				end
			else
				LiDiv_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LiDiv_InputData_Error()
		else
			LiDiv_InputData_Error()
		end
	else
		LiDiv_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LiDiv_InputData_Error()
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LiDiv_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LiDiv_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LiDiv_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LiDiv_InputData_Error()
					else -- Offset {4,Mem}
						LiDiv_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LiDiv_InputData_Error()
						else -- {V,Mem}
							LiDiv_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LiDiv_InputData_Error()
						else -- {V,Mem}
							LiDiv_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LiDiv_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LiDiv_InputData_Error()
				end
			else
				LiDiv_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LiDiv_InputData_Error()
		else
			LiDiv_InputData_Error()
		end
	else
		LiDiv_InputData_Error()
	end

	-- Input Data WRet[4] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[4],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[4],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[4],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[4],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[4],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[4],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Input Data WRet[3] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[3],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[3],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[3],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[3],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LiDiv
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLiDivCall1,0x0,0,0);
					SetCtrigX("X",FLiDivCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLiDivCall1 == 0 then
		Need_Include_64BitLibrary()
	end
	FLDivCheck = 1
	-- Output Data WRet[4] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[4],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[4],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[4],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[4],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[4],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[4],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[4],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[4],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[4],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[4],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[4],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[4],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[4],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[4],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[4],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[4],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[4],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[4],0,"W"},DestArr,Mask)
	end
end



function f_LiMod(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LiMod_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LiMod_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LiMod_InputData_Error()
		end
	else
		LiMod_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LiMod_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LiMod_InputData_Error()
		elseif Source[4] == "LA_W" then
			LiMod_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LiMod_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LiMod_InputData_Error()
					else -- Offset {4,Mem}
						LiMod_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LiMod_InputData_Error()
						else -- {V,Mem}
							LiMod_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LiMod_InputData_Error()
						else -- {V,Mem}
							LiMod_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LiMod_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LiMod_InputData_Error()
				end
			else
				LiMod_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LiMod_InputData_Error()
		else
			LiMod_InputData_Error()
		end
	else
		LiMod_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LiMod_InputData_Error()
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LiMod_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LiMod_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LiMod_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LiMod_InputData_Error()
					else -- Offset {4,Mem}
						LiMod_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LiMod_InputData_Error()
						else -- {V,Mem}
							LiMod_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LiMod_InputData_Error()
						else -- {V,Mem}
							LiMod_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LiMod_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LiMod_InputData_Error()
				end
			else
				LiMod_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LiMod_InputData_Error()
		else
			LiMod_InputData_Error()
		end
	else
		LiMod_InputData_Error()
	end

	-- Input Data WRet[4] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",WRet[4],0x15C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",WRet[4],0x19C,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{"X",WRet[4],0,"W"},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",WRet[4],0x15C+0x40*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",WRet[4],0x15C+0x40*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[4],0x15C+0x40*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Input Data WRet[3] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[3],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[3],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[3],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[3],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LiMod
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLiModCall1,0x0,0,0);
					SetCtrigX("X",FLiModCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLiModCall1 == 0 then
		Need_Include_64BitLibrary()
	end
	FLDivCheck = 1
	-- Output Data WRet[4] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[4],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[4],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[4],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[4],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[4],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[4],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[4],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[4],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[4],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[4],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[4],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[4],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[4],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[4],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[4],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[4],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[4],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[4],0,"W"},DestArr,Mask)
	end
end


function f_LMul(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LMul_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LMul_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LMul_InputData_Error()
		end
	else
		LMul_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LMul_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LMul_InputData_Error()
		elseif Source[4] == "LA_W" then
			LMul_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LMul_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LMul_InputData_Error()
					else -- Offset {4,Mem}
						LMul_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LMul_InputData_Error()
						else -- {V,Mem}
							LMul_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LMul_InputData_Error()
						else -- {V,Mem}
							LMul_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LMul_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LMul_InputData_Error()
				end
			else
				LMul_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LMul_InputData_Error()
		else
			LMul_InputData_Error()
		end
	else
		LMul_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LMul_InputData_Error()
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LMul_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LMul_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LMul_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LMul_InputData_Error()
					else -- Offset {4,Mem}
						LMul_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LMul_InputData_Error()
						else -- {V,Mem}
							LMul_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LMul_InputData_Error()
						else -- {V,Mem}
							LMul_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LMul_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LMul_InputData_Error()
				end
			else
				LMul_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LMul_InputData_Error()
		else
			LMul_InputData_Error()
		end
	else
		LMul_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FLMulIndex,0x19C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",FLMulIndex,0x1BC,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{{"X",FLMulIndex,0x19C,0},{"X",FLMulIndex,0x1BC,0}},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",FLMulIndex,0x19C+0x20*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",FLMulIndex,0x19C+0x20*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",FLMulIndex,0x19C+0x20*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end
	-- Input Data WRet[3] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[3],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[3],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[3],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[3],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LMul
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLMulCall1,0x0,0,0);
					SetCtrigX("X",FLMulCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLMulCall1 == 0 then
		Need_Include_64BitLibrary()
	end
	FLMulCheck = 1

	-- Output Data WRet[1] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[1],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[1],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[1],0,"W"},DestArr,Mask)
	end
end

function f_LiMul(PlayerID,Dest,Source,Operand,Mask)
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end

	if Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then -- Value "8"
		Mask = I64(Mask)
	elseif type(Mask) == "number" then -- Value {4,4}만 허용
		LiMul_InputData_Error()
	end

	local DestArr = {}
	if Dest == "Cp" then -- Cp
		Dest = {"Cp",1}
		DestArr = "Cp"
	elseif type(Dest) == "number" then -- Offset 4
		Dest = {Dest,Dest+4}
		DestArr = {4,4}
	elseif type(Dest) == "table" then
		if Dest[4] == "WA" then -- W
			DestArr = "WA"
		elseif Dest[4] == "LA_V" then -- W
			DestArr = "LA_V"
		elseif Dest[4] == "LA_W" then
			DestArr = "LA_W"
		elseif Dest[4] == "W" then -- W
			DestArr = "W"
		elseif #Dest == 2 then
			if Dest[1] == "Cp" and type(Dest[2][1]) == "number" then -- Cp + Diff(epd)
				Dest = {"Cp",Dest[2][1]}
				DestArr = "Cp"
			elseif type(Dest[1]) == "number" then -- Offset {4, } 
				if type(Dest[2]) == "number" then -- Offset {4,4}
					DestArr = {4,4}
				elseif type(Dest[2]) == "table" then -- Offset {4,{ }}
					if #Dest[2] == 1 then -- Offset {4,{Size}}
						Dest = {Dest[1],Dest[1]+Dest[2][1]}
						DestArr = {4,4}
					elseif Dest[2][4] == "V" then -- Offset {4,V}
						DestArr = {4,"V"}
					elseif Dest[2][4] == "VA" then
						DestArr = {4,"VA"}
					elseif Dest[2][4] == "A" then
						DestArr = {4,"A"}
					else -- Offset {4,Mem}
						DestArr = {4,"Mem"}
					end
				end
			elseif type(Dest[1]) == "table" then
				if Dest[1][4] == "V" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"V",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"V","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"V","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"V","A"}
						else -- {V,Mem}
							DestArr = {"V","Mem"}
						end
					end
				elseif Dest[1][4] == "VA" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"VA",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"VA","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"VA","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"VA","A"}
						else -- {V,Mem}
							DestArr = {"VA","Mem"}
						end
					end
				elseif Dest[1][4] == "A" then -- {V, } 
					if type(Dest[2]) == "number" then -- {V,4}
						DestArr = {"A",4}
					elseif type(Dest[2]) == "table" then
						if Dest[2][4] == "V" then -- {V,V}
							DestArr = {"A","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"A","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"A","A"}
						else -- {V,Mem}
							DestArr = {"A","Mem"}
						end
					end
				elseif type(Dest[1][4]) ~= "string" then -- {Mem, }
					if type(Dest[2]) == "number" then -- {Mem,4}
						DestArr = {"Mem",4}
					elseif type(Dest[2]) == "table" then -- {Mem,{}}
						if #Dest[2] == 1 then -- {Mem,{Size}}
							local Temp = Dest
							Dest = {}
							table.insert(Dest,Temp[1])
							Temp[1][3] = Temp[1][3] + Dest[2][1]
							table.insert(Dest,Temp[1])
							DestArr = {"Mem","Mem"}
						elseif Dest[2][4] == "V" then -- {Mem,V}
							DestArr = {"Mem","V"}
						elseif Dest[2][4] == "VA" then
							DestArr = {"Mem","VA"}
						elseif Dest[2][4] == "A" then
							DestArr = {"Mem","A"}
						else -- {Mem,Mem}
							DestArr = {"Mem","Mem"}
						end	
					end
				end
			else
				LiMul_InputData_Error()
			end
		elseif type(Dest[4]) ~= "string" then -- Mem 4 
			local Temp = Dest
			Dest = {}
			table.insert(Dest,Temp)
			Temp[3] = Temp[3] + 4
			table.insert(Dest,Temp)
			DestArr = {"Mem","Mem"}
		else
			LiMul_InputData_Error()
		end
	else
		LiMul_InputData_Error()
	end

	local SourceArr = {}
	if Source == "Cp" then -- Cp
		LiMul_InputData_Error()
	elseif type(Source) == "number" then -- Value 4
		Source = {Source,0}
		SourceArr = {4,4}
	elseif type(Source) == "string" then -- Value 4
		Source = I64(Source)
		SourceArr = {4,4}
	elseif type(Source) == "table" then
		if Source[4] == "WA" then -- W
			SourceArr = "WA"
		elseif Source[4] == "LA_V" then -- W
			LiMul_InputData_Error()
		elseif Source[4] == "LA_W" then
			LiMul_InputData_Error()
		elseif Source[4] == "W" then -- W
			SourceArr = "W"
		elseif #Source == 2 then
			if Source[1] == "Cp" and type(Source[2][1]) == "number" then -- Cp + Diff(epd)
				LiMul_InputData_Error()
			elseif type(Source[1]) == "number" then -- Offset {4, } 
				if type(Source[2]) == "number" then -- Offset {4,4}
					SourceArr = {4,4}
				elseif type(Source[2]) == "table" then -- Offset {4,{ }}
					if #Source[2] == 1 then -- Offset {4,{Size}}
						Source = {Source[1],Source[1]+Source[2][1]}
						SourceArr = {4,4}
					elseif Source[2][4] == "V" then -- Offset {4,V}
						SourceArr = {4,"V"}
					elseif Source[2][4] == "VA" then
						SourceArr = {4,"VA"}
					elseif Source[2][4] == "A" then
						LiMul_InputData_Error()
					else -- Offset {4,Mem}
						LiMul_InputData_Error()
					end
				end
			elseif type(Source[1]) == "table" then
				if Source[1][4] == "V" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"V",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"V","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"V","VA"}
						elseif Source[2][4] == "A" then
							LiMul_InputData_Error()
						else -- {V,Mem}
							LiMul_InputData_Error()
						end
					end
				elseif Source[1][4] == "VA" then -- {V, } 
					if type(Source[2]) == "number" then -- {V,4}
						SourceArr = {"VA",4}
					elseif type(Source[2]) == "table" then
						if Source[2][4] == "V" then -- {V,V}
							SourceArr = {"VA","V"}
						elseif Source[2][4] == "VA" then
							SourceArr = {"VA","VA"}
						elseif Source[2][4] == "A" then
							LiMul_InputData_Error()
						else -- {V,Mem}
							LiMul_InputData_Error()
						end
					end
				elseif Source[1][4] == "A" then -- {V, } 
					LiMul_InputData_Error()
				elseif type(Source[1][4]) ~= "string" then -- {Mem, }
					LiMul_InputData_Error()
				end
			else
				LiMul_InputData_Error()
			end
		elseif type(Source[4]) ~= "string" then -- Mem 4 
			LiMul_InputData_Error()
		else
			LiMul_InputData_Error()
		end
	else
		LiMul_InputData_Error()
	end

	local OperandArr = {}
	if Operand == "Cp" then -- Cp
		LiMul_InputData_Error()
	elseif type(Operand) == "number" then -- Value 4
		Operand = {Operand,0}
		OperandArr = {4,4}
	elseif type(Operand) == "string" then -- Value 4
		Operand = I64(Operand)
		OperandArr = {4,4}
	elseif type(Operand) == "table" then
		if Operand[4] == "WA" then -- W
			OperandArr = "WA"
		elseif Operand[4] == "LA_V" then -- W
			LiMul_InputData_Error()
		elseif Operand[4] == "LA_W" then
			LiMul_InputData_Error()
		elseif Operand[4] == "W" then -- W
			OperandArr = "W"
		elseif #Operand == 2 then
			if Operand[1] == "Cp" and type(Operand[2][1]) == "number" then -- Cp + Diff(epd)
				LiMul_InputData_Error()
			elseif type(Operand[1]) == "number" then -- Offset {4, } 
				if type(Operand[2]) == "number" then -- Offset {4,4}
					OperandArr = {4,4}
				elseif type(Operand[2]) == "table" then -- Offset {4,{ }}
					if #Operand[2] == 1 then -- Offset {4,{Size}}
						Operand = {Operand[1],Operand[1]+Operand[2][1]}
						OperandArr = {4,4}
					elseif Operand[2][4] == "V" then -- Offset {4,V}
						OperandArr = {4,"V"}
					elseif Operand[2][4] == "VA" then
						OperandArr = {4,"VA"}
					elseif Operand[2][4] == "A" then
						LiMul_InputData_Error()
					else -- Offset {4,Mem}
						LiMul_InputData_Error()
					end
				end
			elseif type(Operand[1]) == "table" then
				if Operand[1][4] == "V" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"V",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"V","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"V","VA"}
						elseif Operand[2][4] == "A" then
							LiMul_InputData_Error()
						else -- {V,Mem}
							LiMul_InputData_Error()
						end
					end
				elseif Operand[1][4] == "VA" then -- {V, } 
					if type(Operand[2]) == "number" then -- {V,4}
						OperandArr = {"VA",4}
					elseif type(Operand[2]) == "table" then
						if Operand[2][4] == "V" then -- {V,V}
							OperandArr = {"VA","V"}
						elseif Operand[2][4] == "VA" then
							OperandArr = {"VA","VA"}
						elseif Operand[2][4] == "A" then
							LiMul_InputData_Error()
						else -- {V,Mem}
							LiMul_InputData_Error()
						end
					end
				elseif Operand[1][4] == "A" then -- {V, } 
					LiMul_InputData_Error()
				elseif type(Operand[1][4]) ~= "string" then -- {Mem, }
					LiMul_InputData_Error()
				end
			else
				LiMul_InputData_Error()
			end
		elseif type(Operand[4]) ~= "string" then -- Mem 4 
			LiMul_InputData_Error()
		else
			LiMul_InputData_Error()
		end
	else
		LiMul_InputData_Error()
	end

	-- Input Data WRet[2] << Value
	local SourceN = {}
	local SourceV = {}
	local SourceC = {}
	if SourceArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X",FLMulIndex,0x19C,1,0);
				SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X",FLMulIndex,0x1BC,1,0);
				SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Source[1],Source[2],Source[3]);
			},
			flag = {Preserved}
		}
	elseif SourceArr == "WA" then
		MovW(PlayerID,{{"X",FLMulIndex,0x19C,0},{"X",FLMulIndex,0x1BC,0}},Source)
	else
		for i = 1, 2 do
			if type(SourceArr[i]) == "number" then
				table.insert(SourceN,SetCtrig1X("X",FLMulIndex,0x19C+0x20*(i-1),0,SetTo,Source[i]))
			elseif SourceArr[i] == "V" then
				table.insert(SourceV,SetCtrigX(Source[i][1],Source[i][2],0x158,Source[i][3],SetTo,"X",FLMulIndex,0x19C+0x20*(i-1),1,0))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x148,Source[i][3],SetTo,0xFFFFFFFF))
				table.insert(SourceV,SetCtrig1X(Source[i][1],Source[i][2],0x160,Source[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(SourceC,Source[i])
			elseif SourceArr[i] == "VA" then
				MovX(PlayerID,{"X",FLMulIndex,0x19C+0x20*(i-1),0},Source[i])
			end
		end
		if #SourceC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
					},
					flag = {Preserved}
				}
		elseif #SourceC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways(SourceC[1][1],SourceC[1][2],SourceC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #SourceC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						SourceN,
						SourceV,
						CallLabelAlways2(SourceC[1][1],SourceC[1][2],SourceC[1][3],SourceC[2][1],SourceC[2][2],SourceC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Input Data WRet[2] << Value
	local OperandN = {}
	local OperandV = {}
	local OperandC = {}
	if OperandArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX(Operand[1],Operand[2],0x198,Operand[3],SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x188,Operand[3],SetTo,0xFFFFFFFF);
				SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X(Operand[1],Operand[2],0x1A0,Operand[3],SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways(Operand[1],Operand[2],Operand[3]);
			},
			flag = {Preserved}
		}
	elseif OperandArr == "WA" then
		MovW(PlayerID,{"X",WRet[2],0,"W"},Operand)
	else
		for i = 1, 2 do
			if type(OperandArr[i]) == "number" then
				table.insert(OperandN,SetCtrig1X("X",WRet[2],0x15C+0x40*(i-1),0,SetTo,Operand[i]))
			elseif OperandArr[i] == "V" then
				table.insert(OperandV,SetCtrigX(Operand[i][1],Operand[i][2],0x158,Operand[i][3],SetTo,"X",WRet[2],0x15C+0x40*(i-1),1,0))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x148,Operand[i][3],SetTo,0xFFFFFFFF))
				table.insert(OperandV,SetCtrig1X(Operand[i][1],Operand[i][2],0x160,Operand[i][3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(OperandC,Operand[i])
			elseif OperandArr[i] == "VA" then
				MovX(PlayerID,{"X",WRet[2],0x15C+0x40*(i-1),0},Operand[i])
			end
		end
		if #OperandC == 0 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
					},
					flag = {Preserved}
				}
		elseif #OperandC == 1 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways(OperandC[1][1],OperandC[1][2],OperandC[1][3]);
					},
					flag = {Preserved}
				}
		elseif #OperandC == 2 then
			Trigger {
					players = {PlayerID},
					conditions = {Label(0);},
					actions = {
						OperandN,
						OperandV,
						CallLabelAlways2(OperandC[1][1],OperandC[1][2],OperandC[1][3],OperandC[2][1],OperandC[2][2],OperandC[2][3]);
					},
					flag = {Preserved}
				}
		end
	end

	-- Call f_LiMul
	Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLiMulCall1,0x0,0,0);
					SetCtrigX("X",FLiMulCall2,0x4,0,SetTo,"X","X",0x0,0,1);
					SetCtrigX("X",FLMulCall2,0x4,0,SetTo,"X",FLMulCall2,0x0,0,1);
				},
				flag = {Preserved}
			}
	if FLiMulCall1 == 0 then
		Need_Include_64BitLibrary()
	end
	FLMulCheck = 1
	-- Output Data WRet[2] = Output
	
	if DestArr == "W" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[2],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
	elseif DestArr == "WA" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_V" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "LA_W" then
		MovW(PlayerID,Dest,{"X",WRet[2],0,"W"},SetTo,Mask)
	elseif DestArr == "Cp" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x158,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x198,0,SetTo,13);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,Mask[1]);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,Mask[2]);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x0,0x2);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetMemory(0x6509B0,Subtract,1);
				SetCtrig1X("X",WRet[2],0x184,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	else
		MovY(PlayerID,Dest,{"X",WRet[2],0,"W"},DestArr,Mask)
	end
end

FLReadCall1 = 0
FLReadCall2 = 0
FLReadCheck = 0
FLReadXCall = {}
FLReadXCheck = 0
FLReadXAlloc = 0
FLAddCall1 = 0
FLAddCall2 = 0
FLSubCall1 = 0
FLSubIndex = 0
FLSubCall2 = 0
FLNegCall1 = 0
FLNegCall2 = 0
FLiSubCall1 = 0
FLiSubCall2 = 0
FLAbsCall1 = 0
FLAbsCall2 = 0
FLRandCall1 = 0
FLRandCall2 = 0
FLRandCheck = 0
FLRandSwitch = 0
FLlShiftCall1 = 0
FLlShiftCall2 = 0
FLMulCall1 = 0
FLMulCall2 = 0
FLiMulCall1 = 0
FLiMulCall2 = 0
FLMulCheck = 0
FLMulAlloc = 0
FLAndCall1 = 0
FLAndCall2 = 0
FLOrCall1 = 0
FLOrCall2 = 0
FLNotCall1 = 0
FLNotCall2 = 0
FLXorCall1 = 0
FLXorCall2 = 0
FLDIVCall1 = 0
FLDIVCall2 = 0
FLiDIVCall1 = 0
FLiDIVCall2 = 0
FLMODCall1 = 0
FLMODCall2 = 0
FLiMODCall1 = 0
FLiMODCall2 = 0
FLDivCheck = 0
FLDivAlloc = 0
function Include_64BitLibrary(SeedSwitch) -- f_LRead / f_LReadX / f_LAdd / f_LSub / f_LNeg / f_LiSub / f_LAbs / f_LRand / f_LlShift / f_LMul / f_LiMul
	if CheckInclude_64BitLibrary == 0 then
		CheckInclude_64BitLibrary = 1
	local IncludePlayer = IncludePlayerID

	if SeedSwitch == "X" or SeedSwitch == nil then
		Need_SeedSwitch_Error()
	end
--------------------- f_LiDiv-------------------------------------------------------
	FLDivAlloc = FuncAlloc
	FLIDIVCall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1
--------------------- f_LiMod-------------------------------------------------------
	FLIMODCall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1
--------------------- f_LDiv-------------------------------------------------------
	FLDIVCall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1
--------------------- f_Mod-------------------------------------------------------
	FLMODCall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1
-------------------------------------------------------------------------------------------------------
		FuncAlloc = FuncAlloc + 1

		FuncAlloc = FuncAlloc + 1

	FuncAlloc = FuncAlloc + 1
		
	FuncAlloc = FuncAlloc + 1
	--------------------- f_LMod End-------------------------------------------------------
	FLMODCall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1
--------------------- f_LDiv End-------------------------------------------------------
	FLDIVCall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

--------------------- f_LiMod End-------------------------------------------------------
	FuncAlloc = FuncAlloc + 1


	FLIMODCall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

--------------------- f_LiDiv End-------------------------------------------------------
	FuncAlloc = FuncAlloc + 1


	FLIDIVCall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1
------------------------------------------------------------------------------------------

-- f_Xor - WRet[2] : X, WRet[3] : Y / WRet[2] = Output = X ^ Y
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[1],0x15C,1,0);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[1],0x19C,1,0);

				SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",WRet[4],0x148,1,0);
				SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",WRet[4],0x188,1,0);
				SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);

				SetCtrig1X("X",WRet[4],0x15C,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[4],0x19C,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[4],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX("X",WRet[4],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX("X",WRet[4],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);

				CallLabelAlways3("X",WRet[2],0,"X",WRet[3],0,"X",WRet[4],0);
			},
			flag = {Preserved}
		}
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[4],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[4],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",WRet[4],0x148,1,0);
				SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",WRet[4],0x188,1,0);
				SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x160,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);

				SetCtrig1X("X",WRet[4],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[4],0x19C,0,SetTo,0);
				SetCtrig1X("X",WRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[4],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX("X",WRet[4],0x158,0,SetTo,"X",WRet[1],0x15C,1,0);
				SetCtrigX("X",WRet[4],0x198,0,SetTo,"X",WRet[1],0x19C,1,0);

				SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrigX("X",WRet[1],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);

				CallLabelAlways3("X",WRet[3],0,"X",WRet[4],0,"X",WRet[1],0);
			},
			flag = {Preserved}
		}
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			flag = {Preserved}
		}

	FLXorCall1 = FuncAlloc
	FLXorCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_LNot - WRet[2] : X / WRet[1] = Output = ~X
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0xFFFFFFFF);

				SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[1],0x15C,1,0);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[1],0x19C,1,0);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			flag = {Preserved}
		}

	FLNotCall1 = FuncAlloc
	FLNotCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_LOr - WRet[2] : X, WRet[3] : Y / WRet[2] = Output = X | Y
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",WRet[1],0x148,1,0);
				SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",WRet[1],0x188,1,0);
				SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);

				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX("X",WRet[1],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
				CallLabelAlways2("X",WRet[3],0,"X",WRet[1],0);
			},
			flag = {Preserved}
		}
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			flag = {Preserved}
		}

	FLOrCall1 = FuncAlloc
	FLOrCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_LAnd - WRet[2] : X, WRet[3] : Y / WRet[2] = Output = X & Y
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",WRet[1],0x148,1,0);
				SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",WRet[1],0x188,1,0);
				SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x160,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);

				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrigX("X",WRet[1],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
				CallLabelAlways2("X",WRet[3],0,"X",WRet[1],0);
			},
			flag = {Preserved}
		}
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			flag = {Preserved}
		}

	FLAndCall1 = FuncAlloc
	FLAndCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_LMul / f_LiMul - FuncAlloc+2 : X, WRet[3] : Y / WRet[1] = Output 
	FLMulAlloc = FuncAlloc
	
FLMulCall1 = FuncAlloc
FLMulCall2 = FuncAlloc+1
FLMulIndex = FuncAlloc+2
FLiMulCall1 = FuncAlloc+4
FLiMulCall2 = FuncAlloc+5
FuncAlloc = FuncAlloc + 6

-- f_LlShift - WRet[2] : X, CRet[1] : Loop / WRet[2] = Output (WRet[2]<<=CRet[1])

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
				CtrigX("X",CRet[1],0x15C,0,Exactly,0,0x3F);
			},
			actions = {
				SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc+1,0,0,0);
			},
			flag = {Preserved}
		}

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",WRet[2],0x1B8,0,SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X("X",WRet[2],0x1BC,0,SetTo,1);
				SetCtrig1X("X",WRet[2],0x1A8,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x1C0,0,SetTo,Add*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1C4,0,SetTo,0x2,0x2);

				SetCtrigX("X",FuncAlloc+2,0x4,1,SetTo,"X",WRet[2],0,0,0);
				SetCtrigX("X",WRet[2],0x4,0,SetTo,"X",FuncAlloc+2,0,0,0);
				SetCtrigX("X",FuncAlloc+2,0x4,0,SetTo,"X",FuncAlloc+2,0,0,1);

				SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,Add*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,Add*16777216,0xFF000000);

				SetCtrigX("X",FuncAlloc+2,0x158+0x20*1,0,SetTo,"X",FuncAlloc+2,0x1A4+0x20*1,1,0); -- Reset Timer
				SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",FuncAlloc+2,0x158+0x20*1,1,0);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",FuncAlloc+2,0x1A4+0x20*1,0,SetTo,0x2,0x2); -- Reset Flag

				SetCtrig1X("X",CRet[1],0x15C,0,Subtract,1);
				SetCtrigX("X","X",0x4,0,SetTo,"X",CRet[1],0,0,0);
				SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc+2,0,0,1);
			},
			flag = {Preserved}
		}



	Trigger {
		players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+2);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x1C4,0,SetTo,0x2,0x2);
				SetCtrig1X("X","X",0x1A4+0x20*1,0,SetTo,0x0,0x2); -- Timer Action
				SetCtrig1X("X","X",0x158+0x20*1,0,Subtract,1); -- Run Tick
				Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+1,0,0,0)); -- Exit Action
				},
				flag = {Preserved}
			}
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CtrigX("X",WRet[2],0x15C,0,AtLeast,0x80000000);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x1C4,0,SetTo,0x0,0x2);
			},
			flag = {Preserved}
		}



	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
				SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0,0,1);
				SetCtrig1X("X",WRet[2],0x1C0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1C4,0,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
	
	FLlShiftCall1 = FuncAlloc
	FLlShiftCall2 = FuncAlloc+1
	FLlShiftIndex = FuncAlloc+2
	FuncAlloc = FuncAlloc + 3
-- f_LRand - WRet[1] = Output
	FLRandSwitch = SeedSwitch
	FLRandCall1 = FuncAlloc
	FLRandCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_LAbs - WRet[2] : X / WRet[1] = Output (WRet[1]=|WRet[2]|)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
				CtrigX("X",WRet[2],0x19C,0,AtMost,0x7FFFFFFF);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",WRet[2],0x0,0,0);
				SetCtrigX("X",WRet[2],0x4,0,SetTo,"X",FuncAlloc+1,0x0,0,0);
				SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[1],0x15C,1,0);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[1],0x19C,1,0);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x15C,0,Add,-1);
			},
			flag = {Preserved}
		}	

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0xFFFFFFFF);
				SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[1],0x15C,1,0);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[1],0x19C,1,0);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CtrigX("X",WRet[1],0x15C,0,Exactly,0xFFFFFFFF);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x19C,0,Add,1);
			},
			flag = {Preserved}
		}	
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,Add,1);
				SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,1);
			},
			flag = {Preserved}
		}

	FLAbsCall1 = FuncAlloc
	FLAbsCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2


-- f_LiSub - WRet[2] : X, WRet[3] : Y & Switch / WRet[1] = Output (WRet[1]=WRet[2]-WRet[3])
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0xFFFFFFFF);
				SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",WRet[1],0x15C,1,0);
				SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",WRet[1],0x19C,1,0);
				SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x160,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
				CallLabelAlways("X",WRet[3],0);
			},
			flag = {Preserved}
		}

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CtrigX("X",WRet[1],0x15C,0,Exactly,0xFFFFFFFF);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x19C,0,Add,1);
			},
			flag = {Preserved}
		}	

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,Add,1);
				SetCtrigX("X",WRet[1],0x158,0,SetTo,"X","X",0x24,1,1);
				SetCtrig1X("X",WRet[1],0x198,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x19C,0,Add,1); -- Carry 가불
				SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[1],0x15C,1,0);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[1],0x19C,1,0);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,Add*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,Add*16777216,0xFF000000);
				CallLabelAlways2("X",WRet[1],0,"X",WRet[2],0);
			},
			flag = {Preserved}
		}
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
				CtrigX("X",WRet[1],0x15C,0,AtLeast,0); -- X2 >= X2(전) : X1 -= 1 (No Carry)
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x19C,0,Add,-1);
			},
			flag = {Preserved}
		}
	FLiSubCall1 = FuncAlloc
	FLiSubCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_LNeg - WRet[2] : X / WRet[1] = Output (WRet[1]=-WRet[2])
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0xFFFFFFFF);
				SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[1],0x15C,1,0);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[1],0x19C,1,0);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CtrigX("X",WRet[1],0x15C,0,Exactly,0xFFFFFFFF);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x19C,0,Add,1);
			},
			flag = {Preserved}
		}	

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,Add,1);
			},
			flag = {Preserved}
		}

	FLNegCall1 = FuncAlloc
	FLNegCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_LSub - WRet[2] : X, WRet[3] : Y, CRet[1] : Temp / WRet[2] = Output (WRet[2]-=WRet[3])

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FuncAlloc+3,0x24,1,0);
				SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FuncAlloc+4,0x24,1,0);
				SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",WRet[3],0);

				SetCtrigX("X",FuncAlloc+3,0x4,0,SetTo,"X",FuncAlloc+7,0,0,0); -- NifX Next 복구
				SetCtrigX("X",FuncAlloc+4,0x4,0,SetTo,"X",FuncAlloc+5,0,0,0); -- NifX Next 복구
				SetCtrigX("X",FuncAlloc+1,0x4,0,SetTo,"X",FuncAlloc+1,0,0,1); -- NifX Next 복구
			},
			flag = {Preserved}
		}
	Trigger { -- NIfX
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc+3);
			CtrigX("X",WRet[2],0x19C,0,AtLeast,0); -- A >= C
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1);
		},
		flag = {Preserved}
	}
		Trigger { -- NIfX
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+4);
				CtrigX("X",WRet[2],0x15C,0,AtLeast,0); -- B >= D
			},
			actions = {
				SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x160,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrigX("X","X",0x4,0,SetTo,"X",WRet[3],0x0,0,0);
				SetCtrigX("X",WRet[3],0x4,0,SetTo,"X",FuncAlloc+2,0x0,0,0);
			},
			flag = {Preserved}
		}

		Trigger { -- NElseX
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+5);
			},
			actions = {
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
				SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
				SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x160,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
				CallLabelAlways("X",WRet[3],0);
			},
			flag = {Preserved}
		}
			Trigger {
				players = {IncludePlayer},
				conditions = {Label(FuncAlloc+1);CtrigX("X",WRet[2],0x19C,0,Exactly,0)},
				actions = {
					SetCtrig1X("X",WRet[2],0x19C,0,SetTo,0);
					SetCtrig1X("X",WRet[2],0x15C,0,SetTo,0);
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc+2,0x0,0,0);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {Label(FuncAlloc+6);},
				actions = {
					SetCtrig1X("X",WRet[2],0x19C,0,Subtract,1);
					SetCtrig1X("X",WRet[2],0x15C,0,Add,1);
					SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
					SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
					SetCtrigX("X","X",0x4,0,SetTo,"X",CRet[1],0x0,0,0);
					SetCtrigX("X",CRet[1],0x4,0,SetTo,"X",FuncAlloc+2,0x0,0,0);
				},
				flag = {Preserved}
			}
	Trigger { -- NElseX
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc+7);
		},
		actions = {
			SetCtrig1X("X",WRet[2],0x19C,0,SetTo,0);
			SetCtrig1X("X",WRet[2],0x15C,0,SetTo,0);
		},
		flag = {Preserved}
	}
	Trigger {
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc+2);
		},
		flag = {Preserved}
	}

	FLSubCall1 = FuncAlloc
	FLSubIndex = FuncAlloc+1
	FLSubCall2 = FuncAlloc+2
	FLSubNIFX1 = FuncAlloc+3
	FLSubNIFX2 = FuncAlloc+4
	FLSubNIFX3 = FuncAlloc+5
	FLSubNIFX4 = FuncAlloc+6
	FLSubNIFX5 = FuncAlloc+7
	FuncAlloc = FuncAlloc + 8

-- f_LAdd - WRet[2] : X, WRet[3] : Y, WRet[1] : Switch / WRet[2] = Output (WRet[2]+=WRet[3])
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc);
			},
			actions = {
				SetCtrigX("X",WRet[2],0x158,0,SetTo,"X","X",0x24,1,1);
				SetCtrig1X("X",WRet[2],0x198,0,SetTo,0);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x19C,0,Add,1); -- Carry 가불
				SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x160,0,SetTo,Add*16777216,0xFF000000);
				SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,Add*16777216,0xFF000000);
				CallLabelAlways2("X",WRet[2],0,"X",WRet[3],0);
			},
			flag = {Preserved}
		}
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FuncAlloc+1);
				CtrigX("X",WRet[2],0x15C,0,AtLeast,0); -- X2 >= X2(전) : X1 -= 1 (No Carry)
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x19C,0,Add,-1);
			},
			flag = {Preserved}
		}

	FLAddCall1 = FuncAlloc
	FLAddCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2

-- f_LRead - Ret[1] : Input[1] (Lower), Ret[2] : Input[2] (Upper) / WRet[1] = Output

	FLReadCall1 = FuncAlloc
	FLReadCall2 = FuncAlloc+1
	FuncAlloc = FuncAlloc + 2
-- f_LReadX - Ret[1] : Input[1] (Lower), Ret[2] : Input[2] (Upper) / WRet[1] = Output
-- +0 
	FLReadXAlloc = FuncAlloc
	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2

-- +1 (x256)

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2

-- +2 (x65536)

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2

-- +3 (x16777216)

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2
-- +4 (x4294967296)

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2

-- +5 (x1099511627776)

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2

-- +6 (x281474976710656)

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2
-- +7 (x72057594037927936)

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2
-- -1 (/256)

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2

	-- -2 (/65536)

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2
-- -3 (/16777216)

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2

-- -4 (/4294967296)

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2

-- -5 (/1099511627776)

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2
-- -6 (/281474976710656)

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2
-- -7 (/72057594037927936)

	table.insert(FLReadXCall,FuncAlloc)
	table.insert(FLReadXCall,FuncAlloc+1)
	FuncAlloc = FuncAlloc + 2
end
end
------------------------------------------------------------------------------------------------------

--[[ 이걸 열어본 사람에게 주는 선물.txt
Trigger { -- 값 대입 TRIG
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			SetCtrigX(V[1],V[2],0x158,V[3],SetTo,"X","X",0x15C+0x20*0,1,1); 
			SetCtrigX(V[1],V[2],0x148,V[3],SetTo,Mask); 
			SetCtrigX(V[1],V[2],0x160,V[3],SetTo,SetTo*16777216,0xFF000000);
			CallLabelAlways(V[1],V[2],V[3]);
			},
			flag = {Preserved}
		}
Trigger { -- 값 증식 TRIG
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			SetCtrig1X("X","X",0x15C+0x20*1,0,SetTo,0); -- 1st Action
			SetCtrig1X("X","X",0x15C+0x20*2,0,SetTo,0); -- 2nd Action
			SetCtrig1X("X","X",0x15C+0x20*3,0,SetTo,0); -- 3rd Action
			SetCtrig1X("X","X",0x15C+0x20*4,0,SetTo,0); -- 4th Action
			SetCtrig1X("X","X",0x15C+0x20*5,0,SetTo,0); -- 5th Action
			SetCtrig1X("X","X",0x15C+0x20*6,0,SetTo,0); -- 6th Action
			SetCtrig1X("X","X",0x15C+0x20*7,0,SetTo,0); -- 7th Action
			SetMemory(0,SetTo,0); -- 8th Action
			},
			flag = {Preserved}
		}

Trigger { --  Switch Actions for SLoopN 
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			Action, -- Switch Action (Default = On)
			SetCtrig1X("X","X",0x164+0x20*Line,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
			
			Disabled(Action), -- Switch Action (Default = Off)
			SetCtrig1X("X","X",0x164+0x20*Line,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)

			Action, -- Switch Action (Default = On)
			Disabled(Action), -- Switch Action (Default = Off)
			SetCtrig1X("X","X",0x164+0x20*Line,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)
			SetCtrig1X("X","X",0x184+0x20*Line,0,Add,0x2,0x2); -- Run Switch (0x0↔0x2)

			------------------------------------------------------------------------
			},
			flag = {Preserved}
		}


function _SLoop(PlayerID,Repeat,Conditions,Actions,EndActions) -- 초소형 반복문 2TRIG 버젼
	if Repeat >= 63 or Repeat <= 0 then
		_SLoop_InputError()
	end

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
			Conditions, -- 루프 도중 조건 불만족시 무한 루프 발생 (루프 시작 조건으로만 사용)
		},
		actions = {
			SetCtrig1X("X","X",0x184+0x20*Repeat,0,SetTo,0x0,0x2); -- Timer Action
			SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,0); -- Make Loop Action A->A
			Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1)); -- Exit Action
			SetCtrig1X("X","X",0x158,0,Subtract,8); -- Run Tick
			Actions, -- Wait 금지
			},
			flag = {Preserved}
		}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
			SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+1,0x0,0,1); -- Reset Next
			SetCtrigX("X",IndexAlloc,0x158,0,SetTo,"X",IndexAlloc,0x184+0x20*Repeat,1,0); -- Reset Timer
			SetCtrig1X("X",IndexAlloc,0x1A4,0,SetTo,0x2,0x2); -- Reset Flag
			EndActions,
			},
			flag = {Preserved}
		}

	PlayerID = PlayerConvert(PlayerID)
	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+1,0x0,0,1))
	end
	IndexAlloc = IndexAlloc + 0x2
end

function SLoop(PlayerID,Repeat,Conditions,Actions,InitActions,EndActions) -- 초소형 반복문 (변수 삽입가능)
	if type(Repeat) == "number" then
		if Repeat >= 64 or Repeat <= 0 then
			SLoop_InputError()
		end
		Trigger {
			players = {PlayerID},
				conditions = {
					Label(IndexAlloc);
					Conditions,
				},
				actions = {
					SetCtrigX("X",IndexAlloc+1,0x4,0,SetTo,"X",IndexAlloc+1,0,0,0); -- Make Loop Action A->A
					SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+1,0x0,0,0); -- Connect Next
					InitActions,
				},
				flag = {Preserved}
			}
		Trigger {
			players = {PlayerID},
				conditions = {
					Label(IndexAlloc+1);
				},
				actions = {
					SetCtrig1X("X","X",0x164+0x20*Repeat,0,SetTo,0x0,0x2); -- Timer Action
					Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1)); -- Exit Action
					SetCtrig1X("X","X",0x158,0,Subtract,8); -- Run Tick
					Actions, -- Wait 금지
					},
					flag = {Preserved}
				}
		Trigger {
			players = {PlayerID},
				conditions = {
					Label(IndexAlloc+2);
				},
				actions = {
					SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1); -- Reset Next
					SetCtrigX("X",IndexAlloc+1,0x158,0,SetTo,"X",IndexAlloc+1,0x164+0x20*Repeat,1,0); -- Reset Timer
					SetCtrig1X("X",IndexAlloc+1,0x184,0,SetTo,0x2,0x2); -- Reset Flag
					EndActions,
					},
					flag = {Preserved}
				}

		PlayerID = PlayerConvert(PlayerID)
		for k, P in pairs(PlayerID) do
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1))
		end
		IndexAlloc = IndexAlloc + 0x3
	else
		if Repeat[4] ~= "V" then
			SLoop_InputError()
		end
		local Deviation = Repeat[5]
		if Repeat[5] == "X" or Repeat[5] == nil then
			Deviation = 0
		end
		local min, max
		if Deviation >= 1 then
			min = 0
		else
			min = 1-Deviation
		end
		if Deviation >= 63 then
			max = 0
		else
			max = 63-Deviation
		end
		STPopTrigArr(PlayerID)

		Trigger {
			players = {PlayerID},
				conditions = {
					Label(IndexAlloc);
					NVar(Repeat,AtLeast,min*8,0xFFFFFFF8);
					NVar(Repeat,AtMost,max*8,0xFFFFFFF8);
					Conditions,
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,Repeat[1],Repeat[2],0,0,Repeat[3]);  -- Connect Next
					SetCtrigX(Repeat[1],Repeat[2],0x4,Repeat[3],SetTo,"X",IndexAlloc+1,0,0,0); -- Connect Next
					SetCtrigX("X",IndexAlloc+1,0x4,0,SetTo,"X",IndexAlloc+1,0,0,0); -- Make Loop Action A->A
					SetCtrigX(Repeat[1],Repeat[2],0x158,Repeat[3],SetTo,"X",IndexAlloc+1,0x158,1,0);
					SetCtrig1X(Repeat[1],Repeat[2],0x160,Repeat[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Repeat[1],Repeat[2],0x148,Repeat[3],SetTo,0xFFFFFFF8);
					SetCtrigX("X",IndexAlloc+1,0x158,0,SetTo,"X",IndexAlloc+1,0x164+0x20*Deviation,1,0); -- Reset Timer
					InitActions,
				},
				flag = {Preserved}
			}
		Trigger {
			players = {PlayerID},
				conditions = {
					Label(IndexAlloc+1);
				},
				actions = {
					SetDeathsX(0,SetTo,0x0,0,0x2); -- Timer Action
					Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1)); -- Exit Action
					SetCtrig1X("X","X",0x158,0,Subtract,8); -- Run Tick
					Actions, -- Wait 금지
					},
					flag = {Preserved}
				}
		Trigger {
			players = {PlayerID},
				conditions = {
					Label(IndexAlloc+2);
				},
				actions = {
					SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1); -- Reset Next
					SetCtrig1X("X",IndexAlloc+1,0x184,0,SetTo,0x2,0x2); -- Reset Flag
					EndActions,
					},
					flag = {Preserved}
				}

		PlayerID = PlayerConvert(PlayerID)
		for k, P in pairs(PlayerID) do
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1))
		end
		IndexAlloc = IndexAlloc + 0x3
	end
end

function SLoopX(PlayerID,Repeat,Conditions,Actions,InitActions,EndActions) -- 초소형 반복문 Another (Max 489)
	local StartLine = #Actions
	local RepeatMax = 1+(61-#Actions)*8
	if Repeat > RepeatMax or Repeat <= 0 then
		SLoopX_InputError()
	end

	Trigger {
		players = {PlayerID},
			conditions = {
				Label(IndexAlloc);
				Conditions,
			},
			actions = {
				SetCtrigX("X",IndexAlloc+1,0x4,0,SetTo,"X",IndexAlloc+1,0,0,0); -- Make Loop Action A->A
				SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+1,0x0,0,0); -- Connect Next
				InitActions,
			},
			flag = {Preserved}
		}
	Trigger {
		players = {PlayerID},
			conditions = {
				Label(IndexAlloc+1);
			},
			actions = {
				Actions, -- Wait 금지
				SetCtrig1X("X","X",0x1A0+0x20*StartLine+0x4*Repeat,0,SetTo,0x0,0x2); -- Timer Action
				SetCtrig1X("X","X",0x158+0x20*StartLine,0,Subtract,1); -- Run Tick
				Disabled(SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1)); -- Exit Action
				},
				flag = {Preserved}
			}
	Trigger {
		players = {PlayerID},
			conditions = {
				Label(IndexAlloc+2);
			},
			actions = {
				SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1); -- Reset Next
				SetCtrigX("X",IndexAlloc+1,0x158+0x20*StartLine,0,SetTo,"X",IndexAlloc+1,0x1A0+0x20*StartLine+0x4*Repeat,1,0); -- Reset Timer
				SetCtrig1X("X",IndexAlloc+1,0x1A4+0x20*StartLine,0,SetTo,0x2,0x2); -- Reset Flag
				EndActions,
				},
				flag = {Preserved}
			}

	PlayerID = PlayerConvert(PlayerID)
	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1))
	end
	IndexAlloc = IndexAlloc + 0x3
end

]]--

function SCopy(PlayerID,SVData,DestLine,SourceLine) -- 증식
	STPopTrigArr(PlayerID)

	local PDestS
	if SVData[4] == "SVA" then --{"X",Temp,0,"SVA",{"X",Index,0,"SA",Number,Size,Line},0,"X",Temp+1,0},
		PDestS = SVData
		SVData = {"X",SRet[SVData[5][5]][4],0,"SV",SVData[5][5]}
		MovS(PlayerID,SVData,PDestS)
	end

	local Box = {}
	local Box2 = {}
	if SVData[4] == "SV" then
		local CloseLine = {}
		for i = 1, SVData[5] do
			table.insert(CloseLine,i)
		end

		if type(SourceLine) == "number" then
			table.insert(Box,SetCtrigX(SVData[1],SVData[2],0x158+0x40*(SourceLine-1),SVData[3],SetTo,SVData[1],SVData[2],0x15C+0x40*(DestLine[1]-1),1,SVData[3]))
			table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x164+0x40*(SourceLine-1),SVData[3],SetTo,0x0,0x2))
			table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x160+0x40*(SourceLine-1),SVData[3],SetTo,SetTo*16777216,0xFF000000))
			table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x148+0x40*(SourceLine-1),SVData[3],SetTo,0xFFFFFFFF))
			CloseLine[SourceLine] = 0
			for i = 1, #DestLine do
				if i == #DestLine then
					table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x158+0x40*(DestLine[i]-1),SVData[3],SetTo,0))
				else
					table.insert(Box,SetCtrigX(SVData[1],SVData[2],0x158+0x40*(DestLine[i]-1),SVData[3],SetTo,SVData[1],SVData[2],0x15C+0x40*(DestLine[i+1]-1),1,SVData[3]))
				end
				table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x164+0x40*(DestLine[i]-1),SVData[3],SetTo,0x0,0x2))
				table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x160+0x40*(DestLine[i]-1),SVData[3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x148+0x40*(DestLine[i]-1),SVData[3],SetTo,0xFFFFFFFF))
				CloseLine[DestLine[i]] = 0
			end
		else
			for k, v in pairs(SourceLine) do
				table.insert(Box,SetCtrigX(SVData[1],SVData[2],0x158+0x40*(v-1),SVData[3],SetTo,SVData[1],SVData[2],0x15C+0x40*(DestLine[k][1]-1),1,SVData[3]))
				table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x164+0x40*(v-1),SVData[3],SetTo,0x0,0x2))
				table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x160+0x40*(v-1),SVData[3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x148+0x40*(v-1),SVData[3],SetTo,0xFFFFFFFF))
				CloseLine[v] = 0
				for i = 1, #DestLine[k] do
					if i == #DestLine[k] then
						table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x158+0x40*(DestLine[k][i]-1),SVData[3],SetTo,0))
					else
						table.insert(Box,SetCtrigX(SVData[1],SVData[2],0x158+0x40*(DestLine[k][i]-1),SVData[3],SetTo,SVData[1],SVData[2],0x15C+0x40*(DestLine[k][i+1]-1),1,SVData[3]))
					end
					table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x164+0x40*(DestLine[k][i]-1),SVData[3],SetTo,0x0,0x2))
					table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x160+0x40*(DestLine[k][i]-1),SVData[3],SetTo,SetTo*16777216,0xFF000000))
					table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x148+0x40*(DestLine[k][i]-1),SVData[3],SetTo,0xFFFFFFFF))
					CloseLine[DestLine[k][i]] = 0
				end
			end
		end

		for k, v in pairs(CloseLine) do
			if v ~= 0 then
				table.insert(Box,SetCtrig1X(SVData[1],SVData[2],0x164+0x40*(v-1),SVData[3],SetTo,0x2,0x2))
				table.insert(Box2,SetCtrig1X(SVData[1],SVData[2],0x164+0x40*(v-1),SVData[3],SetTo,0x0,0x2))
			end
		end

		if #Box == 62 then
			table.insert(Box,PreserveTrigger())
		end
		DoActions2X(PlayerID,Box)
		Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						CallLabelAlways(SVData[1],SVData[2],SVData[3]);
					},
					flag = {Preserved}
				}
		DoActions2X(PlayerID,Box2)
	end

	if PDestS ~= nil then
		MovS(PlayerID,PDestS,SVData)
	end
end


function SCast(PlayerID,Dest,Source,Deviation,Mask,Clear) -- V ↔ SV Type Casting
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end
	if Deviation == "X" then
		Deviation = nil
	end
	if Deviation == nil then
		Deviation = 0
	end
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end

	local Mask2 = Mask
	if Clear == 1 then
		Mask2 = 0xFFFFFFFF
	end

	
 	--[[
 	SA → V
 	SA → VA
 	SVA → V
 	SvA → VA
 	V → SV
 	VA → SV
 	V → SVA
 	VA → SVA
 	]]-- {Player,SVariable[2],Next,"SV",SVariable[3],Line}
	if Source[4] == "SV" then -- SV -> V
		local Line = Source[6]
		local Number = Source[5] 
		local Distance = 0x40*(Line-1)
		local Box = {}
		local Box2 = {}
		for i = 1, Number do
			if i ~= Line then
				table.insert(Box,SetCtrig1X(Source[1],Source[2],0x164+0x40*(i-1),Source[3],SetTo,0x2,0x2))
				table.insert(Box2,SetCtrig1X(Source[1],Source[2],0x164+0x40*(i-1),Source[3],SetTo,0x0,0x2))
			else
				table.insert(Box,SetCtrig1X(Source[1],Source[2],0x164+0x40*(i-1),Source[3],SetTo,0x0,0x2))
			end
		end
		if Dest[4] == "V" then 
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						Box,
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2);
						SetCtrig1X(Source[1],Source[2],0x148+Distance,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160+Distance,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158+Distance,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						Box2,
					},
					flag = {Preserved}
				}
		elseif Dest[4] == "VA" then -- SV -> VA
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						Box,
						SetCtrigX(Source[1],Source[2],0x158+Distance,Source[3],SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
						SetCtrig1X(Source[1],Source[2],0x158+Distance,Source[3],Add,Dest[6]);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158+Distance,1,Source[3]);
						SetCtrig1X(Source[1],Source[2],0x148+Distance,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160+Distance,Source[3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x15C+Distance,Source[3],Add,Deviation);
						CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						Box2,
						SetCtrig1X(Source[1],Source[2],0x15C+Distance,Source[3],Add,-Deviation); 
					},
					flag = {Preserved}
				}
		else
			SCast_InputData_Error()
		end
	elseif Source[4] == "SVA" then -- SVA -> V
		local Line = Source[5][7]
		local Number = Source[5][5] 
		local Distance = 0x40*(Line-1)
		local Box = {}
		local Box2 = {}
		for i = 1, Number do
			if i ~= Line then
				table.insert(Box,SetDeathsX(CurrentPlayer,SetTo,0x2,0,0x2))
				table.insert(Box,SetMemory(0x6509B0,Add,(0x40)/4))

				table.insert(Box2,SetDeathsX(CurrentPlayer,SetTo,0x0,0,0x2))
				table.insert(Box2,SetMemory(0x6509B0,Add,(0x40)/4))
			else
				table.insert(Box,SetDeathsX(CurrentPlayer,SetTo,0x0,0,0x2))
				table.insert(Box,SetMemory(0x6509B0,Add,(0x40)/4))

				table.insert(Box2,SetMemory(0x6509B0,Add,(0x40)/4))
			end
		end
		if Dest[4] == "V" then -- {"X",Temp,0,"SVA",{"X",Index,0,"SA",Number,Size,Line},0,"X",Temp+1,0},
				Trigger {--(CPRead)로 값 출력
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2);
							SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
							SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
							SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
							SetMemory(0x6509B0,Add,Source[6]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
							SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
							CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
						},
						flag = {Preserved}
					}

				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x4,1,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
							SetMemory(0x6509B0,Add,(0x4-0x0)/4);
							SetCtrig2X("Cp",SetTo,"X","X",0,0,2); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
							SetMemory(0x6509B0,Add,(0x158-0x4+Distance)/4);		
							SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);					
							SetMemory(0x6509B0,Add,(0x148-0x158)/4);
							SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x160-0x148)/4);
							SetDeathsX(CurrentPlayer,SetTo,Add*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
							SetMemory(0x6509B0,Add,(0x164-0x160-Distance)/4);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Box,
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,Add,(-0x40*Number)/4);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Box2,
						},
						flag = {Preserved}
					}
				RecoverCp(PlayerID)
		elseif Dest[4] == "VA" then -- SVA -> VA
				Trigger {--(CPRead)로 값 출력
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
							SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
							SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
							SetMemory(0x6509B0,Add,Source[6]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 
							SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
							
							SetCtrigX("X","X",0x1DC,1,SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
							SetCtrig1X("X","X",0x1DC,1,Add,Dest[6]);
							SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x1DC,1,1);
							CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1],Dest[2],Dest[3]);
						},
						flag = {Preserved}
					}

				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x4,1,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
							SetMemory(0x6509B0,Add,(0x4-0x0)/4);
							SetCtrig2X("Cp",SetTo,"X","X",0,0,2); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
							SetMemory(0x6509B0,Add,(0x158-0x4+Distance)/4);		
							SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);					
							SetMemory(0x6509B0,Add,(0x148-0x158)/4);
							SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
							SetMemory(0x6509B0,Add,(0x15C-0x148)/4);
							SetDeaths(CurrentPlayer,Add,Deviation,0);
							SetMemory(0x6509B0,Add,(0x160-0x15C)/4);
							SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
							SetMemory(0x6509B0,Add,(0x164-0x160-Distance)/4);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Box,
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,Add,(-0x40*Number)/4);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Box2,
						},
						flag = {Preserved}
					}
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetMemory(0x6509B0,Add,(0x15C-0x164-0x40*Number)/4);
							SetDeaths(CurrentPlayer,Add,-Deviation,0);

						},
						flag = {Preserved}
					}
				RecoverCp(PlayerID)
		else
			SCast_InputData_Error()
		end
	elseif Source[4] == "V" then -- V -> SV
		if Dest[4] == "SV" then 
			local Number = Dest[5] 
			local DestLine = {}
			for i = 2, Number do
				table.insert(DestLine,i)
			end
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			if Number >= 2 then
				SCopy(PlayerID,Dest,DestLine,1)
			end
		elseif Dest[4] == "SVA" then -- V -> SVA 
			local Number = Dest[5][5]
			local DestLine = {}
			for i = 2, Number do
				table.insert(DestLine,i)
			end
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],Add,Dest[6]);
						SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,Deviation);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways2(Dest[1],Dest[2],Dest[3],Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Source[1],Source[2],0x15C,Source[3],Add,-Deviation);
					},
					flag = {Preserved}
				}
			if Number >= 2 then
				SCopy(PlayerID,Dest,DestLine,1)
			end
		else
			SCast_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if Dest[4] == "SV" then -- VA -> SV
			local Number = Dest[5] 
			local DestLine = {}
			for i = 2, Number do
				table.insert(DestLine,i)
			end
			Trigger {--(CPRead)로 값 출력
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Deviation,Mask2);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
						CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
					},
					flag = {Preserved}
				}

			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148)/4);
						SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
					},
					flag = {Preserved}
				}
			RecoverCp(PlayerID)
			if Number >= 2 then
				SCopy(PlayerID,Dest,DestLine,1)
			end
		elseif Dest[4] == "SVA" then -- VA -> SVA 
			local Number = Dest[5][5]
			local DestLine = {}
			for i = 2, Number do
				table.insert(DestLine,i)
			end
			Trigger {--(CPRead)로 값 출력
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
						SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

						SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
						SetMemory(0x6509B0,Add,Source[6]);

						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 

						SetCtrigX("X","X",0x19C,1,SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
						SetCtrig1X("X","X",0x19C,1,Add,Dest[6]);
						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x19C,1,1);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
						CallLabelAlways3(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9],Dest[1],Dest[2],Dest[3]);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
						SetMemory(0x6509B0,Add,(0x158-0x0)/4);
						SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetMemory(0x6509B0,Add,(0x4-0x158)/4);
						SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
						SetMemory(0x6509B0,Add,(0x148-0x4)/4);
						SetDeaths(CurrentPlayer,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
						SetMemory(0x6509B0,Add,(0x160-0x148)/4);
						SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,(0x15C-0x160)/4);
						SetDeaths(CurrentPlayer,Add,Deviation,0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeaths(CurrentPlayer,Add,-Deviation,0);
					},
					flag = {Preserved}
				}

			RecoverCp(PlayerID)
			if Number >= 2 then
				SCopy(PlayerID,Dest,DestLine,1)
			end
		else
			SCast_InputData_Error()
		end
	else
		SCast_InputData_Error()
	end
end

function SMov(PlayerID,Dest,Source,Mode,Deviation,Mask,Clear) -- <<
	STPopTrigArr(PlayerID)
	if Mask == "X" then
		Mask = nil
	end
	if Deviation == "X" then
		Deviation = nil
	end
	if Mode == "X" then
		Mode = nil
	end

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	if Deviation == nil then
		Deviation = 0
	end
	if Mode == nil then
		Mode = SetTo
	end
	local Mask2 = Mask
	if Clear == 1 then
		Mask2 = 0xFFFFFFFF
	end
	local PDest = {}
	local TempAlloc = 1
	local TempVAlloc = 1
	local TMask, TDeviation, TMask2

	if type(Source) == "table" and Source[4] == "SVA" then
		local TempRet = {"X",SRet[Source[5][5]][3],0,"SV",Source[5][5],Source[5][7]}
		MovS(PlayerID,TempRet,Source)
		Source = TempRet
	end
	local PDestS, PMode, SDest
	if Dest[4] == "SVA" then
		PDestS = Dest
		Dest = {"X",SRet[Dest[5][5]][4],0,"SV",Dest[5][5],Dest[5][7]}
		SDest = Dest
		PMode = Mode
		Mode = SetTo
	end

	if Dest[4] == "SV" then
		if Dest[5] == 1 or type(Dest[6]) == "number" then 
			Dest = {_SMem(Dest,nil)}
		else
			Dest = _SMem(Dest,nil)
		end
	end

	if type(Source) == "table" and Source[4] == "SV" then
		local Box = {}
		local Box2 = {}
		local CloseLine = {}
		for i = 1, Source[5] do
			table.insert(CloseLine,i)
		end

		local Line = {}
		if Source[6] == nil then
			for i = 1, Source[5] do
				table.insert(Line,i)
			end
		else
			Line = Source[6]
		end

		for k, v in pairs(Line) do 
			if type(Mode) == "number" then
				TMode = Mode
			elseif Mode[k] == nil then
				TMode = SetTo
			else
				TMode = Mode[k]
			end
			TMode2 = TMode
			if TMode2 == SetTo then
				TMode2 = Add
			end
			if type(Mask) == "number" then
				TMask = Mask
			elseif Mask[k] == nil then
				TMask = 0xFFFFFFFF
			else
				TMask = Mask[k]
			end
			if type(Mask2) == "number" then
				TMask2 = Mask2
			elseif Mask2[k] == nil then
				TMask2 = 0xFFFFFFFF
			else
				TMask2 = Mask2[k]
			end
			if type(Deviation) == "number" then
				TDeviation = Deviation
			elseif Deviation[k] == nil then
				TDeviation = 0
			else
				TDeviation = Deviation[k]
			end
			if type(Dest[k]) == "number" then
				table.insert(Box,SetMemoryX(Dest[k],TMode,TDeviation,TMask))
				table.insert(Box,SetCtrig1X(Source[1],Source[2],0x158+0x40*(v-1),Source[3],SetTo,EPD(Dest[k])))
			elseif Dest[k][4] == "V" then
				table.insert(Box,SetCtrig1X(Dest[k][1],Dest[k][2],0x15C,Dest[k][3],TMode,TDeviation,TMask))
				table.insert(Box,SetCtrigX(Source[1],Source[2],0x158+0x40*(v-1),Source[3],SetTo,Dest[k][1],Dest[k][2],0x15C,1,Dest[k][3]))
			elseif Dest[k][4] == "A" then
				table.insert(PDest,{Dest[k],TMode})
				Dest[k] = {"X",NRet[TempAlloc],0,"V"}
				TempAlloc = TempAlloc + 1
				table.insert(Box,SetCtrig1X(Dest[k][1],Dest[k][2],0x15C,Dest[k][3],SetTo,TDeviation,0xFFFFFFFF))
				table.insert(Box,SetCtrigX(Source[1],Source[2],0x158+0x40*(v-1),Source[3],SetTo,Dest[k][1],Dest[k][2],0x15C,1,Dest[k][3]))
			elseif Dest[k][4] == "VA" then 
				table.insert(PDest,{Dest[k],TMode})
				Dest[k] = {"X",NRet[TempAlloc],0,"V"}
				TempAlloc = TempAlloc + 1
				table.insert(Box,SetCtrig1X(Dest[k][1],Dest[k][2],0x15C,Dest[k][3],SetTo,TDeviation,0xFFFFFFFF))
				table.insert(Box,SetCtrigX(Source[1],Source[2],0x158+0x40*(v-1),Source[3],SetTo,Dest[k][1],Dest[k][2],0x15C,1,Dest[k][3]))
			else
				table.insert(Box,SetCtrig1X(Dest[k][1],Dest[k][2],Dest[k][3],Dest[k][4],TMode,TDeviation,TMask2))
				table.insert(Box,SetCtrigX(Source[1],Source[2],0x158+0x40*(v-1),Source[3],SetTo,Dest[k][1],Dest[k][2],Dest[k][3],1,Dest[k][4]))
			end
			
			table.insert(Box,SetCtrig1X(Source[1],Source[2],0x164+0x40*(v-1),Source[3],SetTo,0x0,0x2))
			table.insert(Box,SetCtrig1X(Source[1],Source[2],0x160+0x40*(v-1),Source[3],SetTo,TMode2*16777216,0xFF000000))
			table.insert(Box,SetCtrig1X(Source[1],Source[2],0x148+0x40*(v-1),Source[3],SetTo,TMask))
			CloseLine[v] = 0
		end
		for k, v in pairs(CloseLine) do
			if v ~= 0 then
				table.insert(Box,SetCtrig1X(Source[1],Source[2],0x164+0x40*(v-1),Source[3],SetTo,0x2,0x2))
				table.insert(Box2,SetCtrig1X(Source[1],Source[2],0x164+0x40*(v-1),Source[3],SetTo,0x0,0x2))
			end
		end
		DoActions2X(PlayerID,Box)
		Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
		Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						Box2,
					},
					flag = {Preserved}
				}
	else -- Source ~= SV
		local SourceN = {}
		local SourceV = {}
		local SourceVA = {}
		local DestN = {}
		local DestV = {}
		local DestVA = {}
		for k, v in pairs(Source) do 
			if type(v) == "number" then
				table.insert(SourceN,v)
				table.insert(DestN,k)
			elseif v[4] == "V" then
				table.insert(SourceV,v)
				table.insert(DestV,k)
			elseif v[4] == "VA" then
				table.insert(SourceVA,v)
				table.insert(DestVA,k)
			else
				SMov_InputData_Error()
			end
		end

		local Box = {}
		local Box2 = {}
		local Box3 = {}

		for k, v in pairs(SourceN) do 
			local CurDest = Dest[DestN[k]]
			if type(Mode) == "number" then
				TMode = Mode
			elseif Mode[DestN[k]] == nil then
				TMode = SetTo
			else
				TMode = Mode[DestN[k]]
			end
			if type(Mask) == "number" then
				TMask = Mask
			elseif Mask[DestN[k]] == nil then
				TMask = 0xFFFFFFFF
			else
				TMask = Mask[DestN[k]]
			end
			if type(Mask2) == "number" then
				TMask2 = Mask2
			elseif Mask2[DestN[k]] == nil then
				TMask2 = 0xFFFFFFFF
			else
				TMask2 = Mask2[DestN[k]]
			end

			if type(CurDest) == "number" then
				table.insert(Box,SetMemoryX(CurDest,TMode,v,TMask))
			elseif CurDest[4] == "V" then
				table.insert(Box,SetCtrig1X(CurDest[1],CurDest[2],0x15C,CurDest[3],TMode,v,TMask))
			elseif CurDest[4] == "A" then
				table.insert(PDestN,{CurDest,TMode})
				CurDest = {"X",NRet[TempAlloc],0,"V"}
				TempAlloc = TempAlloc + 1
				table.insert(Box,SetCtrig1X(CurDest[1],CurDest[2],0x15C,CurDest[3],SetTo,0,0xFFFFFFFF))
				table.insert(Box,SetCtrig1X(CurDest[1],CurDest[2],0x15C,CurDest[3],TMode,v,TMask))
			elseif CurDest[4] == "VA" then 
				table.insert(PDestN,{CurDest,TMode})
				CurDest = {"X",NRet[TempAlloc],0,"V"}
				TempAlloc = TempAlloc + 1
				table.insert(Box,SetCtrig1X(CurDest[1],CurDest[2],0x15C,CurDest[3],SetTo,0,0xFFFFFFFF))
				table.insert(Box,SetCtrig1X(CurDest[1],CurDest[2],0x15C,CurDest[3],TMode,v,TMask))
			else
				table.insert(Box,SetCtrig1X(CurDest[1],CurDest[2],CurDest[3],CurDest[4],TMode,v,TMask2))
			end
		end
		if SourceN[1] ~= nil then
			DoActions2X(PlayerID,Box)
		end
		for k, v in pairs(SourceV) do 
			local CurDest = Dest[DestV[k]]
			if type(Mode) == "number" then
				TMode = Mode
			elseif Mode[DestV[k]] == nil then
				TMode = SetTo
			else
				TMode = Mode[DestV[k]]
			end
			TMode2 = TMode
			if TMode2 == SetTo then
				TMode2 = Add
			end
			if type(Mask) == "number" then
				TMask = Mask
			elseif Mask[DestV[k]] == nil then
				TMask = 0xFFFFFFFF
			else
				TMask = Mask[DestV[k]]
			end
			if type(Mask2) == "number" then
				TMask2 = Mask2
			elseif Mask2[DestV[k]] == nil then
				TMask2 = 0xFFFFFFFF
			else
				TMask2 = Mask2[DestV[k]]
			end
			if type(Deviation) == "number" then
				TDeviation = Deviation
			elseif Deviation[DestV[k]] == nil then
				TDeviation = 0
			else
				TDeviation = Deviation[DestV[k]]
			end

			if type(CurDest) == "number" then
				table.insert(Box2,SetMemoryX(CurDest,TMode,TDeviation,TMask))
				table.insert(Box2,SetCtrig1X(v[1],v[2],0x158,v[3],SetTo,EPD(CurDest)))
			elseif CurDest[4] == "V" then
				table.insert(Box2,SetCtrig1X(CurDest[1],CurDest[2],0x15C,CurDest[3],TMode,TDeviation,TMask))
				table.insert(Box2,SetCtrigX(v[1],v[2],0x158,v[3],SetTo,CurDest[1],CurDest[2],0x15C,1,CurDest[3]))
			elseif CurDest[4] == "A" then
				table.insert(PDest,{CurDest,TMode})
				CurDest = {"X",NRet[TempAlloc],0,"V"}
				TempAlloc = TempAlloc + 1
				table.insert(Box2,SetCtrig1X(CurDest[1],CurDest[2],0x15C,CurDest[3],SetTo,TDeviation,0xFFFFFFFF))
				table.insert(Box2,SetCtrigX(v[1],v[2],0x158,v[3],SetTo,CurDest[1],CurDest[2],0x15C,1,CurDest[3]))
			elseif CurDest[4] == "VA" then 
				table.insert(PDest,{CurDest,TMode})
				CurDest = {"X",NRet[TempAlloc],0,"V"}
				TempAlloc = TempAlloc + 1
				table.insert(Box2,SetCtrig1X(CurDest[1],CurDest[2],0x15C,CurDest[3],SetTo,TDeviation,0xFFFFFFFF))
				table.insert(Box2,SetCtrigX(v[1],v[2],0x158,v[3],SetTo,CurDest[1],CurDest[2],0x15C,1,CurDest[3]))
			else
				table.insert(Box2,SetCtrig1X(CurDest[1],CurDest[2],CurDest[3],CurDest[4],TMode,TDeviation,TMask2))
				table.insert(Box2,SetCtrigX(v[1],v[2],0x158,v[3],SetTo,CurDest[1],CurDest[2],CurDest[3],1,CurDest[4]))
			end
			table.insert(Box2,SetCtrig1X(v[1],v[2],0x160,v[3],SetTo,TMode2*16777216,0xFF000000))
			table.insert(Box2,SetCtrig1X(v[1],v[2],0x148,v[3],SetTo,TMask))
		end
		if SourceV[1] ~= nil then
			DoActions2X(PlayerID,Box2)
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						CallLabelAlwaysN(table.unpack(SourceV));
					},
					flag = {Preserved}
				}
		end
		local JumpVA = {}
		for k, v in pairs(SourceVA) do 
			local CurDest = Dest[DestVA[k]]
			if type(Mode) == "number" then
				TMode = Mode
			elseif Mode[DestVA[k]] == nil then
				TMode = SetTo
			else
				TMode = Mode[DestVA[k]]
			end
			TMode2 = TMode
			if TMode2 == SetTo then
				TMode2 = Add
			end
			if type(Mask) == "number" then
				TMask = Mask
			elseif Mask[DestVA[k]] == nil then
				TMask = 0xFFFFFFFF
			else
				TMask = Mask[DestVA[k]]
			end
			if type(Mask2) == "number" then
				TMask2 = Mask2
			elseif Mask2[DestVA[k]] == nil then
				TMask2 = 0xFFFFFFFF
			else
				TMask2 = Mask2[DestVA[k]]
			end
			if type(Deviation) == "number" then
				TDeviation = Deviation
			elseif Deviation[DestVA[k]] == nil then
				TDeviation = 0
			else
				TDeviation = Deviation[DestVA[k]]
			end
			local TempRet = {"X",CRet[TempVAlloc],0,"V"}
			table.insert(JumpVA,TempRet)
			MovX(PlayerID,TempRet,v)
			SourceVA[k] = TempRet
			TempVAlloc = TempVAlloc + 1
			if type(CurDest) == "number" then
				table.insert(Box3,SetMemoryX(CurDest,TMode,TDeviation,TMask))
				table.insert(Box3,SetCtrig1X(SourceVA[k][1],SourceVA[k][2],0x158,SourceVA[k][3],SetTo,EPD(CurDest)))
			elseif CurDest[4] == "V" then
				table.insert(Box3,SetCtrig1X(CurDest[1],CurDest[2],0x15C,CurDest[3],TMode,TDeviation,TMask))
				table.insert(Box3,SetCtrigX(SourceVA[k][1],SourceVA[k][2],0x158,SourceVA[k][3],SetTo,CurDest[1],CurDest[2],0x15C,1,CurDest[3]))
			elseif CurDest[4] == "A" then
				table.insert(PDest,{CurDest,TMode})
				CurDest = {"X",NRet[TempAlloc],0,"V"}
				TempAlloc = TempAlloc + 1
				table.insert(Box3,SetCtrig1X(CurDest[1],CurDest[2],0x15C,CurDest[3],SetTo,TDeviation,0xFFFFFFFF))
				table.insert(Box3,SetCtrigX(SourceVA[k][1],SourceVA[k][2],0x158,SourceVA[k][3],SetTo,CurDest[1],CurDest[2],0x15C,1,CurDest[3]))
			elseif CurDest[4] == "VA" then 
				table.insert(PDest,{CurDest,TMode})
				CurDest = {"X",NRet[TempAlloc],0,"V"}
				TempAlloc = TempAlloc + 1
				table.insert(Box3,SetCtrig1X(CurDest[1],CurDest[2],0x15C,CurDest[3],SetTo,TDeviation,0xFFFFFFFF))
				table.insert(Box3,SetCtrigX(SourceVA[k][1],SourceVA[k][2],0x158,SourceVA[k][3],SetTo,CurDest[1],CurDest[2],0x15C,1,CurDest[3]))
			else
				table.insert(Box3,SetCtrig1X(CurDest[1],CurDest[2],CurDest[3],CurDest[4],TMode,TDeviation,TMask2))
				table.insert(Box3,SetCtrigX(SourceVA[k][1],SourceVA[k][2],0x158,SourceVA[k][3],SetTo,CurDest[1],CurDest[2],CurDest[3],1,CurDest[4]))
			end
			table.insert(Box3,SetCtrig1X(SourceVA[k][1],SourceVA[k][2],0x160,SourceVA[k][3],SetTo,TMode2*16777216,0xFF000000))
			table.insert(Box3,SetCtrig1X(SourceVA[k][1],SourceVA[k][2],0x148,SourceVA[k][3],SetTo,TMask))
		end
		if SourceVA[1] ~= nil then
			DoActions2X(PlayerID,Box3)
			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						CallLabelAlwaysN(table.unpack(JumpVA));
					},
					flag = {Preserved}
				}
		end
	end
	if PDest ~= nil then
		for k, v in pairs(PDest) do
			MovX(PlayerID,v[1],{"X",NRet[k],0,"V"},v[2])
		end
	end

	if PDestS ~= nil then
		MovS(PlayerID,PDestS,SDest,PMode)
	end
end

function MovS(PlayerID,Dest,Source,Mode,Mask,Clear) -- SV << SVA / SVA << SV (Value) / 내부함수 (사용 권장X)
	STPopTrigArr(PlayerID)
	if Mask == "X" or Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Mask2 = Mask
	if Clear == 1 then
		Mask2 = 0xFFFFFFFF
	end
	if Mode == "X" then
		Mode = nil
	end
	if Mode == nil then
		Mode = SetTo
	end

	if Dest[4] == "SV" and Source[4] == "SVA" then -- Mov SV, SVA / {"X",Temp,0,"SVA",{"X",Index,0,"SA",Number,Size,Line},0,"X",Temp+1,0},
		if Dest[5] ~= Source[5][5] then
			MovS_InputData_Error()
		end
		local Box0 = {}
		local Box1 = {}
		local Box2 = {}
		local Box3 = {}
		for i = 1, Dest[5] do  
			if Clear == 1 then
				table.insert(Box0,SetCtrig1X(Dest[1],Dest[2],0x15C+0x40*(i-1),Dest[3],SetTo,0,Mask2))
			end
			table.insert(Box1,SetCtrig2X("Cp",SetTo,Dest[1],Dest[2],0x15C+0x40*(i-1),1,Dest[3]))
			table.insert(Box1,SetMemory(0x6509B0,Add,0x40/4))
			table.insert(Box2,SetDeaths(CurrentPlayer,SetTo,Mask,0))
			table.insert(Box2,SetMemory(0x6509B0,Add,0x40/4))
			table.insert(Box3,SetDeathsX(CurrentPlayer,SetTo,Mode*16777216,0,0xFF000000))
			table.insert(Box3,SetMemory(0x6509B0,Add,0x40/4))
		end
		table.insert(Box1,SetMemory(0x6509B0,Add,(-0x40*Dest[5])/4))
		table.insert(Box2,SetMemory(0x6509B0,Add,(-0x40*Dest[5])/4))
		table.insert(Box3,SetMemory(0x6509B0,Add,(-0x40*Dest[5])/4))
		Trigger {--(CPRead)로 값 출력
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					Box0,
					SetCtrigX("X","X",0x15C,1,SetTo,Source[5][1],Source[5][2],0,0,Source[5][3]); 
					SetCtrig1X("X","X",0x15C,1,Add,Source[6]*4);

					SetCtrig2X(0x6509B0,SetTo,Source[5][1],Source[5][2],0,1,Source[5][3]); 
					SetMemory(0x6509B0,Add,Source[6]);

					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(0x6509B0)); 

					SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
					SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,"X","X",0x15C,1,1); 
					CallLabelAlways2(Source[1],Source[2],Source[3],Source[7],Source[8],Source[9]);
				},
				flag = {Preserved}
			}
		Trigger {--(CPRead)로 값 출력
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,5,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
					SetMemory(0x6509B0,Add,(0x4-0x0)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,6); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					SetMemory(0x6509B0,Add,(0x158-0x4)/4);
				},
				flag = {Preserved}
			}
		DoActions2X(PlayerID,Box1)
		Trigger {--(CPRead)로 값 출력
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetMemory(0x6509B0,Add,(0x148-0x158)/4);
				},
				flag = {Preserved}
			}
		DoActions2X(PlayerID,Box2)
		Trigger {--(CPRead)로 값 출력
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
				},
				flag = {Preserved}
			}
		DoActions2X(PlayerID,Box3)
		RecoverCp(PlayerID)
	elseif Dest[4] == "SVA" and Source[4] == "SV" then -- Mov SVA, SV 
		local TMode, TMode2
		if Dest[5][5] ~= Source[5] then
			MovS_InputData_Error()
		end
		local N = Source[5]
		local Box1 = {}
		local Box2 = {}
		if N >= 2 then
			table.insert(Box1,SetCtrigX("X",SRet[N][1],0x158,0,SetTo,"X",SRet[N][1],0x15C+0x40*1,1,0))
			table.insert(Box1,SetCtrig1X("X",SRet[N][1],0x148,0,SetTo,0xFFFFFFFF))
			table.insert(Box1,SetCtrig1X("X",SRet[N][1],0x160,0,SetTo,SetTo*16777216,0xFF000000))
			for i = 1, N-1 do
				if i == N-1 then
					table.insert(Box1,SetCtrig1X("X",SRet[N][1],0x158+0x40*i,0,SetTo,0))
				else
					table.insert(Box1,SetCtrigX("X",SRet[N][1],0x158+0x40*i,0,SetTo,"X",SRet[N][1],0x15C+0x40*(i+1),1,0))
				end
				table.insert(Box1,SetCtrig1X("X",SRet[N][1],0x148+0x40*i,0,SetTo,0xFFFFFFFF))
				table.insert(Box1,SetCtrig1X("X",SRet[N][1],0x160+0x40*i,0,SetTo,SetTo*16777216,0xFF000000))
			end
		end
		for i = 1, N do
			if type(Mode) == "number" then
				TMode = Mode
			elseif Mode[i] == nil then
				TMode = SetTo
			else
				TMode = Mode[i]
			end
			table.insert(Box2,SetCtrig1X("X",SRet[N][1],0x15C+0x40*(i-1),0,Add,0x10*(i-1)))
			table.insert(Box2,SetCtrigX("X",SRet[N][1],0x158+0x40*(i-1),0,SetTo,Source[1],Source[2],0x158+0x40*(i-1),1,Source[3]))
			table.insert(Box2,SetCtrig1X(Source[1],Source[2],0x148+0x40*(i-1),Source[3],SetTo,Mask))
			table.insert(Box2,SetCtrig1X(Source[1],Source[2],0x160+0x40*(i-1),Source[3],SetTo,TMode*16777216,0xFF000000))
			table.insert(Box2,SetCtrig1X(Source[1],Source[2],0x164+0x40*(i-1),Source[3],SetTo,0x0,0x2))
		end
		DoActions2X(PlayerID,{
					SetCtrigX("X",SRet[N][1],0x15C,0,SetTo,Dest[5][1],Dest[5][2],0x15C,1,Dest[5][3]); 
					SetCtrig1X("X",SRet[N][1],0x15C,0,Add,Dest[6]);
					SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,Add*16777216,0xFF000000);
					SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X",SRet[N][1],0x15C,1,0);
					Box1,
		})
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabelAlways2(Dest[1],Dest[2],Dest[3],"X",SRet[N][1],0);
				},
				flag = {Preserved}
			}
		DoActions2X(PlayerID,Box2)
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					CallLabelAlways2("X",SRet[N][1],0,Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
	else
		MovS_InputData_Error()
	end
end

function TSMem(PlayerID,Dest,Source,Address,Next,OffsetFlag) -- V << SV_EPD/Offset, SVA_EPD/Offset
	STPopTrigArr(PlayerID)
	if OffsetFlag == "X" or OffsetFlag == nil then
		OffsetFlag = 0
	end
	if Address == "X" or Address == nil then
		Address = 0x15C
	end
	if Next == "X" or Next == nil then
		Next = 0
	end

	if Dest[4] == "V" then
		if Source[4] == "SV" then
			if Source[3] == nil or Source[3] == "X" then
				Source[3] = 0 
			end
			if OffsetFlag == 0 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Address,1,Source[3]+Next); 
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[1],Source[2],Address,0,Source[3]+Next); 
					},
					flag = {Preserved}
				}
			end
		elseif Source[4] == "SVA" then
			if OffsetFlag == 0 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address,1,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,Source[5][1],Source[5][2],Address,0,Source[5][3]+Next); 
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Source[6]*4);
						SetCtrig1X(Source[7],Source[8],0x148,Source[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[7],Source[8],0x160,Source[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(Source[7],Source[8],0x158,Source[9],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						CallLabelAlways(Source[7],Source[8],Source[9]);
					},
					flag = {Preserved}
				}
			end
		end
	else
		_TSMem_InputData_Error()
	end
end

function f_Diff(PlayerID,Dest,Source,Mask,Time,Delay,Init)
	STPopTrigArr(PlayerID)
	if Mask == "X" or Mask == nil then
		Mask = 0xFFFFFFFF
	end
	if Time == "X" or Time == nil or Time == 1 then
		Time = 0
	end
	if Delay == "X" or Delay == nil then
		Delay = 0
	end
	if Init == "X" or Init == nil then
		Init = 0
	end

	if type(Source) == "table" and Source[4] == "VA" then
		local TempRet = {"X",CRet[7],0,"V"}
		MovX(PlayerID,TempRet,Source)
		Source = TempRet
	end
	local PDest
	if type(Dest) == "table" and Dest[4] == "VA" then
		PDest = Dest
		Dest = {"X",CRet[8],0,"V"}
	end
	if Dest[4] == "V" then
		if Source[4] == "V" then -- Diff V, X : V << ΔX
			if Time == 0 then
				Trigger {-- Z << X - Y
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000); 
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X","X",0x158,1,SetTo,"X",CRet[1],0x15C,1,0);
						SetCtrig1X("X","X",0x148,1,SetTo,0xFFFFFFFF);
						SetCtrig1X("X","X",0x160,1,SetTo,Subtract*16777216,0xFF000000);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);

						SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
						SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0x0,0,1);
						SetCtrigX("X","X",0x4,1,SetTo,"X",CRet[1],0x0,0,0);
						SetCtrigX("X",CRet[1],0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
				Trigger { -- Temp V
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
						SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
					},
					flag = {Preserved}
				}
				Trigger {-- Y << X
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x15C,-1,SetTo,0);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x15C,1,-1);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				if Init ~= 0 then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0);
						},
					}
				end
			else
				if Delay ~= 0 then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x19C,4,SetTo,Delay);
						},
					}
				end
				Trigger { -- Temp Z
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0,0xFFFFFFFF); -- Full Variable
							SetCtrig1X("X","X",0x19C,3,Subtract,1);
						},
						flag = {Preserved}
					}
				CIf(PlayerID,CtrigX("X","X",0x19C,2,Exactly,0),SetCtrig1X("X","X",0x19C,2,Add,Time))
					Trigger {-- Z << X - Y
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x15C,-2,SetTo,0);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x15C,1,-2);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000); 
							SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0xFFFFFFFF);
							SetCtrigX("X","X",0x158,1,SetTo,"X",CRet[1],0x15C,1,0);
							SetCtrig1X("X","X",0x148,1,SetTo,0xFFFFFFFF);
							SetCtrig1X("X","X",0x160,1,SetTo,Subtract*16777216,0xFF000000);
							SetCtrigX("X",CRet[1],0x158,0,SetTo,"X","X",0x15C,1,-2);
							SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);

							SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
							SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0x0,0,1);
							SetCtrigX("X","X",0x4,1,SetTo,"X",CRet[1],0x0,0,0);
							SetCtrigX("X",CRet[1],0x4,0,SetTo,"X","X",0x0,0,2);
						},
						flag = {Preserved}
					}
					Trigger { -- Temp V
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
							SetCtrig1X("X",CRet[1],0x15C,0,Add,1);
							Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Timer
						},
						flag = {Preserved}
					}
					Trigger {-- Y << X
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x15C,-1,SetTo,0);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x15C,1,-1);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				CIfEnd()
				if Init ~= 0 then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
							CtrigX("X","X",0x15C,0,AtMost,Time+Delay);
						},
						actions = {
							Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Timer
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0);
							SetCtrig1X("X","X",0x15C,0,Add,1);
						},
						flag = {Preserved}
					}
				end
			end
		else
			f_Diff_InputData_Error()
		end
	else
		f_Diff_InputData_Error()
	end
	if PDest ~= nil then
		MovX(PlayerID,PDest,Dest)
	end
end

function f_LDiff(PlayerID,Dest,Source,Mask,Time,Delay,Init)
	STPopTrigArr(PlayerID)
	if Mask == "X" or Mask == nil then
		Mask = {0xFFFFFFFF,0xFFFFFFFF}
	elseif type(Mask) == "string" then
		Mask = I64(Mask)
	end
	if Time == "X" or Time == nil or Time == 1 then
		Time = 0
	end
	if Delay == "X" or Delay == nil then
		Delay = 0
	end
	if Init == "X" or Init == nil then
		Init = 0
	end

	if type(Source) == "table" and Source[4] == "WA" then
		local TempRet = {"X",WRet[7],0,"W"}
		MovW(PlayerID,TempRet,Source)
		Source = TempRet
	end
	local PDest
	if type(Dest) == "table" and Dest[4] == "WA" then
		PDest = Dest
		Dest = {"X",WRet[8],0,"W"}
	end
	
	if Dest[4] == "W" then
		if Source[4] == "W" then -- LDiff V, X : V << ΔX
			if Time == 0 then
				Trigger {-- Z << X - Y
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,0);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
						SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000); 
						SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000); 
						SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X","X",0x158,1,SetTo,"X",WRet[1],0x15C,1,0);
						SetCtrigX("X","X",0x198,1,SetTo,"X",WRet[1],0x19C,1,0);
						SetCtrig1X("X","X",0x148,1,SetTo,0xFFFFFFFF);
						SetCtrig1X("X","X",0x188,1,SetTo,0xFFFFFFFF);
						SetCtrig1X("X","X",0x160,1,SetTo,Subtract*16777216,0xFF000000);
						SetCtrig1X("X","X",0x1A0,1,SetTo,Subtract*16777216,0xFF000000);

						SetCtrigX(Dest[1],Dest[2],0x158,Dest[3],SetTo,"X","X",0x24,1,3);
						SetCtrig1X(Dest[1],Dest[2],0x198,Dest[3],SetTo,0);
						SetCtrig1X(Dest[1],Dest[2],0x148,Dest[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Dest[1],Dest[2],0x160,Dest[3],SetTo,SetTo*16777216,0xFF000000);

						SetCtrigX("X",WRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
						SetCtrigX("X",WRet[1],0x198,0,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
						SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[1],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
						SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,Add*16777216,0xFF000000);

						SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
						SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0x0,0,1);
						SetCtrigX("X","X",0x4,2,SetTo,Dest[1],Dest[2],0x0,0,Dest[3]);
						SetCtrigX(Dest[1],Dest[2],0x4,Dest[3],SetTo,"X",WRet[1],0x0,0,0);
						SetCtrigX("X",WRet[1],0x4,0,SetTo,"X","X",0x0,0,3);
					},
					flag = {Preserved}
				}
				Trigger { -- Temp V
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
						Disabled(SetMemoryX(0x6509B0,Add,1,0xFFFFFFFF)); -- Cp Add (Must be Preserved)
						SetDeathsX(0,SetTo,0,0,0xFFFFFFFF);  -- Full Variable
						SetCtrig1X("X",WRet[1],0x15C,0,Add,1);
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],Add,1); -- Carry 가불
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX("X",WRet[1],0x15C,0,Exactly,0);
					},
					actions = {
						SetCtrig1X("X",WRet[1],0x19C,0,Add,1);
					},
					flag = {Preserved}
				}	
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
						CtrigX(Dest[1],Dest[2],0x15C,Dest[3],AtLeast,0); -- X2 >= X2(전) : X1 -= 1 (No Carry)
					},
					actions = {
						SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],Add,-1);
					},
					flag = {Preserved}
				}
				Trigger {-- Y << X
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x15C,-3,SetTo,0);
						SetCtrig1X("X","X",0x19C,-3,SetTo,0);
						SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x15C,1,-3);
						SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X","X",0x19C,1,-3);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				if Init ~= 0 then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0);
							SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,0);
						},
					}
				end
			else
				if Delay ~= 0 then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x17C,4,SetTo,Delay);
						},
					}
				end
				Trigger { -- Temp Z
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0,0xFFFFFFFF); -- Full Variable
							Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Timer
							SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,0,0xFFFFFFFF); -- Full Variable
							SetCtrig1X("X","X",0x17C,3,Subtract,1);
						},
						flag = {Preserved}
					}
				CIf(PlayerID,CtrigX("X","X",0x17C,2,Exactly,0),SetCtrig1X("X","X",0x17C,2,Add,Time))
					Trigger {-- Z << X - Y
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x15C,-2,SetTo,0);
							SetCtrig1X("X","X",0x19C,-2,SetTo,0);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x15C,1,-2);
							SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X","X",0x19C,1,-2);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
							SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000); 
							SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000); 
							SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0xFFFFFFFF);
							SetCtrigX("X","X",0x158,1,SetTo,"X",WRet[1],0x15C,1,0);
							SetCtrigX("X","X",0x198,1,SetTo,"X",WRet[1],0x19C,1,0);
							SetCtrig1X("X","X",0x148,1,SetTo,0xFFFFFFFF);
							SetCtrig1X("X","X",0x188,1,SetTo,0xFFFFFFFF);
							SetCtrig1X("X","X",0x160,1,SetTo,Subtract*16777216,0xFF000000);
							SetCtrig1X("X","X",0x1A0,1,SetTo,Subtract*16777216,0xFF000000);

							SetCtrigX("X","X",0x158,-2,SetTo,"X","X",0x24,1,3);
							SetCtrig1X("X","X",0x198,-2,SetTo,0);

							SetCtrigX("X",WRet[1],0x158,0,SetTo,"X","X",0x15C,1,-2);
							SetCtrigX("X",WRet[1],0x198,0,SetTo,"X","X",0x19C,1,-2);
							SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",WRet[1],0x188,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",WRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
							SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,Add*16777216,0xFF000000);

							SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
							SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0x0,0,1);
							SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,-2);
							SetCtrigX("X","X",0x4,-2,SetTo,"X",WRet[1],0x0,0,0);
							SetCtrigX("X",WRet[1],0x4,0,SetTo,"X","X",0x0,0,3);
						},
						flag = {Preserved}
					}
					Trigger { -- Temp V
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
							Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Timer
							SetDeathsX(0,SetTo,0,0,0xFFFFFFFF); -- Full Variable
							SetCtrig1X("X",WRet[1],0x15C,0,Add,1);
							SetCtrig1X("X","X",0x19C,-3,Add,1); -- Carry 가불
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
							CtrigX("X",WRet[1],0x15C,0,Exactly,0);
						},
						actions = {
							SetCtrig1X("X",WRet[1],0x19C,0,Add,1);
						},
						flag = {Preserved}
					}	
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
							CtrigX("X","X",0x15C,-5,AtLeast,0); -- X2 >= X2(전) : X1 -= 1 (No Carry)
						},
						actions = {
							SetCtrig1X("X","X",0x19C,-5,Add,-1);
						},
						flag = {Preserved}
					}
					Trigger {-- Y << X
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x15C,-3,SetTo,0);
							SetCtrig1X("X","X",0x19C,-3,SetTo,0);
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,"X","X",0x15C,1,-3);
							SetCtrigX(Source[1],Source[2],0x198,Source[3],SetTo,"X","X",0x19C,1,-3);
							CallLabelAlways(Source[1],Source[2],Source[3]);
							SetCtrigX("X","X",0x4,-6,SetTo,"X","X",0x0,0,-5); -- RecoverNext
							SetCtrigX("X","X",0x158,-6,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrigX("X","X",0x198,-6,SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
						},
						flag = {Preserved}
					}
				CIfEnd()
				if Init ~= 0 then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
							CtrigX("X","X",0x15C,0,AtMost,Time+Delay);
						},
						actions = {
							Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Timer
							SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],SetTo,0);
							SetCtrig1X(Dest[1],Dest[2],0x19C,Dest[3],SetTo,0);
							SetCtrig1X("X","X",0x15C,0,Add,1);
						},
						flag = {Preserved}
					}
				end
			end
		else
			f_LDiff_InputData_Error()
		end
	else
		f_LDiff_InputData_Error()
	end

	if PDest ~= nil then
		MovW(PlayerID,PDest,Dest)
	end
end

function f_SDiff(PlayerID,Dest,Source,Mask,Time,Delay,Init) -- SV << ΔSV(A)
	STPopTrigArr(PlayerID)
	
	if Mask == "X" or Mask == nil then
		Mask = 0xFFFFFFFF
	end
	if Time == "X" or Time == nil or Time == 1 then
		Time = 0
	end
	if Delay == "X" or Delay == nil then
		Delay = 0
	end
	if Init == "X" or Init == nil then
		Init = 0
	end

	if type(Source) == "table" and Source[4] == "SVA" then
		local TempRet = {"X",SRet[Source[5][5]][3],0,"SV",Source[5][5]}
		MovS(PlayerID,TempRet,Source)
		Source = TempRet
	end
	local PDest
	if type(Dest) == "table" and Dest[4] == "SVA" then
		PDest = Dest
		Dest = {"X",SRet[Dest[5][5]][4],0,"SV",Dest[5][5]}
	end

	local Number = Source[5]
	if Number ~= Dest[5] or Number < 1 or Number > 16 then
		SDiff_InputData_Error()
	end

	if Dest[4] == "SV" then
		if Source[4] == "SV" then -- Diff SV, X : V << ΔX
			if Time == 0 then
				local Box10 = {}
				for i = 1, Number do
					table.insert(Box10,SetCtrig1X(Dest[1],Dest[2],0x15C+0x40*(i-1),Dest[3],SetTo,0))
					table.insert(Box10,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,Dest[1],Dest[2],0x15C+0x40*(i-1),1,Dest[3]))
					table.insert(Box10,SetCtrig1X(Source[1],Source[2],0x148+0x40*(i-1),Source[3],SetTo,Mask))
					table.insert(Box10,SetCtrig1X(Source[1],Source[2],0x160+0x40*(i-1),Source[3],SetTo,SetTo*16777216,0xFF000000))
				end
				DoActions2X(PlayerID,Box10)

				local Box11a = {}
				local Box11b = {}
				for i = 1, Number do
					table.insert(Box11a,SetCtrig1X("X",SRet[Number][1],0x15C+0x40*(i-1),0,SetTo,0xFFFFFFFF))
					table.insert(Box11a,SetCtrigX("X","X",0x158+0x40*(i-1),4,SetTo,"X",SRet[Number][1],0x15C+0x40*(i-1),1,0))
					table.insert(Box11b,SetCtrig1X("X","X",0x148+0x40*(i-1),3,SetTo,0xFFFFFFFF))
					table.insert(Box11b,SetCtrig1X("X","X",0x160+0x40*(i-1),3,SetTo,Subtract*16777216,0xFF000000))
				end
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						Box11a,
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						Box11b,
					},
					flag = {Preserved}
				}

				local Box12a = {}
				local Box12b = {}
				for i = 1, Number do
					table.insert(Box12a,SetCtrigX("X",SRet[Number][1],0x158+0x40*(i-1),0,SetTo,Dest[1],Dest[2],0x15C+0x40*(i-1),1,Dest[3]))
					table.insert(Box12a,SetCtrig1X("X",SRet[Number][1],0x148+0x40*(i-1),0,SetTo,0xFFFFFFFF))
					table.insert(Box12b,SetCtrig1X("X",SRet[Number][1],0x160+0x40*(i-1),0,SetTo,Add*16777216,0xFF000000))
				end
				Trigger {-- Z << X - Y
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						Box12a,
					},
					flag = {Preserved}
				}
				Trigger {-- Z << X - Y
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						Box12b,
						SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
						SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0x0,0,1);
						SetCtrigX("X","X",0x4,1,SetTo,"X",SRet[Number][1],0x0,0,0);
						SetCtrigX("X",SRet[Number][1],0x4,0,SetTo,"X","X",0x0,0,2);
					},
					flag = {Preserved}
				}
				local Box2 = {}
				for i = 1, Number do
					table.insert(Box2,SetDeathsX(0,SetTo,0,0,0xFFFFFFFF))
					table.insert(Box2,SetCtrig1X("X",SRet[Number][1],0x15C+0x40*(i-1),0,Add,1))
				end
				Trigger { -- Temp V
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						Box2,
					},
					flag = {Preserved}
				}
				local Box3 = {}
				for i = 1, Number do
					table.insert(Box3,SetCtrig1X("X","X",0x15C+0x40*(i-1),-1,SetTo,0))
					table.insert(Box3,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,"X","X",0x15C+0x40*(i-1),1,-1))
				end
				Trigger {-- Y << X
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						Box3,
					},
					flag = {Preserved}
				}
				Trigger {-- Y << X
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
				if Init ~= 0 then
					local Box4 = {}
					for i = 1, Number do
						table.insert(Box4,SetCtrig1X(Dest[1],Dest[2],0x15C+0x40*(i-1),Dest[3],SetTo,0))
					end
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Box4,
						},
					}
				end
			else
				if Delay ~= 0 then
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X","X",0x15C,11,SetTo,Delay);
						},
					}
				end
				local Box0 = {}
				for i = 1, Number do
					table.insert(Box0,SetCtrig1X(Dest[1],Dest[2],0x15C+0x40*(i-1),Dest[3],SetTo,0,0xFFFFFFFF))
					table.insert(Box0,Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)))
				end
				Trigger { -- Temp Z
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Box0; -- Full Variable
						},
						flag = {Preserved}
					}
				CIf(PlayerID,CtrigX("X","X",0x15C,9,Exactly,0),SetCtrig1X("X","X",0x15C,9,Add,Time))

					local Box10a = {}
					local Box10b = {}
					for i = 1, Number do
						table.insert(Box10a,SetCtrig1X("X","X",0x15C+0x40*(i-1),-2,SetTo,0))
						table.insert(Box10a,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,"X","X",0x15C+0x40*(i-1),1,-2))
						table.insert(Box10b,SetCtrig1X(Source[1],Source[2],0x148+0x40*(i-1),Source[3],SetTo,Mask))
						table.insert(Box10b,SetCtrig1X(Source[1],Source[2],0x160+0x40*(i-1),Source[3],SetTo,SetTo*16777216,0xFF000000))
					end
					Trigger {-- Clear
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Box10a,
						},
						flag = {Preserved}
					}
					Trigger {-- Clear
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Box10b,
						},
						flag = {Preserved}
					}


					local Box11a = {}
					local Box11b = {}
					for i = 1, Number do
						table.insert(Box11a,SetCtrig1X("X",SRet[Number][1],0x15C+0x40*(i-1),0,SetTo,0xFFFFFFFF))
						table.insert(Box11a,SetCtrigX("X","X",0x158+0x40*(i-1),4,SetTo,"X",SRet[Number][1],0x15C+0x40*(i-1),4,0))
						table.insert(Box11b,SetCtrig1X("X","X",0x148+0x40*(i-1),3,SetTo,0xFFFFFFFF))
						table.insert(Box11b,SetCtrig1X("X","X",0x160+0x40*(i-1),3,SetTo,Subtract*16777216,0xFF000000))	
					end
					Trigger {-- Clear
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Box11a,
						},
						flag = {Preserved}
					}
					Trigger {-- Clear
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Box11b,
						},
						flag = {Preserved}
					}

					local Box12a = {}
					local Box12b = {}
					for i = 1, Number do
						table.insert(Box12a,SetCtrigX("X",SRet[Number][1],0x158+0x40*(i-1),0,SetTo,"X","X",0x15C+0x40*(i-1),1,-6))
						table.insert(Box12a,SetCtrig1X("X",SRet[Number][1],0x148+0x40*(i-1),0,SetTo,0xFFFFFFFF))
						table.insert(Box12b,SetCtrig1X("X",SRet[Number][1],0x160+0x40*(i-1),0,SetTo,Add*16777216,0xFF000000))
					end
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Box12a,
						},
						flag = {Preserved}
					}
					Trigger {-- Z << X - Y
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Box12b,
							SetCtrigX("X","X",0x4,0,SetTo,Source[1],Source[2],0x0,0,Source[3]);
							SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0x0,0,1);
							SetCtrigX("X","X",0x4,1,SetTo,"X",SRet[Number][1],0x0,0,0);
							SetCtrigX("X",SRet[Number][1],0x4,0,SetTo,"X","X",0x0,0,2);
						},
						flag = {Preserved}
					}
					local Box2 = {}
					for i = 1, Number do
						table.insert(Box2,SetDeathsX(0,SetTo,0,0,0xFFFFFFFF))
						table.insert(Box2,SetCtrig1X("X",SRet[Number][1],0x15C+0x40*(i-1),0,Add,1))
					end
					Trigger { -- Temp V
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Box2,
						},
						flag = {Preserved}
					}
					local Box3 = {}
					for i = 1, Number do
						table.insert(Box3,SetCtrig1X("X","X",0x15C+0x40*(i-1),-1,SetTo,0))
						table.insert(Box3,SetCtrigX(Source[1],Source[2],0x158+0x40*(i-1),Source[3],SetTo,"X","X",0x15C+0x40*(i-1),1,-1))
					end 
					Trigger {-- Y << X
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Box3,
						},
						flag = {Preserved}
					} 
					Trigger {-- Y << X
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Timer 0x15C+0x40*Number
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					} 
				CIfEnd()
				DoActionsX(PlayerID,SetCtrig1X("X","X",0x15C,-2,Subtract,1))
				if Init ~= 0 then
					local Box4 = {}
					for i = 1, Number do
						table.insert(Box4,SetCtrig1X(Dest[1],Dest[2],0x15C+0x40*(i-1),Dest[3],SetTo,0))
					end
					Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
							CtrigX("X","X",0x15C,0,AtMost,Time+Delay);
						},
						actions = {
							Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Timer
							SetCtrig1X("X","X",0x15C,0,Add,1);
							Box4,
						},
						flag = {Preserved}
					}
				end
			end
		else
			f_SDiff_InputData_Error()
		end
	else
		f_SDiff_InputData_Error()
	end
	if PDest ~= nil then
		MovS(PlayerID,PDest,Dest,SetTo)
	end
end

function CreateVar(PlayerID)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"V",PlayerID})
	local Ret = V(CreateVarXAlloc)
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end

function CreateVar2(PlayerID,Offset,Type,Value,Mask)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"V2",PlayerID,Offset,Type,Value,Mask})
	local Ret = V(CreateVarXAlloc)
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end

function CreateVars(Number,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"V",PlayerID})
		table.insert(ret,V(CreateVarXAlloc))
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return table.unpack(ret)
end

function CreateVars(Number,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"V",PlayerID})
		table.insert(ret,V(CreateVarXAlloc))
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return table.unpack(ret)
end

function CreateVar2s(Number,Value,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"V2",PlayerID,nil,SetTo,Value[i],nil})
		table.insert(ret,V(CreateVarXAlloc))
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return table.unpack(ret)
end

function CreateVarArr(Number,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"V",PlayerID})
		table.insert(ret,V(CreateVarXAlloc))
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return ret
end

function CreateVarArr2(Number,Value,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"V2",PlayerID,nil,SetTo,Value[i],nil})
		table.insert(ret,V(CreateVarXAlloc))
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return ret
end

function CreateWar(PlayerID)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"W",PlayerID})
	local Ret = W(CreateVarXAlloc)
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end

function CreateWar2(PlayerID,Offset,Type,Value,Mask)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"W2",PlayerID,Offset,Type,Value,Mask})
	local Ret = W(CreateVarXAlloc)
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end

function CreateWars(Number,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"W",PlayerID})
		table.insert(ret,W(CreateVarXAlloc))
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return table.unpack(ret)
end

function CreateWar2s(Number,Value,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"W2",PlayerID,nil,SetTo,Value[i],nil})
		table.insert(ret,W(CreateVarXAlloc))
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return table.unpack(ret)
end

function CreateWarArr(Number,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"W",PlayerID})
		table.insert(ret,W(CreateVarXAlloc))
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return ret
end

function CreateWarArr2(Number,Value,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"W2",PlayerID,nil,SetTo,Value[i],nil})
		table.insert(ret,W(CreateVarXAlloc))
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return ret
end

function CreateSVar(Size,PlayerID)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"SV",PlayerID,Size})
	local Ret = {SV({"S",CreateVarXAlloc,Size}),{"S",CreateVarXAlloc,Size}}
	if type(PlayerID) == "number" then
		Ret[1][1] = PlayerID
	end
	return Ret
end

function CreateSVar2(Size,PlayerID,Offset,Type,Value,Mask)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"SV2",PlayerID,Size,Offset,Type,Value,Mask})
	local Ret = {SV({"S",CreateVarXAlloc,Size}),{"S",CreateVarXAlloc,Size}}
	if type(PlayerID) == "number" then
		Ret[1][1] = PlayerID
	end
	return Ret
end

function CreateSVars(Size,Number,PlayerID)	
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"SV",PlayerID,Size})
		table.insert(ret,{SV({"S",CreateVarXAlloc,Size}),{"S",CreateVarXAlloc,Size}})
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1][1] = PlayerID
		end
	end
	return table.unpack(ret)
end

function CreateSVarArr(Size,Number,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"SV",PlayerID,Size})
		table.insert(ret,{SV({"S",CreateVarXAlloc,Size}),{"S",CreateVarXAlloc,Size}})
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1][1] = PlayerID
		end
	end
	return ret
end

function CreateVoid()
	VoidAreaAlloc = VoidAreaAlloc+4
	return VoidAreaAlloc
end

function CreateVoids(Number)
	local ret = {}
	for i = 1, Number do
		VoidAreaAlloc = VoidAreaAlloc+4
		table.insert(ret,VoidAreaAlloc)
	end
	return table.unpack(ret)
end

function CreateVoidArr(Number)
	local ret = {}
	for i = 1, Number do
		VoidAreaAlloc = VoidAreaAlloc+4
		table.insert(ret,VoidAreaAlloc)
	end
	return ret
end

function CreateCcode()
	CreateCCodeAlloc = CreateCCodeAlloc+1
	return Ccode(CreateCCodeVarXAlloc+math.floor((CreateCCodeAlloc-1)/480),(CreateCCodeAlloc-1)%480)
end

function CreateCcodes(Number)
	local ret = {}
	for i = 1, Number do
		CreateCCodeAlloc = CreateCCodeAlloc+1
		table.insert(ret,Ccode(CreateCCodeVarXAlloc+math.floor((CreateCCodeAlloc-1)/480),(CreateCCodeAlloc-1)%480))
	end
	return table.unpack(ret)
end

function CreateCcodeArr(Number)
	local ret = {}
	for i = 1, Number do
		CreateCCodeAlloc = CreateCCodeAlloc+1
		table.insert(ret,Ccode(CreateCCodeVarXAlloc+math.floor((CreateCCodeAlloc-1)/480),(CreateCCodeAlloc-1)%480))
	end
	return ret
end

function CreateNcode()
	CreateNCodeAlloc = CreateNCodeAlloc+1
	return CCode(CreateNCodeVarXAlloc+math.floor((CreateNCodeAlloc-1)/60),(CreateNCodeAlloc-1)%60)
end

function CreateNcodes(Number)
	local ret = {}
	for i = 1, Number do
		CreateNCodeAlloc = CreateNCodeAlloc+1
		table.insert(ret,CCode(CreateNCodeVarXAlloc+math.floor((CreateNCodeAlloc-1)/60),(CreateNCodeAlloc-1)%60))
	end
	return table.unpack(ret)
end

function CreateNcodeArr(Number)
	local ret = {}
	for i = 1, Number do
		CreateNCodeAlloc = CreateNCodeAlloc+1
		table.insert(ret,CCode(CreateNCodeVarXAlloc+math.floor((CreateNCodeAlloc-1)/60),(CreateNCodeAlloc-1)%60))
	end
	return ret
end

function CreateVArr(Size,PlayerID)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"VA",PlayerID,Size})
	local Ret = {"X",CreateVarXAlloc,0,"V",0,Size}
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end

function CreateVArr2(Size,Value,PlayerID)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"VA2",PlayerID,Size,Value})
	local Ret = {"X",CreateVarXAlloc,0,"V",0,Size}
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end

function CreateWArr(Size,PlayerID)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"WA",PlayerID,Size})
	local Ret = {"X",CreateVarXAlloc,0,"W",0,Size}
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end

function CreateWArr2(Size,Value,PlayerID)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"WA2",PlayerID,Size,Value})
	local Ret = {"X",CreateVarXAlloc,0,"W",0,Size}
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end

function CreateSVArr(Number,Size,PlayerID)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"SVA",PlayerID,Size,Number})
	local Ret = {"X",CreateVarXAlloc,0,"SA",Number,Size}
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end

function CreateArr(Size,PlayerID)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"A",PlayerID,Size})
	local Ret = {"X",CreateVarXAlloc,0,0}
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end

function CreateLArr(Size,PlayerID)
	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"LA",PlayerID,Size})
	local Ret = {"X",CreateVarXAlloc,0,0}
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end

function CreateDb(ByteSize,PlayerID)
	return CreateArr(ByteSize/4,PlayerID)
end

function CreateLDb(ByteSize,PlayerID)
	return CreateLArr(ByteSize/4,PlayerID)
end

function CreateVArrs(Number,Size,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"VA",PlayerID,Size})
		table.insert(ret,{"X",CreateVarXAlloc,0,"V",0,Size})
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return table.unpack(ret)
end

function CreateVArr2s(Number,Size,Value,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		if Value[i] == nil then Value[i] = {} end
		table.insert(CreateVarPArr,{"VA2",PlayerID,Size,Value[i]})
		table.insert(ret,{"X",CreateVarXAlloc,0,"V",0,Size})
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return table.unpack(ret)
end

function CreateWArrs(Number,Size,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"WA",PlayerID,Size})
		table.insert(ret,{"X",CreateVarXAlloc,0,"W",0,Size})
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return table.unpack(ret)
end

function CreateWArr2s(Number,Size,Value,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		if Value[i] == nil then Value[i] = {} end
		table.insert(CreateVarPArr,{"WA2",PlayerID,Size,Value[i]})
		table.insert(ret,{"X",CreateVarXAlloc,0,"W",0,Size})
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return table.unpack(ret)
end

function CreateSVArrs(Numbers,Number,Size,PlayerID)
	local ret = {}
	for i = 1, Numbers do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"SVA",PlayerID,Size,Number})
		table.insert(ret,{"X",CreateVarXAlloc,0,"SA",Number,Size})
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return table.unpack(ret)
end

function CreateArrs(Number,Size,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"A",PlayerID,Size})
		table.insert(ret,{"X",CreateVarXAlloc,0,0})
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return table.unpack(ret)
end

function CreateLArrs(Number,Size,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"LA",PlayerID,Size})
		table.insert(ret,{"X",CreateVarXAlloc,0,0})
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return table.unpack(ret)
end

function CreateDbs(Number,ByteSize,PlayerID)
	return CreateArrs(Number,ByteSize/4,PlayerID)
end

function CreateLDbs(Number,ByteSize,PlayerID)
	return CreateLArrs(Number,ByteSize/4,PlayerID)
end

function CreateVArrArr(Number,Size,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"VA",PlayerID,Size})
		table.insert(ret,{"X",CreateVarXAlloc,0,"V",0,Size})
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return ret
end

function CreateVArrArr2(Number,Size,Value,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		if Value[i] == nil then Value[i] = {} end
		table.insert(CreateVarPArr,{"VA2",PlayerID,Size,Value[i]})
		table.insert(ret,{"X",CreateVarXAlloc,0,"V",0,Size})
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return ret
end

function CreateWArrArr(Number,Size,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"WA",PlayerID,Size})
		table.insert(ret,{"X",CreateVarXAlloc,0,"W",0,Size})
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return ret
end

function CreateWArrArr2(Number,Size,Value,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		if Value[i] == nil then Value[i] = {} end
		table.insert(CreateVarPArr,{"WA2",PlayerID,Size,Value[i]})
		table.insert(ret,{"X",CreateVarXAlloc,0,"W",0,Size})
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return ret
end

function CreateSVArrArr(Numbers,Number,Size,PlayerID)
	local ret = {}
	for i = 1, Numbers do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"SVA",PlayerID,Size,Number})
		table.insert(ret,{"X",CreateVarXAlloc,0,"SA",Number,Size})
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return ret
end

function CreateArrArr(Number,Size,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"A",PlayerID,Size})
		table.insert(ret,{"X",CreateVarXAlloc,0,0})
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return ret
end

function CreateLArrArr(Number,Size,PlayerID)
	local ret = {}
	for i = 1, Number do
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		if PlayerID == nil then
			PlayerID = AllPlayers
		end
		table.insert(CreateVarPArr,{"LA",PlayerID,Size})
		table.insert(ret,{"X",CreateVarXAlloc,0,0})
	end
	if type(PlayerID) == "number" then
		for k, v in pairs(ret) do
			v[1] = PlayerID
		end
	end
	return ret
end

function CreateDbArr(Number,ByteSize,PlayerID)
	return CreateArrArr(Number,ByteSize/4,PlayerID)
end

function CreateLDbArr(Number,ByteSize,PlayerID)
	return CreateLArrArr(Number,ByteSize/4,PlayerID)
end

function f_GetVoidptr(PlayerID,Size)
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	if Size < 1 then f_GetVoidptr_InputData_Error() end
	local Number = math.ceil(Size/0x970)
	Trigger {
		players = {P10,PlayerID},
		conditions = {
			Label(FuncAlloc);
			Never();
		},
		actions = {
			SetDeathsX(0,SetTo,Number,0,0);
		},
	}
	FuncAlloc = FuncAlloc + 1
	local Ret = {"X",FuncAlloc-1,0x970,0}
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end

function f_GetVArrptr(PlayerID,Size) -- Index 1, P11 (STRCTRIG)
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	if Size < 1 then f_GetVArrptr_InputData_Error() end
	Trigger {
		players = {P11,PlayerID},
		conditions = {
			Label(FuncAlloc);
			Never();
		},
		actions = {
			SetDeathsX(0,SetTo,Size,0,1);
		},
	}
	FuncAlloc = FuncAlloc + 1
	local Ret = {"X",FuncAlloc-1,1,"V",0,Size}
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end 

function f_GetWArrptr(PlayerID,Size) -- Index 2
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	if Size < 1 then f_GetWArrptr_InputData_Error() end
	Trigger {
		players = {P11,PlayerID},
		conditions = {
			Label(FuncAlloc);
			Never();
		},
		actions = {
			SetDeathsX(0,SetTo,Size,0,2);
		},
	}
	FuncAlloc = FuncAlloc + 1
	local Ret = {"X",FuncAlloc-1,1,"W",0,Size}
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end

function f_GetSVArrptr(PlayerID,Size,Number) -- Index 3 ~ 34
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	if Size < 1 then f_GetSVArrptr_InputData_Error() end
	if Number < 1 or Number > 33 then f_GetSVArrptr_InputData_Error() end
	Trigger {
		players = {P11,PlayerID},
		conditions = {
			Label(FuncAlloc);
			Never();
		},
		actions = {
			SetDeathsX(0,SetTo,Size,0,2+Number);
		},
	}
	FuncAlloc = FuncAlloc + 1
	local Ret = {"X",FuncAlloc-1,1,"SA",Number,Size}
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end 

FileDirectory = nil
function SetFileDirectory(AbsolutePath)
	FileDirectory = AbsolutePath.."\\"
end

function EncodeTableptr(PlayerID)
	function _cp949_to_utf8_Table(s)
	    local ret = {}
	    local i = 1
	    function readbyte_Table(s)
	        local ret = s[i]
	        i = i + 1
	        return ret
	    end
		
	    while true do
	        local b1 = readbyte_Table(s, i)
	        if b1 == 0 and i >= 4 then break end
	        if b1 < 128 then
	            ret[#ret+1] = b1
	        else
	            local b2 = readbyte_Table(s, i+1)
	            if b2 == 0 and i >= 4 then break end
	            local code = cvtb[b2 * 256 + b1]
	            if code == nil then code = 0 end
	            if code <= 0x07FF then
	                -- Encode as 2-byte
	                ret[#ret+1] = bitor(0xC0, bitand(math.floor(code / lshift(1, 6)), 0x1F)) + 0xC0
	                ret[#ret+1] = bitor(0x80, bitand(math.floor(code / lshift(1, 0)), 0x3F)) + 0x80
	            else
	                -- Encode as 3-byte
	                ret[#ret+1] = bitor(0xE0, bitand(math.floor(code / lshift(1, 12)), 0xF)) + 0xE0
	                ret[#ret+1] = bitor(0x80, bitand(math.floor(code / lshift(1, 6)), 0x3F)) + 0x80
	                ret[#ret+1] = bitor(0x80, bitand(math.floor(code / lshift(1, 0)), 0x3F)) + 0x80
	            end
	        end
	    end
	    ret[#ret+1] = 0
	    return ret
	end
	local FilePath = FileDirectory.."icp949utf8.EncodeTable"

	local Fileptr = io.open(FilePath, "rb")
	if Fileptr == nil then
		local Fileptr = io.open(FilePath, "wb")
		for k = 1, 0x20000 do
			Fileptr:write(string.char(0xD))
			Fileptr:write(string.char(0xD))
			Fileptr:write(string.char(0xD))
			Fileptr:write(string.char(0xD))
		end
		for i = 0x8141, 0xFDFE do
			local Retx = _cp949_to_utf8_Table({bit32.band(i,0xFF00)/256,bit32.band(i,0xFF),0x0})
			local UCode = bit32.band(Retx[1],0xF)*0x1000+((Retx[2]-0x80)*0x40)+(bit32.band(Retx[3],0xF0)-0x80)+bit32.band(Retx[3],0xF)
			if UCode > 0 and UCode < 0x20000 then
				Fileptr:seek("set",UCode*4+2)
				Fileptr:write(string.char(bit32.band(i,0xFF00)/256))
				Fileptr:write(string.char(bit32.band(i,0xFF)))
			end
		end

		Fileptr:seek("set",0x20000*4)
		for i = 0x8141, 0xFDFE do
			Fileptr:write(string.char(0xD))
			Fileptr:write(string.char(0xD))
			Fileptr:write(string.char(0xD))
			Fileptr:write(string.char(0xD))
		end
		for i = 0x8141, 0xFDFE do
			local Retx = _cp949_to_utf8_Table({bit32.band(i,0xFF00)/256,bit32.band(i,0xFF),0x0})
			if Retx[3] ~= 0 then 
				Fileptr:seek("set",(i-0x8141)*4+1+0x80000)
				Fileptr:write(string.char(Retx[1]))
				Fileptr:write(string.char(Retx[2]))
				Fileptr:write(string.char(Retx[3]))
			end
		end
		io.close(Fileptr)
	else
		io.close(Fileptr)
	end

	local FileAct = {}
	local ret = {}
	for i = 1, #FilePath do
		table.insert(ret,string.byte(FilePath,i))
	end

	local k = 1
	while true do
		local Value, Mask
		local prt = {0,0,0,0,0,0,0,0}
		for i = 0, 7 do
			if ret[k+i] ~= nil then
				prt[i+1] = ret[k+i]
			end
		end
		Mask = prt[1] + bit32.lshift(prt[2],8) + bit32.lshift(prt[3],16) + bit32.lshift(prt[4],24)
		Value = prt[5] + bit32.lshift(prt[6],8) + bit32.lshift(prt[7],16) + bit32.lshift(prt[8],24)
		table.insert(FileAct,SetDeathsX(1,SetTo,Value,0,Mask))
		k = k+8
		if k > #ret then break end
	end

	Trigger {
		players = {P9,PlayerID},
		conditions = {
			Label(EncodeTable[2]);
			Never();
		},
		actions = {
			FileAct;
		},
	}
end

function f_GetFileptr(PlayerID,FileName,LoadCheck)
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	local FileAct = {}
	local FilePath = FileDirectory..FileName
	local ret = {}
	for i = 1, #FilePath do
		table.insert(ret,string.byte(FilePath,i))
	end

	local k = 1
	while true do
		local Value, Mask
		local prt = {0,0,0,0,0,0,0,0}
		for i = 0, 7 do
			if ret[k+i] ~= nil then
				prt[i+1] = ret[k+i]
			end
		end
		Mask = prt[1] + bit32.lshift(prt[2],8) + bit32.lshift(prt[3],16) + bit32.lshift(prt[4],24)
		Value = prt[5] + bit32.lshift(prt[6],8) + bit32.lshift(prt[7],16) + bit32.lshift(prt[8],24)
		table.insert(FileAct,SetDeathsX(1,SetTo,Value,0,Mask))
		k = k+8
		if k > #ret then break end
	end

	Trigger {
		players = {P9,PlayerID},
		conditions = {
			Label(FuncAlloc);
			Never();
		},
		actions = {
			FileAct;
		},
	}
	FuncAlloc = FuncAlloc + 1
	if LoadCheck == 1 then
		local Check = f_GetFileSize(FileName)
	end
	local Ret = {"X",FuncAlloc-1,0x970,0}
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end

function f_GetFileSize(FileName)
	local FilePath = FileDirectory..FileName
	local Fileptr = io.open(FilePath, "rb")
	if Fileptr == nil then
		PushErrorMsg(FilePath.."\nDoesn't Exist!")
	end
    local size = Fileptr:seek("end")    -- get file size
	io.close(Fileptr)
	return size
end

function FArr(Fileptr,Index,Player) -- 1, V, _Mov(VArr()) 사용
	if type(Player) == "table" then
		FArr_InputData_Error()
	end
	if Player == nil then
		Player = "X"
	else
		Fileptr[1] = Player
	end

	if type(Index) == "number" then
		return {Player,Fileptr[2],Index*4+2416,0}
	elseif Index[4] == "V" then
		return {Index[1],Index[2],Index[3],"A",Fileptr}
	else
		FArr_InputData_Error()
	end
end

FileNameIndex = 0
function f_GetFileArrptr(PlayerID,FileArray,ElementSize,LoadCheck)
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	local Ret
	local FileName = "SCTRIGASMFILE"
	local HEX = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'}
	if FileNameIndex < 0x10 then
		FileName = FileName.."000"..HEX[FileNameIndex+1]
	elseif FileNameIndex < 0x100 then
		FileName = FileName.."00"..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF0),4)+1]..HEX[bit32.band(FileNameIndex, 0xF)+1]
	elseif FileNameIndex < 0x1000 then
		FileName = FileName.."0"..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF00),8)+1]..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF0),4)+1]..HEX[bit32.band(FileNameIndex, 0xF)+1]
	elseif FileNameIndex < 0x10000 then
		FileName = FileName..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF000),12)+1]..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF00),8)+1]..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF0),4)+1]..HEX[bit32.band(FileNameIndex, 0xF)+1]
	else
		FILEIndex_Overflow()
	end
	SaveFileArr(FileArray,ElementSize,FileName)
	Ret = f_GetFileptr(PlayerID,FileName,LoadCheck)
	FileNameIndex = FileNameIndex + 1
	return Ret
end

function SaveFileArr(FileArray,ElementSize,FileName)
	local FilePath = FileDirectory..FileName
	local Fileptr = io.open(FilePath, "wb")
	if Fileptr == nil then
		PushErrorMsg(FilePath.."\nCan't be Open!")
	end

	local FileSTR = ""
	local STRLength = 0
    for i = 1, #FileArray do
    	if ElementSize == 1 then
	    	FileSTR = FileSTR .. string.char(FileArray[i])
	    	STRLength = STRLength + 1
	    elseif ElementSize == 2 then
	    	FileSTR = FileSTR .. string.char(bit32.band(FileArray[i], 0xFF),bit32.rshift(bit32.band(FileArray[i], 0xFF00),8))
	    	STRLength = STRLength + 2
	    elseif ElementSize == 3 then
	    	FileSTR = FileSTR .. string.char(bit32.band(FileArray[i], 0xFF),bit32.rshift(bit32.band(FileArray[i], 0xFF00),8),bit32.rshift(bit32.band(FileArray[i], 0xFF0000),16))
	    	STRLength = STRLength + 3
	    elseif ElementSize == 4 then
	    	FileSTR = FileSTR .. string.char(bit32.band(FileArray[i], 0xFF),bit32.rshift(bit32.band(FileArray[i], 0xFF00),8),bit32.rshift(bit32.band(FileArray[i], 0xFF0000),16),bit32.rshift(bit32.band(FileArray[i], 0xFF000000),24))
	    	STRLength = STRLength + 4
	    else
	    	SaveFileArr_InputData_Error()
		end
		if STRLength >= 4096 then
    		Fileptr:write(FileSTR)
    		STRLength = 0
    		FileSTR = ""
    	end
    end
    if STRLength >= 1 then
    	Fileptr:write(FileSTR)
    end
    local size = Fileptr:seek("end")
	io.close(Fileptr)
	return size
end

function f_GetFileptrN(PlayerID,FileName,Repeat,LoadCheck) -- 1st EPD = N
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	if Repeat < 1 then 
		f_GetFileptrN_InputData_Error()
	end
	local FileAct = {}
	local FilePath = FileDirectory..FileName
	local ret = {}
	for i = 1, #FilePath do
		table.insert(ret,string.byte(FilePath,i))
	end

	local k = 1
	while true do
		local Value, Mask
		local prt = {0,0,0,0,0,0,0,0}
		for i = 0, 7 do
			if ret[k+i] ~= nil then
				prt[i+1] = ret[k+i]
			end
		end
		Mask = prt[1] + bit32.lshift(prt[2],8) + bit32.lshift(prt[3],16) + bit32.lshift(prt[4],24)
		Value = prt[5] + bit32.lshift(prt[6],8) + bit32.lshift(prt[7],16) + bit32.lshift(prt[8],24)
		table.insert(FileAct,SetDeathsX(Repeat,SetTo,Value,0,Mask))
		k = k+8
		if k > #ret then break end
	end

	Trigger {
		players = {P9,PlayerID},
		conditions = {
			Label(FuncAlloc);
			Never();
		},
		actions = {
			FileAct;
		},
	}
	FuncAlloc = FuncAlloc + 1
	if LoadCheck == 1 then
		local Check = f_GetFileSize(FileName)
	end
	local Ret = {"X",FuncAlloc-1,0x970,0}
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end

function f_GetTRIGptrN(PlayerID,FileName,Repeat,LoadCheck) -- 1st EPD = N
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	if Repeat < 1 then 
		f_GetFileptrN_InputData_Error()
	end
	local FileAct = {}
	local FilePath = FileDirectory..FileName
	local ret = {}
	for i = 1, #FilePath do
		table.insert(ret,string.byte(FilePath,i))
	end

	local k = 1
	while true do
		local Value, Mask
		local prt = {0,0,0,0,0,0,0,0}
		for i = 0, 7 do
			if ret[k+i] ~= nil then
				prt[i+1] = ret[k+i]
			end
		end
		Mask = prt[1] + bit32.lshift(prt[2],8) + bit32.lshift(prt[3],16) + bit32.lshift(prt[4],24)
		Value = prt[5] + bit32.lshift(prt[6],8) + bit32.lshift(prt[7],16) + bit32.lshift(prt[8],24)
		table.insert(FileAct,SetDeathsX(Repeat,SetTo,Value,0,Mask))
		k = k+8
		if k > #ret then break end
	end

	Trigger {
		players = {P12,PlayerID},
		conditions = {
			Label(FuncAlloc);
			Never();
		},
		actions = {
			FileAct;
		},
	}
	FuncAlloc = FuncAlloc + 1
	if LoadCheck == 1 then
		local Check = f_GetFileSize(FileName)
	end
	local Ret = {"X",FuncAlloc-1,0x970,0}
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end

function f_GetFileArrptrN(PlayerID,FileArray,ElementSize,Repeat,LoadCheck)
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	local Ret
	local FileName = "SCTRIGASMFILE"
	local HEX = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'}
	if FileNameIndex < 0x10 then
		FileName = FileName.."000"..HEX[FileNameIndex+1]
	elseif FileNameIndex < 0x100 then
		FileName = FileName.."00"..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF0),4)+1]..HEX[bit32.band(FileNameIndex, 0xF)+1]
	elseif FileNameIndex < 0x1000 then
		FileName = FileName.."0"..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF00),8)+1]..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF0),4)+1]..HEX[bit32.band(FileNameIndex, 0xF)+1]
	elseif FileNameIndex < 0x10000 then
		FileName = FileName..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF000),12)+1]..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF00),8)+1]..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF0),4)+1]..HEX[bit32.band(FileNameIndex, 0xF)+1]
	else
		FILEIndex_Overflow()
	end
	SaveFileArr(FileArray,ElementSize,FileName)
	Ret = f_GetFileptrN(PlayerID,FileName,Repeat,LoadCheck)
	FileNameIndex = FileNameIndex + 1
	return Ret
end

__VArrSTR = {"","","",""}
__VArrCheck = 0 
__WArrSTR = {"","","","","",""}
__WArrCheck = 0 
__SVArrSTR = {"","","","","","","",""}
__SVArrCheck = 0 
function f_GetFileVArrptrN(PlayerID,FileArray,ElementSize,Repeat,LoadCheck)
	if __VArrCheck == 0 then
		__VArrCheck = 1
		for j = 1, 0x16 do
			__VArrSTR[1] = __VArrSTR[1] .. "\0"
		end
		__VArrSTR[1] = __VArrSTR[1] .. "\x0A\xFE\x00\x02"
		for j = 1, 0x12E do
			__VArrSTR[1] = __VArrSTR[1] .. "\0"
		end

		__VArrSTR[2] = __VArrSTR[2] .. "\0\0\x2D\x07\x14\0\x53\x43\xFF\xFF\xFF\xFF"
		__VArrSTR[3] = __VArrSTR[3] .. "\0\0\x2D\x07\x16\0\x53\x43\xFF\xFF\xFF\xFF"

		for j = 1, 0x16 do
			__VArrSTR[2] = __VArrSTR[2] .. "\0"
		end
		for j = 1, 0xC do
			__VArrSTR[3] = __VArrSTR[3] .. "\0"
		end

		__VArrSTR[2] = __VArrSTR[2] .. "\x2D\x07\x16\0\x53\x43"
		__VArrSTR[3] = __VArrSTR[3] .. "\x93\x19\x03\0\x01\0\0\0\0\0\x2D\x08\x14\0\x53\x43\x02"

		for j = 1, 7 do
			__VArrSTR[3] = __VArrSTR[3] .. "\0"
		end
		__VArrSTR[3] = __VArrSTR[3] .. "\x20"
		for j = 1, 7 do
			__VArrSTR[3] = __VArrSTR[3] .. "\0"
		end
		__VArrSTR[3] = __VArrSTR[3] .. "\x59\0\0\0\x02\0\0\0\0\0\x05\x07\x14\0\x53\x43"

		for j = 1, 0x7C0 do
			__VArrSTR[2] = __VArrSTR[2] .. "\0"
		end
		for j = 1, 0x7A0 do
			__VArrSTR[3] = __VArrSTR[3] .. "\0"
		end

		__VArrSTR[2] = __VArrSTR[2] .. "\x04\0\0\0"
		__VArrSTR[3] = __VArrSTR[3] .. "\x04\0\0\0"

		for j = 1, 0x1C do
			__VArrSTR[4] = __VArrSTR[4] .. "\0"
		end
	end

	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	local SVA1 = 0
	if Repeat == "SVA1" then
		SVA1 = 1
		Repeat = 1
	end
	local Ret
	local FileName = "SCTRIGASMFILE"
	local HEX = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'}
	if FileNameIndex < 0x10 then
		FileName = FileName.."000"..HEX[FileNameIndex+1]
	elseif FileNameIndex < 0x100 then
		FileName = FileName.."00"..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF0),4)+1]..HEX[bit32.band(FileNameIndex, 0xF)+1]
	elseif FileNameIndex < 0x1000 then
		FileName = FileName.."0"..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF00),8)+1]..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF0),4)+1]..HEX[bit32.band(FileNameIndex, 0xF)+1]
	elseif FileNameIndex < 0x10000 then
		FileName = FileName..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF000),12)+1]..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF00),8)+1]..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF0),4)+1]..HEX[bit32.band(FileNameIndex, 0xF)+1]
	else
		FILEIndex_Overflow()
	end

	local FilePath = FileDirectory..FileName
	local Fileptr = io.open(FilePath, "wb")
	if Fileptr == nil then
		PushErrorMsg(FilePath.."\nCan't be Open!")
	end

	local i = 1
	local TCount = 0
	while true do
		local VArrSTR = ""
		VArrSTR = VArrSTR .. __VArrSTR[1]

		if ElementSize == 1 then
			if i == #FileArray then
				VArrSTR = VArrSTR .. "\xFF\0\0\0"
			elseif i+1 == #FileArray then
				VArrSTR = VArrSTR .. "\xFF\xFF\0\0"
			elseif i+2 == #FileArray then
				VArrSTR = VArrSTR .. "\xFF\xFF\xFF\0"
			else
				VArrSTR = VArrSTR .. "\xFF\xFF\xFF\xFF"
			end
		elseif ElementSize == 2 then
			if i == #FileArray then
				VArrSTR = VArrSTR .. "\xFF\xFF\0\0"
			else
				VArrSTR = VArrSTR .. "\xFF\xFF\xFF\xFF"
			end
		elseif ElementSize == 4 then
			VArrSTR = VArrSTR .. "\xFF\xFF\xFF\xFF"
		else
			f_GetFileVArrptrN_InputData_Error()
		end

		if SVA1 == 0 then
			VArrSTR = VArrSTR .. "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
		else
			VArrSTR = VArrSTR .. "\0\0\0\0\0\0\0\0\0\0\0\0\x0D\0\0\0"
		end

		if ElementSize == 1 then
			local addr = 1 
	    	VArrSTR = VArrSTR .. string.char(FileArray[i])
	    	if FileArray[i+1] ~= nil then
		    	VArrSTR = VArrSTR .. string.char(FileArray[i+1])
		    	addr = 2
		    else
		    	VArrSTR = VArrSTR .. "\0"
		    end
		    if FileArray[i+2] ~= nil then
		    	VArrSTR = VArrSTR .. string.char(FileArray[i+2])
		    	addr = 3
		    else
		    	VArrSTR = VArrSTR .. "\0"
		    end
		    if FileArray[i+3] ~= nil then
		    	VArrSTR = VArrSTR .. string.char(FileArray[i+3])
		    	addr = 4
		    else
		    	VArrSTR = VArrSTR .. "\0"
		    end
		    i = i + addr
	    elseif ElementSize == 2 then
	    	local addr = 1 
	    	VArrSTR = VArrSTR .. string.char(bit32.band(FileArray[i], 0xFF),bit32.rshift(bit32.band(FileArray[i], 0xFF00),8))
	    	if FileArray[i+1] ~= nil then
		    	VArrSTR = VArrSTR .. string.char(bit32.band(FileArray[i+1], 0xFF),bit32.rshift(bit32.band(FileArray[i+1], 0xFF00),8))
		    	addr = 2
		    else
		    	VArrSTR = VArrSTR .. "\0\0"
		    end
		    i = i + addr
	    elseif ElementSize == 4 then
	    	VArrSTR = VArrSTR .. string.char(bit32.band(FileArray[i], 0xFF),bit32.rshift(bit32.band(FileArray[i], 0xFF00),8),bit32.rshift(bit32.band(FileArray[i], 0xFF0000),16),bit32.rshift(bit32.band(FileArray[i], 0xFF000000),24))
	    	i = i + 1
	    else
	    	f_GetFileVArrptrN_InputData_Error()
		end

		if SVA1 == 0 then
			VArrSTR = VArrSTR .. __VArrSTR[2]
		else
			VArrSTR = VArrSTR .. __VArrSTR[3]
		end
		
		local PlayerArr = PlayerConvert2(PlayerID)
		for j = 1, 8 do
			if (PlayerArr[j] == 0) then
				VArrSTR = VArrSTR .. "\x01"
			else
				VArrSTR = VArrSTR .."\0"
			end
		end

		VArrSTR = VArrSTR .. __VArrSTR[4]
		Fileptr:write(VArrSTR)

		TCount = TCount + 1
		if i > #FileArray then break end
	end

	io.close(Fileptr)
	if SVA1 == 1 then
		Ret = f_GetTRIGptrN(PlayerID,FileName,Repeat,LoadCheck)
	else
		Ret = f_GetFileptrN(PlayerID,FileName,Repeat,LoadCheck)
	end
	FileNameIndex = FileNameIndex + 1
	local Rett = {"X",Ret[2],1,"V",0,TCount}
	if type(PlayerID) == "number" then
		Rett[1] = PlayerID
	end
	return Rett
end

function f_GetFileWArrptrN(PlayerID,FileArray,ElementSize,Repeat,LoadCheck)
	if __WArrCheck == 0 then
		__WArrCheck = 1
		for j = 1, 0x16 do
			__WArrSTR[1] = __WArrSTR[1] .. "\0"
		end
		__WArrSTR[1] = __WArrSTR[1] .. "\x0A\xFE\x00\x02"
		for j = 1, 0x12E do
			__WArrSTR[1] = __WArrSTR[1] .. "\0"
		end

		__WArrSTR[2] = __WArrSTR[2] .. "\0\0\x2D\x07\x14\0\x53\x43\xFF\xFF\xFF\xFF"
		__WArrSTR[3] = __WArrSTR[3] .. "\0\0\x2D\x07\x14\0\x53\x43\xFF\xFF\xFF\xFF"

		for j = 1, 0xC do
			__WArrSTR[2] = __WArrSTR[2] .. "\0"
		end
		for j = 1, 0xC do
			__WArrSTR[3] = __WArrSTR[3] .. "\0"
		end

		__WArrSTR[2] = __WArrSTR[2] .. "\0\0\0\0\0\0\0\0\0\0\x2D\x07\x16\0\x53\x43"
		__WArrSTR[3] = __WArrSTR[3] .. "\x93\x19\x03\0\x01\0\0\0\0\0\x2D\x08\x16\0\x53\x43"

		for j = 1, 0x1A do
			__WArrSTR[4] = __WArrSTR[4] .. "\0"
		end
		__WArrSTR[4] = __WArrSTR[4] .. "\x2D\x07\x16\0\x53\x43\xFF\xFF\xFF\xFF"
		for j = 1, 0xC do
			__WArrSTR[4] = __WArrSTR[4] .. "\0"
		end
		__WArrSTR[4] = __WArrSTR[4] .. "\x93\x19\x03\0\x01\0\0\0\0\0\x2D\x08\x16\0\x53\x43"

		local R = 0x800 - 0x40*2
		for j = 1, R do
			__WArrSTR[5] = __WArrSTR[5] .. "\0"
		end
		__WArrSTR[5] = __WArrSTR[5] .. "\x04\0\0\0"

		for j = 1, 0x1C do
			__WArrSTR[6] = __WArrSTR[6] .. "\0"
		end
	end


	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	local Ret
	local FileName = "SCTRIGASMFILE"
	local HEX = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'}
	if FileNameIndex < 0x10 then
		FileName = FileName.."000"..HEX[FileNameIndex+1]
	elseif FileNameIndex < 0x100 then
		FileName = FileName.."00"..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF0),4)+1]..HEX[bit32.band(FileNameIndex, 0xF)+1]
	elseif FileNameIndex < 0x1000 then
		FileName = FileName.."0"..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF00),8)+1]..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF0),4)+1]..HEX[bit32.band(FileNameIndex, 0xF)+1]
	elseif FileNameIndex < 0x10000 then
		FileName = FileName..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF000),12)+1]..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF00),8)+1]..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF0),4)+1]..HEX[bit32.band(FileNameIndex, 0xF)+1]
	else
		FILEIndex_Overflow()
	end

	local FilePath = FileDirectory..FileName
	local Fileptr = io.open(FilePath, "wb")
	if Fileptr == nil then
		PushErrorMsg(FilePath.."\nCan't be Open!")
	end

	local i = 1
	local TCount = 0
	while true do
		local WArrSTR = ""
		WArrSTR = WArrSTR .. __WArrSTR[1]
		
---------------------------------------------------------
		for k = 1, 2 do 
			if i <= #FileArray then
				if ElementSize == 1 then
					if i == #FileArray then
						WArrSTR = WArrSTR .. "\xFF\0\0\0"
					elseif i+1 == #FileArray then
						WArrSTR = WArrSTR .. "\xFF\xFF\0\0"
					elseif i+2 == #FileArray then
						WArrSTR = WArrSTR .. "\xFF\xFF\xFF\0"
					else
						WArrSTR = WArrSTR .. "\xFF\xFF\xFF\xFF"
					end
				elseif ElementSize == 2 then
					if i == #FileArray then
						WArrSTR = WArrSTR .. "\xFF\xFF\0\0"
					else
						WArrSTR = WArrSTR .. "\xFF\xFF\xFF\xFF"
					end
				elseif ElementSize == 4 then
					WArrSTR = WArrSTR .. "\xFF\xFF\xFF\xFF"
				else
					f_GetFileWArrptrN_InputData_Error()
				end

				WArrSTR = WArrSTR .. "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"

				if ElementSize == 1 then
					local addr = 1 
			    	WArrSTR = WArrSTR .. string.char(FileArray[i])
			    	if FileArray[i+1] ~= nil then
				    	WArrSTR = WArrSTR .. string.char(FileArray[i+1])
				    	addr = 2
				    else
				    	WArrSTR = WArrSTR .. "\0"
				    end
				    if FileArray[i+2] ~= nil then
				    	WArrSTR = WArrSTR .. string.char(FileArray[i+2])
				    	addr = 3
				    else
				    	WArrSTR = WArrSTR .. "\0"
				    end
				    if FileArray[i+3] ~= nil then
				    	WArrSTR = WArrSTR .. string.char(FileArray[i+3])
				    	addr = 4
				    else
				    	WArrSTR = WArrSTR .. "\0"
				    end
				    i = i + addr
			    elseif ElementSize == 2 then
			    	local addr = 1 
			    	WArrSTR = WArrSTR .. string.char(bit32.band(FileArray[i], 0xFF),bit32.rshift(bit32.band(FileArray[i], 0xFF00),8))
			    	if FileArray[i+1] ~= nil then
				    	WArrSTR = WArrSTR .. string.char(bit32.band(FileArray[i+1], 0xFF),bit32.rshift(bit32.band(FileArray[i+1], 0xFF00),8))
				    	addr = 2
				    else
				    	WArrSTR = WArrSTR .. "\0\0"
				    end
				    i = i + addr
			    elseif ElementSize == 4 then
			    	WArrSTR = WArrSTR .. string.char(bit32.band(FileArray[i], 0xFF),bit32.rshift(bit32.band(FileArray[i], 0xFF00),8),bit32.rshift(bit32.band(FileArray[i], 0xFF0000),16),bit32.rshift(bit32.band(FileArray[i], 0xFF000000),24))
			    	i = i + 1
			    else
			    	f_GetFileWArrptrN_InputData_Error()
				end

				if k == 2 then
					WArrSTR = WArrSTR .. __WArrSTR[2]
				else
					WArrSTR = WArrSTR .. __WArrSTR[3]
				end
			else
				WArrSTR = WArrSTR .. __WArrSTR[4]
			end
		end
		WArrSTR = WArrSTR .. __WArrSTR[5]
		
		local PlayerArr = PlayerConvert2(PlayerID)
		for j = 1, 8 do
			if (PlayerArr[j] == 1) then
				WArrSTR = WArrSTR .. "\x01"
			else
				WArrSTR = WArrSTR .."\0"
			end
		end
		WArrSTR = WArrSTR .. __WArrSTR[6]
		Fileptr:write(WArrSTR)
		TCount = TCount + 1
		if i > #FileArray then break end
	end
	io.close(Fileptr)
	Ret = f_GetFileptrN(PlayerID,FileName,Repeat,LoadCheck)
	FileNameIndex = FileNameIndex + 1
	local Rett = {"X",Ret[2],1,"W",0,TCount}
	if type(PlayerID) == "number" then
		Rett[1] = PlayerID
	end
	return Rett
end

function f_GetFileSVArrptrN(PlayerID,FileArray,ElementSize,Number,Repeat,LoadCheck)
	if __SVArrCheck == 0 then
		__SVArrCheck = 1
		for j = 1, 0x16 do
			__SVArrSTR[1] = __SVArrSTR[1] .. "\0"
		end
		__SVArrSTR[1] = __SVArrSTR[1] .. "\x0A\xFE\x00\x02"
		for j = 1, 0x12E do
			__SVArrSTR[1] = __SVArrSTR[1] .. "\0"
		end

		__SVArrSTR[2] = __SVArrSTR[2] .. "\0\0\x2D\x07\x14\0\x53\x43\xFF\xFF\xFF\xFF"
		__SVArrSTR[3] = __SVArrSTR[3] .. "\0\0\x2D\x07\x14\0\x53\x43\xFF\xFF\xFF\xFF"
		__SVArrSTR[4] = __SVArrSTR[4] .. "\0\0\x2D\x07\x14\0\x53\x43\xFF\xFF\xFF\xFF"
		__SVArrSTR[5] = __SVArrSTR[5] .. "\0\0\x2D\x07\x14\0\x53\x43\xFF\xFF\xFF\xFF"

		for j = 1, 0xC do
			__SVArrSTR[2] = __SVArrSTR[2] .. "\0"
			__SVArrSTR[3] = __SVArrSTR[3] .. "\0"
			__SVArrSTR[4] = __SVArrSTR[4] .. "\0"
			__SVArrSTR[5] = __SVArrSTR[5] .. "\0"
		end
		__SVArrSTR[4] = __SVArrSTR[4] .. "\x93\x19\x03\0\x01\0\0\0\0\0\x2D\x08\x14\0\x53\x43"
		__SVArrSTR[5] = __SVArrSTR[5] .. "\x93\x19\x03\0\x08\0\0\0\0\0\x2D\x08\x14\0\x53\x43"
		__SVArrSTR[2] = __SVArrSTR[2] .. "\0\0\0\0\0\0\0\0\0\0\x2D\x07\x16\0\x53\x43"
		__SVArrSTR[3] = __SVArrSTR[3] .. "\x93\x19\x03\0\x01\0\0\0\0\0\x2D\x08\x16\0\x53\x43"

		for j = 1, 0x1A do
			__SVArrSTR[6] = __SVArrSTR[6] .. "\0"
		end
		__SVArrSTR[6] = __SVArrSTR[6] .. "\x2D\x07\x16\0\x53\x43\xFF\xFF\xFF\xFF"
		for j = 1, 0xC do
			__SVArrSTR[6] = __SVArrSTR[6] .. "\0"
		end
		__SVArrSTR[6] = __SVArrSTR[6] .. "\x93\x19\x03\0\x01\0\0\0\0\0\x2D\x08\x16\0\x53\x43"

		for j = 1, 0x40 do
			__SVArrSTR[7] = __SVArrSTR[7] .. "\0"
		end

		for j = 1, 0x1C do
			__SVArrSTR[8] = __SVArrSTR[8] .. "\0"
		end
	end

	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	local SVA32 = 0
	local SVA32X
	if Repeat == "SVA32" then
		SVA32 = 1
		Repeat = 1
		SVA32X = 1
	elseif Repeat == "SVA32X" then
		SVA32 = 1
		Repeat = 1
		SVA32X = 8
	end
	local Ret
	local FileName = "SCTRIGASMFILE"
	local HEX = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'}
	if FileNameIndex < 0x10 then
		FileName = FileName.."000"..HEX[FileNameIndex+1]
	elseif FileNameIndex < 0x100 then
		FileName = FileName.."00"..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF0),4)+1]..HEX[bit32.band(FileNameIndex, 0xF)+1]
	elseif FileNameIndex < 0x1000 then
		FileName = FileName.."0"..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF00),8)+1]..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF0),4)+1]..HEX[bit32.band(FileNameIndex, 0xF)+1]
	elseif FileNameIndex < 0x10000 then
		FileName = FileName..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF000),12)+1]..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF00),8)+1]..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF0),4)+1]..HEX[bit32.band(FileNameIndex, 0xF)+1]
	else
		FILEIndex_Overflow()
	end

	local FilePath = FileDirectory..FileName
	local Fileptr = io.open(FilePath, "wb")
	if Fileptr == nil then
		PushErrorMsg(FilePath.."\nCan't be Open!")
	end

	local i = 1
	local TCount = 0
	while true do
		local SVArrSTR = ""
		SVArrSTR = SVArrSTR .. __SVArrSTR[1]

---------------------------------------------------------
		for k = 1, Number do 
			if i <= #FileArray then
				if ElementSize == 1 then
					if i == #FileArray then
						SVArrSTR = SVArrSTR .. "\xFF\0\0\0"
					elseif i+1 == #FileArray then
						SVArrSTR = SVArrSTR .. "\xFF\xFF\0\0"
					elseif i+2 == #FileArray then
						SVArrSTR = SVArrSTR .. "\xFF\xFF\xFF\0"
					else
						SVArrSTR = SVArrSTR .. "\xFF\xFF\xFF\xFF"
					end
				elseif ElementSize == 2 then
					if i == #FileArray then
						SVArrSTR = SVArrSTR .. "\xFF\xFF\0\0"
					else
						SVArrSTR = SVArrSTR .. "\xFF\xFF\xFF\xFF"
					end
				elseif ElementSize == 4 then
					SVArrSTR = SVArrSTR .. "\xFF\xFF\xFF\xFF"
				else
					f_GetFileSVArrptrN_InputData_Error()
				end

				if SVA32 == 0 then
					SVArrSTR = SVArrSTR .. "\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0"
				else
					SVArrSTR = SVArrSTR .. "\0\0\0\0\0\0\0\0\0\0\0\0\x0D\0\0\0"
				end

				if ElementSize == 1 then
					local addr = 1 
			    	SVArrSTR = SVArrSTR .. string.char(FileArray[i])
			    	if FileArray[i+1] ~= nil then
				    	SVArrSTR = SVArrSTR .. string.char(FileArray[i+1])
				    	addr = 2
				    else
				    	SVArrSTR = SVArrSTR .. "\0"
				    end
				    if FileArray[i+2] ~= nil then
				    	SVArrSTR = SVArrSTR .. string.char(FileArray[i+2])
				    	addr = 3
				    else
				    	SVArrSTR = SVArrSTR .. "\0"
				    end
				    if FileArray[i+3] ~= nil then
				    	SVArrSTR = SVArrSTR .. string.char(FileArray[i+3])
				    	addr = 4
				    else
				    	SVArrSTR = SVArrSTR .. "\0"
				    end
				    i = i + addr
			    elseif ElementSize == 2 then
			    	local addr = 1 
			    	SVArrSTR = SVArrSTR .. string.char(bit32.band(FileArray[i], 0xFF),bit32.rshift(bit32.band(FileArray[i], 0xFF00),8))
			    	if FileArray[i+1] ~= nil then
				    	SVArrSTR = SVArrSTR .. string.char(bit32.band(FileArray[i+1], 0xFF),bit32.rshift(bit32.band(FileArray[i+1], 0xFF00),8))
				    	addr = 2
				    else
				    	SVArrSTR = SVArrSTR .. "\0\0"
				    end
				    i = i + addr
			    elseif ElementSize == 4 then
			    	SVArrSTR = SVArrSTR .. string.char(bit32.band(FileArray[i], 0xFF),bit32.rshift(bit32.band(FileArray[i], 0xFF00),8),bit32.rshift(bit32.band(FileArray[i], 0xFF0000),16),bit32.rshift(bit32.band(FileArray[i], 0xFF000000),24))
			    	i = i + 1
			    else
			    	f_GetFileSVArrptrN_InputData_Error()
				end

				if SVA32 == 0 then
					if k == Number then
						SVArrSTR = SVArrSTR .. __SVArrSTR[2]
					else
						SVArrSTR = SVArrSTR .. __SVArrSTR[3]
					end
				else
					if SVA32X == 1 then
						SVArrSTR = SVArrSTR .. __SVArrSTR[4]
					else
						SVArrSTR = SVArrSTR .. __SVArrSTR[5]
					end
				end
			else
				SVArrSTR = SVArrSTR .. __SVArrSTR[6]
			end
		end

		local R = 32 - Number
		for j = 1, R do
			SVArrSTR = SVArrSTR .. __SVArrSTR[7]
		end
		SVArrSTR = SVArrSTR .. "\x04\0\0\0"

		local PlayerArr = PlayerConvert2(PlayerID)
		for j = 1, 8 do
			if (PlayerArr[j] == 1) then
				SVArrSTR = SVArrSTR .. "\x01"
			else
				SVArrSTR = SVArrSTR .. "\0"
			end
		end
		SVArrSTR = SVArrSTR .. __SVArrSTR[8]
		Fileptr:write(SVArrSTR)
		TCount = TCount + 1
		if i > #FileArray then break end
	end

	io.close(Fileptr)
	Ret = f_GetFileptrN(PlayerID,FileName,Repeat,LoadCheck)
	FileNameIndex = FileNameIndex + 1
	local Rett = {"X",Ret[2],1,"SA",Number,TCount}
	if type(PlayerID) == "number" then
		Rett[1] = PlayerID
	end
	return Rett
end

function NPA5(PlayerID,Pointer,Fileptr,Size,DestDistance,SourceDistance)
	local Source
	if Fileptr[4] == "V" then
		SourceDistance = SourceDistance*604
	else
		Source = Fileptr
	end
	f_MemcpyEPD(PlayerID,_EPDReadF(Pointer),Source,Size,DestDistance,SourceDistance) 
end

CFuncPlayer = "X"
CFuncIndex = "X"
CFuncArr = {}
CFuncptr = 0

function InitCFunc(PlayerID,Parameter)
	if type(PlayerID) ~= "number" then
		InitCFunc_InputData_Error()
	end

	if Parameter == "X" or Parameter == nil then
		Parameter = nil
	else
		Parameter = CreateVarArr(Parameter,FixPlayer)
	end

	local CFuncData = {PlayerID,FuncAlloc,Parameter}
	FuncAlloc = FuncAlloc + 2
	return CFuncData
end

function CFunc(CFunction)
	CFuncPlayer = CFunction[1]
	CFuncIndex = CFunction[2]+1
	local Parameter = CFunction[3]
	Trigger {
		players = {CFuncPlayer},
		conditions = {
			Label(CFuncIndex-1);
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",CFuncIndex,0x0,0,1);
		},
		flag = {Preserved}
	}
	table.insert(CFuncArr,CFuncIndex)
	CFuncptr = CFuncptr + 1

	local Ret 
	if Parameter == nil then
		Ret = CFuncParaVarArr
	else
		Ret = Parameter
	end

	return Ret
end

function CFuncEnd()
	Trigger {
		players = {CFuncPlayer},
		conditions = {
			Label(CFuncIndex);
		},
		flag = {Preserved}
	}
	table.remove(CFuncArr,CFuncptr)
	CFuncptr = CFuncptr - 1
end

function CFuncReturn(Return)
	local SourceN = {}
	local SourceV = {}
	local DestN = {}
	local DestV = {}
	for k, v in pairs(Return) do 
		if type(v) == "number" then
			table.insert(SourceN,v)
			table.insert(DestN,k)
		elseif v[4] == "V" then
			table.insert(SourceV,v)
			table.insert(DestV,k)
		else
			CFuncReturn_InputData_Error()
		end
	end
	local BoxN = {}
	for k, v in pairs(SourceN) do
		table.insert(BoxN,SetCtrig1X(FixPlayer,CFuncRetVarArr[DestN[k]][2],0x15C,0,SetTo,v))
	end
	if SourceN[1] ~= nil then
		Trigger {
			players = {CFuncPlayer},
			conditions = {
				Label(0);
			},
			actions = {
				BoxN,
			},
			flag = {Preserved}
		}
	end

	local BoxV = {}
	for k, v in pairs(SourceV) do
		if v[5] == nil then
			v[5] = 0
		end
		table.insert(BoxV,SetCtrig1X(FixPlayer,CFuncRetVarArr[DestV[k]][2],0x15C,0,SetTo,v[5]))
		table.insert(BoxV,SetCtrigX(v[1],v[2],0x158,v[3],SetTo,FixPlayer,CFuncRetVarArr[DestV[k]][2],0x15C,1,0))
		table.insert(BoxV,SetCtrig1X(v[1],v[2],0x148,v[3],SetTo,0xFFFFFFFF))
		table.insert(BoxV,SetCtrig1X(v[1],v[2],0x160,v[3],SetTo,SetTo*16777216,0xFF000000))
	end
	if SourceV[1] ~= nil then
		Trigger {
			players = {CFuncPlayer},
			conditions = {
				Label(0);
			},
			actions = {
				BoxV,
				CallLabelAlwaysN(table.unpack(SourceV));
			},
			flag = {Preserved}
		}
	end

	Trigger {
		players = {CFuncPlayer},
		conditions = {
			Label();
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",CFuncIndex,0x0,0,0);
		},
		flag = {Preserved}
	}
end

function CallCFunc(CFunction,Parameter,Return,PlayerID,Conditions,Actions,Once)
	if Parameter == nil then
		Parameter = {}
	end
	if Return == nil then
		Return = {}
	end
	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)

	if Once == 1 then
		Flags = {}
	else
		Flags = {Preserved}
	end

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
			Conditions,
		},
		actions = {
			SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X","X",0x0,0,1);
			Actions,
		},
		flag = {
			Flags,
		}
	}
	if CFunction[3] == nil then
		local SourceN = {}
		local SourceV = {}
		local DestN = {}
		local DestV = {}
		for k, v in pairs(Parameter) do 
			if type(v) == "number" then
				table.insert(SourceN,v)
				table.insert(DestN,k)
			elseif v[4] == "V" then
				table.insert(SourceV,v)
				table.insert(DestV,k)
			else
				CallCFunc_InputData_Error()
			end
		end
		local BoxN = {}
		for k, v in pairs(SourceN) do
			table.insert(BoxN,SetCtrig1X(FixPlayer,CFuncParaVarArr[DestN[k]][2],0x15C,0,SetTo,v))
		end
		if SourceN[1] ~= nil then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					BoxN,
				},
				flag = {Preserved}
			}
		end

		local BoxV = {}
		for k, v in pairs(SourceV) do
			if v[5] == nil then
				v[5] = 0
			end
			table.insert(BoxV,SetCtrig1X(FixPlayer,CFuncParaVarArr[DestV[k]][2],0x15C,0,SetTo,v[5]))
			table.insert(BoxV,SetCtrigX(v[1],v[2],0x158,v[3],SetTo,FixPlayer,CFuncParaVarArr[DestV[k]][2],0x15C,1,0))
			table.insert(BoxV,SetCtrig1X(v[1],v[2],0x148,v[3],SetTo,0xFFFFFFFF))
			table.insert(BoxV,SetCtrig1X(v[1],v[2],0x160,v[3],SetTo,SetTo*16777216,0xFF000000))
		end
		if SourceV[1] ~= nil then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					BoxV,
					CallLabelAlwaysN(table.unpack(SourceV));
				},
				flag = {Preserved}
			}
		end
	else
		local SourceN = {}
		local SourceV = {}
		local DestN = {}
		local DestV = {}
		for k, v in pairs(Parameter) do 
			if type(v) == "number" then
				table.insert(SourceN,v)
				table.insert(DestN,k)
			elseif v[4] == "V" then
				table.insert(SourceV,v)
				table.insert(DestV,k)
			else
				CallCFunc_InputData_Error()
			end
		end
		local BoxN = {}
		for k, v in pairs(SourceN) do
			table.insert(BoxN,SetCtrig1X(FixPlayer,CFunction[3][DestN[k]][2],0x15C,0,SetTo,v))
		end
		if SourceN[1] ~= nil then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					BoxN,
				},
				flag = {Preserved}
			}
		end

		local BoxV = {}
		for k, v in pairs(SourceV) do
			if v[5] == nil then
				v[5] = 0
			end
			table.insert(BoxV,SetCtrig1X(FixPlayer,CFunction[3][DestV[k]][2],0x15C,0,SetTo,v[5]))
			table.insert(BoxV,SetCtrigX(v[1],v[2],0x158,v[3],SetTo,FixPlayer,CFunction[3][DestV[k]][2],0x15C,1,0))
			table.insert(BoxV,SetCtrig1X(v[1],v[2],0x148,v[3],SetTo,0xFFFFFFFF))
			table.insert(BoxV,SetCtrig1X(v[1],v[2],0x160,v[3],SetTo,SetTo*16777216,0xFF000000))
		end
		if SourceV[1] ~= nil then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					BoxV,
					CallLabelAlwaysN(table.unpack(SourceV));
				},
				flag = {Preserved}
			}
		end
	end

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+1,0x0,0,1);
			SetCtrigX("X","X",0x4,0,SetTo,CFunction[1],CFunction[2],0x0,0,1);
			SetCtrigX(CFunction[1],CFunction[2]+1,0x4,0,SetTo,"X","X",0x0,0,1);
		},
		flag = {Preserved}
	}

	local BoxR = {}
	local SourceR = {}
	for k, v in pairs(Return) do
		table.insert(SourceR,{FixPlayer,CFuncRetVarArr[k][2],0,"V"})
		if type(v) == "number" then
			table.insert(BoxR,SetCtrig1X(FixPlayer,CFuncRetVarArr[k][2],0x158,0,SetTo,EPD(v)))
		elseif v[4]== "V" then
			table.insert(BoxR,SetCtrigX(FixPlayer,CFuncRetVarArr[k][2],0x158,0,SetTo,v[1],v[2],0x15C,1,v[3]))
		else
			table.insert(BoxR,SetCtrigX(FixPlayer,CFuncRetVarArr[k][2],0x158,0,SetTo,v[1],v[2],v[3],1,v[4]))
		end
		table.insert(BoxR,SetCtrig1X(FixPlayer,CFuncRetVarArr[k][2],0x148,0,SetTo,0xFFFFFFFF))
		table.insert(BoxR,SetCtrig1X(FixPlayer,CFuncRetVarArr[k][2],0x160,0,SetTo,SetTo*16777216,0xFF000000))
	end

	if Return[1] ~= nil then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				BoxR,
				CallLabelAlwaysN(table.unpack(SourceR));
			},
			flag = {Preserved}
		}
	end

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+1);
		},
		flag = {Preserved}
	}
	PlayerID = PlayerConvert(PlayerID)
	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+1,0x0,0,1))
	end
	IndexAlloc = IndexAlloc + 2
end

function CallCFuncX(PlayerID,CFunction,Parameter,Return)
	if Parameter == nil then
		Parameter = {}
	end
	if Return == nil then
		Return = {}
	end
	STPopTrigArr(PlayerID)

	if CFunction[3] == nil then
		local SourceN = {}
		local SourceV = {}
		local DestN = {}
		local DestV = {}
		for k, v in pairs(Parameter) do 
			if type(v) == "number" then
				table.insert(SourceN,v)
				table.insert(DestN,k)
			elseif v[4] == "V" then
				table.insert(SourceV,v)
				table.insert(DestV,k)
			else
				CallCFuncX_InputData_Error()
			end
		end
		local BoxN = {}
		for k, v in pairs(SourceN) do
			table.insert(BoxN,SetCtrig1X(FixPlayer,CFuncParaVarArr[DestN[k]][2],0x15C,0,SetTo,v))
		end
		if SourceN[1] ~= nil then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					BoxN,
				},
				flag = {Preserved}
			}
		end

		local BoxV = {}
		for k, v in pairs(SourceV) do
			if v[5] == nil then
				v[5] = 0
			end
			table.insert(BoxV,SetCtrig1X(FixPlayer,CFuncParaVarArr[DestV[k]][2],0x15C,0,SetTo,v[5]))
			table.insert(BoxV,SetCtrigX(v[1],v[2],0x158,v[3],SetTo,FixPlayer,CFuncParaVarArr[DestV[k]][2],0x15C,1,0))
			table.insert(BoxV,SetCtrig1X(v[1],v[2],0x148,v[3],SetTo,0xFFFFFFFF))
			table.insert(BoxV,SetCtrig1X(v[1],v[2],0x160,v[3],SetTo,SetTo*16777216,0xFF000000))
		end
		if SourceV[1] ~= nil then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					BoxV,
					CallLabelAlwaysN(table.unpack(SourceV));
				},
				flag = {Preserved}
			}
		end
	else
		local SourceN = {}
		local SourceV = {}
		local DestN = {}
		local DestV = {}
		for k, v in pairs(Parameter) do 
			if type(v) == "number" then
				table.insert(SourceN,v)
				table.insert(DestN,k)
			elseif v[4] == "V" then
				table.insert(SourceV,v)
				table.insert(DestV,k)
			else
				CallCFuncX_InputData_Error()
			end
		end
		local BoxN = {}
		for k, v in pairs(SourceN) do
			table.insert(BoxN,SetCtrig1X(FixPlayer,CFunction[3][DestN[k]][2],0x15C,0,SetTo,v))
		end
		if SourceN[1] ~= nil then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					BoxN,
				},
				flag = {Preserved}
			}
		end

		local BoxV = {}
		for k, v in pairs(SourceV) do
			if v[5] == nil then
				v[5] = 0
			end
			table.insert(BoxV,SetCtrig1X(FixPlayer,CFunction[3][DestV[k]][2],0x15C,0,SetTo,v[5]))
			table.insert(BoxV,SetCtrigX(v[1],v[2],0x158,v[3],SetTo,FixPlayer,CFunction[3][DestV[k]][2],0x15C,1,0))
			table.insert(BoxV,SetCtrig1X(v[1],v[2],0x148,v[3],SetTo,0xFFFFFFFF))
			table.insert(BoxV,SetCtrig1X(v[1],v[2],0x160,v[3],SetTo,SetTo*16777216,0xFF000000))
		end
		if SourceV[1] ~= nil then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					BoxV,
					CallLabelAlwaysN(table.unpack(SourceV));
				},
				flag = {Preserved}
			}
		end
	end

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,CFunction[1],CFunction[2],0x0,0,1);
			SetCtrigX(CFunction[1],CFunction[2]+1,0x4,0,SetTo,"X","X",0x0,0,1);
		},
		flag = {Preserved}
	}

	local BoxR = {}
	local SourceR = {}
	for k, v in pairs(Return) do
		table.insert(SourceR,{FixPlayer,CFuncRetVarArr[k][2],0,"V"})
		if type(v) == "number" then
			table.insert(BoxR,SetCtrig1X(FixPlayer,CFuncRetVarArr[k][2],0x158,0,SetTo,EPD(v)))
		elseif v[4]== "V" then
			table.insert(BoxR,SetCtrigX(FixPlayer,CFuncRetVarArr[k][2],0x158,0,SetTo,v[1],v[2],0x15C,1,v[3]))
		else
			table.insert(BoxR,SetCtrigX(FixPlayer,CFuncRetVarArr[k][2],0x158,0,SetTo,v[1],v[2],v[3],1,v[4]))
		end
		table.insert(BoxR,SetCtrig1X(FixPlayer,CFuncRetVarArr[k][2],0x148,0,SetTo,0xFFFFFFFF))
		table.insert(BoxR,SetCtrig1X(FixPlayer,CFuncRetVarArr[k][2],0x160,0,SetTo,SetTo*16777216,0xFF000000))
	end

	if Return[1] ~= nil then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				BoxR,
				CallLabelAlwaysN(table.unpack(SourceR));
			},
			flag = {Preserved}
		}
	end
end

function PlayerConvert2(PlayerID)
	local Temp = {}
	if type(PlayerID) == "number" or PlayerID == Force1 or PlayerID == Force2 or PlayerID == Force3 or PlayerID == Force4 or PlayerID == AllPlayers then
		PlayerID = {PlayerID}
	end
	
	local Input = {0,0,0,0,0,0,0,0}

	for k, P in pairs(PlayerID) do
		if P == Force1 then
			for i, v in pairs(CForce1) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == Force2 then
			for i, v in pairs(CForce2) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == Force3 then
			for i, v in pairs(CForce3) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == Force4 then
			for i, v in pairs(CForce4) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == AllPlayers then
			for i, v in pairs(CAllPlayers) do
				if v == 1 then
					Input[i] = 1
				end
			end
		else 
			Input[P+1] = 1
		end
	end

	return Input
end

function PlayerConvert2X(PlayerID)
	local Temp = {}
	if type(PlayerID) == "number" or PlayerID == Force1 or PlayerID == Force2 or PlayerID == Force3 or PlayerID == Force4 or PlayerID == AllPlayers then
		PlayerID = {PlayerID}
	end
	if PlayerID == Force5 then
		PlayerID = {P9,P10,P11,P12}
	end
	if PlayerID == EveryPlayers then
		PlayerID = {AllPlayers,P9,P10,P11,P12}
	end
 	
	local Input = {0,0,0,0,0,0,0,0,0,0,0,0}

	for k, P in pairs(PlayerID) do
		if P == Force1 then
			for i, v in pairs(CForce1) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == Force2 then
			for i, v in pairs(CForce2) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == Force3 then
			for i, v in pairs(CForce3) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == Force4 then
			for i, v in pairs(CForce4) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == AllPlayers then
			for i, v in pairs(CAllPlayers) do
				if v == 1 then
					Input[i] = 1
				end
			end
		elseif P == Force5 then
			Input[9] = 1
			Input[10] = 1
			Input[11] = 1
			Input[12] = 1
		elseif P == EveryPlayers then
			for i, v in pairs(CAllPlayers) do
				if v == 1 then
					Input[i] = 1
				end
			end
			Input[9] = 1
			Input[10] = 1
			Input[11] = 1
			Input[12] = 1
		else 
			Input[P+1] = 1
		end
	end

	return Input
end

function CunPack(CPack) -- Condition / Action / Parameter 단일 입력 전용 
	if type(CPack) == "table" and type(CPack[1]) == "function" then
		for i, v in pairs(CPack) do
			if type(v) == "table" and type(v[1]) == "function" then
				local prt = CunPack(v)
				CPack[i] = prt
			end
		end
		local Func = CPack[1]
		table.remove(CPack, 1)
		local Ret = Func(table.unpack(CPack))
		return Ret
	else
		return CPack
	end
end

function CDoActionsX(PlayerID,Actions,Flags,Index)
	if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	Actions = __FlattenCAct(Actions)

	if Index == nil then
		Index = 0
	end

	STPopTrigArr(PlayerID)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID)

	if Flags == nil then
		Flags = {Preserved}
	end
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(Index);
		},
		actions = {
			Actions,
		},
		flag = {
			Flags,
		}
	}
end

function CTriggerX(PlayerID, Conditions, Actions, Flags, Index)
	if Conditions ~= nil then
		for k, v in pairs(Conditions) do
			local Temp = CunPack(v)
			Conditions[k] = Temp
		end
	end

	if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)
	
	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID)

	if Flags == 1 then
		Flags = {Preserved}
	end
	if Index == nil or Index == "X" then
		Index = 0 
	end

	Trigger {
				players = {PlayerID},
				conditions = {
					Label(Index);
					Conditions,
				},
				actions = {
					Actions,
				},
				flag = {
					Flags,
				}
			}
		
end

function CDoActions2X(PlayerID,Actions,Flags)
	if Actions == nil then Actions = {} end
	local k = 1
	local Size = #Actions

	if Flags == nil then
		Flags = {Preserved}
	end

	while k <= Size do
		if Size - k + 1 >= 64 then
			local X = {}
			for i = 0, 63 do
				table.insert(X, Actions[k])
				k = k + 1
			end

			for k, v in pairs(X) do
				local Temp = CunPack(v)
				X[k] = Temp
			end
			X = __FlattenCAct(X)

			STPopTrigArr(PlayerID)
			X = PopActArr(X)
			PopTrigArr(PlayerID)

			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						X,
					},
					flag = {
						Flags,
					},
				}
		else
			local X = {}
			repeat
				table.insert(X, Actions[k])
				k = k + 1
			until k == Size + 1

			for k, v in pairs(X) do
				local Temp = CunPack(v)
				X[k] = Temp
			end
			X = __FlattenCAct(X)

			STPopTrigArr(PlayerID)
			X = PopActArr(X)
			PopTrigArr(PlayerID)

			Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						X,
					},
					flag = {
						Flags,
					},
				}
		end
	end
end

function CTrigger2X(PlayerID, Conditions, Actions, Flags)
	if Flags == 1 then
		CIf2(PlayerID, Conditions)
	else
		CIfOnce2(PlayerID, Conditions)
	end
		CDoActions2X(PlayerID,Actions)
	CIfEnd()
end

function TSVA1Mem(PlayerID,Dest,SVA1,Address,OffsetFlag) -- V << SVA1_EPD/Offset
	STPopTrigArr(PlayerID)
	if OffsetFlag == "X" or OffsetFlag == nil then
		OffsetFlag = 0
	end
	if Address == "X" or Address == nil then
		Address = 0x15C
	end

	if Dest[4] == "V" then
		if SVA1[4] == "V" then
			if SVA1[3] == nil or SVA1[3] == "X" then
				SVA1[3] = 0 
			end
			if OffsetFlag == 0 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,SVA1[1],SVA1[2],Address,1,SVA1[3]+SVA1[5]); 
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,SVA1[1],SVA1[2],Address,0,SVA1[3]+SVA1[5]); 
					},
					flag = {Preserved}
				}
			end
		elseif SVA1[4] == "VA" then
			if SVA1[5][5] == nil then
				SVA1[5][5] = 0 
			end
			if OffsetFlag == 0 then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,SVA1[1],SVA1[2],Address,1,SVA1[3]+SVA1[5][5]); 
						SetCtrig1X(SVA1[5][1],SVA1[5][2],0x148,SVA1[5][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(SVA1[5][1],SVA1[5][2],0x160,SVA1[5][3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(SVA1[5][1],SVA1[5][2],0x158,SVA1[5][3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						CallLabelAlways(SVA1[5][1],SVA1[5][2],SVA1[5][3]);
					},
					flag = {Preserved}
				}
			else
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX(Dest[1],Dest[2],0x15C,Dest[3],SetTo,SVA1[1],SVA1[2],Address,0,SVA1[3]+SVA1[5][5]); 
						SetCtrig1X(SVA1[5][1],SVA1[5][2],0x148,SVA1[5][3],SetTo,0xFFFFFFFF);
						SetCtrig1X(SVA1[5][1],SVA1[5][2],0x160,SVA1[5][3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX(SVA1[5][1],SVA1[5][2],0x158,SVA1[5][3],SetTo,"X",CRet[1],0x15C,1,0); 
						SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
						SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0); 
						CallLabelAlways2(SVA1[5][1],SVA1[5][2],SVA1[5][3],"X",CRet[1],0);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",CRet[1],0x158,0,SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]); 
						CallLabelAlways("X",CRet[1],0);
					},
					flag = {Preserved}
				}
			end
		end
	else
		_TSVA1Mem_InputData_Error()
	end
end

 
function CS__GetName(PlayerID,SVA1,TargetPlayer,Output)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CA__GetName(SVA1,TargetPlayer,Output)
	CAPrintPlayerID = Temp
end

function CS__epdcpy(PlayerID,SVA1,Value,Mask,Start,End,Preserve)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CA__epdcpy(SVA1,Value,Mask,Start,End,Preserve)
	CAPrintPlayerID = Temp
end

function CS__epdcmp(PlayerID,Dest,Source,Size,Mask,CFlag)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CA__epdcmp(Dest,Source,Size,Mask,CFlag)
	CAPrintPlayerID = Temp
end

function CS__Input(PlayerID,Input,SVA1,Mask)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CA__Input(Input,SVA1,Mask)
	CAPrintPlayerID = Temp
end

function CS__InputVA(PlayerID,iStrid,Index,SVA1,Size,Mask,Start,End,SourceDistance) -- CB[1] / A B 13
	local Temp = CAPrintPlayerID
	local TempB = CAPrintCreateArr
	CAPrintPlayerID = PlayerID

	if iStrid[4] == "SV54" then
		DoActionsX(PlayerID,SetCtrigX("X",NRet[16],0x15C,0,SetTo,iStrid[1],iStrid[2],0x15C,1,iStrid[3]))
		CAPrintCreateArr = {{"X",NRet[16],0,"V"}}
	else
		CAPrintCreateArr = {iStrid[1]}
	end

	CA__InputVA(Index,SVA1,Size,Mask,Start,End,SourceDistance)
	CAPrintPlayerID = Temp
	CAPrintCreateArr = TempB
end

function CS__InputVAX(PlayerID,SV54,Index,SVA1,Size,Mask,DestMask,Start,End,SourceDistance) -- CB[1] / 13
	local Temp = CAPrintPlayerID
	local TempB = CAPrintCreateArr
	CAPrintPlayerID = PlayerID

	DoActionsX(PlayerID,SetCtrigX("X",NRet[16],0x15C,0,SetTo,SV54[1],SV54[2],0x15C,1,SV54[3]))
	CAPrintCreateArr = {{"X",NRet[16],0,"V"}}

	CD__InputVAX(Index,SVA1,Size,Mask,DestMask,Start,End,SourceDistance)
	CAPrintPlayerID = Temp
	CAPrintCreateArr = TempB
end

function CS__InputMask(PlayerID,SV54,Line,Mask,Start,End) -- CB[1] / 13
	local Temp = CAPrintPlayerID
	local TempB = CAPrintCreateArr
	CAPrintPlayerID = PlayerID

	DoActionsX(PlayerID,SetCtrigX("X",NRet[16],0x15C,0,SetTo,SV54[1],SV54[2],0x15C,1,SV54[3]))
	CAPrintCreateArr = {{"X",NRet[16],0,"V"}}

	CD__InputMask(Line,Mask,Start,End)
	CAPrintPlayerID = Temp
	CAPrintCreateArr = TempB
end

function CS__InputSVA1(PlayerID,Dest,Source,Size,Mask,Start,End,Next,DestDistance,SourceDistance)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CA__InputSVA1(Dest,Source,Size,Mask,Start,End,Next,DestDistance,SourceDistance) 
	CAPrintPlayerID = Temp
end

function CS__InputSVA1X(PlayerID,Dest,Source,Size,Mask,DestMask,Start,End,Next,DestDistance,SourceDistance)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CA__InputSVA1X(Dest,Source,Size,Mask,DestMask,Start,End,Next,DestDistance,SourceDistance)
	CAPrintPlayerID = Temp
end

function CS__SetValue(PlayerID,SVA1,String,Mask,Index,Preserve,utf8flag)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CA__SetValue(SVA1,String,Mask,Index,Preserve,utf8flag)
	CAPrintPlayerID = Temp
end

function CS__SetMask(PlayerID,SVA1,Mask,Start,End,Preserve)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CA__SetMask(SVA1,Mask,Start,End,Preserve)
	CAPrintPlayerID = Temp
end

function CS__SetNext(PlayerID,SVA1,DestDistance,Mode,Start,End,Preserve)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CA__SetNext(SVA1,DestDistance,Mode,Start,End,Preserve)
	CAPrintPlayerID = Temp
end

function CS__MoveXY(PlayerID,SVA1,Line,Mul,Mode,Fix,PathData,Preserve)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CA__MoveXY(SVA1,Line,Mul,Mode,Fix,PathData,Preserve)
	CAPrintPlayerID = Temp
end

function CS__SetMaskX(PlayerID,SV54,index,Mask) -- CB[1] CB[2] / 13
	local Temp = CAPrintPlayerID
	local TempB = CAPrintCreateArr
	CAPrintPlayerID = PlayerID

	if iStrid[4] == "SV54" then
		DoActionsX(PlayerID,{SetCtrigX("X",NRet[16],0x15C,0,SetTo,SV54[1],SV54[2],0x15C,1,SV54[3]),SetCVar("X",NRet[15],SetTo,54*8)})
		CAPrintCreateArr = {{"X",NRet[16],0,"V"},{"X",NRet[15],0,"V"}}
	end

	CD__SetMaskX(index,Mask)
	CAPrintPlayerID = Temp
	CAPrintCreateArr = TempB
end

function CS__SetMemoryX(PlayerID,iStrid,index,Value,Mask,utf8flag) -- CB[1] CB[2] / A B 13
	local Temp = CAPrintPlayerID
	local TempB = CAPrintCreateArr
	CAPrintPlayerID = PlayerID

	if iStrid[4] == "SV54" then
		DoActionsX(PlayerID,{SetCtrigX("X",NRet[16],0x15C,0,SetTo,iStrid[1],iStrid[2],0x15C,1,iStrid[3]),SetCVar("X",NRet[15],SetTo,54*8)})
		CAPrintCreateArr = {{"X",NRet[16],0,"V"},{"X",NRet[15],0,"V"}}
	else
		DoActionsX(PlayerID,SetCtrig1X("X",NRet[16],0x15C,0,SetTo,iStrid[3]))
		CAPrintCreateArr = {iStrid[1],{"X",NRet[16],0,"V"}}
	end

	CA__SetMemoryX(index,Value,Mask,utf8flag)
	CAPrintPlayerID = Temp
	CAPrintCreateArr = TempB
end

function CS__SetLetter(PlayerID,iStrid,index,Letter,utf8flag) -- CB[1] CB[2] / A B 13
	local Temp = CAPrintPlayerID
	local TempB = CAPrintCreateArr
	CAPrintPlayerID = PlayerID

	if iStrid[4] == "SV54" then
		DoActionsX(PlayerID,{SetCtrigX("X",NRet[16],0x15C,0,SetTo,iStrid[1],iStrid[2],0x15C,1,iStrid[3]),SetCVar("X",NRet[15],SetTo,54*8)})
		CAPrintCreateArr = {{"X",NRet[16],0,"V"},{"X",NRet[15],0,"V"}}
	else
		DoActionsX(PlayerID,SetCtrig1X("X",NRet[16],0x15C,0,SetTo,iStrid[3]))
		CAPrintCreateArr = {iStrid[1],{"X",NRet[16],0,"V"}}
	end
	CA__SetLetter(index,Letter,utf8flag)
	CAPrintPlayerID = Temp
	CAPrintCreateArr = TempB
end

function CS__SetColor(PlayerID,iStrid,index,ColorCode) -- CB[1] CB[2] / A B 13
	local Temp = CAPrintPlayerID
	local TempB = CAPrintCreateArr
	CAPrintPlayerID = PlayerID

	if iStrid[4] == "SV54" then
		DoActionsX(PlayerID,{SetCtrigX("X",NRet[16],0x15C,0,SetTo,iStrid[1],iStrid[2],0x15C,1,iStrid[3]),SetCVar("X",NRet[15],SetTo,54*8)})
		CAPrintCreateArr = {{"X",NRet[16],0,"V"},{"X",NRet[15],0,"V"}}
	else
		DoActionsX(PlayerID,SetCtrig1X("X",NRet[16],0x15C,0,SetTo,iStrid[3]))
		CAPrintCreateArr = {iStrid[1],{"X",NRet[16],0,"V"}}
	end

	CA__SetColor(index,ColorCode)
	CAPrintPlayerID = Temp
	CAPrintCreateArr = TempB
end

function CS__Read(PlayerID,iStrid,Index,Output,Mask) -- CB[1] / A B 13
	local Temp = CAPrintPlayerID
	local TempB = CAPrintCreateArr
	CAPrintPlayerID = PlayerID
	if iStrid[4] == "SV54" then
		DoActionsX(PlayerID,SetCtrigX("X",NRet[16],0x15C,0,SetTo,iStrid[1],iStrid[2],0x15C,1,iStrid[3]))
		CAPrintCreateArr = {{"X",NRet[16],0,"V"}}
	else
		CAPrintCreateArr = {iStrid[1]}
	end
	CA__Read(Index,Output,Mask)
	CAPrintPlayerID = Temp
	CAPrintCreateArr = TempB
end

function CS__ReadX(PlayerID,iStrid,Index,Output,Multiplier,Mask) -- CB[1] / A B 13
	local Temp = CAPrintPlayerID
	local TempB = CAPrintCreateArr
	CAPrintPlayerID = PlayerID
	if iStrid[4] == "SV54" then
		DoActionsX(PlayerID,SetCtrigX("X",NRet[16],0x15C,0,SetTo,iStrid[1],iStrid[2],0x15C,1,iStrid[3]))
		CAPrintCreateArr = {{"X",NRet[16],0,"V"}}
	else
		CAPrintCreateArr = {iStrid[1]}
	end
	CA__ReadX(Index,Output,Multiplier,Mask)
	CAPrintPlayerID = Temp
	CAPrintCreateArr = TempB
end

function CS__OverWrite(PlayerID,iStrid,SVA32,Index,Null,Preserve) -- CB[1] CB[2] / A B 13
	local Temp = CAPrintPlayerID
	local TempB = CAPrintCreateArr
	CAPrintPlayerID = PlayerID
	
	if iStrid[4] == "SV54" then
		DoActionsX(PlayerID,{SetCtrigX("X",NRet[16],0x15C,0,SetTo,iStrid[1],iStrid[2],0x15C,1,iStrid[3]),SetCVar("X",NRet[15],SetTo,54*8)})
		CAPrintCreateArr = {{"X",NRet[16],0,"V"},{"X",NRet[15],0,"V"}}
	else
		DoActionsX(PlayerID,SetCtrig1X("X",NRet[16],0x15C,0,SetTo,iStrid[3]))
		CAPrintCreateArr = {iStrid[1],{"X",NRet[16],0,"V"}}
	end

	CA__OverWrite(SVA32,Index,Null,Preserve)
	CAPrintPlayerID = Temp
	CAPrintCreateArr = TempB
end

function CS__Mov(PlayerID,SVA1,Output,Mask,RecoverMask)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CA__Mov(SVA1,Output,Mask,RecoverMask)
	CAPrintPlayerID = Temp
end

function CS__Movcpy(PlayerID,SVA1,Output,Size,Mask,RecoverMask,DestDistance)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CA__Movcpy(SVA1,Output,Size,Mask,RecoverMask,DestDistance)
	CAPrintPlayerID = Temp
end

function CS__Encode(PlayerID,Dest,Source,Size,cp949flag)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CA__Encode(Dest,Source,Size,cp949flag)
	CAPrintPlayerID = Temp
end

function CS__ConvertColor(PlayerID,SVA1,ConvertData,MaskData,Start,End)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CA__ConvertColor(SVA1,ConvertData,MaskData,Start,End)
	CAPrintPlayerID = Temp
end

function CS__ConvertLetter(PlayerID,SVA1,ConvertData,MaskData,Start,End,utf8flag)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CA__ConvertLetter(SVA1,ConvertData,MaskData,Start,End,utf8flag)
	CAPrintPlayerID = Temp
end

function CS__ItoCustom(PlayerID,SVA1,Input,Output,Mask,Base,Length,Init,Sign,ColorArr,IndexArr,DataArr,ClearArr,utf8flag)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CA__ItoCustom(SVA1,Input,Output,Mask,Base,Length,Init,Sign,ColorArr,IndexArr,DataArr,ClearArr,utf8flag)
	CAPrintPlayerID = Temp
end

function CS__lItoCustom(PlayerID,SVA1,Input,Output,Mask,Base,Length,Init,Sign,ColorArr,IndexArr,DataArr,ClearArr,utf8flag)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CA__lItoCustom(SVA1,Input,Output,Mask,Base,Length,Init,Sign,ColorArr,IndexArr,DataArr,ClearArr,utf8flag)
	CAPrintPlayerID = Temp
end

function CS__ItoName(PlayerID,SVA1,TargetPlayer,Output,Init,ColorArr,FullWidth,utf8flag)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CA__ItoName(SVA1,TargetPlayer,Output,Init,ColorArr,FullWidth,utf8flag)
	CAPrintPlayerID = Temp
end

function CS__SetHotkey(PlayerID,iTBLid,Value) -- CB[1] / B
	local Temp = CAPrintPlayerID
	local TempB = CAPrintCreateArr
	CAPrintPlayerID = PlayerID

	CAPrintCreateArr = {iTBLid[1]}
	
	CB__SetHotkey(Value)
	CAPrintPlayerID = Temp
	CAPrintCreateArr = TempB
end

function CS__SetButtonType(PlayerID,iTBLid,Value) -- CB[1] / B
	local Temp = CAPrintPlayerID
	local TempB = CAPrintCreateArr
	CAPrintPlayerID = PlayerID

	CAPrintCreateArr = {iTBLid[1]}

	CB__SetButtonType(Value)
	CAPrintPlayerID = Temp
	CAPrintCreateArr = TempB
end

function CS__Resize(PlayerID,SV54,Line,Status) -- CB[1] CB[2] / 13
	local Temp = CAPrintPlayerID
	local TempB = CAPrintCreateArr
	CAPrintPlayerID = PlayerID

	if iStrid[4] == "SV54" then
		DoActionsX(PlayerID,{SetCtrigX("X",NRet[16],0x15C,0,SetTo,SV54[1],SV54[2],0x15C,1,SV54[3]),SetCVar("X",NRet[15],SetTo,54*8)})
		CAPrintCreateArr = {{"X",NRet[16],0,"V"},{"X",NRet[15],0,"V"}}
	end

	CD__Resize(Line,Status)
	CAPrintPlayerID = Temp
	CAPrintCreateArr = TempB
end

function CS__ScanW(PlayerID,SVA1,Size,Variable,Output,Base,Sign)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CD__ScanW(SVA1,Size,Wariable,Output,Base,Sign)
	CAPrintPlayerID = Temp
end

function CS__ScanV(PlayerID,SVA1,Size,Variable,Output,Base,Sign)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CD__ScanV(SVA1,Size,Variable,Output,Base,Sign)
	CAPrintPlayerID = Temp
end

function CS__ScanChat(PlayerID,SVA1,Offset,Size,Output,SkipInit)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CD__ScanChat(SVA1,Offset,Size,Output,SkipInit)
	CAPrintPlayerID = Temp
end

function CS__DwItoName(PlayerID,SVA1,TargetPlayer,Output,Init,Color)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CA__DwItoName(SVA1,TargetPlayer,Output,Init,Color)
	CAPrintPlayerID = Temp
end

function CS__DwSetValue(PlayerID,SVA1,String,Index,Preserve,utf8flag)
	local Temp = CAPrintPlayerID
	CAPrintPlayerID = PlayerID
	CA__DwSetValue(SVA1,String,Index,Preserve,utf8flag)
	CAPrintPlayerID = Temp
end

function CS__GetIndex(PlayerID,Index,Output) 
	FGINDXCheck = 1
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << X 

	if type(Index) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Index);
			},
			flag = {Preserved}
		}
	else
		if Index[4] == "VA" then
			local TempRet = {"X",CRet[1],0,"V"}
			MovX(PlayerID,TempRet,Index)
			Index = TempRet
		elseif Index[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Index[1],Index[2],0x158,Index[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Index[1],Index[2],0x148,Index[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Index[1],Index[2],0x160,Index[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Index[1],Index[2],Index[3]);
				},
				flag = {Preserved}
			}
		end
	end

-- Call f_GetIndex
	if FGINDXCall1 == 0 then
		Need_Include_DataTransfer()
	end
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FGINDXCall1,0x0,0,0);
				SetCtrigX("X",FGINDXCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				SetCVar("X",CRet[2],SetTo,0);
			},
			flag = {Preserved}
		}

-- Output Data CRet[2] = Output
	if type(Output) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
	else
		if Output[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
		elseif Output[4] == "VA" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,0xFFFFFFFF)
		elseif Output[4] == "A" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
		end
	end
end

function CS__GetIndex2(PlayerID,Line,Index,Output) 
	FGINDX2Check = 1
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << X 

	if type(Index) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Index);
			},
			flag = {Preserved}
		}
	else
		if Index[4] == "VA" then
			local TempRet = {"X",CRet[1],0,"V"}
			MovX(PlayerID,TempRet,Index)
			Index = TempRet
		elseif Index[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Index[1],Index[2],0x158,Index[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Index[1],Index[2],0x148,Index[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Index[1],Index[2],0x160,Index[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Index[1],Index[2],Index[3]);
				},
				flag = {Preserved}
			}
		end
	end

	if type(Line) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Line);
			},
			flag = {Preserved}
		}
	else
		if Line[4] == "VA" then
			local TempRet = {"X",CRet[2],0,"V"}
			MovX(PlayerID,TempRet,Line)
			Line = TempRet
		elseif Line[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Line[1],Line[2],0x158,Line[3],SetTo,"X",CRet[2],0x15C,1,0);
					SetCtrig1X(Line[1],Line[2],0x148,Line[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Line[1],Line[2],0x160,Line[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Line[1],Line[2],Line[3]);
				},
				flag = {Preserved}
			}
		end
	end

-- Call f_GetIndex2
	if FGINDX2Call1 == 0 then
		Need_Include_DataTransfer()
	end
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FGINDX2Call1,0x0,0,0);
				SetCtrigX("X",FGINDX2Call2,0x4,0,SetTo,"X","X",0x0,0,1);
				SetCVar("X",CRet[3],SetTo,0);
			},
			flag = {Preserved}
		}

-- Output Data CRet[3] = Output
	if type(Output) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",CRet[3],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
						},
						flag = {Preserved}
					}
	else
		if Output[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[3],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
						},
						flag = {Preserved}
					}
		elseif Output[4] == "VA" then
				local TempRet = {"X",CRet[3],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,0xFFFFFFFF)
		elseif Output[4] == "A" then
				local TempRet = {"X",CRet[3],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[3],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
						},
						flag = {Preserved}
					}
		end
	end
end

function CS__GetMask(PlayerID,Index,Output) 
	FGINDXCheck = 1
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << X 

	if type(Index) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Index);
			},
			flag = {Preserved}
		}
	else
		if Index[4] == "VA" then
			local TempRet = {"X",CRet[1],0,"V"}
			MovX(PlayerID,TempRet,Index)
			Index = TempRet
		elseif Index[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Index[1],Index[2],0x158,Index[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Index[1],Index[2],0x148,Index[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Index[1],Index[2],0x160,Index[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Index[1],Index[2],Index[3]);
				},
				flag = {Preserved}
			}
		end
	end

-- Call f_GetMask
	if FGINDXCall1 == 0 then
		Need_Include_DataTransfer()
	end
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FGINDXCall1,0x0,0,0);
				SetCtrigX("X",FGINDXCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				SetCVar("X",CRet[2],SetTo,0);
			},
			flag = {Preserved}
		}

-- Output Data CRet[2] = Output
	if type(Output) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCVar("X",CRet[2],Add,-5);
						SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
	else
		if Output[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCVar("X",CRet[2],Add,-5);
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
		else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCVar("X",CRet[2],Add,-5);
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
		end
	end
end

function CS__GetMask2(PlayerID,Line,Index,Output) 
	FGINDX2Check = 1
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << X 

	if type(Index) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Index);
			},
			flag = {Preserved}
		}
	else
		if Index[4] == "VA" then
			local TempRet = {"X",CRet[1],0,"V"}
			MovX(PlayerID,TempRet,Index)
			Index = TempRet
		elseif Index[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Index[1],Index[2],0x158,Index[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Index[1],Index[2],0x148,Index[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Index[1],Index[2],0x160,Index[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Index[1],Index[2],Index[3]);
				},
				flag = {Preserved}
			}
		end
	end

	if type(Line) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,SetTo,Line);
			},
			flag = {Preserved}
		}
	else
		if Line[4] == "VA" then
			local TempRet = {"X",CRet[2],0,"V"}
			MovX(PlayerID,TempRet,Line)
			Line = TempRet
		elseif Line[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Line[1],Line[2],0x158,Line[3],SetTo,"X",CRet[2],0x15C,1,0);
					SetCtrig1X(Line[1],Line[2],0x148,Line[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Line[1],Line[2],0x160,Line[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Line[1],Line[2],Line[3]);
				},
				flag = {Preserved}
			}
		end
	end

-- Call f_GetIndex2
	if FGINDX2Call1 == 0 then
		Need_Include_DataTransfer()
	end
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FGINDX2Call1,0x0,0,0);
				SetCtrigX("X",FGINDX2Call2,0x4,0,SetTo,"X","X",0x0,0,1);
				SetCVar("X",CRet[3],SetTo,0);
			},
			flag = {Preserved}
		}

-- Output Data CRet[3] = Output
	if type(Output) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCVar("X",CRet[3],Add,-5);
						SetCtrig1X("X",CRet[3],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
						},
						flag = {Preserved}
					}
	else
		if Output[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCVar("X",CRet[3],Add,-5);
						SetCtrigX("X",CRet[3],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
						},
						flag = {Preserved}
					}
		else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCVar("X",CRet[3],Add,-5);
						SetCtrigX("X",CRet[3],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[3],0);
						},
						flag = {Preserved}
					}
		end
	end
end

function CS__GetLine(PlayerID,DisplayLine,Output) -- DisplayLine = 상수(0~10) / Output = V
	FLINECheck = 1
	-- DisplayLine = d, OffsetLine = l, 0x640B58 = ptr
	-- l->d : d = (l+(11-ptr)%11)%11
	-- d->l : l = (d+ptr)%11
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << X 

	if type(DisplayLine) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,DisplayLine);
			},
			flag = {Preserved}
		}
	else
		if DisplayLine[4] == "VA" then
			local TempRet = {"X",CRet[1],0,"V"}
			MovX(PlayerID,TempRet,DisplayLine)
			DisplayLine = TempRet
		elseif DisplayLine[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(DisplayLine[1],DisplayLine[2],0x158,DisplayLine[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(DisplayLine[1],DisplayLine[2],0x148,DisplayLine[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(DisplayLine[1],DisplayLine[2],0x160,DisplayLine[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(DisplayLine[1],DisplayLine[2],DisplayLine[3]);
				},
				flag = {Preserved}
			}
		end
	end

-- Call f_GetLine
	if FLINECall1 == 0 then
		Need_Include_DataTransfer()
	end
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FLINECall1,0x0,0,0);
				SetCtrigX("X",FLINECall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}

-- Output Data CRet[2] = Output
	if type(Output) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
	else
		if Output[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
		elseif Output[4] == "VA" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,0xFFFFFFFF)
		elseif Output[4] == "A" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
		end
	end
end

function CS__GetDisplayLine(PlayerID,Line,Output) -- Line = 상수(0~10) / Output = V
	FDINECheck = 1
	-- DisplayLine = d, OffsetLine = l, 0x640B58 = ptr
	-- l->d : d = (l+(11-ptr)%11)%11
	-- d->l : l = (d+ptr)%11
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << X 

	if type(Line) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,Line);
			},
			flag = {Preserved}
		}
	else
		if Line[4] == "VA" then
			local TempRet = {"X",CRet[1],0,"V"}
			MovX(PlayerID,TempRet,Line)
			Line = TempRet
		elseif Line[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Line[1],Line[2],0x158,Line[3],SetTo,"X",CRet[1],0x15C,1,0);
					SetCtrig1X(Line[1],Line[2],0x148,Line[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(Line[1],Line[2],0x160,Line[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(Line[1],Line[2],Line[3]);
				},
				flag = {Preserved}
			}
		end
	end

-- Call f_GetDisplayLine
	if FDINECall1 == 0 then
		Need_Include_DataTransfer()
	end
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FDINECall1,0x0,0,0);
				SetCtrigX("X",FDINECall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}

-- Output Data CRet[2] = Output
	if type(Output) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(Output));
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
	else
		if Output[4] == "V" then
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
		elseif Output[4] == "VA" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,0xFFFFFFFF)
		elseif Output[4] == "A" then
				local TempRet = {"X",CRet[2],0,"V"}
				MovX(PlayerID,Output,TempRet,SetTo,0xFFFFFFFF)
		else
				Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX("X",CRet[2],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
						SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",CRet[2],0);
						},
						flag = {Preserved}
					}
		end
	end
end

function CreateSV54(PlayerID,String)
	local Arr = str_to_iutf8(String,1)
	local Value = {}
	local Temp
	local n = 1
	while true do
		Temp = 0
		if Arr[n] == nil then
			Temp = Temp+0xD
		else
			Temp = Temp+Arr[n]
		end
		if Arr[n+1] == nil then
			Temp = Temp+0xD00
		else
			Temp = Temp+Arr[n+1]*256
		end
		if Arr[n+2] == nil then
			Temp = Temp+0xD0000
		else
			Temp = Temp+Arr[n+2]*65536
		end
		if Arr[n+3] == nil then
			Temp = Temp+0xD000000
		else
			Temp = Temp+Arr[n+3]*16777216
		end
		table.insert(Value,Temp)
		n = n+4
		if n > 216 then break end
	end

	local Box = {}
	for i = 0, 53 do
		table.insert(Box,SetMemoryX(0x641598+0x4*i,SetTo,Value[i+1],0xFFFFFFFF))
	end
	table.insert(Box,SetMemoryX(0x641670,SetTo,0x0000,0xFFFF))
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(FuncAlloc);
		},
		actions = {
			Box,
		},
		flag = {Preserved}
	}
	FuncAlloc = FuncAlloc + 1

	local Ret = {"X",FuncAlloc-1,0,"SV54"}
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end

--{PlayerID,CreateVarXAlloc-1,0,"SV54"}
function C13Print(SV54,DisplayPlayer,Preset,C13func,PlayerID,Condition,PerAction,CpAction,Action)
	if CpAction == nil then
		CpAction = {}
	elseif CpAction.__trg_magic == "action" then
		CpAction = {CpAction}
	end
-- Preset(CA) : SV54 select / wait(가변) / wait adder / loop counter(가변) / loop limit / Nextptr Temp / Delay(가변) / Delay Adder
-- 내부변수(CB) : SV54 epd(+0x15C) / SV54 Size = 54 / SV54 Offset(+0x0) / display off 

CIf(PlayerID,Condition,Action)

	local CA = {} -- 8-1
	local CB = {} -- 4
	local CTemp

	if Preset[1] == nil or Preset[1] == 0 then
		Preset[1] = 1
	end
	if Preset[2] == nil then
		Preset[2] = 0
	end
	if Preset[3] == nil then
		Preset[3] = 0
	end
	if Preset[4] == nil then
		Preset[4] = 0
	end
	if Preset[5] == nil or Preset[5] == 0 then
		Preset[5] = 1
	end
	if Preset[7] == nil then
		Preset[7] = 0
	end
	if Preset[8] == nil then
		Preset[8] = 0
	end

	for i = 1, 8 do -- CA : Preset
		if i ~= 6 then
			if type(Preset[i]) == "number" then 
				CTemp = CreateVar2(PlayerID,nil,SetTo,Preset[i])
			else
				CTemp = CreateVar(PlayerID)
			end
		else
			CTemp = CreateVar(PlayerID)
		end
		table.insert(CA,CTemp)
	end
	CB = CreateVarArr(4,PlayerID)
	-------- Preset Limit --------------------------------
	for i = 1, 8 do
		if i ~= 6 then
			if type(Preset[i]) ~= "number" then
				CMov(PlayerID,CA[i],Preset[i])
			end
		end
	end

	CIf(PlayerID,NVar(CA[1],AtLeast,1))
		if SV54[4] == "SV54" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label();
				},
				actions = {
					SetNVar(CA[1],SetTo,0);
					SetCtrig1X(CB[2][1],CB[2][2],0x15C,CB[2][3],SetTo,54*8);
					SetCtrigX(CB[1][1],CB[1][2],0x15C,CB[1][3],SetTo,SV54[1],SV54[2],0x15C,1,SV54[3]);
					SetCtrigX(CB[3][1],CB[3][2],0x15C,CB[3][3],SetTo,SV54[1],SV54[2],0x0,0,SV54[3]);
				},
				flag = {Preserved}
			}
		else
			for i = 1, #SV54 do
				Trigger {
					players = {PlayerID},
					conditions = {
						Label();
						NVar(CA[1],Exactly,i);
					},
					actions = {
						SetNVar(CA[1],SetTo,0);
						SetCtrig1X(CB[2][1],CB[2][2],0x15C,CB[2][3],SetTo,54*8);
						SetCtrigX(CB[1][1],CB[1][2],0x15C,CB[1][3],SetTo,SV54[i][1],SV54[i][2],0x15C,1,SV54[i][3]);
						SetCtrigX(CB[3][1],CB[3][2],0x15C,CB[3][3],SetTo,SV54[i][1],SV54[i][2],0x0,0,SV54[i][3]);
					},
					flag = {Preserved}
				}
			end
		end
	CIfEnd()

	
		NWhile(PlayerID,{NVar(CA[2],Exactly,0)})
			NIfX(PlayerID,{TNVar(CA[4],AtMost,Vi(CA[5][2],-1))})
		-------------------------------------------------------------------------
				CAPrintPlayerID = PlayerID
				CAPrintDataArr = CA
				CAPrintCreateArr = CB

				if C13func ~= nil then
					_G[C13func]()
				end
		-------------------------------------------------------------------------
				
				if PerAction == nil then PerAction = {} end
				table.insert(PerAction,SetNVar(CA[4],Add,1))
				CDoActionsX(PlayerID,PerAction)
			NElseX()
				CDoActions(PlayerID,{TSetNVar(CA[2],SetTo,CA[3]),SetNVar(CA[4],SetTo,0),SetNext("X",CAPrintVarAlloc)})
			NIfXEnd()
		NWhileEnd()
		Trigger {players = {PlayerID},conditions = {Label(CAPrintVarAlloc)},flag = {Preserved}}
		CAPrintVarAlloc = CAPrintVarAlloc + 1

		local VariableTrig = {}
		local DisplayPlayers = {}
		local Box = {SetMemory(0x628438,SetTo,0),SetCVar("X",CRet[1],SetTo,0)}
		if DisplayPlayer ~= nil then
			for k, v in pairs(DisplayPlayer) do
				if type(v) == "table" and v[4] == "V" then
					table.insert(Box,{TCreateUnit,1,0,"Anywhere",v})
					table.insert(VariableTrig,v)
				else
					table.insert(DisplayPlayers,v)
				end
			end
		end

		local CpActions = CpAction
		if #VariableTrig <= 1 then
			CIf(PlayerID,{NVar(CB[4],Exactly,0),NVar(CA[7],Exactly,0)},{TSetNVar(CA[7],SetTo,CA[8]),table.unpack(CopyCpActionX(CpActions,DisplayPlayers))})
		else
			CIf(PlayerID,{NVar(CB[4],Exactly,0),NVar(CA[7],Exactly,0)},{TSetNVar(CA[7],SetTo,CA[8])})
		end
			DisplayPlayers = PlayerConvert2(DisplayPlayers)
			for i = 0, 7 do
				if DisplayPlayers[i+1] == 1 then
					table.insert(Box,CreateUnit(1,0,"Anywhere",i))
				end
			end
			CIf(PlayerID,Memory(0x628438,AtLeast,1))
				f_ReadX(PlayerID,0x628438,CA[6],1,0xFFFFFFFF)
				CDoActionsX(PlayerID,Box)

				for k, v in pairs(VariableTrig) do
					CTrigger(PlayerID,{TMemory(0x512684,Exactly,v)},{SetCVar("X",CRet[1],SetTo,1)},{Preserved})
				end

				for i = 0, 7 do
					if DisplayPlayers[i+1] == 1 then
						Trigger {
							players = {PlayerID},
							conditions = {
								Label();
								LocalPlayerID(i);
							},
							actions = {
								SetCVar("X",CRet[1],SetTo,1);
							},
							flag = {Preserved}
						}
					end
				end

				CIf(PlayerID,CVar("X",CRet[1],Exactly,1))
					Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X("X","X",0x178,1,SetTo,-(0x158/4));
							SetCtrig1X(CB[1][1],CB[1][2],0x148,CB[1][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[1][1],CB[1][2],0x160,CB[1][3],SetTo,Add*16777216,0xFF000000);
							SetCtrigX(CB[1][1],CB[1][2],0x158,CB[1][3],SetTo,"X","X",0x178,1,1);
							SetCtrig1X(CB[3][1],CB[3][2],0x148,CB[3][3],SetTo,0xFFFFFFFF);
							SetCtrig1X(CB[3][1],CB[3][2],0x160,CB[3][3],SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX(CB[3][1],CB[3][2],0x158,CB[3][3],SetTo,"X","X",0x15C,1,1);
							CallLabelAlways2(CB[1][1],CB[1][2],CB[1][3],CB[3][1],CB[3][2],CB[3][3]);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {PlayerID},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X("X","X",0x4,0,SetTo,0);
							SetCtrig2X(0,SetTo,"X","X",0x0,0,1);
						},
						flag = {Preserved}
					}
				CIfEnd()
				CMov(PlayerID,0x628438,CA[6])
			CIfEnd()
			RecoverCp(PlayerID)
		CIfEnd()
	CIfEnd()
	DoActionsX(PlayerID,{SetNVar(CA[2],Subtract,1),SetNVar(CA[7],Subtract,1)})

	local Ret = CA, CB
	CAPrintPlayerID = {}
	CAPrintDataArr = {}
	CAPrintCreateArr = {}
	return Ret
end

function SetUnitName(UnitId,StringId)
	if type(UnitId) == "string" then
		UnitId = ParseUnit(UnitId)
	end
	if UnitId < 0 or UnitId > 227 then
		SetUnitName_InputData_Error()
	end
	return SetMemoryW(0x660260+UnitId*2,SetTo,StringId)
end

function PlayerName(TargetPlayer,Name,Length)
	if Length == nil then
		Length = 16
	end
	if Length < 1 or Length > 16 then
		PlayerName_InputData_Error()
	end

	local Arr, Size
	Arr, Size = GetStrArr(1,Name)
	local Box = {}

	local i = 1
	while true do
		local Value = 0
		local Mask = 0xFFFFFFFF
		if i>Length then
			break
		else
			if Arr[i] ~= nil then
				Value = Value + Arr[i]
			end

			if i+1>Length then
				Mask = 0xFF
			else
				if Arr[i+1] ~= nil then
					Value = Value + Arr[i+1]*256
				end

				if i+2>Length then
					Mask = 0xFFFF
				else
					if Arr[i+2] ~= nil then
						Value = Value + Arr[i+2]*65536
					end

					if i+3>Length then
						Mask = 0xFFFFFF
					else
						if Arr[i+3] ~= nil then
							Value = Value + Arr[i+3]*16777216
						end
					end
				end
			end
		end

		i = i+4
		table.insert(Box,MemoryX(0x6D0FDC+0x24*TargetPlayer+i-5,Exactly,Value,Mask))
		if i > 16 then break end
	end

	return Box
end

function HostName(Name,Length)
	if Length == nil then
		Length = 16
	end
	if Length < 1 or Length > 16 then
		PlayerName_InputData_Error()
	end
	
	local Arr, Size
	Arr, Size = GetStrArr(1,Name)
	local Box = {}

	local i = 1
	while true do
		local Value = 0
		local Mask = 0xFFFFFFFF
		if i>Length then
			break
		else
			if Arr[i] ~= nil then
				Value = Value + Arr[i]
			end

			if i+1>Length then
				Mask = 0xFF
			else
				if Arr[i+1] ~= nil then
					Value = Value + Arr[i+1]*256
				end

				if i+2>Length then
					Mask = 0xFFFF
				else
					if Arr[i+2] ~= nil then
						Value = Value + Arr[i+2]*65536
					end

					if i+3>Length then
						Mask = 0xFFFFFF
					else
						if Arr[i+3] ~= nil then
							Value = Value + Arr[i+3]*16777216
						end
					end
				end
			end
		end

		i = i+4
		table.insert(Box,MemoryX(0x6D0F78+i-5,Exactly,Value,Mask))
		if i > 16 then break end
	end

	return Box
end

function GetHostPlayerID(PlayerID,Output)
	CIfOnce(PlayerID,{},{SetNVar(Output,SetTo,-1)}) -- Observer
	for i = 0, 7 do
		CTrigger(PlayerID,{TMemory(0x6D0F78+0x4*0,Exactly,_Read(0x6D0FDC+0x24*i+0x4*0)),
		TMemory(0x6D0F78+0x4*1,Exactly,_Read(0x6D0FDC+0x24*i+0x4*1)),
		TMemory(0x6D0F78+0x4*2,Exactly,_Read(0x6D0FDC+0x24*i+0x4*2)),
		TMemory(0x6D0F78+0x4*3,Exactly,_Read(0x6D0FDC+0x24*i+0x4*3))},
		SetNVar(Output,SetTo,i))
	end
	CIfEnd()
end

function GetHostName(PlayerID,OutputVA,InitBytes) -- VA[1~5] 사용
	if InitBytes == nil then
		InitBytes = 0
	end
	GetNameVArr = GetVArray(OutputVA)
	DoActionsX(PlayerID,{SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3],SetTo,0x0D0D0D0D),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+1,SetTo,0x0D0D0D0D),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+2,SetTo,0x0D0D0D0D),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+3,SetTo,0x0D0D0D0D),
		SetCtrig1X(OutputVA[1],OutputVA[2],0x15C,OutputVA[3]+4,SetTo,0x0D0D0D0D)})
	if InitBytes == 0 then
		for i = 0, 3 do
			f_ReadX(PlayerID,0x6D0F78 +0x4*i,VArr(GetNameVArr,0+i),1,0xFFFFFFFF) -- 0123 -> 0123
		end
	elseif InitBytes == 1 then
		for i = 0, 3 do
			f_ReadX(PlayerID,0x6D0F78 +0x4*i,VArr(GetNameVArr,0+i),256,0xFFFFFF) -- 012->123 / 3->0 
			f_ReadX(PlayerID,0x6D0F78 +0x4*i,VArr(GetNameVArr,1+i),1/16777216,0xFF000000)
		end
	elseif InitBytes == 2 then
		for i = 0, 3 do
			f_ReadX(PlayerID,0x6D0F78 +0x4*i,VArr(GetNameVArr,0+i),65536,0xFFFF) -- 01->23 / 23->01 
			f_ReadX(PlayerID,0x6D0F78 +0x4*i,VArr(GetNameVArr,1+i),1/65536,0xFFFF0000)
		end
	elseif InitBytes == 3 then
		for i = 0, 3 do
			f_ReadX(PlayerID,0x6D0F78 +0x4*i,VArr(GetNameVArr,0+i),16777216,0xFF) -- 0->3 / 123->012 
			f_ReadX(PlayerID,0x6D0F78 +0x4*i,VArr(GetNameVArr,1+i),1/256,0xFFFFFF00)
		end
	end
end

function GetHostLength(PlayerID,Output,Multiplier)
	if Multiplier == nil then
		Multiplier = 1
	end
	for i = 2, 15 do
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
				MemoryB(0x6D0F78+i,AtLeast,1);
			},
			actions = {
				SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,(i+1)*Multiplier);
			},
			flag = {Preserved}
		}
	end
end

function ParseKeyName(KeyName)
	local KeyCodeDict = {
	    ['LBUTTON']= 0x01, ['RBUTTON']= 0x02, ['CANCEL']= 0x03, ['MBUTTON']= 0x04,
	    ['XBUTTON1']= 0x05, ['XBUTTON2']= 0x06, ['BACK']= 0x08, ['TAB']= 0x09,
	    ['CLEAR']= 0x0C, ['ENTER']= 0x0D, ['NX5']= 0x0E, ['SHIFT']= 0x10,
	    ['LCTRL']= 0x11, ['LALT']= 0x12, ['PAUSE']= 0x13, ['CAPSLOCK']= 0x14,
	    ['RALT']= 0x15, ['JUNJA']= 0x17, ['FINAL']= 0x18, ['RCTRL']= 0x19, ['ESC']= 0x1B,
	    ['CONVERT']= 0x1C, ['NONCONVERT']= 0x1D, ['ACCEPT']= 0x1E, ['MODECHANGE']= 0x1F,
	    ['SPACE']= 0x20, ['PGUP']= 0x21, ['PGDN']= 0x22, ['END']= 0x23, ['HOME']= 0x24,
	    ['LEFT']= 0x25, ['UP']= 0x26, ['RIGHT']= 0x27, ['DOWN']= 0x28,  -- ARROW keys
	    ['SELECT']= 0x29, ['PRINTSCREEN']= 0x2A, ['EXECUTE']= 0x2B, ['SNAPSHOT']= 0x2C,
	    ['INSERT']= 0x2D, ['DELETE']= 0x2E, ['HELP']= 0x2F,
	    ['0']= 0x30, ['1']= 0x31, ['2']= 0x32, ['3']= 0x33, ['4']= 0x34,
	    ['5']= 0x35, ['6']= 0x36, ['7']= 0x37, ['8']= 0x38, ['9']= 0x39,
	    ['A']= 0x41, ['B']= 0x42, ['C']= 0x43, ['D']= 0x44, ['E']= 0x45, ['F']= 0x46,
	    ['G']= 0x47, ['H']= 0x48, ['I']= 0x49, ['J']= 0x4A, ['K']= 0x4B, ['L']= 0x4C,
	    ['M']= 0x4D, ['N']= 0x4E, ['O']= 0x4F, ['P']= 0x50, ['Q']= 0x51, ['R']= 0x52,
	    ['S']= 0x53, ['T']= 0x54, ['U']= 0x55, ['V']= 0x56, ['W']= 0x57, ['X']= 0x58,
	    ['Y']= 0x59, ['Z']= 0x5A,
	    ['LWIN']= 0x5B, ['RWIN']= 0x5C, ['APPS']= 0x5D, ['SLEEP']= 0x5F,
	    ['NUMPAD0']= 0x60, ['NUMPAD1']= 0x61, ['NUMPAD2']= 0x62, ['NUMPAD3']= 0x63,
	    ['NUMPAD4']= 0x64, ['NUMPAD5']= 0x65, ['NUMPAD6']= 0x66, ['NUMPAD7']= 0x67,
	    ['NUMPAD8']= 0x68, ['NUMPAD9']= 0x69,
	    ['NUMPAD*']= 0x6A, ['NUMPAD+']= 0x6B, ['SEPARATOR']= 0x6C, ['NUMPAD-']= 0x6D,
	    ['NUMPAD.']= 0x6E, ['NUMPAD/']= 0x6F,
	    ['F1']= 0x70, ['F2']= 0x71, ['F3']= 0x72, ['F4']= 0x73, ['F5']= 0x74,
	    ['F6']= 0x75, ['F7']= 0x76, ['F8']= 0x77, ['F9']= 0x78, ['F10']= 0x79,
	    ['F11']= 0x7A, ['F12']= 0x7B, ['F13']= 0x7C, ['F14']= 0x7D, ['F15']= 0x7E,
	    ['F16']= 0x7F, ['F17']= 0x80, ['F18']= 0x81, ['F19']= 0x82, ['F20']= 0x83,
	    ['F21']= 0x84, ['F22']= 0x85, ['F23']= 0x86, ['F24']= 0x87,
	    ['NUMLOCK']= 0x90, ['SCROLL']= 0x91, ['OEM_FJ_JISHO']= 0x92,
	    ['OEM_FJ_MASSHOU']= 0x93, ['OEM_FJ_TOUROKU']= 0x94,
	    ['OEM_FJ_LOYA']= 0x95, ['OEM_FJ_ROYA']= 0x96,
	    ['LSHIFT']= 0xA0, ['RSHIFT']= 0xA1, ['LCONTROL']= 0xA2, ['RCONTROL']= 0xA3,
	    ['LMENU']= 0xA4, ['RMENU']= 0xA5,
	    ['BROWSER_BACK']= 0xA6, ['BROWSER_FORWARD']= 0xA7, ['BROWSER_REFRESH']= 0xA8,
	    ['BROWSER_STOP']= 0xA9, ['BROWSER_SEARCH']= 0xAA, ['BROWSER_FAVORITES']= 0xAB,
	    ['BROWSER_HOME']= 0xAC,
	    ['VOLUME_MUTE']= 0xAD, ['VOLUME_DOWN']= 0xAE, ['VOLUME_UP']= 0xAF,
	    ['MEDIA_NEXT_TRACK']= 0xB0, ['MEDIA_PLAY_PAUSE']= 0xB3,
	    ['MEDIA_PREV_TRACK']= 0xB1, ['MEDIA_STOP']= 0xB2,
	    ['LAUNCH_MAIL']= 0xB4, ['LAUNCH_MEDIA_SELECT']= 0xB5, ['LAUNCH_APP1']= 0xB6,
	    ['LAUNCH_APP2']= 0xB7,
	    ['SEMICOLON']= 0xBA, ['=']= 0xBB, [',']= 0xBC, ['-']= 0xBD, ['.']= 0xBE, ['/']= 0xBF,
	    ['`']= 0xC0, ['ABNT_C1']= 0xC1, ['ABNT_C2']= 0xC2,
	    ['[']= 0xDB, ['|']= 0xDC, [']']= 0xDD, ["'"]= 0xDE, ['OEM_8']= 0xDF,
	    ['OEM_AX']= 0xE1, ['OEM_102']= 0xE2, ['ICO_HELP']= 0xE3, ['ICO_00']= 0xE4,
	    ['PROCESSKEY']= 0xE5, ['ICO_CLEAR']= 0xE6, ['PACKET']= 0xE7, ['OEM_RESET']= 0xE9,
	    ['OEM_JUMP']= 0xEA, ['OEM_PA1']= 0xEB, ['OEM_PA2']= 0xEC, ['OEM_PA3']= 0xED,
	    ['OEM_WSCTRL']= 0xEE, ['OEM_CUSEL']= 0xEF,
	    ['OEM_ATTN']= 0xF0, ['OEM_FINISH']= 0xF1, ['OEM_COPY']= 0xF2, ['OEM_AUTO']= 0xF3,
	    ['OEM_ENLW']= 0xF4, ['OEM_BACKTAB'] = 0xF5, ['ATTN']= 0xF6, ['CRSEL']= 0xF7,
	    ['EXSEL']= 0xF8, ['EREOF']= 0xF9, ['PLAY']= 0xFA, ['ZOOM']= 0xFB, ['NONAME']= 0xFC,
	    ['PA1']= 0xFD, ['OEM_CLEAR']= 0xFE, ['_NONE_']= 0xFF
	}

	local ret = KeyCodeDict[KeyName]
	if ret == nil then
		PushErrorMsg(KeyName.."Doesn't Exist.")
	end
	ret = 0x596A18+ret
	return ret
end

function KeyPress(KeyName,Status) -- 1 = Set(02) / 0 = Cleared(03)
	if Status == "Down" then
		return MemoryB(ParseKeyName(KeyName),Exactly,1)
	elseif Status == "Up" then
		return MemoryB(ParseKeyName(KeyName),Exactly,0)
	else
		KeyPress_InputData_Error()
	end
end

function TTKeyPress(KeyName,Status) -- "Up" (1->0)/ "Down" (0->1)
	local Mode
	if Status == "Down" then
		Mode = 20
	elseif Status == "Up" then
		Mode = 21
	else
		TTKeyPress_TypeError()
	end

	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
				
	local TTKeyPress = MemoryB(ParseKeyName(KeyName),Exactly,1)

	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,TTKeyPress)
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local KeyPress = CDeaths("X",Exactly,1,FCode)
	return KeyPress
end

function ParseMouseName(KeyName)
	local MouseButtonDict = {["L"]= 2, ["LEFT"]= 2, ["R"]= 8, ["RIGHT"]= 8, ["M"]= 32, ["MIDDLE"]= 32}
	local ret = MouseButtonDict[KeyName]
	if ret == nil then
		PushErrorMsg(KeyName.."Doesn't Exist.")
	end
	return ret
end

function MousePress(KeyName,Status) -- 1 = Set(02) / 0 = Cleared(03)
	if Status == "Down" then
		local CBit = ParseMouseName(KeyName)
		return MemoryX(0x6CDDC0,Exactly,CBit,CBit)
	elseif Status == "Up" then
		local CBit = ParseMouseName(KeyName)
		return MemoryX(0x6CDDC0,Exactly,0,CBit)
	else
		MousePress_InputData_Error()
	end
end

function TTMousePress(KeyName,Status) -- "Up" (1->0)/ "Down" (0->1)
	local Mode
	if Status == "Down" then
		Mode = 20
	elseif Status == "Up" then
		Mode = 21
	else
		TTMousePress_TypeError()
	end

	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)
	local Y = {}
	
	local CBit = ParseMouseName(KeyName)
	local TTMousePress = FMemoryX(0x6CDDC0,Exactly,CBit,CBit)

	table.insert(TTPushTrigArr,Y)
	table.insert(TTPushCondArr,TTMousePress)
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local MousePress = CDeaths("X",Exactly,1,FCode)
	return MousePress
end

function NotTyping()
    return Memory(0x68C144, Exactly, 0)
end

function IsTyping()
	return Memory(0x68C144, AtLeast, 1)
end

function Stage(PlayerID,Step,StageData) --<N or <a,b>,<Actions>,<Conditions>,<flag>,<index>>
	for k, v in pairs(StageData) do
		local ACond = {}
		local AAct = {}
		local Aflag = {Preserved}
		local AIndex = 0
		if v[2] ~= nil then
			AAct = v[2]
		end
		if v[3] ~= nil then
			ACond = v[3]
		end
		if v[4] ~= nil then
			Aflag = v[4]
		end
		if v[5] ~= nil then
			AIndex = v[5]
		end

		if type(v[1]) == "number" then
			if type(Step) == "number" then
				table.insert(ACond,Memory(Step,Exactly,v[1]))
			elseif #Step == 1 then
				table.insert(ACond,CDeaths("X",Exactly,v[1],Step[1]))
			elseif Step[4] == "V" then
				table.insert(ACond,CtrigX(Step[1],Step[2],0x15C,Step[3],Exactly,v[1]))
			else
				table.insert(ACond,CtrigX(Step[1],Step[2],Step[3],Step[4],Exactly,v[1]))
			end
		else -- table <a,b>
			if type(Step) == "number" then
				table.insert(ACond,Memory(Step,AtLeast,v[1][1]))
				table.insert(ACond,Memory(Step,AtMost,v[1][2]))
			elseif #Step == 1 then
				table.insert(ACond,CDeaths("X",AtLeast,v[1][1],Step[1]))
				table.insert(ACond,CDeaths("X",AtMost,v[1][2],Step[1]))
			elseif Step[4] == "V" then
				table.insert(ACond,CtrigX(Step[1],Step[2],0x15C,Step[3],AtLeast,v[1][1]))
				table.insert(ACond,CtrigX(Step[1],Step[2],0x15C,Step[3],AtMost,v[1][2]))
			else
				table.insert(ACond,CtrigX(Step[1],Step[2],Step[3],Step[4],AtLeast,v[1][1]))
				table.insert(ACond,CtrigX(Step[1],Step[2],Step[3],Step[4],AtMost,v[1][2]))
			end
		end

		CTriggerX(PlayerID,ACond,AAct,Aflag,AIndex)
	end	
end

function PlayerState(Player,State)
	return MemoryB(0x57EEE8+36*Player,Exactly,State)
end
function SetPlayerState(Player,State)
	return SetMemoryB(0x57EEE8+36*Player,SetTo,State)
end

function _Loc(LocationId,Direction)
	if type(LocationId) == "string" then
		LocationId = ParseLocation(LocationId)-1
	end
	if Direction == "L" then
		Direction = 0
	elseif Direction == "U" or Direction == 1 then
		Direction = 4
	elseif Direction == "R" or Direction == 2 then
		Direction = 8
	elseif Direction == "D" or Direction == 3 then
		Direction = 12
	end
	return 0x58DC60+LocationId*0x14+Direction
end

function FindSD(PlayerID,TargetPlayer,Location,Output,Preserve)
	local UnitId = 192
	if type(Location) == "table" then
		UnitId = Location[2]
		Location = Location[1]
	end

	local Box = {}
    local Box2 = {}
    if type(Output) == "number" then
    	table.insert(Box,SetMemory(Output,SetTo,0))
    	table.insert(Box2,SetMemory(Output,SetTo,1))
    elseif Output[4] == "V" then
    	table.insert(Box,SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,0))
    	table.insert(Box2,SetCtrig1X(Output[1],Output[2],0x15C,Output[3],SetTo,1))
    else
    	table.insert(Box,SetCtrig1X(Output[1],Output[2],Output[3],Output[4],SetTo,0))
    	table.insert(Box2,SetCtrig1X(Output[1],Output[2],Output[3],Output[4],SetTo,1))
    end
    if Preserve == 0 then
    	CIfOnce(PlayerID)
    end
    f_Read(PlayerID,0x62848C,V(NRet[5])) -- 화면 x좌표
    f_Read(PlayerID,0x6284A8,V(NRet[6])) -- 화면 y좌표

    DoActionsX(PlayerID,{
    SetLoc(Location,0,SetTo,0);
    SetLoc(Location,4,SetTo,0);
    SetLoc(Location,8,SetTo,0);
    SetLoc(Location,12,SetTo,0);
    SetCp(TargetPlayer);
    MoveLocation(Location, UnitId, TargetPlayer, "Anywhere"), -- 로케이션 크기는 0,0
    CenterView(Location),
    Box,
    })
    
    f_Read(PlayerID,_Loc(Location,0),V(NRet[1])) -- 로케이션의 x좌표
    f_Read(PlayerID,0x62848C,V(NRet[2])) -- 화면의 x좌표
    f_Read(PlayerID,_Loc(Location,4),V(NRet[3])) -- 로케이션의 y좌표
    f_Read(PlayerID,0x6284A8,V(NRet[4])) -- 화면의 y좌표
    
    CTrigger(PlayerID,{TCVar("X",NRet[1],Exactly,Vi(NRet[2],320))},Box2,{Preserved}) -- 로케이션과 화면의 좌표 차이가 320이면

    CAdd(PlayerID,V(NRet[5]),V(NRet[1]))
    CSub(PlayerID,V(NRet[5]),V(NRet[2]))
    CAdd(PlayerID,V(NRet[6]),V(NRet[3]))
    CSub(PlayerID,V(NRet[6]),V(NRet[4]))

    CDoActions(PlayerID,{
    TSetLoc(Location,0,SetTo,V(NRet[5]));
    TSetLoc(Location,4,SetTo,V(NRet[6]));
    TSetLoc(Location,8,SetTo,V(NRet[5]));
    TSetLoc(Location,12,SetTo,V(NRet[6]));
    SetCp(TargetPlayer);
    CenterView(Location),
    })

    RecoverCp(PlayerID)
    if Preserve == 0 then
    	CIfEnd()
    end

    -- 센터뷰 화면좌표로 복구
end

function f_OffsetToAlphaID(PlayerID,Input,Output) 
	--alphaID = 2048 * tos(0xA5) + 1 (index=0)
	--alphaID = 2048 * tos(0xA5) + 1701 - index(1~1699)
	STPopTrigArr(PlayerID)

	-- Input Data 
	if type(Input) == "number" then
		Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",NRet[4],0x15C,0,SetTo,Input);
						},
						flag = {Preserved}
					}
	elseif Input[4] == "V" then
		Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",NRet[4],0x15C,1,0);
						SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Input[1],Input[2],Input[3]);
						},
						flag = {Preserved}
					}
	end

		-- Call f_OTI
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCTACall0,0x0,0,0);
					SetCtrigX("X",FCTACall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
		if FCTACall1 == 0 then
			Need_Include_MiscFunc()
		end


		if type(Output) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",NRet[3],0x158,0,SetTo,EPD(Output));
							SetCtrig1X("X",NRet[3],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",NRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",NRet[3],0);
						},
						flag = {Preserved}
					}
		elseif Output[4] == "V" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",NRet[3],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
							SetCtrig1X("X",NRet[3],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",NRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",NRet[3],0);
						},
						flag = {Preserved}
					}
		else
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",NRet[3],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
							SetCtrig1X("X",NRet[3],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",NRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",NRet[3],0);
						},
						flag = {Preserved}
					}
		end
	FCTACheck = 1
end

function f_EPDToAlphaID(PlayerID,Input,Output) 
	STPopTrigArr(PlayerID)

	-- Input Data 
	if type(Input) == "number" then
		Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",NRet[1],0x15C,0,SetTo,Input);
						},
						flag = {Preserved}
					}
	elseif Input[4] == "V" then
		Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",NRet[1],0x15C,1,0);
						SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Input[1],Input[2],Input[3]);
						},
						flag = {Preserved}
					}
	end

		-- Call f_ETI
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCTACall1,0x0,0,0);
					SetCtrigX("X",FCTACall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
		if FCTACall1 == 0 then
			Need_Include_MiscFunc()
		end


		if type(Output) == "number" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X("X",NRet[3],0x158,0,SetTo,EPD(Output));
							SetCtrig1X("X",NRet[3],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",NRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",NRet[3],0);
						},
						flag = {Preserved}
					}
		elseif Output[4] == "V" then
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",NRet[3],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
							SetCtrig1X("X",NRet[3],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",NRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",NRet[3],0);
						},
						flag = {Preserved}
					}
		else
			Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",NRet[3],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
							SetCtrig1X("X",NRet[3],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",NRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",NRet[3],0);
						},
						flag = {Preserved}
					}
		end
	FCTACheck = 1
end

function f_AlphaIDToCunit(PlayerID,Input,Output,EPDOutput) -- Index = 3749-Cunit / Index = 0 -> 2049
	STPopTrigArr(PlayerID)

	-- Input Data 
	if type(Input) == "number" then
		Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrig1X("X",NRet[1],0x15C,0,SetTo,Input);
						},
						flag = {Preserved}
					}
	elseif Input[4] == "V" then
		Trigger {
						players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
						SetCtrigX(Input[1],Input[2],0x158,Input[3],SetTo,"X",NRet[1],0x15C,1,0);
						SetCtrig1X(Input[1],Input[2],0x148,Input[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Input[1],Input[2],0x160,Input[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Input[1],Input[2],Input[3]);
						},
						flag = {Preserved}
					}
	end
		-- Call f_ITC
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FATCCall1,0x0,0,0);
					SetCtrigX("X",FATCCall2,0x4,0,SetTo,"X","X",0x0,0,1);
				},
				flag = {Preserved}
			}
		if FATCCall1 == 0 then
			Need_Include_MiscFunc()
		end
		if Output ~= nil then
			if type(Output) == "number" then
				Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",NRet[3],0x158,0,SetTo,EPD(Output));
								SetCtrig1X("X",NRet[3],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",NRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",NRet[3],0);
							},
							flag = {Preserved}
						}
			elseif Output[4] == "V" then
				Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",NRet[3],0x158,0,SetTo,Output[1],Output[2],0x15C,1,Output[3]);
								SetCtrig1X("X",NRet[3],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",NRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",NRet[3],0);
							},
							flag = {Preserved}
						}
			else
				Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",NRet[3],0x158,0,SetTo,Output[1],Output[2],Output[3],1,Output[4]);
								SetCtrig1X("X",NRet[3],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",NRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",NRet[3],0);
							},
							flag = {Preserved}
						}
			end
		end
		if EPDOutput ~= nil then
			if type(EPDOutput) == "number" then
				Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X("X",NRet[4],0x158,0,SetTo,EPD(EPDOutput));
								SetCtrig1X("X",NRet[4],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",NRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",NRet[4],0);
							},
							flag = {Preserved}
						}
			elseif EPDOutput[4] == "V" then
				Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",NRet[4],0x158,0,SetTo,EPDOutput[1],EPDOutput[2],0x15C,1,EPDOutput[3]);
								SetCtrig1X("X",NRet[4],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",NRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",NRet[4],0);
							},
							flag = {Preserved}
						}
			else
				Trigger {
							players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X",NRet[4],0x158,0,SetTo,EPDOutput[1],EPDOutput[2],EPDOutput[3],1,EPDOutput[4]);
								SetCtrig1X("X",NRet[4],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",NRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								CallLabelAlways("X",NRet[4],0);
							},
							flag = {Preserved}
						}
			end
		end
	FATCCheck = 1
end

function HotkeyUnit(Player,Group,Index,Type,Value)
	return FMemory(0x57FE60+0x360*Player+0x30*Group+0x4*Index,Type,Value)
end

function SetHotkeyUnit(Player,Group,Index,Type,Value)
	return FSetMemory(0x57FE60+0x360*Player+0x30*Group+0x4*Index,Type,Value)
end

function THotkeyUnit(Player,Group,Index,Type,Value)
	if type(Index) == "number" then
		return TDeaths(EPD(0x57FE60+0x360*Player+0x4*Index),Type,Value,Group)
	else
		return TDeaths(Vi(Index[2],EPD(0x57FE60+0x360*Player),Index[1],Index[3]),Type,Value,Group)
	end
end

function TSetHotkeyUnit(Player,Group,Index,Type,Value)
	if type(Index) == "number" then
		return TSetDeaths(EPD(0x57FE60+0x360*Player+0x4*Index),Type,Value,Group)
	else
		return TSetDeaths(Vi(Index[2],EPD(0x57FE60+0x360*Player),Index[1],Index[3]),Type,Value,Group)
	end
end

function TTHotKeyUnit(Player,Group,Index,Type,Value)
	if type(Index) == "number" then
		return TTDeaths(EPD(0x57FE60+0x360*Player+0x4*Index),Type,Value,Group)
	else
		return TTDeaths(Vi(Index[2],EPD(0x57FE60+0x360*Player),Index[1],Index[3]),Type,Value,Group)
	end
end

function _HotKeyUnit(Player,Group,Index)
	return 0x57FE60+0x360*Player+0x30*Group+0x4*Index
end
--[[
function NSQCMov(PlayerID,VArray,Size,Output,Mask,ResetCond) -- VA
	local Var = CreateVar(PlayerID) -- V
	local Var4 = CreateVar(PlayerID)
	local CC = CreateCcode()

	CTrigger(PlayerID,ResetCond,{SetCDeaths("X",SetTo,0,CC)},{Preserved}) -- Reset (Ccode = 0)
	local Init
	if VArray[4] == "V" then
		Init = {SetNVar(Var,SetTo,0),SetNVar(Var4,SetTo,0)}
		VArray = {Var[1],Var[2],Var[3],"VA",VArray,0,Var4[1],Var4[2],Var4[3]}
	elseif Index[4] == "VA" then
		Init = {TSetNVar(Var,SetTo,V(VArray[2],VArray[1],VArray[3])),TSetNVar(Var4,SetTo,V(VArray[8],VArray[7],VArray[9]))}
	end
	CTrigger(PlayerID,CDeaths("X",Exactly,0,CC),Init,{Preserved})-- Ccode == 0 -> V << Index

	CIf(PlayerID,{TTCDeaths("X",iBelow,Size,CC)},{SetCDeaths("X",Add,1,CC),SetNVar(Var,Add,604),SetNVar(Var4,Add,0x970)}) -- Ccode < Size -> Ccode + 1, V + 1
		CMovX(PlayerID,Output,VArrX(VArray,Var,Var4,VArray[5][1]),nil,Mask,nil,1) -- Dest << VA[V]
	CIfEnd()
end
]]--
function NSQCSend(PlayerID,SourceVA,Size,Mask,Offset,ErrorCode,ResetCond,ResetAct)
	STPopTrigArr(PlayerID)	
	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	local Length = CreateVar(PlayerID)
	if ResetCond == nil then
		ResetCond = {}
	end
	table.insert(ResetCond,NVar(Length,Exactly,0))
	CIf(PlayerID,ResetCond,ResetAct)
		if SourceVA[4] == "V" then
			if type(Size) == "number" then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetNVar(Length,SetTo,1+Size);
						SetCtrigX("X",FuncAlloc,0x15C,0,SetTo,SourceVA[1],SourceVA[2],0x0,0,SourceVA[3]);
						SetCtrigX("X",FuncAlloc,0x178,0,SetTo,SourceVA[1],SourceVA[2],0x4,1,SourceVA[3]);
						SetCtrigX("X",FuncAlloc,0x198,0,SetTo,SourceVA[1],SourceVA[2],0x158,1,SourceVA[3]);
						SetCtrigX("X",FuncAlloc,0x1B8,0,SetTo,SourceVA[1],SourceVA[2],0x148,1,SourceVA[3]);
						SetCtrigX("X",FuncAlloc,0x1D8,0,SetTo,SourceVA[1],SourceVA[2],0x160,1,SourceVA[3]);
					},
					flag = {Preserved}
				}
			elseif Size[4] == "V" then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetNVar(Length,SetTo,1);
						SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,Length[1],Length[2],0x15C,Length[3]);
						SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,Add*16777216,0xFF000000);
						CallLabelAlways(Size[1],Size[2],Size[3]);
						SetCtrigX("X",FuncAlloc,0x15C,0,SetTo,SourceVA[1],SourceVA[2],0x0,0,SourceVA[3]);
						SetCtrigX("X",FuncAlloc,0x178,0,SetTo,SourceVA[1],SourceVA[2],0x4,1,SourceVA[3]);
						SetCtrigX("X",FuncAlloc,0x198,0,SetTo,SourceVA[1],SourceVA[2],0x158,1,SourceVA[3]);
						SetCtrigX("X",FuncAlloc,0x1B8,0,SetTo,SourceVA[1],SourceVA[2],0x148,1,SourceVA[3]);
						SetCtrigX("X",FuncAlloc,0x1D8,0,SetTo,SourceVA[1],SourceVA[2],0x160,1,SourceVA[3]);
					},
					flag = {Preserved}
				}
			end
		elseif SourceVA[4] == "VA" then
			if type(Size) == "number" then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetNVar(Length,SetTo,1+Size);
						SetCtrigX("X",FuncAlloc,0x15C,0,SetTo,SourceVA[5][1],SourceVA[5][2],0x0,0,SourceVA[5][3]);
						SetCtrigX("X",FuncAlloc,0x178,0,SetTo,SourceVA[5][1],SourceVA[5][2],0x4,1,SourceVA[5][3]);
						SetCtrigX("X",FuncAlloc,0x198,0,SetTo,SourceVA[5][1],SourceVA[5][2],0x158,1,SourceVA[5][3]);
						SetCtrigX("X",FuncAlloc,0x1B8,0,SetTo,SourceVA[5][1],SourceVA[5][2],0x148,1,SourceVA[5][3]);
						SetCtrigX("X",FuncAlloc,0x1D8,0,SetTo,SourceVA[5][1],SourceVA[5][2],0x160,1,SourceVA[5][3]);
						SetCtrigX(SourceVA[7],SourceVA[8],0x158,SourceVA[9],SetTo,"X",FuncAlloc,0x15C,1,0);
						SetCtrig1X(SourceVA[7],SourceVA[8],0x148,SourceVA[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(SourceVA[7],SourceVA[8],0x160,SourceVA[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(SourceVA[1],SourceVA[2],0x158,SourceVA[3],SetTo,"X",FuncAlloc,0x178,1,0);
						SetCtrig1X(SourceVA[1],SourceVA[2],0x148,SourceVA[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(SourceVA[1],SourceVA[2],0x160,SourceVA[3],SetTo,Add*16777216,0xFF000000);
						CallLabelAlways2(SourceVA[7],SourceVA[8],SourceVA[9],Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			elseif Size[4] == "V" then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetNVar(Length,SetTo,1);
						SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,Length[1],Length[2],0x15C,Length[3]);
						SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,Add*16777216,0xFF000000);
						SetCtrigX("X",FuncAlloc,0x15C,0,SetTo,SourceVA[5][1],SourceVA[5][2],0x0,0,SourceVA[5][3]);
						SetCtrigX("X",FuncAlloc,0x178,0,SetTo,SourceVA[5][1],SourceVA[5][2],0x4,1,SourceVA[5][3]);
						SetCtrigX("X",FuncAlloc,0x198,0,SetTo,SourceVA[5][1],SourceVA[5][2],0x158,1,SourceVA[5][3]);
						SetCtrigX("X",FuncAlloc,0x1B8,0,SetTo,SourceVA[5][1],SourceVA[5][2],0x148,1,SourceVA[5][3]);
						SetCtrigX("X",FuncAlloc,0x1D8,0,SetTo,SourceVA[5][1],SourceVA[5][2],0x160,1,SourceVA[5][3]);
						SetCtrigX(SourceVA[7],SourceVA[8],0x158,SourceVA[9],SetTo,"X",FuncAlloc,0x15C,1,0);
						SetCtrig1X(SourceVA[7],SourceVA[8],0x148,SourceVA[9],SetTo,0xFFFFFFFF);
						SetCtrig1X(SourceVA[7],SourceVA[8],0x160,SourceVA[9],SetTo,Add*16777216,0xFF000000);
						SetCtrigX(SourceVA[1],SourceVA[2],0x158,SourceVA[3],SetTo,"X",FuncAlloc,0x178,1,0);
						SetCtrig1X(SourceVA[1],SourceVA[2],0x148,SourceVA[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(SourceVA[1],SourceVA[2],0x160,SourceVA[3],SetTo,Add*16777216,0xFF000000);
						CallLabelAlways3(Size[1],Size[2],Size[3],SourceVA[7],SourceVA[8],SourceVA[9],Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}
			end
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(SourceVA[1],SourceVA[2],0x158,SourceVA[3],SetTo,"X",FuncAlloc,0x198,1,0);
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(SourceVA[1],SourceVA[2],0x158,SourceVA[3],SetTo,"X",FuncAlloc,0x1B8,1,0);
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(SourceVA[1],SourceVA[2],0x158,SourceVA[3],SetTo,"X",FuncAlloc,0x1D8,1,0);
					CallLabelAlways(Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
		end
	CIfEnd()

	CIfX(PlayerID,{NVar(Length,AtLeast,2)},{SetNVar(Length,Subtract,1)})
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(FuncAlloc);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]);
					SetCtrig2X(0,SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1);
					SetDeaths(0,SetTo,EPD(Offset),0); -- SetCtrigX(VA[1],VA[2],0x158,VA[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetDeaths(0,SetTo,Mask,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF);
					SetDeathsX(0,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000);

					SetCtrig1X("X",FuncAlloc,0x15C,0,Add,0x970);
					SetCtrig1X("X",FuncAlloc,0x178,0,Add,604);
					SetCtrig1X("X",FuncAlloc,0x198,0,Add,604);
					SetCtrig1X("X",FuncAlloc,0x1B8,0,Add,604);
					SetCtrig1X("X",FuncAlloc,0x1D8,0,Add,604);
				},
				flag = {Preserved}
			}
		FuncAlloc = FuncAlloc+1
	CElseIfX({NVar(Length,Exactly,1)},{SetNVar(Length,Subtract,1),SetMemory(Offset,SetTo,ErrorCode)})
	CIfXEnd()
	return Length
end

function NSQCReceive(PlayerID,DestVA,Size,TargetPlayer,NSQCIndex,ErrorCode,ErrorCheck,ResetCond,ResetAct)
	STPopTrigArr(PlayerID)	
	if TargetPlayer < 0 or TargetPlayer > 7 then 
		NSQCReceive_InputData_Error()
	end
	local Length = CreateVar(PlayerID)
	local CC = CreateCcode()
	if ResetCond == nil then
		ResetCond = {}
	end
	local SkipAct = {}
	if type(ErrorCode) == "table" then
		SkipAct = {SetCtrig1X(FixPlayer,NSQCVArray[NSQCIndex][2],0x15C,TargetPlayer,SetTo,ErrorCode[2])}
		ErrorCode = ErrorCode[1]
	end
	table.insert(ResetCond,TTCVAar(VArr(NSQCVArray[NSQCIndex],TargetPlayer,FixPlayer),NotSame,ErrorCode))
	table.insert(ResetCond,NVar(Length,Exactly,0))
	CIf(PlayerID,ResetCond,ResetAct)
		if DestVA[4] == "V" then
			if type(Size) == "number" then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCDeaths("X",SetTo,0,CC);
						SetNVar(Length,SetTo,Size);
						SetCtrigX("X",FuncAlloc,0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]);
					},
					flag = {Preserved}
				}
			elseif Size[4] == "V" then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCDeaths("X",SetTo,0,CC);
						SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,Length[1],Length[2],0x15C,Length[3]);
						SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Size[1],Size[2],Size[3]);
						SetCtrigX("X",FuncAlloc,0x15C,0,SetTo,DestVA[1],DestVA[2],0x15C,1,DestVA[3]);
					},
					flag = {Preserved}
				}
			end
		elseif DestVA[4] == "VA" then
			if type(Size) == "number" then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCDeaths("X",SetTo,0,CC);
						SetNVar(Length,SetTo,Size);
						SetCtrigX(DestVA[1],DestVA[2],0x158,DestVA[3],SetTo,"X",FuncAlloc,0x15C,1,0);
						SetCtrig1X(DestVA[1],DestVA[2],0x148,DestVA[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(DestVA[1],DestVA[2],0x160,DestVA[3],SetTo,Add*16777216,0xFF000000);
						CallLabelAlways(Dest[1],Dest[2],Dest[3]);
						SetCtrigX("X",FuncAlloc,0x15C,0,SetTo,DestVA[5][1],DestVA[5][2],0x15C,1,DestVA[5][3]);
					},
					flag = {Preserved}
				}
			elseif Size[4] == "V" then
				Trigger {
					players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCDeaths("X",SetTo,0,CC);
						SetCtrigX(Size[1],Size[2],0x158,Size[3],SetTo,Length[1],Length[2],0x15C,Length[3]);
						SetCtrig1X(Size[1],Size[2],0x148,Size[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Size[1],Size[2],0x160,Size[3],SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX(DestVA[1],DestVA[2],0x158,DestVA[3],SetTo,"X",FuncAlloc,0x15C,1,0);
						SetCtrig1X(DestVA[1],DestVA[2],0x148,DestVA[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(DestVA[1],DestVA[2],0x160,DestVA[3],SetTo,Add*16777216,0xFF000000);
						CallLabelAlways2(Size[1],Size[2],Size[3],Dest[1],Dest[2],Dest[3]);
						SetCtrigX("X",FuncAlloc,0x15C,0,SetTo,DestVA[5][1],DestVA[5][2],0x15C,1,DestVA[5][3]);
					},
					flag = {Preserved}
				}
			end
		end
	CIfEnd()

	CIfX(PlayerID,{NVar(Length,AtLeast,1)},{SetNVar(Length,Subtract,1)},{SetNVar(ErrorCheck,SetTo,0)})	
		Trigger {
				players = {PlayerID},
				conditions = {
					Label();
					CVAar(VArr(NSQCVArray[NSQCIndex],TargetPlayer,FixPlayer),Exactly,ErrorCode);
				},
				actions = {
					SetCDeaths("X",SetTo,1,CC);
					SkipAct;
				},
				flag = {Preserved}
			}

		Trigger {
				players = {PlayerID},
				conditions = {
					Label(FuncAlloc);
				},
				actions = {
					SetCtrig1X(FixPlayer,NSQCVArray[NSQCIndex][2],0x158,TargetPlayer,SetTo,0); -- DestVA
					SetCtrigX("X","X",0x4,0,SetTo,FixPlayer,NSQCVArray[NSQCIndex][2],0x0,0,TargetPlayer); 
					SetCtrigX(FixPlayer,NSQCVArray[NSQCIndex][2],0x4,TargetPlayer,SetTo,"X","X",0,0,1); 
					SetCtrig1X(FixPlayer,NSQCVArray[NSQCIndex][2],0x148,TargetPlayer,SetTo,0xFFFFFFFF);
					SetCtrig1X(FixPlayer,NSQCVArray[NSQCIndex][2],0x160,TargetPlayer,SetTo,SetTo*16777216,0xFF000000);

					SetCtrig1X("X",FuncAlloc,0x15C,0,Add,604);
				},
				flag = {Preserved}
			}
		FuncAlloc = FuncAlloc+1
	CElseX({SetNVar(ErrorCheck,SetTo,1)})
		Trigger {
				players = {PlayerID},
				conditions = {
					Label();
					CDeaths("X",Exactly,1,CC);
				},
				actions = {
					SetNVar(ErrorCheck,SetTo,-1)
				},
				flag = {Preserved}
			}
	CIfXEnd()
	return Length
end

function SetMapSize(Value,Mask)
	return SetMemoryX(0x57F1D4,SetTo,Value,Mask)
end

function TSetMapSize(Value,Mask)
	return TSetMemoryX(0x57F1D4,SetTo,Value,Mask)
end

function RecallSprite(PlayerID,Owner,UnitId,Location,X,Y,Conditions,Actions,Preserve)
	local Act = {}
	if Conditions == nil then Conditions = {} end
	table.insert(Conditions,Memory(0x628438,AtLeast,1))
	if Preserve == 0 then
		CIfOnce2(PlayerID,Conditions)
	else
		CIf2(PlayerID,Conditions)
	end
		f_Read(PlayerID,0x628438,nil,V(NRet[16]))

		if type(Location) == "table" then
			local X2 = Location[2]
			if type(Location[2]) == "number" then
				table.insert(Act,SetLoc(Location[1],0,SetTo,X2))
				table.insert(Act,SetLoc(Location[1],8,SetTo,X2))
			elseif Location[2][4] == "V" then
				table.insert(Act,{TSetLoc,Location[1],0,SetTo,X2})
				table.insert(Act,{TSetLoc,Location[1],8,SetTo,X2})
			end
			local Y2 = Location[3]
			if type(Location[3]) == "number" then
				table.insert(Act,SetLoc(Location[1],4,SetTo,Y2))
				table.insert(Act,SetLoc(Location[1],12,SetTo,Y2))
			elseif Location[3][4] == "V" then
				table.insert(Act,{TSetLoc,Location[1],4,SetTo,Y2})
				table.insert(Act,{TSetLoc,Location[1],12,SetTo,Y2})
			end
			Location = Location[1]
		end

		if Actions ~= nil then
			for k, v in pairs(Actions) do
				table.insert(Act,v)
			end
		end

		table.insert(Act,CreateUnit(1,UnitId,Location,Owner))
		table.insert(Act,{TSetMemoryX,Vi(NRet[16],0x58/4),SetTo,X,0xFFFF})
		if type(Y) == "number" then
			table.insert(Act,{TSetMemoryX,Vi(NRet[16],0x58/4),SetTo,Y*65536,0xFFFF0000})
		elseif Y[4] == "V" then
			table.insert(Act,{TSetMemoryX,Vi(NRet[16],0x58/4),SetTo,{_lShift,Y,16},0xFFFF0000})
		end
		table.insert(Act,{TSetMemoryX,Vi(NRet[16],0x4C/4),SetTo,137*256,0xFF00})
		table.insert(Act,{TSetMemoryX,Vi(NRet[16],0x110/4),SetTo,3,0xFFFF})
		CDoActionsX(PlayerID,Act)
	CIfEnd()
end

function UnitSprite(PlayerID,Owner,UnitId,Height,Time,Location,Conditions,Actions,Preserve)
	local Act = {}
	if Time == "X" then
			if type(Height) == "number" then
				table.insert(Act,SetMemoryB(0x663150+UnitId,SetTo,Height))
			elseif Height[4] == "V" then 
				table.insert(Act,{TSetMemoryB,0x663150,UnitId,SetTo,Height})
			end

			if type(Location) == "table" then
				local X = Location[2]
				if type(Location[2]) == "number" then
					table.insert(Act,SetLoc(Location[1],0,SetTo,X))
					table.insert(Act,SetLoc(Location[1],8,SetTo,X))
				elseif Location[2][4] == "V" then
					table.insert(Act,{TSetLoc,Location[1],0,SetTo,X})
					table.insert(Act,{TSetLoc,Location[1],8,SetTo,X})
				end
				local Y = Location[3]
				if type(Location[3]) == "number" then
					table.insert(Act,SetLoc(Location[1],4,SetTo,Y))
					table.insert(Act,SetLoc(Location[1],12,SetTo,Y))
				elseif Location[3][4] == "V" then
					table.insert(Act,{TSetLoc,Location[1],4,SetTo,Y})
					table.insert(Act,{TSetLoc,Location[1],12,SetTo,Y})
				end
				Location = Location[1]
			end

			if Actions ~= nil then
				for k, v in pairs(Actions) do
					table.insert(Act,v)
				end
			end

			if type(UnitId) == "number" then
				table.insert(Act,CreateUnit(1,UnitId,Location,Owner))
			else
				table.insert(Act,{TCreateUnit,1,UnitId,Location,Owner})
			end

			local Z = {Preserved}
			if Preserve == 0 then
				Z = {}
			end

			CTriggerX(PlayerID,Conditions,Act,Z)
	else
		if Conditions == nil then Conditions = {} end
		table.insert(Conditions,Memory(0x628438,AtLeast,1))
		if Preserve == 0 then
			CIfOnce2(PlayerID,Conditions)
		else
			CIf2(PlayerID,Conditions)
		end
			f_Read(PlayerID,0x628438,nil,V(NRet[1]))

			if type(Height) == "number" then
				table.insert(Act,SetMemoryB(0x663150+UnitId,SetTo,Height))
			elseif Height[4] == "V" then 
				table.insert(Act,{TSetMemoryB,0x663150,UnitId,SetTo,Height})
			end

			if type(Location) == "table" then
				local X = Location[2]
				if type(Location[2]) == "number" then
					table.insert(Act,SetLoc(Location[1],0,SetTo,X))
					table.insert(Act,SetLoc(Location[1],8,SetTo,X))
				elseif Location[2][4] == "V" then
					table.insert(Act,{TSetLoc,Location[1],0,SetTo,X})
					table.insert(Act,{TSetLoc,Location[1],8,SetTo,X})
				end
				local Y = Location[3]
				if type(Location[3]) == "number" then
					table.insert(Act,SetLoc(Location[1],4,SetTo,Y))
					table.insert(Act,SetLoc(Location[1],12,SetTo,Y))
				elseif Location[3][4] == "V" then
					table.insert(Act,{TSetLoc,Location[1],4,SetTo,Y})
					table.insert(Act,{TSetLoc,Location[1],12,SetTo,Y})
				end
				Location = Location[1]
			end

			if Actions ~= nil then
				for k, v in pairs(Actions) do
					table.insert(Act,v)
				end
			end

			if type(UnitId) == "number" then
				table.insert(Act,CreateUnit(1,UnitId,Location,Owner))
			else
				table.insert(Act,{TCreateUnit,1,UnitId,Location,Owner})
			end

			if Time ~= nil then
				table.insert(Act,{TSetMemoryX,Vi(NRet[1],0x110/4),SetTo,Time,0xFFFF})				
			end

			table.insert(Act,{TSetMemoryX,Vi(NRet[1],55),SetTo,0x100,0x100})
			table.insert(Act,{TSetMemory,Vi(NRet[1],57),SetTo,0})
			CDoActionsX(PlayerID,Act)
		CIfEnd()
	end
end

function ScanSprite(PlayerID,Number,Owner,RemoveScan,Location,Conditions,Actions,Preserve)
	local Act = {}
	if type(Location) == "table" then
		local X = Location[2]
		if type(Location[2]) == "number" then
			table.insert(Act,SetLoc(Location[1],0,SetTo,X))
			table.insert(Act,SetLoc(Location[1],8,SetTo,X))
		elseif Location[2][4] == "V" then
			table.insert(Act,{TSetLoc,Location[1],0,SetTo,X})
			table.insert(Act,{TSetLoc,Location[1],8,SetTo,X})
		end
		local Y = Location[3]
		if type(Location[3]) == "number" then
			table.insert(Act,SetLoc(Location[1],4,SetTo,Y))
			table.insert(Act,SetLoc(Location[1],12,SetTo,Y))
		elseif Location[3][4] == "V" then
			table.insert(Act,{TSetLoc,Location[1],4,SetTo,Y})
			table.insert(Act,{TSetLoc,Location[1],12,SetTo,Y})
		end
		Location = Location[1]
	end

	if RemoveScan == 1 then
		table.insert(Act,SetMemoryX(0x662EC0, SetTo, 0,0xFF00))
		table.insert(Act,SetMemoryX(0x662288, SetTo, 0,0xFF00))
	end

	if type(Number) == "number" then
		table.insert(Act,CreateUnit(Number,33,Location,Owner))
	else
		table.insert(Act,{TCreateUnit,Number,33,Location,Owner})
	end

	if Actions ~= nil then
		for k, v in pairs(Actions) do
			table.insert(Act,v)
		end
	end

	if RemoveScan == 1 then
		table.insert(Act,SetMemoryX(0x662EC0, SetTo, 140*256,0xFF00))
		table.insert(Act,SetMemoryX(0x662288, SetTo, 140*256,0xFF00))
	end

	local Z = {Preserved}
	if Preserve == 0 then
		Z = {}
	end

	CTriggerX(PlayerID,Conditions,Act,Z)
end

function ScanInitSetting(PlayerID,Preserve)
	local X = {Preserved}
	if Preserve == 0 then
		X = {}
	end
	DoActions(PlayerID,{
		SetMemory(0x6618D0, SetTo, 0); -- 스캔크기
		SetMemory(0x6618D4, SetTo, 0); -- 버터쿠키
		SetMemoryX(0x661558, SetTo, 0x1CF0000,0xFFFF0000), -- 에디터 어빌리티
	},X)
end

function BulletInitSetting(PlayerID,UnitId,Weapon,Flingy,Sprite,Image,Script,Color,Damage,DamageUp,UpgradeID,BulletNumber,DamageType,Special,Splash,Preserve)
	local X = {Preserved}
	if Preserve == 0 then
		X = {}
	end
	local BulletUnitFlingy = UnitId[2]
	local BulletUnitSprite = UnitId[3]
	local TrapAct, TrapAct2
	if UnitId[4] == 1 then
		TrapAct = SetMemory(0x664080+UnitId[1]*4, SetTo, 536870916) -- 스패셜 어빌리티
		TrapAct2 = SetMemoryB(0x660FC8+UnitId[1], SetTo, 0) -- 이동플래그
	else
		TrapAct = SetMemory(0x664080+UnitId[1]*4, SetTo, 939524100) -- 스패셜 어빌리티
		TrapAct2 = SetMemoryB(0x660FC8+UnitId[1], SetTo, 197) -- 이동플래그
	end
	UnitId = UnitId[1]
	BulletTable[UnitId]={Weapon,Flingy,Sprite}

	DoActions2(PlayerID,{
		SetMemoryB(0x6636B8+UnitId, SetTo, Weapon), -- 지상무기
		SetMemoryB(0x662DB8+UnitId, SetTo, 3), -- 부가사거리
		TrapAct,
		TrapAct2,
		SetMemory(0x6617C8+UnitId*8, SetTo, 65537), -- 유닛크기
		SetMemory(0x6617CC+UnitId*8, SetTo, 0), -- 버터쿠키
		SetMemoryB(0x6644F8+UnitId, SetTo, BulletUnitFlingy), -- 비행정보
		SetMemoryB(0x6637A0+UnitId, SetTo, 2), -- 소속그룹
		SetMemoryW(0x661518+UnitId*2, SetTo, 0x1CF), -- 에디터 어빌리티
		SetMemory(0x662860+UnitId*4, SetTo, 1), -- 생산크기
		SetMemoryB(0x662EA0+UnitId, SetTo, 2), -- 컴퓨터 기본 Ai
		SetMemoryB(0x662268+UnitId, SetTo, 2), -- 사람 기본 Ai
		SetMemoryB(0x664898+UnitId, SetTo, 2), -- 평상시 Ai
		SetMemoryB(0x663320+UnitId, SetTo, 134), -- 유닛공격 Ai
		SetMemoryB(0x663A50+UnitId, SetTo, 135), -- 공격과 이동 Ai
		SetMemoryB(0x662098+UnitId, SetTo, 1), -- 우클릭 행동

		SetMemory(0x6C9EF8+BulletUnitFlingy*4, SetTo, 0), -- 최대속도
		SetMemoryW(0x6C9C78+BulletUnitFlingy*2, SetTo, 1), -- 가속도
		SetMemory(0x6C9930+BulletUnitFlingy*4, SetTo, 0), -- 멈추는거리
		SetMemoryB(0x6C9E20+BulletUnitFlingy, SetTo, 40), -- 회전반경
		SetMemoryB(0x6C9858+BulletUnitFlingy, SetTo, 0), -- 이동제어
		SetMemoryW(0x6CA318+BulletUnitFlingy*2, SetTo, BulletUnitSprite), -- 스프라이트
		SetMemoryW(0x666160+BulletUnitSprite*2, SetTo, 256), -- 이미지

		SetMemoryW(0x656EB0+Weapon*2,SetTo,Damage), -- 데미지
		SetMemoryW(0x657678+Weapon*2,SetTo,DamageUp), -- 추가데미지
		SetMemoryB(0x6564E0+Weapon, SetTo, BulletNumber), -- 총알갯수
		SetMemoryB(0x6571D0+Weapon, SetTo, UpgradeID), -- 업그레이드
		SetMemoryB(0x657258+Weapon, SetTo, DamageType), -- 데미지형식
		SetMemoryB(0x6566F8+Weapon, SetTo, Special), -- 폭발형
		SetMemoryW(0x656888+Weapon*2, SetTo, Splash[1]), -- 스플안쪽
		SetMemoryW(0x6570C8+Weapon*2, SetTo, Splash[2]), -- 스플중간
		SetMemoryW(0x657780+Weapon*2, SetTo, Splash[3]), -- 스플외각
		SetMemoryB(0x657888+Weapon, SetTo, 0), -- 발사회전값 
		SetMemory(0x656A18+Weapon*4, SetTo, 0), -- 최소사거리
		SetMemory(0x657470+Weapon*4, SetTo, 3), -- 최대사거리
		SetMemory(0x656CA8+Weapon*4, SetTo, Flingy), -- 무기 비행정보
		SetMemoryB(0x657910+Weapon, SetTo, 0), -- 발사위치X
		SetMemoryB(0x656C20+Weapon, SetTo, 2), -- 발사위치Y
		SetMemoryB(0x656990+Weapon, SetTo, 255), -- 공격 가능 각도

		SetMemoryW(0x6CA318+Flingy*2, SetTo, Sprite), -- 스프라이트
		SetMemoryW(0x6C9C78+Flingy*2, SetTo, 50000), -- 가속도
		SetMemory(0x6C9930+Flingy*4, SetTo, 0), -- 멈추는거리
		SetMemoryB(0x6C9E20+Flingy, SetTo, 127), -- 회전반경
		SetMemoryB(0x6C9858+Flingy, SetTo, 0), -- 이동제어

		SetMemoryW(0x666160+Sprite*2, SetTo, Image), -- 이미지

		SetMemoryB(0x669E28+Image, SetTo, Color), -- 화면출력
		SetMemory(0x66EC48+Image*4,SetTo,Script), -- 스크립트
	},X)
end

function CreateBullet(PlayerID,Owner,UnitId,Height,Angle,Speed,Time,Location,Conditions,Actions,Preserve)
	local Act = {}
	if Conditions == nil then Conditions = {} end
	table.insert(Conditions,Memory(0x628438,AtLeast,1))
	if Preserve == 0 then
		CIfOnce2(PlayerID,Conditions)
	else
		CIf2(PlayerID,Conditions)
	end
		f_Read(PlayerID,0x628438,nil,V(NRet[16]))

		table.insert(Act,SetMemory(0x66F048, SetTo, 86))

		if type(Height) == "number" then
			table.insert(Act,SetMemoryB(0x663150+UnitId,SetTo,Height))
		elseif Height[4] == "V" then 
			table.insert(Act,{TSetMemoryB,0x663150,UnitId,SetTo,Height})
		end

		if type(Location) == "table" then
			local X = Location[2]
			if type(Location[2]) == "number" then
				table.insert(Act,SetLoc(Location[1],0,SetTo,X))
				table.insert(Act,SetLoc(Location[1],8,SetTo,X))
			elseif Location[2][4] == "V" then
				table.insert(Act,{TSetLoc,Location[1],0,SetTo,X})
				table.insert(Act,{TSetLoc,Location[1],8,SetTo,X})
			end
			local Y = Location[3]
			if type(Location[3]) == "number" then
				table.insert(Act,SetLoc(Location[1],4,SetTo,Y-2))
				table.insert(Act,SetLoc(Location[1],12,SetTo,Y-2))
			elseif Location[3][4] == "V" then
				if Y[5] == nil then
					Y[5] = 0
				end
				table.insert(Act,{TSetLoc,Location[1],4,SetTo,Vi(Y[2],-2+Y[5],Y[1],Y[3])})
				table.insert(Act,{TSetLoc,Location[1],12,SetTo,Vi(Y[2],-2+Y[5],Y[1],Y[3])})
			end
			Location = Location[1]
		end

		table.insert(Act,SetMemoryB(0x656670+BulletTable[UnitId][1],SetTo,9))

		if Actions ~= nil then
			for k, v in pairs(Actions) do
				table.insert(Act,v)
			end
		end

		table.insert(Act,CreateUnit(1,UnitId,Location,Owner))

		if type(Speed) == "number" then
			table.insert(Act,SetMemory(0x6C9EF8+BulletTable[UnitId][2]*4,SetTo,-Speed))
		else
			table.insert(Act,{TSetMemory,0x6C9EF8+BulletTable[UnitId][2]*4,SetTo,{_Neg,Speed}})
		end

		if type(Time) == "number" then
			table.insert(Act,SetMemoryB(0x657040+BulletTable[UnitId][1], SetTo, Time))
		else
			table.insert(Act,{TSetMemoryB,0x657040,BulletTable[UnitId][1], SetTo, Time})
		end

		CDoActionsX(PlayerID,Act)
		f_Read(PlayerID,_Add(V(NRet[16]),10),V(NRet[15]))
		if type(Angle) == "number" then
			Angle = Angle * 256
		end
		CDoActions(PlayerID,{
			TSetMemory(Vi(NRet[16],0x58/4),SetTo,V(NRet[15])),
			TSetMemoryX(Vi(NRet[16],0x20/4),SetTo,Angle,0xFF00),
			TSetMemoryX(Vi(NRet[16],0x4C/4),SetTo,135*256,0xFF00),
			TSetMemoryX(Vi(NRet[16],0x110/4),SetTo,6,0xFFFF),
		})
	CIfEnd()
end

function CreateBulletTarget(PlayerID,Owner,UnitId,Height,Angle,Speed,Time,Location,X,Y,Conditions,Actions1,Actions2,Preserve) -- XY->Angle
	local Nextptr = CreateVar(PlayerID)

	local Cond2 = {}
	if Conditions == nil then Conditions = {} end
	for k, v in pairs(Conditions) do
		table.insert(Cond2,v)
	end
	table.insert(Cond2,NVar(Nextptr,AtLeast,1))

	local Act2 = {}
	if Preserve == 0 then
		CIfOnce2(PlayerID,Cond2,Actions2)
	else
		CIf2(PlayerID,Cond2,Actions2)
	end
		f_Read(PlayerID,_Add(Nextptr,10),V(NRet[16]))
	
		if type(Angle) == "number" then
			table.insert(Act2,SetMemoryB(0x657888+BulletTable[UnitId][1], SetTo, Angle))
		else
			table.insert(Act2,{TSetMemoryB,0x657888,BulletTable[UnitId][1], SetTo, Angle})
		end

		if type(Speed) == "number" then
			table.insert(Act2,SetMemory(0x6C9EF8+BulletTable[UnitId][2]*4,SetTo,-Speed))
		else
			table.insert(Act2,{TSetMemory,0x6C9EF8+BulletTable[UnitId][2]*4,SetTo,{_Neg,Speed}})
		end

		table.insert(Act2,SetMemoryB(0x656670+BulletTable[UnitId][1],SetTo,9))

		if type(Time) == "number" then
			table.insert(Act2,SetMemoryB(0x657040+BulletTable[UnitId][1], SetTo, Time))
		else
			table.insert(Act2,{TSetMemoryB,0x657040,BulletTable[UnitId][1], SetTo, Time})
		end

		table.insert(Act2,{TSetMemory,Vi(Nextptr[2],0x58/4),SetTo,V(NRet[16])})
		table.insert(Act2,{TSetMemoryX,Vi(Nextptr[2],0x20/4),Add,Angle,0xFF00})
		table.insert(Act2,{TSetMemoryX,Vi(Nextptr[2],0x4C/4),SetTo,135*256,0xFFFFFF00})
		table.insert(Act2,SetNVar(Nextptr,SetTo,0))
		CDoActionsX(PlayerID,Act2)
	CIfEnd()

	local Act1 = {}
	table.insert(Conditions,Memory(0x628438,AtLeast,1))
	if Preserve == 0 then
		CIfOnce2(PlayerID,Conditions)
	else
		CIf2(PlayerID,Conditions)
	end
		f_Read(PlayerID,0x628438,nil,Nextptr)

		table.insert(Act1,SetMemory(0x66F048, SetTo, 86))

		if type(Height) == "number" then
			table.insert(Act1,SetMemoryB(0x663150+UnitId,SetTo,Height))
		elseif Height[4] == "V" then 
			table.insert(Act1,{TSetMemoryB,0x663150,UnitId,SetTo,Height})
		end

		if type(Location) == "table" then
			local X2 = Location[2]
			if type(Location[2]) == "number" then
				table.insert(Act1,SetLoc(Location[1],0,SetTo,X2))
				table.insert(Act1,SetLoc(Location[1],8,SetTo,X2))
			elseif Location[2][4] == "V" then
				table.insert(Act1,{TSetLoc,Location[1],0,SetTo,X2})
				table.insert(Act1,{TSetLoc,Location[1],8,SetTo,X2})
			end
			local Y2 = Location[3]
			if type(Location[3]) == "number" then
				table.insert(Act1,SetLoc(Location[1],4,SetTo,Y2-2))
				table.insert(Act1,SetLoc(Location[1],12,SetTo,Y2-2))
			elseif Location[3][4] == "V" then
				if Y2[5] == nil then
					Y2[5] = 0
				end
				table.insert(Act1,{TSetLoc,Location[1],4,SetTo,Vi(Y2[2],-2+Y2[5],Y2[1],Y2[3])})
				table.insert(Act1,{TSetLoc,Location[1],12,SetTo,Vi(Y2[2],-2+Y2[5],Y2[1],Y2[3])})
			end
			Location = Location[1]
		end

		if Actions1 ~= nil then
			for k, v in pairs(Actions1) do
				table.insert(Act1,v)
			end
		end

		table.insert(Act1,CreateUnit(1,UnitId,Location,Owner))
		table.insert(Act1,SetMemoryB(0x656990+UnitId, SetTo, 0))

		table.insert(Act1,{TSetMemoryX,Vi(Nextptr[2],0x110/4),SetTo,12,0xFFFF})
		table.insert(Act1,{TSetMemoryX,Vi(Nextptr[2],0x58/4),SetTo,X,0xFFFF})
		if type(Y) == "number" then
			table.insert(Act1,{TSetMemoryX,Vi(Nextptr[2],0x58/4),SetTo,Y*65536,0xFFFF0000})
		elseif Y[4] == "V" then
			table.insert(Act1,{TSetMemoryX,Vi(Nextptr[2],0x58/4),SetTo,{_lShift,Y,16},0xFFFF0000})
		end
		table.insert(Act1,{TSetMemoryX,Vi(Nextptr[2],0x4C/4),SetTo,14*256,0xFF00})
		table.insert(Act1,{TSetMemoryX,Vi(Nextptr[2],0x20/4),SetTo,127*65536,0xFF0000})
		CDoActionsX(PlayerID,Act1)
	CIfEnd()
end

function CreateStorm(PlayerID,Owner,UnitId,Height,Angle,ImageID,Time,Location,Conditions,Actions,Preserve) -- 스톰방식
	local Act = {}
	if Conditions == nil then Conditions = {} end
	table.insert(Conditions,Memory(0x628438,AtLeast,1))
	if Preserve == 0 then
		CIfOnce2(PlayerID,Conditions)
	else
		CIf2(PlayerID,Conditions)
	end
		f_Read(PlayerID,0x628438,nil,V(NRet[16]))

		table.insert(Act,SetMemory(0x66F048, SetTo, 86))

		if type(Height) == "number" then
			table.insert(Act,SetMemoryB(0x663150+UnitId,SetTo,Height))
		elseif Height[4] == "V" then 
			table.insert(Act,{TSetMemoryB,0x663150,UnitId,SetTo,Height})
		end

		if type(Location) == "table" then
			local X = Location[2]
			if type(Location[2]) == "number" then
				table.insert(Act,SetLoc(Location[1],0,SetTo,X))
				table.insert(Act,SetLoc(Location[1],8,SetTo,X))
			elseif Location[2][4] == "V" then
				table.insert(Act,{TSetLoc,Location[1],0,SetTo,X})
				table.insert(Act,{TSetLoc,Location[1],8,SetTo,X})
			end
			local Y = Location[3]
			if type(Location[3]) == "number" then
				table.insert(Act,SetLoc(Location[1],4,SetTo,Y-2))
				table.insert(Act,SetLoc(Location[1],12,SetTo,Y-2))
			elseif Location[3][4] == "V" then
				if Y[5] == nil then
					Y[5] = 0
				end
				table.insert(Act,{TSetLoc,Location[1],4,SetTo,Vi(Y[2],-2+Y[5],Y[1],Y[3])})
				table.insert(Act,{TSetLoc,Location[1],12,SetTo,Vi(Y[2],-2+Y[5],Y[1],Y[3])})
			end
			Location = Location[1]
		end

		if Actions ~= nil then
			for k, v in pairs(Actions) do
				table.insert(Act,v)
			end
		end

		table.insert(Act,CreateUnit(1,UnitId,Location,Owner))
		table.insert(Act,SetMemoryB(0x656670+BulletTable[UnitId][1],SetTo,3))

		if type(ImageID) == "number" then
			table.insert(Act,SetMemory(0x66EC48+ImageID*4,SetTo,236))
			table.insert(Act,SetMemoryB(0x66D4D8+ImageID, SetTo, 1))
		else
			table.insert(Act,{TSetMemory,Vi(ImageID[2],EPD(0x66EC48),ImageID[1],ImageID[3]),SetTo,236})
			table.insert(Act,{TSetMemoryB,0x66D4D8,ImageID,SetTo,1})
		end

		if type(Time) == "number" then
			table.insert(Act,SetMemoryB(0x657040+BulletTable[UnitId][1], SetTo, Time))
		else
			table.insert(Act,{TSetMemoryB,0x657040,BulletTable[UnitId][1], SetTo, Time})
		end

		CDoActionsX(PlayerID,Act)
		f_Read(PlayerID,_Add(V(NRet[16]),10),V(NRet[15]))
		if type(Angle) == "number" then
			Angle = Angle * 256
		end
		CDoActions(PlayerID,{
			TSetMemory(Vi(NRet[16],0x58/4),SetTo,V(NRet[15])),
			TSetMemoryX(Vi(NRet[16],0x20/4),SetTo,Angle,0xFF00),
			TSetMemoryX(Vi(NRet[16],0x4C/4),SetTo,135*256,0xFF00),
			TSetMemoryX(Vi(NRet[16],0x110/4),SetTo,6,0xFFFF),
		})
	CIfEnd()
end

function CreateSprite(PlayerID,Owner,UnitId,Height,Angle,Speed,Location,Conditions,Actions,Preserve) -- 영구 스프라이트
		local Act = {}
	if Conditions == nil then Conditions = {} end
	table.insert(Conditions,Memory(0x628438,AtLeast,1))
	if Preserve == 0 then
		CIfOnce2(PlayerID,Conditions)
	else
		CIf2(PlayerID,Conditions)
	end
		f_Read(PlayerID,0x628438,nil,V(NRet[16]))

		table.insert(Act,SetMemory(0x66F048, SetTo, 86))

		if type(Height) == "number" then
			table.insert(Act,SetMemoryB(0x663150+UnitId,SetTo,Height))
		elseif Height[4] == "V" then 
			table.insert(Act,{TSetMemoryB,0x663150,UnitId,SetTo,Height})
		end

		if type(Location) == "table" then
			local X = Location[2]
			if type(Location[2]) == "number" then
				table.insert(Act,SetLoc(Location[1],0,SetTo,X))
				table.insert(Act,SetLoc(Location[1],8,SetTo,X))
			elseif Location[2][4] == "V" then
				table.insert(Act,{TSetLoc,Location[1],0,SetTo,X})
				table.insert(Act,{TSetLoc,Location[1],8,SetTo,X})
			end
			local Y = Location[3]
			if type(Location[3]) == "number" then
				table.insert(Act,SetLoc(Location[1],4,SetTo,Y-2))
				table.insert(Act,SetLoc(Location[1],12,SetTo,Y-2))
			elseif Location[3][4] == "V" then
				if Y[5] == nil then
					Y[5] = 0
				end
				table.insert(Act,{TSetLoc,Location[1],4,SetTo,Vi(Y[2],-2+Y[5],Y[1],Y[3])})
				table.insert(Act,{TSetLoc,Location[1],12,SetTo,Vi(Y[2],-2+Y[5],Y[1],Y[3])})
			end
			Location = Location[1]
		end

		if Actions ~= nil then
			for k, v in pairs(Actions) do
				table.insert(Act,v)
			end
		end

		table.insert(Act,CreateUnit(1,UnitId,Location,Owner))
		table.insert(Act,SetMemoryB(0x656670+BulletTable[UnitId][1],SetTo,7))

		if type(Speed) == "number" then
			table.insert(Act,SetMemory(0x6C9EF8+BulletTable[UnitId][2]*4,SetTo,-Speed))
		else
			table.insert(Act,{TSetMemory,0x6C9EF8+BulletTable[UnitId][2]*4,SetTo,{_Neg,Speed}})
		end

		CDoActionsX(PlayerID,Act)
		f_Read(PlayerID,_Add(V(NRet[16]),10),V(NRet[15]))
		if type(Angle) == "number" then
			Angle = Angle * 256
		end
		CDoActions(PlayerID,{
			TSetMemory(Vi(NRet[16],0x58/4),SetTo,V(NRet[15])),
			TSetMemoryX(Vi(NRet[16],0x20/4),SetTo,Angle,0xFF00),
			TSetMemoryX(Vi(NRet[16],0x4C/4),SetTo,135*256,0xFF00),
			TSetMemoryX(Vi(NRet[16],0x110/4),SetTo,6,0xFFFF),
		})
	CIfEnd()
end

function SetImageColor(ImageID,Code)
	return SetMemoryB(0x669E28+ImageID, SetTo, Code)
end

function TSetImageColor(ImageID,Code)
	return TSetMemoryB(0x669E28,ImageID, SetTo, Code)
end

function SetImageScript(ImageID,ScriptID)
	return SetMemory(0x66EC48+ImageID*4,SetTo,ScriptID)
end

function TSetImageScript(ImageID,ScriptID)
	return TSetMemoryDw(0x66EC48,ImageID,SetTo,ScriptID)
end

function SetImageAllScript(ImageID,Value)
	return SetMemoryB(0x66D4D8+ImageID, SetTo, Value)
end

function TSetImageAllScript(ImageID,Value)
	return TSetMemoryB(0x66D4D8,ImageID, SetTo, Value)
end

--↑ 가변 / ↓ 고정 ---------------------------------------------------------

function SetRecallImage(ImageID)
	return SetMemoryW(0x666456,SetTo,ImageID)
end

function TSetRecallImage(ImageID)
	return TSetMemoryW(0x666160,0x2F6,SetTo,ImageID)
end

function SetScanImage(ImageID)
	return SetMemoryX(0x666458,SetTo,ImageID,0xFFFF)
end

function TSetScanImage(ImageID)
	return TSetMemoryX(0x666458,SetTo,ImageID,0xFFFF)
end

function SetSpriteImage(SpriteID,ImageID)
	return SetMemoryW(0x666160+SpriteID*2,SetTo,ImageID)
end

function TSetSpriteImage(SpriteID,ImageID)
	return TSetMemoryW(0x666160,SpriteID,SetTo,ImageID)
end

function SetBulletDamage(WeaponID,Type,Damage)
	return SetMemoryW(0x656EB0+WeaponID*2,Type,Damage)
end

function TSetBulletDamage(WeaponID,Type,Damage)
	return TSetMemoryW(0x656EB0,WeaponID,Type,Damage)
end

function SetBulletDamageUp(WeaponID,Type,Damage)
	return SetMemoryW(0x657678+WeaponID*2,Type,Damage)
end

function TSetBulletDamageUp(WeaponID,Type,Damage)
	return TSetMemoryW(0x657678,WeaponID,Type,Damage)
end

function SetBulletNumber(WeaponID,Number)
	return SetMemoryB(0x6564E0+WeaponID, SetTo, Number)
end

function TSetBulletNumber(WeaponID,Number)
	return TSetMemoryB(0x6564E0,WeaponID, SetTo, Number)
end

function SetBulletUpgrade(WeaponID,UpgradeID)
	return SetMemoryB(0x6571D0+WeaponID, SetTo, UpgradeID)
end

function TSetBulletUpgrade(WeaponID,UpgradeID)
	return TSetMemoryB(0x6571D0,WeaponID, SetTo, UpgradeID)
end

function SetBulletDamageType(WeaponID,DamageType)
	return SetMemoryB(0x657258+WeaponID, SetTo, DamageType)
end

function TSetBulletDamageType(WeaponID,DamageType)
	return TSetMemoryB(0x657258,WeaponID, SetTo, DamageType)
end

function SetBulletDamageSpecial(WeaponID,DamageSpecial)
	return SetMemoryB(0x6566F8+WeaponID, SetTo, DamageSpecial)
end

function TSetBulletDamageSpecial(WeaponID,DamageSpecial)
	return TSetMemoryB(0x6566F8,WeaponID, SetTo, DamageSpecial)
end

function SetBulletSpin(WeaponID,Type,Angle)
	return SetMemoryB(0x657888+WeaponID, Type, Angle)
end

function TSetBulletSpin(WeaponID,Type,Angle)
	return TSetMemoryB(0x657888,WeaponID, Type, Angle)
end

function SetBulletSplash100(WeaponID,Type,Radius)
	return SetMemoryW(0x656888+WeaponID*2, Type, Radius)
end

function TSetBulletSplash100(WeaponID,Type,Radius)
	return TSetMemoryW(0x656888,WeaponID, Type, Radius)
end

function SetBulletSplash50(WeaponID,Type,Radius)
	return SetMemoryW(0x6570C8+WeaponID*2, Type, Radius)
end

function TSetBulletSplash50(WeaponID,Type,Radius)
	return TSetMemoryW(0x6570C8,WeaponID, Type, Radius)
end

function SetBulletSplash25(WeaponID,Type,Radius)
	return SetMemoryW(0x657780+WeaponID*2, Type, Radius)
end

function TSetBulletSplash25(WeaponID,Type,Radius)
	return TSetMemoryW(0x657780,WeaponID, Type, Radius)
end

function SetDimension(UnitId,Value)
	return SetMemory(0x662860+4*UnitId, SetTo, Value)
end

function TSetDimension(UnitId,Value)
	return TSetMemoryDw(0x662860,UnitId,SetTo,Value)
end

function SetBulletCooldown(WeaponID,Type,Value)
	return SetMemoryB(0x656FB8+WeaponID,Type,Value)
end

function TSetBulletCooldown(WeaponID,Type,Value)
	return TSetMemoryB(0x656FB8+WeaponID,Type,Value)
end

function IBGM_EPD(PlayerID,TargetPlayer,Input,WAVData,AlertWav) -- {{1,"1.Wav",Length1},{2,"2.Wav",Length2},...,{N,"N.Wav",LengthN}}
	STPopTrigArr(PlayerID)	
	local Arr = CreateVarArr(3,PlayerID) -- Temp / ΔT / Delay 

	f_Read(PlayerID,0x51CE8C,Arr[1])

	CNeg(PlayerID,Arr[1])

	f_Diff(PlayerID,Arr[2],Arr[1],nil,nil,nil,1)

	CSub(PlayerID,Arr[3],Arr[2])

	local Cond1, Act1, Cond2
	if type(Input) == "number" then
		Cond1 = Memory(Input,AtLeast,1)
		Act1 = SetMemory(Input,SetTo,0)
	elseif Input[4] == "V" then
		Cond1 = NVar(Input,AtLeast,1)
		Act1 = SetNVar(Input,SetTo,0)
	else
		Cond1 = CtrigX(Input[1],Input[2],Input[3],Input[4],AtLeast,1)
		Act1 = SetCtrig1X(Input[1],Input[2],Input[3],Input[4],SetTo,0)
	end

	CIfX(PlayerID,{NVar(Arr[3],Exactly,0),Cond1})
		for k, v in pairs(WAVData) do
			if type(Input) == "number" then
				Cond2 = Memory(Input,Exactly,v[1])
			elseif Input[4] == "V" then
				Cond2 = NVar(Input,Exactly,v[1])
			else
				Cond2 = CtrigX(Input[1],Input[2],Input[3],Input[4],Exactly,v[1])
			end
			Trigger {players = {PlayerID},
				conditions = {
					Label(0);
					Cond2;
				},
				actions = {
					Act1;
					CopyCpActionX({PlayWAVX(v[2])},TargetPlayer);
					SetNVar(Arr[3],Add,v[3]);
				},
				flag = {Preserved}
			}
		end
	CElseIfX({NVar(Arr[3],AtLeast,1),Cond1},Act1)
		if AlertWav ~= nil then
			Trigger {players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					CopyCpActionX({PlayWAVX(AlertWav)},TargetPlayer);
				},
				flag = {Preserved}
			}
		end
	CIfXEnd()
end

function IBGM_EPDX(PlayerID,TargetPlayer,Input,WAVData,AlertWav) -- {{1,"1.Wav"},{2,"2.Wav"},...,{N,"N.Wav"}}
	STPopTrigArr(PlayerID)	
	local Arr = CreateVarArr(4,PlayerID) -- Temp / ΔT / Delay / NextInput

	f_Read(PlayerID,0x51CE8C,Arr[1])

	CNeg(PlayerID,Arr[1])

	f_Diff(PlayerID,Arr[2],Arr[1],nil,nil,nil,1)

	CSub(PlayerID,Arr[3],Arr[2])

	CIf(PlayerID,{NVar(Input,AtLeast,1),NVar(Arr[4],Exactly,0)})
		CMov(PlayerID,Arr[4],Input)
		DoActionsX(PlayerID,SetNVar(Input,SetTo,0))
	CIfEnd()

	CIfX(PlayerID,{NVar(Arr[3],Exactly,0),NVar(Arr[4],AtLeast,1)})
		for k, v in pairs(WAVData) do
			Trigger {players = {PlayerID},
				conditions = {
					Label(0);
					NVar(Arr[4],Exactly,v[1]);
				},
				actions = {
					SetNVar(Arr[4],SetTo,0);
					CopyCpActionX({PlayWAVX(v[2])},TargetPlayer);
					SetNVar(Arr[3],Add,v[3]);
				},
				flag = {Preserved}
			}
		end
	CElseIfX({NVar(Arr[3],AtLeast,1),NVar(Arr[4],AtLeast,1),NVar(Input,AtLeast,1)},SetNVar(Input,SetTo,0))
		if AlertWav ~= nil then
			Trigger {players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					CopyCpActionX({PlayWAVX(AlertWav)},TargetPlayer);
				},
				flag = {Preserved}
			}
		end
	CIfXEnd()
end

function CMotion(PlayerID,Displacement,Velocity,Acceleration,Time)
	if Time == nil then
		Time = 1 
	end

	if Displacement[4] ~= "V" or Velocity[4] ~= "V" or Acceleration[4] ~= "V" then
		CMotion_InputData_Error()
	end
	if type(Time) == "number" then
		if Time == 1 then
			CMov(PlayerID,V(NRet[1]),Velocity)
			CAdd(PlayerID,Velocity,Acceleration)

			CAdd(PlayerID,V(NRet[1]),Velocity)
			CiDiv(PlayerID,V(NRet[1]),2)
			CAdd(PlayerID,Displacement,V(NRet[1]))
		else
			CMov(PlayerID,V(NRet[1]),Velocity)
			CMul(PlayerID,V(NRet[2]),Acceleration,Time)
			CAdd(PlayerID,Velocity,V(NRet[2]))

			CAdd(PlayerID,V(NRet[1]),Velocity)
			CMul(PlayerID,V(NRet[1]),Time)
			CiDiv(PlayerID,V(NRet[1]),2)
			CAdd(PlayerID,Displacement,V(NRet[1]))
		end
	else
		CMov(PlayerID,V(NRet[1]),Velocity)
		CIfX(PlayerID,NVar(Time,Exactly,1))
			CAdd(PlayerID,Velocity,Acceleration)

			CAdd(PlayerID,V(NRet[1]),Velocity)
		CElseX()
			f_Mul(PlayerID,V(NRet[2]),Acceleration,Time)
			CAdd(PlayerID,Velocity,V(NRet[2]))

			CAdd(PlayerID,V(NRet[1]),Velocity)
			f_Mul(PlayerID,V(NRet[1]),Time)
		CIfXEnd()
		CiDiv(PlayerID,V(NRet[1]),2)
		CAdd(PlayerID,Displacement,V(NRet[1]))
	end
end

function _ParseDw(Number)
	local Ret = {0,0,0,0}
	Ret[1] = bit32.band(Number, 0xFF)
	Ret[2] = bit32.rshift(bit32.band(Number, 0xFF00),8)
	Ret[3] = bit32.rshift(bit32.band(Number, 0xFF0000),16)
	Ret[4] = bit32.band(bit32.rshift(bit32.band(Number, 0xFF000000),24), 0xFF)
	return Ret[1], Ret[2], Ret[3], Ret[4]
end

function _ParseW(Number)
	local Ret = {0,0}
	Ret[1] = bit32.band(Number, 0xFF)
	Ret[2] = bit32.rshift(bit32.band(Number, 0xFF00),8)
	return Ret[1], Ret[2]
end

-- Dot / X Dot / Y Dot / YX Size 
-- Color(1 : RGBW(1)TR(2)TK(2)) / Height(1) / ImageID(2)

function VisionTurbo(PlayerID) -- 0으로 고정시 시야 갱신 X
	DoActions(PlayerID,SetMemory(0x51CE98,SetTo,1))
end

function CMathFunc(PlayerID,Func,Start,End,Exception,T,TException,Magnificent)
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	local CMath = InitCFunc(PlayerID)
	local Para = CFunc(CMath)
		local Check = 0
		if Exception ~= nil then
			Check = 1
			for k, v in pairs(Exception) do
				if v[1] == "==" then
					NJumpX(PlayerID,CAPlotJumpAlloc,{NVar(Para[1],Exactly,v[2])},{SetNVar(Para[1],SetTo,v[3])})
				elseif v[1] == ">=" then
					NJumpX(PlayerID,CAPlotJumpAlloc,{TTNVar(Para[1],iAtLeast,v[2])},{SetNVar(Para[1],SetTo,v[3])})
				elseif v[1] == "<=" then
					NJumpX(PlayerID,CAPlotJumpAlloc,{TTNVar(Para[1],iAtMost,v[2])},{SetNVar(Para[1],SetTo,v[3])})
				else -- "><"
					NJumpX(PlayerID,CAPlotJumpAlloc,{TTNVar(Para[1],iAtLeast,v[2]),TTNVar(Para[1],iAtMost,v[3])},{SetNVar(Para[1],SetTo,v[4])})
				end
			end
		end

		if T ~= nil then
			CIf(PlayerID,NVar(Para[1],AtLeast,T))
				CiMod(PlayerID,Para[1],T)
			CIfEnd()

			CIf(PlayerID,NVar(Para[1],AtLeast,0x80000000))
				CAdd(PlayerID,Para[1],T)
			CIfEnd()

			if TException ~= nil then
				Check = 1
				for k, v in pairs(TException) do
					if v[1] == "==" then
						NJumpX(PlayerID,CAPlotJumpAlloc,{NVar(Para[1],Exactly,v[2])},{SetNVar(Para[1],SetTo,v[3])})
					elseif v[1] == ">=" then
						NJumpX(PlayerID,CAPlotJumpAlloc,{TTNVar(Para[1],iAtLeast,v[2])},{SetNVar(Para[1],SetTo,v[3])})
					elseif v[1] == "<=" then
						NJumpX(PlayerID,CAPlotJumpAlloc,{TTNVar(Para[1],iAtMost,v[2])},{SetNVar(Para[1],SetTo,v[3])})
					else -- "><"
						NJumpX(PlayerID,CAPlotJumpAlloc,{TTNVar(Para[1],iAtLeast,v[2]),TTNVar(Para[1],iAtMost,v[3])},{SetNVar(Para[1],SetTo,v[4])})
					end
				end
			end
		end

		if Start ~= nil then
			local MathArr = {}
			if Magnificent == nil then
				for i = Start, End do
					table.insert(MathArr,_G[Func](i))
				end
				CIf(PlayerID,Never())
			 	local MathFArr = f_GetFileArrptrN(PlayerID,MathArr,4,1) 
			 	CIfEnd()
			 	f_Read(PlayerID,FArr(MathFArr,_iSub(Para[1],Start)),Para[1],"X",0xFFFFFFFF,1)
			 else
			 	for i = Start, End do
					table.insert(MathArr,Magnificent*_G[Func](i))
				end
				CIf(PlayerID,Never())
			 	local MathFArr = f_GetFileArrptrN(PlayerID,MathArr,4,1) 
			 	CIfEnd()
			 	f_Read(PlayerID,FArr(MathFArr,_iSub(Para[1],Start)),Para[1],"X",0xFFFFFFFF,1)
			 	f_iMul(PlayerID,Para[1],Para[2])
				CiDiv(PlayerID,Para[1],Magnificent)
			 end
		end
	 	if Check == 1 then
	 		NJumpXEnd(PlayerID,CAPlotJumpAlloc)
	 	end
	 	CFuncReturn({Para[1]})
	 	CAPlotJumpAlloc = CAPlotJumpAlloc+1
	CFuncEnd()
	return CMath 
end

function CMathFunc2(PlayerID,Func,Start,End,Exception,T,TException,Magnificent)
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	local CMath = InitCFunc(PlayerID)
	local Para = CFunc(CMath)
		local Check = 0
		local CheckT = 0
		if Exception ~= nil then
			Check = 1
			NIfX(PlayerID,Never())
			for k, v in pairs(Exception) do
				if v[1] == "Y==" then
					if type(v[3]) == "number" then
						NElseIfX({NVar(Para[2],Exactly,v[2])},{SetNVar(Para[1],SetTo,v[3])})
					else -- CFunc
						NElseIfX({NVar(Para[2],Exactly,v[2])})
							CMov(PlayerID,V(NRet[1]),Para[1])
							CMov(PlayerID,V(NRet[2]),Para[3])
							CallCFuncX(PlayerID,v[3],{V(NRet[1]),V(NRet[2])},{Para[1]})
					end
				elseif v[1] == "Y>=" then
					if type(v[3]) == "number" then
						NElseIfX({TTNVar(Para[2],iAtLeast,v[2])},{SetNVar(Para[1],SetTo,v[3])})
					else -- CFunc
						NElseIfX({TTNVar(Para[2],iAtLeast,v[2])})
							CMov(PlayerID,V(NRet[1]),Para[1])
							CMov(PlayerID,V(NRet[2]),Para[3])
							CallCFuncX(PlayerID,v[3],{V(NRet[1]),V(NRet[2])},{Para[1]})
					end
				elseif v[1] == "Y<=" then
					if type(v[3]) == "number" then
						NElseIfX({TTNVar(Para[2],iAtMost,v[2])},{SetNVar(Para[1],SetTo,v[3])})
					else -- CFunc
						NElseIfX({TTNVar(Para[2],iAtMost,v[2])})
							CMov(PlayerID,V(NRet[1]),Para[1])
							CMov(PlayerID,V(NRet[2]),Para[3])
							CallCFuncX(PlayerID,v[3],{V(NRet[1]),V(NRet[2])},{Para[1]})
					end
				elseif v[1] == "Y><" then
					if type(v[4]) == "number" then
						NElseIfX({TTNVar(Para[2],iAtLeast,v[2]),TTNVar(Para[2],iAtMost,v[3])},{SetNVar(Para[1],SetTo,v[4])})
					else -- CFunc
						NElseIfX({TTNVar(Para[2],iAtLeast,v[2]),TTNVar(Para[2],iAtMost,v[3])})
							CMov(PlayerID,V(NRet[1]),Para[1])
							CMov(PlayerID,V(NRet[2]),Para[3])
							CallCFuncX(PlayerID,v[4],{V(NRet[1]),V(NRet[2])},{Para[1]})
					end
				elseif v[1] == "X==" then
					if type(v[3]) == "number" then
						if v[4] == nil then
							NElseIfX({NVar(Para[1],Exactly,v[2])},{SetNVar(Para[1],SetTo,v[3])})
						elseif v[4] == "Y==" then
							NElseIfX({NVar(Para[1],Exactly,v[2]),NVar(Para[2],Exactly,v[5])},{SetNVar(Para[1],SetTo,v[3])})
						elseif v[4] == "Y>=" then
							NElseIfX({NVar(Para[1],Exactly,v[2]),TTNVar(Para[2],iAtLeast,v[5])},{SetNVar(Para[1],SetTo,v[3])})
						elseif v[4] == "Y<=" then
							NElseIfX({NVar(Para[1],Exactly,v[2]),TTNVar(Para[2],iAtMost,v[5])},{SetNVar(Para[1],SetTo,v[3])})
						else -- Y><
							NElseIfX({NVar(Para[1],Exactly,v[2]),TTNVar(Para[2],iAtLeast,v[5]),TTNVar(Para[2],iAtMost,v[6])},{SetNVar(Para[1],SetTo,v[3])})
						end
					else -- CFunc
						NElseIfX({NVar(Para[1],Exactly,v[2])})
							CMov(PlayerID,V(NRet[1]),Para[2])
							CMov(PlayerID,V(NRet[2]),Para[3])
							CallCFuncX(PlayerID,v[3],{V(NRet[1]),V(NRet[2])},{Para[1]})
					end
				elseif v[1] == "X>=" then
					if type(v[3]) == "number" then
						if v[4] == nil then
							NElseIfX({TTNVar(Para[1],iAtLeast,v[2])},{SetNVar(Para[1],SetTo,v[3])})
						elseif v[4] == "Y==" then
							NElseIfX({TTNVar(Para[1],iAtLeast,v[2]),NVar(Para[2],Exactly,v[5])},{SetNVar(Para[1],SetTo,v[3])})
						elseif v[4] == "Y>=" then
							NElseIfX({TTNVar(Para[1],iAtLeast,v[2]),TTNVar(Para[2],iAtLeast,v[5])},{SetNVar(Para[1],SetTo,v[3])})
						elseif v[4] == "Y<=" then
							NElseIfX({TTNVar(Para[1],iAtLeast,v[2]),TTNVar(Para[2],iAtMost,v[5])},{SetNVar(Para[1],SetTo,v[3])})
						else -- Y><
							NElseIfX({TTNVar(Para[1],iAtLeast,v[2]),TTNVar(Para[2],iAtLeast,v[5]),TTNVar(Para[2],iAtMost,v[6])},{SetNVar(Para[1],SetTo,v[3])})
						end
					else -- CFunc
						NElseIfX({TTNVar(Para[1],iAtLeast,v[2])})
							CMov(PlayerID,V(NRet[1]),Para[2])
							CMov(PlayerID,V(NRet[2]),Para[3])
							CallCFuncX(PlayerID,v[3],{V(NRet[1]),V(NRet[2])},{Para[1]})
					end
				elseif v[1] == "X<=" then
					if type(v[3]) == "number" then
						if v[4] == nil then
							NElseIfX({TTNVar(Para[1],iAtMost,v[2])},{SetNVar(Para[1],SetTo,v[3])})
						elseif v[4] == "Y==" then
							NElseIfX({TTNVar(Para[1],iAtMost,v[2]),NVar(Para[2],Exactly,v[5])},{SetNVar(Para[1],SetTo,v[3])})
						elseif v[4] == "Y>=" then
							NElseIfX({TTNVar(Para[1],iAtMost,v[2]),TTNVar(Para[2],iAtLeast,v[5])},{SetNVar(Para[1],SetTo,v[3])})
						elseif v[4] == "Y<=" then
							NElseIfX({TTNVar(Para[1],iAtMost,v[2]),TTNVar(Para[2],iAtMost,v[5])},{SetNVar(Para[1],SetTo,v[3])})
						else -- Y><
							NElseIfX({TTNVar(Para[1],iAtMost,v[2]),TTNVar(Para[2],iAtLeast,v[5]),TTNVar(Para[2],iAtMost,v[6])},{SetNVar(Para[1],SetTo,v[3])})
						end
					else -- CFunc
						NElseIfX({TTNVar(Para[1],iAtMost,v[2])})
							CMov(PlayerID,V(NRet[1]),Para[2])
							CMov(PlayerID,V(NRet[2]),Para[3])
							CallCFuncX(PlayerID,v[3],{ParV(NRet[1]),V(NRet[2])},{Para[1]})
					end
				elseif v[1] == "X><" then
					if type(v[4]) == "number" then
						if v[5] == nil then
							NElseIfX({TTNVar(Para[1],iAtLeast,v[2]),TTNVar(Para[1],iAtMost,v[3])},{SetNVar(Para[1],SetTo,v[4])})
						elseif v[5] == "Y==" then
							NElseIfX({TTNVar(Para[1],iAtLeast,v[2]),TTNVar(Para[1],iAtMost,v[3]),NVar(Para[2],Exactly,v[6])},{SetNVar(Para[1],SetTo,v[4])})
						elseif v[5] == "Y>=" then
							NElseIfX({TTNVar(Para[1],iAtLeast,v[2]),TTNVar(Para[1],iAtMost,v[3]),TTNVar(Para[2],iAtLeast,v[6])},{SetNVar(Para[1],SetTo,v[4])})
						elseif v[5] == "Y<=" then
							NElseIfX({TTNVar(Para[1],iAtLeast,v[2]),TTNVar(Para[1],iAtMost,v[3]),TTNVar(Para[2],iAtMost,v[6])},{SetNVar(Para[1],SetTo,v[4])})
						else -- Y><
							NElseIfX({TTNVar(Para[1],iAtLeast,v[2]),TTNVar(Para[1],iAtMost,v[3]),TTNVar(Para[2],iAtLeast,v[6]),TTNVar(Para[2],iAtMost,v[7])},{SetNVar(Para[1],SetTo,v[4])})
						end
					else -- CFunc
						NElseIfX({TTNVar(Para[1],iAtLeast,v[2]),TTNVar(Para[1],iAtMost,v[3])})
							CMov(PlayerID,V(NRet[1]),Para[2])
							CMov(PlayerID,V(NRet[2]),Para[3])
							CallCFuncX(PlayerID,v[4],{V(NRet[1]),V(NRet[2])},{Para[1]})
					end
				end
			end
			NElseX()
		end

		if T ~= nil then
			if T[1] ~= nil then
				CIf(PlayerID,NVar(Para[1],AtLeast,T[1]))
					CiMod(PlayerID,Para[1],T[1])
				CIfEnd()

				CIf(PlayerID,NVar(Para[1],AtLeast,0x80000000))
					CAdd(PlayerID,Para[1],T[1])
				CIfEnd()
			end
			if T[2] ~= nil then
				CIf(PlayerID,NVar(Para[2],AtLeast,T[2]))
					CiMod(PlayerID,Para[2],T[2])
				CIfEnd()

				CIf(PlayerID,NVar(Para[2],AtLeast,0x80000000))
					CAdd(PlayerID,Para[2],T[2])
				CIfEnd()
			end
			
			if TException ~= nil then
				CheckT = 1
				NIfX(PlayerID,Never())
				for k, v in pairs(TException) do
					if v[1] == "Y==" then
						if type(v[3]) == "number" then
							NElseIfX({NVar(Para[2],Exactly,v[2])},{SetNVar(Para[1],SetTo,v[3])})
						else -- CFunc
							NElseIfX({NVar(Para[2],Exactly,v[2])})
								CallCFunc(v[3],{Para[1],Para[3]},{Para[1]},PlayerID)
						end
					elseif v[1] == "Y>=" then
						if type(v[3]) == "number" then
							NElseIfX({TTNVar(Para[2],iAtLeast,v[2])},{SetNVar(Para[1],SetTo,v[3])})
						else -- CFunc
							NElseIfX({TTNVar(Para[2],iAtLeast,v[2])})
								CallCFunc(v[3],{Para[1],Para[3]},{Para[1]},PlayerID)
						end
					elseif v[1] == "Y<=" then
						if type(v[3]) == "number" then
							NElseIfX({TTNVar(Para[2],iAtMost,v[2])},{SetNVar(Para[1],SetTo,v[3])})
						else -- CFunc
							NElseIfX({TTNVar(Para[2],iAtMost,v[2])})
								CallCFunc(v[3],{Para[1],Para[3]},{Para[1]},PlayerID)
						end
					elseif v[1] == "Y><" then
						if type(v[4]) == "number" then
							NElseIfX({TTNVar(Para[2],iAtLeast,v[2]),TTNVar(Para[2],iAtMost,v[3])},{SetNVar(Para[1],SetTo,v[4])})
						else -- CFunc
							NElseIfX({TTNVar(Para[2],iAtLeast,v[2]),TTNVar(Para[2],iAtMost,v[3])})
								CallCFunc(v[4],{Para[1],Para[3]},{Para[1]},PlayerID)
						end
					elseif v[1] == "X==" then
						if type(v[3]) == "number" then
							if v[4] == nil then
								NElseIfX({NVar(Para[1],Exactly,v[2])},{SetNVar(Para[1],SetTo,v[3])})
							elseif v[4] == "Y==" then
								NElseIfX({NVar(Para[1],Exactly,v[2]),NVar(Para[2],Exactly,v[5])},{SetNVar(Para[1],SetTo,v[3])})
							elseif v[4] == "Y>=" then
								NElseIfX({NVar(Para[1],Exactly,v[2]),TTNVar(Para[2],iAtLeast,v[5])},{SetNVar(Para[1],SetTo,v[3])})
							elseif v[4] == "Y<=" then
								NElseIfX({NVar(Para[1],Exactly,v[2]),TTNVar(Para[2],iAtMost,v[5])},{SetNVar(Para[1],SetTo,v[3])})
							else -- Y><
								NElseIfX({NVar(Para[1],Exactly,v[2]),TTNVar(Para[2],iAtLeast,v[5]),TTNVar(Para[2],iAtMost,v[6])},{SetNVar(Para[1],SetTo,v[3])})
							end
						else -- CFunc

							NElseIfX({NVar(Para[1],Exactly,v[2])})
								CallCFunc(v[3],{Para[2],Para[3]},{Para[1]},PlayerID)
						end
					elseif v[1] == "X>=" then
						if type(v[3]) == "number" then
							if v[4] == nil then
								NElseIfX({TTNVar(Para[1],iAtLeast,v[2])},{SetNVar(Para[1],SetTo,v[3])})
							elseif v[4] == "Y==" then
								NElseIfX({TTNVar(Para[1],iAtLeast,v[2]),NVar(Para[2],Exactly,v[5])},{SetNVar(Para[1],SetTo,v[3])})
							elseif v[4] == "Y>=" then
								NElseIfX({TTNVar(Para[1],iAtLeast,v[2]),TTNVar(Para[2],iAtLeast,v[5])},{SetNVar(Para[1],SetTo,v[3])})
							elseif v[4] == "Y<=" then
								NElseIfX({TTNVar(Para[1],iAtLeast,v[2]),TTNVar(Para[2],iAtMost,v[5])},{SetNVar(Para[1],SetTo,v[3])})
							else -- Y><
								NElseIfX({TTNVar(Para[1],iAtLeast,v[2]),TTNVar(Para[2],iAtLeast,v[5]),TTNVar(Para[2],iAtMost,v[6])},{SetNVar(Para[1],SetTo,v[3])})
							end
						else -- CFunc
							NElseIfX({TTNVar(Para[1],iAtLeast,v[2])})
								CallCFunc(v[3],{Para[2],Para[3]},{Para[1]},PlayerID)
						end
					elseif v[1] == "X<=" then
						if type(v[3]) == "number" then
							if v[4] == nil then
								NElseIfX({TTNVar(Para[1],iAtMost,v[2])},{SetNVar(Para[1],SetTo,v[3])})
							elseif v[4] == "Y==" then
								NElseIfX({TTNVar(Para[1],iAtMost,v[2]),NVar(Para[2],Exactly,v[5])},{SetNVar(Para[1],SetTo,v[3])})
							elseif v[4] == "Y>=" then
								NElseIfX({TTNVar(Para[1],iAtMost,v[2]),TTNVar(Para[2],iAtLeast,v[5])},{SetNVar(Para[1],SetTo,v[3])})
							elseif v[4] == "Y<=" then
								NElseIfX({TTNVar(Para[1],iAtMost,v[2]),TTNVar(Para[2],iAtMost,v[5])},{SetNVar(Para[1],SetTo,v[3])})
							else -- Y><
								NElseIfX({TTNVar(Para[1],iAtMost,v[2]),TTNVar(Para[2],iAtLeast,v[5]),TTNVar(Para[2],iAtMost,v[6])},{SetNVar(Para[1],SetTo,v[3])})
							end
						else -- CFunc
							NElseIfX({TTNVar(Para[1],iAtMost,v[2])})
								CallCFunc(v[3],{Para[2],Para[3]},{Para[1]},PlayerID)
						end
					elseif v[1] == "X><" then
						if type(v[4]) == "number" then
							if v[5] == nil then
								NElseIfX({TTNVar(Para[1],iAtLeast,v[2]),TTNVar(Para[1],iAtMost,v[3])},{SetNVar(Para[1],SetTo,v[4])})
							elseif v[5] == "Y==" then
								NElseIfX({TTNVar(Para[1],iAtLeast,v[2]),TTNVar(Para[1],iAtMost,v[3]),NVar(Para[2],Exactly,v[6])},{SetNVar(Para[1],SetTo,v[4])})
							elseif v[5] == "Y>=" then
								NElseIfX({TTNVar(Para[1],iAtLeast,v[2]),TTNVar(Para[1],iAtMost,v[3]),TTNVar(Para[2],iAtLeast,v[6])},{SetNVar(Para[1],SetTo,v[4])})
							elseif v[5] == "Y<=" then
								NElseIfX({TTNVar(Para[1],iAtLeast,v[2]),TTNVar(Para[1],iAtMost,v[3]),TTNVar(Para[2],iAtMost,v[6])},{SetNVar(Para[1],SetTo,v[4])})
							else -- Y><
								NElseIfX({TTNVar(Para[1],iAtLeast,v[2]),TTNVar(Para[1],iAtMost,v[3]),TTNVar(Para[2],iAtLeast,v[6]),TTNVar(Para[2],iAtMost,v[7])},{SetNVar(Para[1],SetTo,v[4])})
							end
						else -- CFunc
							NElseIfX({TTNVar(Para[1],iAtLeast,v[2]),TTNVar(Para[1],iAtMost,v[3])})
								CallCFunc(v[4],{Para[2],Para[3]},{Para[1]},PlayerID)
						end
					end
				end
				NElseX()
			end
		end

		if Start ~= nil then
			local MathArr = {}
			if Magnificent == nil then
				for i = Start[2], End[2] do -- Y
					for j = Start[1], End[1] do -- X
						table.insert(MathArr,_G[Func](j,i))
					end
				end
				CIf(PlayerID,Never())
			 	local MathFArr = f_GetFileArrptrN(PlayerID,MathArr,4,1) 
			 	CIfEnd()
			 	f_Read(PlayerID,FArr(MathFArr,_Add(_iSub(Para[1],Start[1]),_Mul(_iSub(Para[2],Start[2]),End[1]-Start[1]+1))),Para[1],"X",0xFFFFFFFF,1)
			 else
			 	for i = Start[2], End[2] do
			 		for j = Start[1], End[1] do
						table.insert(MathArr,Magnificent*_G[Func](j,i))
					end
				end
				CIf(PlayerID,Never())
			 	local MathFArr = f_GetFileArrptrN(PlayerID,MathArr,4,1) 
			 	CIfEnd()
			 	f_Read(PlayerID,FArr(MathFArr,_Add(_iSub(Para[1],Start[1]),_Mul(_iSub(Para[2],Start[2]),End[1]-Start[1]+1))),Para[1],"X",0xFFFFFFFF,1)
			 	f_iMul(PlayerID,Para[1],Para[3])
				CiDiv(PlayerID,Para[1],Magnificent)
			 end
		end
		if CheckT == 1 then
			 NIfXEnd()
		end
	 	if Check == 1 then
	 		NIfXEnd()
	 	end
	 	CFuncReturn({Para[1]})
	CFuncEnd()
	return CMath 
end

function CPush(PlayerID,Parameter) -- VA << V[]
	STPopTrigArr(PlayerID)	

	local TempArr = {}
	local TempArr2 = {}
	for k, v in pairs(Parameter) do
		table.insert(TempArr,SetCtrig1X(v[1],v[2],0x148,v[3],SetTo,0xFFFFFFFF))
		table.insert(TempArr,SetCtrig1X(v[1],v[2],0x160,v[3],SetTo,SetTo*16777216,0xFF000000))
		table.insert(TempArr,SetCtrig1X(v[1],v[2],0x158,v[3],SetTo,13))

		table.insert(TempArr,SetCtrig1X(v[1],v[2],0x178,v[3],SetTo,EPD(0x6509B0)))
		table.insert(TempArr,SetCtrig1X(v[1],v[2],0x180,v[3],SetTo,Add*16777216,0xFF000000))
		table.insert(TempArr,SetCtrig1X(v[1],v[2],0x17C,v[3],SetTo,-604))
		table.insert(TempArr,SetCtrig1X(v[1],v[2],0x184,v[3],SetTo,0,0x2))

		table.insert(TempArr2,SetCtrig1X(v[1],v[2],0x180,v[3],SetTo,SetTo*16777216,0xFF000000))
		table.insert(TempArr2,SetCtrig1X(v[1],v[2],0x184,v[3],SetTo,0x2,0x2))
	end

	DoActions2X(PlayerID,{
		SetCtrig2X(0x6509B0,SetTo,FixPlayer,CStackArr[2],0x15C,1,CreateCStackVarXAlloc-1);
		SetCtrig1X(FixPlayer,CStackptr[2],0x148,0,SetTo,0xFFFFFFFF);
		SetCtrig1X(FixPlayer,CStackptr[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
		SetCtrig1X(FixPlayer,CStackptr[2],0x158,0,SetTo,EPD(0x6509B0));
		TempArr,
	})

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			CallLabelAlwaysN(CStackptr,table.unpack(Parameter));
		},
		flag = {Preserved}
	}

	DoActions2X(PlayerID,{
		SetNVar(CStackptr,Add,604*(#Parameter));
		SetNWar(CStackptr2,Add,{2416*(#Parameter),2416*(#Parameter)});
		TempArr2,
	})

	RecoverCp(PlayerID)
end

function CPop(PlayerID,Return) -- VA >> Offset / Mem / V
	STPopTrigArr(PlayerID)

	local TempArr = {}
	for k, v in pairs(Return) do
		if type(v) == "number" then
			table.insert(TempArr,SetDeaths(CurrentPlayer,SetTo,EPD(v),0))
		elseif v[4] == "V" then
			table.insert(TempArr,SetCtrig2X("Cp",SetTo,v[1],v[2],0x15C,1,v[3]))
		else
			table.insert(TempArr,SetCtrig2X("Cp",SetTo,v[1],v[2],v[3],1,v[4]))
		end

		if k == #Return then
			table.insert(TempArr,SetMemory(0x6509B0,Add,(0x4-0x158)/4))
		else
			table.insert(TempArr,SetMemory(0x6509B0,Add,604))
		end
	end

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			SetCtrig2X(0x6509B0,SetTo,FixPlayer,CStackArr[2],0x158,1,CreateCStackVarXAlloc);
			SetCtrig1X(FixPlayer,CStackptr[2],0x148,0,SetTo,0xFFFFFFFF);
			SetCtrig1X(FixPlayer,CStackptr[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
			SetCtrig1X(FixPlayer,CStackptr[2],0x158,0,SetTo,EPD(0x6509B0));

			SetCtrigX("X",FuncAlloc,0x15C,0,SetTo,FixPlayer,CStackArr[2],0x0,0,CreateCStackVarXAlloc);
			SetCtrig1X(FixPlayer,CStackptr2[2],0x148,0,SetTo,0xFFFFFFFF);
			SetCtrig1X(FixPlayer,CStackptr2[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
			SetCtrigX(FixPlayer,CStackptr2[2],0x158,0,SetTo,"X",FuncAlloc,0x15C,1,0);
			SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,FixPlayer,CStackArr[2],0x0,0,CreateCStackVarXAlloc);
			SetCtrig1X("X",FuncAlloc,0x15C,1,Add,2416*(#Return));
			SetCtrig1X(FixPlayer,CStackptr2[2],0x188,0,SetTo,0xFFFFFFFF);
			SetCtrig1X(FixPlayer,CStackptr2[2],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
			SetCtrigX(FixPlayer,CStackptr2[2],0x198,0,SetTo,"X",FuncAlloc,0x15C,1,1);
			CallLabelAlways2(CStackptr[1],CStackptr[2],CStackptr[3],CStackptr2[1],CStackptr2[2],CStackptr2[3]);


		},
		flag = {Preserved}
	}

	DoActions2X(PlayerID,{
		TempArr,
	})

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(FuncAlloc);
		},
		actions = {
			SetCtrig1X("X","X",0x4,0,SetTo,0);
			SetCtrig2X("Cp",SetTo,"X","X",0,0,1);
		},
		flag = {Preserved}
	}

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			SetDeaths(CurrentPlayer,SetTo,0,0);
			SetNVar(CStackptr,Subtract,604*(#Return));
			SetNWar(CStackptr2,Subtract,{2416*(#Return),2416*(#Return)});
		},
		flag = {Preserved}
	}

	FuncAlloc = FuncAlloc + 1
	RecoverCp(PlayerID)
end

function LPush(PlayerID,Parameter) -- WA << W[]
	STPopTrigArr(PlayerID)	

	local TempArr = {}
	local TempArr2 = {}
	for k, v in pairs(Parameter) do
		table.insert(TempArr,SetCtrig1X(v[1],v[2],0x148,v[3],SetTo,0xFFFFFFFF))
		table.insert(TempArr,SetCtrig1X(v[1],v[2],0x160,v[3],SetTo,SetTo*16777216,0xFF000000))
		table.insert(TempArr,SetCtrig1X(v[1],v[2],0x158,v[3],SetTo,13))

		table.insert(TempArr,SetCtrig1X(v[1],v[2],0x17C,v[3],SetTo,16))
		table.insert(TempArr,SetCtrig1X(v[1],v[2],0x184,v[3],SetTo,0,0x2))

		table.insert(TempArr,SetCtrig1X(v[1],v[2],0x188,v[3],SetTo,0xFFFFFFFF))
		table.insert(TempArr,SetCtrig1X(v[1],v[2],0x1A0,v[3],SetTo,SetTo*16777216,0xFF000000))
		table.insert(TempArr,SetCtrig1X(v[1],v[2],0x198,v[3],SetTo,13))

		table.insert(TempArr,SetCtrig1X(v[1],v[2],0x1B8,v[3],SetTo,EPD(0x6509B0)))
		table.insert(TempArr,SetCtrig1X(v[1],v[2],0x1C0,v[3],SetTo,Add*16777216,0xFF000000))
		table.insert(TempArr,SetCtrig1X(v[1],v[2],0x1BC,v[3],SetTo,-620))
		table.insert(TempArr,SetCtrig1X(v[1],v[2],0x1C4,v[3],SetTo,0,0x2))

		table.insert(TempArr2,SetCtrig1X(v[1],v[2],0x17C,v[3],SetTo,1))
		table.insert(TempArr2,SetCtrig1X(v[1],v[2],0x184,v[3],SetTo,0x2,0x2))
		table.insert(TempArr2,SetCtrig1X(v[1],v[2],0x1C0,v[3],SetTo,SetTo*16777216,0xFF000000))
		table.insert(TempArr2,SetCtrig1X(v[1],v[2],0x1C4,v[3],SetTo,0x2,0x2))
	end

	DoActions2X(PlayerID,{
		SetCtrig2X(0x6509B0,SetTo,FixPlayer,LStackArr[2],0x15C,1,CreateLStackVarXAlloc-1);
		SetCtrig1X(FixPlayer,LStackptr[2],0x148,0,SetTo,0xFFFFFFFF);
		SetCtrig1X(FixPlayer,LStackptr[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
		SetCtrig1X(FixPlayer,LStackptr[2],0x158,0,SetTo,EPD(0x6509B0));
		TempArr,
	})

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			CallLabelAlwaysN(LStackptr,table.unpack(Parameter));
		},
		flag = {Preserved}
	}

	DoActions2X(PlayerID,{
		SetNVar(LStackptr,Add,604*(#Parameter));
		SetNWar(LStackptr2,Add,{2416*(#Parameter),2416*(#Parameter)});
		TempArr2,
	})

	RecoverCp(PlayerID)
end

function LPop(PlayerID,Return) -- WA >> LMem/Offsetx2 / W
	STPopTrigArr(PlayerID)

	local TempArr = {}
	for k, v in pairs(Return) do
		if type(v) == "number" then -- Offset 4
			v = {v,v+4}
		end

		if v[4] == "W" then
			table.insert(TempArr,SetCtrig2X("Cp",SetTo,v[1],v[2],0x15C,1,v[3]))
			table.insert(TempArr,SetMemory(0x6509B0,Add,16))
			table.insert(TempArr,SetCtrig2X("Cp",SetTo,v[1],v[2],0x19C,1,v[3]))
		else 
			if type(v[1]) == "number" then
				table.insert(TempArr,SetDeaths(CurrentPlayer,SetTo,EPD(v[1]),0))
			elseif v[1][4] == "V" then
				table.insert(TempArr,SetCtrig2X("Cp",SetTo,v[1][1],v[1][2],0x15C,1,v[1][4]))
			else
				table.insert(TempArr,SetCtrig2X("Cp",SetTo,v[1][1],v[1][2],v[1][3],1,v[1][4]))
			end

			table.insert(TempArr,SetMemory(0x6509B0,Add,16))
			
			if type(v[2]) == "number" then
				table.insert(TempArr,SetDeaths(CurrentPlayer,SetTo,EPD(v[2]),0))
			elseif v[2][4] == "V" then
				table.insert(TempArr,SetCtrig2X("Cp",SetTo,v[2][1],v[2][2],0x15C,1,v[2][4]))
			else
				table.insert(TempArr,SetCtrig2X("Cp",SetTo,v[2][1],v[2][2],v[2][3],1,v[2][4]))
			end
		end

		if k == #Return then
			table.insert(TempArr,SetMemory(0x6509B0,Add,(0x4-0x198)/4))
		else
			table.insert(TempArr,SetMemory(0x6509B0,Add,588))
		end
	end

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			SetCtrig2X(0x6509B0,SetTo,FixPlayer,LStackArr[2],0x158,1,CreateLStackVarXAlloc);
			SetCtrig1X(FixPlayer,LStackptr[2],0x148,0,SetTo,0xFFFFFFFF);
			SetCtrig1X(FixPlayer,LStackptr[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
			SetCtrig1X(FixPlayer,LStackptr[2],0x158,0,SetTo,EPD(0x6509B0));

			SetCtrigX("X",FuncAlloc,0x15C,0,SetTo,FixPlayer,LStackArr[2],0x0,0,CreateLStackVarXAlloc);
			SetCtrig1X(FixPlayer,LStackptr2[2],0x148,0,SetTo,0xFFFFFFFF);
			SetCtrig1X(FixPlayer,LStackptr2[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
			SetCtrigX(FixPlayer,LStackptr2[2],0x158,0,SetTo,"X",FuncAlloc,0x15C,1,0);
			SetCtrigX("X",FuncAlloc,0x15C,1,SetTo,FixPlayer,LStackArr[2],0x0,0,CreateLStackVarXAlloc);
			SetCtrig1X("X",FuncAlloc,0x15C,1,Add,2416*(#Return));
			SetCtrig1X(FixPlayer,LStackptr2[2],0x188,0,SetTo,0xFFFFFFFF);
			SetCtrig1X(FixPlayer,LStackptr2[2],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
			SetCtrigX(FixPlayer,LStackptr2[2],0x198,0,SetTo,"X",FuncAlloc,0x15C,1,1);
			CallLabelAlways2(LStackptr[1],LStackptr[2],LStackptr[3],LStackptr2[1],LStackptr2[2],LStackptr2[3]);


		},
		flag = {Preserved}
	}

	DoActions2X(PlayerID,{
		TempArr,
	})

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(FuncAlloc);
		},
		actions = {
			SetCtrig1X("X","X",0x4,0,SetTo,0);
			SetCtrig2X("Cp",SetTo,"X","X",0,0,1);
		},
		flag = {Preserved}
	}

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			SetDeaths(CurrentPlayer,SetTo,0,0);
			SetNVar(LStackptr,Subtract,604*(#Return));
			SetNWar(LStackptr2,Subtract,{2416*(#Return),2416*(#Return)});
		},
		flag = {Preserved}
	}

	FuncAlloc = FuncAlloc + 1
	RecoverCp(PlayerID)
end

function f_CGive(PlayerID,UnitEPD,UnitPtr,NewOwner,PrevOwner) -- Cunit Giveunits
	-- f_CGive - Ret[1] : PTR / Ret[2] : EPD+19 / Ret[3] : Prev PID / Ret[4] : New PID
	-- Ret[5] : EPD+26 / Ret[6] : EPD+27 / Ret[7], Ret[8] : Prev ptr,epd / Ret[9], Ret[10] : Next ptr,epd
	-- Ret[11] : EPD(0x6283F8) + New PID / Ret[12], Ret[13] : New Prev ptr,epd / Ret[14], Ret[15] : New Next ptr,epd / Ret[16] : New Prev Next
	STPopTrigArr(PlayerID)
	-- Input Data CRet[1] << X 
	if UnitPtr == nil and UnitEPD == nil then
		f_CGive_InputData_Error()
	end

	if type(UnitPtr) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetNVar(FCGU[1],SetTo,UnitPtr);
			},
			flag = {Preserved}
		}
	elseif UnitPtr ~= nil then
		if UnitPtr[4] == "VA" then
			local TempRet = {"X",CFCGU[1][2],0,"V"}
			MovX(PlayerID,TempRet,UnitPtr)
		elseif UnitPtr[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(UnitPtr[1],UnitPtr[2],0x158,UnitPtr[3],SetTo,"X",FCGU[1][2],0x15C,1,0);
					SetCtrig1X(UnitPtr[1],UnitPtr[2],0x148,UnitPtr[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(UnitPtr[1],UnitPtr[2],0x160,UnitPtr[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(UnitPtr[1],UnitPtr[2],UnitPtr[3]);
				},
				flag = {Preserved}
			}
		end
	end

	if type(UnitEPD) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetNVar(FCGU[2],SetTo,UnitEPD);
			},
			flag = {Preserved}
		}
	elseif UnitEPD ~= nil then
		if UnitEPD[4] == "VA" then
			local TempRet = {"X",CFCGU[2][2],0,"V"}
			MovX(PlayerID,TempRet,UnitEPD)
		elseif UnitEPD[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(UnitEPD[1],UnitEPD[2],0x158,UnitEPD[3],SetTo,"X",FCGU[2][2],0x15C,1,0);
					SetCtrig1X(UnitEPD[1],UnitEPD[2],0x148,UnitEPD[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(UnitEPD[1],UnitEPD[2],0x160,UnitEPD[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(UnitEPD[1],UnitEPD[2],UnitEPD[3]);
				},
				flag = {Preserved}
			}
		end
	end

	if type(NewOwner) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetNVar(FCGU[4],SetTo,NewOwner);
			},
			flag = {Preserved}
		}
	elseif NewOwner ~= nil then
		if NewOwner[4] == "VA" then
			local TempRet = {"X",CFCGU[4][2],0,"V"}
			MovX(PlayerID,TempRet,NewOwner)
		elseif NewOwner[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(NewOwner[1],NewOwner[2],0x158,NewOwner[3],SetTo,"X",FCGU[4][2],0x15C,1,0);
					SetCtrig1X(NewOwner[1],NewOwner[2],0x148,NewOwner[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(NewOwner[1],NewOwner[2],0x160,NewOwner[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(NewOwner[1],NewOwner[2],NewOwner[3]);
				},
				flag = {Preserved}
			}
		end
	else
		f_CGive_InputData_Error()
	end

	if type(PrevOwner) == "number" then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetNVar(FCGU[3],SetTo,PrevOwner);
			},
			flag = {Preserved}
		}
	elseif PrevOwner ~= nil then
		if PrevOwner[4] == "VA" then
			local TempRet = {"X",CFCGU[3][2],0,"V"}
			MovX(PlayerID,TempRet,PrevOwner)
		elseif PrevOwner[4] == "V" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(PrevOwner[1],PrevOwner[2],0x158,PrevOwner[3],SetTo,"X",FCGU[3][2],0x15C,1,0);
					SetCtrig1X(PrevOwner[1],PrevOwner[2],0x148,PrevOwner[3],SetTo,0xFFFFFFFF);
					SetCtrig1X(PrevOwner[1],PrevOwner[2],0x160,PrevOwner[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways(PrevOwner[1],PrevOwner[2],PrevOwner[3]);
				},
				flag = {Preserved}
			}
		end
	else
		DoActionsX(PlayerID,SetNVar(FCGU[3],SetTo,-1))
	end

-- Call f_EPD
	if FCGUCall1 == 0 then
		Need_Include_DataTransfer()
	end
	Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FCGUCall1,0x0,0,0);
				SetCtrigX("X",FCGUCall2,0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}
	FCGUCheck = 1
end

function InitVFunc(PlayerID,CFunction,Wariable,Conditions,Actions,Once) -- W의 Player와 CFunction의 플레이어가 동일해야함
	local PDest
	if Wariable[4] == "WA" then
		PDest = Wariable
		Wariable = {"X",WRet[8],0,"W"}
	end

	local Flags = {Preserved}
	if Once ~= nil then
		Flags = {}
	end
	TriggerX(PlayerID,Conditions,
	{SetCtrigX(Wariable[1],Wariable[2],0x15C,Wariable[3],SetTo,CFunction[1],CFunction[2],0x0,0,1),
	SetCtrigX(Wariable[1],Wariable[2],0x19C,Wariable[3],SetTo,CFunction[1],CFunction[2]+1,0x4,1,0),
	Actions},Flags)

	if PDest ~= nil then
		MovW(PlayerID,PDest,{"X",WRet[8],0,"W"})
	end
end

function VFunc(CFunction,Wariable)
	local VFuncAct = {SetCtrigX(Wariable[1],Wariable[2],0x15C,Wariable[3],SetTo,CFunction[1],CFunction[2],0x0,0,1),
						SetCtrigX(Wariable[1],Wariable[2],0x19C,Wariable[3],SetTo,CFunction[1],CFunction[2]+1,0x4,1,0)}
	return VFuncAct
end

function InitVFuncX(PlayerID,CFunction) -- W의 Player와 CFunction의 플레이어가 동일해야함
	if CFunction[3] == nil then
		local Ret = CreateWar(PlayerID)
		PlayerID = PlayerConvert(PlayerID)
		for k, P in pairs(PlayerID) do
			table.insert(CtrigInitArr[P+1], SetCtrigX(Ret[1],Ret[2],0x15C,Ret[3],SetTo,CFunction[1],CFunction[2],0x0,0,1))
			table.insert(CtrigInitArr[P+1], SetCtrigX(Ret[1],Ret[2],0x19C,Ret[3],SetTo,CFunction[1],CFunction[2]+1,0x4,1,0))
		end
		return Ret
	else
		local Number = #CFunction[3]

		local PID = "X"
		if type(PlayerID) == "number" then
			PID = PlayerID
		end
		CreateVarXAlloc = CreateVarXAlloc + 1
		if CreateVarXAlloc > CreateMaxVAlloc then
			CreateVariable_IndexAllocation_Overflow()
		end
		table.insert(CreateVarPArr,{"VFP",PlayerID,Number,CFunction[3]})

		local VFptr = {PID,CreateVarXAlloc,0,"V"}
		local Ret = CreateWar(PlayerID)

		PlayerID = PlayerConvert(PlayerID)
		for k, P in pairs(PlayerID) do
			table.insert(CtrigInitArr[P+1], SetCtrigX(Ret[1],Ret[2],0x15C,Ret[3],SetTo,CFunction[1],CFunction[2],0x0,0,1))
			table.insert(CtrigInitArr[P+1], SetCtrigX(Ret[1],Ret[2],0x19C,Ret[3],SetTo,CFunction[1],CFunction[2]+1,0x4,1,0))
		end

		return {Ret,VFptr}
	end
end

function VFuncX(PlayerID,CFunction,Wariable)
	if CFunction[3] == nil then
		VFuncXAct = {}
		table.insert(VFuncXAct, SetCtrigX(Wariable[1],Wariable[2],0x15C,Wariable[3],SetTo,CFunction[1],CFunction[2],0x0,0,1))
		table.insert(VFuncXAct, SetCtrigX(Wariable[1],Wariable[2],0x19C,Wariable[3],SetTo,CFunction[1],CFunction[2]+1,0x4,1,0))
		DoActionsX(PlayerID,VFuncXAct)
	else
		VFuncXAct = {}
		local Number = #CFunction[3]
		for i = 0, Number-1 do
			table.insert(VFuncXAct, SetCtrigX(Wariable[2][1],Wariable[2][2],0x15C+0x40*i,Wariable[2][3],SetTo,FixPlayer,CFunction[3][i+1][2],0x15C,1,0))
		end
		table.insert(VFuncXAct, SetCtrigX(Wariable[1][1],Wariable[1][2],0x15C,Wariable[1][3],SetTo,CFunction[1],CFunction[2],0x0,0,1))
		table.insert(VFuncXAct, SetCtrigX(Wariable[1][1],Wariable[1][2],0x19C,Wariable[1][3],SetTo,CFunction[1],CFunction[2]+1,0x4,1,0))
		DoActions2X(PlayerID,VFuncXAct)
	end
end

function CallVFunc(Wariable,Parameter,Return,PlayerID,Conditions,Actions,Once)
	if Wariable[4] == "WA" then
		local TempRet = {"X",WRet[7],0,"W"}
		MovW(PlayerID,TempRet,Wariable)
		Wariable = TempRet
	end

	if Parameter == nil then
		Parameter = {}
	end
	if Return == nil then
		Return = {}
	end
	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)

	if Once == 1 then
		Flags = {}
	else
		Flags = {Preserved}
	end

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
			Conditions,
		},
		actions = {
			SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X","X",0x0,0,1);
			Actions,
		},
		flag = {
			Flags,
		}
	}
	if #Wariable ~= 2 then
		local SourceN = {}
		local SourceV = {}
		local DestN = {}
		local DestV = {}
		for k, v in pairs(Parameter) do 
			if type(v) == "number" then
				table.insert(SourceN,v)
				table.insert(DestN,k)
			elseif v[4] == "V" then
				table.insert(SourceV,v)
				table.insert(DestV,k)
			else
				CallVFunc_InputData_Error()
			end
		end
		local BoxN = {}
		for k, v in pairs(SourceN) do
			table.insert(BoxN,SetCtrig1X(FixPlayer,CFuncParaVarArr[DestN[k]][2],0x15C,0,SetTo,v))
		end
		if SourceN[1] ~= nil then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					BoxN,
				},
				flag = {Preserved}
			}
		end

		local BoxV = {}
		for k, v in pairs(SourceV) do
			if v[5] == nil then
				v[5] = 0
			end
			table.insert(BoxV,SetCtrig1X(FixPlayer,CFuncParaVarArr[DestV[k]][2],0x15C,0,SetTo,v[5]))
			table.insert(BoxV,SetCtrigX(v[1],v[2],0x158,v[3],SetTo,FixPlayer,CFuncParaVarArr[DestV[k]][2],0x15C,1,0))
			table.insert(BoxV,SetCtrig1X(v[1],v[2],0x148,v[3],SetTo,0xFFFFFFFF))
			table.insert(BoxV,SetCtrig1X(v[1],v[2],0x160,v[3],SetTo,SetTo*16777216,0xFF000000))
		end
		if SourceV[1] ~= nil then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					BoxV,
					CallLabelAlwaysN(table.unpack(SourceV));
				},
				flag = {Preserved}
			}
		end

		f_LMov(PlayerID,{Mem("X",IndexAlloc+1,0x15C,0),Mem("X",IndexAlloc+1,0x178,0)},Wariable)
		Trigger { 
			players = {PlayerID},
			conditions = {
				Label(IndexAlloc+1);
			},
			actions = {
				SetCtrig1X("X","X",0x4,0,SetTo,0); -- CFunction[1],CFunction[2],0x0,0,1
				SetCtrig2X(0,SetTo,"X","X",0x0,0,1); -- CFunction[1],CFunction[2]+1,0x4,0
				SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1);
			},
			flag = {Preserved}
		}
	else
		local SourceN = {}
		local SourceV = {}
		local DestN = {}
		local DestV = {}
		for k, v in pairs(Parameter) do 
			if type(v) == "number" then
				table.insert(SourceN,v)
				table.insert(DestN,k)
			elseif v[4] == "V" then
				table.insert(SourceV,v)
				table.insert(DestV,k)
			else
				CallVFunc_InputData_Error()
			end
		end
		local BoxN = {}
		for k, v in pairs(SourceN) do
			table.insert(BoxN,SetCtrig1X(FixPlayer,VFuncParaVarArr[DestN[k]][2],0x15C,0,SetTo,v))
		end
		if SourceN[1] ~= nil then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					BoxN,
				},
				flag = {Preserved}
			}
		end

		local BoxV = {}
		for k, v in pairs(SourceV) do
			if v[5] == nil then
				v[5] = 0
			end
			table.insert(BoxV,SetCtrig1X(FixPlayer,VFuncParaVarArr[DestV[k]][2],0x15C,0,SetTo,v[5]))
			table.insert(BoxV,SetCtrigX(v[1],v[2],0x158,v[3],SetTo,FixPlayer,VFuncParaVarArr[DestV[k]][2],0x15C,1,0))
			table.insert(BoxV,SetCtrig1X(v[1],v[2],0x148,v[3],SetTo,0xFFFFFFFF))
			table.insert(BoxV,SetCtrig1X(v[1],v[2],0x160,v[3],SetTo,SetTo*16777216,0xFF000000))
		end
		if SourceV[1] ~= nil then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					BoxV,
					CallLabelAlwaysN(table.unpack(SourceV));
				},
				flag = {Preserved}
			}
		end

		local Ret = {Wariable[2]}
		for i = 1, #Parameter do
			table.insert(Ret,VFuncParaVarArr[i])
		end
		Trigger { 
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				CallLabelAlwaysN(table.unpack(Ret));
			},
			flag = {Preserved}
		}

		f_LMov(PlayerID,{Mem("X",IndexAlloc+1,0x15C,0),Mem("X",IndexAlloc+1,0x178,0)},Wariable[1])
		Trigger { 
			players = {PlayerID},
			conditions = {
				Label(IndexAlloc+1);
			},
			actions = {
				SetCtrig1X("X","X",0x4,0,SetTo,0); -- CFunction[1],CFunction[2],0x0,0,1
				SetCtrig2X(0,SetTo,"X","X",0x0,0,1); -- CFunction[1],CFunction[2]+1,0x4,0
				SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1);
			},
			flag = {Preserved}
		}
	end

	local BoxR = {}
	local SourceR = {}
	for k, v in pairs(Return) do
		table.insert(SourceR,{FixPlayer,CFuncRetVarArr[k][2],0,"V"})
		if type(v) == "number" then
			table.insert(BoxR,SetCtrig1X(FixPlayer,CFuncRetVarArr[k][2],0x158,0,SetTo,EPD(v)))
		elseif v[4]== "V" then
			table.insert(BoxR,SetCtrigX(FixPlayer,CFuncRetVarArr[k][2],0x158,0,SetTo,v[1],v[2],0x15C,1,v[3]))
		else
			table.insert(BoxR,SetCtrigX(FixPlayer,CFuncRetVarArr[k][2],0x158,0,SetTo,v[1],v[2],v[3],1,v[4]))
		end
		table.insert(BoxR,SetCtrig1X(FixPlayer,CFuncRetVarArr[k][2],0x148,0,SetTo,0xFFFFFFFF))
		table.insert(BoxR,SetCtrig1X(FixPlayer,CFuncRetVarArr[k][2],0x160,0,SetTo,SetTo*16777216,0xFF000000))
	end

	if Return[1] ~= nil then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				BoxR,
				CallLabelAlwaysN(table.unpack(SourceR));
			},
			flag = {Preserved}
		}
	end

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+2);
		},
		flag = {Preserved}
	}
	PlayerID = PlayerConvert(PlayerID)
	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",IndexAlloc+2,0x0,0,1))
	end
	IndexAlloc = IndexAlloc + 3
end

function CallVFuncX(PlayerID,Wariable,Parameter,Return)
	if Wariable[4] == "WA" then
		local TempRet = {"X",WRet[7],0,"W"}
		MovW(PlayerID,TempRet,Wariable)
		Wariable = TempRet
	end

	if Parameter == nil then
		Parameter = {}
	end
	if Return == nil then
		Return = {}
	end
	STPopTrigArr(PlayerID)

	if #Wariable ~= 2 then
		local SourceN = {}
		local SourceV = {}
		local DestN = {}
		local DestV = {}
		for k, v in pairs(Parameter) do 
			if type(v) == "number" then
				table.insert(SourceN,v)
				table.insert(DestN,k)
			elseif v[4] == "V" then
				table.insert(SourceV,v)
				table.insert(DestV,k)
			else
				CallVFuncX_InputData_Error()
			end
		end
		local BoxN = {}
		for k, v in pairs(SourceN) do
			table.insert(BoxN,SetCtrig1X(FixPlayer,CFuncParaVarArr[DestN[k]][2],0x15C,0,SetTo,v))
		end
		if SourceN[1] ~= nil then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					BoxN,
				},
				flag = {Preserved}
			}
		end

		local BoxV = {}
		for k, v in pairs(SourceV) do
			if v[5] == nil then
				v[5] = 0
			end
			table.insert(BoxV,SetCtrig1X(FixPlayer,CFuncParaVarArr[DestV[k]][2],0x15C,0,SetTo,v[5]))
			table.insert(BoxV,SetCtrigX(v[1],v[2],0x158,v[3],SetTo,FixPlayer,CFuncParaVarArr[DestV[k]][2],0x15C,1,0))
			table.insert(BoxV,SetCtrig1X(v[1],v[2],0x148,v[3],SetTo,0xFFFFFFFF))
			table.insert(BoxV,SetCtrig1X(v[1],v[2],0x160,v[3],SetTo,SetTo*16777216,0xFF000000))
		end
		if SourceV[1] ~= nil then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					BoxV,
					CallLabelAlwaysN(table.unpack(SourceV));
				},
				flag = {Preserved}
			}
		end

		f_LMov(PlayerID,{Mem("X",IndexAlloc,0x15C,0),Mem("X",IndexAlloc,0x178,0)},Wariable)
		Trigger { 
			players = {PlayerID},
			conditions = {
				Label(IndexAlloc);
			},
			actions = {
				SetCtrig1X("X","X",0x4,0,SetTo,0); -- CFunction[1],CFunction[2],0x0,0,1
				SetCtrig2X(0,SetTo,"X","X",0x0,0,1); -- CFunction[1],CFunction[2]+1,0x4,0
			},
			flag = {Preserved}
		}
		IndexAlloc = IndexAlloc + 1
	else
		local SourceN = {}
		local SourceV = {}
		local DestN = {}
		local DestV = {}
		for k, v in pairs(Parameter) do 
			if type(v) == "number" then
				table.insert(SourceN,v)
				table.insert(DestN,k)
			elseif v[4] == "V" then
				table.insert(SourceV,v)
				table.insert(DestV,k)
			else
				CallVFuncX_InputData_Error()
			end
		end
		local BoxN = {}
		for k, v in pairs(SourceN) do
			table.insert(BoxN,SetCtrig1X(FixPlayer,VFuncParaVarArr[DestN[k]][2],0x15C,0,SetTo,v))
		end
		if SourceN[1] ~= nil then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					BoxN,
				},
				flag = {Preserved}
			}
		end

		local BoxV = {}
		for k, v in pairs(SourceV) do
			if v[5] == nil then
				v[5] = 0
			end
			table.insert(BoxV,SetCtrig1X(FixPlayer,VFuncParaVarArr[DestV[k]][2],0x15C,0,SetTo,v[5]))
			table.insert(BoxV,SetCtrigX(v[1],v[2],0x158,v[3],SetTo,FixPlayer,VFuncParaVarArr[DestV[k]][2],0x15C,1,0))
			table.insert(BoxV,SetCtrig1X(v[1],v[2],0x148,v[3],SetTo,0xFFFFFFFF))
			table.insert(BoxV,SetCtrig1X(v[1],v[2],0x160,v[3],SetTo,SetTo*16777216,0xFF000000))
		end
		if SourceV[1] ~= nil then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					BoxV,
					CallLabelAlwaysN(table.unpack(SourceV));
				},
				flag = {Preserved}
			}
		end

		local Ret = {Wariable[2]}
		for i = 1, #Parameter do
			table.insert(Ret,VFuncParaVarArr[i])
		end
		Trigger { 
			players = {PlayerID},
			conditions = {
				Label();
			},
			actions = {
				CallLabelAlwaysN(table.unpack(Ret));
			},
			flag = {Preserved}
		}

		f_LMov(PlayerID,{Mem("X",IndexAlloc,0x15C,0),Mem("X",IndexAlloc,0x178,0)},Wariable[1])
		Trigger { 
			players = {PlayerID},
			conditions = {
				Label(IndexAlloc);
			},
			actions = {
				SetCtrig1X("X","X",0x4,0,SetTo,0); -- CFunction[1],CFunction[2],0x0,0,1
				SetCtrig2X(0,SetTo,"X","X",0x0,0,1); -- CFunction[1],CFunction[2]+1,0x4,0
			},
			flag = {Preserved}
		}
		IndexAlloc = IndexAlloc + 1
	end

	local BoxR = {}
	local SourceR = {}
	for k, v in pairs(Return) do
		table.insert(SourceR,{FixPlayer,CFuncRetVarArr[k][2],0,"V"})
		if type(v) == "number" then
			table.insert(BoxR,SetCtrig1X(FixPlayer,CFuncRetVarArr[k][2],0x158,0,SetTo,EPD(v)))
		elseif v[4]== "V" then
			table.insert(BoxR,SetCtrigX(FixPlayer,CFuncRetVarArr[k][2],0x158,0,SetTo,v[1],v[2],0x15C,1,v[3]))
		else
			table.insert(BoxR,SetCtrigX(FixPlayer,CFuncRetVarArr[k][2],0x158,0,SetTo,v[1],v[2],v[3],1,v[4]))
		end
		table.insert(BoxR,SetCtrig1X(FixPlayer,CFuncRetVarArr[k][2],0x148,0,SetTo,0xFFFFFFFF))
		table.insert(BoxR,SetCtrig1X(FixPlayer,CFuncRetVarArr[k][2],0x160,0,SetTo,SetTo*16777216,0xFF000000))
	end

	if Return[1] ~= nil then
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(0);
			},
			actions = {
				BoxR,
				CallLabelAlwaysN(table.unpack(SourceR));
			},
			flag = {Preserved}
		}
	end
end

function _VFunc(Wariable,Parameter)
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if Parameter == nil then
		Parameter = {}
	end

	table.insert(STPushTrigArr,{"CallVFuncX",Wariable,Parameter,{TempData}}) 

	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function TTVFunc(Wariable,Parameter,flag)
	local Mode = 31
	local FIndex = FlagAlloc
	local FCode = FlagIndex(FIndex)

	local Pack = {}
	table.insert(Pack,Wariable)
	table.insert(Pack,Parameter)

	table.insert(TTPushTrigArr,{})
	table.insert(TTPushCondArr,Pack)
	table.insert(TTFCodeArr,FCode)
	table.insert(TTModeArr,Mode)

	FlagAlloc = FlagAlloc + 1
	local TTVFuncX
	if flag == 0 then
		TTVFuncX = CDeaths("X",Exactly,0,FCode)
	else
		TTVFuncX = CDeaths("X",AtLeast,1,FCode)
	end
	return TTVFuncX
end

function _TTVFunc(Wariable,Parameter,flag)
	return {"TT","TTVFunc",Wariable,Parameter,flag}
end

function ExitDrop(PlayerID,DropPlayer)
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
			LocalPlayerID(DropPlayer);
		},
		actions = {
			SetCtrigX("X",0xFFFD,0x4,0,SetTo,"X",0xFFFD,0x0,0,1);
		},
		flag = {Preserved}
	}
end

function PauseCount(Player,Type,Value)
	if Player == 0 then
		return MemoryX(0x58D718,Type,Value,0xFF)
	elseif Player == 1 then
		return MemoryX(0x58D718,Type,Value*256,0xFF00)
	elseif Player == 2 then
		return MemoryX(0x58D718,Type,Value*65536,0xFF0000)
	elseif Player == 3 then
		return MemoryX(0x58D718,Type,Value*16777216,0xFF000000)
	elseif Player == 4 then
		return MemoryX(0x58D71C,Type,Value,0xFF)
	elseif Player == 5 then
		return MemoryX(0x58D71C,Type,Value*256,0xFF00)
	elseif Player == 6 then
		return MemoryX(0x58D71C,Type,Value*65536,0xFF0000)
	elseif Player == 7 then
		return MemoryX(0x58D71C,Type,Value*16777216,0xFF000000)
	end
end

function SetPauseCount(Player,Type,Value)
	if Player == 0 then
		return SetMemoryX(0x58D718,Type,Value,0xFF)
	elseif Player == 1 then
		return SetMemoryX(0x58D718,Type,Value*256,0xFF00)
	elseif Player == 2 then
		return SetMemoryX(0x58D718,Type,Value*65536,0xFF0000)
	elseif Player == 3 then
		return SetMemoryX(0x58D718,Type,Value*16777216,0xFF000000)
	elseif Player == 4 then
		return SetMemoryX(0x58D71C,Type,Value,0xFF)
	elseif Player == 5 then
		return SetMemoryX(0x58D71C,Type,Value*256,0xFF00)
	elseif Player == 6 then
		return SetMemoryX(0x58D71C,Type,Value*65536,0xFF0000)
	elseif Player == 7 then
		return SetMemoryX(0x58D71C,Type,Value*16777216,0xFF000000)
	end
end

function SetDropTimer(Type,Value)
	return SetMemory(0x59CC80,Type,Value)
end

function SetDropWindow(Type,Value)
	return SetMemory(0x59CC78,Type,Value)
end

function DropTimer(Type,Value)
	return Memory(0x59CC80,Type,Value)
end

function DropWindow(Type,Value)
	return Memory(0x59CC78,Type,Value)
end

function SaveValueMsg(String,FileName)
	local FilePath = FileDirectory..FileName
	local Fileptr = io.open(FilePath, "wb")
	if Fileptr == nil then
		PushErrorMsg(FilePath.."\nCan't be Open!")
	end

	Fileptr:write(String)
   
    local size = Fileptr:seek("end")
	io.close(Fileptr)
	return size
end


function Include_Last()
	local IncludePlayer = IncludePlayerID
	local LastCJumpAlloc = CAPlotJumpAlloc
	CAPlotJumpAlloc = CAPlotJumpAlloc + 1
	CJump(IncludePlayer,LastCJumpAlloc)
	if FCBPAINTCheck == 1 then
		Include_CBLast(IncludePlayer)
	end
--------------------------------------------------
if FCGUCheck == 1 then
-- f_CGive - Ret[1] : PTR / Ret[2] : EPD+19 / Ret[3] : Prev PID / Ret[4] : New PID
-- Ret[5] : EPD+26 / Ret[6] : EPD+27 / Ret[7], Ret[8] : Prev ptr,epd / Ret[9], Ret[10] : Next ptr,epd
-- Ret[11] : EPD(0x6283F8) + New PID / Ret[12], Ret[13] : New Prev ptr,epd / Ret[14], Ret[15] : New Next ptr,epd / Ret[16] : New Prev Next
-- Ret[17] : 중복 방지 / (탱크,골럇은 처리가능) 인터셉터 스캐럽 벙커 드랍쉽 뽑는유닛 등의 유닛은 적용 X

	NJumpEnd(IncludePlayer,CAPlotJumpAlloc)
	f_Read(IncludePlayer,FCGU[2],FCGU[1],FCGU[2])

	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FCGUCall1);
				NVar(FCGU[2],AtLeast,1);
			},
			actions = {SetNVar(FCGU[2],Add,19)},
			flag = {Preserved}
		}

	CIf(IncludePlayer,NVar(FCGU[1],Exactly,0))
		CMov(IncludePlayer,FCGU[1],_lShift(FCGU[2],2),0x58A364-0x4C)
	CIfEnd()

	CIf(IncludePlayer,NVar(FCGU[2],Exactly,0))
		f_EPD(IncludePlayer,FCGU[2],FCGU[1])
		CAdd(IncludePlayer,FCGU[2],19)
	CIfEnd()

	CIf(IncludePlayer,NVar(FCGU[3],Exactly,-1),SetNVar(FCGU[3],SetTo,0)) -- f_OptCGive
		CRead(IncludePlayer,FCGU[3],FCGU[2],0,0xFF)
	CIfEnd()

	TriggerX(IncludePlayer,{NVar(FCGU[4],AtLeast,12)},{SetNVar(FCGU[4],SetTo,0)},{Preserved})

	CWrite(IncludePlayer,FCGU[2],FCGU[4],0,0xFF)
	CMov(IncludePlayer,FCGU[5],FCGU[2],26-19)
	CMov(IncludePlayer,FCGU[6],FCGU[2],27-19)

	f_Read(IncludePlayer,FCGU[5],FCGU[7],FCGU[8]) -- Prev
	f_Read(IncludePlayer,FCGU[6],FCGU[9],FCGU[10]) -- Next

	CIfX(IncludePlayer,NVar(FCGU[7],AtLeast,0x59CCA8))
		CWrite(IncludePlayer,Vi(FCGU[8][2],27),FCGU[9])
	CElseX()
		CWrite(IncludePlayer,Vi(FCGU[3][2],EPD(0x6283F8)),FCGU[9])
	CIfXEnd()

	CIf(IncludePlayer,NVar(FCGU[9],AtLeast,0x59CCA8))
		CWrite(IncludePlayer,Vi(FCGU[10][2],26),FCGU[7])
	CIfEnd()

	CMov(IncludePlayer,FCGU[11],FCGU[4],EPD(0x6283F8))

	CIfX(IncludePlayer,{TMemory(FCGU[11],AtLeast,0x59CCA8)})
		f_Read(IncludePlayer,FCGU[11],FCGU[12],FCGU[13])
		CMov(IncludePlayer,FCGU[16],FCGU[13],27)
		f_Read(IncludePlayer,FCGU[16],FCGU[14],FCGU[15])
		CWrite(IncludePlayer,FCGU[16],FCGU[1])
		CWrite(IncludePlayer,FCGU[5],FCGU[12])
		CWrite(IncludePlayer,FCGU[6],FCGU[14])
		CIf(IncludePlayer,NVar(FCGU[14],AtLeast,0x59CCA8))
			CWrite(IncludePlayer,Vi(FCGU[15][2],26),FCGU[1])
		CIfEnd()
	CElseX()
		CWrite(IncludePlayer,FCGU[11],FCGU[1])
		CWrite(IncludePlayer,FCGU[5],0)
		CWrite(IncludePlayer,FCGU[6],0)
	CIfXEnd()

	NJump(IncludePlayer,CAPlotJumpAlloc,{NVar(FCGU[17],Exactly,0),TMemory(Vi(FCGU[2][2],28-19),AtLeast,0x59CCA8)},{SetNVar(FCGU[2],Add,28-19),SetNVar(FCGU[17],SetTo,1)})
	CAPlotJumpAlloc = CAPlotJumpAlloc + 1
	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FCGUCall2);
			},
			actions = {
				SetNVar(FCGU[1],SetTo,0);
				SetNVar(FCGU[2],SetTo,0);
				SetNVar(FCGU[17],SetTo,0);
			},
			flag = {Preserved}
		}
end
-----------------------------------------------------------
if FCTACheck == 1 then
-- f_CunitToAlphaID - Ret[1] : EPD / Ret[2] : Ret
-- alphaID = 2048 * tos + 1 (index=0)
-- alphaID = 2048 * tos + 1701 - index(1~1699)
	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FCTACall0);
			},
			actions = {
				SetCVar("X",NRet[1],SetTo,0);
				SetCVar("X",NRet[4],Subtract,0x58A364);
			},
			flag = {Preserved}
		}
	CDiv(IncludePlayer,V(NRet[1]),V(NRet[4]),4)

	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FCTACall1);
			},
			actions = {
				SetCVar("X",NRet[3],SetTo,0);
				SetCVar("X",NRet[1],Add,41);
			},
			flag = {Preserved}
		}
	CReadX(IncludePlayer,V(NRet[3]),V(NRet[1]),1700,{0xFF00,0xFFFFFFFF},8) -- Tos*2048 + 1701

	DoActionsX(IncludePlayer,{SetCVar("X",NRet[1],Subtract,41),SetCVar("X",NRet[2],SetTo,161741)})

	CSub(IncludePlayer,V(NRet[2]),V(NRet[1]))
	
	CDiv(IncludePlayer,V(NRet[2]),84) -- Index

	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label();
				CVar("X",NRet[2],Exactly,0);
			},
			actions = {
				SetCVar("X",NRet[3],Subtract,1700);
			},
			flag = {Preserved}
		}

	CSub(IncludePlayer,V(NRet[3]),V(NRet[2]))

	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FCTACall2);
			},
			flag = {Preserved}
		}
end
-----------------------------------------------------------
if FATCCheck == 1 then
	-- f_AlphaIDToCunit - Ret[1] : AlphaID / Ret[2] : Ret / Ret[3] : Output / Ret[4] : EPDOutput
	-- index(0) = 1 - alphaID%2048
	-- index(1~1699) = 1701 - alphaID%2048
Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FATCCall1);
			},
			actions = {
				SetCVar("X",NRet[5],SetTo,1700);
				SetCVar("X",NRet[4],SetTo,161741);
				SetCVar("X",NRet[3],SetTo,0x628298);
			},
			flag = {Preserved}
		}
	CIfX(IncludePlayer,CVar("X",NRet[1],AtLeast,1))
		CMod(IncludePlayer,V(NRet[2]),V(NRet[1]),2048) -- Alpha%2048
		CSub(IncludePlayer,V(NRet[5]),V(NRet[2]))

		Trigger {  -- Index
				players = {IncludePlayer},
				conditions = {
					Label();
					CVar("X",NRet[5],Exactly,1700);
				},
				actions = {
					SetCVar("X",NRet[5],SetTo,0);
				},
				flag = {Preserved}
			}

		for i = 10, 0, -1 do
			local CBit = 2^i
			Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label();
					CVar("X",NRet[5],Exactly,CBit,CBit);
				},
				actions = {
					SetCVar("X",NRet[3],Add,-CBit*0x150);
					SetCVar("X",NRet[4],Add,-CBit*84);
				},
				flag = {Preserved}
			}
		end
	CElseX({SetCVar("X",NRet[3],SetTo,0),SetCVar("X",NRet[4],SetTo,0)})
	CIfXEnd()
	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FATCCall2);
			},
			flag = {Preserved}
		}
end
-----------------------------------------------------------
if FPSTRCheck == 1 then
	-- f_GetStrptr - Ret[1] : StringId  Ret[2] = Type | Ret[3] = Strptr  
	Trigger {
				players = {IncludePlayer},
					conditions = {
						Label(FPSTRCall0);
					},
					actions = {
						SetCtrig1X("X",FPSTR[1],0x15C,0,SetTo,0);
					},
					flag = {Preserved}
				}

	for i = 14, 0, -1 do
		local CBit = 2^i
			Trigger {
					players = {IncludePlayer},
						conditions = {
							Label(0);
						   	CtrigX("X",FPSTR[2],0x15C,0,AtLeast,CBit*2);
						},
						actions = {
							SetCtrig1X("X",FPSTR[2],0x15C,0,Subtract,CBit*2);
							SetCtrig1X("X",FPSTR[1],0x15C,0,Add,CBit);
						},
						flag = {Preserved}
					}
	end

	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FPSTRCall1);
			},
			actions = {
				SetCVar("X",FPSTR[3],SetTo,0x191943C8);
				SetMemory(0x6509B0,SetTo,EPD(0x191943C8));
				SetCtrig1X("X",FPSTR[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",FPSTR[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",FPSTR[1],0x160,0,SetTo,Add*16777216,0xFF000000);
				CallLabelAlways("X",FPSTR[1],0);
			},
			flag = {Preserved}
		}

	CIfX(IncludePlayer,CVar("X",FPSTR[2],Exactly,0)) -- 0x0000FFFF
		for i = 0, 15 do
			local CBit = 2^i
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FPSTR[3],0x15C,0,Add,CBit);
					},
					flag = {Preserved}
				}
		end
	CElseX()
		for i = 16, 31 do
			local CBit = 2^i
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FPSTR[3],0x15C,0,Add,CBit/65536);
					},
					flag = {Preserved}
				}
		end
	CIfXEnd()

	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FPSTRCall2);
			},
			flag = {Preserved}
		}
end
-----------------------------------------------------------
if FPSTRXCheck == 1 then
	-- f_GetStrXptr - Ret[1] : StringId | Ret[2] = Strptr  
	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FPSTRXCall1);
			},
			actions = {
				SetCVar("X",FPSTRX[2],SetTo,0x191943C8);
				SetMemory(0x6509B0,SetTo,EPD(0x191943C8));
				SetCtrig1X("X",FPSTRX[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",FPSTRX[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",FPSTRX[1],0x160,0,SetTo,Add*16777216,0xFF000000);
				CallLabelAlways("X",FPSTRX[1],0);
			},
			flag = {Preserved}
		}

	for i = 0, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",FPSTRX[2],0x15C,0,Add,CBit);
				},
				flag = {Preserved}
			}
	end

	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FPSTRXCall2);
			},
			flag = {Preserved}
		}
end
-----------------------------------------------------------
if FPTBLCheck == 1 then
-- f_GetTblptr - Ret[1] : Tbl Index  Ret[2] = Type | Ret[3] = Tblptr  
	Trigger {
				players = {IncludePlayer},
					conditions = {
						Label(FPTBLCall0);
					},
					actions = {
						SetCtrig1X("X",FPTBL[1],0x15C,0,SetTo,0);
					},
					flag = {Preserved}
				}

	for i = 14, 0, -1 do
		local CBit = 2^i
			Trigger {
					players = {IncludePlayer},
						conditions = {
							Label(0);
						   	CtrigX("X",FPTBL[2],0x15C,0,AtLeast,CBit*2);
						},
						actions = {
							SetCtrig1X("X",FPTBL[2],0x15C,0,Subtract,CBit*2);
							SetCtrig1X("X",FPTBL[1],0x15C,0,Add,CBit);
						},
						flag = {Preserved}
					}
	end

	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FPTBLCall1);
			},
			actions = {
				SetCVar("X",FPTBL[3],SetTo,0x19184660);
				SetMemory(0x6509B0,SetTo,EPD(0x19184660));
				SetCtrig1X("X",FPTBL[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",FPTBL[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",FPTBL[1],0x160,0,SetTo,Add*16777216,0xFF000000);
				CallLabelAlways("X",FPTBL[1],0);
			},
			flag = {Preserved}
		}

	CIfX(IncludePlayer,CVar("X",FPTBL[2],Exactly,0)) -- 0x0000FFFF
		for i = 0, 15 do
			local CBit = 2^i
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FPTBL[3],0x15C,0,Add,CBit);
					},
					flag = {Preserved}
				}
		end
	CElseX()
		for i = 16, 31 do
			local CBit = 2^i
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FPTBL[3],0x15C,0,Add,CBit/65536);
					},
					flag = {Preserved}
				}
		end
	CIfXEnd()

	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FPTBLCall2);
			},
			flag = {Preserved}
		}
end
-----------------------------------------------------------
if FISTRXCheck == 1 then
-- f_GetiStrXepd - Ret[1] : StringId | Ret[2] = Strepd
	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FISTRXCall1);
			},
			actions = {
				SetCVar("X",FISTRX[2],SetTo,EPD(0x191943C8));
				SetMemory(0x6509B0,SetTo,EPD(0x191943C8));
				SetCtrig1X("X",FISTRX[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",FISTRX[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",FISTRX[1],0x160,0,SetTo,Add*16777216,0xFF000000);
				CallLabelAlways("X",FISTRX[1],0);
			},
			flag = {Preserved}
		}

	for i = 2, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",FISTRX[2],0x15C,0,Add,CBit/4);
				},
				flag = {Preserved}
			}
	end

	Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(FISTRXCall2);
			},
			flag = {Preserved}
		}
end
-----------------------------------------------------------
if ISTRCheck == 1 then
	-- f_InitiStrptr - Ret[1] : Offset , Ret[2] : EPD, Ret[3] : EPDX, Ret[4] : Size (4N+3), Ret[5] : EPD Backup
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(ISTRCall1);
				},
				flag = {Preserved}
			}

		CMod(IncludePlayer,V(ISTR[3]),V(ISTR[1]),4)
		CMov(IncludePlayer,V(ISTR[2]),V(CRet[1]))
		CiSub(IncludePlayer,V(ISTR[2]),1452249)
		CMov(IncludePlayer,V(ISTR[5]),V(ISTR[2]))

		CIfX(IncludePlayer,CVar("X",ISTR[3],Exactly,0)) -- <- 3byte
			CWhile(IncludePlayer,CVar("X",ISTR[4],AtLeast,1),SetCVar("X",ISTR[4],Subtract,1))
				CDoActions(IncludePlayer,{TSetMemoryX(V(ISTR[2]),SetTo,_ReadFX(V(ISTR[2]),0xFF000000,"-3"),0xFF),TSetMemoryX(V(ISTR[2]),SetTo,_ReadFX(_Add(V(ISTR[2]),1),0xFFFFFF,"+1"),0xFFFFFF00)})
			CWhileEnd(SetCVar("X",ISTR[2],Add,1))
			CDoActions(IncludePlayer,{TSetMemoryX(V(ISTR[2]),SetTo,0x0D0D0D,0xFFFFFF)})
		CElseIfX(CVar("X",ISTR[3],Exactly,1),SetCVar("X",ISTR[5],Add,1)) -- <- 0byte

		CElseIfX(CVar("X",ISTR[3],Exactly,2),{SetCVar("X",ISTR[5],Add,1),SetCVar("X",ISTR[2],Add,1)}) -- <- 1byte
			CWhile(IncludePlayer,CVar("X",ISTR[4],AtLeast,1),SetCVar("X",ISTR[4],Subtract,1))
				CDoActions(IncludePlayer,{TSetMemoryX(V(ISTR[2]),SetTo,_ReadFX(V(ISTR[2]),0xFFFFFF00,"-1"),0xFFFFFF),TSetMemoryX(V(ISTR[2]),SetTo,_ReadFX(_Add(V(ISTR[2]),1),0xFF,"+3"),0xFF000000)})
			CWhileEnd(SetCVar("X",ISTR[2],Add,1))
			CDoActions(IncludePlayer,{TSetMemoryX(V(ISTR[2]),SetTo,0x0D,0xFF)})
		CElseIfX(CVar("X",ISTR[3],Exactly,3),{SetCVar("X",ISTR[5],Add,1),SetCVar("X",ISTR[2],Add,1)}) -- <- 2byte
			CWhile(IncludePlayer,CVar("X",ISTR[4],AtLeast,1),SetCVar("X",ISTR[4],Subtract,1))
				CDoActions(IncludePlayer,{TSetMemoryX(V(ISTR[2]),SetTo,_ReadFX(V(ISTR[2]),0xFFFF0000,"-2"),0xFFFF),TSetMemoryX(V(ISTR[2]),SetTo,_ReadFX(_Add(V(ISTR[2]),1),0xFFFF,"+2"),0xFFFF0000)})
			CWhileEnd(SetCVar("X",ISTR[2],Add,1))
			CDoActions(IncludePlayer,{TSetMemoryX(V(ISTR[2]),SetTo,0x0D0D,0xFFFF)})
		CIfXEnd()

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(ISTRCall2);
				},
				flag = {Preserved}
			}
end
-----------------------------------------------------------
if ITBLCheck == 1 then
	-- f_InitiTblptr - Ret[1] : Offset , Ret[2] : EPD, Ret[3] : EPDX, Ret[4] : Size (4N+3), Ret[5] : EPD Backup, Ret[6] : PointerEPD, Ret[7] : PointerEPDX
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(ITBLCall1);
				},
				flag = {Preserved}
			}

		CMod(IncludePlayer,V(ITBL[3]),V(ITBL[1]),4)
		CMov(IncludePlayer,V(ITBL[2]),V(CRet[1]))
		CiSub(IncludePlayer,V(ITBL[2]),1452249)
		CMov(IncludePlayer,V(ITBL[5]),V(ITBL[2]))

		CIfX(IncludePlayer,CVar("X",ITBL[3],Exactly,0),{TSetMemoryX(V(ITBL[2]),SetTo,_ReadFX(V(ITBL[2]),0xFFFF,"+2"),0xFFFF0000),SetCVar("X",ITBL[2],Add,1)}) -- Init 2-> / <-1 tbl
			CWhile(IncludePlayer,CVar("X",ITBL[4],AtLeast,1),SetCVar("X",ITBL[4],Subtract,1))
				CDoActions(IncludePlayer,{TSetMemoryX(V(ITBL[2]),SetTo,_ReadFX(V(ITBL[2]),0xFFFFFF00,"-1"),0xFFFFFF),TSetMemoryX(V(ITBL[2]),SetTo,_ReadFX(_Add(V(ITBL[2]),1),0xFF,"+3"),0xFF000000)})
			CWhileEnd(SetCVar("X",ITBL[2],Add,1))
			CDoActions(IncludePlayer,{TSetMemoryX(V(ITBL[2]),SetTo,0x0D,0xFF),SetCVar("X",ITBL[5],Add,1)})
			CTrigger(IncludePlayer,{CVar("X",ITBL[7],Exactly,0)},{TSetMemory(V(ITBL[6]),Add,2)},{Preserved})
			CTrigger(IncludePlayer,{CVar("X",ITBL[7],Exactly,1)},{TSetMemory(V(ITBL[6]),Add,2*65536)},{Preserved})
		CElseIfX(CVar("X",ITBL[3],Exactly,1),{TSetMemoryX(V(ITBL[2]),SetTo,_ReadFX(V(ITBL[2]),0xFFFF00,"+1"),0xFFFF0000),SetCVar("X",ITBL[2],Add,1)}) -- Init 1-> / <-2 tbl
			CWhile(IncludePlayer,CVar("X",ITBL[4],AtLeast,1),SetCVar("X",ITBL[4],Subtract,1))
				CDoActions(IncludePlayer,{TSetMemoryX(V(ITBL[2]),SetTo,_ReadFX(V(ITBL[2]),0xFFFF0000,"-2"),0xFFFF),TSetMemoryX(V(ITBL[2]),SetTo,_ReadFX(_Add(V(ITBL[2]),1),0xFFFF,"+2"),0xFFFF0000)})
			CWhileEnd(SetCVar("X",ITBL[2],Add,1))
			CDoActions(IncludePlayer,{TSetMemoryX(V(ITBL[2]),SetTo,0x0D0D,0xFFFF),SetCVar("X",ITBL[5],Add,1)})
			CTrigger(IncludePlayer,{CVar("X",ITBL[7],Exactly,0)},{TSetMemory(V(ITBL[6]),Add,1)},{Preserved})
			CTrigger(IncludePlayer,{CVar("X",ITBL[7],Exactly,1)},{TSetMemory(V(ITBL[6]),Add,1*65536)},{Preserved})
		CElseIfX(CVar("X",ITBL[3],Exactly,2),{SetCVar("X",ITBL[2],Add,1)}) -- Init 0-> / <-3 tbl
			CWhile(IncludePlayer,CVar("X",ITBL[4],AtLeast,1),SetCVar("X",ITBL[4],Subtract,1))
				CDoActions(IncludePlayer,{TSetMemoryX(V(ITBL[2]),SetTo,_ReadFX(V(ITBL[2]),0xFF000000,"-3"),0xFF),TSetMemoryX(V(ITBL[2]),SetTo,_ReadFX(_Add(V(ITBL[2]),1),0xFFFFFF,"+1"),0xFFFFFF00)})
			CWhileEnd(SetCVar("X",ITBL[2],Add,1))
			CDoActions(IncludePlayer,{TSetMemoryX(V(ITBL[2]),SetTo,0x0D0D0D,0xFFFFFF),SetCVar("X",ITBL[5],Add,1)})
		CElseIfX(CVar("X",ITBL[3],Exactly,3),{TSetMemoryX(_Add(V(ITBL[2]),1),SetTo,_ReadFX(V(ITBL[2]),0xFF000000,"-1"),0xFF0000),TSetMemoryX(_Add(V(ITBL[2]),1),SetTo,_ReadFX(_Add(V(ITBL[2]),1),0xFF,"+3"),0xFF000000)}) -- Init 3-> / <-0 tbl
			CDoActions(IncludePlayer,{SetCVar("X",ITBL[5],Add,2)})
			CTrigger(IncludePlayer,{CVar("X",ITBL[7],Exactly,0)},{TSetMemory(V(ITBL[6]),Add,3)},{Preserved})
			CTrigger(IncludePlayer,{CVar("X",ITBL[7],Exactly,1)},{TSetMemory(V(ITBL[6]),Add,3*65536)},{Preserved})
		CIfXEnd()

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(ITBLCall2);
				},
				flag = {Preserved}
			}
end
-----------------------------------------------------------
-- f_Sqrt - Ret[1] : Input Value / Ret[2] = Output | Ret = √X 
if FSQRTCheck == 1 then
	Trigger {
		players = {IncludePlayer},
		conditions = { -- X == 0
			Label(FSQRTCall1);
			CtrigX("X",FSQRT[1],0x15C,0,Exactly,0);
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FSQRTCall2,0,0,0); -- Skip Calc
			SetCtrig1X("X",FSQRT[2],0x15C,0,SetTo,0);
		},
		flag = {Preserved}
	}

	for i = 15, 0, -1 do
		local CBit = 2^i
		Trigger { -- 1 ~ 16
			players = {IncludePlayer},
			conditions = { -- X Max Bit Check
				Label(0);
				CtrigX("X",FSQRT[1],0x15C,0,AtLeast,CBit^2);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FSQRTCall1,0,0,17+2*(15-i)); -- Jump Calc
				SetCtrig1X("X",FSQRT[2],0x15C,0,SetTo,0);	
			},
			flag = {Preserved}
		}
	end

	for i = 15, 0, -1 do -- 17 ~ 47
		local CBit = 2^i
		Trigger { -- 17, 19, ~ 47
			players = {IncludePlayer},
			conditions = { -- X^2 Binary Search
				Label(0);
				CtrigX("X",FSQRT[1],0x15C,0,AtLeast,CBit^2);
			},
			actions = {
				SetCtrig1X("X",FSQRT[2],0x15C,0,Add,CBit);
			},
			flag = {Preserved}
		}
		if i >= 1 then
			Trigger { -- 18, 20, ~ 46
				players = {IncludePlayer},
				conditions = { -- Go X^2
					Label(0);
				},
				actions = {
					SetCtrig1X("X",CRet[3],0x15C,0,SetTo,CBit/2); -- Add CBit
					SetCtrig1X("X",CRet[4],0x15C,0,SetTo,CBit/2);
					SetCtrigX("X",FSQRTCall3,0x4,1,SetTo,"X","X",0,0,1);
					SetCtrigX("X",FSQRTCall3,0x15C,0,SetTo,"X","X",0x24,1,1);	
				},
				flag = {Preserved}
			}
		end
	end

	local PlayerID = IncludePlayer
	PlayerID = PlayerConvert(PlayerID)
	for k, P in pairs(PlayerID) do
		for i = 18, 46, 2 do
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",FSQRTCall1,0x4,i,SetTo,"X",FSQRTCall2,0x0,0,1)) -- -> X*X
		end
	end

	ClearJump1 = {}
	for i = 0, 16 do 
		table.insert(ClearJump1,SetCtrigX("X",FSQRTCall1,0x4,i,SetTo,"X",FSQRTCall1,0,0,i+1))
	end
	for i = 17, 47, 2 do 
		table.insert(ClearJump1,SetCtrig1X("X",FSQRTCall1,0x24,i,SetTo, 2^(47-i) ))
	end

	Trigger {
		players = {IncludePlayer},
		conditions = { -- Init Calc
			Label(FSQRTCall2);
		},
		actions = {
			ClearJump1,
		},
		flag = {Preserved}
	}

	Trigger { -- +1
		players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FSQRT[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",FSQRT[2],0x160,0,SetTo,Add*16777216,0xFF000000);
				SetCtrigX("X",FSQRT[2],0x158,0,SetTo,"X",CRet[3],0x15C,1,0);
				CallLabelAlways("X",FSQRT[2],0);
			},
			flag = {Preserved}
		}
	Trigger { -- +2
		players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FSQRT[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",FSQRT[2],0x160,0,SetTo,Add*16777216,0xFF000000);
				SetCtrigX("X",FSQRT[2],0x158,0,SetTo,"X",CRet[4],0x15C,1,0);
				CallLabelAlways("X",FSQRT[2],0);
			},
			flag = {Preserved}
		}

	CMul(IncludePlayer,V(CRet[3]),V(CRet[4]),"X","X",0xFFFF)-- FuncAlloc + 1

	Trigger { 
		players = {IncludePlayer},
			conditions = {
				Label(FSQRTCall3);
			},
			actions = {
				SetCtrigX("X",CRet[3],0x158,0,SetTo,"X",FSQRTCall1,0x24,1,17);
				SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[3],0);
			},
			flag = {Preserved}
		}
	Trigger { 
		players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			flag = {Preserved}
		}
end
-----------------------------------------------------------
-- f_Lengthdir - Ret[1] : Input R  Ret[2] = Θ | Ret[3] = RCosΘ  Ret[4] = RSinΘ
	if AngleCycle == "X" or AngleCycle == nil then
		AngleCycle = 360
	end
	local Range = AngleCycle/4
if FLENGCheck == 1 then
	for i = 0, Range do
		if i == 0 then
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FuncAlloc);
				},
				actions = {
					SetDeathsX(0,SetTo,0x10000*math.sin(math.rad(i*90/Range)),0,0xFFFFFFFF); -- Full Variable
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
		else
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label();
				},
				actions = {
					SetDeathsX(0,SetTo,0x10000*math.sin(math.rad(i*90/Range)),0,0xFFFFFFFF); -- Full Variable
					Disabled(SetDeathsX(0,SetTo,0,0,0xFFFFFFFF)); -- Recover Next
				},
				flag = {Preserved}
			}
		end
	end
	local FLENGVA = GetVArray(V(FuncAlloc))
	FuncAlloc = FuncAlloc + 1

	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(FLENGCall1);
		},
		flag = {Preserved}
	}

 	CIfX(IncludePlayer,CVar("X",FLENG[2],AtLeast,AngleCycle))
		CiMod(IncludePlayer,V(FLENG[2]),AngleCycle)
	CIfXEnd()

	CIfX(IncludePlayer,CVar("X",FLENG[2],AtLeast,0x80000000))
		CAdd(IncludePlayer,V(FLENG[2]),AngleCycle)
	CIfXEnd()

	-- FLENG[5] = Cos Signflag / FLENG[6] = Sin Signflag / FLENG[7] = Cos VAindex / FLENG[8] = Sin VAindex
	CIfX(IncludePlayer,CVar("X",FLENG[2],AtMost,Range-1)) 
		DoActionsX(IncludePlayer,{SetCVar("X",FLENG[5],SetTo,0),SetCVar("X",FLENG[6],SetTo,0)})
		CMov(IncludePlayer,V(FLENG[8]),V(FLENG[2])) -- Sin.i << i
		CMov(IncludePlayer,V(FLENG[7]),Range)
		CSub(IncludePlayer,V(FLENG[7]),V(FLENG[2])) -- Cos.i << pi/2 - i
	CElseIfX(CVar("X",FLENG[2],AtMost,Range*2-1))
		DoActionsX(IncludePlayer,{SetCVar("X",FLENG[5],SetTo,1),SetCVar("X",FLENG[6],SetTo,0)})
		CMov(IncludePlayer,V(FLENG[8]),Range*2) -- Sin.i << pi - i
		CSub(IncludePlayer,V(FLENG[8]),V(FLENG[2]))
		CMov(IncludePlayer,V(FLENG[7]),V(FLENG[2])) -- Cos.i << i - pi/2
		CSub(IncludePlayer,V(FLENG[7]),Range)
	CElseIfX(CVar("X",FLENG[2],AtMost,Range*3-1))
		DoActionsX(IncludePlayer,{SetCVar("X",FLENG[5],SetTo,1),SetCVar("X",FLENG[6],SetTo,1)})
		CMov(IncludePlayer,V(FLENG[8]),V(FLENG[2])) -- Sin.i << i - pi
		CSub(IncludePlayer,V(FLENG[8]),Range*2)
		CMov(IncludePlayer,V(FLENG[7]),Range*3) -- Cos.i << 3pi/2 - i
		CSub(IncludePlayer,V(FLENG[7]),V(FLENG[2]))
	CElseX()
		DoActionsX(IncludePlayer,{SetCVar("X",FLENG[5],SetTo,0),SetCVar("X",FLENG[6],SetTo,1)})
		CMov(IncludePlayer,V(FLENG[8]),Range*4)
		CSub(IncludePlayer,V(FLENG[8]),V(FLENG[2])) -- Sin.i << 2pi - i
		CMov(IncludePlayer,V(FLENG[7]),V(FLENG[2]))
		CSub(IncludePlayer,V(FLENG[7]),Range*3) -- Cos.i << i - 3pi/2
	CIfXEnd()

	CMov(IncludePlayer,V(FLENG[4]),VArr(FLENGVA,V(FLENG[8])))
	CMov(IncludePlayer,V(FLENG[3]),VArr(FLENGVA,V(FLENG[7])))

	f_Mul(IncludePlayer,V(FLENG[4]),V(FLENG[1]))
	f_Mul(IncludePlayer,V(FLENG[3]),V(FLENG[1]))

	CiDiv(IncludePlayer,V(FLENG[4]),0x10000)
	CiDiv(IncludePlayer,V(FLENG[3]),0x10000)

	CIfX(IncludePlayer,CVar("X",FLENG[5],Exactly,1))
		CNeg(IncludePlayer,V(FLENG[3]))
	CIfXEnd()

	CIfX(IncludePlayer,CVar("X",FLENG[6],Exactly,1))
		CNeg(IncludePlayer,V(FLENG[4]))
	CIfXEnd()

	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(FLENGCall2);
		},
		flag = {Preserved}
	}
end
-----------------------------------------------------------
-- f_Atan2 - Ret[1] : Input Y  Ret[2] = X | Ret[3] = Θ  
if FATANCheck == 1 then
	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(FATANCall1);
		},
		flag = {Preserved}
	}

	CIfX(IncludePlayer,CVar("X",FATAN[1],AtLeast,0x80000000)) 
		CIfX(IncludePlayer,CVar("X",FATAN[2],AtLeast,0x80000000)) -- 3사분면
			DoActionsX(IncludePlayer,{SetCVar("X",FATAN[4],SetTo,3)}) -- Θ + pi
			CNeg(IncludePlayer,V(FATAN[1]))
			CNeg(IncludePlayer,V(FATAN[2]))
		CElseX() -- 4사분면
			DoActionsX(IncludePlayer,{SetCVar("X",FATAN[4],SetTo,4)}) -- 2pi - Θ
			CNeg(IncludePlayer,V(FATAN[1]))
		CIfXEnd()
	CElseX()
		CIfX(IncludePlayer,CVar("X",FATAN[2],AtLeast,0x80000000)) -- 2사분면
			DoActionsX(IncludePlayer,{SetCVar("X",FATAN[4],SetTo,2)}) -- pi - Θ
			CNeg(IncludePlayer,V(FATAN[2]))
		CElseX() -- 1사분면
			DoActionsX(IncludePlayer,{SetCVar("X",FATAN[4],SetTo,1)}) -- Θ
		CIfXEnd()
	CIfXEnd()

	CMul(IncludePlayer,V(FATAN[1]),0x10000,"X","X",0xFFFFF)

	f_Div(IncludePlayer,V(FATAN[1]),V(FATAN[2]))

	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(0);
			CVar("X",FATAN[1],AtMost,0x10000*math.tan(math.rad(1*90/8)));
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,1);
			SetCtrigX("X",FuncAlloc+1,0x178,0,SetTo,"X","X",0x4,1,0);
			SetCtrigX("X",FuncAlloc+1,0x17C,0,SetTo,"X","X",0,0,1);
		},
		flag = {Preserved}
	}
	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(0);
			CVar("X",FATAN[1],AtMost,0x10000*math.tan(math.rad(2*90/8)));
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,math.floor(Range/8));
			SetCtrigX("X",FuncAlloc+1,0x178,0,SetTo,"X","X",0x4,1,0);
			SetCtrigX("X",FuncAlloc+1,0x17C,0,SetTo,"X","X",0,0,1);
		},
		flag = {Preserved}
	}
	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(0);
			CVar("X",FATAN[1],AtMost,0x10000*math.tan(math.rad(3*90/8)));
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,math.floor(2*Range/8));
			SetCtrigX("X",FuncAlloc+1,0x178,0,SetTo,"X","X",0x4,1,0);
			SetCtrigX("X",FuncAlloc+1,0x17C,0,SetTo,"X","X",0,0,1);
		},
		flag = {Preserved}
	}
	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(0);
			CVar("X",FATAN[1],AtMost,0x10000*math.tan(math.rad(4*90/8)));
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,math.floor(3*Range/8));
			SetCtrigX("X",FuncAlloc+1,0x178,0,SetTo,"X","X",0x4,1,0);
			SetCtrigX("X",FuncAlloc+1,0x17C,0,SetTo,"X","X",0,0,1);
		},
		flag = {Preserved}
	}
	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(0);
			CVar("X",FATAN[1],AtMost,0x10000*math.tan(math.rad(5*90/8)));
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,math.floor(4*Range/8));
			SetCtrigX("X",FuncAlloc+1,0x178,0,SetTo,"X","X",0x4,1,0);
			SetCtrigX("X",FuncAlloc+1,0x17C,0,SetTo,"X","X",0,0,1);
		},
		flag = {Preserved}
	}
	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(0);
			CVar("X",FATAN[1],AtMost,0x10000*math.tan(math.rad(6*90/8)));
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,math.floor(5*Range/8));
			SetCtrigX("X",FuncAlloc+1,0x178,0,SetTo,"X","X",0x4,1,0);
			SetCtrigX("X",FuncAlloc+1,0x17C,0,SetTo,"X","X",0,0,1);
		},
		flag = {Preserved}
	}
	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(0);
			CVar("X",FATAN[1],AtMost,0x10000*math.tan(math.rad(7*90/8)));
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,math.floor(6*Range/8));
			SetCtrigX("X",FuncAlloc+1,0x178,0,SetTo,"X","X",0x4,1,0);
			SetCtrigX("X",FuncAlloc+1,0x17C,0,SetTo,"X","X",0,0,1);
		},
		flag = {Preserved}
	}
	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(0);
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,math.floor(7*Range/8));
			SetCtrigX("X",FuncAlloc+1,0x178,0,SetTo,"X","X",0x4,1,0);
			SetCtrigX("X",FuncAlloc+1,0x17C,0,SetTo,"X","X",0,0,1);
		},
		flag = {Preserved}
	}
	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc);
		},
		flag = {Preserved}
	}
	FuncAlloc = FuncAlloc + 1
	for i = 0, Range-1 do
		Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CVar("X",FATAN[1],AtMost,0x10000*math.tan(math.rad(i*90/Range)));
			},
			actions = {
				SetCVar("X",FATAN[3],SetTo,i);
				SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,0);
				SetCtrigX("X",FuncAlloc,0x158,0,SetTo,"X","X",0x4,1,0);
				SetCtrigX("X",FuncAlloc,0x15C,0,SetTo,"X","X",0,0,1);
			},
			flag = {Preserved}
		}
	end
		Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCVar("X",FATAN[3],SetTo,Range);
				SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0,0,0);
				SetCtrigX("X",FuncAlloc,0x158,0,SetTo,"X","X",0x4,1,0);
				SetCtrigX("X",FuncAlloc,0x15C,0,SetTo,"X","X",0,0,1);
			},
			flag = {Preserved}
		}

	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			SetDeaths(0,SetTo,0,0);
		},
		flag = {Preserved}
	}
	FuncAlloc = FuncAlloc + 1

	CIfX(IncludePlayer,CVar("X",FATAN[4],Exactly,2))
		CMov(IncludePlayer,V(FATAN[3]),_Sub(_Mov(Range*2),V(FATAN[3])))
	CElseIfX(CVar("X",FATAN[4],Exactly,3))
		CAdd(IncludePlayer,V(FATAN[3]),Range*2)
	CElseIfX(CVar("X",FATAN[4],Exactly,4))
		CMov(IncludePlayer,V(FATAN[3]),_Sub(_Mov(Range*4),V(FATAN[3])))
	CIfXEnd()

	Trigger { 
		players = {IncludePlayer},
		conditions = {
			Label(FATANCall2);
		},
		flag = {Preserved}
	}
end
-----------------------------------------------------------
-- f_Log2 - Ret[1] : Input Value / Ret[2] = Output | Ret = log2(X) 
if FLOG2Check == 1 then
	Trigger {
		players = {IncludePlayer},
		conditions = { -- Init Calc
			Label(FLOG2Call1);
			CtrigX("X",FLOG2[1],0x15C,0,Exactly,0);
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FLOG2Call2,0,0,0); -- Skip Calc
			SetCtrigX("X",FLOG2Call2,0x158,0,SetTo,"X","X",0x4,1,0); -- RecoverNext
			SetCtrigX("X",FLOG2Call2,0x15C,0,SetTo,"X","X",0,0,1);
			SetCtrig1X("X",FLOG2[2],0x15C,0,SetTo,0x80000000);
		},
		flag = {Preserved}
	}

	Trigger {
		players = {IncludePlayer},
		conditions = {
			Label(0);
			CtrigX("X",FLOG2[1],0x15C,0,Exactly,1);
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",FLOG2Call2,0,0,0); -- Skip Calc
			SetCtrigX("X",FLOG2Call2,0x158,0,SetTo,"X","X",0x4,1,0); -- RecoverNext
			SetCtrigX("X",FLOG2Call2,0x15C,0,SetTo,"X","X",0,0,1);
			SetCtrig1X("X",FLOG2[2],0x15C,0,SetTo,0);
		},
		flag = {Preserved}
	}

	for i = 2, 31 do
		Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CtrigX("X",FLOG2[1],0x15C,0,AtMost,2^i-1);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FLOG2Call2,0,0,0); -- Skip Calc
				SetCtrigX("X",FLOG2Call2,0x158,0,SetTo,"X","X",0x4,1,0); -- RecoverNext
				SetCtrigX("X",FLOG2Call2,0x15C,0,SetTo,"X","X",0,0,1);
				SetCtrig1X("X",FLOG2[2],0x15C,0,SetTo,i-1);
			},
			flag = {Preserved}
		}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",FLOG2[2],0x15C,0,SetTo,31);
			},
			flag = {Preserved}
		}

	Trigger {
		players = {IncludePlayer},
		conditions = { -- End Calc
			Label(FLOG2Call2);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
		},
		flag = {Preserved}
	}
end
-----------------------------------------------------------
if FSHReadCheck == 1 then
	-- f_SHRead - Ret[1] : Input EPD / Ret[2] = Output

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FSHReadCall1);
				DeathsX(CurrentPlayer,Exactly,0x80000000,0,0x80000000);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x15C,0,SetTo,0xFFFF0000);
			},
			flag = {Preserved}
		}
	for i = 0, 15 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",CRet[2],0x15C,0,Add,CBit);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FSHReadCall2);
			},
			flag = {Preserved}
		}
end
-----------------------------------------------------------
if FMEMCheck == 1 then
	-- f_Memcpy - Ret[1] : Input Dest / Ret[2] = Source / Ret[3] = DestX / Ret[4] = SourceX / Ret[5] = Size

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FMEMCall0);
				},
				flag = {Preserved}
			}
		FMEMAlloc = FMEMAlloc + 1

		
		CIfX(IncludePlayer,CVar("X",FMEM[6],Exactly,0))
			CMod(IncludePlayer,V(FMEM[3]),V(FMEM[1]),4)
			CMov(IncludePlayer,V(FMEM[1]),V(CRet[1]))
			CiSub(IncludePlayer,V(FMEM[1]),1452249)
		CIfXEnd()
		CMod(IncludePlayer,V(FMEM[4]),V(FMEM[2]),4)
		CMov(IncludePlayer,V(FMEM[2]),V(CRet[1]))
		CiSub(IncludePlayer,V(FMEM[2]),1452249)

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FMEMCall1);
				},
				flag = {Preserved}
			}
		FMEMAlloc = FMEMAlloc + 1

		CIfX(IncludePlayer,CVar("X",FMEM[3],AtLeast,4))
			CMod(IncludePlayer,V(FMEM[3]),4)
			CAdd(IncludePlayer,V(FMEM[1]),V(CRet[1]))
		CIfXEnd()

		CIfX(IncludePlayer,CVar("X",FMEM[4],AtLeast,4))
			CMod(IncludePlayer,V(FMEM[4]),4)
			CAdd(IncludePlayer,V(FMEM[2]),V(CRet[1]))
		CIfXEnd()

		CIfX(IncludePlayer,CVar("X",FMEM[3],Exactly,0))
			CIfX(IncludePlayer,CVar("X",FMEM[4],Exactly,0))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFFFFFF,1),0xFFFFFFFF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1),SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFFFF,1),0x00FFFFFF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,1),0x0000FFFF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,1),0x000000FF)},{Preserved})
				CIfXEnd()
			CElseIfX(CVar("X",FMEM[4],Exactly,1))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFFFF00,1/256),0x00FFFFFF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF,16777216),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFFFF00,1/256),0x00FFFFFF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFF00,1/256),0x0000FFFF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FF00,1/256),0x000000FF)},{Preserved})
				CIfXEnd()
			CElseIfX(CVar("X",FMEM[4],Exactly,2))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1/65536),0x0000FFFF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,65536),0xFFFF0000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1/65536),0x0000FFFF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,65536),0x00FF00000)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1/65536),0x0000FFFF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FF0000,1/65536),0x000000FF)},{Preserved})
				CIfXEnd()
			CElseX()
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/16777216),0x000000FF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFFFF,256),0xFFFFFF00)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/16777216),0x000000FF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,256),0x00FFFF000)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/16777216),0x000000FF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,256),0x0000FF000)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/16777216),0x000000FF)},{Preserved})
				CIfXEnd()
			CIfXEnd()
		CElseIfX(CVar("X",FMEM[3],Exactly,1))
			CIfX(IncludePlayer,CVar("X",FMEM[4],Exactly,0))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFFFF,256),0xFFFFFF00)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/16777216),0x000000FF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFFFF,256),0xFFFFFF00)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,256),0x00FFFF00)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,256),0x0000FF00)},{Preserved})
				CIfXEnd()
			CElseIfX(CVar("X",FMEM[4],Exactly,1))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFFFF00,1),0xFFFFFF00)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1),SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,1),0x000000FF)},{Preserved})
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFFFF00,1),0xFFFFFF00)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFF00,1),0x00FFFF00)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FF00,1),0x0000FF00)},{Preserved})
				CIfXEnd()
			CElseIfX(CVar("X",FMEM[4],Exactly,2))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1/256),0x00FFFF00)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,16777216),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FF00,1/256),0x000000FF)},{Preserved})
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1/256),0x00FFFF00)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,16777216),0xFF000000)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1/256),0x00FFFF00)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FF0000,1/256),0x0000FF00)},{Preserved})
				CIfXEnd()
			CElseX()
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/65536),0x0000FF00)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,65536),0xFFFF0000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FF0000,1/65536),0x000000FF)},{Preserved})
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/65536),0x0000FF00)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,65536),0xFFFF0000)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/65536),0x0000FF00)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,65536),0x00FF0000)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/65536),0x0000FF00)},{Preserved})
				CIfXEnd()
			CIfXEnd()
		CElseIfX(CVar("X",FMEM[3],Exactly,2))
			CIfX(IncludePlayer,CVar("X",FMEM[4],Exactly,0))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,65536),0xFFFF0000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1/65536),0x0000FFFF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,65536),0xFFFF0000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FF0000,1/65536),0x000000FF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,65536),0xFFFF0000)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,65536),0x00FF0000)},{Preserved})
				CIfXEnd()
			CElseIfX(CVar("X",FMEM[4],Exactly,1))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFF00,256),0xFFFF0000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/16777216),0x000000FF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,256),0x0000FF00)},{Preserved})
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFF00,256),0xFFFF0000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/16777216),0x000000FF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFF00,256),0xFFFF0000)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FF00,256),0x00FF0000)},{Preserved})
				CIfXEnd()
			CElseIfX(CVar("X",FMEM[4],Exactly,2))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1),0xFFFF0000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1),SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,1),0x0000FFFF)},{Preserved})
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1),0xFFFF0000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,1),0x000000FF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1),0xFFFF0000)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FF0000,1),0x00FF0000)},{Preserved})
				CIfXEnd()
			CElseX()
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/256),0x00FF0000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,16777216),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFF00,1/256),0x0000FFFF)},{Preserved})
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/256),0x00FF0000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,16777216),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FF00,1/256),0x000000FF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/256),0x00FF0000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,16777216),0xFF000000)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/256),0x00FF0000)},{Preserved})
				CIfXEnd()
			CIfXEnd()
		CElseX()
			CIfX(IncludePlayer,CVar("X",FMEM[4],Exactly,0))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,16777216),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFFFF00,1/256),0x00FFFFFF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,16777216),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFF00,1/256),0x0000FFFF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,16777216),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FF00,1/256),0x000000FF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,16777216),0xFF000000)},{Preserved})
				CIfXEnd()
			CElseIfX(CVar("X",FMEM[4],Exactly,1))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FF00,65536),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1/65536),0x0000FFFF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,65536),0x00FF0000)},{Preserved})
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FF00,65536),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFFFF0000,1/65536),0x0000FFFF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FF00,65536),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FF0000,1/65536),0x000000FF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FF00,65536),0xFF000000)},{Preserved})
				CIfXEnd()
			CElseIfX(CVar("X",FMEM[4],Exactly,2))
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FF0000,256),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/16777216),0x000000FF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,256),0x00FFFF00)},{Preserved})
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FF0000,256),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/16777216),0x000000FF)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,256),0x0000FF00)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FF0000,256),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1/16777216),0x000000FF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FF0000,256),0xFF000000)},{Preserved})
				CIfXEnd()
			CElseX()
				CWhile(IncludePlayer, CVar("X",FMEM[5],AtLeast,4),SetCVar("X",FMEM[5],Subtract,4))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x00FFFFFF,1),0x00FFFFFF)},{Preserved})
				CWhileEnd()
				CIfX(IncludePlayer,CVar("X",FMEM[5],Exactly,3))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x0000FFFF,1),0x0000FFFF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,2))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1),0xFF000000)},{Preserved})
					Trigger {players = {IncludePlayer},conditions = {Label(FMEMAlloc);},actions = {SetCVar("X",FMEM[2],Add,1),SetCVar("X",FMEM[1],Add,1)},flag = {Preserved}}
					FMEMAlloc = FMEMAlloc + 1
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0x000000FF,1),0x000000FF)},{Preserved})
				CElseIfX(CVar("X",FMEM[5],Exactly,1))
					CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEM[1]),SetTo,_ReadFX(V(FMEM[2]),0xFF000000,1),0xFF000000)},{Preserved})
				CIfXEnd()
			CIfXEnd()
		CIfXEnd()

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FMEMCall2);
				},
				flag = {Preserved}
			}
		FMEMAlloc = FMEMAlloc + 1
end
-----------------------------------------------------------
if FMEMECheck == 1 then
-- f_MemcpyEPD - Ret[1] : Input Dest / Ret[2] = Source / Ret[3] = Size / Ret[4] = VAflag

	Trigger {
		players = {IncludePlayer},
		conditions = {
			Label(FMEMECall1);
		},
		flag = {Preserved}
	}

	CWhile(IncludePlayer, CVar("X",FMEME[3],AtLeast,4),SetCVar("X",FMEME[3],Subtract,4))
		CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEME[1]),SetTo,_ReadX(V(FMEME[2]),0xFFFFFFFF,1),0xFFFFFFFF)},{Preserved})
		Trigger {players = {IncludePlayer},conditions = {Label(FMEMEArr[1][1]);},actions = {SetCVar("X",FMEME[2],Add,1),SetCVar("X",FMEME[1],Add,1)},flag = {Preserved}}
	CWhileEnd()
	CIfX(IncludePlayer,CVar("X",FMEME[3],Exactly,3))
		CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEME[1]),SetTo,_ReadX(V(FMEME[2]),0x00FFFFFF,1),0x00FFFFFF)},{Preserved})
	CElseIfX(CVar("X",FMEME[3],Exactly,2))
		CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEME[1]),SetTo,_ReadX(V(FMEME[2]),0x0000FFFF,1),0x0000FFFF)},{Preserved})
	CElseIfX(CVar("X",FMEME[3],Exactly,1))
		CTrigger(IncludePlayer, nil,{TSetMemoryX(V(FMEME[1]),SetTo,_ReadX(V(FMEME[2]),0x000000FF,1),0x000000FF)},{Preserved})
	CIfXEnd()

	Trigger {
		players = {IncludePlayer},
		conditions = {
			Label(FMEMECall2);
		},
		flag = {Preserved}
	}
end
-----------------------------------------------------------
-- f_Movcpy(EPD) - Ret[1] : Input Dest / Ret[2] : Source Offset / Ret[3] = Size / Ret[4] << Init Mask
if FMOVECheck == 1 then

	Trigger {
		players = {IncludePlayer},
		conditions = {
			Label(FMOVEAlloc);
		},
		flag = {Preserved}
	}
	FMOVECall0 = FMOVEAlloc
	FMOVEAlloc = FMOVEAlloc + 1

	CDiv(IncludePlayer,V(FMOVE[1]),4) 
	CMov(IncludePlayer,V(FMOVE[4]),V(CRet[2]))

	Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FMOVE[4],Exactly,0);
				},
				actions = {
					SetCVar("X",FMOVE[4],SetTo,0xFFFFFFFF);
					SetCVar("X",FMOVE[1],Add,0-1452249);
				},
				flag = {Preserved}
			}
	Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FMOVE[4],Exactly,1);
				},
				actions = {
					SetCVar("X",FMOVE[4],SetTo,0xFFFFFF00);
					SetCVar("X",FMOVE[1],Add,0-1452249);
				},
				flag = {Preserved}
			}
	Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FMOVE[4],Exactly,2);
				},
				actions = {
					SetCVar("X",FMOVE[4],SetTo,0xFFFF0000);
					SetCVar("X",FMOVE[1],Add,0-1452249);
				},
				flag = {Preserved}
			}
	Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FMOVE[4],Exactly,3);
				},
				actions = {
					SetCVar("X",FMOVE[4],SetTo,0xFF000000);
					SetCVar("X",FMOVE[1],Add,0-1452249);
				},
				flag = {Preserved}
			}

	Trigger {
		players = {IncludePlayer},
		conditions = {
			Label(FMOVEAlloc);
		},
		flag = {Preserved}
	}
	FMOVECall1 = FMOVEAlloc
	FMOVEAlloc = FMOVEAlloc + 1


	CIfX(IncludePlayer,CVar("X",FMOVE[3],AtLeast,4),SetCVar("X",FMOVE[3],Subtract,4))

		Trigger {--(CPRead)로 값 출력 (A)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[2],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FMOVE[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FMOVE[2],0x158,0,SetTo,"X",FMOVEAlloc,0x15C,1,0); 
					CallLabelAlways("X",FMOVE[2],0);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {IncludePlayer},
				conditions = { -- (B)
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FMOVE[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FMOVE[1],0x158,0,SetTo,"X",FMOVEAlloc,0x19C,1,0); 
					CallLabelAlways("X",FMOVE[1],0);
				},
				flag = {Preserved}
			}


		Trigger {
				players = {IncludePlayer},
				conditions = { -- (C)
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[4],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FMOVE[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FMOVE[4],0x158,0,SetTo,"X",FMOVEAlloc,0x21C,1,0); 
					CallLabelAlways("X",FMOVE[4],0);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FMOVEAlloc);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]); 0x0 (A)
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrig1X(VA[1],VA[2],0x158,VA[3],SetTo,EPD(Dest)); EPD 0x158 (B)
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1); EPD 0x4
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,0,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,InitMask); EPD 0x148 (C)
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000); EPD 0x160
					SetMemory(0x6509B0,Add,(0x0-0x160)/4);
					SetMemory(0x6509B0,Add,(0x970)/4);
					SetCVar("X",FMOVE[2],Add,0x970);
					SetCVar("X",FMOVE[1],Add,1);
				},
				flag = {Preserved}
			}
	CIfXEnd()
	FMOVEAlloc = FMOVEAlloc + 1

	Trigger {--(CPRead)로 값 출력 (A)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[2],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FMOVE[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FMOVE[2],0x158,0,SetTo,"X",FMOVEAlloc,0x15C,1,0); 
					CallLabelAlways("X",FMOVE[2],0);
				},
				flag = {Preserved}
			}

	Trigger {
				players = {IncludePlayer},
				conditions = { -- (B)
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FMOVE[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FMOVE[1],0x158,0,SetTo,"X",FMOVEAlloc,0x19C,1,0); 
					CallLabelAlways("X",FMOVE[1],0);
				},
				flag = {Preserved}
			}

	CWhile(IncludePlayer,CVar("X",FMOVE[3],AtLeast,4),SetCVar("X",FMOVE[3],Subtract,4))
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FMOVEAlloc);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]); 0x0 (A)
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrig1X(VA[1],VA[2],0x158,VA[3],SetTo,EPD(Dest)); EPD 0x158 (B)
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1); EPD 0x4
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,0xFFFFFFFF,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,0xFFFFFFFF); EPD 0x148 
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000); EPD 0x160
					SetMemory(0x6509B0,Add,(0x0-0x160)/4);
					SetMemory(0x6509B0,Add,(0x970)/4);
					SetCVar("X",FMOVE[2],Add,0x970);
					SetCtrig1X("X",FMOVEAlloc,0x15C,0,Add,0x970);
					SetCVar("X",FMOVE[1],Add,1);
					SetCtrig1X("X",FMOVEAlloc,0x19C,0,Add,1);
				},
				flag = {Preserved}
			}
	CWhileEnd()
	FMOVEAlloc = FMOVEAlloc + 1

	CIfX(IncludePlayer,CVar("X",FMOVE[3],Exactly,3))
		Trigger {--(CPRead)로 값 출력 (A)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[2],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FMOVE[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FMOVE[2],0x158,0,SetTo,"X",FMOVEAlloc,0x15C,1,0); 
					CallLabelAlways("X",FMOVE[2],0);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {IncludePlayer},
				conditions = { -- (B)
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FMOVE[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FMOVE[1],0x158,0,SetTo,"X",FMOVEAlloc,0x19C,1,0); 
					CallLabelAlways("X",FMOVE[1],0);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FMOVEAlloc);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]); 0x0 (A)
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrig1X(VA[1],VA[2],0x158,VA[3],SetTo,EPD(Dest)); EPD 0x158 (B)
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1); EPD 0x4
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,0x00FFFFFF,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,InitMask); EPD 0x148 (C)
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000); EPD 0x160
					SetMemory(0x6509B0,Add,(0x0-0x160)/4);
				},
				flag = {Preserved}
			}
		FMOVEAlloc = FMOVEAlloc + 1
	CElseIfX(CVar("X",FMOVE[3],Exactly,2))
		Trigger {--(CPRead)로 값 출력 (A)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[2],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FMOVE[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FMOVE[2],0x158,0,SetTo,"X",FMOVEAlloc,0x15C,1,0); 
					CallLabelAlways("X",FMOVE[2],0);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {IncludePlayer},
				conditions = { -- (B)
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FMOVE[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FMOVE[1],0x158,0,SetTo,"X",FMOVEAlloc,0x19C,1,0); 
					CallLabelAlways("X",FMOVE[1],0);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FMOVEAlloc);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]); 0x0 (A)
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrig1X(VA[1],VA[2],0x158,VA[3],SetTo,EPD(Dest)); EPD 0x158 (B)
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1); EPD 0x4
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,0x0000FFFF,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,InitMask); EPD 0x148 (C)
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000); EPD 0x160
					SetMemory(0x6509B0,Add,(0x0-0x160)/4);
				},
				flag = {Preserved}
			}
		FMOVEAlloc = FMOVEAlloc + 1
	CElseIfX(CVar("X",FMOVE[3],Exactly,1))
		Trigger {--(CPRead)로 값 출력 (A)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[2],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FMOVE[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FMOVE[2],0x158,0,SetTo,"X",FMOVEAlloc,0x15C,1,0); 
					CallLabelAlways("X",FMOVE[2],0);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {IncludePlayer},
				conditions = { -- (B)
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FMOVE[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FMOVE[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FMOVE[1],0x158,0,SetTo,"X",FMOVEAlloc,0x19C,1,0); 
					CallLabelAlways("X",FMOVE[1],0);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FMOVEAlloc);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- SetCtrigX("X","X",0x4,0,SetTo,VA[1],VA[2],0,0,VA[3]); 0x0 (A)
					SetMemory(0x6509B0,Add,(0x158-0x0)/4);
					SetDeaths(CurrentPlayer,SetTo,0,0);	-- SetCtrig1X(VA[1],VA[2],0x158,VA[3],SetTo,EPD(Dest)); EPD 0x158 (B)
					SetMemory(0x6509B0,Add,(0x4-0x158)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- SetCtrigX(VA[1],VA[2],0x4,VA[3],SetTo,"X","X",0,0,1); EPD 0x4
					SetMemory(0x6509B0,Add,(0x148-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,0x000000FF,0); -- SetCtrig1X(VA[1],VA[2],0x148,VA[3],SetTo,InitMask); EPD 0x148 (C)
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- SetCtrig1X(VA[1],VA[2],0x160,VA[3],SetTo,SetTo*16777216,0xFF000000); EPD 0x160
					SetMemory(0x6509B0,Add,(0x0-0x160)/4);
				},
				flag = {Preserved}
			}
		FMOVEAlloc = FMOVEAlloc + 1
	CIfXEnd()

	Trigger {
		players = {IncludePlayer},
		conditions = {
			Label(FMOVEAlloc);
		},
		flag = {Preserved}
	}
	FMOVECall2 = FMOVEAlloc
	FMOVEAlloc = FMOVEAlloc + 1
end
-----------------------------------------------------------
if FCONVCheck == 1 then
	-- 	f_byteConvert - [1~4] : DestVA / [5] : Source / [6] : Size / [7] : SourceX
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FCONVCall0);
				},
				flag = {Preserved}
			}

		CMod(IncludePlayer,V(FCONV[7]),V(FCONV[5]),4)
		CMov(IncludePlayer,V(FCONV[5]),V(CRet[1]))
		CiSub(IncludePlayer,V(FCONV[5]),1452249)

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FCONVCall1);
				},
				flag = {Preserved}
			}


		CIfX(IncludePlayer,CVar("X",FCONV[7],AtLeast,4))
			CMod(IncludePlayer,V(FCONV[7]),4)
			CAdd(IncludePlayer,V(FCONV[5]),V(CRet[1]))
		CIfXEnd()

		CMov(IncludePlayer,0x6509B0,V(FCONV[5]))

		Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",FCONV[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FCONV[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",FCONV[1],0x158,0,SetTo,"X",FCONVAlloc+20,0x158+0x20*0,1,0);
						SetCtrig1X("X",FCONV[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FCONV[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",FCONV[2],0x158,0,SetTo,"X",FCONVAlloc+20,0x158+0x20*1,1,0);
						SetCtrig1X("X",FCONV[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FCONV[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",FCONV[3],0x158,0,SetTo,"X",FCONVAlloc+20,0x158+0x20*2,1,0);
						SetCtrig1X("X",FCONV[4],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FCONV[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",FCONV[4],0x158,0,SetTo,"X",FCONVAlloc+20,0x158+0x20*3,1,0);
						CallLabelAlways4("X",FCONV[1],0,"X",FCONV[2],0,"X",FCONV[3],0,"X",FCONV[4],0);

						SetCtrig1X("X",FCONVAlloc+20,0x148+0x20*0,0,SetTo,0xFFFFFFFF); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+20,0x148+0x20*1,0,SetTo,0xFFFFFF00); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+20,0x148+0x20*2,0,SetTo,0xFFFF0000); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+20,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FCONVAlloc+20,0x148+0x20*4,0,SetTo,0x000000FF); -- [2+1],[9]
						SetCtrig1X("X",FCONVAlloc+20,0x148+0x20*5,0,SetTo,0x0000FFFF); -- [3+1],[10]
						SetCtrig1X("X",FCONVAlloc+20,0x148+0x20*6,0,SetTo,0x00FFFFFF); -- [4+1],[11]
					},
					flag = {Preserved}
				}
		Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",FCONV[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FCONV[2],0x160,0,SetTo,Add*16777216,0xFF000000);
						SetCtrigX("X",FCONV[2],0x158,0,SetTo,"X",FCONVAlloc+20,0x158+0x20*4,1,0);
						SetCtrig1X("X",FCONV[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FCONV[3],0x160,0,SetTo,Add*16777216,0xFF000000);
						SetCtrigX("X",FCONV[3],0x158,0,SetTo,"X",FCONVAlloc+20,0x158+0x20*5,1,0);
						SetCtrig1X("X",FCONV[4],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FCONV[4],0x160,0,SetTo,Add*16777216,0xFF000000);
						SetCtrigX("X",FCONV[4],0x158,0,SetTo,"X",FCONVAlloc+20,0x158+0x20*6,1,0);
						SetCtrig1X("X",FCONVAlloc+20,0x158+0x20*4,0,SetTo,0x970);
						SetCtrig1X("X",FCONVAlloc+20,0x158+0x20*5,0,SetTo,0x970);
						SetCtrig1X("X",FCONVAlloc+20,0x158+0x20*6,0,SetTo,0x970);
						CallLabelAlways3("X",FCONV[2],0,"X",FCONV[3],0,"X",FCONV[4],0);

						SetCtrigX("X","X",0x4,1,SetTo,"X","X",0,0,2);
						SetCtrigX("X","X",0x4,2,SetTo,"X","X",0,0,3);
						SetCtrigX("X","X",0x4,3,SetTo,"X","X",0,0,4);
						SetCtrigX("X","X",0x4,4,SetTo,"X","X",0,0,5);
						SetCtrig1X("X",FCONVAlloc+20,0x15C+0x20*0,0,SetTo,0); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+20,0x15C+0x20*1,0,SetTo,0); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+20,0x15C+0x20*2,0,SetTo,0); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+20,0x15C+0x20*3,0,SetTo,0); -- [4],[11]
						SetCtrig1X("X",FCONVAlloc+20,0x15C+0x20*4,0,SetTo,0); -- [2+1],[9]
						SetCtrig1X("X",FCONVAlloc+20,0x15C+0x20*5,0,SetTo,0); -- [3+1],[10]
						SetCtrig1X("X",FCONVAlloc+20,0x15C+0x20*6,0,SetTo,0); -- [4+1],[11]
					},
					flag = {Preserved}
				}

		Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
						CVar("X",FCONV[7],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVAlloc,0x0,0,0);
						SetCtrigX("X",FCONVAlloc,0x4,0,SetTo,"X",FCONVAlloc,0x0,0,1);
						SetCtrigX("X",FCONVAlloc+1,0x4,0,SetTo,"X",FCONVAlloc+1,0x0,0,1);
						SetCtrigX("X",FCONVAlloc+2,0x4,0,SetTo,"X",FCONVAlloc+2,0x0,0,1);
						SetCtrigX("X",FCONVAlloc+3,0x4,0,SetTo,"X",FCONVAlloc+3,0x0,0,1);
						SetCtrigX("X",FCONVAlloc+4,0x4,0,SetTo,"X",FCONVAlloc+4,0x0,0,1);
						SetCtrigX("X",FCONVAlloc+20,0x4,0,SetTo,"X",FCONVAlloc,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+5,0x4,-1,SetTo,"X",FCONVAlloc+20,0x0,0,0);
					},
					flag = {Preserved}
				}
		Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
						CVar("X",FCONV[7],Exactly,1);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVAlloc+5,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+5,0x4,0,SetTo,"X",FCONVAlloc+5,0x0,0,1);
						SetCtrigX("X",FCONVAlloc+6,0x4,0,SetTo,"X",FCONVAlloc+6,0x0,0,1);
						SetCtrigX("X",FCONVAlloc+7,0x4,0,SetTo,"X",FCONVAlloc+7,0x0,0,1);
						SetCtrigX("X",FCONVAlloc+8,0x4,0,SetTo,"X",FCONVAlloc+8,0x0,0,1);
						SetCtrigX("X",FCONVAlloc+9,0x4,0,SetTo,"X",FCONVAlloc+9,0x0,0,1);
						SetCtrigX("X",FCONVAlloc+20,0x4,0,SetTo,"X",FCONVAlloc+5,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+10,0x4,-1,SetTo,"X",FCONVAlloc+20,0x0,0,0);
					},
					flag = {Preserved}
				}
		Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
						CVar("X",FCONV[7],Exactly,2);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVAlloc+10,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+10,0x4,0,SetTo,"X",FCONVAlloc+10,0x0,0,1);
						SetCtrigX("X",FCONVAlloc+11,0x4,0,SetTo,"X",FCONVAlloc+11,0x0,0,1);
						SetCtrigX("X",FCONVAlloc+12,0x4,0,SetTo,"X",FCONVAlloc+12,0x0,0,1);
						SetCtrigX("X",FCONVAlloc+13,0x4,0,SetTo,"X",FCONVAlloc+13,0x0,0,1);
						SetCtrigX("X",FCONVAlloc+14,0x4,0,SetTo,"X",FCONVAlloc+14,0x0,0,1);
						SetCtrigX("X",FCONVAlloc+20,0x4,0,SetTo,"X",FCONVAlloc+10,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+15,0x4,-1,SetTo,"X",FCONVAlloc+20,0x0,0,0);
					},
					flag = {Preserved}
				}
		Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
						CVar("X",FCONV[7],Exactly,3);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVAlloc+15,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+15,0x4,0,SetTo,"X",FCONVAlloc+15,0x0,0,1);
						SetCtrigX("X",FCONVAlloc+16,0x4,0,SetTo,"X",FCONVAlloc+16,0x0,0,1);
						SetCtrigX("X",FCONVAlloc+17,0x4,0,SetTo,"X",FCONVAlloc+17,0x0,0,1);
						SetCtrigX("X",FCONVAlloc+18,0x4,0,SetTo,"X",FCONVAlloc+18,0x0,0,1);
						SetCtrigX("X",FCONVAlloc+19,0x4,0,SetTo,"X",FCONVAlloc+19,0x0,0,1);
						SetCtrigX("X",FCONVAlloc+20,0x4,0,SetTo,"X",FCONVAlloc+15,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+20,0x4,-1,SetTo,"X",FCONVAlloc+20,0x0,0,0);
					},
					flag = {Preserved}
				}

		-------------------------------------------------
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FCONVAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVAlloc+20,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+20,0x4,0,SetTo,"X",FCONVAlloc+21,0x0,0,0);
						SetCtrig1X("X",FCONVAlloc+20,0x148+0x20*0,0,SetTo,0x00000000); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+20,0x148+0x20*1,0,SetTo,0x00000000); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+20,0x148+0x20*2,0,SetTo,0x00000000); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+20,0x148+0x20*3,0,SetTo,0x00000000); -- [4],[11]
						SetCtrig1X("X",FCONVAlloc+20,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FCONVAlloc+20,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FCONVAlloc+20,0x148+0x20*6,0,SetTo,0x00000000); -- [4+1],[11]
					},
					flag = {Preserved}
				}
			
			for i = 7, 0, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FCONVAlloc+20,0x15C+0x20*0,0,Add,CBit*1); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+20,0x15C+0x20*1,0,Add,CBit*256); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+20,0x15C+0x20*2,0,Add,CBit*65536); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+20,0x15C+0x20*3,0,Add,CBit*16777216); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			FCONVAlloc = FCONVAlloc+1
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FCONVAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVAlloc+19,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+19,0x4,0,SetTo,"X",FCONVAlloc+20,0x0,0,0);
						SetCtrig1X("X",FCONVAlloc+19,0x148+0x20*0,0,SetTo,0x000000FF); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+19,0x148+0x20*1,0,SetTo,0x0000FF00); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+19,0x148+0x20*2,0,SetTo,0x00FF0000); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+19,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FCONVAlloc+19,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FCONVAlloc+19,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FCONVAlloc+19,0x148+0x20*6,0,SetTo,0x00000000); -- [4+1],[11]
					},
					flag = {Preserved}
				}

			for i = 15, 8, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FCONVAlloc+19,0x15C+0x20*0,0,Add,CBit*1); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+19,0x15C+0x20*1,0,Add,CBit*256); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+19,0x15C+0x20*2,0,Add,CBit*65536); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+19,0x15C+0x20*6,0,Add,CBit/256); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			FCONVAlloc = FCONVAlloc+1

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FCONVAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVAlloc+18,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+18,0x4,0,SetTo,"X",FCONVAlloc+19,0x0,0,0);
						SetCtrig1X("X",FCONVAlloc+18,0x148+0x20*0,0,SetTo,0x0000FFFF); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+18,0x148+0x20*1,0,SetTo,0x00FFFF00); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+18,0x148+0x20*2,0,SetTo,0xFFFF0000); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+18,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FCONVAlloc+18,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FCONVAlloc+18,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FCONVAlloc+18,0x148+0x20*6,0,SetTo,0x000000FF); -- [4+1],[11]
					},
					flag = {Preserved}
				}

			for i = 23, 16, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FCONVAlloc+18,0x15C+0x20*0,0,Add,CBit*1); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+18,0x15C+0x20*1,0,Add,CBit*256); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+18,0x15C+0x20*5,0,Add,CBit/65536); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+18,0x15C+0x20*6,0,Add,CBit/256); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			FCONVAlloc = FCONVAlloc+1

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FCONVAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVAlloc+17,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+17,0x4,0,SetTo,"X",FCONVAlloc+18,0x0,0,0);
						SetCtrig1X("X",FCONVAlloc+17,0x148+0x20*0,0,SetTo,0x00FFFFFF); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+17,0x148+0x20*1,0,SetTo,0xFFFFFF00); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+17,0x148+0x20*2,0,SetTo,0xFFFF0000); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+17,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FCONVAlloc+17,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FCONVAlloc+17,0x148+0x20*5,0,SetTo,0x000000FF); -- [3+1],[10]
						SetCtrig1X("X",FCONVAlloc+17,0x148+0x20*6,0,SetTo,0x0000FFFF); -- [4+1],[11]
					},
					flag = {Preserved}
				}

			for i = 31, 24, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FCONVAlloc+17,0x15C+0x20*0,0,Add,CBit*1); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+17,0x15C+0x20*4,0,Add,CBit/16777216); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+17,0x15C+0x20*5,0,Add,CBit/65536); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+17,0x15C+0x20*6,0,Add,CBit/256); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			FCONVAlloc = FCONVAlloc+1
			
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FCONVAlloc);
					},
					actions = {
						SetMemory(0x6509B0,Add,1);
						SetCVar("X",FCONV[6],Subtract,1);
					},
					flag = {Preserved}
				}
			FCONVAlloc = FCONVAlloc+1

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FCONVAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVAlloc+15,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+15,0x4,0,SetTo,"X",FCONVAlloc+16,0x0,0,0);
						SetCtrig1X("X",FCONVAlloc+15,0x148+0x20*0,0,SetTo,0x00000000); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+15,0x148+0x20*1,0,SetTo,0x00000000); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+15,0x148+0x20*2,0,SetTo,0x00000000); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+15,0x148+0x20*3,0,SetTo,0x00000000); -- [4],[11]
						SetCtrig1X("X",FCONVAlloc+15,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FCONVAlloc+15,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FCONVAlloc+15,0x148+0x20*6,0,SetTo,0x00000000); -- [4+1],[11]
					},
					flag = {Preserved}
				}

			for i = 15, 8, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FCONVAlloc+15,0x15C+0x20*0,0,Add,CBit/256); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+15,0x15C+0x20*1,0,Add,CBit*1); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+15,0x15C+0x20*2,0,Add,CBit*256); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+15,0x15C+0x20*3,0,Add,CBit*65536); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			FCONVAlloc = FCONVAlloc+1
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FCONVAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVAlloc+14,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+14,0x4,0,SetTo,"X",FCONVAlloc+15,0x0,0,0);
						SetCtrig1X("X",FCONVAlloc+14,0x148+0x20*0,0,SetTo,0x000000FF); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+14,0x148+0x20*1,0,SetTo,0x0000FF00); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+14,0x148+0x20*2,0,SetTo,0x00FF0000); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+14,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FCONVAlloc+14,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FCONVAlloc+14,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FCONVAlloc+14,0x148+0x20*6,0,SetTo,0x00000000); -- [4+1],[11]

					},
					flag = {Preserved}
				}

			for i = 23, 16, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FCONVAlloc+14,0x15C+0x20*0,0,Add,CBit/256); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+14,0x15C+0x20*1,0,Add,CBit*1); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+14,0x15C+0x20*2,0,Add,CBit*256); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+14,0x15C+0x20*6,0,Add,CBit/65536); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			FCONVAlloc = FCONVAlloc+1

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FCONVAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVAlloc+13,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+13,0x4,0,SetTo,"X",FCONVAlloc+14,0x0,0,0);
						SetCtrig1X("X",FCONVAlloc+13,0x148+0x20*0,0,SetTo,0x0000FFFF); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+13,0x148+0x20*1,0,SetTo,0x00FFFF00); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+13,0x148+0x20*2,0,SetTo,0xFFFF0000); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+13,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FCONVAlloc+13,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FCONVAlloc+13,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FCONVAlloc+13,0x148+0x20*6,0,SetTo,0x000000FF); -- [4+1],[11]
					},
					flag = {Preserved}
				}

			for i = 31, 24, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FCONVAlloc+13,0x15C+0x20*0,0,Add,CBit/256); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+13,0x15C+0x20*1,0,Add,CBit*1); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+13,0x15C+0x20*5,0,Add,CBit/16777216); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+13,0x15C+0x20*6,0,Add,CBit/65536); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			FCONVAlloc = FCONVAlloc+1

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FCONVAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVAlloc+12,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+12,0x4,0,SetTo,"X",FCONVAlloc+13,0x0,0,0);
						SetCtrig1X("X",FCONVAlloc+12,0x148+0x20*0,0,SetTo,0x00FFFFFF); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+12,0x148+0x20*1,0,SetTo,0xFFFFFF00); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+12,0x148+0x20*2,0,SetTo,0xFFFF0000); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+12,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FCONVAlloc+12,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FCONVAlloc+12,0x148+0x20*5,0,SetTo,0x000000FF); -- [3+1],[10]
						SetCtrig1X("X",FCONVAlloc+12,0x148+0x20*6,0,SetTo,0x0000FFFF); -- [4+1],[11]
					},
					flag = {Preserved}
				}
			FCONVAlloc = FCONVAlloc+1
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FCONVAlloc);
					},
					actions = {
						SetMemory(0x6509B0,Add,1);
					},
					flag = {Preserved}
				}
			FCONVAlloc = FCONVAlloc+1

			for i = 7, 0, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FCONVAlloc+10,0x15C+0x20*0,0,Add,CBit*16777216); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+10,0x15C+0x20*4,0,Add,CBit*1); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+10,0x15C+0x20*5,0,Add,CBit*256); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+10,0x15C+0x20*6,0,Add,CBit*65536); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCVar("X",FCONV[6],Subtract,1);
					},
					flag = {Preserved}
				}



			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FCONVAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVAlloc+10,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+10,0x4,0,SetTo,"X",FCONVAlloc+11,0x0,0,0);
						SetCtrig1X("X",FCONVAlloc+10,0x148+0x20*0,0,SetTo,0x00000000); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+10,0x148+0x20*1,0,SetTo,0x00000000); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+10,0x148+0x20*2,0,SetTo,0x00000000); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+10,0x148+0x20*3,0,SetTo,0x00000000); -- [4],[11]
						SetCtrig1X("X",FCONVAlloc+10,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FCONVAlloc+10,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FCONVAlloc+10,0x148+0x20*6,0,SetTo,0x00000000); -- [4+1],[11]
					},
					flag = {Preserved}
				}

			for i = 23, 16, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FCONVAlloc+10,0x15C+0x20*0,0,Add,CBit/65536); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+10,0x15C+0x20*1,0,Add,CBit/256); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+10,0x15C+0x20*2,0,Add,CBit*1); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+10,0x15C+0x20*3,0,Add,CBit*256); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			FCONVAlloc = FCONVAlloc+1
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FCONVAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVAlloc+9,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+9,0x4,0,SetTo,"X",FCONVAlloc+10,0x0,0,0);
						SetCtrig1X("X",FCONVAlloc+9,0x148+0x20*0,0,SetTo,0x000000FF); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+9,0x148+0x20*1,0,SetTo,0x0000FF00); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+9,0x148+0x20*2,0,SetTo,0x00FF0000); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+9,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FCONVAlloc+9,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FCONVAlloc+9,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FCONVAlloc+9,0x148+0x20*6,0,SetTo,0x00000000); -- [4+1],[11]

					},
					flag = {Preserved}
				}

			for i = 31, 24, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FCONVAlloc+9,0x15C+0x20*0,0,Add,CBit/65536); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+9,0x15C+0x20*1,0,Add,CBit/256); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+9,0x15C+0x20*2,0,Add,CBit*1); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+9,0x15C+0x20*6,0,Add,CBit/16777216); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			FCONVAlloc = FCONVAlloc+1

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FCONVAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVAlloc+7,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+8,0x4,0,SetTo,"X",FCONVAlloc+8,0x0,0,0);
						SetCtrig1X("X",FCONVAlloc+8,0x148+0x20*0,0,SetTo,0x0000FFFF); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+8,0x148+0x20*1,0,SetTo,0x00FFFF00); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+8,0x148+0x20*2,0,SetTo,0xFFFF0000); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+8,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FCONVAlloc+8,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FCONVAlloc+8,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FCONVAlloc+8,0x148+0x20*6,0,SetTo,0x000000FF); -- [4+1],[11]
					},
					flag = {Preserved}
				}
			FCONVAlloc = FCONVAlloc+1

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FCONVAlloc);
					},
					actions = {
						SetMemory(0x6509B0,Add,1);
					},
					flag = {Preserved}
				}
			FCONVAlloc = FCONVAlloc+1

			for i = 7, 0, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FCONVAlloc+6,0x15C+0x20*0,0,Add,CBit*65536); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+6,0x15C+0x20*1,0,Add,CBit*16777216); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+6,0x15C+0x20*5,0,Add,CBit*1); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+6,0x15C+0x20*6,0,Add,CBit*256); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FCONVAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVAlloc+6,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+6,0x4,0,SetTo,"X",FCONVAlloc+7,0x0,0,0);
						SetCtrig1X("X",FCONVAlloc+6,0x148+0x20*0,0,SetTo,0x00FFFFFF); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+6,0x148+0x20*1,0,SetTo,0xFFFFFF00); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+6,0x148+0x20*2,0,SetTo,0xFFFF0000); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+6,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FCONVAlloc+6,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FCONVAlloc+6,0x148+0x20*5,0,SetTo,0x000000FF); -- [3+1],[10]
						SetCtrig1X("X",FCONVAlloc+6,0x148+0x20*6,0,SetTo,0x0000FFFF); -- [4+1],[11]
					},
					flag = {Preserved}
				}

			for i = 15, 8, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FCONVAlloc+6,0x15C+0x20*0,0,Add,CBit*65536); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+6,0x15C+0x20*4,0,Add,CBit/256); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+6,0x15C+0x20*5,0,Add,CBit*1); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+6,0x15C+0x20*6,0,Add,CBit*256); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			FCONVAlloc = FCONVAlloc+1
			
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCVar("X",FCONV[6],Subtract,1);
					},
					flag = {Preserved}
				}



			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FCONVAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVAlloc+5,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+5,0x4,0,SetTo,"X",FCONVAlloc+6,0x0,0,0);
						SetCtrig1X("X",FCONVAlloc+5,0x148+0x20*0,0,SetTo,0x00000000); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+5,0x148+0x20*1,0,SetTo,0x00000000); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+5,0x148+0x20*2,0,SetTo,0x00000000); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+5,0x148+0x20*3,0,SetTo,0x00000000); -- [4],[11]
						SetCtrig1X("X",FCONVAlloc+5,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FCONVAlloc+5,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FCONVAlloc+5,0x148+0x20*6,0,SetTo,0x00000000); -- [4+1],[11]
					},
					flag = {Preserved}
				}

			for i = 31, 24, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FCONVAlloc+5,0x15C+0x20*0,0,Add,CBit/16777216); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+5,0x15C+0x20*1,0,Add,CBit/65536); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+5,0x15C+0x20*2,0,Add,CBit/256); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+5,0x15C+0x20*3,0,Add,CBit*1); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			FCONVAlloc = FCONVAlloc+1

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FCONVAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVAlloc+3,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+4,0x4,0,SetTo,"X",FCONVAlloc+4,0x0,0,0);
						SetCtrig1X("X",FCONVAlloc+4,0x148+0x20*0,0,SetTo,0x000000FF); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+4,0x148+0x20*1,0,SetTo,0x0000FF00); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+4,0x148+0x20*2,0,SetTo,0x00FF0000); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+4,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FCONVAlloc+4,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FCONVAlloc+4,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FCONVAlloc+4,0x148+0x20*6,0,SetTo,0x00000000); -- [4+1],[11]

					},
					flag = {Preserved}
				}
			FCONVAlloc = FCONVAlloc+1

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FCONVAlloc);
					},
					actions = {
						SetMemory(0x6509B0,Add,1);
					},
					flag = {Preserved}
				}
			FCONVAlloc = FCONVAlloc+1

			for i = 7, 0, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FCONVAlloc+2,0x15C+0x20*0,0,Add,CBit*256); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+2,0x15C+0x20*1,0,Add,CBit*65536); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+2,0x15C+0x20*2,0,Add,CBit*16777216); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+2,0x15C+0x20*6,0,Add,CBit*1); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FCONVAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVAlloc+2,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+2,0x4,0,SetTo,"X",FCONVAlloc+3,0x0,0,0);
						SetCtrig1X("X",FCONVAlloc+2,0x148+0x20*0,0,SetTo,0x0000FFFF); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+2,0x148+0x20*1,0,SetTo,0x00FFFF00); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+2,0x148+0x20*2,0,SetTo,0xFFFF0000); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+2,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FCONVAlloc+2,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FCONVAlloc+2,0x148+0x20*5,0,SetTo,0x00000000); -- [3+1],[10]
						SetCtrig1X("X",FCONVAlloc+2,0x148+0x20*6,0,SetTo,0x000000FF); -- [4+1],[11]
					},
					flag = {Preserved}
				}

			for i = 15, 8, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FCONVAlloc+2,0x15C+0x20*0,0,Add,CBit*256); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+2,0x15C+0x20*1,0,Add,CBit*65536); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+2,0x15C+0x20*5,0,Add,CBit/256); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+2,0x15C+0x20*6,0,Add,CBit*1); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			DoActionsX(IncludePlayer,SetCVar("X",FCONV[6],Subtract,1))
			FCONVAlloc = FCONVAlloc+1

			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(FCONVAlloc);
						CVar("X",FCONV[6],Exactly,0);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCONVAlloc+1,0x0,0,0);
						SetCtrigX("X",FCONVAlloc+1,0x4,0,SetTo,"X",FCONVAlloc+2,0x0,0,0);
						SetCtrig1X("X",FCONVAlloc+1,0x148+0x20*0,0,SetTo,0x00FFFFFF); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+1,0x148+0x20*1,0,SetTo,0xFFFFFF00); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+1,0x148+0x20*2,0,SetTo,0xFFFF0000); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+1,0x148+0x20*3,0,SetTo,0xFF000000); -- [4],[11]
						SetCtrig1X("X",FCONVAlloc+1,0x148+0x20*4,0,SetTo,0x00000000); -- [2+1],[9]
						SetCtrig1X("X",FCONVAlloc+1,0x148+0x20*5,0,SetTo,0x000000FF); -- [3+1],[10]
						SetCtrig1X("X",FCONVAlloc+1,0x148+0x20*6,0,SetTo,0x0000FFFF); -- [4+1],[11]
					},
					flag = {Preserved}
				}

			for i = 23, 16, -1 do
				local CBit = 2^i
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCtrig1X("X",FCONVAlloc+1,0x15C+0x20*0,0,Add,CBit*256); -- [1],[8]
						SetCtrig1X("X",FCONVAlloc+1,0x15C+0x20*4,0,Add,CBit/65536); -- [2],[9]
						SetCtrig1X("X",FCONVAlloc+1,0x15C+0x20*5,0,Add,CBit/256); -- [3],[10]
						SetCtrig1X("X",FCONVAlloc+1,0x15C+0x20*6,0,Add,CBit*1); -- [4],[11]
					},
					flag = {Preserved}
				}
			end
			FCONVAlloc = FCONVAlloc+1
			
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCVar("X",FCONV[6],Subtract,1);
					},
					flag = {Preserved}
				}

			Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(FCONVAlloc);
					},
					actions = {
						SetMemoryX(0,SetTo,0,0xFFFFFFFF); -- [1],[8]
						SetMemoryX(0,SetTo,0,0xFFFFFF00); -- [2],[9]
						SetMemoryX(0,SetTo,0,0xFFFF0000); -- [3],[10]
						SetMemoryX(0,SetTo,0,0xFF000000); -- [4],[11]
						SetMemoryX(0,SetTo,0,0x000000FF); -- [2+1],[9]
						SetMemoryX(0,SetTo,0,0x0000FFFF); -- [3+1],[10]
						SetMemoryX(0,SetTo,0,0x00FFFFFF); -- [4+1],[11]
						SetCtrig1X("X","X",0x158+0x20*0,0,Add,0x970);
						SetCtrig1X("X","X",0x158+0x20*1,0,Add,0x970);
						SetCtrig1X("X","X",0x158+0x20*2,0,Add,0x970);
						SetCtrig1X("X","X",0x158+0x20*3,0,Add,0x970);
						SetCtrig1X("X","X",0x158+0x20*4,0,Add,0x970);
						SetCtrig1X("X","X",0x158+0x20*5,0,Add,0x970);
						SetCtrig1X("X","X",0x158+0x20*6,0,Add,0x970);
						SetCtrig1X("X","X",0x15C+0x20*0,0,SetTo,0);
						SetCtrig1X("X","X",0x15C+0x20*1,0,SetTo,0);
						SetCtrig1X("X","X",0x15C+0x20*2,0,SetTo,0);
						SetCtrig1X("X","X",0x15C+0x20*3,0,SetTo,0);
						SetCtrig1X("X","X",0x15C+0x20*4,0,SetTo,0);
						SetCtrig1X("X","X",0x15C+0x20*5,0,SetTo,0);
						SetCtrig1X("X","X",0x15C+0x20*6,0,SetTo,0);
					},
					flag = {Preserved}
				}

			FCONVAlloc = FCONVAlloc + 1
			
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FCONVCall2);
				},
				flag = {Preserved}
			}
end
-----------------------------------------------------------
if FBYTECheck == 1 then
	-- 	f_byteCpy - [1] : SourceVA Offset / [2] : Dest / [3] : Size / [4] : DestX

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FBYTECall0);
				},
				flag = {Preserved}
			}

		CMod(IncludePlayer,V(FBYTE[4]),V(FBYTE[2]),4)
		CMov(IncludePlayer,V(FBYTE[2]),V(CRet[1]))
		CiSub(IncludePlayer,V(FBYTE[2]),1452249)

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FBYTECall1);
				},
				flag = {Preserved}
			}

		CIfX(IncludePlayer,CVar("X",FBYTE[4],AtLeast,4))
			CMod(IncludePlayer,V(FBYTE[4]),4)
			CAdd(IncludePlayer,V(FBYTE[2]),V(CRet[1]))
		CIfXEnd()


		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2);
					SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,3);
					SetCtrigX("X","X",0x4,3,SetTo,"X","X",0x0,0,4);
					SetCtrigX("X","X",0x4,4,SetTo,"X","X",0x0,0,5);
					SetCtrig1X("X",FBYTE[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FBYTE[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X("X",FBYTE[2],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FBYTE[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X("X",FBYTEAlloc,0x15C+0x20*6,0,SetTo,0x00000000);
					SetCtrig1X("X",FBYTEAlloc+2,0x15C+0x20*6,0,SetTo,0x00000000);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FBYTE[4],Exactly,0,0x3);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FBYTEAlloc,0x0,0,1);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FBYTE[4],Exactly,1,0x3);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FBYTEAlloc,0x0,0,-4);
					SetMemory(0x6509B0,Add,0x970/4);
					SetCVar("X",FBYTE[1],Add,0x970);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FBYTE[4],Exactly,2,0x3);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FBYTEAlloc,0x0,0,-3);
					SetMemory(0x6509B0,Add,0x970/2);
					SetCVar("X",FBYTE[1],Add,0x970*2);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FBYTE[4],Exactly,3,0x3);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FBYTEAlloc,0x0,0,-2);
					SetMemory(0x6509B0,Add,3*0x970/4);
					SetCVar("X",FBYTE[1],Add,0x970*3);
				},
				flag = {Preserved}
			}


  			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FBYTE[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FBYTE[3],Subtract,1);
					SetCtrig1X("X",FBYTEAlloc,0x15C+0x20*6,0,SetTo,0xFF00,0xFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FBYTE[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FBYTE[3],Subtract,1);
					SetCtrig1X("X",FBYTEAlloc,0x15C+0x20*6,0,SetTo,0xFF0000,0xFF0000);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FBYTE[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FBYTE[3],Subtract,1);
					SetCtrig1X("X",FBYTEAlloc,0x15C+0x20*6,0,SetTo,0xFF000000,0xFF000000);
				},
				flag = {Preserved}
			}

			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FBYTE[1],0x158,0,SetTo,"X","X",0x15C+0x20*0,1,1); 
					SetCtrigX("X",FBYTE[2],0x158,0,SetTo,"X","X",0x15C+0x20*4,1,1); 
					CallLabelAlways2("X",FBYTE[1],0,"X",FBYTE[2],0);
				},
				flag = {Preserved}
			}

			Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(FBYTEAlloc);
				},
				actions = {
					SetCtrig1X("X",FBYTEAlloc,0x4,0,SetTo,0); -- next offset
					SetMemory(0x6509B0,Add,(0x4-0x0)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- next epd
					SetMemory(0x6509B0,Add,(0x158-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,0,0); -- epd
					SetMemory(0x6509B0,Add,(0x148-0x158)/4);
					SetDeaths(CurrentPlayer,SetTo,0x00000000,0); -- Mask
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- type 
					SetMemory(0x6509B0,Add,(0x0-0x160)/4);
					SetCVar("X",FBYTE[2],Add,1);
					SetCVar("X",FBYTE[1],Add,0x970*4);
					SetMemory(0x6509B0,Add,0x970);
				},
				flag = {Preserved}
			}

			FBYTEAlloc = FBYTEAlloc+1

			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FBYTE[1],0x158,0,SetTo,"X",FBYTEAlloc,0x15C+0x20*0,1,0); 
					SetCtrigX("X",FBYTE[2],0x158,0,SetTo,"X",FBYTEAlloc,0x15C+0x20*4,1,0); 
					CallLabelAlways2("X",FBYTE[1],0,"X",FBYTE[2],0);
				},
				flag = {Preserved}
			}

  		CWhile(IncludePlayer,{CVar("X",FBYTE[3],AtLeast,4)},{SetCVar("X",FBYTE[3],Subtract,4)})

			Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(FBYTEAlloc);
				},
				actions = {
					SetCtrig1X("X",FBYTEAlloc,0x4,0,SetTo,0); -- next offset
					SetMemory(0x6509B0,Add,(0x4-0x0)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- next epd
					SetMemory(0x6509B0,Add,(0x158-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,0,0); -- epd
					SetMemory(0x6509B0,Add,(0x148-0x158)/4);
					SetDeaths(CurrentPlayer,SetTo,0xFFFFFFFF,0); -- Mask
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- type 
					SetMemory(0x6509B0,Add,(0x0-0x160)/4);
					SetCVar("X",FBYTE[2],Add,1);
					SetCVar("X",FBYTE[1],Add,0x970*4);
					SetMemory(0x6509B0,Add,0x970);
					SetCtrig1X("X","X",0x15C+0x20*0,0,Add,0x970*4);
					SetCtrig1X("X","X",0x15C+0x20*4,0,Add,1);
				},
				flag = {Preserved}
			}

			FBYTEAlloc = FBYTEAlloc+1

		CWhileEnd()

  			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FBYTE[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FBYTE[3],Subtract,1);
					SetCtrig1X("X",FBYTEAlloc,0x15C+0x20*6,0,SetTo,0xFF,0xFF);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FBYTE[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FBYTE[3],Subtract,1);
					SetCtrig1X("X",FBYTEAlloc,0x15C+0x20*6,0,SetTo,0xFF00,0xFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FBYTE[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FBYTE[3],Subtract,1);
					SetCtrig1X("X",FBYTEAlloc,0x15C+0x20*6,0,SetTo,0xFF0000,0xFF0000);
				},
				flag = {Preserved}
			}

			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FBYTE[1],0x158,0,SetTo,"X",FBYTEAlloc,0x15C+0x20*0,1,0); 
					SetCtrigX("X",FBYTE[2],0x158,0,SetTo,"X",FBYTEAlloc,0x15C+0x20*4,1,0); 
					CallLabelAlways2("X",FBYTE[1],0,"X",FBYTE[2],0);
				},
				flag = {Preserved}
			}

			Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(FBYTEAlloc);
				},
				actions = {
					SetCtrig1X("X",FBYTEAlloc,0x4,0,SetTo,0); -- next offset
					SetMemory(0x6509B0,Add,(0x4-0x0)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- next epd
					SetMemory(0x6509B0,Add,(0x158-0x4)/4);
					SetDeaths(CurrentPlayer,SetTo,0,0); -- epd
					SetMemory(0x6509B0,Add,(0x148-0x158)/4);
					SetDeaths(CurrentPlayer,SetTo,0x00000000,0); -- Mask
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- type 
					SetMemory(0x6509B0,Add,(0x0-0x160)/4);
				},
				flag = {Preserved}
			}
			FBYTEAlloc = FBYTEAlloc+1

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FBYTECall2);
				},
				flag = {Preserved}
			}

end
-----------------------------------------------------------
-- 	f_bytecmp - [1] : SourceVA Offset / [2] : Dest / [3] : Size / [4] : DestX
if FCONDCheck == 1 then
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FCONDCall0);
				},
				flag = {Preserved}
			}

		CMod(IncludePlayer,V(FCOND[4]),V(FCOND[2]),4)
		CMov(IncludePlayer,V(FCOND[2]),V(CRet[1]))
		CiSub(IncludePlayer,V(FCOND[2]),1452249)

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FCONDCall1);
				},
				flag = {Preserved}
			}

		CIf(IncludePlayer,CVar("X",FCOND[4],AtLeast,4))
			CMod(IncludePlayer,V(FCOND[4]),4)
			CAdd(IncludePlayer,V(FCOND[2]),V(CRet[1]))
		CIfEnd()

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2);
					SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,3);
					SetCtrigX("X","X",0x4,3,SetTo,"X","X",0x0,0,4);
					SetCtrigX("X","X",0x4,4,SetTo,"X","X",0x0,0,5);
					SetCtrig1X("X",FCOND[1],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FCOND[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X("X",FCOND[2],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FCOND[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X("X",FCONDAlloc,0x15C+0x20*6,-1,SetTo,0x00000000);
					SetCtrig1X("X",FCONDAlloc+2,0x15C+0x20*6,-1,SetTo,0x00000000);
					SetCtrig1X("X",FCONDAlloc,0x1C,0,SetTo,0x00000000);
					SetCtrig1X("X",FCONDAlloc+2,0x1C,0,SetTo,0x00000000);
					SetCtrig1X("X",FCONDAlloc,0x24,0,SetTo,0x00000000);
					SetCtrig1X("X",FCONDAlloc+2,0x24,0,SetTo,0x00000000);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCOND[4],Exactly,0,0x3);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCONDAlloc,0x0,0,1);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCOND[4],Exactly,1,0x3);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCONDAlloc,0x0,0,-5);
					SetMemory(0x6509B0,Add,0x970/4);
					SetCVar("X",FCOND[1],Add,0x970);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCOND[4],Exactly,2,0x3);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCONDAlloc,0x0,0,-4);
					SetMemory(0x6509B0,Add,0x970/2);
					SetCVar("X",FCOND[1],Add,0x970*2);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCOND[4],Exactly,3,0x3);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCONDAlloc,0x0,0,-3);
					SetMemory(0x6509B0,Add,3*0x970/4);
					SetCVar("X",FCOND[1],Add,0x970*3);
				},
				flag = {Preserved}
			}


  			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCOND[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FCOND[3],Subtract,1);
					SetCtrig1X("X",FCONDAlloc,0x15C+0x20*6,-1,SetTo,0xFF00,0xFF00);
					SetCtrig1X("X",FCONDAlloc,0x1C,0,SetTo,0xFF00,0xFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCOND[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FCOND[3],Subtract,1);
					SetCtrig1X("X",FCONDAlloc,0x15C+0x20*6,-1,SetTo,0xFF0000,0xFF0000);
					SetCtrig1X("X",FCONDAlloc,0x1C,0,SetTo,0xFF0000,0xFF0000);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCOND[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FCOND[3],Subtract,1);
					SetCtrig1X("X",FCONDAlloc,0x15C+0x20*6,-1,SetTo,0xFF000000,0xFF000000);
					SetCtrig1X("X",FCONDAlloc,0x1C,0,SetTo,0xFF000000,0xFF000000);
				},
				flag = {Preserved}
			}

			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FCOND[1],0x158,0,SetTo,"X","X",0x15C+0x20*0,1,1); 
					SetCtrigX("X",FCOND[2],0x158,0,SetTo,"X","X",0x20,1,2); 
					CallLabelAlways2("X",FCOND[1],0,"X",FCOND[2],0);
				},
				flag = {Preserved}
			}

			Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- next offset
					SetMemory(0x6509B0,Add,(0x4-0x0)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- next epd
					SetMemory(0x6509B0,Add,(0x158-0x4)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0x24,1,1); -- epd
					SetMemory(0x6509B0,Add,(0x148-0x158)/4);
					SetDeaths(CurrentPlayer,SetTo,0x00000000,0); -- Mask
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- type 
					SetMemory(0x6509B0,Add,(0x0-0x160)/4);
					SetCVar("X",FCOND[1],Add,0x970*4);
					SetMemory(0x6509B0,Add,0x970);
					SetCtrigX("X","X",0x4,1,SetTo,"X",FCONDAlloc+4,0x0,0,0); 
				},
				flag = {Preserved}
			}

			Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(FCONDAlloc);
					MemoryX(0,Exactly,0,0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1);
					SetCVar("X",FCOND[2],Add,1);
				},
				flag = {Preserved}
			}

			FCONDAlloc = FCONDAlloc+1


			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FCOND[1],0x158,0,SetTo,"X",FCONDAlloc,0x15C+0x20*0,1,-1); 
					SetCtrigX("X",FCOND[2],0x158,0,SetTo,"X",FCONDAlloc,0x20,1,0); 
					CallLabelAlways2("X",FCOND[1],0,"X",FCOND[2],0);
				},
				flag = {Preserved}
			}

  		NWhile(IncludePlayer,{CVar("X",FCOND[3],AtLeast,4)},{SetCVar("X",FCOND[3],Subtract,4)})

			Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- next offset
					SetMemory(0x6509B0,Add,(0x4-0x0)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- next epd
					SetMemory(0x6509B0,Add,(0x158-0x4)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0x24,1,1); -- epd
					SetMemory(0x6509B0,Add,(0x148-0x158)/4);
					SetDeaths(CurrentPlayer,SetTo,0xFFFFFFFF,0); -- Mask
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- type 
					SetMemory(0x6509B0,Add,(0x0-0x160)/4);
					SetCVar("X",FCOND[1],Add,0x970*4);
					SetMemory(0x6509B0,Add,0x970);
					SetCtrig1X("X","X",0x15C+0x20*0,0,Add,0x970*4);
					SetCtrigX("X","X",0x4,1,SetTo,"X",FCONDAlloc+3,0x0,0,0); 
				},
				flag = {Preserved}
			}

			Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(FCONDAlloc);
					MemoryX(0,Exactly,0,0xFFFFFFFF);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1);
					SetCtrig1X("X","X",0x20,0,Add,1);
					SetCVar("X",FCOND[2],Add,1);
				},
				flag = {Preserved}
			}

			FCONDAlloc = FCONDAlloc+1

		NWhileEnd()

			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCOND[3],Exactly,0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCONDAlloc+1,0x0,0,0);
				},
				flag = {Preserved}
			}

  			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCOND[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FCOND[3],Subtract,1);
					SetCtrig1X("X",FCONDAlloc,0x15C+0x20*6,-1,SetTo,0xFF,0xFF);
					SetCtrig1X("X",FCONDAlloc,0x1C,0,SetTo,0xFF,0xFF);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCOND[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FCOND[3],Subtract,1);
					SetCtrig1X("X",FCONDAlloc,0x15C+0x20*6,-1,SetTo,0xFF00,0xFF00);
					SetCtrig1X("X",FCONDAlloc,0x1C,0,SetTo,0xFF00,0xFF00);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCOND[3],AtLeast,1);
				},
				actions = {
					SetCVar("X",FCOND[3],Subtract,1);
					SetCtrig1X("X",FCONDAlloc,0x15C+0x20*6,-1,SetTo,0xFF0000,0xFF0000);
					SetCtrig1X("X",FCONDAlloc,0x1C,0,SetTo,0xFF0000,0xFF0000);
				},
				flag = {Preserved}
			}

			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FCOND[1],0x158,0,SetTo,"X",FCONDAlloc,0x15C+0x20*0,1,-1); 
					SetCtrigX("X",FCOND[2],0x158,0,SetTo,"X",FCONDAlloc,0x20,1,0);
					CallLabelAlways2("X",FCOND[1],0,"X",FCOND[2],0);
				},
				flag = {Preserved}
			}

			Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x4,0,SetTo,0); -- next offset
					SetMemory(0x6509B0,Add,(0x4-0x0)/4);
					SetCtrig2X("Cp",SetTo,"X","X",0,0,1); -- next epd
					SetMemory(0x6509B0,Add,(0x158-0x4)/4);
					SetCtrig2X("Cp",SetTo,"X",FCONDAlloc,0x24,1,0); -- epd
					SetMemory(0x6509B0,Add,(0x148-0x158)/4);
					SetDeaths(CurrentPlayer,SetTo,0x00000000,0); -- Mask
					SetMemory(0x6509B0,Add,(0x160-0x148)/4);
					SetDeathsX(CurrentPlayer,SetTo,SetTo*16777216,0,0xFF000000); -- type 
					SetMemory(0x6509B0,Add,(0x0-0x160)/4);
					SetCtrigX("X",FCONDAlloc,0x4,0,SetTo,"X",FCONDAlloc+2,0x0,0,0); 
				},
				flag = {Preserved}
			}

			Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(FCONDAlloc);
					MemoryX(0,Exactly,0,0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}
			FCONDAlloc = FCONDAlloc+1

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FCONDCall2);
				},
				actions = {
					SetCtrigX("X","X",0x4,-7,SetTo,"X","X",0x0,0,-6);
				},
				flag = {Preserved}
			}

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FCONDCall3);
				},
				flag = {Preserved}
			}
end
-----------------------------------------------------------
-- f_ItoChat - Ret[1] : Size / Ret[2] : Source / Ret[3] : SourceX / Ret[4] : Temp / Ret[5] : Dest / Ret[6] : Count / Ret[7] : Temp2
if FCHATCheck == 1 then
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FCHATAlloc);
				},
				flag = {Preserved}
			}
		FCHATAlloc = FCHATAlloc + 1

		CMod(IncludePlayer,V(FCHAT[3]),V(FCHAT[2]),4)
		CMov(IncludePlayer,V(FCHAT[2]),V(CRet[1]))
		CAdd(IncludePlayer,V(FCHAT[2]),-1452249)

		Trigger {
			players = {IncludePlayer},
			conditions = {
				Label();
			},
			actions = {
				SetCVar("X",FCHAT[7],SetTo,0,15);
				SetCtrig1X("X",FCHAT[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",FCHAT[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",FCHAT[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",FCHAT[2],0);
			},
			flag = {Preserved}
		}

		Trigger {
			players = {IncludePlayer},
			conditions = {
				Label();
				CVar("X",FCHAT[7],Exactly,16,16);
				DeathsX(CurrentPlayer,Exactly,0x0D0D0000,0,0xFFFF0000);
			},
			actions = {
				SetMemory(0x6509B0,Add,1);
				SetCVar("X",FCHAT[3],SetTo,0);
			},
			flag = {Preserved}
		}

		DoActionsX(IncludePlayer,{
			SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,2),
			SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,3),
			SetCtrigX("X","X",0x4,3,SetTo,"X","X",0x0,0,4),
			SetCtrigX("X","X",0x4,4,SetTo,"X","X",0x0,0,5),
			SetCtrigX("X",FCHATAlloc+0,0x4,8,SetTo,"X",FCHATAlloc+4,0x0,0,0);
			SetCtrigX("X",FCHATAlloc+1,0x4,8,SetTo,"X",FCHATAlloc+4,0x0,0,0);
			SetCtrigX("X",FCHATAlloc+2,0x4,8,SetTo,"X",FCHATAlloc+4,0x0,0,0);
			SetCtrigX("X",FCHATAlloc+3,0x4,8,SetTo,"X",FCHATAlloc+4,0x0,0,0);
			})
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label();
					CVar("X",FCHAT[3],Exactly,0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCHATAlloc,0x0,0,0);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label();
					CVar("X",FCHAT[3],Exactly,1);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCHATAlloc+1,0x0,0,0);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label();
					CVar("X",FCHAT[3],Exactly,2);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCHATAlloc+2,0x0,0,0);
				},
				flag = {Preserved}
			}
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label();
					CVar("X",FCHAT[3],Exactly,3);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCHATAlloc+3,0x0,0,0);
				},
				flag = {Preserved}
			}

		DoActionsX(IncludePlayer,SetCVar("X",FCHAT[4],SetTo,0),nil,FCHATAlloc)
		for i = 7, 0, -1 do
			local CBit = 2^i
			local NBit = 2^i*0x01010101
			Trigger { -- SourceX == 0
				players = {IncludePlayer},
				conditions = {
					Label();
					DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCVar("X",FCHAT[4],SetTo,NBit,NBit);
				},
				flag = {Preserved}
			}
		end
		FCHATAlloc = FCHATAlloc+1

		-- Read 1byte
		DoActionsX(IncludePlayer,SetCVar("X",FCHAT[4],SetTo,0),nil,FCHATAlloc)
		for i = 15, 8, -1 do
			local CBit = 2^i
			local NBit = 2^(i-8)*0x01010101
			Trigger { -- SourceX == 1
				players = {IncludePlayer},
				conditions = {
					Label();
					DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCVar("X",FCHAT[4],SetTo,NBit,NBit);
				},
				flag = {Preserved}
			}
		end
		FCHATAlloc = FCHATAlloc+1

		DoActionsX(IncludePlayer,SetCVar("X",FCHAT[4],SetTo,0),nil,FCHATAlloc)
		for i = 23, 16, -1 do
			local CBit = 2^i
			local NBit = 2^(i-16)*0x01010101
			Trigger { -- SourceX == 2
				players = {IncludePlayer},
				conditions = {
					Label();
					DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCVar("X",FCHAT[4],SetTo,NBit,NBit);
				},
				flag = {Preserved}
			}
		end
		FCHATAlloc = FCHATAlloc+1

		DoActionsX(IncludePlayer,SetCVar("X",FCHAT[4],SetTo,0),nil,FCHATAlloc)
		for i = 31, 24, -1 do
			local CBit = 2^i
			local NBit = 2^(i-24)*0x01010101
			Trigger { -- SourceX == 3
				players = {IncludePlayer},
				conditions = {
					Label();
					DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCVar("X",FCHAT[4],SetTo,NBit,NBit);
				},
				flag = {Preserved}
			}
		end
		FCHATAlloc = FCHATAlloc+1
--------------------------------------------------------------------------------------
		-- Convert str -> istr
		Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label(FCHATAlloc);
				},
				flag = {Preserved}
			}
		NIfX(IncludePlayer,CVar("X",FCHAT[4],Exactly,0x0,0xFF)) -- Null -> TapeStop
			Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label();
				},
				actions = {
					SetCtrig1X("X","X",0x164,2,SetTo,0x2,0x2);
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[5],0x0,0,0);
					SetCtrigX("X",FCHAT[5],0x4,0,SetTo,"X","X",0x0,0,1);
					SetCtrig1X("X",FCHAT[5],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FCHAT[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FCHAT[5],0x158,0,SetTo,"X","X",0x158,1,1); 
				},
				flag = {Preserved}
			}
			Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label();
					CVar("X",FCHAT[7],Exactly,32,32);
				},
				actions = {
					SetCtrig1X("X","X",0x164,1,SetTo,0x0,0x2);
					SetCVar("X",FCHAT[6],Add,1);
				},
				flag = {Preserved}
			}
			Trigger { 
				players = {IncludePlayer},
				conditions = {
					Label();
				},
				actions = {
					SetDeathsX(0,SetTo,0x00000000,0,0xFFFFFFFF);
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCHATAlloc+2,0x0,0,0);
				},
				flag = {Preserved}
			}
		NElseIfX(CVar("X",FCHAT[4],Exactly,0xA,0xFF),{SetCVar("X",FCHAT[7],SetTo,0,72)}) -- 0xA Enter
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCHAT[3],Exactly,0);
					DeathsX(CurrentPlayer,Exactly,0x0000,0,0xFF00);
				},
				actions = {
					SetCVar("X",FCHAT[7],SetTo,64,64);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCHAT[3],Exactly,1);
					DeathsX(CurrentPlayer,Exactly,0x000000,0,0xFF0000);
				},
				actions = {
					SetCVar("X",FCHAT[7],SetTo,64,64);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCHAT[3],Exactly,2);
					DeathsX(CurrentPlayer,Exactly,0x00000000,0,0xFF000000);
				},
				actions = {
					SetCVar("X",FCHAT[7],SetTo,64,64);
				},
				flag = {Preserved}
			}
			DoActions(IncludePlayer,SetMemory(0x6509B0,Add,1))
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCHAT[3],Exactly,3);
					DeathsX(CurrentPlayer,Exactly,0x00,0,0xFF);
				},
				actions = {
					SetCVar("X",FCHAT[7],SetTo,64,64);
				},
				flag = {Preserved}
			}
			DoActions(IncludePlayer,SetMemory(0x6509B0,Subtract,1))
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCHAT[1],Exactly,1);
				},
				actions = {
					SetCVar("X",FCHAT[7],SetTo,64,64);
				},
				flag = {Preserved}
			}

			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",FCHAT[5],0x158,0,SetTo,"X","X",0x158,1,1);
					SetCtrig1X("X",FCHAT[5],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FCHAT[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",FCHAT[5],0);
					SetCVar("X",FCHAT[1],Subtract,1);
					SetCVar("X",FCHAT[7],SetTo,0,2);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCHAT[7],Exactly,0,64);
				},
				actions = {
					SetDeaths(0,SetTo,0x0A0D0D0D,0);
					SetCVar("X",FCHAT[5],Add,604);
					SetCVar("X",FCHAT[6],Add,1);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCHAT[7],Exactly,0,2);
					CVar("X",FCHAT[3],Exactly,0);
				},
				actions = {
					SetCVar("X",FCHAT[7],SetTo,2,2);
					SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-3,0x0,0,0);
					SetCVar("X",FCHAT[3],SetTo,1);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCHAT[7],Exactly,0,2);
					CVar("X",FCHAT[3],Exactly,1);
				},
				actions = {
					SetCVar("X",FCHAT[7],SetTo,2,2);
					SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-2,0x0,0,0);
					SetCVar("X",FCHAT[3],SetTo,2);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCHAT[7],Exactly,0,2);
					CVar("X",FCHAT[3],Exactly,2);
				},
				actions = {
					SetCVar("X",FCHAT[7],SetTo,2,2);
					SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-1,0x0,0,0);
					SetCVar("X",FCHAT[3],SetTo,3);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCHAT[7],Exactly,0,2);
					CVar("X",FCHAT[3],Exactly,3);
				},
				actions = {
					SetCVar("X",FCHAT[7],SetTo,2,2);
					SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-4,0x0,0,0);
					SetCVar("X",FCHAT[3],SetTo,0);
					SetMemory(0x6509B0,Add,1);
				},
				flag = {Preserved}
			}
		NElseIfX(CVar("X",FCHAT[4],Exactly,0xD,0xFF)) -- 0xD Blank
			CIfX(IncludePlayer,{CVar("X",FCHAT[3],Exactly,0)},{SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,3),SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,4)})
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,0x0D0D0D00,0,0xFFFFFF00);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[5],0x0,0,0);
						SetCtrigX("X",FCHAT[5],0x4,0,SetTo,"X","X",0x0,0,1);
						SetCtrig1X("X",FCHAT[5],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FCHAT[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",FCHAT[5],0x158,0,SetTo,"X","X",0x158,1,1); 
					},
					flag = {Preserved}
				}
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetDeathsX(0,SetTo,0x0D0D0D0D,0,0xFFFFFFFF);
						SetCVar("X",FCHAT[5],Add,604);
						SetCVar("X",FCHAT[6],Add,1);
						SetCVar("X",FCHAT[1],Subtract,1);
						SetMemory(0x6509B0,Add,1);
						SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-4,0x0,0,0);
					},
					flag = {Preserved}
				}
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetCVar("X",FCHAT[3],SetTo,1);
						SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-3,0x0,0,0);
					},
					flag = {Preserved}
				}
			CElseIfX({CVar("X",FCHAT[3],Exactly,1)},{SetCVar("X",FCHAT[7],SetTo,0,1),SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,4),SetCtrigX("X","X",0x4,3,SetTo,"X","X",0x0,0,6)})
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,0x0D0D0000,0,0xFFFF0000);
					},
					actions = {
						SetCVar("X",FCHAT[7],SetTo,1,1);
						SetMemory(0x6509B0,Add,1);
					},
					flag = {Preserved}
				}
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label();
						CVar("X",FCHAT[7],Exactly,1,1);
						DeathsX(CurrentPlayer,Exactly,0x0D,0,0xFF);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[5],0x0,0,0);
						SetCtrigX("X",FCHAT[5],0x4,0,SetTo,"X","X",0x0,0,1);
						SetCtrig1X("X",FCHAT[5],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FCHAT[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",FCHAT[5],0x158,0,SetTo,"X","X",0x158,1,1); 
					},
					flag = {Preserved}
				}
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetDeathsX(0,SetTo,0x0D0D0D0D,0,0xFFFFFFFF);
						SetCVar("X",FCHAT[5],Add,604);
						SetCVar("X",FCHAT[6],Add,1);
						SetCVar("X",FCHAT[1],Subtract,1);
						SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-3,0x0,0,0);
					},
					flag = {Preserved}
				}
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label();
						CVar("X",FCHAT[7],Exactly,1,1);
					},
					actions = {
						SetMemory(0x6509B0,Add,-1);
					},
					flag = {Preserved}
				}
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetCVar("X",FCHAT[3],SetTo,2);
						SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-2,0x0,0,0);
					},
					flag = {Preserved}
				}
			CElseIfX({CVar("X",FCHAT[3],Exactly,2)},{SetCVar("X",FCHAT[7],SetTo,0,1),SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,4),SetCtrigX("X","X",0x4,3,SetTo,"X","X",0x0,0,6)})
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,0x0D000000,0,0xFF000000);
					},
					actions = {
						SetCVar("X",FCHAT[7],SetTo,1,1);
						SetMemory(0x6509B0,Add,1);
					},
					flag = {Preserved}
				}
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label();
						CVar("X",FCHAT[7],Exactly,1,1);
						DeathsX(CurrentPlayer,Exactly,0x0D0D,0,0xFFFF);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[5],0x0,0,0);
						SetCtrigX("X",FCHAT[5],0x4,0,SetTo,"X","X",0x0,0,1);
						SetCtrig1X("X",FCHAT[5],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FCHAT[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",FCHAT[5],0x158,0,SetTo,"X","X",0x158,1,1); 
					},
					flag = {Preserved}
				}
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetDeathsX(0,SetTo,0x0D0D0D0D,0,0xFFFFFFFF);
						SetCVar("X",FCHAT[5],Add,604);
						SetCVar("X",FCHAT[6],Add,1);
						SetCVar("X",FCHAT[1],Subtract,1);
						SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-2,0x0,0,0);
					},
					flag = {Preserved}
				}
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label();
						CVar("X",FCHAT[7],Exactly,1,1);
					},
					actions = {
						SetMemory(0x6509B0,Add,-1);
					},
					flag = {Preserved}
				}
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetCVar("X",FCHAT[3],SetTo,3);
						SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-1,0x0,0,0);
					},
					flag = {Preserved}
				}
			CElseX({SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,4),SetCtrigX("X","X",0x4,3,SetTo,"X","X",0x0,0,5)})
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetMemory(0x6509B0,Add,1);
					},
					flag = {Preserved}
				}
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,0x0D0D0D,0,0xFFFFFF);
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[5],0x0,0,0);
						SetCtrigX("X",FCHAT[5],0x4,0,SetTo,"X","X",0x0,0,1);
						SetCtrig1X("X",FCHAT[5],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FCHAT[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",FCHAT[5],0x158,0,SetTo,"X","X",0x158,1,1); 
					},
					flag = {Preserved}
				}
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetDeathsX(0,SetTo,0x0D0D0D0D,0,0xFFFFFFFF);
						SetCVar("X",FCHAT[5],Add,604);
						SetCVar("X",FCHAT[6],Add,1);
						SetCVar("X",FCHAT[1],Subtract,1);
						SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-1,0x0,0,0);
					},
					flag = {Preserved}
				}
				Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetCVar("X",FCHAT[3],SetTo,0);
						SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-4,0x0,0,0);
					},
					flag = {Preserved}
				}
			CIfXEnd()
		NElseIfX({_TP(_TOR(_TB(_TC(CVar("X",FCHAT[4],AtLeast,0x1,0xFF)),_TC(CVar("X",FCHAT[4],AtMost,0x8,0xFF))),_TB(_TC(CVar("X",FCHAT[4],AtLeast,0xE,0xFF)),_TC(CVar("X",FCHAT[4],AtMost,0x11,0xFF))),_TB(_TC(CVar("X",FCHAT[4],AtLeast,0x14,0xFF)),_TC(CVar("X",FCHAT[4],AtMost,0x1F,0xFF))) ))}) -- ColorCode
			CIfX(IncludePlayer,{CVar("X",FCHAT[7],Exactly,8,8)})
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",FCHAT[4],0x158,0,SetTo,"X",CAPrintVarAlloc,0x15C,1,0);
						SetCtrig1X("X",FCHAT[4],0x148,0,SetTo,0x000000FF);
						SetCtrig1X("X",FCHAT[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[4],0x0,0,0);
						SetCtrigX("X",FCHAT[4],0x4,0,SetTo,"X","X",0x0,0,1);
						SetCVar("X",FCHAT[7],SetTo,0,2);
					},
					flag = {Preserved}
				}

				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
						CVar("X",FCHAT[7],Exactly,0,2);
						CVar("X",FCHAT[3],Exactly,0);
					},
					actions = {
						SetCVar("X",FCHAT[7],SetTo,14,14);
						SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-3,0x0,0,0);
						SetCVar("X",FCHAT[3],SetTo,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
						CVar("X",FCHAT[7],Exactly,0,2);
						CVar("X",FCHAT[3],Exactly,1);
					},
					actions = {
						SetCVar("X",FCHAT[7],SetTo,14,14);
						SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-2,0x0,0,0);
						SetCVar("X",FCHAT[3],SetTo,2);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
						CVar("X",FCHAT[7],Exactly,0,2);
						CVar("X",FCHAT[3],Exactly,2);
					},
					actions = {
						SetCVar("X",FCHAT[7],SetTo,14,14);
						SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-1,0x0,0,0);
						SetCVar("X",FCHAT[3],SetTo,3);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
						CVar("X",FCHAT[7],Exactly,0,2);
						CVar("X",FCHAT[3],Exactly,3);
					},
					actions = {
						SetCVar("X",FCHAT[7],SetTo,14,14);
						SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-4,0x0,0,0);
						SetCVar("X",FCHAT[3],SetTo,0);
						SetMemory(0x6509B0,Add,1);
					},
					flag = {Preserved}
				}
			CElseX()
				CIfX(IncludePlayer,{CVar("X",FCHAT[3],Exactly,0)},{SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,3),SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,4)})
					Trigger { 
						players = {IncludePlayer},
						conditions = {
							Label();
							DeathsX(CurrentPlayer,Exactly,0x0D0D0D00,0,0xFFFFFF00);
						},
						actions = {
							SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[5],0x0,0,0);
							SetCtrigX("X",FCHAT[5],0x4,0,SetTo,"X",FCHAT[4],0x0,0,0);
							SetCtrigX("X",FCHAT[4],0x4,0,SetTo,"X","X",0x0,0,1);
							SetCtrig1X("X",FCHAT[5],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FCHAT[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",FCHAT[5],0x158,0,SetTo,"X","X",0x158,1,1); 
							SetCtrig1X("X",FCHAT[4],0x148,0,SetTo,0xFF);
							SetCtrig1X("X",FCHAT[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",FCHAT[4],0x158,0,SetTo,"X","X",0x15C,1,1); 
						},
						flag = {Preserved}
					}
					Trigger { 
						players = {IncludePlayer},
						conditions = {
							Label();
						},
						actions = {
							SetDeathsX(0,SetTo,0x0D0D0D00,0,0xFFFFFFFF);
							SetCVar("X",FCHAT[7],SetTo,0,12);
							SetCVar("X",FCHAT[5],Add,604);
							SetCVar("X",FCHAT[6],Add,1);
							SetCVar("X",FCHAT[1],Subtract,1);
							SetMemory(0x6509B0,Add,1);
							SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-4,0x0,0,0);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {IncludePlayer},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",FCHAT[5],0x158,0,SetTo,"X",CAPrintVarAlloc,0x158,1,0);
							SetCtrig1X("X",FCHAT[5],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FCHAT[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",FCHAT[4],0x158,0,SetTo,"X",CAPrintVarAlloc,0x15C,1,0);
							SetCtrig1X("X",FCHAT[4],0x148,0,SetTo,0x000000FF);
							SetCtrig1X("X",FCHAT[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							
							SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[4],0x0,0,0);
							SetCtrigX("X",FCHAT[4],0x4,0,SetTo,"X",FCHAT[5],0x0,0,0);
							SetCtrigX("X",FCHAT[5],0x4,0,SetTo,"X","X",0x0,0,1);

							SetCVar("X",FCHAT[7],SetTo,12,12);
							SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-3,0x0,0,0);
							SetCVar("X",FCHAT[3],SetTo,1);
						},
						flag = {Preserved}
					}
				CElseIfX({CVar("X",FCHAT[3],Exactly,1)},{SetCVar("X",FCHAT[7],SetTo,0,1),SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,4),SetCtrigX("X","X",0x4,3,SetTo,"X","X",0x0,0,6)})
					Trigger { 
						players = {IncludePlayer},
						conditions = {
							Label();
							DeathsX(CurrentPlayer,Exactly,0x0D0D0000,0,0xFFFF0000);
						},
						actions = {
							SetCVar("X",FCHAT[7],SetTo,1,1);
							SetMemory(0x6509B0,Add,1);
						},
						flag = {Preserved}
					}
					Trigger { 
						players = {IncludePlayer},
						conditions = {
							Label();
							CVar("X",FCHAT[7],Exactly,1,1);
							DeathsX(CurrentPlayer,Exactly,0x0D,0,0xFF);
						},
						actions = {
							SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[5],0x0,0,0);
							SetCtrigX("X",FCHAT[5],0x4,0,SetTo,"X",FCHAT[4],0x0,0,0);
							SetCtrigX("X",FCHAT[4],0x4,0,SetTo,"X","X",0x0,0,1);
							SetCtrig1X("X",FCHAT[5],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FCHAT[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",FCHAT[5],0x158,0,SetTo,"X","X",0x158,1,1); 
							SetCtrig1X("X",FCHAT[4],0x148,0,SetTo,0xFF);
							SetCtrig1X("X",FCHAT[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",FCHAT[4],0x158,0,SetTo,"X","X",0x15C,1,1); 
						},
						flag = {Preserved}
					}
					Trigger { 
						players = {IncludePlayer},
						conditions = {
							Label();
						},
						actions = {
							SetDeathsX(0,SetTo,0x0D0D0D00,0,0xFFFFFFFF);
							SetCVar("X",FCHAT[7],SetTo,0,12);
							SetCVar("X",FCHAT[5],Add,604);
							SetCVar("X",FCHAT[6],Add,1);
							SetCVar("X",FCHAT[1],Subtract,1);
							SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-3,0x0,0,0);
						},
						flag = {Preserved}
					}
					Trigger { 
						players = {IncludePlayer},
						conditions = {
							Label();
							CVar("X",FCHAT[7],Exactly,1,1);
						},
						actions = {
							SetMemory(0x6509B0,Add,-1);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {IncludePlayer},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",FCHAT[5],0x158,0,SetTo,"X",CAPrintVarAlloc,0x158,1,0);
							SetCtrig1X("X",FCHAT[5],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FCHAT[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",FCHAT[4],0x158,0,SetTo,"X",CAPrintVarAlloc,0x15C,1,0);
							SetCtrig1X("X",FCHAT[4],0x148,0,SetTo,0x000000FF);
							SetCtrig1X("X",FCHAT[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							
							SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[4],0x0,0,0);
							SetCtrigX("X",FCHAT[4],0x4,0,SetTo,"X",FCHAT[5],0x0,0,0);
							SetCtrigX("X",FCHAT[5],0x4,0,SetTo,"X","X",0x0,0,1);

							SetCVar("X",FCHAT[7],SetTo,12,12);
							SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-2,0x0,0,0);
							SetCVar("X",FCHAT[3],SetTo,2);
						},
						flag = {Preserved}
					}
				CElseIfX({CVar("X",FCHAT[3],Exactly,2)},{SetCVar("X",FCHAT[7],SetTo,0,1),SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,4),SetCtrigX("X","X",0x4,3,SetTo,"X","X",0x0,0,6)})
					Trigger { 
						players = {IncludePlayer},
						conditions = {
							Label();
							DeathsX(CurrentPlayer,Exactly,0x0D000000,0,0xFF000000);
						},
						actions = {
							SetCVar("X",FCHAT[7],SetTo,1,1);
							SetMemory(0x6509B0,Add,1);
						},
						flag = {Preserved}
					}
					Trigger { 
						players = {IncludePlayer},
						conditions = {
							Label();
							CVar("X",FCHAT[7],Exactly,1,1);
							DeathsX(CurrentPlayer,Exactly,0x0D0D,0,0xFFFF);
						},
						actions = {
							SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[5],0x0,0,0);
							SetCtrigX("X",FCHAT[5],0x4,0,SetTo,"X",FCHAT[4],0x0,0,0);
							SetCtrigX("X",FCHAT[4],0x4,0,SetTo,"X","X",0x0,0,1);
							SetCtrig1X("X",FCHAT[5],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FCHAT[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",FCHAT[5],0x158,0,SetTo,"X","X",0x158,1,1); 
							SetCtrig1X("X",FCHAT[4],0x148,0,SetTo,0xFF);
							SetCtrig1X("X",FCHAT[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",FCHAT[4],0x158,0,SetTo,"X","X",0x15C,1,1); 
						},
						flag = {Preserved}
					}
					Trigger { 
						players = {IncludePlayer},
						conditions = {
							Label();
						},
						actions = {
							SetDeathsX(0,SetTo,0x0D0D0D00,0,0xFFFFFFFF);
							SetCVar("X",FCHAT[7],SetTo,0,12);
							SetCVar("X",FCHAT[5],Add,604);
							SetCVar("X",FCHAT[6],Add,1);
							SetCVar("X",FCHAT[1],Subtract,1);
							SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-2,0x0,0,0);
						},
						flag = {Preserved}
					}
					Trigger { 
						players = {IncludePlayer},
						conditions = {
							Label();
							CVar("X",FCHAT[7],Exactly,1,1);
						},
						actions = {
							SetMemory(0x6509B0,Add,-1);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {IncludePlayer},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",FCHAT[5],0x158,0,SetTo,"X",CAPrintVarAlloc,0x158,1,0);
							SetCtrig1X("X",FCHAT[5],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FCHAT[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",FCHAT[4],0x158,0,SetTo,"X",CAPrintVarAlloc,0x15C,1,0);
							SetCtrig1X("X",FCHAT[4],0x148,0,SetTo,0x000000FF);
							SetCtrig1X("X",FCHAT[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							
							SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[4],0x0,0,0);
							SetCtrigX("X",FCHAT[4],0x4,0,SetTo,"X",FCHAT[5],0x0,0,0);
							SetCtrigX("X",FCHAT[5],0x4,0,SetTo,"X","X",0x0,0,1);

							SetCVar("X",FCHAT[7],SetTo,12,12);
							SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-1,0x0,0,0);
							SetCVar("X",FCHAT[3],SetTo,3);
						},
						flag = {Preserved}
					}
				CElseX({SetCtrigX("X","X",0x4,2,SetTo,"X","X",0x0,0,4),SetCtrigX("X","X",0x4,3,SetTo,"X","X",0x0,0,5)})
					Trigger { 
						players = {IncludePlayer},
						conditions = {
							Label();
						},
						actions = {
							SetMemory(0x6509B0,Add,1);
						},
						flag = {Preserved}
					}
					Trigger { 
						players = {IncludePlayer},
						conditions = {
							Label();
							DeathsX(CurrentPlayer,Exactly,0x0D0D0D,0,0xFFFFFF);
						},
						actions = {
							SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[5],0x0,0,0);
							SetCtrigX("X",FCHAT[5],0x4,0,SetTo,"X",FCHAT[4],0x0,0,0);
							SetCtrigX("X",FCHAT[4],0x4,0,SetTo,"X","X",0x0,0,1);
							SetCtrig1X("X",FCHAT[5],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FCHAT[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",FCHAT[5],0x158,0,SetTo,"X","X",0x158,1,1); 
							SetCtrig1X("X",FCHAT[4],0x148,0,SetTo,0xFF);
							SetCtrig1X("X",FCHAT[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",FCHAT[4],0x158,0,SetTo,"X","X",0x15C,1,1); 
						},
						flag = {Preserved}
					}
					Trigger { 
						players = {IncludePlayer},
						conditions = {
							Label();
						},
						actions = {
							SetDeathsX(0,SetTo,0x0D0D0D00,0,0xFFFFFFFF);
							SetCVar("X",FCHAT[7],SetTo,0,12);
							SetCVar("X",FCHAT[5],Add,604);
							SetCVar("X",FCHAT[6],Add,1);
							SetCVar("X",FCHAT[1],Subtract,1);
							SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-1,0x0,0,0);
						},
						flag = {Preserved}
					}
					Trigger {
						players = {IncludePlayer},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X",FCHAT[5],0x158,0,SetTo,"X",CAPrintVarAlloc,0x158,1,0);
							SetCtrig1X("X",FCHAT[5],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FCHAT[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",FCHAT[4],0x158,0,SetTo,"X",CAPrintVarAlloc,0x15C,1,0);
							SetCtrig1X("X",FCHAT[4],0x148,0,SetTo,0x000000FF);
							SetCtrig1X("X",FCHAT[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							
							SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[4],0x0,0,0);
							SetCtrigX("X",FCHAT[4],0x4,0,SetTo,"X",FCHAT[5],0x0,0,0);
							SetCtrigX("X",FCHAT[5],0x4,0,SetTo,"X","X",0x0,0,1);

							SetCVar("X",FCHAT[7],SetTo,12,12);
							SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-4,0x0,0,0);
							SetCVar("X",FCHAT[3],SetTo,0);
						},
						flag = {Preserved}
					}
				CIfXEnd()
			CIfXEnd()			
		NElseIfX({CVar("X",FCHAT[4],AtMost,0x7F,0xFF)},{SetCVar("X",FCHAT[7],SetTo,0,8)}) -- 1byte
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x15C,1,SetTo,0x0D0D0D0D);
					SetCtrigX("X",FCHAT[5],0x158,0,SetTo,"X","X",0x158,1,1);
					SetCtrig1X("X",FCHAT[5],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FCHAT[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",FCHAT[4],0x158,0,SetTo,"X","X",0x15C,1,1);
					SetCtrig1X("X",FCHAT[4],0x148,0,SetTo,0xFF000000);
					SetCtrig1X("X",FCHAT[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways2("X",FCHAT[5],0,"X",FCHAT[4],0);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetDeaths(0,SetTo,0,0);
					SetCVar("X",FCHAT[5],Add,604);
					SetCVar("X",FCHAT[6],Add,1);
					SetCVar("X",FCHAT[1],Subtract,1);
					SetCVar("X",FCHAT[7],SetTo,0,2);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCHAT[7],Exactly,0,2);
					CVar("X",FCHAT[3],Exactly,0);
				},
				actions = {
					SetCVar("X",FCHAT[7],SetTo,2,2);
					SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-3,0x0,0,0);
					SetCVar("X",FCHAT[3],SetTo,1);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCHAT[7],Exactly,0,2);
					CVar("X",FCHAT[3],Exactly,1);
				},
				actions = {
					SetCVar("X",FCHAT[7],SetTo,2,2);
					SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-2,0x0,0,0);
					SetCVar("X",FCHAT[3],SetTo,2);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCHAT[7],Exactly,0,2);
					CVar("X",FCHAT[3],Exactly,2);
				},
				actions = {
					SetCVar("X",FCHAT[7],SetTo,2,2);
					SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-1,0x0,0,0);
					SetCVar("X",FCHAT[3],SetTo,3);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CVar("X",FCHAT[7],Exactly,0,2);
					CVar("X",FCHAT[3],Exactly,3);
				},
				actions = {
					SetCVar("X",FCHAT[7],SetTo,2,2);
					SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-4,0x0,0,0);
					SetCVar("X",FCHAT[3],SetTo,0);
					SetMemory(0x6509B0,Add,1);
				},
				flag = {Preserved}
			}
		NElseX({SetCVar("X",FCHAT[7],SetTo,0,8)}) -- 3bytes
			CIfX(IncludePlayer,{CVar("X",FCHAT[3],Exactly,0)})
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x15C,3,SetTo,0x0D0D0D0D);
						SetCtrigX("X",FCHAT[5],0x158,0,SetTo,"X","X",0x158,1,3);
						SetCtrig1X("X",FCHAT[5],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FCHAT[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",FCHAT[4],0x158,0,SetTo,"X","X",0x15C,1,3);
						SetCtrig1X("X",FCHAT[4],0x148,0,SetTo,0x0000FF00);
						SetCtrig1X("X",FCHAT[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);

						SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[4],0x0,0,0);
						SetCtrigX("X",FCHAT[4],0x4,0,SetTo,"X",FCHAT[5],0x0,0,0);
						SetCtrigX("X",FCHAT[5],0x4,0,SetTo,"X",FCHATAlloc-3,0x0,0,0);
						SetCtrigX("X",FCHATAlloc-3,0x4,8,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",FCHATAlloc-3,0x4,8,SetTo,"X",FCHATAlloc,0x0,0,0);
						SetCtrigX("X",FCHAT[4],0x158,0,SetTo,"X","X",0x15C,1,2);
						SetCtrig1X("X",FCHAT[4],0x148,0,SetTo,0x00FF0000);
						SetCtrig1X("X",FCHAT[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[4],0x0,0,0);
						SetCtrigX("X",FCHAT[4],0x4,0,SetTo,"X",FCHATAlloc-2,0x0,0,0);
						SetCtrigX("X",FCHATAlloc-2,0x4,8,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",FCHATAlloc-2,0x4,8,SetTo,"X",FCHATAlloc,0x0,0,0);
						SetCtrigX("X",FCHAT[4],0x158,0,SetTo,"X","X",0x15C,1,1);
						SetCtrig1X("X",FCHAT[4],0x148,0,SetTo,0xFF000000);
						SetCtrig1X("X",FCHAT[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[4],0x0,0,0);
						SetCtrigX("X",FCHAT[4],0x4,0,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeaths(0,SetTo,0,0);
						SetCVar("X",FCHAT[5],Add,604);
						SetCVar("X",FCHAT[1],Subtract,1);
						SetCVar("X",FCHAT[6],Add,1);
						SetCVar("X",FCHAT[3],SetTo,3);
						SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-1,0x0,0,0);
					},
					flag = {Preserved}
				}
			CElseIfX({CVar("X",FCHAT[3],Exactly,1)})
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x15C,3,SetTo,0x0D0D0D0D);
						SetCtrigX("X",FCHAT[5],0x158,0,SetTo,"X","X",0x158,1,3);
						SetCtrig1X("X",FCHAT[5],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FCHAT[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",FCHAT[4],0x158,0,SetTo,"X","X",0x15C,1,3);
						SetCtrig1X("X",FCHAT[4],0x148,0,SetTo,0x0000FF00);
						SetCtrig1X("X",FCHAT[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[4],0x0,0,0);
						SetCtrigX("X",FCHAT[4],0x4,0,SetTo,"X",FCHAT[5],0x0,0,0);
						SetCtrigX("X",FCHAT[5],0x4,0,SetTo,"X",FCHATAlloc-2,0x0,0,0);
						SetCtrigX("X",FCHATAlloc-2,0x4,8,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",FCHATAlloc-2,0x4,8,SetTo,"X",FCHATAlloc,0x0,0,0);
						SetCtrigX("X",FCHAT[4],0x158,0,SetTo,"X","X",0x15C,1,2);
						SetCtrig1X("X",FCHAT[4],0x148,0,SetTo,0x00FF0000);
						SetCtrig1X("X",FCHAT[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[4],0x0,0,0);
						SetCtrigX("X",FCHAT[4],0x4,0,SetTo,"X",FCHATAlloc-1,0x0,0,0);
						SetCtrigX("X",FCHATAlloc-1,0x4,8,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",FCHATAlloc-1,0x4,8,SetTo,"X",FCHATAlloc,0x0,0,0);
						SetCtrigX("X",FCHAT[4],0x158,0,SetTo,"X","X",0x15C,1,1);
						SetCtrig1X("X",FCHAT[4],0x148,0,SetTo,0xFF000000);
						SetCtrig1X("X",FCHAT[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[4],0x0,0,0);
						SetCtrigX("X",FCHAT[4],0x4,0,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeaths(0,SetTo,0,0);
						SetCVar("X",FCHAT[5],Add,604);
						SetCVar("X",FCHAT[1],Subtract,1);
						SetCVar("X",FCHAT[6],Add,1);
						SetMemory(0x6509B0,Add,1);
						SetCVar("X",FCHAT[3],SetTo,0);
						SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-4,0x0,0,0);
					},
					flag = {Preserved}
				}
			CElseIfX({CVar("X",FCHAT[3],Exactly,2)})
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x15C,3,SetTo,0x0D0D0D0D);
						SetCtrigX("X",FCHAT[5],0x158,0,SetTo,"X","X",0x158,1,3);
						SetCtrig1X("X",FCHAT[5],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FCHAT[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",FCHAT[4],0x158,0,SetTo,"X","X",0x15C,1,3);
						SetCtrig1X("X",FCHAT[4],0x148,0,SetTo,0x0000FF00);
						SetCtrig1X("X",FCHAT[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[4],0x0,0,0);
						SetCtrigX("X",FCHAT[4],0x4,0,SetTo,"X",FCHAT[5],0x0,0,0);
						SetCtrigX("X",FCHAT[5],0x4,0,SetTo,"X",FCHATAlloc-1,0x0,0,0);
						SetCtrigX("X",FCHATAlloc-1,0x4,8,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",FCHATAlloc-1,0x4,8,SetTo,"X",FCHATAlloc,0x0,0,0);
						SetCtrigX("X",FCHAT[4],0x158,0,SetTo,"X","X",0x15C,1,2);
						SetCtrig1X("X",FCHAT[4],0x148,0,SetTo,0x00FF0000);
						SetCtrig1X("X",FCHAT[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,1);
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[4],0x0,0,0);
						SetCtrigX("X",FCHAT[4],0x4,0,SetTo,"X",FCHATAlloc-4,0x0,0,0);
						SetCtrigX("X",FCHATAlloc-4,0x4,8,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",FCHATAlloc-4,0x4,8,SetTo,"X",FCHATAlloc,0x0,0,0);
						SetCtrigX("X",FCHAT[4],0x158,0,SetTo,"X","X",0x15C,1,1);
						SetCtrig1X("X",FCHAT[4],0x148,0,SetTo,0xFF000000);
						SetCtrig1X("X",FCHAT[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[4],0x0,0,0);
						SetCtrigX("X",FCHAT[4],0x4,0,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeaths(0,SetTo,0,0);
						SetCVar("X",FCHAT[5],Add,604);
						SetCVar("X",FCHAT[1],Subtract,1);
						SetCVar("X",FCHAT[6],Add,1);
						SetCVar("X",FCHAT[3],SetTo,1);
						SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-3,0x0,0,0);
					},
					flag = {Preserved}
				}
			CElseX()
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X","X",0x15C,3,SetTo,0x0D0D0D0D);
						SetCtrigX("X",FCHAT[5],0x158,0,SetTo,"X","X",0x158,1,3);
						SetCtrig1X("X",FCHAT[5],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FCHAT[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrigX("X",FCHAT[4],0x158,0,SetTo,"X","X",0x15C,1,3);
						SetCtrig1X("X",FCHAT[4],0x148,0,SetTo,0x0000FF00);
						SetCtrig1X("X",FCHAT[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetMemory(0x6509B0,Add,1);
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[4],0x0,0,0);
						SetCtrigX("X",FCHAT[4],0x4,0,SetTo,"X",FCHAT[5],0x0,0,0);
						SetCtrigX("X",FCHAT[5],0x4,0,SetTo,"X",FCHATAlloc-4,0x0,0,0);
						SetCtrigX("X",FCHATAlloc-4,0x4,8,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",FCHATAlloc-4,0x4,8,SetTo,"X",FCHATAlloc,0x0,0,0);
						SetCtrigX("X",FCHAT[4],0x158,0,SetTo,"X","X",0x15C,1,2);
						SetCtrig1X("X",FCHAT[4],0x148,0,SetTo,0x00FF0000);
						SetCtrig1X("X",FCHAT[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[4],0x0,0,0);
						SetCtrigX("X",FCHAT[4],0x4,0,SetTo,"X",FCHATAlloc-3,0x0,0,0);
						SetCtrigX("X",FCHATAlloc-3,0x4,8,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",FCHATAlloc-3,0x4,8,SetTo,"X",FCHATAlloc,0x0,0,0);
						SetCtrigX("X",FCHAT[4],0x158,0,SetTo,"X","X",0x15C,1,1);
						SetCtrig1X("X",FCHAT[4],0x148,0,SetTo,0xFF000000);
						SetCtrig1X("X",FCHAT[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						
						SetCtrigX("X","X",0x4,0,SetTo,"X",FCHAT[4],0x0,0,0);
						SetCtrigX("X",FCHAT[4],0x4,0,SetTo,"X","X",0x0,0,1);
					},
					flag = {Preserved}
				}
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetDeaths(0,SetTo,0,0);
						SetCVar("X",FCHAT[5],Add,604);
						SetCVar("X",FCHAT[1],Subtract,1);
						SetCVar("X",FCHAT[6],Add,1);
						SetCVar("X",FCHAT[3],SetTo,2);
						SetCtrigX("X",FCHATAlloc+1,0x4,0,SetTo,"X",FCHATAlloc-2,0x0,0,0);
					},
					flag = {Preserved}
				}
			CIfXEnd()
		NIfXEnd()

		CIf(IncludePlayer,{CVar("X",FCHAT[7],Exactly,4,4),CVar("X",FCHAT[7],Exactly,0,8)},SetCVar("X",FCHAT[7],SetTo,0,4)) -- write ColorCode
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(CAPrintVarAlloc);
				},
				actions = {
					SetDeathsX(0,SetTo,0,0,0xFF);
				},
				flag = {Preserved}
			}
			CAPrintVarAlloc = CAPrintVarAlloc+1
		CIfEnd()

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FCHATAlloc+1);
					CVar("X",FCHAT[1],Exactly,0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FCHATAlloc+2,0x0,0,0);
				},
				flag = {Preserved}
			}
		FCHATAlloc = FCHATAlloc+2
----------------------------------------------------------------------------------
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FCHATAlloc);
				},
				flag = {Preserved}
			}
		FCHATAlloc = FCHATAlloc + 1
end
-----------------------------------------------------------
if FBWZCheck == 1 then
-- f_BwriteZ - Ret[1] : Input Value / Ret[2] = Output / Ret[3] = Offset
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FBWZCall1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	CIfX(IncludePlayer,{CVar("X",CRet[3],Exactly,1,0x3)})
		for i = 7, 0, -1 do
			local CBit = 2^i
			local NBit = CBit*256
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label();
					CVar("X",CRet[1],Exactly,CBit,CBit);
				},
				actions = {
					SetCVar("X",CRet[2],SetTo,NBit,NBit);
				},
				flag = {Preserved}
			}
		end
	CElseIfX(CVar("X",CRet[3],Exactly,2,0x3))
		for i = 7, 0, -1 do
			local CBit = 2^i
			local NBit = CBit*65536
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label();
					CVar("X",CRet[1],Exactly,CBit,CBit);
				},
				actions = {
					SetCVar("X",CRet[2],SetTo,NBit,NBit);
				},
				flag = {Preserved}
			}
		end
	CElseIfX(CVar("X",CRet[3],Exactly,3,0x3))
		for i = 7, 0, -1 do
			local CBit = 2^i
			local NBit = CBit*16777216
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label();
					CVar("X",CRet[1],Exactly,CBit,CBit);
				},
				actions = {
					SetCVar("X",CRet[2],SetTo,NBit,NBit);
				},
				flag = {Preserved}
			}
		end
	CElseX()
		Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[2],0x15C,1,0);
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}
	CIfXEnd()

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FBWZCall2);
			},
			actions = {
			},
			flag = {Preserved}
		}
end
-----------------------------------------------------------
if FBWXCheck == 1 then
	-- f_BwriteX - Ret[1] : Input Offset / Ret[2] = Value / Ret[3] = EPD / Ret[4] = Value / Ret[5] = Mask
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FBWXCall1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	for i = 31, 2, -1 do
			local CBit = 2^i
			local NBit = CBit/4
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label();
					CVar("X",CRet[1],Exactly,CBit,CBit);
				},
				actions = {
					SetCVar("X",CRet[3],Add,NBit);
				},
				flag = {Preserved}
			}
	end

	CIfX(IncludePlayer,{CVar("X",CRet[1],Exactly,1,0x3)},SetCVar("X",CRet[5],SetTo,0xFF00))
		for i = 7, 0, -1 do
			local CBit = 2^i
			local NBit = CBit*256
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label();
					CVar("X",CRet[2],Exactly,CBit,CBit);
				},
				actions = {
					SetCVar("X",CRet[4],SetTo,NBit,NBit);
				},
				flag = {Preserved}
			}
		end
	CElseIfX(CVar("X",CRet[1],Exactly,2,0x3),SetCVar("X",CRet[5],SetTo,0xFF0000))
		for i = 7, 0, -1 do
			local CBit = 2^i
			local NBit = CBit*65536
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label();
					CVar("X",CRet[2],Exactly,CBit,CBit);
				},
				actions = {
					SetCVar("X",CRet[4],SetTo,NBit,NBit);
				},
				flag = {Preserved}
			}
		end
	CElseIfX(CVar("X",CRet[1],Exactly,3,0x3),SetCVar("X",CRet[5],SetTo,0xFF000000))
		for i = 7, 0, -1 do
			local CBit = 2^i
			local NBit = CBit*16777216
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label();
					CVar("X",CRet[2],Exactly,CBit,CBit);
				},
				actions = {
					SetCVar("X",CRet[4],SetTo,NBit,NBit);
				},
				flag = {Preserved}
			}
		end
	CElseX(SetCVar("X",CRet[5],SetTo,0xFF))
		Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",CRet[2],0x158,0,SetTo,"X",CRet[4],0x15C,1,0);
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}
	CIfXEnd()

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FBWXCall2);
			},
			actions = {
			},
			flag = {Preserved}
		}
end
-----------------------------------------------------------
-- f_WwriteZ - Ret[1] : Input Value / Ret[2] = Output / Ret[3] = Offset
if FWWZCheck == 1 then
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FWWZCall1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	CIfX(IncludePlayer,{CVar("X",CRet[3],Exactly,2,0x3)})
		for i = 15, 0, -1 do
			local CBit = 2^i
			local NBit = CBit*65536
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label();
					CVar("X",CRet[1],Exactly,CBit,CBit);
				},
				actions = {
					SetCVar("X",CRet[2],SetTo,NBit,NBit);
				},
				flag = {Preserved}
			}
		end
	CElseX()
		Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[2],0x15C,1,0);
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}
	CIfXEnd()

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FWWZCall2);
			},
			actions = {
			},
			flag = {Preserved}
		}
end
-----------------------------------------------------------
-- f_WwriteX - Ret[1] : Input Offset / Ret[2] = Value / Ret[3] = EPD / Ret[4] = Value / Ret[5] = Mask
if FWWXCheck == 1 then
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FWWXCall0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",CRet[1],0x0,0,0);
				SetCtrigX("X",CRet[1],0x4,0,SetTo,"X","X",0x0,0,24);
				SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
			},
			flag = {Preserved}
		}
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FWWXCall1);
			},
			flag = {Preserved}
		}

	for i = 31, 2, -1 do
			local CBit = 2^i
			local NBit = CBit/4
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label();
					CVar("X",CRet[1],Exactly,CBit,CBit);
				},
				actions = {
					SetCVar("X",CRet[3],Add,NBit);
				},
				flag = {Preserved}
			}
	end

	CIfX(IncludePlayer,{CVar("X",CRet[1],Exactly,2,0x3)},SetCVar("X",CRet[5],SetTo,0xFFFF0000))
		for i = 15, 0, -1 do
			local CBit = 2^i
			local NBit = CBit*65536
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label();
					CVar("X",CRet[2],Exactly,CBit,CBit);
				},
				actions = {
					SetCVar("X",CRet[4],SetTo,NBit,NBit);
				},
				flag = {Preserved}
			}
		end
	CElseX(SetCVar("X",CRet[5],SetTo,0xFFFF))
		Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrigX("X",CRet[2],0x158,0,SetTo,"X",CRet[4],0x15C,1,0);
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}
	CIfXEnd()

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FWWXCall2);
			},
			actions = {
			},
			flag = {Preserved}
		}
end
if FBRZCheck == 1 then
-- f_BreadZ - Ret[1] : Input Value / Ret[2] = Output / Ret[3] = Offset
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FBRZCall1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	CIfX(IncludePlayer,{CVar("X",CRet[3],Exactly,1,0x3)})
		CIfX(IncludePlayer,{CVar("X",CRet[4],Exactly,1)})
			for i = 15, 8, -1 do
				local CBit = 2^i
				local NBit = CBit
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[2],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseIfX(CVar("X",CRet[4],Exactly,2))
			for i = 15, 8, -1 do
				local CBit = 2^i
				local NBit = CBit*256
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[2],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseIfX(CVar("X",CRet[4],Exactly,3))
			for i = 15, 8, -1 do
				local CBit = 2^i
				local NBit = CBit*65536
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[2],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseX()
			for i = 15, 8, -1 do
				local CBit = 2^i
				local NBit = CBit/256
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[2],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CIfXEnd()
	CElseIfX(CVar("X",CRet[3],Exactly,2,0x3))
		CIfX(IncludePlayer,{CVar("X",CRet[4],Exactly,1)})
			for i = 23, 16, -1 do
				local CBit = 2^i
				local NBit = CBit/256
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[2],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseIfX(CVar("X",CRet[4],Exactly,2))
			for i = 23, 16, -1 do
				local CBit = 2^i
				local NBit = CBit
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[2],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseIfX(CVar("X",CRet[4],Exactly,3))
			for i = 23, 16, -1 do
				local CBit = 2^i
				local NBit = CBit*256
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[2],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseX()
			for i = 23, 16, -1 do
				local CBit = 2^i
				local NBit = CBit/65536
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[2],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CIfXEnd()
	CElseIfX(CVar("X",CRet[3],Exactly,3,0x3))
		CIfX(IncludePlayer,{CVar("X",CRet[4],Exactly,1)})
			for i = 31, 24, -1 do
				local CBit = 2^i
				local NBit = CBit/65536
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[2],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseIfX(CVar("X",CRet[4],Exactly,2))
			for i = 31, 24, -1 do
				local CBit = 2^i
				local NBit = CBit/256
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[2],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseIfX(CVar("X",CRet[4],Exactly,3))
			for i = 31, 24, -1 do
				local CBit = 2^i
				local NBit = CBit
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[2],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseX()
			for i = 31, 24, -1 do
				local CBit = 2^i
				local NBit = CBit/16777216
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[2],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CIfXEnd()
	CElseX()
		CIfX(IncludePlayer,{CVar("X",CRet[4],Exactly,1)})
			for i = 7, 0, -1 do
				local CBit = 2^i
				local NBit = CBit*256
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[2],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseIfX(CVar("X",CRet[4],Exactly,2))
			for i = 7, 0, -1 do
				local CBit = 2^i
				local NBit = CBit*65536
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[2],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseIfX(CVar("X",CRet[4],Exactly,3))
			for i = 7, 0, -1 do
				local CBit = 2^i
				local NBit = CBit*16777216
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[2],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseX()
			for i = 7, 0, -1 do
				local CBit = 2^i
				local NBit = CBit
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[2],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CIfXEnd()
	CIfXEnd()

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FBRZCall2);
			},
			actions = {
			},
			flag = {Preserved}
		}
end
-----------------------------------------------------------
if FBRXCheck == 1 then
	-- f_BreadX - Ret[1] : Input Offset / Ret[2] = Value / Ret[3] = EPD / Ret[4] = Value / Ret[5] = Mask
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FBRXCall1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	for i = 31, 2, -1 do
			local CBit = 2^i
			local NBit = CBit/4
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label();
					CVar("X",CRet[1],Exactly,CBit,CBit);
				},
				actions = {
					SetMemory(0x6509B0,Add,NBit);
				},
				flag = {Preserved}
			}
	end

	CIfX(IncludePlayer,{CVar("X",CRet[1],Exactly,1,0x3)})
		CIfX(IncludePlayer,{CVar("X",CRet[4],Exactly,1)})
			for i = 15, 8, -1 do
				local CBit = 2^i
				local NBit = CBit
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[3],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseIfX(CVar("X",CRet[4],Exactly,2))
			for i = 15, 8, -1 do
				local CBit = 2^i
				local NBit = CBit*256
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[3],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseIfX(CVar("X",CRet[4],Exactly,3))
			for i = 15, 8, -1 do
				local CBit = 2^i
				local NBit = CBit*65536
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[3],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseX()
			for i = 15, 8, -1 do
				local CBit = 2^i
				local NBit = CBit/256
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[3],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CIfXEnd()
	CElseIfX(CVar("X",CRet[1],Exactly,2,0x3))
		CIfX(IncludePlayer,{CVar("X",CRet[4],Exactly,1)})
			for i = 23, 16, -1 do
				local CBit = 2^i
				local NBit = CBit/256
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[3],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseIfX(CVar("X",CRet[4],Exactly,2))
			for i = 23, 16, -1 do
				local CBit = 2^i
				local NBit = CBit
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[3],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseIfX(CVar("X",CRet[4],Exactly,3))
			for i = 23, 16, -1 do
				local CBit = 2^i
				local NBit = CBit*256
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[3],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseX()
			for i = 23, 16, -1 do
				local CBit = 2^i
				local NBit = CBit/65536
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[3],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CIfXEnd()
	CElseIfX(CVar("X",CRet[1],Exactly,3,0x3))
		CIfX(IncludePlayer,{CVar("X",CRet[4],Exactly,1)})
			for i = 31, 24, -1 do
				local CBit = 2^i
				local NBit = CBit/65536
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[3],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseIfX(CVar("X",CRet[4],Exactly,2))
			for i = 31, 24, -1 do
				local CBit = 2^i
				local NBit = CBit/256
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[3],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseIfX(CVar("X",CRet[4],Exactly,3))
			for i = 31, 24, -1 do
				local CBit = 2^i
				local NBit = CBit
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[3],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseX()
			for i = 31, 24, -1 do
				local CBit = 2^i
				local NBit = CBit/16777216
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[3],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CIfXEnd()
	CElseX()
		CIfX(IncludePlayer,{CVar("X",CRet[4],Exactly,1)})
			for i = 7, 0, -1 do
				local CBit = 2^i
				local NBit = CBit*256
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[3],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseIfX(CVar("X",CRet[4],Exactly,2))
			for i = 7, 0, -1 do
				local CBit = 2^i
				local NBit = CBit*65536
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[3],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseIfX(CVar("X",CRet[4],Exactly,3))
			for i = 7, 0, -1 do
				local CBit = 2^i
				local NBit = CBit*16777216
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[3],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseX()
			for i = 7, 0, -1 do
				local CBit = 2^i
				local NBit = CBit
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[3],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CIfXEnd()
	CIfXEnd()

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FBRXCall2);
			},
			actions = {
			},
			flag = {Preserved}
		}
end
-----------------------------------------------------------
-- f_WreadZ - Ret[1] : Input Value / Ret[2] = Output / Ret[3] = Offset
if FWRZCheck == 1 then
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FWRZCall1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	CIfX(IncludePlayer,{CVar("X",CRet[3],AtLeast,2,0x3)})
		CIfX(IncludePlayer,{CVar("X",CRet[4],Exactly,1)})
			for i = 31, 16, -1 do
				local CBit = 2^i
				local NBit = CBit
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[2],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseX()
			for i = 31, 16, -1 do
				local CBit = 2^i
				local NBit = CBit/65536
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[2],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CIfXEnd()
	CElseX()
		CIfX(IncludePlayer,{CVar("X",CRet[4],Exactly,1)})
			for i = 15, 0, -1 do
				local CBit = 2^i
				local NBit = CBit*65536
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[2],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseX()
			for i = 15, 0, -1 do
				local CBit = 2^i
				local NBit = CBit
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[2],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CIfXEnd()
	CIfXEnd()

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FWRZCall2);
			},
			actions = {
			},
			flag = {Preserved}
		}
end
-----------------------------------------------------------
-- f_WreadX - Ret[1] : Input Offset / Ret[2] = Value / Ret[3] = EPD / Ret[4] = Value / Ret[5] = Mask
if FWRXCheck == 1 then
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FWRXCall0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",CRet[1],0x0,0,0);
				SetCtrigX("X",CRet[1],0x4,0,SetTo,"X","X",0x0,0,24);
				SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[1],0x15C,1,0);
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
			},
			flag = {Preserved}
		}
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FWRXCall1);
			},
			flag = {Preserved}
		}

	for i = 31, 2, -1 do
		local CBit = 2^i
		local NBit = CBit/4
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label();
					CVar("X",CRet[1],Exactly,CBit,CBit);
				},
				actions = {
					SetMemory(0x6509B0,Add,NBit);	
				},
				flag = {Preserved}
			}
	end

	CIfX(IncludePlayer,{CVar("X",CRet[1],AtLeast,2,0x3)})
		CIfX(IncludePlayer,{CVar("X",CRet[4],Exactly,1)})
			for i = 31, 16, -1 do
				local CBit = 2^i
				local NBit = CBit
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[3],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseX()
			for i = 31, 16, -1 do
				local CBit = 2^i
				local NBit = CBit/65536
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[3],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CIfXEnd()
	CElseX()
		CIfX(IncludePlayer,{CVar("X",CRet[4],Exactly,1)})
			for i = 15, 0, -1 do
				local CBit = 2^i
				local NBit = CBit*65536
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[3],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CElseX()
			for i = 15, 0, -1 do
				local CBit = 2^i
				local NBit = CBit
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
						DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
					},
					actions = {
						SetCVar("X",CRet[3],SetTo,NBit,NBit);
					},
					flag = {Preserved}
				}
			end
		CIfXEnd()

	CIfXEnd()

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FWRXCall2);
			},
			actions = {
			},
			flag = {Preserved}
		}
end
---------------------------------------------------------------------------------
	-- f_GetLine - Ret[1] : DisplayLine / Ret[2] = Output | Output = Line
if FLINECheck == 1 then
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLINECall1);
			},
			actions = {
				SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[2],0x15C,1,0);
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label();
				CVar("X",CRet[2],AtLeast,11);
			},
			actions = {
				SetCVar("X",CRet[2],SetTo,10);
			},
			flag = {Preserved}
		}
		
	for i = 0, 3 do
		local CBit = 2^i
		Trigger {players = {IncludePlayer},conditions = {Label(),MemoryX(0x640B58,Exactly,CBit,CBit)},actions = {SetCVar("X",CRet[2],Add,CBit)},flag = {Preserved}}
	end
	Trigger {players = {IncludePlayer},conditions = {Label(FLINECall2),CVar("X",CRet[2],AtLeast,11)},actions = {SetCVar("X",CRet[2],Subtract,11)},flag = {Preserved}}
end
-----------------------------------------------------------
	-- f_GetDisplayLine - Ret[1] : Line / Ret[2] = Output | Output = DisplayLine
if FDINECheck == 1 then
	Trigger {players = {IncludePlayer},conditions = {Label(FDINECall1)},actions = {SetCVar("X",CRet[2],SetTo,11)},flag = {Preserved}}
	for i = 0, 3 do
		local CBit = 2^i
		Trigger {players = {IncludePlayer},conditions = {Label(),MemoryX(0x640B58,Exactly,CBit,CBit)},actions = {SetCVar("X",CRet[2],Subtract,CBit)},flag = {Preserved}}
	end
	Trigger {players = {IncludePlayer},conditions = {Label(),CVar("X",CRet[2],Exactly,11)},actions = {SetCVar("X",CRet[2],SetTo,0)},flag = {Preserved}}

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label();
				CVar("X",CRet[1],AtLeast,11);
			},
			actions = {
				SetCVar("X",CRet[1],SetTo,10);
			},
			flag = {Preserved}
		}

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label();
			},
			actions = {
				SetCtrigX("X",CRet[1],0x158,0,SetTo,"X",CRet[2],0x15C,1,0);
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,Add*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}
	
	Trigger {players = {IncludePlayer},conditions = {Label(FDINECall2),CVar("X",CRet[2],AtLeast,11)},actions = {SetCVar("X",CRet[2],Subtract,11)},flag = {Preserved}}
end
-----------------------------------------------------------
	-- f_GetIndex - Ret[1] : Index / Ret[2] = Output 
if FGINDXCheck == 1 then
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FGINDXCall1);
				CVar("X",CRet[1],AtLeast,0+54*11);
			},
			actions = {
				SetCVar("X",CRet[1],SetTo,0);
			},
			flag = {Preserved}
		}

	for i = 3, 0, -1 do
		local CBit = 2^i
		Trigger {players = {IncludePlayer},conditions = {Label(),CVar("X",CRet[1],AtLeast,54*CBit)},actions = {SetCVar("X",CRet[1],Subtract,54*CBit),SetCVar("X",CRet[2],Add,604*CBit)},flag = {Preserved}}
	end
	
	for i = 5, 0, -1 do
		local CBit = 2^i
		Trigger {players = {IncludePlayer},conditions = {Label(),CVar("X",CRet[1],AtLeast,CBit)},actions = {SetCVar("X",CRet[1],Subtract,CBit),SetCVar("X",CRet[2],Add,8*CBit)},flag = {Preserved}}
	end
		
	Trigger {players = {IncludePlayer},conditions = {Label(FGINDXCall2)},flag = {Preserved}}
end
-----------------------------------------------------------
if FGINDX2Check == 1 then
		-- f_GetIndex2 - Ret[1] : Index / Ret[2] : Line / Ret[3] = Output 

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FGINDX2Call1);
				CVar("X",CRet[1],AtLeast,54);
			},
			actions = {
				SetCVar("X",CRet[1],SetTo,0);
			},
			flag = {Preserved}
		}
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label();
				CVar("X",CRet[2],AtLeast,11);
			},
			actions = {
				SetCVar("X",CRet[2],SetTo,0);
			},
			flag = {Preserved}
		}

	for i = 3, 0, -1 do
		local CBit = 2^i
		Trigger {players = {IncludePlayer},conditions = {Label(),CVar("X",CRet[2],AtLeast,CBit)},actions = {SetCVar("X",CRet[2],Subtract,CBit),SetCVar("X",CRet[3],Add,604*CBit)},flag = {Preserved}}
	end
	
	for i = 5, 0, -1 do
		local CBit = 2^i
		Trigger {players = {IncludePlayer},conditions = {Label(),CVar("X",CRet[1],AtLeast,CBit)},actions = {SetCVar("X",CRet[1],Subtract,CBit),SetCVar("X",CRet[3],Add,8*CBit)},flag = {Preserved}}
	end
		
	Trigger {players = {IncludePlayer},conditions = {Label(FGINDX2Call2)},flag = {Preserved}}
end
-----------------------------------------------------------
if FDISPCheck == 1 then
		-- f_Display - Ret[1] : Line / Ret[2] = Output 
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FDISPCall1);
			},
			actions = {
				SetCVar("X",CRet[2],SetTo,0);
			},
			flag = {Preserved}
		}

	for i = 0, 10 do
		if i%2 == 0 then
			Trigger {players = {IncludePlayer},conditions = {Label(),CVar("X",CRet[1],Exactly,i),MemoryX(0x640B60+218*i,Exactly,0,0xFF)},actions = {SetCVar("X",CRet[2],SetTo,1)},flag = {Preserved}}
		else
			Trigger {players = {IncludePlayer},conditions = {Label(),CVar("X",CRet[1],Exactly,i),MemoryX(0x640B60+218*i-2,Exactly,0,0xFF0000)},actions = {SetCVar("X",CRet[2],SetTo,1)},flag = {Preserved}}
		end
	end
	Trigger {players = {IncludePlayer},conditions = {Label(FDISPCall2),CVar("X",CRet[1],Exactly,12),MemoryX(0x640B60+218*12,Exactly,0,0xFF)},actions = {SetCVar("X",CRet[2],SetTo,1)},flag = {Preserved}}
end
-----------------------------------------------------------
if FDISPXCheck == 1 then
	-- f_DisplayX - Ret[1] : Line / Ret[2] : Index / Ret[3] : Value / Ret[4] : Mask / Ret[5] = Output 
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FDISPXCall1);
			},
			actions = {
				SetCVar("X",CRet[5],SetTo,0);
			},
			flag = {Preserved}
		}

	Trigger {players = {IncludePlayer},conditions = {Label(),CVar("X",CRet[1],AtLeast,13)},actions = {SetCVar("X",CRet[1],SetTo,12)},flag = {Preserved}}
	for i = 0, 10 do
		if i%2 == 0 then
			Trigger {players = {IncludePlayer},conditions = {Label(),CVar("X",CRet[1],Exactly,i)},actions = {SetCtrig1X("X",FDISPXCall2,0x20,0,SetTo,EPD(0x640B60+218*i))},flag = {Preserved}}
		else
			Trigger {players = {IncludePlayer},conditions = {Label(),CVar("X",CRet[1],Exactly,i)},actions = {SetCtrig1X("X",FDISPXCall2,0x20,0,SetTo,EPD(0x640B62+218*i))},flag = {Preserved}}
		end
	end
	Trigger {players = {IncludePlayer},conditions = {Label(),CVar("X",CRet[1],AtLeast,11),CVar("X",CRet[1],AtMost,12)},actions = {SetCtrig1X("X",FDISPXCall2,0x20,0,SetTo,EPD(0x640B60+218*12))},flag = {Preserved}}

	Trigger {players = {IncludePlayer},conditions = {Label(),CVar("X",CRet[2],AtLeast,54)},actions = {SetCVar("X",CRet[2],SetTo,53)},flag = {Preserved}}
	Trigger {
			players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",CRet[2],0x158,0,SetTo,"X",FDISPXCall2,0x20,1,0); -- Index
					SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[2],0x160,0,SetTo,Add*16777216,0xFF000000);
					SetCtrigX("X",CRet[3],0x158,0,SetTo,"X",FDISPXCall2,0x24,1,0); -- Value
					SetCtrig1X("X",CRet[3],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrigX("X",CRet[4],0x158,0,SetTo,"X",FDISPXCall2,0x1C,1,0); -- Mask
					SetCtrig1X("X",CRet[4],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",CRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways3("X",CRet[2],0,"X",CRet[3],0,"X",CRet[4],0);
				},
				flag = {Preserved}
			}

	Trigger {players = {IncludePlayer},conditions = {Label(FDISPXCall2),DeathsX(0,Exactly,0,0,0)},actions = {SetCVar("X",CRet[5],SetTo,1)},flag = {Preserved}}
end
-----------------------------------------------------------
if FSTRLCheck == 1 then
		-- f_strlen - Ret[1] : Line / Ret[2] = Output / Ret[3] : EPDXOutput / Ret[4] : len/cat 
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FSTRLCall1);
			},
			actions = {
				SetCVar("X",CRet[2],SetTo,0);
				SetCVar("X",CRet[3],SetTo,0);
				SetCtrigX("X",IndexAlloc,0x4,3,SetTo,"X",IndexAlloc,0x0,0,4);
				SetCtrigX("X",IndexAlloc,0x4,4,SetTo,"X",IndexAlloc,0x0,0,5);
				SetCtrigX("X",IndexAlloc,0x4,5,SetTo,"X",IndexAlloc,0x0,0,6);
				SetCtrigX("X",IndexAlloc,0x4,6,SetTo,"X",IndexAlloc,0x0,0,7);
			},
			flag = {Preserved}
		}
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label();
				CVar("X",CRet[4],Exactly,1);
			},
			actions = {
				SetCtrig1X("X",IndexAlloc,0x164,3,SetTo,0x0,0x2);
				SetCtrig1X("X",IndexAlloc,0x164,4,SetTo,0x0,0x2);
				SetCtrig1X("X",IndexAlloc,0x164,5,SetTo,0x0,0x2);
				SetCtrig1X("X",IndexAlloc,0x164,6,SetTo,0x0,0x2);
			},
			flag = {Preserved}
		}

	for i = 0, 10 do
		if i%2 == 0 then
			Trigger {players = {IncludePlayer},conditions = {Label(),CVar("X",CRet[1],Exactly,i)},actions = {SetMemory(0x6509B0,SetTo,EPD(0x640B60+218*i))},flag = {Preserved}}
		else
			Trigger {players = {IncludePlayer},conditions = {Label(),CVar("X",CRet[1],Exactly,i)},actions = {SetMemory(0x6509B0,SetTo,EPD(0x640B62+218*i))},flag = {Preserved}}
		end
	end
	Trigger {players = {IncludePlayer},conditions = {Label(),CVar("X",CRet[1],Exactly,12)},actions = {SetMemory(0x6509B0,SetTo,EPD(0x640B60+218*12))},flag = {Preserved}}
	local FSTRLAlloc = IndexAlloc
	NWhile(IncludePlayer,{CVar("X",CRet[2],AtMost,53)})
		Trigger { -- +0x0
			players = {IncludePlayer},
			conditions = {
				Label();
				DeathsX(CurrentPlayer,Exactly,0,0,0xFF);
			},
			actions = {
				Disabled(SetDeathsX(CurrentPlayer,SetTo,0x0D0D0D0D,0,0xFFFFFFFF)); -- cat
				SetCtrigX("X","X",0x4,0,SetTo,"X",FSTRLCall2,0x0,0,0);
				SetCVar("X",CRet[3],SetTo,0);
			},
			flag = {Preserved}
		}
		Trigger { -- +0x1
			players = {IncludePlayer},
			conditions = {
				Label();
				DeathsX(CurrentPlayer,Exactly,0,0,0xFF00);
			},
			actions = {
				Disabled(SetDeathsX(CurrentPlayer,SetTo,0x0D0D0D00,0,0xFFFFFF00)); -- cat
				SetCtrigX("X","X",0x4,0,SetTo,"X",FSTRLCall2,0x0,0,0);
				SetCVar("X",CRet[3],SetTo,1);
			},
			flag = {Preserved}
		}
		Trigger { -- +0x2
			players = {IncludePlayer},
			conditions = {
				Label();
				DeathsX(CurrentPlayer,Exactly,0,0,0xFF0000);
			},
			actions = {
				Disabled(SetDeathsX(CurrentPlayer,SetTo,0x0D0D0000,0,0xFFFF0000)); -- cat
				SetCtrigX("X","X",0x4,0,SetTo,"X",FSTRLCall2,0x0,0,0);
				SetCVar("X",CRet[3],SetTo,2);
			},
			flag = {Preserved}
		}
		Trigger { -- +0x3
			players = {IncludePlayer},
			conditions = {
				Label();
				DeathsX(CurrentPlayer,Exactly,0,0,0xFF000000);
			},
			actions = {
				Disabled(SetDeathsX(CurrentPlayer,SetTo,0x0D000000,0,0xFF000000)); -- cat
				SetCtrigX("X","X",0x4,0,SetTo,"X",FSTRLCall2,0x0,0,0);
				SetCVar("X",CRet[3],SetTo,3);
			},
			flag = {Preserved}
		}
	NWhileEnd({SetCVar("X",CRet[2],Add,1),SetMemory(0x6509B0,Add,1)})

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label();
				CVar("X",CRet[4],Exactly,1);
			},
			actions = {
				SetCVar("X",CRet[2],Add,1);
			},
			flag = {Preserved}
		}
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label();
				CVar("X",CRet[4],Exactly,1);
				CVar("X",CRet[2],Exactly,55);
			},
			actions = {
				SetCVar("X",CRet[2],SetTo,0);
			},
			flag = {Preserved}
		}

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FSTRLCall2);
			},
			actions = {
				SetCtrig1X("X",FSTRLAlloc,0x164,3,SetTo,0x2,0x2);
				SetCtrig1X("X",FSTRLAlloc,0x164,4,SetTo,0x2,0x2);
				SetCtrig1X("X",FSTRLAlloc,0x164,5,SetTo,0x2,0x2);
				SetCtrig1X("X",FSTRLAlloc,0x164,6,SetTo,0x2,0x2);
			},
			flag = {Preserved}
		}
end
-----------------------------------------------------------
if FCHATOCheck == 1 then
	-- f_ChatOffset - Ret[1] : Line / Ret[2] = Offset / Ret[3] = Output 
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FCHATOCall);
			},
			actions = {
				SetCVar("X",CRet[3],SetTo,0x640B60);
				SetCtrigX("X",CRet[2],0x158,0,SetTo,"X",CRet[3],0x15C,1,0);
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,Add*16777216,0xFF000000);
				SetCtrigX("X","X",0x4,0,SetTo,"X",CRet[2],0x0,0,0);
				SetCtrigX("X",CRet[2],0x4,0,SetTo,"X","X",0x0,0,1);
			},
			flag = {Preserved}
		}

	for i = 3, 0, -1 do
		local CBit = 2^i
		Trigger {players = {IncludePlayer},conditions = {Label(),CVar("X",CRet[1],Exactly,CBit,CBit)},actions = {SetCVar("X",CRet[3],Add,218*CBit)},flag = {Preserved}}
	end
end
-----------------------------------------------------------
if FSCANVCheck == 1 then
	-- f_VtoI - Ret[1] : Base / Ret[2] : Sign / Ret[3] : Source / Ret[4] : V / Ret[5] : Output / Ret[6] : Temp / Ret[7] : Size

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FSCANVCall1);
				},
				actions = {
					SetCVar("X",FSCANV[6],SetTo,0);
					SetCVar("X",FSCANV[4],SetTo,0);
					SetCtrig1X("X",FSCANV[3],0x158,0,SetTo,EPD(0x6509B0));
					SetCtrig1X("X",FSCANV[3],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FSCANV[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",FSCANV[3],0);
					
			},
				flag = {Preserved}
			}

		CIfX(IncludePlayer,CVar("X",FSCANV[1],Exactly,10),SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,1))
			NIfX(IncludePlayer,{CVar("X",FSCANV[7],AtLeast,1),CVar("X",FSCANV[6],Exactly,0,1),CVar("X",FSCANV[5],AtLeast,604),DeathsX(CurrentPlayer,AtLeast,0x30000000,0,0xFF000000),DeathsX(CurrentPlayer,AtMost,0x39000000,0,0xFF000000)},{SetCVar("X",FSCANV[6],SetTo,4,4)})
				Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc)},flag = {Preserved}}
				for j = 0, 8 do	-- Digit 1~9
					local NBit = 10^j
					for i = 0, 3 do
						local CBit = 2^i
						Trigger {players = {IncludePlayer},conditions = {Label(),DeathsX(CurrentPlayer,Exactly,CBit*0x01000000,0,CBit*0x01000000)},actions = {SetCVar("X",FSCANV[4],Add,CBit*NBit)},flag = {Preserved}}
					end
					Trigger {players = {IncludePlayer},conditions = {Label()},actions = {SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X","X",0x0,0,1),
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,-2),SetMemory(0x6509B0,Subtract,604),SetCVar("X",FSCANV[5],Subtract,604),SetCVar("X",FSCANV[7],Subtract,1)},flag = {Preserved}}
				end
				for i = 0, 2 do -- Digit -- 10
					local CBit = 2^i
					Trigger {players = {IncludePlayer},conditions = {Label(),DeathsX(CurrentPlayer,Exactly,CBit*0x01000000,0,CBit*0x01000000)},actions = {SetCVar("X",FSCANV[4],Add,CBit*1000000000)},flag = {Preserved}}
				end
				Trigger {players = {IncludePlayer},conditions = {Label()},actions = {SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X","X",0x0,0,1),
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,-2),SetMemory(0x6509B0,Subtract,604),SetCVar("X",FSCANV[5],Subtract,604),SetCVar("X",FSCANV[7],Subtract,1),SetCVar("X",FSCANV[6],SetTo,1,1)},flag = {Preserved}}
				FuncAlloc = FuncAlloc + 1
			NElseIfX({CVar("X",FSCANV[7],AtLeast,1),CVar("X",FSCANV[6],Exactly,0,1),CVar("X",FSCANV[5],AtLeast,604),DeathsX(CurrentPlayer,Exactly,0x2C000000,0,0xFF000000)}) -- ,
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc-1,0x0,0,-2);
						SetMemory(0x6509B0,Subtract,604);
						SetCVar("X",FSCANV[5],Subtract,604);
						SetCVar("X",FSCANV[7],Subtract,1);
					},
					flag = {Preserved}
				}
			NElseIfX({CVar("X",FSCANV[7],AtLeast,1),CVar("X",FSCANV[2],AtLeast,1),CVar("X",FSCANV[5],AtLeast,604),DeathsX(CurrentPlayer,Exactly,0x2D000000,0,0xFF000000)},{SetCVar("X",FSCANV[6],SetTo,4,4)}) -- -	
				CNeg(IncludePlayer,V(FSCANV[4]))
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetMemory(0x6509B0,Subtract,604);
						SetCVar("X",FSCANV[5],Subtract,604);
						SetCVar("X",FSCANV[7],Subtract,1);
						SetCVar("X",FSCANV[6],SetTo,1,1);
					},
					flag = {Preserved}
				}
			NElseIfX({CVar("X",FSCANV[7],AtLeast,1),CVar("X",FSCANV[5],AtLeast,604),CVar("X",FSCANV[6],Exactly,0,4)})
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc-1,0x0,0,-2);
						SetMemory(0x6509B0,Subtract,604);
						SetCVar("X",FSCANV[5],Subtract,604);
						SetCVar("X",FSCANV[7],Subtract,1);
					},
					flag = {Preserved}
				}
			NIfXEnd()-- 나머지 (TapeStop)
		CElseIfX(CVar("X",FSCANV[1],Exactly,16),{SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,1),SetCtrigX("X",FuncAlloc+1,0x4,0,SetTo,"X",FuncAlloc+1,0x0,0,1)})
			local Box
			NIfX(IncludePlayer,{CVar("X",FSCANV[7],AtLeast,1),CVar("X",FSCANV[6],Exactly,0,1),CVar("X",FSCANV[5],AtLeast,604),DeathsX(CurrentPlayer,AtLeast,0x30000000,0,0xFF000000),DeathsX(CurrentPlayer,AtMost,0x39000000,0,0xFF000000)},{SetCVar("X",FSCANV[6],SetTo,4,4)})
				Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc)},flag = {Preserved}}
				for j = 0, 7 do	-- Digit 1~8
					if j == 7 then Box = {SetCVar("X",FSCANV[6],SetTo,1,1)} else Box = {} end
					local NBit = 16^j
					for i = 0, 3 do
						local CBit = 2^i
						Trigger {players = {IncludePlayer},conditions = {Label(),DeathsX(CurrentPlayer,Exactly,CBit*0x01000000,0,CBit*0x01000000)},actions = {SetCVar("X",FSCANV[4],Add,CBit*NBit)},flag = {Preserved}}
					end
					Trigger {players = {IncludePlayer},conditions = {Label()},actions = {SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X","X",0x0,0,1),
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,-2),SetMemory(0x6509B0,Subtract,604),SetCVar("X",FSCANV[5],Subtract,604),SetCVar("X",FSCANV[7],Subtract,1),
					SetCtrigX("X",FuncAlloc+1,0x4,0,SetTo,"X",FuncAlloc+1,0x0,0,1+(j+1)*5),Box},flag = {Preserved}}
				end
				FuncAlloc = FuncAlloc + 1
			NElseIfX({CVar("X",FSCANV[7],AtLeast,1),CVar("X",FSCANV[6],Exactly,0,1),CVar("X",FSCANV[5],AtLeast,604),DeathsX(CurrentPlayer,AtLeast,0x61000000,0,0xFF000000),DeathsX(CurrentPlayer,AtMost,0x66000000,0,0xFF000000)},{SetCVar("X",FSCANV[6],SetTo,4,4)})
				Trigger {players = {IncludePlayer},conditions = {Label()},actions={SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,0)},flag = {Preserved}}
			NElseIfX({CVar("X",FSCANV[7],AtLeast,1),CVar("X",FSCANV[6],Exactly,0,1),CVar("X",FSCANV[5],AtLeast,604),DeathsX(CurrentPlayer,AtLeast,0x41000000,0,0xFF000000),DeathsX(CurrentPlayer,AtMost,0x46000000,0,0xFF000000)},{SetCVar("X",FSCANV[6],SetTo,4,4)})
				Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc)},flag = {Preserved}}
				for j = 0, 7 do	-- Digit 1~8
					if j == 7 then Box = {SetCVar("X",FSCANV[6],SetTo,1,1)} else Box = {} end
					local NBit = 16^j
					Trigger {players = {IncludePlayer},conditions = {Label()},actions = {SetCVar("X",FSCANV[4],Add,9*NBit)},flag = {Preserved}}
					for i = 0, 2 do
						local CBit = 2^i
						Trigger {players = {IncludePlayer},conditions = {Label(),DeathsX(CurrentPlayer,Exactly,CBit*0x01000000,0,CBit*0x01000000)},actions = {SetCVar("X",FSCANV[4],Add,CBit*NBit)},flag = {Preserved}}
					end
					Trigger {players = {IncludePlayer},conditions = {Label()},actions = {SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X","X",0x0,0,1),
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc-1,0x0,0,-2),SetMemory(0x6509B0,Subtract,604),SetCVar("X",FSCANV[5],Subtract,604),SetCVar("X",FSCANV[7],Subtract,1),
					SetCtrigX("X",FuncAlloc-1,0x4,0,SetTo,"X",FuncAlloc-1,0x0,0,1+(j+1)*5),Box},flag = {Preserved}}
				end
				FuncAlloc = FuncAlloc + 1
			NElseIfX({CVar("X",FSCANV[7],AtLeast,1),CVar("X",FSCANV[6],Exactly,0,1),CVar("X",FSCANV[5],AtLeast,604),DeathsX(CurrentPlayer,Exactly,0x20000000,0,0xFF000000)}) -- ' '
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc-2,0x0,0,-2);
						SetMemory(0x6509B0,Subtract,604);
						SetCVar("X",FSCANV[5],Subtract,604);
						SetCVar("X",FSCANV[7],Subtract,1);
					},
					flag = {Preserved}
				}
			NElseIfX({CVar("X",FSCANV[7],AtLeast,2),CVar("X",FSCANV[6],Exactly,0,2),CVar("X",FSCANV[5],AtLeast,604*2),DeathsX(CurrentPlayer,Exactly,0x78000000,0,0xFF000000)},{SetCVar("X",FSCANV[6],SetTo,4,4)}) -- 0x 
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc-2,0x0,0,-2);
						SetMemory(0x6509B0,Subtract,604*2);
						SetCVar("X",FSCANV[5],Subtract,604*2);
						SetCVar("X",FSCANV[7],Subtract,2);
						SetCVar("X",FSCANV[6],SetTo,3,3);
					},
					flag = {Preserved}
				}
			NElseIfX({CVar("X",FSCANV[7],AtLeast,1),CVar("X",FSCANV[2],AtLeast,1),CVar("X",FSCANV[5],AtLeast,604),DeathsX(CurrentPlayer,Exactly,0x2D000000,0,0xFF000000)},{SetCVar("X",FSCANV[6],SetTo,4,4)}) -- -	
				CNeg(IncludePlayer,V(FSCANV[4]))
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetMemory(0x6509B0,Subtract,604);
						SetCVar("X",FSCANV[5],Subtract,604);
						SetCVar("X",FSCANV[7],Subtract,1);
						SetCVar("X",FSCANV[6],SetTo,1,1);
					},
					flag = {Preserved}
				}
			NElseIfX({CVar("X",FSCANV[7],AtLeast,1),CVar("X",FSCANV[5],AtLeast,604),CVar("X",FSCANV[6],Exactly,0,4)})
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc-2,0x0,0,-2);
						SetMemory(0x6509B0,Subtract,604);
						SetCVar("X",FSCANV[5],Subtract,604);
						SetCVar("X",FSCANV[7],Subtract,1);
					},
					flag = {Preserved}
				}
			NIfXEnd() -- 나머지 (TapeStop)
		CIfXEnd()

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FSCANVCall2);
				},
				flag = {Preserved}
			}
end
-----------------------------------------------------------
if FSCANWCheck == 1 then
	-- f_WtoI - Ret[1] : Base / Ret[2] : Sign / Ret[3] : Source / Ret[4] : W / Ret[5] : Output / Ret[6] : Temp / Ret[7] : Size
		local Top = {
			{0.0,0.0,0.0,0.0},--0
			{0.0,0.0,0.0,0.0},--1
			{0.0,0.0,0.0,0.0},--2
			{0.0,0.0,0.0,0.0},--3
			{0.0,0.0,0.0,0.0},--4
			{0.0,0.0,0.0,0.0},--5
			{0.0,0.0,0.0,0.0},--6	
			{0.0,0.0,0.0,0.0},--7
			{0.0,0.0,0.0,0.0},--8
			{0.0,0.0,0.0,1.0},--9
			{2.0,4.0,9.0,18.0},--10
			{23.0,46.0,93.0,186.0},--11
			{232.0,465.0,931.0,1862.0},--12
			{2328.0,4656.0,9313.0,18626.0},--13
			{23283.0,46566.0,93132.0,186264.0},--14
			{232830.0,465661.0,931322.0,1862645.0},--15
			{2328306.0,4656612.0,9313225.0,18626451.0},--16
			{23283064.0,46566128.0,93132257.0,186264514.0},--17
			{232830643.0,465661287.0,931322574.0,1862645149.0},--18
			{2328306436.0}--19
			}
		local Bottom = {
			{1.0,2.0,4.0,8.0},--0
			{10.0,20.0,40.0,80.0},--1
			{100.0,200.0,400.0,800.0},--2
			{1000.0,2000.0,4000.0,8000.0},--3
			{10000.0,20000.0,40000.0,80000.0},--4
			{100000.0,200000.0,400000.0,800000.0},--5
			{1000000.0,2000000.0,4000000.0,8000000.0},--6
			{10000000.0,20000000.0,40000000.0,80000000.0},--7
			{100000000.0,200000000.0,400000000.0,800000000.0},--8
			{1000000000.0,2000000000.0,4000000000.0,3705032704.0},--9
			{1410065408.0,2820130816.0,1345294336.0,2690588672.0},--10
			{1215752192.0,2431504384.0,568041472.0,1136082944.0},--11
			{3567587328.0,2840207360.0,1385447424.0,2770894848.0},--12
			{1316134912.0,2632269824.0,969572352.0,1939144704.0},--13
			{276447232.0,552894464.0,1105788928.0,2211577856.0},--14
			{2764472320.0,1233977344.0,2467954688.0,640942080.0},--15
			{1874919424.0,3749838848.0,3204710400.0,2114453504.0},--16
			{1569325056.0,3138650112.0,1982332928.0,3964665856.0},--17
			{2808348672.0,1321730048.0,2643460096.0,991952896.0},--18
			{2313682944.0}--19
			}

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FSCANWCall1);
				},
				actions = {
					SetCVar("X",FSCANW[6],SetTo,0);
					SetCWar("X",FSCANW[4],SetTo,{0,0});
					SetCtrig1X("X",FSCANW[3],0x158,0,SetTo,EPD(0x6509B0));
					SetCtrig1X("X",FSCANW[3],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FSCANW[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",FSCANW[3],0);
					
			},
				flag = {Preserved}
			}

		CIfX(IncludePlayer,CVar("X",FSCANW[1],Exactly,10),SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,1))
			NIfX(IncludePlayer,{CVar("X",FSCANW[7],AtLeast,1),CVar("X",FSCANW[6],Exactly,0,1),CVar("X",FSCANW[5],AtLeast,604),DeathsX(CurrentPlayer,AtLeast,0x30000000,0,0xFF000000),DeathsX(CurrentPlayer,AtMost,0x39000000,0,0xFF000000)},{SetCVar("X",FSCANW[6],SetTo,4,4)})
				Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc)},flag = {Preserved}}
				for j = 0, 18 do	-- Digit 1~19
					DoActionsX(IncludePlayer,{SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,3),SetCtrigX("X","X",0x4,3,SetTo,"X","X",0x0,0,5),SetCtrigX("X","X",0x4,5,SetTo,"X","X",0x0,0,7),SetCtrigX("X","X",0x4,7,SetTo,"X","X",0x0,0,9)})
					for i = 0, 3 do
						local CBit = 2^i
						Trigger {
							players = {IncludePlayer},
							conditions = {
								Label();
								DeathsX(CurrentPlayer,Exactly,CBit*0x01000000,0,CBit*0x01000000);
							},
							actions = {
								SetCWar("X",WRet[3],SetTo,{Bottom[j+1][i+1],Top[j+1][i+1]});
								SetCtrigX("X",FSCANW[4],0x158,0,SetTo,"X","X",0x24,1,1);
								SetCtrig1X("X",FSCANW[4],0x198,0,SetTo,0);
								SetCtrig1X("X",FSCANW[4],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",FSCANW[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",FSCANW[4],0x19C,0,Add,1); -- Carry 가불
								SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FSCANW[4],0x15C,1,0);
								SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FSCANW[4],0x19C,1,0);
								SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",WRet[3],0x160,0,SetTo,Add*16777216,0xFF000000);
								SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,Add*16777216,0xFF000000);
								CallLabelAlways2("X",FSCANW[4],0,"X",WRet[3],0);
							},
							flag = {Preserved}
						}
						Trigger {
							players = {IncludePlayer},
							conditions = {
								Label();
								CtrigX("X",FSCANW[4],0x15C,0,AtLeast,0); -- X2 >= X2(전) : X1 -= 1 (No Carry)
							},
							actions = {
								SetCtrig1X("X",FSCANW[4],0x19C,0,Add,-1);
							},
							flag = {Preserved}
						}
					end
					Trigger {players = {IncludePlayer},conditions = {Label()},actions = {SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X","X",0x0,0,1),
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,-2),SetMemory(0x6509B0,Subtract,604),SetCVar("X",FSCANW[5],Subtract,604),SetCVar("X",FSCANW[7],Subtract,1)},flag = {Preserved}}
				end
				DoActionsX(IncludePlayer,{SetCtrigX("X","X",0x4,1,SetTo,"X","X",0x0,0,3)})
				for i = 0, 0 do -- Digit -- 20
					local CBit = 2^i
					Trigger {
							players = {IncludePlayer},
							conditions = {
								Label();
								DeathsX(CurrentPlayer,Exactly,CBit*0x01000000,0,CBit*0x01000000);
							},
							actions = {
								SetCtrigX("X",FSCANW[4],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
								SetCtrigX("X",FSCANW[4],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
								SetCtrig1X("X",FSCANW[4],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",FSCANW[4],0x188,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",FSCANW[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",FSCANW[4],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
								SetCWar("X",WRet[3],SetTo,{Bottom[20][i+1],Top[20][i+1]});

								SetCtrigX("X","X",0x4,0,SetTo,"X",FSCANW[4],0x0,0,0);
								SetCtrigX("X",FSCANW[4],0x4,0,SetTo,"X",FLAddCall1,0x0,0,0);
								SetCtrigX("X",FLAddCall2,0x4,0,SetTo,"X","X",0x0,0,1);
							},
							flag = {Preserved}
						}
						Trigger {
							players = {IncludePlayer},
							conditions = {
								Label();
							},
							actions = {
								SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",FSCANW[4],0x15C,1,0);
								SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",FSCANW[4],0x19C,1,0);
								SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
								SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
								SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);

								SetCtrigX("X","X",0x4,0,SetTo,"X",WRet[2],0x0,0,0);
								SetCtrigX("X",WRet[2],0x4,0,SetTo,"X","X",0x0,0,1);
							},
							flag = {Preserved}
						}	
				end
				Trigger {players = {IncludePlayer},conditions = {Label()},actions = {SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X","X",0x0,0,1),
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,-2),SetMemory(0x6509B0,Subtract,604),SetCVar("X",FSCANW[5],Subtract,604),SetCVar("X",FSCANW[7],Subtract,1),SetCVar("X",FSCANW[6],SetTo,1,1)},flag = {Preserved}}
				FuncAlloc = FuncAlloc + 1
			NElseIfX({CVar("X",FSCANW[7],AtLeast,1),CVar("X",FSCANW[6],Exactly,0,1),CVar("X",FSCANW[5],AtLeast,604),DeathsX(CurrentPlayer,Exactly,0x2C000000,0,0xFF000000)}) -- ,
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc-1,0x0,0,-2);
						SetMemory(0x6509B0,Subtract,604);
						SetCVar("X",FSCANW[5],Subtract,604);
						SetCVar("X",FSCANW[7],Subtract,1);
					},
					flag = {Preserved}
				}
			NElseIfX({CVar("X",FSCANW[7],AtLeast,1),CVar("X",FSCANW[2],AtLeast,1),CVar("X",FSCANW[5],AtLeast,604),DeathsX(CurrentPlayer,Exactly,0x2D000000,0,0xFF000000)},{SetCVar("X",FSCANW[6],SetTo,4,4)}) -- -	
				Trigger {
						players = {IncludePlayer},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0xFFFFFFFF);
							SetCtrigX("X",FSCANW[4],0x158,0,SetTo,"X",WRet[1],0x15C,1,0);
							SetCtrigX("X",FSCANW[4],0x198,0,SetTo,"X",WRet[1],0x19C,1,0);
							SetCtrig1X("X",FSCANW[4],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FSCANW[4],0x188,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FSCANW[4],0x160,0,SetTo,Subtract*16777216,0xFF000000);
							SetCtrig1X("X",FSCANW[4],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);

							SetCtrigX("X",WRet[1],0x158,0,SetTo,"X",FSCANW[4],0x15C,1,0);
							SetCtrigX("X",WRet[1],0x198,0,SetTo,"X",FSCANW[4],0x19C,1,0);
							SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",WRet[1],0x188,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways2("X",FSCANW[4],0,"X",WRet[1],0);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {IncludePlayer},
						conditions = {
							Label(0);
							CtrigX("X",FSCANW[4],0x15C,0,Exactly,0xFFFFFFFF);
						},
						actions = {
							SetCtrig1X("X",FSCANW[4],0x19C,0,Add,1);
						},
						flag = {Preserved}
					}	
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetCtrig1X("X",FSCANW[4],0x15C,0,Add,1);
						SetMemory(0x6509B0,Subtract,604);
						SetCVar("X",FSCANW[5],Subtract,604);
						SetCVar("X",FSCANW[7],Subtract,1);
						SetCVar("X",FSCANW[6],SetTo,1,1);
					},
					flag = {Preserved}
				}
			NElseIfX({CVar("X",FSCANW[7],AtLeast,1),CVar("X",FSCANW[5],AtLeast,604),CVar("X",FSCANW[6],Exactly,0,4)})
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc-1,0x0,0,-2);
						SetMemory(0x6509B0,Subtract,604);
						SetCVar("X",FSCANW[5],Subtract,604);
						SetCVar("X",FSCANW[7],Subtract,1);
					},
					flag = {Preserved}
				}
			NIfXEnd()-- 나머지 (TapeStop)
		CElseIfX(CVar("X",FSCANW[1],Exactly,16),{SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,1),SetCtrigX("X",FuncAlloc+1,0x4,0,SetTo,"X",FuncAlloc+1,0x0,0,1)})
			local Box
			NIfX(IncludePlayer,{CVar("X",FSCANW[7],AtLeast,1),CVar("X",FSCANW[6],Exactly,0,1),CVar("X",FSCANW[5],AtLeast,604),DeathsX(CurrentPlayer,AtLeast,0x30000000,0,0xFF000000),DeathsX(CurrentPlayer,AtMost,0x39000000,0,0xFF000000)},{SetCVar("X",FSCANW[6],SetTo,4,4)})
				Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc)},flag = {Preserved}}
				for j = 0, 7 do	-- Digit 1~8
					local NBit = 16^j
					for i = 0, 3 do
						local CBit = 2^i
						Trigger {players = {IncludePlayer},conditions = {Label(),DeathsX(CurrentPlayer,Exactly,CBit*0x01000000,0,CBit*0x01000000)},actions = {SetCWar("X",FSCANW[4],Add,CBit*NBit)},flag = {Preserved}}
					end
					Trigger {players = {IncludePlayer},conditions = {Label()},actions = {SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X","X",0x0,0,1),
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,-2),SetMemory(0x6509B0,Subtract,604),SetCVar("X",FSCANW[5],Subtract,604),SetCVar("X",FSCANW[7],Subtract,1),
					SetCtrigX("X",FuncAlloc+1,0x4,0,SetTo,"X",FuncAlloc+1,0x0,0,1+(j+1)*5)},flag = {Preserved}}
				end
				for j = 0, 7 do	-- Digit 9~16
					if j == 7 then Box = {SetCVar("X",FSCANW[6],SetTo,1,1)} else Box = {} end
					local NBit = 16^j
					for i = 0, 3 do
						local CBit = 2^i
						Trigger {players = {IncludePlayer},conditions = {Label(),DeathsX(CurrentPlayer,Exactly,CBit*0x01000000,0,CBit*0x01000000)},actions = {SetCWar("X",FSCANW[4],Add,{CBit*NBit})},flag = {Preserved}}
					end
					Trigger {players = {IncludePlayer},conditions = {Label()},actions = {SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X","X",0x0,0,1),
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,-2),SetMemory(0x6509B0,Subtract,604),SetCVar("X",FSCANW[5],Subtract,604),SetCVar("X",FSCANW[7],Subtract,1),
					SetCtrigX("X",FuncAlloc+1,0x4,0,SetTo,"X",FuncAlloc+1,0x0,0,1+(j+9)*5),Box},flag = {Preserved}}
				end
				FuncAlloc = FuncAlloc + 1
			NElseIfX({CVar("X",FSCANW[7],AtLeast,1),CVar("X",FSCANW[6],Exactly,0,1),CVar("X",FSCANW[5],AtLeast,604),DeathsX(CurrentPlayer,AtLeast,0x61000000,0,0xFF000000),DeathsX(CurrentPlayer,AtMost,0x66000000,0,0xFF000000)},{SetCVar("X",FSCANW[6],SetTo,4,4)})
				Trigger {players = {IncludePlayer},conditions = {Label()},actions={SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc,0x0,0,0)},flag = {Preserved}}
			NElseIfX({CVar("X",FSCANW[7],AtLeast,1),CVar("X",FSCANW[6],Exactly,0,1),CVar("X",FSCANW[5],AtLeast,604),DeathsX(CurrentPlayer,AtLeast,0x41000000,0,0xFF000000),DeathsX(CurrentPlayer,AtMost,0x46000000,0,0xFF000000)},{SetCVar("X",FSCANW[6],SetTo,4,4)})
				Trigger {players = {IncludePlayer},conditions = {Label(FuncAlloc)},flag = {Preserved}}
				for j = 0, 7 do	-- Digit 1~8
					local NBit = 16^j
					Trigger {players = {IncludePlayer},conditions = {Label()},actions = {SetCWar("X",FSCANW[4],Add,9*NBit)},flag = {Preserved}}
					for i = 0, 2 do
						local CBit = 2^i
						Trigger {players = {IncludePlayer},conditions = {Label(),DeathsX(CurrentPlayer,Exactly,CBit*0x01000000,0,CBit*0x01000000)},actions = {SetCWar("X",FSCANW[4],Add,CBit*NBit)},flag = {Preserved}}
					end
					Trigger {players = {IncludePlayer},conditions = {Label()},actions = {SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X","X",0x0,0,1),
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc-1,0x0,0,-2),SetMemory(0x6509B0,Subtract,604),SetCVar("X",FSCANW[5],Subtract,604),SetCVar("X",FSCANW[7],Subtract,1),
					SetCtrigX("X",FuncAlloc-1,0x4,0,SetTo,"X",FuncAlloc-1,0x0,0,1+(j+1)*5)},flag = {Preserved}}
				end
				for j = 0, 7 do	-- Digit 9~16
					if j == 7 then Box = {SetCVar("X",FSCANW[6],SetTo,1,1)} else Box = {} end
					local NBit = 16^j
					Trigger {players = {IncludePlayer},conditions = {Label()},actions = {SetCWar("X",FSCANW[4],Add,{9*NBit})},flag = {Preserved}}
					for i = 0, 2 do
						local CBit = 2^i
						Trigger {players = {IncludePlayer},conditions = {Label(),DeathsX(CurrentPlayer,Exactly,CBit*0x01000000,0,CBit*0x01000000)},actions = {SetCWar("X",FSCANW[4],Add,{CBit*NBit})},flag = {Preserved}}
					end
					Trigger {players = {IncludePlayer},conditions = {Label()},actions = {SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X","X",0x0,0,1),
					SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc-1,0x0,0,-2),SetMemory(0x6509B0,Subtract,604),SetCVar("X",FSCANW[5],Subtract,604),SetCVar("X",FSCANW[7],Subtract,1),
					SetCtrigX("X",FuncAlloc-1,0x4,0,SetTo,"X",FuncAlloc-1,0x0,0,1+(j+9)*5),Box},flag = {Preserved}}
				end
				FuncAlloc = FuncAlloc + 1
			NElseIfX({CVar("X",FSCANW[7],AtLeast,1),CVar("X",FSCANW[6],Exactly,0,1),CVar("X",FSCANW[5],AtLeast,604),DeathsX(CurrentPlayer,Exactly,0x20000000,0,0xFF000000)}) -- ' '
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc-2,0x0,0,-2);
						SetMemory(0x6509B0,Subtract,604);
						SetCVar("X",FSCANW[5],Subtract,604);
						SetCVar("X",FSCANW[7],Subtract,1);
					},
					flag = {Preserved}
				}
			NElseIfX({CVar("X",FSCANW[7],AtLeast,2),CVar("X",FSCANW[6],Exactly,0,2),CVar("X",FSCANW[5],AtLeast,604*2),DeathsX(CurrentPlayer,Exactly,0x78000000,0,0xFF000000)},{SetCVar("X",FSCANW[6],SetTo,4,4)}) -- 0x 
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc-2,0x0,0,-2);
						SetMemory(0x6509B0,Subtract,604*2);
						SetCVar("X",FSCANW[5],Subtract,604*2);
						SetCVar("X",FSCANW[7],Subtract,2);
						SetCVar("X",FSCANW[6],SetTo,3,3);
					},
					flag = {Preserved}
				}
			NElseIfX({CVar("X",FSCANW[7],AtLeast,1),CVar("X",FSCANW[2],AtLeast,1),CVar("X",FSCANW[5],AtLeast,604),DeathsX(CurrentPlayer,Exactly,0x2D000000,0,0xFF000000)},{SetCVar("X",FSCANW[6],SetTo,4,4)}) -- -	
				Trigger {
						players = {IncludePlayer},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0xFFFFFFFF);
							SetCtrigX("X",FSCANW[4],0x158,0,SetTo,"X",WRet[1],0x15C,1,0);
							SetCtrigX("X",FSCANW[4],0x198,0,SetTo,"X",WRet[1],0x19C,1,0);
							SetCtrig1X("X",FSCANW[4],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FSCANW[4],0x188,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FSCANW[4],0x160,0,SetTo,Subtract*16777216,0xFF000000);
							SetCtrig1X("X",FSCANW[4],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);

							SetCtrigX("X",WRet[1],0x158,0,SetTo,"X",FSCANW[4],0x15C,1,0);
							SetCtrigX("X",WRet[1],0x198,0,SetTo,"X",FSCANW[4],0x19C,1,0);
							SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",WRet[1],0x188,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways2("X",FSCANW[4],0,"X",WRet[1],0);
						},
						flag = {Preserved}
					}
				Trigger {
						players = {IncludePlayer},
						conditions = {
							Label(0);
							CtrigX("X",FSCANW[4],0x15C,0,Exactly,0xFFFFFFFF);
						},
						actions = {
							SetCtrig1X("X",FSCANW[4],0x19C,0,Add,1);
						},
						flag = {Preserved}
					}	
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetCtrig1X("X",FSCANW[4],0x15C,0,Add,1);
						SetMemory(0x6509B0,Subtract,604);
						SetCVar("X",FSCANW[5],Subtract,604);
						SetCVar("X",FSCANW[7],Subtract,1);
						SetCVar("X",FSCANW[6],SetTo,1,1);
					},
					flag = {Preserved}
				}
			NElseIfX({CVar("X",FSCANW[7],AtLeast,1),CVar("X",FSCANW[5],AtLeast,604),CVar("X",FSCANW[6],Exactly,0,4)})
				Trigger {
					players = {IncludePlayer},
					conditions = {
						Label();
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FuncAlloc-2,0x0,0,-2);
						SetMemory(0x6509B0,Subtract,604);
						SetCVar("X",FSCANW[5],Subtract,604);
						SetCVar("X",FSCANW[7],Subtract,1);
					},
					flag = {Preserved}
				}
			NIfXEnd() -- 나머지 (TapeStop)
		CIfXEnd()

		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FSCANWCall2);
				},
				flag = {Preserved}
			}
end
-----------------------------------------------------------
-- f_Encode - Ret[1] : Dest / Ret[2] : Source / Ret[3] : Size / Ret[4] : cp949flag / Ret[5] : Temp / Ret[6] : Ret
if FENCDCheck == 1 then
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FENCDCall1);
				},
				actions = {
					SetCtrig1X("X",FENCD[2],0x158,0,SetTo,EPD(0x6509B0));
					SetCtrig1X("X",FENCD[2],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",FENCD[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",FENCD[2],0);	
				},
				flag = {Preserved}
			}

		CIfX(IncludePlayer,CVar("X",FENCD[4],AtLeast,1))
			CWhile(IncludePlayer,{CVar("X",FENCD[3],AtLeast,1)},{SetCVar("X",FENCD[3],Subtract,1)})
				CIfX(IncludePlayer,DeathsX(CurrentPlayer,Exactly,0xE000,0,0xFF00))
					Trigger {
						players = {IncludePlayer},
						conditions = {
							Label();
						},
						actions = {
							SetCtrigX("X",FENCD[5],0x15C,0,SetTo,"X",0xF001,0x970,1,0);
							SetCVar("X",FENCD[5],Add,-0x2080); -- EABCDF -> A(BC-0x80)*4+(D-8)F	
							SetCVar("X",FENCD[6],SetTo,0x0D00);
						},
						flag = {Preserved}
					}

					for i = 7, 0, -1 do local CBit = 2^i
						TriggerX(IncludePlayer,{DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)},{SetCVar("X",FENCD[6],Add,CBit)},{Preserved}) -- ColorCode
					end
					for i = 11, 8, -1 do local CBit = 2^i
						TriggerX(IncludePlayer,{DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)},{SetCVar("X",FENCD[5],Add,CBit*16)},{Preserved}) -- __ 0xE(A) 0xBC 0xDF
					end
					for i = 23, 16, -1 do local CBit = 2^i
						TriggerX(IncludePlayer,{DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)},{SetCVar("X",FENCD[5],Add,CBit/4)},{Preserved}) -- __ 0xEA 0x(BC) 0xDF
					end
					for i = 31, 28, -1 do local CBit = 2^i
						TriggerX(IncludePlayer,{DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)},{SetCVar("X",FENCD[5],Add,CBit/16777216)},{Preserved}) -- __ 0xEA 0xBC 0x(D)F
					end
					for i = 27, 24, -1 do local CBit = 2^i
						TriggerX(IncludePlayer,{DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)},{SetCVar("X",FENCD[5],Add,CBit/16777216)},{Preserved}) -- __ 0xEA 0xBC 0xD(F)
					end

					Trigger {
						players = {IncludePlayer},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X("X",FENCD[5],0x158,0,SetTo,EPD(0x6509B0));
							SetCtrig1X("X",FENCD[5],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FENCD[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",FENCD[5],0);	
						},
						flag = {Preserved}
					}
					for i = 31, 16, -1 do local CBit = 2^i
						TriggerX(IncludePlayer,{DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)},{SetCVar("X",FENCD[6],Add,CBit)},{Preserved}) -- __ __ 0x81 0x41
					end

					Trigger {
						players = {IncludePlayer},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X("X",FENCD[2],0x158,0,SetTo,EPD(0x6509B0));
							SetCtrig1X("X",FENCD[2],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FENCD[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",FENCD[1],0x158,0,SetTo,"X","X",0x158,1,1);
							SetCtrig1X("X",FENCD[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FENCD[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",FENCD[6],0x158,0,SetTo,"X","X",0x15C,1,1);
							SetCtrig1X("X",FENCD[6],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FENCD[6],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways3("X",FENCD[2],0,"X",FENCD[1],0,"X",FENCD[6],0);	
						},
						flag = {Preserved}
					}
					Trigger {
						players = {IncludePlayer},
						conditions = {
							Label();
						},
						actions = {
							SetDeathsX(0,SetTo,0,0,0xFFFFFFFF);
						},
						flag = {Preserved}
					}
				CElseX(SetCVar("X",FENCD[6],SetTo,0))
					for i = 31, 0, -1 do local CBit = 2^i
						TriggerX(IncludePlayer,{DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)},{SetCVar("X",FENCD[6],Add,CBit)},{Preserved})
					end
					Trigger {
						players = {IncludePlayer},
						conditions = {
							Label();
						},
						actions = {
							SetCtrigX("X",FENCD[1],0x158,0,SetTo,"X","X",0x158,1,1);
							SetCtrig1X("X",FENCD[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FENCD[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",FENCD[6],0x158,0,SetTo,"X","X",0x15C,1,1);
							SetCtrig1X("X",FENCD[6],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FENCD[6],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways2("X",FENCD[1],0,"X",FENCD[6],0);	
						},
						flag = {Preserved}
					}
					Trigger {
						players = {IncludePlayer},
						conditions = {
							Label();
						},
						actions = {
							SetDeathsX(0,SetTo,0,0,0xFFFFFFFF);
						},
						flag = {Preserved}
					}
			 	CIfXEnd()
			CWhileEnd({SetCVar("X",FENCD[1],Add,604),SetCVar("X",FENCD[2],Add,604),SetMemory(0x6509B0,Add,604)})
		CElseX()
			CWhile(IncludePlayer,{CVar("X",FENCD[3],AtLeast,1)},{SetCVar("X",FENCD[3],Subtract,1)})
				CIfX(IncludePlayer,DeathsX(CurrentPlayer,AtLeast,0x800000,0,0xFF0000))
					Trigger {
						players = {IncludePlayer},
						conditions = {
							Label();
						},
						actions = {
							SetCtrigX("X",FENCD[5],0x15C,0,SetTo,"X",0xF001,0x970,1,0);
							SetCVar("X",FENCD[5],Add,0x20000-0x8141); -- EABCDF -> A(BC-0x80)*4+(D-8)F	
							SetCVar("X",FENCD[6],SetTo,0x00);
						},
						flag = {Preserved}
					}

					for i = 7, 0, -1 do local CBit = 2^i
						TriggerX(IncludePlayer,{DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)},{SetCVar("X",FENCD[6],Add,CBit)},{Preserved}) -- ColorCode
					end
					for i = 23, 16, -1 do local CBit = 2^i
						TriggerX(IncludePlayer,{DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)},{SetCVar("X",FENCD[5],Add,CBit/256)},{Preserved}) -- __ __ 0x81 0x41
					end
					for i = 31, 24, -1 do local CBit = 2^i
						TriggerX(IncludePlayer,{DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)},{SetCVar("X",FENCD[5],Add,CBit/16777216)},{Preserved}) -- 0x41 0x81 __ __
					end
					
					Trigger {
						players = {IncludePlayer},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X("X",FENCD[5],0x158,0,SetTo,EPD(0x6509B0));
							SetCtrig1X("X",FENCD[5],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FENCD[5],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways("X",FENCD[5],0);	
						},
						flag = {Preserved}
					}
					for i = 31, 8, -1 do local CBit = 2^i
						TriggerX(IncludePlayer,{DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)},{SetCVar("X",FENCD[6],Add,CBit)},{Preserved}) -- __ 0xEA 0xBC 0xDF
					end

					Trigger {
						players = {IncludePlayer},
						conditions = {
							Label();
						},
						actions = {
							SetCtrig1X("X",FENCD[2],0x158,0,SetTo,EPD(0x6509B0));
							SetCtrig1X("X",FENCD[2],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FENCD[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",FENCD[1],0x158,0,SetTo,"X","X",0x158,1,1);
							SetCtrig1X("X",FENCD[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FENCD[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",FENCD[6],0x158,0,SetTo,"X","X",0x15C,1,1);
							SetCtrig1X("X",FENCD[6],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FENCD[6],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways3("X",FENCD[2],0,"X",FENCD[1],0,"X",FENCD[6],0);	
						},
						flag = {Preserved}
					}
					Trigger {
						players = {IncludePlayer},
						conditions = {
							Label();
						},
						actions = {
							SetDeathsX(0,SetTo,0,0,0xFFFFFFFF);
						},
						flag = {Preserved}
					}
				CElseX(SetCVar("X",FENCD[6],SetTo,0))
					for i = 31, 0, -1 do local CBit = 2^i
						TriggerX(IncludePlayer,{DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)},{SetCVar("X",FENCD[6],Add,CBit)},{Preserved})
					end
					Trigger {
						players = {IncludePlayer},
						conditions = {
							Label();
						},
						actions = {
							SetCtrigX("X",FENCD[1],0x158,0,SetTo,"X","X",0x158,1,1);
							SetCtrig1X("X",FENCD[1],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FENCD[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							SetCtrigX("X",FENCD[6],0x158,0,SetTo,"X","X",0x15C,1,1);
							SetCtrig1X("X",FENCD[6],0x148,0,SetTo,0xFFFFFFFF);
							SetCtrig1X("X",FENCD[6],0x160,0,SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways2("X",FENCD[1],0,"X",FENCD[6],0);	
						},
						flag = {Preserved}
					}
					Trigger {
						players = {IncludePlayer},
						conditions = {
							Label();
						},
						actions = {
							SetDeathsX(0,SetTo,0,0,0xFFFFFFFF);
						},
						flag = {Preserved}
					}
			 	CIfXEnd()
			CWhileEnd({SetCVar("X",FENCD[1],Add,604),SetCVar("X",FENCD[2],Add,604),SetMemory(0x6509B0,Add,604)})
		CIfXEnd()
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(FENCDCall2);
				},
				flag = {Preserved}
			}
end
-----------------------------------------------------------
if FLDivCheck == 1 then
	--------------------- f_LiDiv-------------------------------------------------------
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FLIDIVCall1); -- FLIDIV1
				},
				flag = {Preserved}
			}
		CIfX(IncludePlayer,CtrigX("X",WRet[4],0x19C,0,AtLeast,0x80000000))
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,1); -- Sflag
						SetCtrig1X("X",WRet[4],0x15C,0,Add,-1);
						SetCtrig1X("X",WRet[2],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[2],0x19C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",WRet[4],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
						SetCtrigX("X",WRet[4],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
						SetCtrig1X("X",WRet[4],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[4],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[4],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						SetCtrig1X("X",WRet[4],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",WRet[4],0);
					},
					flag = {Preserved}
				}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",WRet[2],0x15C,0,Exactly,0);
				},
				actions = {
					SetCtrig1X("X",WRet[2],0x19C,0,Add,1);
				},
				flag = {Preserved}
			}	
		CElseX()
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0); -- Sflag
						SetCtrigX("X",WRet[4],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
						SetCtrigX("X",WRet[4],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
						SetCtrig1X("X",WRet[4],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[4],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",WRet[4],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",WRet[4],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()

		CIfX(IncludePlayer,CtrigX("X",WRet[3],0x19C,0,AtLeast,0x80000000))
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,Add,1,0x1); -- Sflag
						SetCtrig1X("X",WRet[3],0x15C,0,Add,-1);
						SetCtrig1X("X",FLDivAlloc+5,0x15C+0x20*0,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLDivAlloc+5,0x15C+0x20*3,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FLDivAlloc+5,0x15C+0x20*3,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FLDivAlloc+5,0x15C+0x20*0,1,0);
						SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[3],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",FLDivAlloc+5,0x15C+0x20*1,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLDivAlloc+5,0x15C+0x20*4,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FLDivAlloc+5,0x15C+0x20*4,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FLDivAlloc+5,0x15C+0x20*1,1,0);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",FLDivAlloc+5,0x15C+0x20*2,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLDivAlloc+5,0x15C+0x20*5,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FLDivAlloc+5,0x15C+0x20*5,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FLDivAlloc+5,0x15C+0x20*2,1,0);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",FLDivAlloc+5,0x15C+0x20*3,0,Exactly,0);
				},
				actions = {
					SetCtrig1X("X",FLDivAlloc+5,0x15C+0x20*0,0,Add,1);
					SetCtrig1X("X",FLDivAlloc+5,0x15C+0x20*1,0,Add,1);
					SetCtrig1X("X",FLDivAlloc+5,0x15C+0x20*2,0,Add,1);
				},
				flag = {Preserved}
			}	
		CElseX()
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FLDivAlloc+5,0x15C+0x20*3,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FLDivAlloc+5,0x15C+0x20*0,1,0);
						SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FLDivAlloc+5,0x15C+0x20*4,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FLDivAlloc+5,0x15C+0x20*1,1,0);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FLDivAlloc+5,0x15C+0x20*5,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FLDivAlloc+5,0x15C+0x20*2,1,0);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- /0
					CtrigX("X",WRet[3],0x15C,0,Exactly,0);
					CtrigX("X",WRet[3],0x19C,0,Exactly,0);
					CtrigX("X",CRet[1],0x15C,0,Exactly,0,0x1);
				},
				actions = {
					SetCtrig1X("X",WRet[4],0x19C,0,SetTo,0x7FFFFFFF); 
					SetCtrig1X("X",WRet[4],0x15C,0,SetTo,0xFFFFFFFF); 
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLDivAlloc+7,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FLDivAlloc+7,0x4,0,SetTo,"X",FLDivAlloc+13,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FLDivAlloc+7,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FLDivAlloc+7,0x15C,0,SetTo,"X","X",0,0,1);

				},
				flag = {Preserved}
			}

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- /0
					CtrigX("X",WRet[3],0x15C,0,Exactly,0);
					CtrigX("X",WRet[3],0x19C,0,Exactly,0);
					CtrigX("X",CRet[1],0x15C,0,Exactly,1,0x1);
				},
				actions = {
					SetCtrig1X("X",WRet[4],0x19C,0,SetTo,0x80000000); 
					SetCtrig1X("X",WRet[4],0x15C,0,SetTo,0x00000000); 
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLDivAlloc+7,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FLDivAlloc+7,0x4,0,SetTo,"X",FLDivAlloc+13,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FLDivAlloc+7,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FLDivAlloc+7,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- FIDIV1
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLDivAlloc+4,0x0,0,0); -- goto Div Calc Start
					SetCtrigX("X",FLDivAlloc+7,0x4,0,SetTo,"X",FLDivAlloc+12,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FLDivAlloc+7,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FLDivAlloc+7,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}
		
	FLDivAlloc = FLDivAlloc + 1
--------------------- f_LiMod-------------------------------------------------------

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FLIMODCall1); -- FLIMOD1
				},
				flag = {Preserved}
			}

		CIfX(IncludePlayer,CtrigX("X",WRet[4],0x19C,0,AtLeast,0x80000000))
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,1); -- Sflag
						SetCtrig1X("X",WRet[4],0x15C,0,Add,-1);
						SetCtrig1X("X",WRet[2],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[2],0x19C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",WRet[4],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
						SetCtrigX("X",WRet[4],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
						SetCtrig1X("X",WRet[4],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[4],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[4],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						SetCtrig1X("X",WRet[4],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",WRet[4],0);
					},
					flag = {Preserved}
				}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",WRet[2],0x15C,0,Exactly,0);
				},
				actions = {
					SetCtrig1X("X",WRet[2],0x19C,0,Add,1);
				},
				flag = {Preserved}
			}	
		CElseX()
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0); -- Sflag
						SetCtrigX("X",WRet[4],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
						SetCtrigX("X",WRet[4],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
						SetCtrig1X("X",WRet[4],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[4],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[4],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",WRet[4],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",WRet[4],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()

		CIfX(IncludePlayer,CtrigX("X",WRet[3],0x19C,0,AtLeast,0x80000000))
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",WRet[3],0x15C,0,Add,-1);
						SetCtrig1X("X",FLDivAlloc+4,0x15C+0x20*0,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLDivAlloc+4,0x15C+0x20*3,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FLDivAlloc+4,0x15C+0x20*3,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FLDivAlloc+4,0x15C+0x20*0,1,0);
						SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[3],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",FLDivAlloc+4,0x15C+0x20*1,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLDivAlloc+4,0x15C+0x20*4,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FLDivAlloc+4,0x15C+0x20*4,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FLDivAlloc+4,0x15C+0x20*1,1,0);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",FLDivAlloc+4,0x15C+0x20*2,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",FLDivAlloc+4,0x15C+0x20*5,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FLDivAlloc+4,0x15C+0x20*5,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FLDivAlloc+4,0x15C+0x20*2,1,0);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",FLDivAlloc+4,0x15C+0x20*3,0,Exactly,0);
				},
				actions = {
					SetCtrig1X("X",FLDivAlloc+4,0x15C+0x20*0,0,Add,1);
					SetCtrig1X("X",FLDivAlloc+4,0x15C+0x20*1,0,Add,1);
					SetCtrig1X("X",FLDivAlloc+4,0x15C+0x20*2,0,Add,1);
				},
				flag = {Preserved}
			}	
		CElseX()
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FLDivAlloc+4,0x15C+0x20*3,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FLDivAlloc+4,0x15C+0x20*0,1,0);
						SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FLDivAlloc+4,0x15C+0x20*4,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FLDivAlloc+4,0x15C+0x20*1,1,0);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FLDivAlloc+4,0x15C+0x20*5,1,0);
						SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FLDivAlloc+4,0x15C+0x20*2,1,0);
						CallLabelAlways("X",WRet[3],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- /0
					CtrigX("X",CRet[1],0x15C,0,Exactly,0,1);
					CtrigX("X",WRet[3],0x15C,0,Exactly,0);
					CtrigX("X",WRet[3],0x19C,0,Exactly,0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLDivAlloc+6,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FLDivAlloc+6,0x4,0,SetTo,"X",FLDivAlloc+10,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FLDivAlloc+6,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FLDivAlloc+6,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- /0
					CtrigX("X",CRet[1],0x15C,0,Exactly,1,1);
					CtrigX("X",WRet[3],0x15C,0,Exactly,0);
					CtrigX("X",WRet[3],0x19C,0,Exactly,0);
				},
				actions = {
					SetCtrig1X("X",WRet[4],0x15C,0,Add,1);
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLDivAlloc+6,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FLDivAlloc+6,0x4,0,SetTo,"X",FLDivAlloc+10,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FLDivAlloc+6,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FLDivAlloc+6,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLDivAlloc+3,0x0,0,0); -- goto Div Calc Start
					SetCtrigX("X",FLDivAlloc+6,0x4,0,SetTo,"X",FLDivAlloc+9,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FLDivAlloc+6,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FLDivAlloc+6,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}

	FLDivAlloc = FLDivAlloc + 1
--------------------- f_LDiv-------------------------------------------------------
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FLDIVCall1); -- FLDIV1
				},
				actions = {
					SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FLDivAlloc+3,0x15C+0x20*3,1,0);
					SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FLDivAlloc+3,0x15C+0x20*0,1,0);
					SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",WRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",WRet[3],0);
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FLDivAlloc+3,0x15C+0x20*4,1,0);
					SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FLDivAlloc+3,0x15C+0x20*1,1,0);
					CallLabelAlways("X",WRet[3],0);
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- /0
					CtrigX("X",WRet[3],0x15C,0,Exactly,0);
					CtrigX("X",WRet[3],0x19C,0,Exactly,0);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0xFFFFFFFF);
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLDivAlloc+5,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FLDivAlloc+5,0x4,0,SetTo,"X",FLDivAlloc+7,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FLDivAlloc+5,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FLDivAlloc+5,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FLDivAlloc+3,0x15C+0x20*5,1,0);
					SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FLDivAlloc+3,0x15C+0x20*2,1,0);
					SetCtrigX("X","X",0x4,0,SetTo,"X",WRet[3],0x0,0,0);
					SetCtrigX("X",WRet[3],0x4,0,SetTo,"X",FLDivAlloc+2,0x0,0,0); -- goto Div Calc Start
					SetCtrigX("X",FLDivAlloc+5,0x4,0,SetTo,"X",FLDivAlloc+7,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FLDivAlloc+5,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FLDivAlloc+5,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}
		


	FLDivAlloc = FLDivAlloc + 1

--------------------- f_Mod-------------------------------------------------------
	Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FLMODCall1); -- FLDIV1
				},
				actions = {
					SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FLDivAlloc+2,0x15C+0x20*3,1,0);
					SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FLDivAlloc+2,0x15C+0x20*0,1,0);
					SetCtrig1X("X",WRet[3],0x148,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",WRet[3],0x188,0,SetTo,0xFFFFFFFF);
					SetCtrig1X("X",WRet[3],0x160,0,SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X("X",WRet[3],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways("X",WRet[3],0);
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FLDivAlloc+2,0x15C+0x20*4,1,0);
					SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FLDivAlloc+2,0x15C+0x20*1,1,0);
					CallLabelAlways("X",WRet[3],0);
				},
				flag = {Preserved}
			}
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0); -- /0
					CtrigX("X",WRet[3],0x15C,0,Exactly,0);
					CtrigX("X",WRet[3],0x19C,0,Exactly,0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLDivAlloc+4,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FLDivAlloc+4,0x4,0,SetTo,"X",FLDivAlloc+5,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FLDivAlloc+4,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FLDivAlloc+4,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X",WRet[3],0x158,0,SetTo,"X",FLDivAlloc+2,0x15C+0x20*5,1,0);
					SetCtrigX("X",WRet[3],0x198,0,SetTo,"X",FLDivAlloc+2,0x15C+0x20*2,1,0);
					SetCtrigX("X","X",0x4,0,SetTo,"X",WRet[3],0x0,0,0);
					SetCtrigX("X",WRet[3],0x4,0,SetTo,"X",FLDivAlloc+1,0x0,0,0); -- goto Div Calc Start
					SetCtrigX("X",FLDivAlloc+4,0x4,0,SetTo,"X",FLDivAlloc+5,0x0,0,0); -- 분기점 -> End
					SetCtrigX("X",FLDivAlloc+4,0x158,0,SetTo,"X","X",0x4,1,0);
					SetCtrigX("X",FLDivAlloc+4,0x15C,0,SetTo,"X","X",0,0,1);
				},
				flag = {Preserved}
			}


	FLDivAlloc = FLDivAlloc + 1

-------------------------------------------------------------------------------------------------------

		-- WRet[2] = X / WRet[3] = Y / Q = WRet[1], R = WRet[2]

		Trigger { -- Clear Value
				players = {IncludePlayer},
				conditions = {
					Label(FLDivAlloc);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
					SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);
					SetCtrigX("X",FLDivAlloc+1,0x15C+0x20*12,0,SetTo,"X",FLDivAlloc+1,0,0,1); -- X -> B+1
					SetCtrigX("X",FLDivAlloc+1,0x158+0x20*0,0,SetTo,"X",FLDivAlloc+1,0x15C+0x20*0,1,0); -- X_epd -> X
					SetCtrigX("X",FLDivAlloc+1,0x158+0x20*1,0,SetTo,"X",FLDivAlloc+1,0x15C+0x20*1,1,0); -- X_epd -> X
					SetCtrigX("X",FLDivAlloc+1,0x158+0x20*2,0,SetTo,"X",FLDivAlloc+1,0x15C+0x20*2,1,0); -- X_epd -> X
					SetCtrigX("X",FLDivAlloc+1,0x158+0x20*3,0,SetTo,"X",FLDivAlloc+1,0x15C+0x20*3,1,0); -- X_epd -> X
					SetCtrigX("X",FLDivAlloc+1,0x158+0x20*4,0,SetTo,"X",FLDivAlloc+1,0x15C+0x20*4,1,0); -- X_epd -> X
					SetCtrigX("X",FLDivAlloc+1,0x158+0x20*5,0,SetTo,"X",FLDivAlloc+1,0x15C+0x20*5,1,0); -- X_epd -> X
				},
				flag = {Preserved}
			}

		FLDivAlloc = FLDivAlloc + 1

		local ClearNext3 = {}
		for i = 0, 63 do
			table.insert(ClearNext3,SetCtrigX("X",FLDivAlloc+1,0x4,i+1,SetTo,"X",FLDivAlloc+1,0x0,0,i-64)) -- W -> CRet
		end

		Trigger { -- Clear Next (-10)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					ClearNext3,
				},
				flag = {Preserved}
			}

		local ClearNext2 = {}
		for i = 0, 63 do
			table.insert(ClearNext2,SetCtrigX("X",FLDivAlloc+1,0x4,256-3*i-2,SetTo,"X",FLDivAlloc+1,0x0,0,256-3*i-1)) -- RecoverNext
		end

		Trigger { -- Clear Next (-9)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					ClearNext2,
				},
				flag = {Preserved}
			}

		local ClearNext = {}
		for i = 1, 64 do
			table.insert(ClearNext,SetCtrigX("X",FLDivAlloc,0x4,i,SetTo,"X",FLDivAlloc,0,0,i+64)) -- B -> BF
		end

		Trigger { -- Clear Next (-8)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					ClearNext,
				},
				flag = {Preserved}
			}

		local ClearRet1 = {}
		for i = 0, 63 do
			table.insert(ClearRet1,SetCtrig1X("X",FLDivAlloc+1,0x19C,64-i,SetTo,0))
		end

		Trigger { -- Clear Ret (-7)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					ClearRet1,
				},
				flag = {Preserved}
			}

		local ClearRet2 = {}
		for i = 0, 63 do
			table.insert(ClearRet2,SetCtrig1X("X",FLDivAlloc+1,0x24,256-3*i-0,SetTo,0))
		end

		Trigger { -- Clear Ret (-6)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					ClearRet2,
				},
				flag = {Preserved}
			}

		local ClearRet3 = {}
		for i = 0, 63 do
			table.insert(ClearRet3,SetCtrig1X("X",FLDivAlloc+1,0x24,256-3*i-2,SetTo,0))
		end

		Trigger { -- Clear Ret (-5)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					ClearRet3,
				},
				flag = {Preserved}
			}

		local ClearRet4 = {}
		for i = 0, 63 do
			table.insert(ClearRet4,SetCtrig1X("X",FLDivAlloc+1,0x15C,64-i,SetTo,0))
		end

		Trigger { -- Clear Ret (-4)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					ClearRet4,
				},
				flag = {Preserved}
			}

		local ClearRet5 = {}
		for i = 0, 63 do
			table.insert(ClearRet5,SetCtrig1X("X",FLDivAlloc+1,0x38,256-3*i-0,SetTo,0))
		end

		Trigger { -- Clear Ret (-3)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					ClearRet5,
				},
				flag = {Preserved}
			}

		local ClearRet6 = {}
		for i = 0, 63 do
			table.insert(ClearRet6,SetCtrig1X("X",FLDivAlloc+1,0x24,256-3*i-1,SetTo,0))
		end

		Trigger { -- Clear Ret (-2)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					ClearRet6,
				},
				flag = {Preserved}
			}

		Trigger { -- A (-1) -> X
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",FLDivAlloc,0x15C+0x20*3,0,AtLeast,0x80000000); -- VL >= 0x80000000 -> VH + 1
				},
				actions = {
					SetCtrig1X("X",FLDivAlloc,0x164+0x20*6,0,SetTo,0x0,0x2); -- enable
					SetCtrig1X("X",FLDivAlloc,0x164+0x20*7,0,SetTo,0x0,0x2); -- enable
					SetCtrig1X("X",FLDivAlloc,0x164+0x20*8,0,SetTo,0x0,0x2); -- enable
				},
				flag = {Preserved}
			}

		Trigger { -- X (0)
				players = {IncludePlayer},
				conditions = {
					Label(FLDivAlloc);
				},
				actions = {
					SetMemoryX(0,Add,0,0xFFFFFFFF); -- VH
					SetMemoryX(0,Add,0,0xFFFFFFFF); -- VH
					SetMemoryX(0,Add,0,0xFFFFFFFF); -- VH
					SetMemoryX(0,Add,0,0xFFFFFFFF); -- VL
					SetMemoryX(0,Add,0,0xFFFFFFFF); -- VL
					SetMemoryX(0,Add,0,0xFFFFFFFF); -- VL
					Disabled(SetCtrig1X("X","X",0x15C+0x20*0,0,Add,1)); -- VH + 1
					Disabled(SetCtrig1X("X","X",0x15C+0x20*1,0,Add,1)); -- VH + 1
					Disabled(SetCtrig1X("X","X",0x15C+0x20*2,0,Add,1)); -- VH + 1
					SetCtrig1X("X","X",0x164+0x20*6,0,SetTo,0x2,0x2); -- disable
					SetCtrig1X("X","X",0x164+0x20*7,0,SetTo,0x2,0x2); -- disable
					SetCtrig1X("X","X",0x164+0x20*8,0,SetTo,0x2,0x2); -- disable
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLDivAlloc,0,0,1); -- X -> B+1
					--------------------------------
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLDivAlloc,0,0,-1); -- X -> A
					SetCtrig1X("X",FLDivAlloc,0x15C+0x20*12,0,Add,0x970); -- X -> B+1 + i
					SetCtrigX("X",FLDivAlloc,0x158+0x20*0,0,SetTo,"X",FLDivAlloc,0x15C+0x20*0,1,0); -- X_epd -> X
					SetCtrigX("X",FLDivAlloc,0x158+0x20*1,0,SetTo,"X",FLDivAlloc,0x15C+0x20*1,1,0); -- X_epd -> X
					SetCtrigX("X",FLDivAlloc,0x158+0x20*2,0,SetTo,"X",FLDivAlloc,0x15C+0x20*2,1,0); -- X_epd -> X
					SetCtrigX("X",FLDivAlloc,0x158+0x20*3,0,SetTo,"X",FLDivAlloc,0x15C+0x20*3,1,0); -- X_epd -> X
					SetCtrigX("X",FLDivAlloc,0x158+0x20*4,0,SetTo,"X",FLDivAlloc,0x15C+0x20*4,1,0); -- X_epd -> X
					SetCtrigX("X",FLDivAlloc,0x158+0x20*5,0,SetTo,"X",FLDivAlloc,0x15C+0x20*5,1,0); -- X_epd -> X
					SetCtrig1X("X",FLDivAlloc,0x160+0x20*13,0,SetTo,0x000000,0xFF0000); -- Close
				},
				flag = {Preserved}
			}

		for i = 0, 63 do
			Trigger { -- B (1~64)
					players = {IncludePlayer},
					conditions = {
						Label(0);
						CtrigX("X",FLDivAlloc,0x15C+0x20*0,0,AtMost,0x7FFFFFFF); -- VH <= 0x7FFFFFFF
					},
					actions = {
						SetCtrigX("X","X",0x4,0,SetTo,"X",FLDivAlloc,0,0,0); -- B -> X
						SetCtrigX("X",FLDivAlloc,0x158+0x20*0,0,SetTo,"X",FLDivAlloc+1,0x19C,1,64-i); -- X_epd -> Ret
						SetCtrigX("X",FLDivAlloc,0x158+0x20*1,0,SetTo,"X",FLDivAlloc+1,0x24,1,256-3*i-0); -- X_epd -> Ret
						SetCtrigX("X",FLDivAlloc,0x158+0x20*2,0,SetTo,"X",FLDivAlloc+1,0x24,1,256-3*i-2); -- X_epd -> Ret
						SetCtrigX("X",FLDivAlloc,0x158+0x20*3,0,SetTo,"X",FLDivAlloc+1,0x15C,1,64-i); -- X_epd -> Ret
						SetCtrigX("X",FLDivAlloc,0x158+0x20*4,0,SetTo,"X",FLDivAlloc+1,0x38,1,256-3*i-0); -- X_epd -> Ret
						SetCtrigX("X",FLDivAlloc,0x158+0x20*5,0,SetTo,"X",FLDivAlloc+1,0x24,1,256-3*i-1); -- X_epd -> Ret
						SetCtrig1X("X",FLDivAlloc,0x160+0x20*13,0,SetTo,0x2D0000,0xFF0000); -- Open
					},
					flag = {Preserved}
				}
		end

		for i = 0, 63 do
			Trigger { -- BF (65~128)
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",FLDivAlloc,0x15C+0x20*12,0,SetTo,"X",FLDivAlloc+1,0,0,256-3*i-2); -- X -> Ret
						SetCtrigX("X",FLDivAlloc,0x158+0x20*0,0,SetTo,"X",FLDivAlloc+1,0x19C,1,64-i); -- X_epd -> Ret
						SetCtrigX("X",FLDivAlloc,0x158+0x20*1,0,SetTo,"X",FLDivAlloc+1,0x24,1,256-3*i-0); -- X_epd -> Ret
						SetCtrigX("X",FLDivAlloc,0x158+0x20*2,0,SetTo,"X",FLDivAlloc+1,0x24,1,256-3*i-2); -- X_epd -> Ret
						SetCtrigX("X",FLDivAlloc,0x158+0x20*3,0,SetTo,"X",FLDivAlloc+1,0x15C,1,64-i); -- X_epd -> Ret
						SetCtrigX("X",FLDivAlloc,0x158+0x20*4,0,SetTo,"X",FLDivAlloc+1,0x38,1,256-3*i-0); -- X_epd -> Ret
						SetCtrigX("X",FLDivAlloc,0x158+0x20*5,0,SetTo,"X",FLDivAlloc+1,0x24,1,256-3*i-1); -- X_epd -> Ret
					},
					flag = {Preserved}
				}
		end

		local PlayerID = IncludePlayer
		PlayerID = PlayerConvert(PlayerID)
		for k, P in pairs(PlayerID) do
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",FLDivAlloc,0x4,-2,SetTo,"X",FLDivAlloc,0x0,0,1)) -- Clear -> B1
			for i = 1, 64 do
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",FLDivAlloc,0x4,i+64,SetTo,"X",FLDivAlloc,0x0,0,0)) -- BF -> X
			end
		end

		FLDivAlloc = FLDivAlloc + 1

		for i = 0, 63 do
			Trigger { -- CRet (-1~-64)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X","X",0x17C,0,Add,1); -- CRet Add 1
					SetCtrig1X("X",WRet[2],0x15C,0,Add,0xFFFFFFFF); -- VL Add -D
					SetCtrig1X("X",WRet[2],0x19C,0,Subtract,1); -- A Sub 1
					SetCtrig1X("X","X",0x17C,0,SetTo,0xFFFFFFFF); -- CRet Clear
				},
				flag = {Preserved}
			}
		end

		Trigger { -- (0)
				players = {IncludePlayer},
				conditions = {
					Label(FLDivAlloc);
				},
				flag = {Preserved}
			}

		for i = 0, 31 do
			local CBit = 2^(31-i) -- 역행 2^63 -> 2^32
			Trigger { -- WRet (1~32)
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FLDivAlloc,0x17C,i-64,Subtract,0); -- XL - D
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit); -- Ret + 2^i
					SetCtrig1X("X",WRet[2],0x19C,0,Subtract,0); -- XH - C
					SetCtrigX("X",FLDivAlloc,0x4,67+3*i,SetTo,"X",FLDivAlloc,0x0,0,68+3*i); -- RecoverNext
					SetCtrigX("X","X",0x158,0,SetTo,"X",FLDivAlloc,0x17C,1,i-64); -- b -> CRet
				},
				flag = {Preserved}
			}
		end

		for i = 0, 31 do
			local CBit = 2^(31-i) -- 역행 2^31 -> 2^0
			Trigger { -- WRet (33~64) 
				players = {IncludePlayer},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X("X",FLDivAlloc,0x17C,i-32,Subtract,0); -- XL - D
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit); -- Ret + 2^i
					SetCtrig1X("X",WRet[2],0x19C,0,Subtract,0); -- XH - C
					SetCtrigX("X",FLDivAlloc,0x4,67+3*(i+32),SetTo,"X",FLDivAlloc,0x0,0,68+3*(i+32)); -- RecoverNext
					SetCtrigX("X","X",0x158,0,SetTo,"X",FLDivAlloc,0x17C,1,i-32); -- b -> CRet
				},
				flag = {Preserved}
			}
		end

		for i = 0, 63 do
			Trigger { -- (-2) (65~256) α
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",WRet[2],0x19C,0,AtMost,0); -- A <= C 
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,2); -- Next -> γ
				},
				flag = {Preserved}
			}
				Trigger { -- (-1) (65~256) β
					players = {IncludePlayer},
					conditions = {
						Label(0);
						CtrigX("X",WRet[2],0x15C,0,AtLeast,0); -- B >= D
					},
					actions = {
						SetCtrigX("X",FLDivAlloc,0x4,i+1,SetTo,"X","X",0x0,0,2); -- W -> Next
						SetCtrigX("X",FLDivAlloc,0x158,i+1,SetTo,"X",WRet[2],0x15C,1,0); -- b -> B ( -D)
					},
					flag = {Preserved}
				}
			Trigger { -- (-0) (65~256) γ
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",WRet[2],0x19C,0,Exactly,0); -- A == C
					CtrigX("X",WRet[2],0x15C,0,AtLeast,0); -- B >= D
				},
				actions = {
					SetCtrigX("X",FLDivAlloc,0x4,i+1,SetTo,"X","X",0x0,0,1); -- W -> Next
					SetCtrigX("X","X",0x4,0,SetTo,"X",FLDivAlloc,0x0,0,i+1); -- Next -> W
					SetCtrigX("X",FLDivAlloc,0x158,i+1,SetTo,"X",WRet[2],0x15C,1,0); -- b -> B ( -D)
				},
				flag = {Preserved}
			}
		end

		local PlayerID = IncludePlayer
		PlayerID = PlayerConvert(PlayerID)
		for k, P in pairs(PlayerID) do
			for i = 0, 63 do
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",FLDivAlloc,0x4,256-3*i-1,SetTo,"X",FLDivAlloc,0x0,0,64-i)) -- β -> W
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",FLDivAlloc,0x4,i-64,SetTo,"X",FLDivAlloc,0x0,0,68+3*i)) -- CRet -> Next
			end
		end

	FLDivAlloc = FLDivAlloc + 1
		

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FLDivAlloc); -- 분기점
				},
				actions = {
					SetMemory(0,SetTo,0); -- RecoverNext
				},
				flag = {Preserved}
			}
	FLDivAlloc = FLDivAlloc + 1

	--------------------- f_LMod End-------------------------------------------------------
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FLMODCall2); -- f_Mod End
				},
				flag = {Preserved}
			}

	FLDivAlloc = FLDivAlloc + 1
--------------------- f_LDiv End-------------------------------------------------------
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FLDIVCall2); -- f_Div End
				},
				flag = {Preserved}
			}

	FLDivAlloc = FLDivAlloc + 1

--------------------- f_LiMod End-------------------------------------------------------
		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FLDivAlloc); -- LIMod End Start
				},
				flag = {Preserved}
			}

		CIfX(IncludePlayer,CtrigX("X",CRet[1],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",WRet[2],0x15C,0,Add,-1);
						SetCtrig1X("X",WRet[4],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[4],0x19C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[4],0x15C,1,0);
						SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[4],0x19C,1,0);
						SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",WRet[2],0);
					},
					flag = {Preserved}
				}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",WRet[4],0x15C,0,Exactly,0);
				},
				actions = {
					SetCtrig1X("X",WRet[4],0x19C,0,Add,1);
				},
				flag = {Preserved}
			}	
		CElseX()
			Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[4],0x15C,1,0);
						SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[4],0x19C,1,0);
						SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",WRet[2],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()
	
	FLDivAlloc = FLDivAlloc + 1

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FLIMODCall2); -- Exit Func
				},
				flag = {Preserved}
			}

	FLDivAlloc = FLDivAlloc + 1

--------------------- f_LiDiv End-------------------------------------------------------

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FLDivAlloc); -- LIDiv End Start
				},
				flag = {Preserved}
			}

		CIfX(IncludePlayer,CtrigX("X",CRet[1],0x15C,0,Exactly,0x1,0x1)) -- Sflag == 1
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",WRet[1],0x15C,0,Add,-1);
						SetCtrig1X("X",WRet[4],0x15C,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[4],0x19C,0,SetTo,0xFFFFFFFF);
						SetCtrigX("X",WRet[1],0x158,0,SetTo,"X",WRet[4],0x15C,1,0);
						SetCtrigX("X",WRet[1],0x198,0,SetTo,"X",WRet[4],0x19C,1,0);
						SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[1],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
						SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
						CallLabelAlways("X",WRet[1],0);
					},
					flag = {Preserved}
				}
			Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
					CtrigX("X",WRet[4],0x15C,0,Exactly,0);
				},
				actions = {
					SetCtrig1X("X",WRet[4],0x19C,0,Add,1);
				},
				flag = {Preserved}
			}	
		CElseX()
			Trigger { 
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",WRet[1],0x158,0,SetTo,"X",WRet[4],0x15C,1,0);
						SetCtrigX("X",WRet[1],0x198,0,SetTo,"X",WRet[4],0x19C,1,0);
						SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[1],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",WRet[1],0);
					},
					flag = {Preserved}
				}
		CIfXEnd()
	
	FLDivAlloc = FLDivAlloc + 1

		Trigger { 
			players = {IncludePlayer},
				conditions = {
					Label(FLIDIVCall2); -- Exit Func
				},
				flag = {Preserved}
			}

	FLDivAlloc = FLDivAlloc + 1
------------------------------------------------------------------------------------------
end
-----------------------------------------------------------
if FLMulCheck == 1 then
	-- f_LMul / f_LiMul - FLMulAlloc+2 : X, WRet[3] : Y / WRet[1] = Output 

	Trigger {
		players = {IncludePlayer},
		conditions = { 
			Label(FLiMulCall1);
		},
		flag = {Preserved}
	}

	CIfX(IncludePlayer,CtrigX("X",WRet[2],0x19C,0,AtLeast,0x80000000))
		Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[3],0x15C,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[3],0x19C,0,SetTo,0xFFFFFFFF);
				SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[3],0x15C,1,0);
				SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[3],0x19C,1,0);
				SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x160,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
				CallLabelAlways("X",WRet[2],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CtrigX("X",WRet[3],0x15C,0,Exactly,0xFFFFFFFF);
			},
			actions = {
				SetCtrig1X("X",WRet[3],0x19C,0,Add,1);
			},
			flag = {Preserved}
		}	
		Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[1],0x15C,0,SetTo,1);
				SetCtrig1X("X",WRet[3],0x15C,0,Add,1);
			},
			flag = {Preserved}
		}
	CElseX()
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrig1X("X",CRet[1],0x15C,0,SetTo,0);
						SetCtrigX("X",WRet[2],0x158,0,SetTo,"X",WRet[3],0x15C,1,0);
						SetCtrigX("X",WRet[2],0x198,0,SetTo,"X",WRet[3],0x19C,1,0);
						SetCtrig1X("X",WRet[2],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[2],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",WRet[2],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",WRet[2],0);
					},
					flag = {Preserved}
				}
	CIfXEnd()

	Trigger {
		players = {IncludePlayer},
		conditions = { -- Ret = 0
			Label(FLMulCall1);
		},
		actions = {
			SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);
			SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
			SetCtrigX("X",FLMulAlloc+2,0x158+0x20*2,0,SetTo,"X",FLMulAlloc+2,0x15C+0x20*2,1,0); 
			SetCtrigX("X",FLMulAlloc+2,0x178+0x20*2,0,SetTo,"X",FLMulAlloc+2,0x17C+0x20*2,1,0); 
			SetCtrigX("X",FLMulAlloc+2,0x15C,0,SetTo,"X",FLMulAlloc+2,0,0,2);
			SetCtrig1X("X",FLMulAlloc+2,0x160+0x20*8,0,SetTo,0x0,0xFF0000);
		},
		flag = {Preserved}
	}

	for i = 31, 0, -1 do
		local CBit = 2^i
		Trigger { -- 1 ~ 32
			players = {IncludePlayer},
			conditions = { -- X Max Bit Check
				Label(0);
				CtrigX("X",WRet[3],0x19C,0,Exactly,CBit,CBit);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FLMulAlloc+2,0,0,1); -- Jump Calc
				SetCtrigX("X",FLMulAlloc+1,0x158,0,SetTo,"X","X",0x4,1,0); -- RecoverNext
				SetCtrigX("X",FLMulAlloc+1,0x15C,0,SetTo,"X","X",0,0,1); -- RecoverNext
				SetCtrigX("X",FLMulAlloc+2,0x158+0x20*6,0,SetTo,"X",FLMulAlloc+2,0x4-0x10*(i+32),1,0);
			},
			flag = {Preserved}
		}
	end
	for i = 31, 0, -1 do
		local CBit = 2^i
		Trigger { -- 33 ~ 64
			players = {IncludePlayer},
			conditions = { -- X Max Bit Check
				Label(0);
				CtrigX("X",WRet[3],0x15C,0,Exactly,CBit,CBit);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FLMulAlloc+2,0,0,1); -- Jump Calc
				SetCtrigX("X",FLMulAlloc+1,0x158,0,SetTo,"X","X",0x4,1,0); -- RecoverNext
				SetCtrigX("X",FLMulAlloc+1,0x15C,0,SetTo,"X","X",0,0,1); -- RecoverNext
				SetCtrigX("X",FLMulAlloc+2,0x158+0x20*6,0,SetTo,"X",FLMulAlloc+2,0x4-0x10*i,1,0);
			},
			flag = {Preserved}
		}
	end
	Trigger { -- 0
			players = {IncludePlayer},
			conditions = { -- X Max Bit Check
				Label(0);
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X",FLMulAlloc+1,0,0,0); -- Jump Calc
				SetCtrigX("X",FLMulAlloc+1,0x158,0,SetTo,"X","X",0x4,1,0); -- RecoverNext
				SetCtrigX("X",FLMulAlloc+1,0x15C,0,SetTo,"X","X",0,0,1); -- RecoverNext
			},
			flag = {Preserved}
		}
		
	Trigger { -- -2
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CtrigX("X",FLMulAlloc+2,0x15C+0x20*2,0,AtLeast,0x80000000);
			},
			actions = {
				SetCtrig1X("X",FLMulAlloc+2,0x164+0x20*4,0,SetTo,0x0,0x2);
			},
			flag = {Preserved}
		}
	Trigger { -- -1 (LoopN)
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			flag = {Preserved}
		}
	Trigger { -- LoopX 
			players = {IncludePlayer},
			conditions = {
				Label(FLMulIndex);
			},
			actions = {
				SetCtrig1X("X","X",0x4,0,SetTo,0);
				SetCtrig1X("X","X",0x15C,0,Add,0x970);
				SetMemoryX(0,Add,0,0xFFFFFFFF); -- Inline Variable VL
				SetMemoryX(0,Add,0,0xFFFFFFFF); -- Inline Variable VH
				Disabled(SetCtrig1X("X","X",0x17C+0x20*2,0,Add,1));
				SetCtrig1X("X","X",0x164+0x20*4,0,SetTo,0x2,0x2);
				SetCtrig2X(0,SetTo,"X",FLMulAlloc+1,0,0,0); -- Timer Action & Exit TRIG
				SetCtrig1X("X","X",0x158+0x20*6,0,Add,4); -- Run Tick
				-----------------------------------------------------------
				SetDeaths(0,SetTo,0,0); -- RecoverNext
				SetCtrigX("X",FLMulAlloc+2,0x158+0x20*2,0,SetTo,"X",FLMulAlloc+2,0x15C+0x20*2,1,0); -- X_epd -> X
				SetCtrigX("X",FLMulAlloc+2,0x178+0x20*2,0,SetTo,"X",FLMulAlloc+2,0x17C+0x20*2,1,0); 
				SetCtrig1X("X",FLMulAlloc+2,0x164+0x20*0,0,SetTo,0,0x2); -- enable 
				SetCtrig1X("X",FLMulAlloc+2,0x164+0x20*1,0,SetTo,0,0x2); -- enable
				SetCtrig1X("X",FLMulAlloc+2,0x160+0x20*8,0,SetTo,0x000000,0xFF0000);
			},
			flag = {Preserved}
		}
	for i = 0, 31 do
		local CBit = 2^i
		Trigger { -- 1 ~ 32
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CtrigX("X",WRet[3],0x15C,0,Exactly,CBit,CBit);
			},
			actions = {
				SetCtrigX("X",FLMulAlloc+2,0x158+0x20*2,0,SetTo,"X",WRet[1],0x15C,1,0); -- X_epd -> Ret
				SetCtrigX("X",FLMulAlloc+2,0x178+0x20*2,0,SetTo,"X",WRet[1],0x19C,1,0);
				SetCtrig1X("X",FLMulAlloc+2,0x164+0x20*0,0,SetTo,0x2,0x2); -- disable
				SetCtrig1X("X",FLMulAlloc+2,0x164+0x20*1,0,SetTo,0x2,0x2); -- disable
				SetCtrig1X("X",FLMulAlloc+2,0x160+0x20*8,0,SetTo,0x2D0000,0xFF0000);
				SetCtrig1X("X",FLMulAlloc+2,0x158+0x20*6,0,Add,-0x10/4);

				SetCtrigX("X",WRet[1],0x158,0,SetTo,"X",FLMulAlloc+3,0x24,1,0);
				SetCtrig1X("X",WRet[1],0x198,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x19C,0,Add,1); -- Carry 가불

				SetCtrigX("X","X",0x4,0,SetTo,"X",WRet[1],0x0,0,0);
				SetCtrigX("X",WRet[1],0x4,0,SetTo,"X",FLMulAlloc+2,0x0,0,0);
				SetCtrigX("X",FLMulAlloc+2,0x4,0,SetTo,"X",FLMulAlloc+3,0x0,0,0);
				SetCtrigX("X",FLMulAlloc+2,0x158+0x20*8,0,SetTo,"X","X",0x4,1,0);
				SetCtrigX("X",FLMulAlloc+2,0x15C+0x20*8,0,SetTo,"X",FLMulAlloc+2,0x0,0,-2);
			},
			flag = {Preserved}
		}
	end
	for i = 0, 31 do
		local CBit = 2^i
		Trigger { -- 33 ~ 64
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CtrigX("X",WRet[3],0x19C,0,Exactly,CBit,CBit);
			},
			actions = {
				SetCtrigX("X",FLMulAlloc+2,0x158+0x20*2,0,SetTo,"X",WRet[1],0x15C,1,0); -- X_epd -> Ret
				SetCtrigX("X",FLMulAlloc+2,0x178+0x20*2,0,SetTo,"X",WRet[1],0x19C,1,0);
				SetCtrig1X("X",FLMulAlloc+2,0x164+0x20*0,0,SetTo,0x2,0x2); -- disable
				SetCtrig1X("X",FLMulAlloc+2,0x164+0x20*1,0,SetTo,0x2,0x2); -- disable
				SetCtrig1X("X",FLMulAlloc+2,0x160+0x20*8,0,SetTo,0x2D0000,0xFF0000);
				SetCtrig1X("X",FLMulAlloc+2,0x158+0x20*6,0,Add,-0x10/4);

				SetCtrigX("X",WRet[1],0x158,0,SetTo,"X",FLMulAlloc+3,0x24,1,0);
				SetCtrig1X("X",WRet[1],0x198,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x19C,0,Add,1); -- Carry 가불

				SetCtrigX("X","X",0x4,0,SetTo,"X",WRet[1],0x0,0,0);
				SetCtrigX("X",WRet[1],0x4,0,SetTo,"X",FLMulAlloc+2,0x0,0,0);
				SetCtrigX("X",FLMulAlloc+2,0x4,0,SetTo,"X",FLMulAlloc+3,0x0,0,0);
				SetCtrigX("X",FLMulAlloc+2,0x158+0x20*8,0,SetTo,"X","X",0x4,1,0);
				SetCtrigX("X",FLMulAlloc+2,0x15C+0x20*8,0,SetTo,"X",FLMulAlloc+2,0x0,0,-2);
			},
			flag = {Preserved}
		}
	end
	Trigger { -- 65
			players = {IncludePlayer},
			conditions = {
				Label(FLMulAlloc+3);
				CtrigX("X",WRet[1],0x15C,0,AtLeast,0); -- X2 >= X2(전) : X1 -= 1 (No Carry)
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x19C,0,Add,-1);
			},
			flag = {Preserved}
		}

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLMulCall2);
			},
			actions = {
				SetDeaths(0,SetTo,0,0); -- RecoverNext
			},
			flag = {Preserved}
		}

	CIfX(IncludePlayer,CtrigX("X",CRet[1],0x15C,0,Exactly,1))
		Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x15C,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[2],0x19C,0,SetTo,0xFFFFFFFF);
				SetCtrigX("X",WRet[1],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
				SetCtrigX("X",WRet[1],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
				SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x188,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",WRet[1],0x160,0,SetTo,Subtract*16777216,0xFF000000);
				SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,Subtract*16777216,0xFF000000);
				CallLabelAlways("X",WRet[1],0);
			},
			flag = {Preserved}
		}
		Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
				CtrigX("X",WRet[2],0x15C,0,Exactly,0xFFFFFFFF);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x19C,0,Add,1);
			},
			flag = {Preserved}
		}	
		Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",WRet[2],0x15C,0,Add,1);
			},
			flag = {Preserved}
		}
	CElseX()
			Trigger {
					players = {IncludePlayer},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X",WRet[1],0x158,0,SetTo,"X",WRet[2],0x15C,1,0);
						SetCtrigX("X",WRet[1],0x198,0,SetTo,"X",WRet[2],0x19C,1,0);
						SetCtrig1X("X",WRet[1],0x148,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[1],0x188,0,SetTo,0xFFFFFFFF);
						SetCtrig1X("X",WRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
						SetCtrig1X("X",WRet[1],0x1A0,0,SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways("X",WRet[1],0);
					},
					flag = {Preserved}
				}
	CIfXEnd()

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLiMulCall2);
			},
			flag = {Preserved}
		}

	local PlayerID = IncludePlayer
	PlayerID = PlayerConvert(PlayerID)
	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",FLMulAlloc+3,0x4,0,SetTo,"X",FLMulAlloc+2,0x0,0,-2))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",FLMulAlloc+2,0x4,-2,SetTo,"X",FLMulAlloc+2,0x0,0,0))
		for i = 1, 64 do
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",FLMulAlloc+2,0x4,i,SetTo,"X",FLMulAlloc+2,0x0,0,-2))
		end
	end

FLMulAlloc = FLMulAlloc + 6
end
-----------------------------------------------------------
if FLRandCheck == 1 then
	-- f_LRand - WRet[1] = Output
	local SeedSwitch = FLRandSwitch
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLRandCall1);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);
				SetSwitch(SeedSwitch,Random);
			},
			flag = {Preserved}
		}

	for i = 31, 0, -1 do
		Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(0);
				Switch(SeedSwitch,Set);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,Add,2^i);
			},
			flag = {Preserved}
		}
		Trigger { 
			players = {IncludePlayer},
			actions = {
				SetSwitch(SeedSwitch,Random);
			},
			flag = {Preserved}
		}
	end
	for i = 31, 0, -1 do
		Trigger { 
			players = {IncludePlayer},
			conditions = {
				Label(0);
				Switch(SeedSwitch,Set);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x19C,0,Add,2^i);
			},
			flag = {Preserved}
		}
		if i ~= 0 then
			Trigger { 
				players = {IncludePlayer},
				actions = {
					SetSwitch(SeedSwitch,Random);
				},
				flag = {Preserved}
			}
		end
	end
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLRandCall2);
			},
			flag = {Preserved}
		}
end	
-----------------------------------------------------------
if FLReadCheck == 1 then
	-- f_LRead - Ret[1] : Input[1] (Lower), Ret[2] : Input[2] (Upper) / WRet[1] = Output
	
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadCall1);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 0, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}

	for i = 0, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadCall2);
			},
			actions = {
			},
			flag = {Preserved}
		}
end
-----------------------------------------------------------
if FLReadXCheck == 1 then
	-- f_LReadX - Ret[1] : Input[1] (Lower), Ret[2] : Input[2] (Upper) / WRet[1] = Output
-- +0
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 0, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}

	for i = 0, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	FLReadXAlloc = FLReadXAlloc + 2

-- +1 (x256)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 0, 23 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit*256);
				},
				flag = {Preserved}
			}
	end
	for i = 24, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit/16777216);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}

	for i = 0, 23 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit*256);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	FLReadXAlloc = FLReadXAlloc + 2

-- +2 (x65536)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 0, 15 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit*65536);
				},
				flag = {Preserved}
			}
	end
	for i = 16, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit/65536);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}

	for i = 0, 15 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit*65536);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	FLReadXAlloc = FLReadXAlloc + 2

-- +3 (x16777216)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 0, 7 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit*16777216);
				},
				flag = {Preserved}
			}
	end
	for i = 8, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit/256);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}

	for i = 0, 7 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit*16777216);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	FLReadXAlloc = FLReadXAlloc + 2
-- +4 (x4294967296)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 0, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	FLReadXAlloc = FLReadXAlloc + 2

-- +5 (x1099511627776)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 0, 23 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit*256);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	FLReadXAlloc = FLReadXAlloc + 2

-- +6 (x281474976710656)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 0, 15 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit*65536);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	FLReadXAlloc = FLReadXAlloc + 2
-- +7 (x72057594037927936)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 0, 7 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit*16777216);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	FLReadXAlloc = FLReadXAlloc + 2
-- -1 (/256)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 8, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit/256);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}
	for i = 0, 7 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit*16777216);
				},
				flag = {Preserved}
			}
	end

	for i = 8, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit/256);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	FLReadXAlloc = FLReadXAlloc + 2

	-- -2 (/65536)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 16, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit/65536);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}
	for i = 0, 15 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit*65536);
				},
				flag = {Preserved}
			}
	end

	for i = 16, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit/65536);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	FLReadXAlloc = FLReadXAlloc + 2
-- -3 (/16777216)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[1],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[1],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[1],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[1],0);
			},
			flag = {Preserved}
		}

	for i = 24, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit/16777216);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(0);
			},
			actions = {
				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}
	for i = 0, 23 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit*256);
				},
				flag = {Preserved}
			}
	end

	for i = 24, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x19C,0,Add,CBit/16777216);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	FLReadXAlloc = FLReadXAlloc + 2

-- -4 (/4294967296)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}

	for i = 0, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	FLReadXAlloc = FLReadXAlloc + 2

-- -5 (/1099511627776)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}

	for i = 8, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit/256);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	FLReadXAlloc = FLReadXAlloc + 2
-- -6 (/281474976710656)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}

	for i = 16, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit/65536);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	FLReadXAlloc = FLReadXAlloc + 2
-- -7 (/72057594037927936)
	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc);
			},
			actions = {
				SetCtrig1X("X",WRet[1],0x15C,0,SetTo,0);
				SetCtrig1X("X",WRet[1],0x19C,0,SetTo,0);

				SetCtrig1X("X",CRet[2],0x158,0,SetTo,EPD(0x6509B0));
				SetCtrig1X("X",CRet[2],0x148,0,SetTo,0xFFFFFFFF);
				SetCtrig1X("X",CRet[2],0x160,0,SetTo,SetTo*16777216,0xFF000000);
				CallLabelAlways("X",CRet[2],0);
			},
			flag = {Preserved}
		}

	for i = 24, 31 do
		local CBit = 2^i
		Trigger {
				players = {IncludePlayer},
				conditions = {
					Label(0);
				   	DeathsX(CurrentPlayer,Exactly,CBit,0,CBit);
				},
				actions = {
					SetCtrig1X("X",WRet[1],0x15C,0,Add,CBit/16777216);
				},
				flag = {Preserved}
			}
	end

	Trigger {
			players = {IncludePlayer},
			conditions = {
				Label(FLReadXAlloc+1);
			},
			actions = {
			},
			flag = {Preserved}
		}

	FLReadXAlloc = FLReadXAlloc + 2
end
-----------------------------------------------------------
CJumpEnd(IncludePlayer,LastCJumpAlloc)
end

function NIfNotOnce2(PlayerID, Conditions, Actions) -- > Jump 무관
	return NIfNotOnce(PlayerID, Conditions, Actions, 1)
end

function NIfNotOnce(PlayerID, Conditions, Actions, UnPack) -- 1번만 실행
	return CIfOnce(PlayerID, Conditions, Actions, UnPack)
end

function NIfNot2(PlayerID, Conditions, Actions)
	return NIfNot(PlayerID, Conditions, Actions, 1)
end

function NIfNot(PlayerID, Conditions, Actions, UnPack)
	return CIf(PlayerID, Conditions, Actions, UnPack)
end

function NIfNotEnd()
	local Index
	Index = CIfArr[CIfptr] + 1
	local PlayerID
	PlayerID = CIfPArr[CIfptr]
	table.remove(CIfArr,CIfptr)
	table.remove(CIfPArr,CIfptr)
	CIfptr = CIfptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x158,0,SetTo,"X",Index-1,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x15C,0,SetTo,"X",Index,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x158,0,SetTo,"X",Index-1,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x15C,0,SetTo,"X",Index-1,0x0,0,1))
	end
	
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(Index);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			PreserveTrigger();
		},
	}
end


function NJumpNot2(PlayerID,sIndex,Conditions,Actions)
	return NJumpNot(PlayerID,sIndex,Conditions,Actions,1)
end

function NJumpNot(PlayerID,sIndex,Conditions,Actions,UnPack)
	if UnPack == 1 then
		if Conditions ~= nil then
		for k, v in pairs(Conditions) do
			local Temp = CunPack(v)
			Conditions[k] = Temp
		end
	end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(sIndex+JumpStartAlloc);
			Conditions,
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			SetCtrigX("X","X",0x4,-1,SetTo,"X",sIndex+JumpEndAlloc,0x0,0,1);
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",sIndex+JumpStartAlloc,0x4,0,SetTo,"X",sIndex+JumpEndAlloc,0x0,0,1))
	end
	table.insert(NJumpArr,sIndex)
end

function NJumpNotEnd(PlayerID,sIndex)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(sIndex+JumpEndAlloc);
			Never();
		},
	}
	table.insert(NJumpEndArr,sIndex)
end


function NJumpNotX2(PlayerID,sIndex,Conditions,Actions)
	return NJumpNotX(PlayerID,sIndex,Conditions,Actions,1)
end

function NJumpNotX(PlayerID,sIndex,Conditions,Actions,UnPack)
	if UnPack == 1 then
		if Conditions ~= nil then
			for k, v in pairs(Conditions) do
				local Temp = CunPack(v)
				Conditions[k] = Temp
			end
		end
		if Actions ~= nil then
			for k, v in pairs(Actions) do
				local Temp = CunPack(v)
				Actions[k] = Temp
			end
		end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
			Conditions,
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			SetCtrigX("X","X",0x4,-1,SetTo,"X",sIndex+JumpEndAlloc,0x0,0,1);
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",IndexAlloc,0x4,0,SetTo,"X",sIndex+JumpEndAlloc,0x0,0,1))
	end
	table.insert(NJumpArr,sIndex)
	IndexAlloc = IndexAlloc+1
end

function NJumpNotXEnd(PlayerID,sIndex)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(sIndex+JumpEndAlloc);
			Never();
		},
	}
	table.insert(NJumpEndArr,sIndex)
end


function NWhileNot2(PlayerID, Conditions, Actions)
	return NWhileNot(PlayerID, Conditions, Actions, 1)
end

function NWhileNot(PlayerID, Conditions, Actions, UnPack)
	if UnPack == 1 then
		if Conditions ~= nil then
		for k, v in pairs(Conditions) do
			local Temp = CunPack(v)
			Conditions[k] = Temp
		end
	end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
			Conditions,
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
			SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1);
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(CWhileArr, IndexAlloc)
	table.insert(CWhilePArr, PlayerID)
	CWhileptr = CWhileptr + 1
	IndexAlloc = IndexAlloc + 0x3
end

function NWhileNotEnd2(Actions)
	return NWhileNotEnd(Actions,1)
end

function NWhileNotEnd(Actions,UnPack)
	local Index
	Index = CWhileArr[CWhileptr] + 2
	local PlayerID
	PlayerID = CWhilePArr[CWhileptr]
	table.remove(CWhileArr,CWhileptr)
	table.remove(CWhilePArr,CWhileptr)
	CWhileptr = CWhileptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x4,0,SetTo,"X",Index-1,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x4,0,SetTo,"X",Index-2,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x4,0,SetTo,"X",Index,0x0,0,1))
	end

	if UnPack == 1 then
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID)

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(Index);
		},
		actions = {
			Actions,
			PreserveTrigger();
		},
	}
end
--[[
function NLoopNotX2(PlayerID, Repeat, Conditions, Actions)
	return NLoopNotX(PlayerID, Repeat, Conditions, Actions, 1)
end

function NLoopNotX(PlayerID, Repeat, Conditions, Actions, UnPack) -- 조건 불만족시 무한루프
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
		},
		actions = {
			SetCDeaths("X",SetTo,0,Ccode(IndexAlloc+2,0));
	   		PreserveTrigger();
		},
	}

	if type(Repeat) == "number" then
		if UnPack == 1 then
			if Conditions ~= nil then
			for k, v in pairs(Conditions) do
				local Temp = CunPack(v)
				Conditions[k] = Temp
			end
		end
			if Actions ~= nil then
			for k, v in pairs(Actions) do
				local Temp = CunPack(v)
				Actions[k] = Temp
			end
		end
		end
		Conditions = __FlattenCCond(Conditions)
		Actions = __FlattenCAct(Actions)

		STPopTrigArr(PlayerID)
		_TPopCondArr(PlayerID)
		ORPopCondArr(PlayerID)
		TTPopTrigArr(PlayerID)
		Conditions = PopCondArr(Conditions)
		Actions = PopActArr(Actions)
		PopTrigArr(PlayerID,1,1)
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(IndexAlloc+1);
				CDeaths("X",AtLeast,Repeat,Ccode(IndexAlloc+2,0));
				Conditions,
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1);
				Actions,
		   		PreserveTrigger();
			},
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(IndexAlloc+2);
			},
			actions = {
				SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1);
		   		PreserveTrigger();
			},
		}
	else
		Conditions = {Conditions,TCDeaths("X",AtLeast,Vi(Repeat[2],0,Repeat[1],Repeat[3]),Ccode(IndexAlloc+2,0))}

		if UnPack == 1 then
			if Conditions ~= nil then
			for k, v in pairs(Conditions) do
				local Temp = CunPack(v)
				Conditions[k] = Temp
			end
		end
			if Actions ~= nil then
			for k, v in pairs(Actions) do
				local Temp = CunPack(v)
				Actions[k] = Temp
			end
		end
		end
		Conditions = __FlattenCCond(Conditions)
		Actions = __FlattenCAct(Actions)

		STPopTrigArr(PlayerID)
		_TPopCondArr(PlayerID)
		ORPopCondArr(PlayerID)
		TTPopTrigArr(PlayerID)
		Conditions = PopCondArr(Conditions)
		Actions = PopActArr(Actions)
		PopTrigArr(PlayerID,1)
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(IndexAlloc+1);
				Conditions,
			},
			actions = {
				SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1);
				Actions,
		   		PreserveTrigger();
			},
		}
		Trigger {
			players = {PlayerID},
			conditions = {
				Label(IndexAlloc+2);
			},
			actions = {
				SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1);
		   		PreserveTrigger();
			},
		}
	end
	PlayerID = PlayerConvert(PlayerID)
	table.insert(CWhileXArr, IndexAlloc)
	table.insert(CWhileXPArr, PlayerID)
	CWhileXptr = CWhileXptr + 1
	IndexAlloc = IndexAlloc + 0x4
end

function NLoopNotXEnd2(Actions)
	return NLoopNotXEnd(Actions,1)
end

function NLoopNotXEnd(Actions,UnPack)
	local Index
	Index = CWhileXArr[CWhileXptr] + 3
	local PlayerID
	PlayerID = CWhileXPArr[CWhileXptr]
	table.remove(CWhileXArr,CWhileXptr)
	table.remove(CWhileXPArr,CWhileXptr)
	CWhileXptr = CWhileXptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x4,0,SetTo,"X",Index-1,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x4,0,SetTo,"X",Index-3,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x4,0,SetTo,"X",Index,0x0,0,1))
	end

	if UnPack == 1 then
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(Index);
		},
		actions = {
			SetCDeaths("X",Add,1,Ccode(Index-1,0));
			Actions,
			PreserveTrigger();
		},
	}
end
]]--

function NWhileNotX2(PlayerID, Conditions, Actions)
	return NWhileNotX(PlayerID, Conditions, Actions, 1)
end

function NWhileNotX(PlayerID, Conditions, Actions, UnPack)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
			Never();
		},
		actions = {
	   		PreserveTrigger();
		},
	}

	if UnPack == 1 then
		if Conditions ~= nil then
		for k, v in pairs(Conditions) do
			local Temp = CunPack(v)
			Conditions[k] = Temp
		end
	end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+1);
			Conditions,
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+2);
		},
		actions = {
			SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1);
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(CWhileXArr, IndexAlloc)
	table.insert(CWhileXPArr, PlayerID)
	CWhileXptr = CWhileXptr + 1
	IndexAlloc = IndexAlloc + 0x4
end

function NWhileNotXEnd2(Actions)
	return NWhileNotXEnd(Actions,1)
end

function NWhileNotXEnd(Actions,UnPack)
	local Index
	Index = CWhileXArr[CWhileXptr] + 3
	local PlayerID
	PlayerID = CWhileXPArr[CWhileXptr]
	table.remove(CWhileXArr,CWhileXptr)
	table.remove(CWhileXPArr,CWhileXptr)
	CWhileXptr = CWhileXptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x4,0,SetTo,"X",Index-1,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x4,0,SetTo,"X",Index-3,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x4,0,SetTo,"X",Index,0x0,0,1))
	end

	if UnPack == 1 then
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID)

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(Index);
		},
		actions = {
			Actions,
			PreserveTrigger();
		},
	}
end


function DoWhileNot(PlayerID, Actions_Always)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions_Always,
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(DWhileArr, IndexAlloc)
	table.insert(DWhilePArr, PlayerID)
	DWhileptr = DWhileptr + 1
	IndexAlloc = IndexAlloc + 0x2
end

function DoWhileNotEnd2(Loop_Conditions, Actions)
	return DoWhileNotEnd(Loop_Conditions, Actions,1)
end

function DoWhileNotEnd(Loop_Conditions, Actions,UnPack)
	local Index
	Index = DWhileArr[DWhileptr] + 1
	local PlayerID
	PlayerID = DWhilePArr[DWhileptr]
	table.remove(DWhileArr,DWhileptr)
	table.remove(DWhilePArr,DWhileptr)
	DWhileptr = DWhileptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x158,0,SetTo,"X",Index,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x15C,0,SetTo,"X",Index-1,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x158,0,SetTo,"X",Index,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x15C,0,SetTo,"X",Index,0x0,0,1))
	end
	if UnPack == 1 then
		for k, v in pairs(Loop_Conditions) do
			local Temp = CunPack(v)
			Loop_Conditions[k] = Temp
		end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Loop_Conditions = __FlattenCCond(Loop_Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Loop_Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(Index);
			Loop_Conditions,
		},
		actions = {
		SetDeaths(0,SetTo,0,0);
			Actions,
			PreserveTrigger();
		},
	}
end


function NIfNotX2(PlayerID, Conditions, Actions)
	return NIfNotX(PlayerID, Conditions, Actions,1)
end

function NIfNotX(PlayerID, Conditions, Actions,UnPack)
	if UnPack == 1 then
		if Conditions ~= nil then
		for k, v in pairs(Conditions) do
			local Temp = CunPack(v)
			Conditions[k] = Temp
		end
	end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label();
		},
		actions = {
			SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1);
	   		PreserveTrigger();
		},
	}
	local X = {}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(X, IndexAlloc)
	table.insert(NIfXArr, X)
	table.insert(NIfXPArr, PlayerID)
	table.insert(NIfXNotArr,{1})
	NIfXptr = NIfXptr + 1
	IndexAlloc = IndexAlloc + 0x2
end

function NElseIfNotX2(Conditions, Actions)
	return NElseIfNotX(Conditions, Actions,1)
end

function NElseIfNotX(Conditions, Actions,UnPack)
	local PlayerID
	PlayerID = NIfXPArr[NIfXptr]
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		flag = {Preserved}
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
		},
		flag = {Preserved}
	}
	if UnPack == 1 then
		if Conditions ~= nil then
		for k, v in pairs(Conditions) do
			local Temp = CunPack(v)
			Conditions[k] = Temp
		end
	end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+1);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label();
		},
		actions = {
			SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1);
	   		PreserveTrigger();
		},
	}
	table.insert(NIfXArr[NIfXptr],IndexAlloc+1)
	table.insert(NIfXNotArr[NIfXptr],1)
	IndexAlloc = IndexAlloc + 0x2
end

--[[
function NElseNotX2(Actions)
	return NElseNotX(Actions,1)
end

function NElseNotX(Actions,UnPack)
	local PlayerID
	PlayerID = NIfXPArr[NIfXptr]
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		flag = {Preserved}
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
		},
		flag = {Preserved}
	}
	if UnPack == 1 then
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label();
		},
		actions = {
			SetCtrigX("X","X",0x4,-1,SetTo,"X","X",0x0,0,1);
	   		PreserveTrigger();
		},
	}
	table.insert(NIfXArr[NIfXptr],IndexAlloc+1)
	table.insert(NIfXNotArr[NIfXptr],1)
	IndexAlloc = IndexAlloc + 0x2
end
]]--

function NIfX2(PlayerID, Conditions, Actions)
	return NIfX(PlayerID, Conditions, Actions, 1)
end

function NIfX(PlayerID, Conditions, Actions, UnPack)
	if UnPack == 1 then
		if Conditions ~= nil then
		for k, v in pairs(Conditions) do
			local Temp = CunPack(v)
			Conditions[k] = Temp
		end
	end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
	   		PreserveTrigger();
		},
	}
	local X = {}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(X, IndexAlloc)
	table.insert(NIfXArr, X)
	table.insert(NIfXPArr, PlayerID)
	table.insert(NIfXNotArr,{0})
	NIfXptr = NIfXptr + 1
	IndexAlloc = IndexAlloc + 0x2
end

function NElseIfX2(Conditions, Actions)
	return NElseIfX(Conditions, Actions,1)
end

function NElseIfX(Conditions, Actions,UnPack)
	local PlayerID
	PlayerID = NIfXPArr[NIfXptr]
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		flag = {Preserved}
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
		},
		flag = {Preserved}
	}
	if UnPack == 1 then
		if Conditions ~= nil then
		for k, v in pairs(Conditions) do
			local Temp = CunPack(v)
			Conditions[k] = Temp
		end
	end
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Conditions = __FlattenCCond(Conditions)
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(Conditions)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+1);
			Conditions,
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
	   		PreserveTrigger();
		},
	}
	table.insert(NIfXArr[NIfXptr],IndexAlloc+1)
	table.insert(NIfXNotArr[NIfXptr],0)
	IndexAlloc = IndexAlloc + 0x2
end

function NElseX2(Actions)
	return NElseX(Actions,1)
end

function NElseX(Actions,UnPack)
	local PlayerID
	PlayerID = NIfXPArr[NIfXptr]
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		flag = {Preserved}
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
		},
		flag = {Preserved}
	}
	if UnPack == 1 then
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
	   		PreserveTrigger();
		},
	}
	table.insert(NIfXArr[NIfXptr],IndexAlloc+1)
	table.insert(NIfXNotArr[NIfXptr],0)
	IndexAlloc = IndexAlloc + 0x2
end

function NIfXEnd()
	local PlayerID
	PlayerID = NIfXPArr[NIfXptr]
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		flag = {Preserved}
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
		},
		flag = {Preserved}
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+1);
		},
		actions = {
			PreserveTrigger();
		},
	}
	table.insert(NIfXArr[NIfXptr],IndexAlloc+1)
	IndexAlloc = IndexAlloc + 0x2

	for k, P in pairs(PlayerID) do
		local Size = 0
		for i, index in pairs(NIfXArr[NIfXptr]) do
			Size = Size + 1
		end
		for i = 1, Size-1 do
			if NIfXNotArr[NIfXptr][i] == 1 then
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",NIfXArr[NIfXptr][i],0x4,0,SetTo,"X",NIfXArr[NIfXptr][i],0x0,0,2))
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",NIfXArr[NIfXptr][i],0x4,1,SetTo,"X",NIfXArr[NIfXptr][i+1]-1,0x0,0,0))
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",NIfXArr[NIfXptr][i+1]-1,0x4,-1,SetTo,"X",IndexAlloc-1,0x0,0,0))
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",NIfXArr[NIfXptr][i],0x158,0,SetTo,"X",NIfXArr[NIfXptr][i],0x4,1,0))
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",NIfXArr[NIfXptr][i],0x15C,0,SetTo,"X",NIfXArr[NIfXptr][i],0x0,0,1))
			else
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",NIfXArr[NIfXptr][i],0x4,0,SetTo,"X",NIfXArr[NIfXptr][i+1]-1,0x0,0,0))
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",NIfXArr[NIfXptr][i+1]-1,0x4,-1,SetTo,"X",IndexAlloc-1,0x0,0,0))
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",NIfXArr[NIfXptr][i],0x158,0,SetTo,"X",NIfXArr[NIfXptr][i],0x4,1,0))
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",NIfXArr[NIfXptr][i],0x15C,0,SetTo,"X",NIfXArr[NIfXptr][i],0x0,0,1))
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",NIfXArr[NIfXptr][i],0x158,1,SetTo,"X",NIfXArr[NIfXptr][i],0x4,1,0))
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",NIfXArr[NIfXptr][i],0x15C,1,SetTo,"X",NIfXArr[NIfXptr][i+1]-1,0x0,0,0))
			end
		end
	end

	table.remove(NIfXArr,NIfXptr)
	table.remove(NIfXPArr,NIfXptr)
	table.remove(NIfXNotArr,NIfXptr)
	NIfXptr = NIfXptr - 1
end

function NFor(PlayerID,Index,Init,End,Step,Actions) -- UnPack 기본적용
	if not(type(Index) == "table" and Index[4] == "V") then
		Index = CreateVar(PlayerID)
	end

	if type(Init) == "number" then
		Init = {SetNVar(Index,SetTo,Init)}
	end
	CDoActionsX(PlayerID,Init,nil,IndexAlloc)

	if type(End) == "table" and #End == 2 and type(End[1]) == "number" and type(End[2]) == "number" then -- {AtMost,1}
		if End[1] == AtLeast or End[1] == AtMost or End[1] == Exactly then
			End = {NVar(Index,End[1],End[2])}
		else
			End = {{TTNVar,Index,End[1],End[2]}}
		end
	end

	if type(Step) == "number" then
		Step = {SetNVar(Index,Add,Step)}
	end

	if End ~= nil then
		for k, v in pairs(End) do
			local Temp = CunPack(v)
			End[k] = Temp
		end
	end
	if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end

	End = __FlattenCCond(End)
	Actions = __FlattenCAct(Actions)
	
	STPopTrigArr(PlayerID)
	_TPopCondArr(PlayerID)
	ORPopCondArr(PlayerID)
	TTPopTrigArr(PlayerID)
	Conditions = PopCondArr(End)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+1);
			End;
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
		},
		flag = {Preserved}
	}

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+2);
		},
		actions = {
	   		PreserveTrigger();
		},
	}

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+3);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(NForArr, IndexAlloc)
	table.insert(NForPArr, PlayerID)
	table.insert(NForStepArr, Step)
	NForptr = NForptr + 1
	IndexAlloc = IndexAlloc + 0x5

	return Index
end

function NForEnd()
	local Index
	Index = NForArr[NForptr] + 4
	local PlayerID
	PlayerID = NForPArr[NForptr]
	local Actions
	Actions = NForStepArr[NForptr]
	table.remove(NForArr,NForptr)
	table.remove(NForPArr,NForptr)
	table.remove(NForStepArr,NForptr)
	NForptr = NForptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x4,0,SetTo,"X",Index-4,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x4,0,SetTo,"X",Index,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-3,0x158,0,SetTo,"X",Index-3,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-3,0x15C,0,SetTo,"X",Index-1,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x158,0,SetTo,"X",Index-3,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x15C,0,SetTo,"X",Index-2,0x0,0,0))
	end

	if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end

	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(Index);
		},
		actions = {
			Actions,
			PreserveTrigger();
		},
	}
end

function NSwitch(PlayerID,Offset,Mask) -- *C 연산 / Offset V Mem Cp 지원
	STPopTrigArr(PlayerID)

	if Mask == nil then
		Mask = 0xFFFFFFFF
	end
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			PreserveTrigger();
		},
	}

	PlayerID = PlayerConvert(PlayerID)
	table.insert(CSwitchPArr, PlayerID)
	table.insert(CSwitchArr,IndexAlloc)
	table.insert(CSwitchCaseArr,{})
	table.insert(CSwitchKeyArr,{})
	table.insert(CSwitchDataArr,{Offset,Mask})
	CSwitchptr = CSwitchptr + 1
	IndexAlloc = IndexAlloc + 2
end

function NSwitchCase(Case) -- N -> Case : N / {A,B,C} -> Case : A~B (간격 C)
	local PlayerID
	PlayerID = CSwitchPArr[CSwitchptr]

	if type(Case) == "number" then
		table.insert(CSwitchCaseArr[CSwitchptr],IndexAlloc)
		table.insert(CSwitchKeyArr[CSwitchptr],Case)
	elseif type(Case) == "table" then
		if Case[3] == nil then
			Case[3] = 1
		end

		for i = Case[1], Case[2], Case[3] do
			table.insert(CSwitchCaseArr[CSwitchptr],IndexAlloc)
			table.insert(CSwitchKeyArr[CSwitchptr],i)
		end
	else 
		CSwitchCaseArr[CSwitchptr]["Default"] = IndexAlloc
	end	

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
		},
	}
	IndexAlloc = IndexAlloc + 1
end

function NSwitchBreak() -- goto SwitchEnd
	local PlayerID
	PlayerID = CSwitchPArr[CSwitchptr]
	local Index
	Index = CSwitchArr[CSwitchptr] + 1

	Trigger {
		players = {PlayerID},
		conditions = {
			Label();
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",Index,0x0,0,1);
			PreserveTrigger();
		},
	}
end

function NSwitchEnd() 
    -- EUDJumpIfNot(MemoryXEPD(epd,Exactly,keyand, (~keyor | keyand) &bitmask), defbranch)
    -- -> Jump Header(16bytes) -> Code Areas -> SwitchEnd
	local PlayerID
	PlayerID = CSwitchPArr[CSwitchptr]
	local Index
	Index = CSwitchArr[CSwitchptr] + 1

	Trigger {
		players = {PlayerID},
		conditions = {
			Label();
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X",Index,0x0,0,1);
			PreserveTrigger();
		},
	}

	local Mask = CSwitchDataArr[CSwitchptr][2]
	local Offset = CSwitchDataArr[CSwitchptr][1]

	local keyor = 0
	local keyand = 0xFFFFFFFF
	for k, v in pairs(CSwitchKeyArr[CSwitchptr]) do
		keyand = bit32.band(keyand, v)
		keyor = bit32.bor(keyor, v)
	end
	local keymask = bit32.band(bit32.bor(bit32.bnot(keyor),keyand),Mask)
	local keybit = keyor - keyand
	local BitSize = 0
	local Cond1, Cond2

	if type(Offset) == "number" then
		Cond1 = MemoryX(Offset,Exactly,keyand,keymask)
	elseif Offset == "Cp" then
		Cond1 = DeathsX(CurrentPlayer,Exactly,keyand,0,keymask)
	elseif Offset[4] == "V" then
		Cond1 = NVar(Offset,Exactly,keyand,keymask)
	else
		Cond1 = CtrigX(Offset[1],Offset[2],Offset[3],Offset[4],Exactly,keyand,keymask)
	end
	Trigger {	players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
			Cond1;
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,1);
			SetCtrigX("X",FuncAlloc,0x4,0,SetTo,"X",FuncAlloc,0x0,0,1); -- Next Reset
			PreserveTrigger();
		},
	}
	for i = 0, 31 do
		local CBit = 2^i
		if type(Offset) == "number" then
			Cond2 = MemoryX(Offset,Exactly,CBit,CBit)
		elseif Offset == "Cp" then
			Cond2 = DeathsX(CurrentPlayer,Exactly,CBit,0,CBit)
		elseif Offset[4] == "V" then
			Cond2 = NVar(Offset,Exactly,CBit,CBit)
		else
			Cond2 = CtrigX(Offset[1],Offset[2],Offset[3],Offset[4],Exactly,CBit,CBit)
		end
		if bit32.band(CBit,keybit) ~= 0 then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label();
					Cond2;
				},
				actions = {
					SetCtrig1X("X",FuncAlloc,0x4,0,Add,2^(4+BitSize)); -- Next Add
					PreserveTrigger();
				},
			}
			BitSize = BitSize + 1
		end
	end

	local JumpIndex = FuncAlloc
	JumpTable = f_GetVoidptr(PlayerID,2^(BitSize+4)+0x970)

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(Index);
		},
	}

	for _, P in pairs(PlayerID) do
		if CSwitchCaseArr[CSwitchptr]["Default"] == nil then
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x4,0,SetTo,"X",IndexAlloc,0x0,0,0))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x158,0,SetTo,"X",IndexAlloc,0x4,1,0))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x15C,0,SetTo,"X",Index,0x0,0,1))
			for i = 0, 2^(BitSize)-1 do
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",JumpIndex,0x4+0x10*i,1,SetTo,"X",Index,0x0,0,1))
				table.insert(CtrigInitArr[P+1], SetCtrig1X("X",JumpIndex,0x948+0x10*i,1,SetTo,8))
			end
		else
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x4,0,SetTo,"X",IndexAlloc,0x0,0,0))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x158,0,SetTo,"X",IndexAlloc,0x4,1,0))
			table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x15C,0,SetTo,"X",CSwitchCaseArr[CSwitchptr]["Default"],0x0,0,1))
			for i = 0, 2^(BitSize)-1 do
				table.insert(CtrigInitArr[P+1], SetCtrigX("X",JumpIndex,0x4+0x10*i,1,SetTo,"X",CSwitchCaseArr[CSwitchptr]["Default"],0x0,0,1))
				table.insert(CtrigInitArr[P+1], SetCtrig1X("X",JumpIndex,0x948+0x10*i,1,SetTo,8))
			end
		end

		for k, v in pairs(CSwitchKeyArr[CSwitchptr]) do
			local BitSize2 = 0
			local Ret = 0
			for i = 0, 31 do
				local CBit = 2^i
				if bit32.band(CBit,keybit) ~= 0 then
					if bit32.band(v,CBit) ~= 0 then
						Ret = Ret + 2^BitSize2
					end
					BitSize2 = BitSize2 + 1
				end
			end

			table.insert(CtrigInitArr[P+1], SetCtrigX("X",JumpIndex,0x4+0x10*Ret,1,SetTo,"X",CSwitchCaseArr[CSwitchptr][k],0x0,0,1))
		end
	end

	IndexAlloc = IndexAlloc + 1
	table.remove(CSwitchArr,CSwitchptr)
	table.remove(CSwitchPArr,CSwitchptr)
	table.remove(CSwitchDataArr,CSwitchptr)
	table.remove(CSwitchCaseArr,CSwitchptr)
	table.remove(CSwitchKeyArr,CSwitchptr)
	CSwitchptr = CSwitchptr - 1
end

function NStack(PlayerID,Number,Size) 
	-- ptr : EPD / ptr2 : Next + EPD Mask Type

	if Number < 1 or Number > 32 then
		NStack_InputData_Error()
	end

	local NVArr = CreateSVArr(Number,Size,PlayerID)

	local PID = "X"
	if type(PlayerID) == "number" then
		PID = PlayerID
	end
	CreateVarXAlloc = CreateVarXAlloc + 2
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	table.insert(CreateVarPArr,{"NP1",PlayerID,Number,NVArr[2]})
	table.insert(CreateVarPArr,{"NP2",PlayerID,Number,NVArr[2]})

	local Nptr1 = {PID,CreateVarXAlloc-1,0,"V"}
	local Nptr2 = {PID,CreateVarXAlloc,0,"V"}

	return {NVArr, Nptr1, Nptr2, "Stack"}
end

function NPush(PlayerID,Stack,Source,Mask)
	STPopTrigArr(PlayerID)
	local Number = Stack[1][5]
	if Number == 1 then -- V/SVA1
		if Mask == nil then
			Mask = 0xFFFFFFFF
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		elseif type(Source) == "table" and Source[4] == "SVA" then
			local TempRet = {"X",SRet[Source[5][5]][3],0,"SV",Source[5][5],Source[5][7]}
			MovS(PlayerID,TempRet,Source)
			Source = TempRet
		end

		if type(Source) == "number" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Stack[2][1],Stack[2][2],0x158,Stack[2][3],SetTo,"X","X",0x158,1,1);
					CallLabelAlways(Stack[2][1],Stack[2][2],Stack[2][3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetMemoryX(0,SetTo,Source,Mask);
					SetCtrig1X(Stack[2][1],Stack[2][2],0x15C,Stack[2][3],Add,604);
					SetCtrig1X(Stack[2][1],Stack[2][2],0x178,Stack[2][3],Add,604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x15C,Stack[3][3],Add,0x970);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x178,Stack[3][3],Add,604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x198,Stack[3][3],Add,604);
				},
				flag = {Preserved}
			}
		elseif Source[4] == "V" or (Source[4] == "SV" and Source[5] == 1) then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Stack[2][1],Stack[2][2],0x158,Stack[2][3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways2(Stack[2][1],Stack[2][2],Stack[2][3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Stack[2][1],Stack[2][2],0x15C,Stack[2][3],Add,604);
					SetCtrig1X(Stack[2][1],Stack[2][2],0x178,Stack[2][3],Add,604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x15C,Stack[3][3],Add,0x970);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x178,Stack[3][3],Add,604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x198,Stack[3][3],Add,604);
				},
				flag = {Preserved}
			}
		else
			NPush_InputData_Error()
		end
	elseif Number == 2 then -- W/SVA2
		if Mask == nil then
			Mask = {0xFFFFFFFF,0xFFFFFFFF}
		elseif type(Mask) == "number" then
			Mask = {Mask,Mask}
		end
		if type(Source) == "table" and Source[4] == "WA" then
			local TempRet = {"X",WRet[7],0,"W"}
			MovW(PlayerID,TempRet,Source)
			Source = TempRet
		elseif type(Source) == "table" and Source[4] == "SVA" then
			local TempRet = {"X",SRet[Source[5][5]][3],0,"SV",Source[5][5],Source[5][7]}
			MovS(PlayerID,TempRet,Source)
			Source = TempRet
		end

		if type(Source) == "number" or type(Source) == "string" or (type(Source) == "table" and type(Source[1]) == "number" and type(Source[2]) == "number" and #Source == 2) then
			if type(Source) == "number" then
				Source = {Source,0}
			elseif type(Source) == "string" then
				Source = I64(Source)
			end

			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Stack[2][1],Stack[2][2],0x158,Stack[2][3],SetTo,"X","X",0x158,1,1);
					SetCtrigX(Stack[2][1],Stack[2][2],0x198,Stack[2][3],SetTo,"X","X",0x178,1,1);
					CallLabelAlways(Stack[2][1],Stack[2][2],Stack[2][3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetMemoryX(0,SetTo,Source[1],Mask[1]);
					SetMemoryX(0,SetTo,Source[2],Mask[2]);
					SetCtrig1X(Stack[2][1],Stack[2][2],0x15C,Stack[2][3],Add,604);
					SetCtrig1X(Stack[2][1],Stack[2][2],0x178,Stack[2][3],Add,604);
					SetCtrig1X(Stack[2][1],Stack[2][2],0x19C,Stack[2][3],Add,604);
					SetCtrig1X(Stack[2][1],Stack[2][2],0x1B8,Stack[2][3],Add,604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x15C,Stack[3][3],Add,0x970);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x178,Stack[3][3],Add,604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x198,Stack[3][3],Add,604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x1B8,Stack[3][3],Add,604);
				},
				flag = {Preserved}
			}
		elseif Source[4] == "W" or (Source[4] == "SV" and Source[5] == 2) then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX(Stack[2][1],Stack[2][2],0x158,Stack[2][3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
					SetCtrigX(Stack[2][1],Stack[2][2],0x198,Stack[2][3],SetTo,Source[1],Source[2],0x198,1,Source[3]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways2(Stack[2][1],Stack[2][2],Stack[2][3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Stack[2][1],Stack[2][2],0x15C,Stack[2][3],Add,604);
					SetCtrig1X(Stack[2][1],Stack[2][2],0x178,Stack[2][3],Add,604);
					SetCtrig1X(Stack[2][1],Stack[2][2],0x19C,Stack[2][3],Add,604);
					SetCtrig1X(Stack[2][1],Stack[2][2],0x1B8,Stack[2][3],Add,604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x15C,Stack[3][3],Add,0x970);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x178,Stack[3][3],Add,604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x198,Stack[3][3],Add,604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x1B8,Stack[3][3],Add,604);
				},
				flag = {Preserved}
			}
		else
			NPush_InputData_Error()
		end
	else -- SVA3~32
		if Mask == nil then
			Mask = {}
			for i = 1, Number do
				table.insert(Mask,0xFFFFFFFF)
			end
		elseif type(Mask) == "number" then
			Mask = {Mask}
			for i = 2, Number do
				table.insert(Mask,Mask[1])
			end
		else
			for i = 1, Number do
				if Mask[i] == nil then
					Mask[i] = 0xFFFFFFFF
				end
			end
		end

		if type(Source) == "table" and Source[4] == "SVA" then
			local TempRet = {"X",SRet[Source[5][5]][3],0,"SV",Source[5][5],Source[5][7]}
			MovS(PlayerID,TempRet,Source)
			Source = TempRet
		end

		if type(Source) == "number" or (type(Source) == "table" and type(Source[4]) == "number" and #Source == Number) then
			if type(Source) == "number" then
				Source = {Source}
				for i = 2, Number do
					table.insert(Source,Source[1])
				end
			end

			local Box1 = {}
			local Box2 = {}
			local Box3 = {}
			for i = 1, Number do
				table.insert(Box1,SetCtrigX(Stack[2][1],Stack[2][2],0x158+0x40*(i-1),Stack[2][3],SetTo,"X","X",0x158+0x20*(i-1),1,1))
				table.insert(Box2,SetMemoryX(0,SetTo,Source[i],Mask[i]))
				table.insert(Box3,SetCtrig1X(Stack[2][1],Stack[2][2],0x15C+0x40*(i-1),Stack[2][3],Add,604))
				table.insert(Box3,SetCtrig1X(Stack[2][1],Stack[2][2],0x178+0x40*(i-1),Stack[2][3],Add,604))
				table.insert(Box3,SetCtrig1X(Stack[3][1],Stack[3][2],0x198+0x20*(i-1),Stack[3][3],Add,604))
			end
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					Box1;
					CallLabelAlways(Stack[2][1],Stack[2][2],Stack[2][3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					Box2;
					SetCtrig1X(Stack[3][1],Stack[3][2],0x15C,Stack[3][3],Add,0x970);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x178,Stack[3][3],Add,604);
				},
				flag = {Preserved}
			}
			DoActions2X(PlayerID,Box3)
		elseif Source[4] == "SV" and Source[5] == Number then
			local Box1 = {}
			local Box2 = {}
			local Box3 = {SetCtrig1X(Stack[3][1],Stack[3][2],0x15C,Stack[3][3],Add,0x970),SetCtrig1X(Stack[3][1],Stack[3][2],0x178,Stack[3][3],Add,604)}
			for i = 1, Number do
				table.insert(Box1,SetCtrig1X(Source[1],Source[2],0x148+0x40*(i-1),Source[3],SetTo,Mask[i]))
				table.insert(Box1,SetCtrig1X(Source[1],Source[2],0x160+0x40*(i-1),Source[3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(Box2,SetCtrigX(Stack[2][1],Stack[2][2],0x158+0x40*(i-1),Stack[2][3],SetTo,Source[1],Source[2],0x158+0x40*(i-1),1,Source[3]))
				table.insert(Box3,SetCtrig1X(Stack[2][1],Stack[2][2],0x15C+0x40*(i-1),Stack[2][3],Add,604))
				table.insert(Box3,SetCtrig1X(Stack[2][1],Stack[2][2],0x178+0x40*(i-1),Stack[2][3],Add,604))
				table.insert(Box3,SetCtrig1X(Stack[3][1],Stack[3][2],0x198+0x20*(i-1),Stack[3][3],Add,604))
			end

			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					Box1;
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					Box2;
					CallLabelAlways2(Stack[2][1],Stack[2][2],Stack[2][3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
			DoActions2X(PlayerID,Box3)
		else
			NPush_InputData_Error()
		end
	end
end

function NPop(PlayerID,Stack,Dest)
	STPopTrigArr(PlayerID)
	local Number = Stack[1][5]
	if Number == 1 then -- V/Mem/SVA1
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		elseif type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		elseif type(Dest) == "table" and Dest[4] == "SVA" then
			PDestS = Dest
			Dest = {"X",SRet[Dest[5][5]][4],0,"SV",Dest[5][5],Dest[5][7]}
		end

		if type(Dest) == "number" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Stack[2][1],Stack[2][2],0x15C,Stack[2][3],Add,-604);
					SetCtrig1X(Stack[2][1],Stack[2][2],0x178,Stack[2][3],Add,-604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x15C,Stack[3][3],Add,-0x970);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x178,Stack[3][3],Add,-604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x198,Stack[3][3],Add,-604);

					SetCtrigX("X","X",0x4,0,SetTo,Stack[3][1],Stack[3][2],0x0,0,Stack[3][3]);
					SetCtrigX(Stack[3][1],Stack[3][2],0x17C,Stack[3][3],SetTo,"X","X",0x0,0,1);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x19C,Stack[3][3],SetTo,EPD(Dest));
				},
				flag = {Preserved}
			}
			
		elseif Dest[4] == "V" or (Dest[4] == "SV" and Dest[5] == 1) then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Stack[2][1],Stack[2][2],0x15C,Stack[2][3],Add,-604);
					SetCtrig1X(Stack[2][1],Stack[2][2],0x178,Stack[2][3],Add,-604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x15C,Stack[3][3],Add,-0x970);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x178,Stack[3][3],Add,-604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x198,Stack[3][3],Add,-604);

					SetCtrigX("X","X",0x4,0,SetTo,Stack[3][1],Stack[3][2],0x0,0,Stack[3][3]);
					SetCtrigX(Stack[3][1],Stack[3][2],0x17C,Stack[3][3],SetTo,"X","X",0x0,0,1);
					SetCtrigX(Stack[3][1],Stack[3][2],0x19C,Stack[3][3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				},
				flag = {Preserved}
			}
		else -- Mem
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Stack[2][1],Stack[2][2],0x15C,Stack[2][3],Add,-604);
					SetCtrig1X(Stack[2][1],Stack[2][2],0x178,Stack[2][3],Add,-604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x15C,Stack[3][3],Add,-0x970);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x178,Stack[3][3],Add,-604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x198,Stack[3][3],Add,-604);

					SetCtrigX("X","X",0x4,0,SetTo,Stack[3][1],Stack[3][2],0x0,0,Stack[3][3]);
					SetCtrigX(Stack[3][1],Stack[3][2],0x17C,Stack[3][3],SetTo,"X","X",0x0,0,1);
					SetCtrigX(Stack[3][1],Stack[3][2],0x19C,Stack[3][3],SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
				},
				flag = {Preserved}
			}
		end

		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Number == 2 then -- W/LMem/SVA2
		local PDest
		if type(Dest) == "table" and Dest[4] == "WA" then
			PDest = Dest
			Dest = {"X",WRet[8],0,"W"}
		elseif type(Dest) == "table" and Dest[4] == "LA_V" then
			PDest = Dest
			Dest = {"X",WRet[8],0,"W"}
		elseif type(Dest) == "table" and Dest[4] == "LA_W" then
			PDest = Dest
			Dest = {"X",WRet[8],0,"W"}
		elseif type(Dest) == "table" and Dest[4] == "SVA" then
			PDestS = Dest
			Dest = {"X",SRet[Dest[5][5]][4],0,"SV",Dest[5][5],Dest[5][7]}
		end

		if type(Dest) == "number" or (type(Dest) == "table" and type(Dest[1]) == "number" and (type(Dest[2]) == "number" or (type(Dest[2]) == "table" and type(Dest[2][1]) == "number")) and #Dest == 2) then
			if type(Dest) == "number" then
				Dest = {Dest,Dest+4}
			elseif type(Dest) == "table" and type(Dest[2]) == "table" then
				Dest = {Dest[1],Dest[1]+Dest[2][1]}
			end

			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Stack[2][1],Stack[2][2],0x15C,Stack[2][3],Add,-604);
					SetCtrig1X(Stack[2][1],Stack[2][2],0x178,Stack[2][3],Add,-604);
					SetCtrig1X(Stack[2][1],Stack[2][2],0x19C,Stack[2][3],Add,-604);
					SetCtrig1X(Stack[2][1],Stack[2][2],0x1B8,Stack[2][3],Add,-604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x15C,Stack[3][3],Add,-0x970);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x178,Stack[3][3],Add,-604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x198,Stack[3][3],Add,-604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x1B8,Stack[3][3],Add,-604);

					SetCtrigX("X","X",0x4,0,SetTo,Stack[3][1],Stack[3][2],0x0,0,Stack[3][3]);
					SetCtrigX(Stack[3][1],Stack[3][2],0x17C,Stack[3][3],SetTo,"X","X",0x0,0,1);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x19C,Stack[3][3],SetTo,EPD(Dest[1]));
					SetCtrig1X(Stack[3][1],Stack[3][2],0x1BC,Stack[3][3],SetTo,EPD(Dest[2]));
				},
				flag = {Preserved}
			}
		elseif Dest[4] == "W" or (Dest[4] == "SV" and Dest[5] == 2) then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Stack[2][1],Stack[2][2],0x15C,Stack[2][3],Add,-604);
					SetCtrig1X(Stack[2][1],Stack[2][2],0x178,Stack[2][3],Add,-604);
					SetCtrig1X(Stack[2][1],Stack[2][2],0x19C,Stack[2][3],Add,-604);
					SetCtrig1X(Stack[2][1],Stack[2][2],0x1B8,Stack[2][3],Add,-604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x15C,Stack[3][3],Add,-0x970);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x178,Stack[3][3],Add,-604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x198,Stack[3][3],Add,-604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x1B8,Stack[3][3],Add,-604);

					SetCtrigX("X","X",0x4,0,SetTo,Stack[3][1],Stack[3][2],0x0,0,Stack[3][3]);
					SetCtrigX(Stack[3][1],Stack[3][2],0x17C,Stack[3][3],SetTo,"X","X",0x0,0,1);
					SetCtrigX(Stack[3][1],Stack[3][2],0x19C,Stack[3][3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrigX(Stack[3][1],Stack[3][2],0x1BC,Stack[3][3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				},
				flag = {Preserved}
			}
		else -- LMem
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Stack[2][1],Stack[2][2],0x15C,Stack[2][3],Add,-604);
					SetCtrig1X(Stack[2][1],Stack[2][2],0x178,Stack[2][3],Add,-604);
					SetCtrig1X(Stack[2][1],Stack[2][2],0x19C,Stack[2][3],Add,-604);
					SetCtrig1X(Stack[2][1],Stack[2][2],0x1B8,Stack[2][3],Add,-604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x15C,Stack[3][3],Add,-0x970);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x178,Stack[3][3],Add,-604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x198,Stack[3][3],Add,-604);
					SetCtrig1X(Stack[3][1],Stack[3][2],0x1B8,Stack[3][3],Add,-604);

					SetCtrigX("X","X",0x4,0,SetTo,Stack[3][1],Stack[3][2],0x0,0,Stack[3][3]);
					SetCtrigX(Stack[3][1],Stack[3][2],0x17C,Stack[3][3],SetTo,"X","X",0x0,0,1);
					SetCtrigX(Stack[3][1],Stack[3][2],0x19C,Stack[3][3],SetTo,Dest[1][1],Dest[1][2],Dest[1][3],1,Dest[1][4]);
					SetCtrigX(Stack[3][1],Stack[3][2],0x1BC,Stack[3][3],SetTo,Dest[2][1],Dest[2][2],Dest[2][3],1,Dest[2][4]);
				},
				flag = {Preserved}
			}
		end

		if PDest ~= nil then
			MovW(PlayerID,PDest,{"X",WRet[8],0,"W"})
		end
	else -- SVA3~32
		local PDest
		if Dest[4] == "SVA" then
			PDest = Dest
			Dest = {"X",SRet[Dest[5][5]][4],0,"SV",Dest[5][5],Dest[5][7]}
		end

		if Dest[4] == "SV" and Dest[5] == Number then
			local Box1 = {}
			local Box2 = {SetCtrig1X(Stack[3][1],Stack[3][2],0x15C,Stack[3][3],Add,-0x970),SetCtrig1X(Stack[3][1],Stack[3][2],0x178,Stack[3][3],Add,-604)}
			for i = 1, Number do
				table.insert(Box1,SetCtrigX(Stack[3][1],Stack[3][2],0x19C+0x20*(i-1),Stack[3][3],SetTo,Dest[1],Dest[2],0x15C+0x40*(i-1),1,Dest[3]))
				table.insert(Box2,SetCtrig1X(Stack[2][1],Stack[2][2],0x15C+0x40*(i-1),Stack[2][3],Add,-604))
				table.insert(Box2,SetCtrig1X(Stack[2][1],Stack[2][2],0x178+0x40*(i-1),Stack[2][3],Add,-604))
				table.insert(Box2,SetCtrig1X(Stack[3][1],Stack[3][2],0x198+0x20*(i-1),Stack[3][3],Add,-604))
			end
			DoActions2X(PlayerID,Box2)

			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrigX("X","X",0x4,0,SetTo,Stack[3][1],Stack[3][2],0x0,0,Stack[3][3]);
					SetCtrigX(Stack[3][1],Stack[3][2],0x17C,Stack[3][3],SetTo,"X","X",0x0,0,1);
					Box1;
				},
				flag = {Preserved}
			}
		else
			NPop_InputData_Error()
		end
		if PDest ~= nil then
			MovS(PlayerID,PDest,Dest,SetTo)
		end
	end
end

function NQueue(PlayerID,Number,Size)
	-- ptr : EPD + Rear(0x30) / ptr2 : Next + EPD Mask + Front(0x30) 

	if Number < 1 or Number > 32 then
		NQueue_InputData_Error()
	end

	local NVArr = CreateSVArr(Number,Size+1,PlayerID)

	local PID = "X"
	if type(PlayerID) == "number" then
		PID = PlayerID
	end
	CreateVarXAlloc = CreateVarXAlloc + 2
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	table.insert(CreateVarPArr,{"NP1",PlayerID,Number,NVArr[2]})
	table.insert(CreateVarPArr,{"NP2",PlayerID,Number,NVArr[2]})

	local Nptr1 = {PID,CreateVarXAlloc-1,0,"V"} -- rear
	local Nptr2 = {PID,CreateVarXAlloc,0,"V"} -- front
	
	return {NVArr, Nptr1, Nptr2, "Queue"}
end

function NEnqueue(PlayerID,Queue,Source,Mask)
	STPopTrigArr(PlayerID)
	local Number = Queue[1][5]
	local Size = Queue[1][6]
	if Number == 1 then -- V/SVA1
		if Mask == nil then
			Mask = 0xFFFFFFFF
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		elseif type(Source) == "table" and Source[4] == "SVA" then
			local TempRet = {"X",SRet[Source[5][5]][3],0,"SV",Source[5][5],Source[5][7]}
			MovS(PlayerID,TempRet,Source)
			Source = TempRet
		end

		if type(Source) == "number" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Queue[2][1],Queue[2][2],0x30,Queue[2][3],Add,1); -- rear
					SetCtrig1X(Queue[2][1],Queue[2][2],0x15C,Queue[2][3],Add,604);
					SetCtrig1X(Queue[2][1],Queue[2][2],0x178,Queue[2][3],Add,604);

					SetCtrigX(Queue[2][1],Queue[2][2],0x158,Queue[2][3],SetTo,"X","X",0x158,1,2);
					SetCtrigX("X","X",0x4,1,SetTo,Queue[2][1],Queue[2][2],0x0,0,Queue[2][3]);
					SetCtrigX(Queue[2][1],Queue[2][2],0x4,Queue[2][3],SetTo,"X","X",0x0,0,2);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Queue[2][1],Queue[2][2],0x30,Queue[2][3],AtLeast,Size);
				},
				actions = {
					SetCtrig1X(Queue[2][1],Queue[2][2],0x30,Queue[2][3],Add,-Size);
					SetCtrig1X(Queue[2][1],Queue[2][2],0x15C,Queue[2][3],Add,-604*Size);
					SetCtrig1X(Queue[2][1],Queue[2][2],0x178,Queue[2][3],Add,-604*Size);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetMemoryX(0,SetTo,Source,Mask);
				},
				flag = {Preserved}
			}
		elseif Source[4] == "V" or (Source[4] == "SV" and Source[5] == 1) then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Queue[2][1],Queue[2][2],0x30,Queue[2][3],Add,1); -- rear
					SetCtrig1X(Queue[2][1],Queue[2][2],0x15C,Queue[2][3],Add,604);
					SetCtrig1X(Queue[2][1],Queue[2][2],0x178,Queue[2][3],Add,604);

					SetCtrigX(Queue[2][1],Queue[2][2],0x158,Queue[2][3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);

					SetCtrigX("X","X",0x4,1,SetTo,Queue[2][1],Queue[2][2],0x0,0,Queue[2][3]);
					SetCtrigX(Queue[2][1],Queue[2][2],0x4,Queue[2][3],SetTo,Source[1],Source[2],0x0,0,Source[3]);
					SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0x0,0,2);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Queue[2][1],Queue[2][2],0x30,Queue[2][3],AtLeast,Size);
				},
				actions = {
					SetCtrig1X(Queue[2][1],Queue[2][2],0x30,Queue[2][3],Add,-Size);
					SetCtrig1X(Queue[2][1],Queue[2][2],0x15C,Queue[2][3],Add,-604*Size);
					SetCtrig1X(Queue[2][1],Queue[2][2],0x178,Queue[2][3],Add,-604*Size);
				},
				flag = {Preserved}
			}
		else
			NEnqueue_InputData_Error()
		end
	elseif Number == 2 then -- W/SVA2
		if Mask == nil then
			Mask = {0xFFFFFFFF,0xFFFFFFFF}
		elseif type(Mask) == "number" then
			Mask = {Mask,Mask}
		end
		if type(Source) == "table" and Source[4] == "WA" then
			local TempRet = {"X",WRet[7],0,"W"}
			MovW(PlayerID,TempRet,Source)
			Source = TempRet
		elseif type(Source) == "table" and Source[4] == "SVA" then
			local TempRet = {"X",SRet[Source[5][5]][3],0,"SV",Source[5][5],Source[5][7]}
			MovS(PlayerID,TempRet,Source)
			Source = TempRet
		end

		if type(Source) == "number" or type(Source) == "string" or (type(Source) == "table" and type(Source[1]) == "number" and type(Source[2]) == "number" and #Source == 2) then
			if type(Source) == "number" then
				Source = {Source,0}
			elseif type(Source) == "string" then
				Source = I64(Source)
			end

			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Queue[2][1],Queue[2][2],0x30,Queue[2][3],Add,1); -- rear
					SetCtrig1X(Queue[2][1],Queue[2][2],0x15C,Queue[2][3],Add,604);
					SetCtrig1X(Queue[2][1],Queue[2][2],0x178,Queue[2][3],Add,604);
					SetCtrig1X(Queue[2][1],Queue[2][2],0x19C,Queue[2][3],Add,604);
					SetCtrig1X(Queue[2][1],Queue[2][2],0x1B8,Queue[2][3],Add,604);

					SetCtrigX(Queue[2][1],Queue[2][2],0x158,Queue[2][3],SetTo,"X","X",0x158,1,2);
					SetCtrigX(Queue[2][1],Queue[2][2],0x198,Queue[2][3],SetTo,"X","X",0x178,1,2);
					SetCtrigX("X","X",0x4,1,SetTo,Queue[2][1],Queue[2][2],0x0,0,Queue[2][3]);
					SetCtrigX(Queue[2][1],Queue[2][2],0x4,Queue[2][3],SetTo,"X","X",0x0,0,2);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Queue[2][1],Queue[2][2],0x30,Queue[2][3],AtLeast,Size);
				},
				actions = {
					SetCtrig1X(Queue[2][1],Queue[2][2],0x30,Queue[2][3],Add,-Size);
					SetCtrig1X(Queue[2][1],Queue[2][2],0x15C,Queue[2][3],Add,-604*Size);
					SetCtrig1X(Queue[2][1],Queue[2][2],0x178,Queue[2][3],Add,-604*Size);
					SetCtrig1X(Queue[2][1],Queue[2][2],0x19C,Queue[2][3],Add,-604*Size);
					SetCtrig1X(Queue[2][1],Queue[2][2],0x1B8,Queue[2][3],Add,-604*Size);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetMemoryX(0,SetTo,Source[1],Mask[1]);
					SetMemoryX(0,SetTo,Source[2],Mask[2]);
				},
				flag = {Preserved}
			}
		elseif Source[4] == "W" or (Source[4] == "SV" and Source[5] == 2) then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Queue[2][1],Queue[2][2],0x30,Queue[2][3],Add,1); -- rear
					SetCtrig1X(Queue[2][1],Queue[2][2],0x15C,Queue[2][3],Add,604);
					SetCtrig1X(Queue[2][1],Queue[2][2],0x178,Queue[2][3],Add,604);
					SetCtrig1X(Queue[2][1],Queue[2][2],0x19C,Queue[2][3],Add,604);
					SetCtrig1X(Queue[2][1],Queue[2][2],0x1B8,Queue[2][3],Add,604);

					SetCtrigX(Queue[2][1],Queue[2][2],0x158,Queue[2][3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
					SetCtrigX(Queue[2][1],Queue[2][2],0x198,Queue[2][3],SetTo,Source[1],Source[2],0x198,1,Source[3]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
					
					SetCtrigX("X","X",0x4,1,SetTo,Queue[2][1],Queue[2][2],0x0,0,Queue[2][3]);
					SetCtrigX(Queue[2][1],Queue[2][2],0x4,Queue[2][3],SetTo,Source[1],Source[2],0x0,0,Source[3]);
					SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0x0,0,2);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Queue[2][1],Queue[2][2],0x30,Queue[2][3],AtLeast,Size);
				},
				actions = {
					SetCtrig1X(Queue[2][1],Queue[2][2],0x30,Queue[2][3],Add,-Size);
					SetCtrig1X(Queue[2][1],Queue[2][2],0x15C,Queue[2][3],Add,-604*Size);
					SetCtrig1X(Queue[2][1],Queue[2][2],0x178,Queue[2][3],Add,-604*Size);
					SetCtrig1X(Queue[2][1],Queue[2][2],0x19C,Queue[2][3],Add,-604*Size);
					SetCtrig1X(Queue[2][1],Queue[2][2],0x1B8,Queue[2][3],Add,-604*Size);
				},
				flag = {Preserved}
			}
		else
			NEnqueue_InputData_Error()
		end
	else -- SVA3~32
		if Mask == nil then
			Mask = {}
			for i = 1, Number do
				table.insert(Mask,0xFFFFFFFF)
			end
		elseif type(Mask) == "number" then
			Mask = {Mask}
			for i = 2, Number do
				table.insert(Mask,Mask[1])
			end
		else
			for i = 1, Number do
				if Mask[i] == nil then
					Mask[i] = 0xFFFFFFFF
				end
			end
		end

		if type(Source) == "table" and Source[4] == "SVA" then
			local TempRet = {"X",SRet[Source[5][5]][3],0,"SV",Source[5][5],Source[5][7]}
			MovS(PlayerID,TempRet,Source)
			Source = TempRet
		end

		if type(Source) == "number" or (type(Source) == "table" and type(Source[4]) == "number" and #Source == Number) then
			if type(Source) == "number" then
				Source = {Source}
				for i = 2, Number do
					table.insert(Source,Source[1])
				end
			end

			local Box0 = {}
			local Box1 = {}
			local Box2 = {}
			local Box3 = {}
			for i = 1, Number do
				table.insert(Box0,SetCtrig1X(Queue[2][1],Queue[2][2],0x15C+0x40*(i-1),Queue[2][3],Add,-604*Size))
				table.insert(Box0,SetCtrig1X(Queue[2][1],Queue[2][2],0x178+0x40*(i-1),Queue[2][3],Add,-604*Size))
				table.insert(Box1,SetCtrigX(Queue[2][1],Queue[2][2],0x158+0x40*(i-1),Queue[2][3],SetTo,"X","X",0x158+0x20*(i-1),1,3))
				table.insert(Box2,SetMemoryX(0,SetTo,Source[i],Mask[i]))
				table.insert(Box3,SetCtrig1X(Queue[2][1],Queue[2][2],0x15C+0x40*(i-1),Queue[2][3],Add,604))
				table.insert(Box3,SetCtrig1X(Queue[2][1],Queue[2][2],0x178+0x40*(i-1),Queue[2][3],Add,604))
			end
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					Box3;
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Queue[2][1],Queue[2][2],0x30,Queue[2][3],Add,1); -- rear
					Box1;
					SetCtrigX("X","X",0x4,2,SetTo,Queue[2][1],Queue[2][2],0x0,0,Queue[2][3]);
					SetCtrigX(Queue[2][1],Queue[2][2],0x4,Queue[2][3],SetTo,"X","X",0x0,0,3);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Queue[2][1],Queue[2][2],0x30,Queue[2][3],AtLeast,Size);
				},
				actions = {
					Box0;
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Queue[2][1],Queue[2][2],0x30,Queue[2][3],AtLeast,Size);
				},
				actions = {
					SetCtrig1X(Queue[2][1],Queue[2][2],0x30,Queue[2][3],Add,-Size);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					Box2;
				},
				flag = {Preserved}
			}
		elseif Source[4] == "SV" and Source[5] == Number then
			local Box0 = {}
			local Box1 = {}
			local Box2 = {}
			local Box3 = {}
			for i = 1, Number do
				table.insert(Box0,SetCtrig1X(Queue[2][1],Queue[2][2],0x15C+0x40*(i-1),Queue[2][3],Add,-604*Size))
				table.insert(Box0,SetCtrig1X(Queue[2][1],Queue[2][2],0x178+0x40*(i-1),Queue[2][3],Add,-604*Size))
				table.insert(Box2,SetCtrigX(Queue[2][1],Queue[2][2],0x158+0x40*(i-1),Queue[2][3],SetTo,Source[1],Source[2],0x158+0x40*(i-1),1,Source[3]))
				table.insert(Box3,SetCtrig1X(Queue[2][1],Queue[2][2],0x15C+0x40*(i-1),Queue[2][3],Add,604))
				table.insert(Box3,SetCtrig1X(Queue[2][1],Queue[2][2],0x178+0x40*(i-1),Queue[2][3],Add,604))
				table.insert(Box3,SetCtrig1X(Source[1],Source[2],0x148+0x40*(i-1),Source[3],SetTo,Mask[i]))
				table.insert(Box3,SetCtrig1X(Source[1],Source[2],0x160+0x40*(i-1),Source[3],SetTo,SetTo*16777216,0xFF000000))
			end

			DoActions2X(PlayerID,Box3)
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Queue[2][1],Queue[2][2],0x30,Queue[2][3],Add,1); -- rear
					Box2;
					SetCtrigX("X","X",0x4,2,SetTo,Queue[2][1],Queue[2][2],0x0,0,Queue[2][3]);
					SetCtrigX(Queue[2][1],Queue[2][2],0x4,Queue[2][3],SetTo,Source[1],Source[2],0x0,0,Source[3]);
					SetCtrigX(Source[1],Source[2],0x4,Source[3],SetTo,"X","X",0x0,0,3);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Queue[2][1],Queue[2][2],0x30,Queue[2][3],AtLeast,Size);
				},
				actions = {
					Box0;
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Queue[2][1],Queue[2][2],0x30,Queue[2][3],AtLeast,Size);
				},
				actions = {
					SetCtrig1X(Queue[2][1],Queue[2][2],0x30,Queue[2][3],Add,-Size);
				},
				flag = {Preserved}
			}
		else
			NEnqueue_InputData_Error()
		end
	end
end

function NDequeue(PlayerID,Queue,Dest)
	STPopTrigArr(PlayerID)
	local Number = Queue[1][5]
	local Size = Queue[1][6]
	if Number == 1 then -- V/Mem/SVA1
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		elseif type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		elseif type(Dest) == "table" and Dest[4] == "SVA" then
			PDestS = Dest
			Dest = {"X",SRet[Dest[5][5]][4],0,"SV",Dest[5][5],Dest[5][7]}
		end

		if type(Dest) == "number" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Queue[3][1],Queue[3][2],0x30,Queue[3][3],Add,1); -- front
					SetCtrig1X(Queue[3][1],Queue[3][2],0x15C,Queue[3][3],Add,0x970);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x178,Queue[3][3],Add,604);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x198,Queue[3][3],Add,604);

					SetCtrigX("X","X",0x4,1,SetTo,Queue[3][1],Queue[3][2],0x0,0,Queue[3][3]);
					SetCtrigX(Queue[3][1],Queue[3][2],0x17C,Queue[3][3],SetTo,"X","X",0x0,0,2);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x19C,Queue[3][3],SetTo,EPD(Dest));
				},
				flag = {Preserved}
			}
		elseif Dest[4] == "V" or (Dest[4] == "SV" and Dest[5] == 1) then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Queue[3][1],Queue[3][2],0x30,Queue[3][3],Add,1); -- front
					SetCtrig1X(Queue[3][1],Queue[3][2],0x15C,Queue[3][3],Add,0x970);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x178,Queue[3][3],Add,604);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x198,Queue[3][3],Add,604);

					SetCtrigX("X","X",0x4,1,SetTo,Queue[3][1],Queue[3][2],0x0,0,Queue[3][3]);
					SetCtrigX(Queue[3][1],Queue[3][2],0x17C,Queue[3][3],SetTo,"X","X",0x0,0,2);
					SetCtrigX(Queue[3][1],Queue[3][2],0x19C,Queue[3][3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
				},
				flag = {Preserved}
			}
		else -- Mem
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Queue[3][1],Queue[3][2],0x30,Queue[3][3],Add,1); -- front
					SetCtrig1X(Queue[3][1],Queue[3][2],0x15C,Queue[3][3],Add,0x970);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x178,Queue[3][3],Add,604);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x198,Queue[3][3],Add,604);

					SetCtrigX("X","X",0x4,1,SetTo,Queue[3][1],Queue[3][2],0x0,0,Queue[3][3]);
					SetCtrigX(Queue[3][1],Queue[3][2],0x17C,Queue[3][3],SetTo,"X","X",0x0,0,2);
					SetCtrigX(Queue[3][1],Queue[3][2],0x19C,Queue[3][3],SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]);
				},
				flag = {Preserved}
			}
		end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Queue[3][1],Queue[3][2],0x30,Queue[3][3],AtLeast,Size);
				},
				actions = {
					SetCtrig1X(Queue[3][1],Queue[3][2],0x30,Queue[3][3],Add,-Size);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x15C,Queue[3][3],Add,-0x970*Size);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x178,Queue[3][3],Add,-604*Size);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x198,Queue[3][3],Add,-604*Size);
				},
				flag = {Preserved}
			}
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Number == 2 then -- W/LMem/SVA2
		local PDest
		if type(Dest) == "table" and Dest[4] == "WA" then
			PDest = Dest
			Dest = {"X",WRet[8],0,"W"}
		elseif type(Dest) == "table" and Dest[4] == "LA_V" then
			PDest = Dest
			Dest = {"X",WRet[8],0,"W"}
		elseif type(Dest) == "table" and Dest[4] == "LA_W" then
			PDest = Dest
			Dest = {"X",WRet[8],0,"W"}
		elseif type(Dest) == "table" and Dest[4] == "SVA" then
			PDestS = Dest
			Dest = {"X",SRet[Dest[5][5]][4],0,"SV",Dest[5][5],Dest[5][7]}
		end

		if type(Dest) == "number" or (type(Dest) == "table" and type(Dest[1]) == "number" and (type(Dest[2]) == "number" or (type(Dest[2]) == "table" and type(Dest[2][1]) == "number")) and #Dest == 2) then
			if type(Dest) == "number" then
				Dest = {Dest,Dest+4}
			elseif type(Dest) == "table" and type(Dest[2]) == "table" then
				Dest = {Dest[1],Dest[1]+Dest[2][1]}
			end

			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Queue[3][1],Queue[3][2],0x30,Queue[3][3],Add,1); -- front
					SetCtrig1X(Queue[3][1],Queue[3][2],0x15C,Queue[3][3],Add,0x970);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x178,Queue[3][3],Add,604);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x198,Queue[3][3],Add,604);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x1B8,Queue[3][3],Add,604);

					SetCtrigX("X","X",0x4,1,SetTo,Queue[3][1],Queue[3][2],0x0,0,Queue[3][3]);
					SetCtrigX(Queue[3][1],Queue[3][2],0x17C,Queue[3][3],SetTo,"X","X",0x0,0,2);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x19C,Queue[3][3],SetTo,EPD(Dest[1]));
					SetCtrig1X(Queue[3][1],Queue[3][2],0x1BC,Queue[3][3],SetTo,EPD(Dest[2]));
				},
				flag = {Preserved}
			}
		elseif Dest[4] == "W" or (Dest[4] == "SV" and Dest[5] == 2) then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Queue[3][1],Queue[3][2],0x30,Queue[3][3],Add,1); -- front
					SetCtrig1X(Queue[3][1],Queue[3][2],0x15C,Queue[3][3],Add,0x970);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x178,Queue[3][3],Add,604);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x198,Queue[3][3],Add,604);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x1B8,Queue[3][3],Add,604);

					SetCtrigX("X","X",0x4,1,SetTo,Queue[3][1],Queue[3][2],0x0,0,Queue[3][3]);
					SetCtrigX(Queue[3][1],Queue[3][2],0x17C,Queue[3][3],SetTo,"X","X",0x0,0,2);
					SetCtrigX(Queue[3][1],Queue[3][2],0x19C,Queue[3][3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
					SetCtrigX(Queue[3][1],Queue[3][2],0x1BC,Queue[3][3],SetTo,Dest[1],Dest[2],0x19C,1,Dest[3]);
				},
				flag = {Preserved}
			}
		else -- LMem
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Queue[3][1],Queue[3][2],0x30,Queue[3][3],Add,1); -- front
					SetCtrig1X(Queue[3][1],Queue[3][2],0x15C,Queue[3][3],Add,0x970);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x178,Queue[3][3],Add,604);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x198,Queue[3][3],Add,604);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x1B8,Queue[3][3],Add,604);

					SetCtrigX("X","X",0x4,1,SetTo,Queue[3][1],Queue[3][2],0x0,0,Queue[3][3]);
					SetCtrigX(Queue[3][1],Queue[3][2],0x17C,Queue[3][3],SetTo,"X","X",0x0,0,2);
					SetCtrigX(Queue[3][1],Queue[3][2],0x19C,Queue[3][3],SetTo,Dest[1][1],Dest[1][2],Dest[1][3],1,Dest[1][4]);
					SetCtrigX(Queue[3][1],Queue[3][2],0x1BC,Queue[3][3],SetTo,Dest[2][1],Dest[2][2],Dest[2][3],1,Dest[2][4]);
				},
				flag = {Preserved}
			}
		end
		Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Queue[3][1],Queue[3][2],0x30,Queue[3][3],AtLeast,Size);
				},
				actions = {
					SetCtrig1X(Queue[3][1],Queue[3][2],0x30,Queue[3][3],Add,-Size);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x15C,Queue[3][3],Add,-0x970*Size);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x178,Queue[3][3],Add,-604*Size);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x198,Queue[3][3],Add,-604*Size);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x1B8,Queue[3][3],Add,-604*Size);
				},
				flag = {Preserved}
			}
		if PDest ~= nil then
			MovW(PlayerID,PDest,{"X",WRet[8],0,"W"})
		end
	else -- SVA3~32
		local PDest
		if Dest[4] == "SVA" then
			PDest = Dest
			Dest = {"X",SRet[Dest[5][5]][4],0,"SV",Dest[5][5],Dest[5][7]}
		end

		if Dest[4] == "SV" and Dest[5] == Number then
			local Box0 = {}
			local Box1 = {}
			for i = 1, Number do
				table.insert(Box0,SetCtrig1X(Queue[3][1],Queue[3][2],0x198+0x20*(i-1),Queue[3][3],Add,-604*Size))
				table.insert(Box1,SetCtrig1X(Queue[3][1],Queue[3][2],0x198+0x20*(i-1),Queue[3][3],Add,604))
				table.insert(Box1,SetCtrigX(Queue[3][1],Queue[3][2],0x19C+0x20*(i-1),Queue[3][3],SetTo,Dest[1],Dest[2],0x15C+0x40*(i-1),1,Dest[3]))
			end

			DoActions2X(PlayerID,Box1)
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Queue[3][1],Queue[3][2],0x30,Queue[3][3],Add,1); -- front
					SetCtrig1X(Queue[3][1],Queue[3][2],0x15C,Queue[3][3],Add,0x970);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x178,Queue[3][3],Add,604);
					
					SetCtrigX("X","X",0x4,1,SetTo,Queue[3][1],Queue[3][2],0x0,0,Queue[3][3]);
					SetCtrigX(Queue[3][1],Queue[3][2],0x17C,Queue[3][3],SetTo,"X","X",0x0,0,2);
				},
				flag = {Preserved}
			}
		
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
					CtrigX(Queue[3][1],Queue[3][2],0x30,Queue[3][3],AtLeast,Size);
				},
				actions = {
					SetCtrig1X(Queue[3][1],Queue[3][2],0x30,Queue[3][3],Add,-Size);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x15C,Queue[3][3],Add,-0x970*Size);
					SetCtrig1X(Queue[3][1],Queue[3][2],0x178,Queue[3][3],Add,-604*Size);
					Box0;
				},
				flag = {Preserved}
			}
		else
			NDequeue_InputData_Error()
		end
		if PDest ~= nil then
			MovS(PlayerID,PDest,Dest,SetTo)
		end
	end
end

function NBag(PlayerID,Number,Size)
	-- ptr : EPD + Rear(0x30) / ptr2 : Next + EPD Mask + Front(0x30) 

	if Number < 1 or Number > 32 then
		NBag_InputData_Error()
	end

	local NVArr = CreateSVArr(Number,Size+1,PlayerID)

	local PID = "X"
	if type(PlayerID) == "number" then
		PID = PlayerID
	end
	CreateVarXAlloc = CreateVarXAlloc + 4
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end

	table.insert(CreateVarPArr,{"NP1",PlayerID,Number,NVArr[2]})
	table.insert(CreateVarPArr,{"NP2",PlayerID,Number,NVArr[2]})
	table.insert(CreateVarPArr,{"NP1",PlayerID,Number,NVArr[2]})
	table.insert(CreateVarPArr,{"NP2",PlayerID,Number,NVArr[2]})

	local Nptr1 = {PID,CreateVarXAlloc-3,0,"V"} 
	local Nptr2 = {PID,CreateVarXAlloc-2,0,"V"}
	local Iptr1 = {PID,CreateVarXAlloc-1,0,"V"} 
	local Iptr2 = {PID,CreateVarXAlloc,0,"V"}  
	local Index = CreateVar(PlayerID) -- Index
	local Temp = CreateSVar(Number,PlayerID)
	
	return {NVArr, Nptr1, Nptr2, "Bag", Index, Iptr1, Iptr2, Temp[1]}
end

function NAppend(PlayerID,Bag,Source,Mask)
	STPopTrigArr(PlayerID)
	local Number = Bag[1][5]
	if Number == 1 then -- V/SVA1
		if Mask == nil then
			Mask = 0xFFFFFFFF
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		elseif type(Source) == "table" and Source[4] == "SVA" then
			local TempRet = {"X",SRet[Source[5][5]][3],0,"SV",Source[5][5],Source[5][7]}
			MovS(PlayerID,TempRet,Source)
			Source = TempRet
		end

		if type(Source) == "number" then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Bag[2][1],Bag[2][2],0x30,Bag[2][3],Add,1);
					SetCtrig1X(Bag[2][1],Bag[2][2],0x15C,Bag[2][3],Add,604);
					SetCtrig1X(Bag[2][1],Bag[2][2],0x178,Bag[2][3],Add,604);
					SetCtrig1X(Bag[3][1],Bag[3][2],0x15C,Bag[3][3],Add,0x970);
					SetCtrig1X(Bag[3][1],Bag[3][2],0x178,Bag[3][3],Add,604);
					SetCtrig1X(Bag[3][1],Bag[3][2],0x198,Bag[3][3],Add,604);

					SetCtrigX(Bag[2][1],Bag[2][2],0x158,Bag[2][3],SetTo,"X","X",0x158,1,1);
					CallLabelAlways(Bag[2][1],Bag[2][2],Bag[2][3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetMemoryX(0,SetTo,Source,Mask);
				},
				flag = {Preserved}
			}
		elseif Source[4] == "V" or (Source[4] == "SV" and Source[5] == 1) then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Bag[2][1],Bag[2][2],0x30,Bag[2][3],Add,1);
					SetCtrig1X(Bag[2][1],Bag[2][2],0x15C,Bag[2][3],Add,604);
					SetCtrig1X(Bag[2][1],Bag[2][2],0x178,Bag[2][3],Add,604);
					SetCtrig1X(Bag[3][1],Bag[3][2],0x15C,Bag[3][3],Add,0x970);
					SetCtrig1X(Bag[3][1],Bag[3][2],0x178,Bag[3][3],Add,604);
					SetCtrig1X(Bag[3][1],Bag[3][2],0x198,Bag[3][3],Add,604);

					SetCtrigX(Bag[2][1],Bag[2][2],0x158,Bag[2][3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways2(Bag[2][1],Bag[2][2],Bag[2][3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
		else
			NAppend_InputData_Error()
		end
	elseif Number == 2 then -- W/SVA2
		if Mask == nil then
			Mask = {0xFFFFFFFF,0xFFFFFFFF}
		elseif type(Mask) == "number" then
			Mask = {Mask,Mask}
		end
		if type(Source) == "table" and Source[4] == "WA" then
			local TempRet = {"X",WRet[7],0,"W"}
			MovW(PlayerID,TempRet,Source)
			Source = TempRet
		elseif type(Source) == "table" and Source[4] == "SVA" then
			local TempRet = {"X",SRet[Source[5][5]][3],0,"SV",Source[5][5],Source[5][7]}
			MovS(PlayerID,TempRet,Source)
			Source = TempRet
		end

		if type(Source) == "number" or type(Source) == "string" or (type(Source) == "table" and type(Source[1]) == "number" and type(Source[2]) == "number" and #Source == 2) then
			if type(Source) == "number" then
				Source = {Source,0}
			elseif type(Source) == "string" then
				Source = I64(Source)
			end

			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Bag[2][1],Bag[2][2],0x30,Bag[2][3],Add,1);
					SetCtrig1X(Bag[2][1],Bag[2][2],0x15C,Bag[2][3],Add,604);
					SetCtrig1X(Bag[2][1],Bag[2][2],0x178,Bag[2][3],Add,604);
					SetCtrig1X(Bag[2][1],Bag[2][2],0x19C,Bag[2][3],Add,604);
					SetCtrig1X(Bag[2][1],Bag[2][2],0x1B8,Bag[2][3],Add,604);
					SetCtrig1X(Bag[3][1],Bag[3][2],0x15C,Bag[3][3],Add,0x970);
					SetCtrig1X(Bag[3][1],Bag[3][2],0x178,Bag[3][3],Add,604);
					SetCtrig1X(Bag[3][1],Bag[3][2],0x198,Bag[3][3],Add,604);
					SetCtrig1X(Bag[3][1],Bag[3][2],0x1B8,Bag[3][3],Add,604);

					SetCtrigX(Bag[2][1],Bag[2][2],0x158,Bag[2][3],SetTo,"X","X",0x158,1,1);
					SetCtrigX(Bag[2][1],Bag[2][2],0x198,Bag[2][3],SetTo,"X","X",0x178,1,1);
					CallLabelAlways(Bag[2][1],Bag[2][2],Bag[2][3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetMemoryX(0,SetTo,Source[1],Mask[1]);
					SetMemoryX(0,SetTo,Source[2],Mask[2]);
				},
				flag = {Preserved}
			}
		elseif Source[4] == "W" or (Source[4] == "SV" and Source[5] == 2) then
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					SetCtrig1X(Bag[2][1],Bag[2][2],0x30,Bag[2][3],Add,1);
					SetCtrig1X(Bag[2][1],Bag[2][2],0x15C,Bag[2][3],Add,604);
					SetCtrig1X(Bag[2][1],Bag[2][2],0x178,Bag[2][3],Add,604);
					SetCtrig1X(Bag[2][1],Bag[2][2],0x19C,Bag[2][3],Add,604);
					SetCtrig1X(Bag[2][1],Bag[2][2],0x1B8,Bag[2][3],Add,604);
					SetCtrig1X(Bag[3][1],Bag[3][2],0x15C,Bag[3][3],Add,0x970);
					SetCtrig1X(Bag[3][1],Bag[3][2],0x178,Bag[3][3],Add,604);
					SetCtrig1X(Bag[3][1],Bag[3][2],0x198,Bag[3][3],Add,604);
					SetCtrig1X(Bag[3][1],Bag[3][2],0x1B8,Bag[3][3],Add,604);

					SetCtrigX(Bag[2][1],Bag[2][2],0x158,Bag[2][3],SetTo,Source[1],Source[2],0x158,1,Source[3]);
					SetCtrigX(Bag[2][1],Bag[2][2],0x198,Bag[2][3],SetTo,Source[1],Source[2],0x198,1,Source[3]);
					SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,Mask[1]);
					SetCtrig1X(Source[1],Source[2],0x188,Source[3],SetTo,Mask[2]);
					SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
					SetCtrig1X(Source[1],Source[2],0x1A0,Source[3],SetTo,SetTo*16777216,0xFF000000);
					CallLabelAlways2(Bag[2][1],Bag[2][2],Bag[2][3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}
		else
			NAppend_InputData_Error()
		end
	else -- SVA3~32
		if Mask == nil then
			Mask = {}
			for i = 1, Number do
				table.insert(Mask,0xFFFFFFFF)
			end
		elseif type(Mask) == "number" then
			Mask = {Mask}
			for i = 2, Number do
				table.insert(Mask,Mask[1])
			end
		else
			for i = 1, Number do
				if Mask[i] == nil then
					Mask[i] = 0xFFFFFFFF
				end
			end
		end

		if type(Source) == "table" and Source[4] == "SVA" then
			local TempRet = {"X",SRet[Source[5][5]][3],0,"SV",Source[5][5],Source[5][7]}
			MovS(PlayerID,TempRet,Source)
			Source = TempRet
		end

		if type(Source) == "number" or (type(Source) == "table" and type(Source[4]) == "number" and #Source == Number) then
			if type(Source) == "number" then
				Source = {Source}
				for i = 2, Number do
					table.insert(Source,Source[1])
				end
			end

			local Box1 = {}
			local Box2 = {}
			local Box3 = {}
			for i = 1, Number do
				table.insert(Box1,SetCtrigX(Bag[2][1],Bag[2][2],0x158+0x40*(i-1),Bag[2][3],SetTo,"X","X",0x158+0x20*(i-1),1,1))
				table.insert(Box2,SetMemoryX(0,SetTo,Source[i],Mask[i]))
				table.insert(Box3,SetCtrig1X(Bag[2][1],Bag[2][2],0x15C+0x40*(i-1),Bag[2][3],Add,604))
				table.insert(Box3,SetCtrig1X(Bag[2][1],Bag[2][2],0x178+0x40*(i-1),Bag[2][3],Add,604))
				table.insert(Box3,SetCtrig1X(Bag[3][1],Bag[3][2],0x198+0x20*(i-1),Bag[3][3],Add,604))
			end
			DoActions2X(PlayerID,Box3)

			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					Box1;
					CallLabelAlways(Bag[2][1],Bag[2][2],Bag[2][3]);
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					Box2;
					SetCtrig1X(Bag[2][1],Bag[2][2],0x30,Bag[2][3],Add,1);
					SetCtrig1X(Bag[3][1],Bag[3][2],0x15C,Bag[3][3],Add,0x970);
					SetCtrig1X(Bag[3][1],Bag[3][2],0x178,Bag[3][3],Add,604);
				},
				flag = {Preserved}
			}
		elseif Source[4] == "SV" and Source[5] == Number then
			local Box1 = {}
			local Box2 = {}
			local Box3 = {SetCtrig1X(Bag[2][1],Bag[2][2],0x30,Bag[2][3],Add,1),SetCtrig1X(Bag[3][1],Bag[3][2],0x15C,Bag[3][3],Add,0x970),SetCtrig1X(Bag[3][1],Bag[3][2],0x178,Bag[3][3],Add,604)}
			for i = 1, Number do
				table.insert(Box1,SetCtrig1X(Source[1],Source[2],0x148+0x40*(i-1),Source[3],SetTo,Mask[i]))
				table.insert(Box1,SetCtrig1X(Source[1],Source[2],0x160+0x40*(i-1),Source[3],SetTo,SetTo*16777216,0xFF000000))
				table.insert(Box2,SetCtrigX(Bag[2][1],Bag[2][2],0x158+0x40*(i-1),Bag[2][3],SetTo,Source[1],Source[2],0x158+0x40*(i-1),1,Source[3]))
				table.insert(Box3,SetCtrig1X(Bag[2][1],Bag[2][2],0x15C+0x40*(i-1),Bag[2][3],Add,604))
				table.insert(Box3,SetCtrig1X(Bag[2][1],Bag[2][2],0x178+0x40*(i-1),Bag[2][3],Add,604))
				table.insert(Box3,SetCtrig1X(Bag[3][1],Bag[3][2],0x198+0x20*(i-1),Bag[3][3],Add,604))
			end
			DoActions2X(PlayerID,Box3)

			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					Box1;
				},
				flag = {Preserved}
			}
			Trigger {
				players = {PlayerID},
				conditions = {
					Label(0);
				},
				actions = {
					Box2;
					CallLabelAlways2(Bag[2][1],Bag[2][2],Bag[2][3],Source[1],Source[2],Source[3]);
				},
				flag = {Preserved}
			}	
		else
			NAppend_InputData_Error()
		end
	end
end

function NRemove(PlayerID,Bag)
	local Number = Bag[1][5]
	local Index = NBagIndexArr[NBagLoopptr]
	local PDest
	-- Bag[i] << Bag[#Bag], #Bag--

	local Box1 = {}
	local Box2 = {}
	local Box3 = {SetCtrig1X(Bag[2][1],Bag[2][2],0x30,Bag[2][3],Add,-1),SetCtrig1X(Bag[3][1],Bag[3][2],0x15C,Bag[3][3],Add,-0x970),SetCtrig1X(Bag[3][1],Bag[3][2],0x178,Bag[3][3],Add,-604)}
	for i = 1, Number do
		table.insert(Box1,SetCtrigX(Bag[3][1],Bag[3][2],0x19C+0x20*(i-1),Bag[3][3],SetTo,Bag[8][1],Bag[8][2],0x15C+0x40*(i-1),1,Bag[8][3]))
		table.insert(Box2,SetCtrigX(Bag[6][1],Bag[6][2],0x158+0x40*(i-1),Bag[6][3],SetTo,Bag[8][1],Bag[8][2],0x158+0x40*(i-1),1,Bag[8][3]))
		table.insert(Box3,SetCtrig1X(Bag[2][1],Bag[2][2],0x15C+0x40*(i-1),Bag[2][3],Add,-604))
		table.insert(Box3,SetCtrig1X(Bag[2][1],Bag[2][2],0x178+0x40*(i-1),Bag[2][3],Add,-604))
		table.insert(Box3,SetCtrig1X(Bag[3][1],Bag[3][2],0x198+0x20*(i-1),Bag[3][3],Add,-604))
	end
	table.insert(Box3,{SetCtrigX("X","X",0x4,0,SetTo,"X",Index,0x0,0,0)})

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,Bag[3][1],Bag[3][2],0x0,0,Bag[3][3]);
			SetCtrigX(Bag[3][1],Bag[3][2],0x17C,Bag[3][3],SetTo,"X","X",0x0,0,1);
			Box1;
		},
		flag = {Preserved}
	}

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			Box2;
			CallLabelAlways2(Bag[6][1],Bag[6][2],Bag[6][3],Bag[8][1],Bag[8][2],Bag[8][3]);
		},
		flag = {Preserved}
	}

	DoActions2X(PlayerID,Box3)
end

function NBagLoop2(PlayerID,Bag,Dest,Actions)
	NBagLoop(PlayerID,Bag,Dest,Actions,1)
end

function NBagLoop(PlayerID,Bag,Dest,Actions,UnPack)

	local Number = Bag[1][5]
	local Box0 = {SetCtrig1X(Bag[5][1],Bag[5][2],0x15C,Bag[5][3],SetTo,1),
					SetCtrigX(Bag[7][1],Bag[7][2],0x15C,Bag[7][3],SetTo,Bag[1][1],Bag[1][2],0x0,0,1),
					SetCtrigX(Bag[7][1],Bag[7][2],0x178,Bag[7][3],SetTo,Bag[1][1],Bag[1][2],0x4,1,1)}
	for i = 1, Number do
		table.insert(Box0,SetCtrigX(Bag[6][1],Bag[6][2],0x15C+0x40*(i-1),Bag[6][3],SetTo,Bag[1][1],Bag[1][2],0x15C+0x40*(i-1),1,1))
		table.insert(Box0,SetCtrigX(Bag[6][1],Bag[6][2],0x178+0x40*(i-1),Bag[6][3],SetTo,Bag[1][1],Bag[1][2],0x15C+0x40*(i-1),1,1))
		table.insert(Box0,SetCtrigX(Bag[7][1],Bag[7][2],0x198+0x20*(i-1),Bag[7][3],SetTo,Bag[1][1],Bag[1][2],0x158+0x40*(i-1),1,1))
	end

	DoActionsX(PlayerID,Box0)

	Trigger { 
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc);
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,Bag[5][1],Bag[5][2],0x0,0,0);
			SetCtrigX(Bag[5][1],Bag[5][2],0x4,Bag[5][3],SetTo,"X","X",0x0,0,1);
			SetCtrig1X("X",IndexAlloc+1,0x24,0,SetTo,0);
			SetCtrig1X(Bag[5][1],Bag[5][2],0x160,Bag[5][3],SetTo,Add*16777216,0xFF000000);
			SetCtrigX(Bag[5][1],Bag[5][2],0x158,Bag[5][3],SetTo,"X",IndexAlloc+1,0x24,1,0);
		},
		flag = {Preserved}
	}

	if UnPack == 1 then
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID,1)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+1);
			CtrigX(Bag[2][1],Bag[2][2],0x30,Bag[2][3],AtLeast,0); -- Max >= Index
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
			Actions,
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+2);
		},
		actions = {
	   		PreserveTrigger();
		},
	}
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(IndexAlloc+3);
		},
		actions = {
			SetDeaths(0,SetTo,0,0);
	   		PreserveTrigger();
		},
	}
	PlayerID = PlayerConvert(PlayerID)
	table.insert(NWhileXArr, IndexAlloc)
	table.insert(NWhileXPArr, PlayerID)
	table.insert(NBagLoopArr,Bag)
	table.insert(NBagIndexArr, IndexAlloc)
	NWhileXptr = NWhileXptr + 1
	NBagLoopptr = NBagLoopptr + 1
	IndexAlloc = IndexAlloc + 0x5

	local Box1 = {}
	for i = 1, Number do
		table.insert(Box1,SetCtrigX(Bag[7][1],Bag[7][2],0x19C+0x20*(i-1),Bag[7][3],SetTo,Bag[8][1],Bag[8][2],0x15C+0x40*(i-1),1,Bag[8][3]))
	end

	Trigger {
		players = {PlayerID},
		conditions = {
			Label(0);
		},
		actions = {
			SetCtrigX("X","X",0x4,0,SetTo,Bag[7][1],Bag[7][2],0x0,0,Bag[7][3]);
			SetCtrigX(Bag[7][1],Bag[7][2],0x17C,Bag[7][3],SetTo,"X","X",0x0,0,1);
			Box1;
		},
		flag = {Preserved}
	}

	SMov(PlayerID,Dest,Bag[8],SetTo)
end

function NBagLoopEnd2(Actions)
	NBagLoopEnd(Actions,1)
end

function NBagLoopEnd(Actions,UnPack)
	local PlayerID
	PlayerID = NWhileXPArr[NWhileXptr]
	local Bag = NBagLoopArr[NBagLoopptr]
	local Number = Bag[1][5]

	local Box0 = {SetCtrig1X(Bag[5][1],Bag[5][2],0x15C,Bag[5][3],Add,1),SetCtrig1X(Bag[7][1],Bag[7][2],0x15C,Bag[7][3],Add,0x970),SetCtrig1X(Bag[7][1],Bag[7][2],0x178,Bag[7][3],Add,604)}
	for i = 1, Number do
		table.insert(Box0,SetCtrig1X(Bag[6][1],Bag[6][2],0x15C+0x40*(i-1),Bag[6][3],Add,604))
		table.insert(Box0,SetCtrig1X(Bag[6][1],Bag[6][2],0x178+0x40*(i-1),Bag[6][3],Add,604))
		table.insert(Box0,SetCtrig1X(Bag[7][1],Bag[7][2],0x198+0x20*(i-1),Bag[7][3],Add,604))
	end

	DoActions2X(PlayerID,Box0)

	local Index
	Index = NWhileXArr[NWhileXptr] + 4
	local PlayerID
	PlayerID = NWhileXPArr[NWhileXptr]
	table.remove(NWhileXArr,NWhileXptr)
	table.remove(NWhileXPArr,NWhileXptr)
	table.remove(NBagLoopArr,NBagLoopptr)
	table.remove(NBagIndexArr,NBagLoopptr)
	NWhileXptr = NWhileXptr - 1
	NBagLoopptr = NBagLoopptr - 1

	for k, P in pairs(PlayerID) do
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index,0x4,0,SetTo,"X",Index-4,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-2,0x4,0,SetTo,"X",Index,0x0,0,1))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-3,0x158,0,SetTo,"X",Index-3,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-3,0x15C,0,SetTo,"X",Index-1,0x0,0,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x158,0,SetTo,"X",Index-3,0x4,1,0))
		table.insert(CtrigInitArr[P+1], SetCtrigX("X",Index-1,0x15C,0,SetTo,"X",Index-2,0x0,0,0))
	end
	if UnPack == 1 then
		if Actions ~= nil then
		for k, v in pairs(Actions) do
			local Temp = CunPack(v)
			Actions[k] = Temp
		end
	end
	end
	Actions = __FlattenCAct(Actions)

	STPopTrigArr(PlayerID)
	Actions = PopActArr(Actions)
	PopTrigArr(PlayerID)
	Trigger {
		players = {PlayerID},
		conditions = {
			Label(Index);
		},
		actions = {
			Actions,
			PreserveTrigger();
		},
	}
end

function NReset(PlayerID,Header) -- Stack Queue Bag 공통
	if Header[4] == "Stack" then
		local Stack = Header
		local Number = Stack[1][5]
		local Box0 = {SetCtrigX(Stack[3][1],Stack[3][2],0x15C,Stack[3][3],SetTo,Stack[1][1],Stack[1][2],0x0,0,0),
						SetCtrigX(Stack[3][1],Stack[3][2],0x178,Stack[3][3],SetTo,Stack[1][1],Stack[1][2],0x4,1,0)}
		for i = 1, Number do
			table.insert(Box0,SetCtrigX(Stack[2][1],Stack[2][2],0x15C+0x40*(i-1),Stack[2][3],SetTo,Stack[1][1],Stack[1][2],0x15C+0x40*(i-1),1,0))
			table.insert(Box0,SetCtrigX(Stack[2][1],Stack[2][2],0x178+0x40*(i-1),Stack[2][3],SetTo,Stack[1][1],Stack[1][2],0x15C+0x40*(i-1),1,0))
			table.insert(Box0,SetCtrigX(Stack[3][1],Stack[3][2],0x198+0x20*(i-1),Stack[3][3],SetTo,Stack[1][1],Stack[1][2],0x158+0x40*(i-1),1,0))
		end
		DoActionsX(PlayerID,Box0)
	elseif Header[4] == "Queue" then
		local Queue = Header
		local Number = Queue[1][5]
		local Box0 = {SetCtrig1X(Queue[2][1],Queue[2][2],0x30,Queue[2][3],SetTo,0),
						SetCtrig1X(Queue[3][1],Queue[3][2],0x30,Queue[3][3],SetTo,0),
						SetCtrigX(Queue[3][1],Queue[3][2],0x15C,Queue[3][3],SetTo,Queue[1][1],Queue[1][2],0x0,0,0),
						SetCtrigX(Queue[3][1],Queue[3][2],0x178,Queue[3][3],SetTo,Queue[1][1],Queue[1][2],0x4,1,0)}
		for i = 1, Number do
			table.insert(Box0,SetCtrigX(Queue[2][1],Queue[2][2],0x15C+0x40*(i-1),Queue[2][3],SetTo,Queue[1][1],Queue[1][2],0x15C+0x40*(i-1),1,0))
			table.insert(Box0,SetCtrigX(Queue[2][1],Queue[2][2],0x178+0x40*(i-1),Queue[2][3],SetTo,Queue[1][1],Queue[1][2],0x15C+0x40*(i-1),1,0))
			table.insert(Box0,SetCtrigX(Queue[3][1],Queue[3][2],0x198+0x20*(i-1),Queue[3][3],SetTo,Queue[1][1],Queue[1][2],0x158+0x40*(i-1),1,0))
		end
		DoActionsX(PlayerID,Box0)
	elseif Header[4] == "Bag" then
		local Bag = Header
		local Number = Bag[1][5]
		local Box0 = {SetCtrig1X(Bag[2][1],Bag[2][2],0x30,Bag[2][3],SetTo,0),
						SetCtrigX(Bag[3][1],Bag[3][2],0x15C,Bag[3][3],SetTo,Bag[1][1],Bag[1][2],0x0,0,0),
						SetCtrigX(Bag[3][1],Bag[3][2],0x178,Bag[3][3],SetTo,Bag[1][1],Bag[1][2],0x4,1,0)}
		for i = 1, Number do
			table.insert(Box0,SetCtrigX(Bag[2][1],Bag[2][2],0x15C+0x40*(i-1),Bag[2][3],SetTo,Bag[1][1],Bag[1][2],0x15C+0x40*(i-1),1,0))
			table.insert(Box0,SetCtrigX(Bag[2][1],Bag[2][2],0x178+0x40*(i-1),Bag[2][3],SetTo,Bag[1][1],Bag[1][2],0x15C+0x40*(i-1),1,0))
			table.insert(Box0,SetCtrigX(Bag[3][1],Bag[3][2],0x198+0x20*(i-1),Bag[3][3],SetTo,Bag[1][1],Bag[1][2],0x158+0x40*(i-1),1,0))
		end
		DoActionsX(PlayerID,Box0)
	else
		NReset_InputData_Error()
	end
end

function CEPD(PlayerID,Dest,Source,Deviation)
	STPopTrigArr(PlayerID)

	if Deviation == nil then
		Deviation = 0 
	end

	if Source == nil then
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end

		local CBit = bit32.lshift(1,2)-1
		local NBit = CBit+CBit+1
		local Repeat = 32-2
		local RShiftAct = {}

		if type(Dest) == "number" then
			table.insert(RShiftAct,SetMemoryX(Dest,SetTo,0,CBit))
			for i = 1, Repeat do
				table.insert(RShiftAct,SetMemoryX(Dest,Subtract,CBit,NBit))
				CBit = bit32.lshift(CBit,1) NBit = bit32.lshift(NBit,1)
			end
			table.insert(RShiftAct,SetMemory(Dest,Add,Deviation-1452249))
		elseif Dest == "Cp" then
			table.insert(RShiftAct,SetDeathsX(CurrentPlayer,SetTo,0,0,CBit))
			for i = 1, Repeat do
				table.insert(RShiftAct,SetDeathsX(CurrentPlayer,Subtract,CBit,0,NBit))
				CBit = bit32.lshift(CBit,1) NBit = bit32.lshift(NBit,1)
			end
			table.insert(RShiftAct,SetDeaths(CurrentPlayer,Add,Deviation-1452249,0))
		elseif Dest[4] == "V" then
			table.insert(RShiftAct,SetNVar(Dest,SetTo,0,CBit))
			for i = 1, Repeat do
				table.insert(RShiftAct,SetNVar(Dest,Subtract,CBit,NBit))
				CBit = bit32.lshift(CBit,1) NBit = bit32.lshift(NBit,1)
			end
			table.insert(RShiftAct,SetNVar(Dest,Add,Deviation-1452249))
		else
			table.insert(RShiftAct,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,0,CBit))
			for i = 1, Repeat do
				table.insert(RShiftAct,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Subtract,CBit,NBit))
				CBit = bit32.lshift(CBit,1) NBit = bit32.lshift(NBit,1)
			end
			table.insert(RShiftAct,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,Deviation-1452249))
		end

		Trigger {
				players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						RShiftAct;
					},
					flag = {Preserved}
				}
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CEPD_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end

		if type(Source) == "number" then -- And V, 0x58A364, 1 : V << 0x58A364 & 1 / Read필요
			CEPD_InputData_Error()
		elseif Source == "Cp" then
			CEPD_InputData_Error()
		elseif Source[4] == "V" then
			local Box0, Box1, Box2
			if type(Dest) == "number" then
				Box0 = SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(Dest))
			elseif Dest == "Cp" then
				Box0 = SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,13)
			elseif Dest[4] == "V" then
				Box0 = SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3])
			else
				Box0 = SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4])
			end
			Trigger {
				players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						Box0;
						SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
						SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
						CallLabelAlways(Source[1],Source[2],Source[3]);
					},
					flag = {Preserved}
				}

			local CBit = bit32.lshift(1,2)-1
			local NBit = CBit+CBit+1
			if type(Dest) == "number" then
				Box1 = {SetMemoryX(Dest,SetTo,0,CBit)}
			elseif Dest == "Cp" then
				Box1 = {SetDeathsX(CurrentPlayer,SetTo,0,0,CBit)}
			elseif Dest[4] == "V" then
				Box1 = {SetNVar(Dest,SetTo,0,CBit)}
			else
				Box1 = {SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,0,CBit)}
			end
			local RShiftAct = Box1
			local Repeat = 32-2
			for i = 1, Repeat do
				if type(Dest) == "number" then
					table.insert(RShiftAct,SetMemoryX(Dest,Subtract,CBit,NBit))
				elseif Dest == "Cp" then
					table.insert(RShiftAct,SetDeathsX(CurrentPlayer,Subtract,CBit,0,NBit))
				elseif Dest[4] == "V" then
					table.insert(RShiftAct,SetNVar(Dest,Subtract,CBit,NBit))
				else
					table.insert(RShiftAct,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Subtract,CBit,NBit))
				end
				CBit = bit32.lshift(CBit,1)
				NBit = bit32.lshift(NBit,1)
			end
			if type(Dest) == "number" then
				Box2 = SetMemory(Dest,Add,Deviation-1452249)
			elseif Dest == "Cp" then
				Box2 = SetDeaths(CurrentPlayer,Add,Deviation-1452249,0)
			elseif Dest[4] == "V" then
				Box2 = SetCtrig1X(Dest[1],Dest[2],0x15C,Dest[3],Add,Deviation-1452249)
			else
				Box2 = SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,Deviation-1452249)
			end
			Trigger {
				players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						RShiftAct;
						Box2;
					},
					flag = {Preserved}
				}
		else 
			CEPD_InputData_Error()
		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	end
end

function CrShift(PlayerID,Dest,Source,Operand) -- >> (/2)
	STPopTrigArr(PlayerID)

	if Operand == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CrShift_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end

		if type(Source) == "number" then
			if Source >= 32 or Source <= 0 then
				Source = math.abs(Source % 32)
			end
			if Source ~= 0 then
				local CBit = bit32.lshift(1,Source)-1
				local NBit = CBit+CBit+1
				local Repeat = 32-Source
				local RShiftAct = {}

				if type(Dest) == "number" then
					table.insert(RShiftAct,SetMemoryX(Dest,SetTo,0,CBit))
					for i = 1, Repeat do
						table.insert(RShiftAct,SetMemoryX(Dest,Subtract,CBit,NBit))
						CBit = bit32.lshift(CBit,1) NBit = bit32.lshift(NBit,1)
					end
				elseif Dest == "Cp" then
					table.insert(RShiftAct,SetDeathsX(CurrentPlayer,SetTo,0,0,CBit))
					for i = 1, Repeat do
						table.insert(RShiftAct,SetDeathsX(CurrentPlayer,Subtract,CBit,0,NBit))
						CBit = bit32.lshift(CBit,1) NBit = bit32.lshift(NBit,1)
					end
				elseif Dest[4] == "V" then
					table.insert(RShiftAct,SetNVar(Dest,SetTo,0,CBit))
					for i = 1, Repeat do
						table.insert(RShiftAct,SetNVar(Dest,Subtract,CBit,NBit))
						CBit = bit32.lshift(CBit,1) NBit = bit32.lshift(NBit,1)
					end
				else
					table.insert(RShiftAct,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,0,CBit))
					for i = 1, Repeat do
						table.insert(RShiftAct,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Subtract,CBit,NBit))
						CBit = bit32.lshift(CBit,1) NBit = bit32.lshift(NBit,1)
					end
				end

				Trigger {
						players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								RShiftAct;
							},
							flag = {Preserved}
						}
			end
		elseif Source[4] == "V" then
			Trigger {
				players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x4,5,SetTo,"X","X",0x0,0,6);
					},
					flag = {Preserved}
				}
			for i = 4, 0, -1 do
				local CBit = bit32.lshift(1,i)
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
							CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,CBit,CBit);
						},
						actions = {
							SetCtrig1X("X","X",0x4,i,Add,0x970*CBit);
						},
						flag = {Preserved}
					}
			end
			for Source = 0, 31 do
				if Source == 0 then
					Trigger {
						players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,32);
							},
							flag = {Preserved}
						}
				else
					local CBit = bit32.lshift(1,Source)-1
					local NBit = CBit+CBit+1
					local Repeat = 32-Source
					local RShiftAct = {}

					if type(Dest) == "number" then
						table.insert(RShiftAct,SetMemoryX(Dest,SetTo,0,CBit))
						for i = 1, Repeat do
							table.insert(RShiftAct,SetMemoryX(Dest,Subtract,CBit,NBit))
							CBit = bit32.lshift(CBit,1) NBit = bit32.lshift(NBit,1)
						end
					elseif Dest == "Cp" then
						table.insert(RShiftAct,SetDeathsX(CurrentPlayer,SetTo,0,0,CBit))
						for i = 1, Repeat do
							table.insert(RShiftAct,SetDeathsX(CurrentPlayer,Subtract,CBit,0,NBit))
							CBit = bit32.lshift(CBit,1) NBit = bit32.lshift(NBit,1)
						end
					elseif Dest[4] == "V" then
						table.insert(RShiftAct,SetNVar(Dest,SetTo,0,CBit))
						for i = 1, Repeat do
							table.insert(RShiftAct,SetNVar(Dest,Subtract,CBit,NBit))
							CBit = bit32.lshift(CBit,1) NBit = bit32.lshift(NBit,1)
						end
					else
						table.insert(RShiftAct,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,0,CBit))
						for i = 1, Repeat do
							table.insert(RShiftAct,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Subtract,CBit,NBit))
							CBit = bit32.lshift(CBit,1) NBit = bit32.lshift(NBit,1)
						end
					end

					Trigger {
						players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								RShiftAct;
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,32-Source);
							},
							flag = {Preserved}
						}
				end
			end
		else
			CrShift_InputData_Error()
		end

		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Operand) == "table" and Operand[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Operand)
			Operand = TempRet
		end
		if type(Operand) == "table" and Operand[4] == "A" then
			CrShift_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CrShift_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end

		if type(Source) == "number" then -- And V, 0x58A364, 1 : V << 0x58A364 & 1 / Read필요
			if type(Operand) == "number" then
				CrShift_InputData_Error()
			elseif Operand[4] == "V" then -- And V, 0x58A364, X : V << 0x58A364 & X / Read필요
				CrShift_InputData_Error()
			else
				CrShift_InputData_Error()
			end
		elseif Source == "Cp" then
			if type(Operand) == "number" then -- And V, Cp, 1 : V << Cp & 1 / Read필요 
				CrShift_InputData_Error()
			elseif Operand[4] == "V" then -- And V, Cp, X : V << Cp & X / Read필요 
				CrShift_InputData_Error()
			else
				CrShift_InputData_Error()
			end
		elseif Source[4] == "V" then
			if type(Operand) == "number" then -- And A, 1 : A >>= 1 (max 31)
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				if Operand >= 32 or Operand <= 0 then
					Operand = math.abs(Operand % 32)
				end
				if Operand ~= 0 then
					local CBit = bit32.lshift(1,Operand)-1
					local NBit = CBit+CBit+1
					local RShiftAct = {SetNVar(Dest,SetTo,0,CBit)}
					local Repeat = 32-Operand
					for i = 1, Repeat do
						table.insert(RShiftAct,SetNVar(Dest,Subtract,CBit,NBit))
						CBit = bit32.lshift(CBit,1)
						NBit = bit32.lshift(NBit,1)
					end
					Trigger {
						players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								RShiftAct;
							},
							flag = {Preserved}
						}
				end
			elseif Operand[4] == "V" then -- And X, Y : X <<= Y
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x4,5,SetTo,"X","X",0x0,0,6);
						},
						flag = {Preserved}
					}
				for i = 4, 0, -1 do
					local CBit = 2^i
					Trigger {
						players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX(Operand[1],Operand[2],0x15C,Operand[3],Exactly,CBit,CBit);
							},
							actions = {
								SetCtrig1X("X","X",0x4,i,Add,0x970*CBit);
							},
							flag = {Preserved}
						}
				end
				for Operand = 0, 31 do
					if Operand == 0 then
						Trigger {
							players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,32);
								},
								flag = {Preserved}
							}
					else
						local CBit = bit32.lshift(1,Operand)-1
						local NBit = CBit+CBit+1
						local RShiftAct = {SetNVar(Dest,SetTo,0,CBit)}
						local Repeat = 32-Operand
						for i = 1, Repeat do
							table.insert(RShiftAct,SetNVar(Dest,Subtract,CBit,NBit))
							CBit = bit32.lshift(CBit,1)
							NBit = bit32.lshift(NBit,1)
						end
						Trigger {
							players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									RShiftAct;
									SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,32-Operand);
								},
								flag = {Preserved}
							}
					end
				end
			else
				CrShift_InputData_Error()
			end
		else 
			if type(Operand) == "number" then -- And V, Mem, 1 : V << Mem & 1 / Read필요
				CrShift_InputData_Error()
			elseif Operand[4] == "V" then -- And V, Mem, X : V << Mem & X / Read필요
				CrShift_InputData_Error()
			else
				CrShift_InputData_Error()
			end
		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CrShift_InputData_Error()
	end
end

function ClShift2(PlayerID,Dest,Source,Operand) -- >> (/2)
	STPopTrigArr(PlayerID)

	if Operand == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			ClShift2_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end

		if type(Source) == "number" then
			if Source >= 32 or Source <= 0 then
				Source = math.abs(Source % 32)
			end
			if Source ~= 0 then
				local CBit = bit32.lshift(bit32.lshift(1,Source)-1,32-Source)
				local NBit = bit32.rshift(CBit,1)
				local RBit = bit32.lshift(1,31-Source)+CBit
				local LShiftAct = {}
				local Repeat = 32-Source

				if type(Dest) == "number" then
					for i = 1, Repeat do
						table.insert(LShiftAct,SetMemoryX(Dest,SetTo,0,CBit))
						table.insert(LShiftAct,SetMemoryX(Dest,Add,NBit,RBit))
						CBit = bit32.rshift(CBit,1)
						NBit = bit32.rshift(NBit,1)
						RBit = bit32.rshift(RBit,1)
					end
					table.insert(LShiftAct,SetMemoryX(Dest,SetTo,0,bit32.lshift(1,Source)-1))
				elseif Dest == "Cp" then
					for i = 1, Repeat do
						table.insert(LShiftAct,SetDeathsX(CurrentPlayer,SetTo,0,0,CBit))
						table.insert(LShiftAct,SetDeathsX(CurrentPlayer,Add,NBit,0,RBit))
						CBit = bit32.rshift(CBit,1)
						NBit = bit32.rshift(NBit,1)
						RBit = bit32.rshift(RBit,1)
					end
					table.insert(LShiftAct,SetDeathsX(CurrentPlayer,SetTo,0,0,bit32.lshift(1,Source)-1))
				elseif Dest[4] == "V" then
					for i = 1, Repeat do
						table.insert(LShiftAct,SetNVar(Dest,SetTo,0,CBit))
						table.insert(LShiftAct,SetNVar(Dest,Add,NBit,RBit))
						CBit = bit32.rshift(CBit,1)
						NBit = bit32.rshift(NBit,1)
						RBit = bit32.rshift(RBit,1)
					end
					table.insert(LShiftAct,SetNVar(Dest,SetTo,0,bit32.lshift(1,Source)-1))
				else
					for i = 1, Repeat do
						table.insert(LShiftAct,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,0,CBit))
						table.insert(LShiftAct,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,NBit,RBit))
						CBit = bit32.rshift(CBit,1)
						NBit = bit32.rshift(NBit,1)
						RBit = bit32.rshift(RBit,1)
					end
					table.insert(LShiftAct,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,0,bit32.lshift(1,Source)-1))
				end
					
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							LShiftAct;
						},
						flag = {Preserved}
					}
			end
		elseif Source[4] == "V" then
			Trigger {
				players = {PlayerID},
					conditions = {
						Label(0);
					},
					actions = {
						SetCtrigX("X","X",0x4,5,SetTo,"X","X",0x0,0,6);
					},
					flag = {Preserved}
				}
			for i = 4, 0, -1 do
				local CBit = bit32.lshift(1,i)
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
							CtrigX(Source[1],Source[2],0x15C,Source[3],Exactly,CBit,CBit);
						},
						actions = {
							SetCtrig1X("X","X",0x4,i,Add,0x970*CBit);
						},
						flag = {Preserved}
					}
			end
			for Source = 0, 31 do
				if Source == 0 then
					Trigger {
						players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,32);
							},
							flag = {Preserved}
						}
				else
					local CBit = bit32.lshift(bit32.lshift(1,Source)-1,32-Source)
					local NBit = bit32.rshift(CBit,1)
					local RBit = bit32.lshift(1,31-Source)+CBit
					local LShiftAct = {}
					local Repeat = 32-Source

					if type(Dest) == "number" then
						for i = 1, Repeat do
							table.insert(LShiftAct,SetMemoryX(Dest,SetTo,0,CBit))
							table.insert(LShiftAct,SetMemoryX(Dest,Add,NBit,RBit))
							CBit = bit32.rshift(CBit,1)
							NBit = bit32.rshift(NBit,1)
							RBit = bit32.rshift(RBit,1)
						end
						table.insert(LShiftAct,SetMemoryX(Dest,SetTo,0,bit32.lshift(1,Source)-1))
					elseif Dest == "Cp" then
						for i = 1, Repeat do
							table.insert(LShiftAct,SetDeathsX(CurrentPlayer,SetTo,0,0,CBit))
							table.insert(LShiftAct,SetDeathsX(CurrentPlayer,Add,NBit,0,RBit))
							CBit = bit32.rshift(CBit,1)
							NBit = bit32.rshift(NBit,1)
							RBit = bit32.rshift(RBit,1)
						end
						table.insert(LShiftAct,SetDeathsX(CurrentPlayer,SetTo,0,0,bit32.lshift(1,Source)-1))
					elseif Dest[4] == "V" then
						for i = 1, Repeat do
							table.insert(LShiftAct,SetNVar(Dest,SetTo,0,CBit))
							table.insert(LShiftAct,SetNVar(Dest,Add,NBit,RBit))
							CBit = bit32.rshift(CBit,1)
							NBit = bit32.rshift(NBit,1)
							RBit = bit32.rshift(RBit,1)
						end
						table.insert(LShiftAct,SetNVar(Dest,SetTo,0,bit32.lshift(1,Source)-1))
					else
						for i = 1, Repeat do
							table.insert(LShiftAct,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,0,CBit))
							table.insert(LShiftAct,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,NBit,RBit))
							CBit = bit32.rshift(CBit,1)
							NBit = bit32.rshift(NBit,1)
							RBit = bit32.rshift(RBit,1)
						end
						table.insert(LShiftAct,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,0,bit32.lshift(1,Source)-1))
					end

					Trigger {
						players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								LShiftAct;
								SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,32-Source);
							},
							flag = {Preserved}
						}
				end
			end
		else
			ClShift2_InputData_Error()
		end

		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Operand) == "table" and Operand[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Operand)
			Operand = TempRet
		end
		if type(Operand) == "table" and Operand[4] == "A" then
			ClShift2_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			ClShift2_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end

		if type(Source) == "number" then -- And V, 0x58A364, 1 : V << 0x58A364 & 1 / Read필요
			if type(Operand) == "number" then
				ClShift2_InputData_Error()
			elseif Operand[4] == "V" then -- And V, 0x58A364, X : V << 0x58A364 & X / Read필요
				ClShift2_InputData_Error()
			else
				ClShift2_InputData_Error()
			end
		elseif Source == "Cp" then
			if type(Operand) == "number" then -- And V, Cp, 1 : V << Cp & 1 / Read필요 
				ClShift2_InputData_Error()
			elseif Operand[4] == "V" then -- And V, Cp, X : V << Cp & X / Read필요 
				ClShift2_InputData_Error()
			else
				ClShift2_InputData_Error()
			end
		elseif Source[4] == "V" then
			if type(Operand) == "number" then -- And A, 1 : A >>= 1 (max 31)
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				if Operand >= 32 or Operand <= 0 then
					Operand = math.abs(Operand % 32)
				end
				if Operand ~= 0 then
					local CBit = bit32.lshift(bit32.lshift(1,Operand)-1,32-Operand)
					local NBit = bit32.rshift(CBit,1)
					local RBit = bit32.lshift(1,31-Operand)+CBit
					local LShiftAct = {}
					local Repeat = 32-Operand

					if type(Dest) == "number" then
						for i = 1, Repeat do
							table.insert(LShiftAct,SetMemoryX(Dest,SetTo,0,CBit))
							table.insert(LShiftAct,SetMemoryX(Dest,Add,NBit,RBit))
							CBit = bit32.rshift(CBit,1)
							NBit = bit32.rshift(NBit,1)
							RBit = bit32.rshift(RBit,1)
						end
						table.insert(LShiftAct,SetMemoryX(Dest,SetTo,0,bit32.lshift(1,Operand)-1))
					elseif Dest == "Cp" then
						for i = 1, Repeat do
							table.insert(LShiftAct,SetDeathsX(CurrentPlayer,SetTo,0,0,CBit))
							table.insert(LShiftAct,SetDeathsX(CurrentPlayer,Add,NBit,0,RBit))
							CBit = bit32.rshift(CBit,1)
							NBit = bit32.rshift(NBit,1)
							RBit = bit32.rshift(RBit,1)
						end
						table.insert(LShiftAct,SetDeathsX(CurrentPlayer,SetTo,0,0,bit32.lshift(1,Operand)-1))
					elseif Dest[4] == "V" then
						for i = 1, Repeat do
							table.insert(LShiftAct,SetNVar(Dest,SetTo,0,CBit))
							table.insert(LShiftAct,SetNVar(Dest,Add,NBit,RBit))
							CBit = bit32.rshift(CBit,1)
							NBit = bit32.rshift(NBit,1)
							RBit = bit32.rshift(RBit,1)
						end
						table.insert(LShiftAct,SetNVar(Dest,SetTo,0,bit32.lshift(1,Operand)-1))
					else
						for i = 1, Repeat do
							table.insert(LShiftAct,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,0,CBit))
							table.insert(LShiftAct,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,NBit,RBit))
							CBit = bit32.rshift(CBit,1)
							NBit = bit32.rshift(NBit,1)
							RBit = bit32.rshift(RBit,1)
						end
						table.insert(LShiftAct,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,0,bit32.lshift(1,Operand)-1))
					end
						
					Trigger {
						players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								LShiftAct;
							},
							flag = {Preserved}
						}
				end
			elseif Operand[4] == "V" then -- And X, Y : X <<= Y
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX("X","X",0x4,5,SetTo,"X","X",0x0,0,6);
						},
						flag = {Preserved}
					}
				for i = 4, 0, -1 do
					local CBit = bit32.lshift(1,i)
					Trigger {
						players = {PlayerID},
							conditions = {
								Label(0);
								CtrigX(Operand[1],Operand[2],0x15C,Operand[3],Exactly,CBit,CBit);
							},
							actions = {
								SetCtrig1X("X","X",0x4,i,Add,0x970*CBit);
							},
							flag = {Preserved}
						}
				end
				for Operand = 0, 31 do
					if Operand == 0 then
						Trigger {
							players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,32);
								},
								flag = {Preserved}
							}
					else
						local CBit = bit32.lshift(bit32.lshift(1,Operand)-1,32-Operand)
						local NBit = bit32.rshift(CBit,1)
						local RBit = bit32.lshift(1,31-Operand)+CBit
						local LShiftAct = {}
						local Repeat = 32-Operand

						if type(Dest) == "number" then
							for i = 1, Repeat do
								table.insert(LShiftAct,SetMemoryX(Dest,SetTo,0,CBit))
								table.insert(LShiftAct,SetMemoryX(Dest,Add,NBit,RBit))
								CBit = bit32.rshift(CBit,1)
								NBit = bit32.rshift(NBit,1)
								RBit = bit32.rshift(RBit,1)
							end
							table.insert(LShiftAct,SetMemoryX(Dest,SetTo,0,bit32.lshift(1,Operand)-1))
						elseif Dest == "Cp" then
							for i = 1, Repeat do
								table.insert(LShiftAct,SetDeathsX(CurrentPlayer,SetTo,0,0,CBit))
								table.insert(LShiftAct,SetDeathsX(CurrentPlayer,Add,NBit,0,RBit))
								CBit = bit32.rshift(CBit,1)
								NBit = bit32.rshift(NBit,1)
								RBit = bit32.rshift(RBit,1)
							end
							table.insert(LShiftAct,SetDeathsX(CurrentPlayer,SetTo,0,0,bit32.lshift(1,Operand)-1))
						elseif Dest[4] == "V" then
							for i = 1, Repeat do
								table.insert(LShiftAct,SetNVar(Dest,SetTo,0,CBit))
								table.insert(LShiftAct,SetNVar(Dest,Add,NBit,RBit))
								CBit = bit32.rshift(CBit,1)
								NBit = bit32.rshift(NBit,1)
								RBit = bit32.rshift(RBit,1)
							end
							table.insert(LShiftAct,SetNVar(Dest,SetTo,0,bit32.lshift(1,Operand)-1))
						else
							for i = 1, Repeat do
								table.insert(LShiftAct,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,0,CBit))
								table.insert(LShiftAct,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,NBit,RBit))
								CBit = bit32.rshift(CBit,1)
								NBit = bit32.rshift(NBit,1)
								RBit = bit32.rshift(RBit,1)
							end
							table.insert(LShiftAct,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],SetTo,0,bit32.lshift(1,Operand)-1))
						end

						Trigger {
							players = {PlayerID},
								conditions = {
									Label(0);
								},
								actions = {
									LShiftAct;
									SetCtrigX("X","X",0x4,0,SetTo,"X","X",0x0,0,32-Operand);
								},
								flag = {Preserved}
							}
					end
				end
			else
				ClShift2_InputData_Error()
			end
		else 
			if type(Operand) == "number" then -- And V, Mem, 1 : V << Mem & 1 / Read필요
				ClShift2_InputData_Error()
			elseif Operand[4] == "V" then -- And V, Mem, X : V << Mem & X / Read필요
				ClShift2_InputData_Error()
			else
				ClShift2_InputData_Error()
			end
		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		ClShift2_InputData_Error()
	end
end

function CXor2(PlayerID,Dest,Source,Operand) -- >> (/2)
	STPopTrigArr(PlayerID)

	if Operand == nil then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CXor2_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end

		if type(Source) == "number" then
				local Xor2Act = {}
				if type(Dest) == "number" then
					table.insert(Xor2Act,SetMemoryX(Dest,Add,Source,0x55555555))
					table.insert(Xor2Act,SetMemoryX(Dest,Add,Source,0xAAAAAAAA))
				elseif Dest == "Cp" then
					table.insert(Xor2Act,SetDeathsX(CurrentPlayer,Add,Source,0,0x55555555))
					table.insert(Xor2Act,SetDeathsX(CurrentPlayer,Add,Source,0,0xAAAAAAAA))
				elseif Dest[4] == "V" then
					table.insert(Xor2Act,SetNVar(Dest,Add,Source,0x55555555))
					table.insert(Xor2Act,SetNVar(Dest,Add,Source,0xAAAAAAAA))
				else
					table.insert(Xor2Act,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,Source,0x55555555))
					table.insert(Xor2Act,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,Source,0xAAAAAAAA))
				end
					
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Xor2Act;
						},
						flag = {Preserved}
					}
		elseif Source[4] == "V" then
			local Xor2Act = {}
			if type(Dest) == "number" then
				table.insert(Xor2Act,SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,EPD(Dest)))
			elseif Dest == "Cp" then
				table.insert(Xor2Act,SetCtrig1X(Source[1],Source[2],0x158,Source[3],SetTo,13))
			elseif Dest[4] == "V" then
				table.insert(Xor2Act,SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]))
			else
				table.insert(Xor2Act,SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]))
			end

			Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Xor2Act;
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0x55555555);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,Add*16777216,0xFF000000);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
			Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xAAAAAAAA);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
		else
			CXor2_InputData_Error()
		end

		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Operand) == "table" and Operand[4] == "VA" then
			local TempRet = {"X",CRet[7],0,"V"}
			MovX(PlayerID,TempRet,Operand)
			Operand = TempRet
		end
		if type(Operand) == "table" and Operand[4] == "A" then
			CXor2_InputData_Error()
		end
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CXor2_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end

		if type(Source) == "number" then -- And V, 0x58A364, 1 : V << 0x58A364 & 1 / Read필요
			if type(Operand) == "number" then
				CXor2_InputData_Error()
			elseif Operand[4] == "V" then -- And V, 0x58A364, X : V << 0x58A364 & X / Read필요
				CXor2_InputData_Error()
			else
				CXor2_InputData_Error()
			end
		elseif Source == "Cp" then
			if type(Operand) == "number" then -- And V, Cp, 1 : V << Cp & 1 / Read필요 
				CXor2_InputData_Error()
			elseif Operand[4] == "V" then -- And V, Cp, X : V << Cp & X / Read필요 
				CXor2_InputData_Error()
			else
				CXor2_InputData_Error()
			end
		elseif Source[4] == "V" then
			if type(Operand) == "number" then -- And A, 1 : A >>= 1 (max 31)
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				local Xor2Act = {}
				if type(Dest) == "number" then
					table.insert(Xor2Act,SetMemoryX(Dest,Add,Operand,0x55555555))
					table.insert(Xor2Act,SetMemoryX(Dest,Add,Operand,0xAAAAAAAA))
				elseif Dest == "Cp" then
					table.insert(Xor2Act,SetDeathsX(CurrentPlayer,Add,Operand,0,0x55555555))
					table.insert(Xor2Act,SetDeathsX(CurrentPlayer,Add,Operand,0,0xAAAAAAAA))
				elseif Dest[4] == "V" then
					table.insert(Xor2Act,SetNVar(Dest,Add,Operand,0x55555555))
					table.insert(Xor2Act,SetNVar(Dest,Add,Operand,0xAAAAAAAA))
				else
					table.insert(Xor2Act,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,Operand,0x55555555))
					table.insert(Xor2Act,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,Operand,0xAAAAAAAA))
				end
					
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Xor2Act;
						},
						flag = {Preserved}
					}
			elseif Operand[4] == "V" then -- And X, Y : X <<= Y
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				local Xor2Act = {}
				if type(Dest) == "number" then
					table.insert(Xor2Act,SetCtrig1X(Operand[1],Operand[2],0x158,Operand[3],SetTo,EPD(Dest)))
				elseif Dest == "Cp" then
					table.insert(Xor2Act,SetCtrig1X(Operand[1],Operand[2],0x158,Operand[3],SetTo,13))
				elseif Dest[4] == "V" then
					table.insert(Xor2Act,SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]))
				else
					table.insert(Xor2Act,SetCtrigX(Operand[1],Operand[2],0x158,Operand[3],SetTo,Dest[1],Dest[2],Dest[3],1,Dest[4]))
				end

				Trigger {
						players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								Xor2Act;
								SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0x55555555);
								SetCtrig1X(Operand[1],Operand[2],0x160,Operand[3],SetTo,Add*16777216,0xFF000000);
								CallLabelAlways(Operand[1],Operand[2],Operand[3]);
							},
							flag = {Preserved}
						}
				Trigger {
						players = {PlayerID},
							conditions = {
								Label(0);
							},
							actions = {
								SetCtrig1X(Operand[1],Operand[2],0x148,Operand[3],SetTo,0xAAAAAAAA);
								CallLabelAlways(Operand[1],Operand[2],Operand[3]);
							},
							flag = {Preserved}
						}
			else
				CXor2_InputData_Error()
			end
		else 
			if type(Operand) == "number" then -- And V, Mem, 1 : V << Mem & 1 / Read필요
				CXor2_InputData_Error()
			elseif Operand[4] == "V" then -- And V, Mem, X : V << Mem & X / Read필요
				CXor2_InputData_Error()
			else
				CXor2_InputData_Error()
			end
		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CXor2_InputData_Error()
	end
end

function CNot2(PlayerID,Dest,Source) -- >> (/2)
	STPopTrigArr(PlayerID)

	if Source == nil then
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end

			local Not2Act = {}
			if type(Dest) == "number" then
				table.insert(Not2Act,SetMemoryX(Dest,Add,0xFFFFFFFF,0x55555555))
				table.insert(Not2Act,SetMemoryX(Dest,Add,0xFFFFFFFF,0xAAAAAAAA))
			elseif Dest == "Cp" then
				table.insert(Not2Act,SetDeathsX(CurrentPlayer,Add,0xFFFFFFFF,0,0x55555555))
				table.insert(Not2Act,SetDeathsX(CurrentPlayer,Add,0xFFFFFFFF,0,0xAAAAAAAA))
			elseif Dest[4] == "V" then
				table.insert(Not2Act,SetNVar(Dest,Add,0xFFFFFFFF,0x55555555))
				table.insert(Not2Act,SetNVar(Dest,Add,0xFFFFFFFF,0xAAAAAAAA))
			else
				table.insert(Not2Act,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,0xFFFFFFFF,0x55555555))
				table.insert(Not2Act,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,0xFFFFFFFF,0xAAAAAAAA))
			end
					
			Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Not2Act;
						},
						flag = {Preserved}
					}
		
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CNot2_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end

		if type(Source) == "number" then -- And V, 0x58A364, 1 : V << 0x58A364 & 1 / Read필요
			CNot2_InputData_Error()
		elseif Source == "Cp" then
			CNot2_InputData_Error()
		elseif Source[4] == "V" then
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				local Not2Act = {}
				if type(Dest) == "number" then
					table.insert(Not2Act,SetMemoryX(Dest,Add,0xFFFFFFFF,0x55555555))
					table.insert(Not2Act,SetMemoryX(Dest,Add,0xFFFFFFFF,0xAAAAAAAA))
				elseif Dest == "Cp" then
					table.insert(Not2Act,SetDeathsX(CurrentPlayer,Add,0xFFFFFFFF,0,0x55555555))
					table.insert(Not2Act,SetDeathsX(CurrentPlayer,Add,0xFFFFFFFF,0,0xAAAAAAAA))
				elseif Dest[4] == "V" then
					table.insert(Not2Act,SetNVar(Dest,Add,0xFFFFFFFF,0x55555555))
					table.insert(Not2Act,SetNVar(Dest,Add,0xFFFFFFFF,0xAAAAAAAA))
				else
					table.insert(Not2Act,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,0xFFFFFFFF,0x55555555))
					table.insert(Not2Act,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,0xFFFFFFFF,0xAAAAAAAA))
				end
					
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Not2Act;
						},
						flag = {Preserved}
					}
			
		else 
			CNot2_InputData_Error()
		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CNot2_InputData_Error()
	end
end

function CNeg2(PlayerID,Dest,Source) -- >> (/2)
	STPopTrigArr(PlayerID)

	if Source == nil then
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[8],0,"V"}
		end

			local Neg2Act = {}
			if type(Dest) == "number" then
				table.insert(Neg2Act,SetMemoryX(Dest,Add,0xFFFFFFFF,0x55555555))
				table.insert(Neg2Act,SetMemoryX(Dest,Add,0xFFFFFFFF,0xAAAAAAAA))
				table.insert(Neg2Act,SetMemory(Dest,Add,1))
			elseif Dest == "Cp" then
				table.insert(Neg2Act,SetDeathsX(CurrentPlayer,Add,0xFFFFFFFF,0,0x55555555))
				table.insert(Neg2Act,SetDeathsX(CurrentPlayer,Add,0xFFFFFFFF,0,0xAAAAAAAA))
				table.insert(Neg2Act,SetDeaths(CurrentPlayer,Add,1,0))
			elseif Dest[4] == "V" then
				table.insert(Neg2Act,SetNVar(Dest,Add,0xFFFFFFFF,0x55555555))
				table.insert(Neg2Act,SetNVar(Dest,Add,0xFFFFFFFF,0xAAAAAAAA))
				table.insert(Neg2Act,SetNVar(Dest,Add,1))
			else
				table.insert(Neg2Act,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,0xFFFFFFFF,0x55555555))
				table.insert(Neg2Act,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,0xFFFFFFFF,0xAAAAAAAA))
				table.insert(Neg2Act,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,1))
			end
					
			Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Neg2Act;
						},
						flag = {Preserved}
					}
		
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	elseif Dest[4] == "V" or Dest[4] == "VA" then
		if type(Source) == "table" and Source[4] == "VA" then
			local TempRet = {"X",CRet[8],0,"V"}
			MovX(PlayerID,TempRet,Source)
			Source = TempRet
		end
		if type(Source) == "table" and Source[4] == "A" then
			CNeg2_InputData_Error()
		end
		local PDest
		if type(Dest) == "table" and Dest[4] == "VA" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end
		if type(Dest) == "table" and Dest[4] == "A" then
			PDest = Dest
			Dest = {"X",CRet[9],0,"V"}
		end

		if type(Source) == "number" then -- And V, 0x58A364, 1 : V << 0x58A364 & 1 / Read필요
			CNeg2_InputData_Error()
		elseif Source == "Cp" then
			CNeg2_InputData_Error()
		elseif Source[4] == "V" then
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							SetCtrigX(Source[1],Source[2],0x158,Source[3],SetTo,Dest[1],Dest[2],0x15C,1,Dest[3]);
							SetCtrig1X(Source[1],Source[2],0x148,Source[3],SetTo,0xFFFFFFFF);
							SetCtrig1X(Source[1],Source[2],0x160,Source[3],SetTo,SetTo*16777216,0xFF000000);
							CallLabelAlways(Source[1],Source[2],Source[3]);
						},
						flag = {Preserved}
					}
				local Neg2Act = {}
				if type(Dest) == "number" then
					table.insert(Neg2Act,SetMemoryX(Dest,Add,0xFFFFFFFF,0x55555555))
					table.insert(Neg2Act,SetMemoryX(Dest,Add,0xFFFFFFFF,0xAAAAAAAA))
					table.insert(Neg2Act,SetMemory(Dest,Add,1))
				elseif Dest == "Cp" then
					table.insert(Neg2Act,SetDeathsX(CurrentPlayer,Add,0xFFFFFFFF,0,0x55555555))
					table.insert(Neg2Act,SetDeathsX(CurrentPlayer,Add,0xFFFFFFFF,0,0xAAAAAAAA))
					table.insert(Neg2Act,SetDeaths(CurrentPlayer,Add,1,0))
				elseif Dest[4] == "V" then
					table.insert(Neg2Act,SetNVar(Dest,Add,0xFFFFFFFF,0x55555555))
					table.insert(Neg2Act,SetNVar(Dest,Add,0xFFFFFFFF,0xAAAAAAAA))
					table.insert(Neg2Act,SetNVar(Dest,Add,1))
				else
					table.insert(Neg2Act,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,0xFFFFFFFF,0x55555555))
					table.insert(Neg2Act,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,0xFFFFFFFF,0xAAAAAAAA))
					table.insert(Neg2Act,SetCtrig1X(Dest[1],Dest[2],Dest[3],Dest[4],Add,1))
				end
					
				Trigger {
					players = {PlayerID},
						conditions = {
							Label(0);
						},
						actions = {
							Neg2Act;
						},
						flag = {Preserved}
					}
			
		else 
			CNeg2_InputData_Error()
		end
		if PDest ~= nil then
			MovX(PlayerID,PDest,Dest)
		end
	else
		CNeg2_InputData_Error()
	end
end


function _rShift(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		rShift_InputData_Error()
	elseif Source == "Cp" then
		rShift_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CrShift",TempData,Source,Operand}) -- A << X & 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CrShift",TempData,Source,Operand}) -- A << X & Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CrShift",TempData,Source,Operand}) -- A << X & VA
		elseif Operand[4] == "A" then
			rShift_InputData_Error()
		else
			rShift_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CrShift",TempData,Source,Operand}) -- A << VA & 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CrShift",TempData,Source,Operand}) -- A << VA & Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CrShift",TempData,Source,Operand}) -- A << VA & VA
		elseif Operand[4] == "A" then
			rShift_InputData_Error()
		else
			rShift_InputData_Error()
		end
	else
		rShift_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _lShift2(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		lShift2_InputData_Error()
	elseif Source == "Cp" then
		lShift2_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"ClShift2",TempData,Source,Operand}) -- A << X & 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"ClShift2",TempData,Source,Operand}) -- A << X & Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"ClShift2",TempData,Source,Operand}) -- A << X & VA
		elseif Operand[4] == "A" then
			lShift2_InputData_Error()
		else
			lShift2_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"ClShift2",TempData,Source,Operand}) -- A << VA & 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"ClShift2",TempData,Source,Operand}) -- A << VA & Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"ClShift2",TempData,Source,Operand}) -- A << VA & VA
		elseif Operand[4] == "A" then
			lShift2_InputData_Error()
		else
			lShift2_InputData_Error()
		end
	else
		lShift2_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Xor2(Source,Operand)
	if Source == nil then
		Source = "X"
	end
	if Operand == nil then
		Operand = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Xor2_InputData_Error()
	elseif Source == "Cp" then
		Xor2_InputData_Error()
	elseif Source[4] == "V" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CXor2",TempData,Source,Operand}) -- A << X ^ 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CXor2",TempData,Source,Operand}) -- A << X ^ Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CXor2",TempData,Source,Operand}) -- A << X ^ VA
		elseif Operand[4] == "A" then
			Xor2_InputData_Error()
		else
			Xor2_InputData_Error()
		end
	elseif Source[4] == "VA" then
		if type(Operand) == "number" then
			table.insert(STPushTrigArr,{"CXor2",TempData,Source,Operand}) -- A << VA ^ 1
		elseif Operand[4] == "V" then
			table.insert(STPushTrigArr,{"CXor2",TempData,Source,Operand}) -- A << VA ^ Y
		elseif Operand[4] == "VA" then
			table.insert(STPushTrigArr,{"CXor2",TempData,Source,Operand}) -- A << VA ^ VA
		elseif Operand[4] == "A" then
			Xor2_InputData_Error()
		else
			Xor2_InputData_Error()
		end
	else
		Xor2_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Not2(Source)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Not2_InputData_Error()
	elseif Source == "Cp" then
		Not2_InputData_Error()
	elseif Source[4] == "V" then
		table.insert(STPushTrigArr,{"CNot2",TempData,Source}) -- A << ~X 
	elseif Source[4] == "VA" then
		table.insert(STPushTrigArr,{"CNot2",TempData,Source}) -- A << ~VA
	elseif Source[4] == "A" then
		Not2_InputData_Error()
	else
		Not2_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function _Neg2(Source)
	if Source == nil then
		Source = "X"
	end
	local Temp = VarXAlloc
	local TempData = {"X",Temp,0,"V"}

	if type(Source) == "number" then
		Neg2_InputData_Error()
	elseif Source == "Cp" then
		Neg2_InputData_Error()
	elseif Source[4] == "V" then
		table.insert(STPushTrigArr,{"CNeg2",TempData,Source}) -- A << ~X 
	elseif Source[4] == "VA" then
		table.insert(STPushTrigArr,{"CNeg2",TempData,Source}) -- A << ~VA
	elseif Source[4] == "A" then
		Neg2_InputData_Error()
	else
		Neg2_InputData_Error()
	end
	VarXAlloc = VarXAlloc + 1
	if VarXAlloc > MAXVAlloc then
		MAXVAlloc = VarXAlloc
	end
	return TempData
end

function CreateFArr(Size,PlayerID)
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	if Size < 1 then CreateFArr_InputData_Error() end

	CreateVarXAlloc = CreateVarXAlloc + 1
	if CreateVarXAlloc > CreateMaxVAlloc then
		CreateVariable_IndexAllocation_Overflow()
	end
	if PlayerID == nil then
		PlayerID = AllPlayers
	end
	table.insert(CreateVarPArr,{"FA",PlayerID,Size})
	local Ret = {"X",CreateVarXAlloc,0x970,0}
	if type(PlayerID) == "number" then
		Ret[1] = PlayerID
	end
	return Ret
end

function FastDrop(PlayerID,DropPlayer)
	Trigger {
		players = {PlayerID},
		conditions = {
			LocalPlayerID(DropPlayer);
		},
		actions = {
			SetMemory(0x6509B0,SetTo,8);
			RunAIScript("Turn ON Shared Vision for Player 1");
			RunAIScript("Turn ON Shared Vision for Player 2");
			RunAIScript("Turn ON Shared Vision for Player 3");
			RunAIScript("Turn ON Shared Vision for Player 4");
			RunAIScript("Turn ON Shared Vision for Player 5");
			RunAIScript("Turn ON Shared Vision for Player 6");
			RunAIScript("Turn ON Shared Vision for Player 7");
			RunAIScript("Turn ON Shared Vision for Player 8");
		},
		flag = {Preserved}
	}
end

function PlayerDrop(PlayerID,DropPlayer)
	Trigger {
		players = {PlayerID},
		conditions = {
			LocalPlayerID(DropPlayer);
		},
		actions = {
			SetMemory(0x57F0F0+0x4*0,Add,1);SetMemory(0x57F120+0x4*0,Add,1);
			SetMemory(0x57F0F0+0x4*1,Add,1);SetMemory(0x57F120+0x4*1,Add,1);
			SetMemory(0x57F0F0+0x4*2,Add,1);SetMemory(0x57F120+0x4*2,Add,1);
			SetMemory(0x57F0F0+0x4*3,Add,1);SetMemory(0x57F120+0x4*3,Add,1);
			SetMemory(0x57F0F0+0x4*4,Add,1);SetMemory(0x57F120+0x4*4,Add,1);
			SetMemory(0x57F0F0+0x4*5,Add,1);SetMemory(0x57F120+0x4*5,Add,1);
			SetMemory(0x57F0F0+0x4*6,Add,1);SetMemory(0x57F120+0x4*6,Add,1);
			SetMemory(0x57F0F0+0x4*7,Add,1);SetMemory(0x57F120+0x4*7,Add,1);
		},
		flag = {Preserved}
	}
end

function TogglePlayerModerate(PlayerID,State,Timer,TargetPlayer,Condition,Action)
	if State == "Off" then
		Trigger { 
			players = {PlayerID},
			conditions = {
				Memory(0x57EEE4+0x24*TargetPlayer,AtMost,0x0F);
				Condition;
			},
			actions = {
				SetMemoryX(Timer,SetTo,0x80000000,0x80000000);
				Action;
				PreserveTrigger();
			},
		}
		for i = 0, 15 do
			Trigger { 
				players = {PlayerID},
				conditions = {
					MemoryX(Timer,Exactly,0x80000000,0x80000000);
					Memory(0x57EEE4+0x24*TargetPlayer,Exactly,i);
				},
				actions = {
					SetMemoryX(Timer,SetTo,0,0x80000000);
					SetMemoryX(0x57F1D8,SetTo,2^i,2^i);
					PreserveTrigger();
				},
			}
		end
	elseif State == "On" then
		Trigger { 
			players = {PlayerID},
			conditions = {
				Memory(0x57EEE4+0x24*TargetPlayer,AtMost,0x0F);
				Condition;
			},
			actions = {
				SetMemoryX(Timer,SetTo,0x80000000,0x80000000);
				Action;
				PreserveTrigger();
			},
		}
		for i = 0, 15 do
			Trigger { 
				players = {PlayerID},
				conditions = {
					MemoryX(Timer,Exactly,0x80000000,0x80000000);
					Memory(0x57EEE4+0x24*TargetPlayer,Exactly,i);
				},
				actions = {
					SetMemoryX(Timer,SetTo,0,0x80000000);
					SetMemoryX(0x57F1D8,SetTo,0,2^i);
					PreserveTrigger();
				},
			}
		end
	end
end

function TogglePlayerChat(PlayerID,Timer,TargetPlayer,KeyName,Delay,Condition,ActionOn,ActionOff) -- Player→Ob
	local KeyCond = {}
	if KeyName ~= nil then
		KeyCond = {KeyPress(KeyName,"Down");Memory(0x68C144,Exactly,0)}
	end
	local DelayCond = {MemoryX(Timer,Exactly,0,0x80),MemoryX(Timer,Exactly,0x80,0x80)}
	local DelayAct = {SetMemoryX(Timer,SetTo,0x80,0x80),SetMemoryX(Timer,SetTo,0,0x80)}
	if Delay ~= nil then
		DelayCond = {MemoryX(Timer,Exactly,0,0xFF),MemoryX(Timer,Exactly,0x80,0xFF)}
		DelayAct = {SetMemoryX(Timer,SetTo,0x80+Delay,0xFF),SetMemoryX(Timer,SetTo,Delay,0xFF)}
	end

	Trigger { 
		players = {PlayerID},
		conditions = {
			LocalPlayerID(TargetPlayer);
			KeyCond;
			DelayCond[1];
			Condition;
		},
		actions = {
			DelayAct[1];
			ActionOn;
			PreserveTrigger();
		},
	}

	Trigger { 
		players = {PlayerID},
		conditions = {
			LocalPlayerID(TargetPlayer);
			KeyCond;
			DelayCond[2];
			Condition;
		},
		actions = {
			DelayAct[2];
			ActionOff;
			PreserveTrigger();
		},
	}

	Trigger { 
		players = {PlayerID},
		conditions = {
			LocalPlayerID(TargetPlayer);
			MemoryX(Timer,Exactly,0x80,0x80);
			Memory(0x68C144,AtLeast,1);
		},
		actions = {
			SetMemory(0x68C144,SetTo,5);
			PreserveTrigger();
		},
	}

	Trigger { 
		players = {PlayerID},
		conditions = {
			LocalPlayerID(TargetPlayer);
			MemoryX(Timer,AtLeast,1,0x7F);
		},
		actions = {
			SetMemoryX(Timer,Subtract,1,0x7F);
			PreserveTrigger();
		},
	}
end

function ObserverDrop(PlayerID,Timer,TargetPlayer,Delay,Condition,Action) -- "Ob1"~"Ob4"
	Trigger { 
		players = {PlayerID},
		conditions = {
			LocalPlayerID(TargetPlayer);
			MemoryX(Timer,Exactly,0,0xFFF0);
			Condition;
		},
		actions = {
			SetMemoryX(Timer,SetTo,1*16,0xFFF0);
			Action;
		},
	}

	Trigger { 
		players = {PlayerID},
		conditions = {
			LocalPlayerID(TargetPlayer);
			MemoryX(Timer,AtLeast,1*16,0xFFF0);
			MemoryX(Timer,AtMost,0xFFE0,0xFFF0);
		},
		actions = {
			SetMemory(0x657A9C,SetTo,0); -- 화면 암전
			SetMemoryX(Timer,Add,1*16,0xFFF0);
			PreserveTrigger();
		},
	}

	Trigger { 
		players = {PlayerID},
		conditions = {
			LocalPlayerID(TargetPlayer);
			MemoryX(Timer,AtLeast,Delay*16,0xFFF0);
		},
		actions = {
			SetMemory(0x6509B0,SetTo,8);
			RunAIScript("Turn ON Shared Vision for Player 1");
			RunAIScript("Turn ON Shared Vision for Player 2");
			RunAIScript("Turn ON Shared Vision for Player 3");
			RunAIScript("Turn ON Shared Vision for Player 4");
			RunAIScript("Turn ON Shared Vision for Player 5");
			RunAIScript("Turn ON Shared Vision for Player 6");
			RunAIScript("Turn ON Shared Vision for Player 7");
			RunAIScript("Turn ON Shared Vision for Player 8");
			PreserveTrigger();
		},
	}
end

ObserverChatCheck = 0

function ObserverChatToAll(PlayerID,Timer,TargetPlayer,KeyName,Delay,Condition,Action)
	local KeyCond = {}
	if KeyName ~= nil then
		KeyCond = {KeyPress(KeyName,"Down");Memory(0x68C144,Exactly,0)}
	end
	local DelayCond = {}
	local DelayAct = {SetMemoryX(Timer,SetTo,0x20000000,0x70000000)}
	if Delay ~= nil then
		DelayCond = {MemoryX(Timer,Exactly,0,0xFF0000)}
		DelayAct = {SetMemoryX(Timer,SetTo,0x20000000+Delay*65536,0x70FF0000)}
	end
	Trigger { 
		players = {PlayerID},
		conditions = {
			LocalPlayerID(TargetPlayer);
			KeyCond;
			DelayCond;
			Condition;
		},
		actions = {
			DelayAct;
			Action;
			PreserveTrigger();
		},
	}

	Trigger { 
		players = {PlayerID},
		conditions = {
			LocalPlayerID(TargetPlayer);
			MemoryX(Timer,Exactly,0x20000000,0x70000000);
			Memory(0x68C144,AtLeast,1);
		},
		actions = {
			SetMemory(0x68C144,SetTo,2);
			PreserveTrigger();
		},
	}

	if ObserverChatCheck == 0  then
		Trigger { 
			players = {PlayerID},
			conditions = {
				LocalPlayerID(TargetPlayer);
				MemoryX(Timer,AtLeast,1*65536,0xFF0000);
			},
			actions = {
				SetMemoryX(Timer,Subtract,1*65536,0xFF0000);
				PreserveTrigger();
			},
		}
	end
	ObserverChatCheck = 1
end

function ObserverChatToNone(PlayerID,Timer,TargetPlayer,KeyName,Delay,Condition,Action)
	local KeyCond = {}
	if KeyName ~= nil then
		KeyCond = {KeyPress(KeyName,"Down");Memory(0x68C144,Exactly,0)}
	end
	local DelayCond = {}
	local DelayAct = {SetMemoryX(Timer,SetTo,0x30000000,0x70000000)}
	if Delay ~= nil then
		DelayCond = {MemoryX(Timer,Exactly,0,0xFF0000)}
		DelayAct = {SetMemoryX(Timer,SetTo,0x30000000+Delay*65536,0x70FF0000)}
	end
	Trigger { 
		players = {PlayerID},
		conditions = {
			LocalPlayerID(TargetPlayer);
			KeyCond;
			DelayCond;
			Condition;
		},
		actions = {
			DelayAct;
			Action;
			PreserveTrigger();
		},
	}

	Trigger { 
		players = {PlayerID},
		conditions = {
			LocalPlayerID(TargetPlayer);
			MemoryX(Timer,Exactly,0x30000000,0x70000000);
			Memory(0x68C144,AtLeast,1);
		},
		actions = {
			SetMemory(0x68C144,SetTo,3);
			PreserveTrigger();
		},
	}

	if ObserverChatCheck == 0  then
		Trigger { 
			players = {PlayerID},
			conditions = {
				LocalPlayerID(TargetPlayer);
				MemoryX(Timer,AtLeast,1*65536,0xFF0000);
			},
			actions = {
				SetMemoryX(Timer,Subtract,1*65536,0xFF0000);
				PreserveTrigger();
			},
		}
	end
	ObserverChatCheck = 1
end

function ObserverChatToPlayer(PlayerID,Timer,TargetPlayer,KeyName,Delay,Condition,ActionArray)
	local KeyCond = {}
	if KeyName ~= nil then
		KeyCond = {KeyPress(KeyName,"Down");Memory(0x68C144,Exactly,0)}
	end
	
	if ActionArray == nil then ActionArray = {} end

	for i = 0, 7 do
		if ActionArray[i+1] == nil then ActionArray[i+1] = {} end
		local j = (i+7)%8

		local DelayCond = {MemoryX(Timer,Exactly,j*0x01000000,0x0F00000F)}
		local DelayAct = {SetMemoryX(Timer,SetTo,0xC0000000,0xF0000000)}
		if Delay ~= nil then
			DelayCond = {MemoryX(Timer,Exactly,j*0x01000000,0x0FFF000F)}
			DelayAct = {SetMemoryX(Timer,SetTo,0xC0000000+Delay*65536,0xF0FF0000)}
		end
		
		Trigger { 
			players = {PlayerID},
			conditions = {
				LocalPlayerID(TargetPlayer);
				KeyCond;
				DelayCond;
				Condition;
			},
			actions = {
				DelayAct;
				PreserveTrigger();
			},
		}

		for k = 0, 7 do
			local l = (k+i)%8
			Trigger { 
				players = {PlayerID},
				conditions = {
					LocalPlayerID(TargetPlayer);
					MemoryX(Timer,Exactly,0x80000000,0x80000000);
					Memory(0x57EEE4+0x24*l,AtMost,0x0F);
				},
				actions = {
					SetMemoryX(Timer,SetTo,l*0x01000000+(l+1),0x8F00000F);
					PreserveTrigger();
				},
			}
		end
	end

	for i = 0, 7 do
		Trigger { 
			players = {PlayerID},
			conditions = {
				LocalPlayerID(TargetPlayer);
				MemoryX(Timer,Exactly,i+1+0x40000000,0x4000000F);
			},
			actions = {
				ActionArray[i+1];
				SetMemoryX(Timer,SetTo,0,0xF);
				PreserveTrigger();
			},
		}
	end

	for i = 0, 7 do
		for j = 3, 0, -1 do
			Trigger { 
				players = {PlayerID},
				conditions = {
					LocalPlayerID(TargetPlayer);
					MemoryX(Timer,Exactly,0x40000000+i*0x01000000,0x7F000000);
					MemoryX(0x57EEE4+0x24*i,Exactly,2^j,2^j);
				},
				actions = {
					SetMemoryX(Timer,SetTo,2^j,2^j);
					PreserveTrigger();
				},
			}
		end
	end

	for i = 0, 15 do
		Trigger { 
			players = {PlayerID},
			conditions = {
				LocalPlayerID(TargetPlayer);
				MemoryX(Timer,Exactly,0x40000000+i,0x7000000F);
			},
			actions = {
				SetMemoryX(0x57F1D8,SetTo,2^(i+16),0xFFFF0000);
				SetMemoryX(Timer,SetTo,0,0xF);
				PreserveTrigger();
			},
		}
	end

	Trigger { 
		players = {PlayerID},
		conditions = {
			LocalPlayerID(TargetPlayer);
			MemoryX(Timer,Exactly,0x40000000,0x70000000);
			Memory(0x68C144,AtLeast,1);
		},
		actions = {
			SetMemory(0x68C144,SetTo,4);
			PreserveTrigger();
		},
	}

	if ObserverChatCheck == 0  then
		Trigger { 
			players = {PlayerID},
			conditions = {
				LocalPlayerID(TargetPlayer);
				MemoryX(Timer,AtLeast,1*65536,0xFF0000);
			},
			actions = {
				SetMemoryX(Timer,Subtract,1*65536,0xFF0000);
				PreserveTrigger();
			},
		}
	end
	ObserverChatCheck = 1
end

function ObserverChatToOb(PlayerID,Timer,TargetPlayer,KeyName,Delay,Condition,Action)
	local KeyCond = {}
	if KeyName ~= nil then
		KeyCond = {KeyPress(KeyName,"Down");Memory(0x68C144,Exactly,0)}
	end
	local DelayCond = {}
	local DelayAct = {SetMemoryX(Timer,SetTo,0x50000000,0x70000000)}
	if Delay ~= nil then
		DelayCond = {MemoryX(Timer,Exactly,0,0xFF0000)}
		DelayAct = {SetMemoryX(Timer,SetTo,0x50000000+Delay*65536,0x70FF0000)}
	end
	Trigger { 
		players = {PlayerID},
		conditions = {
			LocalPlayerID(TargetPlayer);
			KeyCond;
			DelayCond;
			Condition;
		},
		actions = {
			DelayAct;
			Action;
			PreserveTrigger();
		},
	}

	Trigger { 
		players = {PlayerID},
		conditions = {
			LocalPlayerID(TargetPlayer);
			MemoryX(Timer,Exactly,0x50000000,0x70000000);
			Memory(0x68C144,AtLeast,1);
		},
		actions = {
			SetMemory(0x68C144,SetTo,5);
			PreserveTrigger();
		},
	}

	if ObserverChatCheck == 0  then
		Trigger { 
			players = {PlayerID},
			conditions = {
				LocalPlayerID(TargetPlayer);
				MemoryX(Timer,AtLeast,1*65536,0xFF0000);
			},
			actions = {
				SetMemoryX(Timer,Subtract,1*65536,0xFF0000);
				PreserveTrigger();
			},
		}
	end
	ObserverChatCheck = 1
end

function SelectionColor(Player,Type,Value)
	if Value == "Green" then
		Value = 0
	elseif Value == "Yellow" then
		Value = 1
	elseif Value == "Red" then
		Value = 2
	end

	if Player >= 0 and Player <= 11 then
		return MemoryB(0x581D6A+Player,Type,Value)
	else
		SelectionColor_InputData_Error()
	end
end

function SetSelectionColor(Player,Type,Value)
	if Value == "Green" then
		Value = 0
	elseif Value == "Yellow" then
		Value = 1
	elseif Value == "Red" then
		Value = 2
	end
	
	if Player >= 0 and Player <= 11 then
		return SetMemoryB(0x581D6A+Player,Type,Value)
	else
		SetSelectionColor_InputData_Error()
	end
end

function SharedVision(SharePlayer,Player,Value)
	if Value == "On" then
		Value = 1
	elseif Value == "Off" then
		Value = 0
	end
	if Value ~= 0 and Value ~= 1 then
		SharedVision_InputData_Error()
	end
	return MemoryX(0x57F1EC+0x4*SharePlayer,Exactly,bit32.lshift(Value, Player),bit32.lshift(1, Player))
end

function SetSharedVision(SharePlayer,Player,Value)
	if Value == "On" then
		Value = 1
	elseif Value == "Off" then
		Value = 0
	end
	if Value ~= 0 and Value ~= 1 then
		SharedVision_InputData_Error()
	end
	return SetMemoryX(0x57F1EC+0x4*SharePlayer,SetTo,bit32.lshift(Value, Player),bit32.lshift(1, Player))
end

function PlayerAlliance(Player,TargetPlayer,Value)
	if Value == "Enemy" then
		Value = 0
	elseif Value == "Ally" then
		Value = 1
	end
	if Value ~= 0 and Value ~= 1 then
		Value = 2
	end
	return MemoryB(0x58D634+0xC*Player+TargetPlayer,Exactly,Value)
end

function SetPlayerAlliance(Player,TargetPlayer,Value)
	if Value == "Enemy" then
		Value = 0
	elseif Value == "Ally" then
		Value = 1
	end
	if Value ~= 0 and Value ~= 1 then
		Value = 2
	end
	return SetMemoryB(0x58D634+0xC*Player+TargetPlayer,SetTo,Value)
end

function LeaderBoardOff()
	return SetMemoryX(0x58D70C,SetTo,0xFF,0xFF)
end

function ZergSupplyAvailable(Player,Type,Value)
	return Memory(0x582144+0x4*Player,Type,Value)
end
function ZergSupplyUsed(Player,Type,Value)
	return Memory(0x582174+0x4*Player,Type,Value)
end
function ZergSupplyMax(Player,Type,Value)
	return Memory(0x5821A4+0x4*Player,Type,Value)
end
function TerranSupplyAvailable(Player,Type,Value)
	return Memory(0x5821D4+0x4*Player,Type,Value)
end
function TerranSupplyUsed(Player,Type,Value)
	return Memory(0x582204+0x4*Player,Type,Value)
end
function TerranSupplyMax(Player,Type,Value)
	return Memory(0x582234+0x4*Player,Type,Value)
end
function ProtossSupplyAvailable(Player,Type,Value)
	return Memory(0x582264+0x4*Player,Type,Value)
end
function ProtossSupplyUsed(Player,Type,Value)
	return Memory(0x582294+0x4*Player,Type,Value)
end
function ProtossSupplyMax(Player,Type,Value)
	return Memory(0x5822C4+0x4*Player,Type,Value)
end

function SetZergSupplyAvailable(Player,Type,Value)
	return SetMemory(0x582144+0x4*Player,Type,Value)
end
function SetZergSupplyUsed(Player,Type,Value)
	return SetMemory(0x582174+0x4*Player,Type,Value)
end
function SetZergSupplyMax(Player,Type,Value)
	return SetMemory(0x5821A4+0x4*Player,Type,Value)
end
function SetTerranSupplyAvailable(Player,Type,Value)
	return SetMemory(0x5821D4+0x4*Player,Type,Value)
end
function SetTerranSupplyUsed(Player,Type,Value)
	return SetMemory(0x582204+0x4*Player,Type,Value)
end
function SetTerranSupplyMax(Player,Type,Value)
	return SetMemory(0x582234+0x4*Player,Type,Value)
end
function SetProtossSupplyAvailable(Player,Type,Value)
	return SetMemory(0x582264+0x4*Player,Type,Value)
end
function SetProtossSupplyUsed(Player,Type,Value)
	return SetMemory(0x582294+0x4*Player,Type,Value)
end
function SetProtossSupplyMax(Player,Type,Value)
	return SetMemory(0x5822C4+0x4*Player,Type,Value)
end

function UnitAvailable(Player,UnitId,Value)
	if Value >= 1 then
		Value = 1
	end
	return MemoryB(0x57F27C + 228*Player+ParseUnit(UnitId),Exactly,Value)
end

function SetUnitAvailable(Player,UnitId,Value)
	if Value >= 1 then
		Value = 1
	end
	return SetMemoryB(0x57F27C + 228*Player+ParseUnit(UnitId),SetTo,Value)
end

function DamageMultiplier(DamageType,UnitSize,Type,Value)
	return Memory(0x515B88+0x14*DamageType+0x4*UnitSize,Type,Value)
end

function SetDamageMultiplier(DamageType,UnitSize,Type,Value)
	return SetMemory(0x515B88+0x14*DamageType+0x4*UnitSize,Type,Value)
end

function InverseSystemTime(Type,Value)
	return Memory(0x51CE8C,Type,Value)
end

function TtoA(String)
	OffsetKeyArr = {
		['InverseSystemTime'] = 0x51CE8C,
		['VisionTurbo'] = 0x51CE98,
		['EUDTurbo'] = 0x6509A0,
		['PlayerColor'] = 0x581D76,
		['MinimapColor'] = 0x581DD6,
		['Speed'] = 0x5124F0,
		['LocalPlayerID'] = 0x512684,
		['UnixTime'] = 0x6D0F38,
		['MapSize'] = 0x57F1D4,
		['PlayerState'] = 0x57EEE8,
		['PauseCount'] = 0x58D718,
		['DropTimer'] = 0x59CC80,
		['DropWindow'] = 0x59CC78,
		['UnitName'] = 0x660260,
		['SelectionColor'] = 0x581D6A,
		['SharedVision'] = 0x57F1EC,
		['PlayerAlliance'] = 0x58D634,
		['LeaderBoardType'] = 0x58D70C,
		['ZergSupplyAvailable'] = 0x582144,
		['ZergSupplyUsed'] = 0x582174,
		['ZergSupplyMax'] = 0x5821A4,
		['TerranSupplyAvailable'] = 0x5821D4,
		['TerranSupplyUsed'] = 0x582204,
		['TerranSupplyMax'] = 0x582234,
		['ProtossSupplyAvailable'] = 0x582264,
		['ProtossSupplyUsed'] = 0x582294,
		['ProtossSupplyMax'] = 0x5822C4,
		['UnitAvailable'] = 0x57F27C,
		["DamageMultiplier"] = 0x515B88, 
		['ImageColor'] = 0x669E28,
		['ImageScript'] = 0x66EC48,
		['ImageAllScript'] = 0x66D4D8,
		['RecallImage'] = 0x666456,
		['ScanImage'] = 0x666458,
		['SpriteImage'] = 0x666160,
		['BulletDamage'] = 0x656EB0,
		['BulletDamageUp'] = 0x657678,
		['BulletNumber'] = 0x6564E0,
		['BulletUpgrade'] = 0x6571D0,
		['BulletDamageType'] = 0x657258,
		['BulletDamageSpecial'] = 0x6566F8,
		['BulletSpin'] = 0x657888,
		['BulletSplash100'] = 0x656888,
		['BulletSplash50'] = 0x6570C8,
		['BulletSplash25'] = 0x657780,
		['Dimension'] = 0x662860,
		['BulletCooldown'] = 0x656FB8,
	}

	local Ret = OffsetKeyArr[String]
	if Ret == nil then
		PushErrorMsg(String.." Doesn't Exist.")
	end
	return Ret
end

function PatchCRGB(P1Color,P2Color,P3Color,P4Color,P5Color,P6Color,P7Color,P8Color) -- Type or Color (0xBBGGRR)
	-- Type = 03 (Unused) / 02 (Custom RGB) / 01 (Select) / 00 (Random)  
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	local Type = {}
	local RGB = {}

	if P1Color == nil or P1Color == "Unused" then
		Type[1] = 3
		RGB[1] = 0
	elseif type(P1Color) == "number" then
		Type[1] = 2
		RGB[1] = P1Color
	elseif P1Color == "Select" then
		Type[1] = 1
		RGB[1] = 0
	elseif P1Color == "Random" then
		Type[1] = 0
		RGB[1] = 0
	elseif type(P1Color) == "table" or type(P1Color) == "string" then
		Type[1] = 3
		RGB[1] = P1Color
	end

	if P2Color == nil or P2Color == "Unused" then
		Type[2] = 3
		RGB[2] = 0
	elseif type(P2Color) == "number" then
		Type[2] = 2
		RGB[2] = P2Color
	elseif P2Color == "Select" then
		Type[2] = 1
		RGB[2] = 0
	elseif P2Color == "Random" then
		Type[2] = 0
		RGB[2] = 0
	elseif type(P2Color) == "table" or type(P2Color) == "string" then
		Type[2] = 3
		RGB[2] = P2Color
	end

	if P3Color == nil or P3Color == "Unused" then
		Type[3] = 3
		RGB[3] = 0
	elseif type(P3Color) == "number" then
		Type[3] = 2
		RGB[3] = P3Color
	elseif P3Color == "Select" then
		Type[3] = 1
		RGB[3] = 0
	elseif P3Color == "Random" then
		Type[3] = 0
		RGB[3] = 0
	elseif type(P3Color) == "table" or type(P3Color) == "string" then
		Type[3] = 3
		RGB[3] = P3Color
	end

	if P4Color == nil or P4Color == "Unused" then
		Type[4] = 3
		RGB[4] = 0
	elseif type(P4Color) == "number" then
		Type[4] = 2
		RGB[4] = P4Color
	elseif P4Color == "Select" then
		Type[4] = 1
		RGB[4] = 0
	elseif P4Color == "Random" then
		Type[4] = 0
		RGB[4] = 0
	elseif type(P4Color) == "table" or type(P4Color) == "string" then
		Type[4] = 3
		RGB[4] = P4Color
	end

	if P5Color == nil or P5Color == "Unused" then
		Type[5] = 3
		RGB[5] = 0
	elseif type(P5Color) == "number" then
		Type[5] = 2
		RGB[5] = P5Color
	elseif P5Color == "Select" then
		Type[5] = 1
		RGB[5] = 0
	elseif P5Color == "Random" then
		Type[5] = 0
		RGB[5] = 0
	elseif type(P5Color) == "table" or type(P5Color) == "string" then
		Type[5] = 3
		RGB[5] = P5Color
	end

	if P6Color == nil or P6Color == "Unused" then
		Type[6] = 3
		RGB[6] = 0
	elseif type(P6Color) == "number" then
		Type[6] = 2
		RGB[6] = P6Color
	elseif P6Color == "Select" then
		Type[6] = 1
		RGB[6] = 0
	elseif P6Color == "Random" then
		Type[6] = 0
		RGB[6] = 0
	elseif type(P6Color) == "table" or type(P6Color) == "string" then
		Type[6] = 3
		RGB[6] = P6Color
	end

	if P7Color == nil or P7Color == "Unused" then
		Type[7] = 3
		RGB[7] = 0
	elseif type(P7Color) == "number" then
		Type[7] = 2
		RGB[7] = P7Color
	elseif P7Color == "Select" then
		Type[7] = 1
		RGB[7] = 0
	elseif P7Color == "Random" then
		Type[7] = 0
		RGB[7] = 0
	elseif type(P7Color) == "table" or type(P7Color) == "string" then
		Type[7] = 3
		RGB[7] = P7Color
	end

	if P8Color == nil or P8Color == "Unused" then
		Type[8] = 3
		RGB[8] = 0
	elseif type(P8Color) == "number" then
		Type[8] = 2
		RGB[8] = P8Color
	elseif P8Color == "Select" then
		Type[8] = 1
		RGB[8] = 0
	elseif P8Color == "Random" then
		Type[8] = 0
		RGB[8] = 0
	elseif type(P8Color) == "table" or type(P8Color) == "string" then
		Type[8] = 3
		RGB[8] = P8Color
	end

	CRGBColorKeyArr = {
		['Red'] = 0*65536,
		['Blue'] = 1*65536,
		['Teal'] = 2*65536,
		['Purple'] = 3*65536,
		['Orange'] = 4*65536,
		['Brown'] = 5*65536,
		['White'] = 6*65536,
		['Yellow'] = 7*65536,
		['Green'] = 8*65536,
		['Pale Yellow'] = 9*65536,
		['Tan'] = 10*65536,
		['Dark Aqua'] = 11*65536,
		['Pale Green'] = 12*65536,
		['Blueish Grey'] = 13*65536,
		['Cyan'] = 14*65536,
		['Pink'] = 15*65536,
		['Olive'] = 16*65536,
		['Lime'] = 17*65536,
		['Navy'] = 18*65536,
		['Magenta'] = 19*65536,
		['Grey'] = 20*65536,
		['Black'] = 21*65536,
	}

	Box = {}
	for i = 1, 8 do
		if type(RGB[i]) == "string" then
			RGB[i] = CRGBColorKeyArr[RGB[i]]
		elseif type(RGB[i]) == "table" then
			RGB[i] = RGB[i][1]*65536
		end
		table.insert(Box,SetDeaths(0,SetTo,bit32.lshift(Type[i],24)+RGB[i],0))
	end
	Trigger {
		players = {FixPlayer,12},
		conditions = {
			Label();
			Never();
		},
		actions = {
			Box;
		},
	}
end

ExtTextArr = {}
ExtTextFile = {}
ExtTextIndex = 1
function DisplayExtText(Text,AlwaysDisplay) -- EndCtrig에서 ExtText 파일 생성함
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	if ExtTextArr[Text] == nil then
		ExtTextArr[Text] = ExtTextIndex
		ExtTextFile[ExtTextIndex] = Text
		ExtTextIndex = ExtTextIndex + 1
	end
	if AlwaysDisplay == nil then
		AlwaysDisplay = 4
	end
	return Action(0, ExtTextArr[Text], 0, 0, 0, 0, 0, 6, 0, AlwaysDisplay)
end

function f_PatchSTRxArr(PlayerID)
	if STRCTRIGASM == 0 then
		Need_STRCTRIGASM()
	end
	local Ret
	local FileName = "SCTRIGASMFILE"
	local HEX = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'}
	if FileNameIndex < 0x10 then
		FileName = FileName.."000"..HEX[FileNameIndex+1]
	elseif FileNameIndex < 0x100 then
		FileName = FileName.."00"..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF0),4)+1]..HEX[bit32.band(FileNameIndex, 0xF)+1]
	elseif FileNameIndex < 0x1000 then
		FileName = FileName.."0"..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF00),8)+1]..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF0),4)+1]..HEX[bit32.band(FileNameIndex, 0xF)+1]
	elseif FileNameIndex < 0x10000 then
		FileName = FileName..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF000),12)+1]..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF00),8)+1]..HEX[bit32.rshift(bit32.band(FileNameIndex, 0xF0),4)+1]..HEX[bit32.band(FileNameIndex, 0xF)+1]
	else
		FILEIndex_Overflow()
	end
	FileNameIndex = FileNameIndex + 1

	local FilePath = FileDirectory..FileName
	local Fileptr = io.open(FilePath, "wb")
	if Fileptr == nil then
		PushErrorMsg(FilePath.."\nCan't be Open!")
	end

	local stroff = 0
	for k, v in pairs(ExtTextFile) do -- header
		Fileptr:write(string.char(bit32.band(stroff, 0xFF),bit32.rshift(bit32.band(stroff, 0xFF00),8),bit32.rshift(bit32.band(stroff, 0xFF0000),16),bit32.rshift(bit32.band(stroff, 0xFF000000),24)))
		stroff = stroff + #v + 1
	end
	for k, v in pairs(ExtTextFile) do -- String
		v = v.."\0"
		Fileptr:write(v)
	end
	io.close(Fileptr)

	local FileAct = {}
	local ret = {}
	for i = 1, #FilePath do
		table.insert(ret,string.byte(FilePath,i))
	end

	local k = 1
	while true do
		local Value, Mask
		local prt = {0,0,0,0,0,0,0,0}
		for i = 0, 7 do
			if ret[k+i] ~= nil then
				prt[i+1] = ret[k+i]
			end
		end
		Mask = prt[1] + bit32.lshift(prt[2],8) + bit32.lshift(prt[3],16) + bit32.lshift(prt[4],24)
		Value = prt[5] + bit32.lshift(prt[6],8) + bit32.lshift(prt[7],16) + bit32.lshift(prt[8],24)
		table.insert(FileAct,SetDeathsX(#ExtTextFile,SetTo,Value,0,Mask))
		k = k+8
		if k > #ret then break end
	end

	Trigger {
		players = {CurrentPlayer,PlayerID},
		conditions = {
			Label(FuncAlloc);
			Never();
		},
		actions = {
			FileAct;
		},
	}
	FuncAlloc = FuncAlloc + 1
end


__tranwire32 = {0x00070040, 0x03562014, 0x01030000, 0x05C51E17, 0x05000000, 0x07B63520, 0x02020000, 0x0C213C1E, 0x05010000, 0x1185091D, 0x00010000, 0x1291403F, 0x05010000, 0x1B28091D, 0x01030000, 0x1C2A201C, 0x05010000, 0x1EF7091D, 0x05010000, 0x1EF7091D, 0x00040000, 0x1FFE2018, 0x05010000, 0x1EF7091D, 0x05010000, 0x1EF7091D, 0x02010000, 0x22B91C1A, 0x05010000, 0x256F091D, 0x02060000, 0x267B1E12, 0x00030000, 0x28532017, 0x02020000, 0x2A603C1E, 0x05010000, 0x2FC4091D, 0x05000000, 0x07B63520, 0x00070000, 0x30D22014, 0x02020000, 0x2A603C1E, 0x05010000, 0x2FC4091D, 0x00010000, 0x3341403F, 0x05010000, 0x1B28091D, 0x05010000, 0x1B28091D, 0x05010000, 0x1B28091D, 0x05010000, 0x1B28091D, 0x05010000, 0x1B28091D, 0x05010000, 0x1B28091D, 0x00000000, 0x3BD6403C, 0x05010000, 0x4561091D, 0x00040000, 0x1FFE2018, 0x00070000, 0x30D22014, 0x01060000, 0x46672017, 0x05050000, 0x49271615, 0x05010000, 0x4A59091D, 0x00060000, 0x4B5A1F17, 0x06000000, 0x4D1C351F, 0x06000000, 0x50A13440, 0x01030000, 0x55B91E1B, 0x02000000, 0x57A71E20, 0x05010000, 0x5A23091D, 0x05010000, 0x5A23091D, 0x05010000, 0x5A23091D, 0x05010000, 0x5A23091D, 0x06010000, 0x5B2D321F, 0x05010000, 0x5DAE091D, 0x06000000, 0x50A13440, 0x0B070000, 0x5EB22732, 0x00010000, 0x62C0201C, 0x01020000, 0x65421F1B, 0x06010000, 0x5B2D321F, 0x06000000, 0x4D1C351F, 0x00060000, 0x4B5A1F17, 0x05010000, 0x1EF7091D, 0x05010000, 0x1EF7091D, 0x05010000, 0x1EF7091D, 0x03000000, 0x675A3B40, 0x05010000, 0x1EF7091D, 0x05010000, 0x1EF7091D, 0x00000000, 0x6F32401F, 0x01000000, 0x74B93D3C, 0x00030000, 0x7C39403C, 0x00010000, 0x8524201F, 0x00010000, 0x882A401F, 0x01070000, 0x8EB73E31, 0x00000000, 0x96684020, 0x03010000, 0x9CD53D3C, 0x05010000, 0x5A23091D, 0x05010000, 0x5A23091D, 0x05010000, 0x5A23091D, 0x05010000, 0x5A23091D, 0x05010000, 0x5A23091D, 0x00000000, 0x6F32401F, 0x00000000, 0x6F32401F, 0x03010000, 0x9CD53D3C, 0x00010000, 0xA5F2401F, 0x01070000, 0x8EB73E31, 0x00000000, 0x96684020, 0x00000000, 0xAC7D2020, 0x06030000, 0xAFB3383A, 0x05010000, 0xB6CE091D, 0x06030000, 0xAFB3383A, 0x05010000, 0xB7D8091D, 0x05010000, 0xB7D8091D, 0x05010000, 0xB7D8091D, 0x05010000, 0xB7D8091D, 0x01030000, 0x05C51E17, 0x03000000, 0xB8D91B20, 0x04000000, 0xBB75181F, 0x06000000, 0xBCEB3440, 0x06000000, 0xBCEB3440, 0x00010000, 0xC2981F1B, 0x05010000, 0xB7D8091D, 0x05000000, 0xC47D1520, 0x05010000, 0xC6311A19, 0x05010000, 0xB7D8091D, 0x05010000, 0xB7D8091D, 0x01030000, 0x05C51E17, 0x01030000, 0x05C51E17, 0x06000000, 0xBCEB3440, 0x05010000, 0x1EF7091D, 0x06000000, 0xBCEB3440, 0x01030000, 0x05C51E17, 0x05010000, 0xB7D8091D, 0x00400000, 0x00510047}
__tranwire64 = {0x00070040, 0x04FE2014, 0x01030000, 0x076D1E17, 0x05000000, 0x095E3520, 0x02020000, 0x0DC93C1E, 0x05010000, 0x132D091D, 0x00010000, 0x1439403F, 0x05010000, 0x1CD0091D, 0x01030000, 0x1DD2201C, 0x05010000, 0x209F091D, 0x05010000, 0x209F091D, 0x00040000, 0x21A62018, 0x05010000, 0x209F091D, 0x05010000, 0x209F091D, 0x02010000, 0x24611C1A, 0x05010000, 0x2717091D, 0x02060000, 0x28231E12, 0x00030000, 0x29FB2017, 0x02020000, 0x2C083C1E, 0x05010000, 0x316C091D, 0x05000000, 0x095E3520, 0x00070000, 0x327A2014, 0x02020000, 0x2C083C1E, 0x05010000, 0x316C091D, 0x00010000, 0x34E9403F, 0x05010000, 0x1CD0091D, 0x05010000, 0x1CD0091D, 0x05010000, 0x1CD0091D, 0x05010000, 0x1CD0091D, 0x05010000, 0x1CD0091D, 0x05010000, 0x1CD0091D, 0x00000000, 0x3D7E403C, 0x05010000, 0x4709091D, 0x00040000, 0x21A62018, 0x00070000, 0x327A2014, 0x01060000, 0x480F2017, 0x05050000, 0x4ACF1615, 0x05010000, 0x4C01091D, 0x00060000, 0x4D021F17, 0x06000000, 0x4EC4351F, 0x06000000, 0x52493440, 0x01030000, 0x57611E1B, 0x02000000, 0x594F1E20, 0x05010000, 0x5BCB091D, 0x05010000, 0x5BCB091D, 0x05010000, 0x5BCB091D, 0x05010000, 0x5BCB091D, 0x06010000, 0x5CD5321F, 0x05010000, 0x5F56091D, 0x06000000, 0x52493440, 0x0B070000, 0x605A2732, 0x00010000, 0x6468201C, 0x01020000, 0x66EA1F1B, 0x06010000, 0x5CD5321F, 0x06000000, 0x4EC4351F, 0x00060000, 0x4D021F17, 0x05010000, 0x209F091D, 0x05010000, 0x209F091D, 0x05010000, 0x209F091D, 0x03000000, 0x69023B40, 0x05010000, 0x209F091D, 0x05010000, 0x209F091D, 0x00000000, 0x70DA401F, 0x01000000, 0x76613D3C, 0x00030000, 0x7DE1403C, 0x00010000, 0x86CC201F, 0x00010000, 0x89D2401F, 0x01070000, 0x905F3E31, 0x00000000, 0x98104020, 0x03010000, 0x9E7D3D3C, 0x05010000, 0x5BCB091D, 0x05010000, 0x5BCB091D, 0x05010000, 0x5BCB091D, 0x05010000, 0x5BCB091D, 0x05010000, 0x5BCB091D, 0x00000000, 0x70DA401F, 0x00000000, 0x70DA401F, 0x03010000, 0x9E7D3D3C, 0x00010000, 0xA79A401F, 0x01070000, 0x905F3E31, 0x00000000, 0x98104020, 0x00000000, 0xAE252020, 0x06030000, 0xB15B383A, 0x05010000, 0xB876091D, 0x06030000, 0xB15B383A, 0x05010000, 0xB980091D, 0x05010000, 0xB980091D, 0x05010000, 0xB980091D, 0x05010000, 0xB980091D, 0x01030000, 0x076D1E17, 0x03000000, 0xBA811B20, 0x04000000, 0xBD1D181F, 0x06000000, 0xBE933440, 0x06000000, 0xBE933440, 0x00010000, 0xC4401F1B, 0x05010000, 0xB980091D, 0x05000000, 0xC6251520, 0x05010000, 0xC7D91A19, 0x05010000, 0xB980091D, 0x05010000, 0xB980091D, 0x01030000, 0x076D1E17, 0x01030000, 0x076D1E17, 0x06000000, 0xBE933440, 0x05010000, 0x209F091D, 0x06000000, 0xBE933440, 0x01030000, 0x076D1E17, 0x05010000, 0xB980091D, 0x00400000, 0x00510047}
__grpwire32 = {0x00070020, 0x041E2014, 0x01030000, 0x068D1E17, 0x03000000, 0x087E1C20, 0x00030000, 0x0AD5201C, 0x05010000, 0x0DA2091D, 0x00010000, 0x0EA6201F, 0x05010000, 0x1176091D, 0x00030000, 0x127D201C, 0x04000000, 0x154A1920, 0x00000000, 0x17E61F1F, 0x00040000, 0x1AF22018, 0x00000000, 0x1DA91F20, 0x01000000, 0x20E81E20, 0x00020000, 0x2432201C, 0x05010000, 0x2774091D, 0x02060000, 0x287B1E12, 0x00030000, 0x2A532017, 0x00030000, 0x0AD5201C, 0x05010000, 0x2C60091D, 0x03000000, 0x087E1C20, 0x00070000, 0x2D672014, 0x04000000, 0x2FD81920, 0x00000000, 0x17E61F1F, 0x00010000, 0x0EA6201F, 0x05010000, 0x3276091D, 0x00010000, 0x337D1F1D, 0x05010000, 0x2C60091D, 0x05010000, 0x2C60091D, 0x01000000, 0x20E81E20, 0x01000000, 0x20E81E20, 0x00010000, 0x337D1F1D, 0x05010000, 0x366A091D, 0x00040000, 0x37742018, 0x00070000, 0x3A2F2014, 0x00060000, 0x3C9E2017, 0x00020000, 0x3F5C201D, 0x02000000, 0x414C1C20, 0x00040000, 0x43B72018, 0x00030000, 0x45A1201C, 0x03000000, 0x47BD1B20, 0x01030000, 0x49E11E1B, 0x01000000, 0x4BCF1E20, 0x00030000, 0x4E4B201C, 0x02000000, 0x51421C20, 0x02000000, 0x534B1C20, 0x00000000, 0x55542020, 0x01000000, 0x57ED1F20, 0x02010000, 0x59B31C1E, 0x03000000, 0x47BD1B20, 0x00000000, 0x55542020, 0x00010000, 0x5B93201C, 0x01020000, 0x5E151F1B, 0x01000000, 0x57ED1F20, 0x00030000, 0x45A1201C, 0x00040000, 0x602D2018, 0x02000000, 0x62171C20, 0x02000000, 0x534B1C20, 0x00030000, 0x4E4B201C, 0x02000000, 0x641F1D20, 0x02000000, 0x66DE1C20, 0x02010000, 0x69571B1D, 0x00000000, 0x6B9E201E, 0x01000000, 0x6E541E1E, 0x01020000, 0x70C51F1E, 0x00010000, 0x7396201F, 0x00010000, 0x769C201F, 0x01040000, 0x79F11F18, 0x00000000, 0x7C862020, 0x00000000, 0x7FDC2020, 0x04000000, 0x832E1B20, 0x00000000, 0x85D81F20, 0x00000000, 0x8895201F, 0x00000000, 0x8B7D2020, 0x04000000, 0x8EB61920, 0x00000000, 0x6B9E201E, 0x00000000, 0x6B9E201E, 0x00000000, 0x7FDC2020, 0x00010000, 0x769C201F, 0x01040000, 0x79F11F18, 0x00000000, 0x7C862020, 0x00000000, 0x90C21F20, 0x02000000, 0x93811D1F, 0x00000000, 0x8B7D2020, 0x02000000, 0x93811D1F, 0x01010000, 0x961D1D1C, 0x05010000, 0x987D091D, 0x00000000, 0x8895201F, 0x05010000, 0x366A091D, 0x00000000, 0x85D81F20, 0x03000000, 0x99841B20, 0x04000000, 0x9C20181F, 0x03000000, 0x9D961A20, 0x03000000, 0x9D961A20, 0x00010000, 0x9F7D1F1B, 0x00000000, 0xA1621F20, 0x05000000, 0xA30C1520, 0x05010000, 0xA4C01A19, 0x08020000, 0xA6920E1A, 0x00000000, 0x6B9E201E, 0x01030000, 0x068D1E17, 0x01030000, 0x068D1E17, 0x03000000, 0x9D961A20, 0x01000000, 0x20E81E20, 0x03000000, 0x9D961A20, 0x01030000, 0x068D1E17, 0x05010000, 0xA7A9091D, 0x02000000, 0xA8B31D20, 0x05010000, 0xABAF091D, 0x05010000, 0xABAF091D, 0x05010000, 0xABAF091D, 0x05010000, 0xABAF091D, 0x01000000, 0xACB61F20, 0x05010000, 0xAFF7091D, 0x01000000, 0xB0FD1F20, 0x00000000, 0xB4602020, 0x05010000, 0xB7A5091D, 0x05000000, 0xB8AB1820, 0x05010000, 0xBB3A091D, 0x05010000, 0xBB3A091D, 0x05010000, 0xBB3A091D, 0x05010000, 0xBB3A091D, 0x05010000, 0xBB3A091D, 0x05000000, 0xBC431720, 0x05010000, 0x366A091D, 0x05010000, 0x366A091D, 0x05010000, 0x366A091D, 0x05010000, 0x366A091D, 0x05010000, 0x366A091D, 0x05010000, 0x366A091D, 0x05010000, 0x366A091D, 0x05010000, 0x366A091D, 0x00400000, 0x00510047}
__grpwire64 = {0x00070020, 0x062A2014, 0x01030000, 0x08991E17, 0x03000000, 0x0A8A1C20, 0x00030000, 0x0CE1201C, 0x05010000, 0x0FAE091D, 0x00010000, 0x10B2201F, 0x05010000, 0x1382091D, 0x00030000, 0x1489201C, 0x04000000, 0x17561920, 0x00000000, 0x19F21F1F, 0x00040000, 0x1CFE2018, 0x00000000, 0x1FB51F20, 0x01000000, 0x22F41E20, 0x00020000, 0x263E201C, 0x05010000, 0x2980091D, 0x02060000, 0x2A871E12, 0x00030000, 0x2C5F2017, 0x00030000, 0x0CE1201C, 0x05010000, 0x2E6C091D, 0x03000000, 0x0A8A1C20, 0x00070000, 0x2F732014, 0x04000000, 0x31E41920, 0x00000000, 0x19F21F1F, 0x00010000, 0x10B2201F, 0x05010000, 0x3482091D, 0x00010000, 0x35891F1D, 0x05010000, 0x2E6C091D, 0x05010000, 0x2E6C091D, 0x01000000, 0x22F41E20, 0x01000000, 0x22F41E20, 0x00010000, 0x35891F1D, 0x05010000, 0x3876091D, 0x00040000, 0x39802018, 0x00070000, 0x3C3B2014, 0x00060000, 0x3EAA2017, 0x00020000, 0x4168201D, 0x02000000, 0x43581C20, 0x00040000, 0x45C32018, 0x00030000, 0x47AD201C, 0x03000000, 0x49C91B20, 0x01030000, 0x4BED1E1B, 0x01000000, 0x4DDB1E20, 0x00030000, 0x5057201C, 0x02000000, 0x534E1C20, 0x02000000, 0x55571C20, 0x00000000, 0x57602020, 0x01000000, 0x59F91F20, 0x02010000, 0x5BBF1C1E, 0x03000000, 0x49C91B20, 0x00000000, 0x57602020, 0x00010000, 0x5D9F201C, 0x01020000, 0x60211F1B, 0x01000000, 0x59F91F20, 0x00030000, 0x47AD201C, 0x00040000, 0x62392018, 0x02000000, 0x64231C20, 0x02000000, 0x55571C20, 0x00030000, 0x5057201C, 0x02000000, 0x662B1D20, 0x02000000, 0x68EA1C20, 0x02010000, 0x6B631B1D, 0x00000000, 0x6DAA201E, 0x01000000, 0x70601E1E, 0x01020000, 0x72D11F1E, 0x00010000, 0x75A2201F, 0x00010000, 0x78A8201F, 0x01040000, 0x7BFD1F18, 0x00000000, 0x7E922020, 0x00000000, 0x81E82020, 0x04000000, 0x853A1B20, 0x00000000, 0x87E41F20, 0x00000000, 0x8AA1201F, 0x00000000, 0x8D892020, 0x04000000, 0x90C21920, 0x00000000, 0x6DAA201E, 0x00000000, 0x6DAA201E, 0x00000000, 0x81E82020, 0x00010000, 0x78A8201F, 0x01040000, 0x7BFD1F18, 0x00000000, 0x7E922020, 0x00000000, 0x92CE1F20, 0x02000000, 0x958D1D1F, 0x00000000, 0x8D892020, 0x02000000, 0x958D1D1F, 0x01010000, 0x98291D1C, 0x05010000, 0x9A89091D, 0x00000000, 0x8AA1201F, 0x05010000, 0x3876091D, 0x00000000, 0x87E41F20, 0x03000000, 0x9B901B20, 0x04000000, 0x9E2C181F, 0x03000000, 0x9FA21A20, 0x03000000, 0x9FA21A20, 0x00010000, 0xA1891F1B, 0x00000000, 0xA36E1F20, 0x05000000, 0xA5181520, 0x05010000, 0xA6CC1A19, 0x08020000, 0xA89E0E1A, 0x00000000, 0x6DAA201E, 0x01030000, 0x08991E17, 0x01030000, 0x08991E17, 0x03000000, 0x9FA21A20, 0x01000000, 0x22F41E20, 0x03000000, 0x9FA21A20, 0x01030000, 0x08991E17, 0x05010000, 0xA9B5091D, 0x02000000, 0xAABF1D20, 0x05010000, 0xADBB091D, 0x05010000, 0xADBB091D, 0x05010000, 0xADBB091D, 0x05010000, 0xADBB091D, 0x01000000, 0xAEC21F20, 0x05010000, 0xB203091D, 0x01000000, 0xB3091F20, 0x00000000, 0xB66C2020, 0x05010000, 0xB9B1091D, 0x05000000, 0xBAB71820, 0x05010000, 0xBD46091D, 0x05010000, 0xBD46091D, 0x05010000, 0xBD46091D, 0x05010000, 0xBD46091D, 0x05010000, 0xBD46091D, 0x05000000, 0xBE4F1720, 0x05010000, 0x3876091D, 0x05010000, 0x3876091D, 0x05010000, 0x3876091D, 0x05010000, 0x3876091D, 0x05010000, 0x3876091D, 0x05010000, 0x3876091D, 0x05010000, 0x3876091D, 0x05010000, 0x3876091D, 0x00400000, 0x00510047}
__wireframe32 = {0x000D0040, 0x07263F28, 0x02070000, 0x0E473C2E, 0x06000000, 0x138F3540, 0x00050000, 0x19A54037, 0x05010000, 0x21A4091D, 0x00010000, 0x22AE403F, 0x05010000, 0x2B47091D, 0x00050000, 0x2C464039, 0x07000000, 0x34AF3440, 0x00000000, 0x3C654040, 0x00060000, 0x45FC4030, 0x02000000, 0x4E013C40, 0x01000000, 0x569D3840, 0x06010000, 0x5F51353F, 0x05010000, 0x6560091D, 0x030D0000, 0x66613C23, 0x01070000, 0x6B223F2E, 0x00050000, 0x709D4037, 0x05010000, 0x789C091D, 0x06000000, 0x138F3540, 0x000D0000, 0x79A03F28, 0x07000000, 0x80BB3440, 0x00000000, 0x3C654040, 0x00010000, 0x8871403F, 0x05010000, 0x9106091D, 0x00000000, 0x9204403C, 0x05010000, 0x9B81091D, 0x05010000, 0x9B81091D, 0x01000000, 0x9C843840, 0x01000000, 0x9C843840, 0x00000000, 0xA53A403C, 0x05010000, 0xAEBB091D, 0x00060000, 0xAFC54030, 0x000D0000, 0xB7CA3F28, 0x000C0000, 0xBEED402E, 0x080A0000, 0xC72D2D2A, 0x0B070000, 0xCA632732, 0x000B0000, 0xCE713F2E, 0x050B0000, 0xD383352F, 0x06000000, 0xD7A73440, 0x05030000, 0xDCBF3A35, 0x0C050000, 0xE2062E36, 0x01070000, 0xE7093D31, 0x07020000, 0xEE803139, 0x08000000, 0xF35C3140, 0x06040000, 0xF8A03537, 0x06010000, 0xFEB7323F, 0x04010000, 0x0259393E, 0x06000001, 0xD7A73440, 0x06040000, 0xF8A03537, 0x01090000, 0x07D43A2F, 0x00000001, 0x0E943D37, 0x06010001, 0xFEB7323F, 0x050B0000, 0xD383352F, 0x000B0000, 0xCE713F2E, 0x07020000, 0xEE803139, 0x08000000, 0xF35C3140, 0x01070000, 0xE7093D31, 0x03000000, 0x14913B40, 0x0F0B0001, 0x1C6D282D, 0x04020001, 0x20DB363A, 0x00000001, 0x2736403D, 0x01000001, 0x2E773D3C, 0x00030001, 0x35F7403C, 0x01030001, 0x3EE23E3A, 0x00010001, 0x45F3403E, 0x01070001, 0x50023E31, 0x00000001, 0x57B34040, 0x03010001, 0x61413D3C, 0x03000001, 0x6A5E3840, 0x02000001, 0x723C3D40, 0x00000001, 0x79784040, 0x00010001, 0x826D403F, 0x05000001, 0x8C203340, 0x00000001, 0x2736403D, 0x00000001, 0x2736403D, 0x03010001, 0x61413D3C, 0x00010001, 0x928E403E, 0x01070001, 0x50023E31, 0x00000001, 0x57B34040, 0x02000001, 0x9C9E3D40, 0x06030001, 0xA3D9383A, 0x00010001, 0xAAF4403F, 0x06030001, 0xB4A7383A, 0x04050001, 0xBBC23635, 0x05010001, 0xC1EC091D, 0x00000001, 0xC2ED4040, 0x05010001, 0xCBE4091D, 0x02000001, 0xCCE03D40, 0x06010001, 0xD41B373F, 0x09000001, 0xDC072F3E, 0x06000001, 0xE03E3340, 0x03000001, 0xE8683B40, 0x00030001, 0xF0814036, 0x01000001, 0xF6393E40, 0x0A000001, 0xFB052B40, 0x0A020001, 0x005C3433, 0x10050002, 0x05911C35, 0x00000002, 0x2736403D, 0x02070001, 0x0E473C2E, 0x02070000, 0x0E473C2E, 0x05010000, 0x08D0091D, 0x01000002, 0x09D13840, 0x06000002, 0x12873440, 0x02080002, 0x0E473C2E, 0x05010000, 0x08D0091D, 0x03000002, 0x18343A40, 0x01000002, 0x219E3F40, 0x00000002, 0x29F84040, 0x06000002, 0x336D3540, 0x06000002, 0x3B713540, 0x02000002, 0x442A3D40, 0x00000002, 0x4E4A3F40, 0x00000002, 0x57703F40, 0x00000002, 0x625C4040, 0x00000002, 0x6BFB3F40, 0x09000002, 0x75BB3140, 0x04000002, 0x7D793640, 0x00000002, 0x85254040, 0x05010002, 0x8DFE091D, 0x01010002, 0x8F023D3C, 0x01000002, 0x97DE3F40, 0x09000002, 0xA1902E40, 0x00000002, 0xA76B4040, 0x00070002, 0xB20C4032, 0x0B000002, 0xBACA2B40, 0x07000002, 0xC1C93240, 0x0E040002, 0xC8422633, 0x070D0002, 0xCBBA3423, 0x070D0002, 0xCBBA3423, 0x04000002, 0xCEBA3340, 0x0B030002, 0xD7C2353A, 0x00000002, 0xDE8C4040, 0x00020002, 0xE78C403D, 0x00000002, 0xF0A53F40, 0x01000002, 0xFA143E40, 0x06010002, 0x033F303F, 0x00080003, 0x098F4032, 0x01000003, 0x11D7393E, 0x01000003, 0x19C13C3F, 0x01000003, 0x22463C40, 0x00070003, 0x2AE14032, 0x0A000003, 0x32EF2C40, 0x08010003, 0x3984363D, 0x00020003, 0x41D3403D, 0x05010003, 0x4A20091D, 0x06000003, 0x4B2A2E40, 0x06000003, 0x511F3240, 0x0A000003, 0x5A152E40, 0x01020003, 0x60EB3B3C, 0x01010003, 0x69103B3E, 0x0A000003, 0x6EC12A40, 0x0A000003, 0x6EC12A40, 0x05010003, 0x7590091D, 0x00000003, 0x769A4040, 0x00000003, 0x81AB4040, 0x00030003, 0x8AE8403A, 0x05000003, 0x94893540, 0x05010003, 0x9C57091D, 0x04000003, 0x9D573740, 0x02000003, 0xA5F23C40, 0x05010003, 0xAFB8091D, 0x0B000003, 0xB0BF2D40, 0x00000003, 0xB6F54040, 0x00000003, 0xC1264040, 0x00000003, 0xCB334040, 0x00000003, 0xD3114040, 0x00000003, 0xDCA33F40, 0x00000003, 0xE4A14040, 0x07000003, 0xEDA53340, 0x04000003, 0xF52B3840, 0x02000003, 0xFD4F3C40, 0x0A000003, 0x06A72D40, 0x00000004, 0x0DEF3F40, 0x06000004, 0x15EC3240, 0x00050004, 0x1DB34037, 0x07000004, 0x252A3540, 0x07000004, 0x252A3540, 0x07000004, 0x252A3540, 0x1A140004, 0x2E0A0717, 0x1A140004, 0x2E0A0717, 0x1D0D0004, 0x2E7D0725, 0x05010004, 0x2F46091D, 0x1F080004, 0x3050082D, 0x05010004, 0x2F46091D, 0x1F080004, 0x313F0836, 0x05020004, 0x324C353D, 0x00000004, 0x38833F40, 0x0C000004, 0x40812A40, 0x00050004, 0x47294034, 0x00000004, 0x4E8D3F40, 0x05010004, 0x2F46091D, 0x05010004, 0x2F46091D, 0x05010004, 0x2F46091D, 0x0F000004, 0x57F42340, 0x08000004, 0x5D122C40, 0x07010004, 0x61AB293F, 0x0F000004, 0x65E72340, 0x08000004, 0x5D122C40, 0x07010004, 0x61AB293F, 0x06000004, 0x6B053640, 0x10010004, 0x7221243E, 0x05010004, 0x7590091D, 0x0B000003, 0x779D2C40, 0x05010004, 0x7590091D, 0x05010003, 0x7590091D, 0x05010003, 0x7590091D, 0x05010003, 0x7590091D, 0x05010003, 0x7590091D, 0x090B0003, 0x7C802E2B, 0x0D0E0004, 0x80692725, 0x0A120004, 0x84402D1C, 0x0D0E0004, 0x80692725, 0x0A120004, 0x84402D1C, 0x05010004, 0x2F46091D, 0x02080004, 0x87653D2D, 0x04100004, 0x8B623323, 0x070A0004, 0x8F66322D, 0x11040004, 0x94592239, 0x070D0004, 0xCBBA3423, 0x00000002, 0x97804040, 0x00000004, 0x97804040, 0x06070004, 0x9F033633, 0x06070004, 0x9F033633, 0x05070004, 0xA2D23734, 0x05070004, 0xA2D23734, 0x03060004, 0xAA223B33, 0x03060004, 0xAA223B33, 0x007E0004, 0x008C0082}
__wireframe64 = {0x000D0040, 0x0AB63F28, 0x02070000, 0x11D73C2E, 0x06000000, 0x171F3540, 0x00050000, 0x1D354037, 0x05010000, 0x2534091D, 0x00010000, 0x263E403F, 0x05010000, 0x2ED7091D, 0x00050000, 0x2FD64039, 0x07000000, 0x383F3440, 0x00000000, 0x3FF54040, 0x00060000, 0x498C4030, 0x02000000, 0x51913C40, 0x01000000, 0x5A2D3840, 0x06010000, 0x62E1353F, 0x05010000, 0x68F0091D, 0x030D0000, 0x69F13C23, 0x01070000, 0x6EB23F2E, 0x00050000, 0x742D4037, 0x05010000, 0x7C2C091D, 0x06000000, 0x171F3540, 0x000D0000, 0x7D303F28, 0x07000000, 0x844B3440, 0x00000000, 0x3FF54040, 0x00010000, 0x8C01403F, 0x05010000, 0x9496091D, 0x00000000, 0x9594403C, 0x05010000, 0x9F11091D, 0x05010000, 0x9F11091D, 0x01000000, 0xA0143840, 0x01000000, 0xA0143840, 0x00000000, 0xA8CA403C, 0x05010000, 0xB24B091D, 0x00060000, 0xB3554030, 0x000D0000, 0xBB5A3F28, 0x000C0000, 0xC27D402E, 0x080A0000, 0xCABD2D2A, 0x0B070000, 0xCDF32732, 0x000B0000, 0xD2013F2E, 0x050B0000, 0xD713352F, 0x06000000, 0xDB373440, 0x05030000, 0xE04F3A35, 0x0C050000, 0xE5962E36, 0x01070000, 0xEA993D31, 0x07020000, 0xF2103139, 0x08000000, 0xF6EC3140, 0x06040000, 0xFC303537, 0x06010000, 0x0247323F, 0x04010001, 0x05E9393E, 0x06000001, 0xDB373440, 0x06040000, 0xFC303537, 0x01090000, 0x0B643A2F, 0x00000001, 0x12243D37, 0x06010001, 0x0247323F, 0x050B0001, 0xD713352F, 0x000B0000, 0xD2013F2E, 0x07020000, 0xF2103139, 0x08000000, 0xF6EC3140, 0x01070000, 0xEA993D31, 0x03000000, 0x18213B40, 0x0F0B0001, 0x1FFD282D, 0x04020001, 0x246B363A, 0x00000001, 0x2AC6403D, 0x01000001, 0x32073D3C, 0x00030001, 0x3987403C, 0x01030001, 0x42723E3A, 0x00010001, 0x4983403E, 0x01070001, 0x53923E31, 0x00000001, 0x5B434040, 0x03010001, 0x64D13D3C, 0x03000001, 0x6DEE3840, 0x02000001, 0x75CC3D40, 0x00000001, 0x7D084040, 0x00010001, 0x85FD403F, 0x05000001, 0x8FB03340, 0x00000001, 0x2AC6403D, 0x00000001, 0x2AC6403D, 0x03010001, 0x64D13D3C, 0x00010001, 0x961E403E, 0x01070001, 0x53923E31, 0x00000001, 0x5B434040, 0x02000001, 0xA02E3D40, 0x06030001, 0xA769383A, 0x00010001, 0xAE84403F, 0x06030001, 0xB837383A, 0x04050001, 0xBF523635, 0x05010001, 0xC57C091D, 0x00000001, 0xC67D4040, 0x05010001, 0xCF74091D, 0x02000001, 0xD0703D40, 0x06010001, 0xD7AB373F, 0x09000001, 0xDF972F3E, 0x06000001, 0xE3CE3340, 0x03000001, 0xEBF83B40, 0x00030001, 0xF4114036, 0x01000001, 0xF9C93E40, 0x0A000001, 0xFE952B40, 0x0A020001, 0x03EC3433, 0x10050002, 0x09211C35, 0x00000002, 0x2AC6403D, 0x02070001, 0x11D73C2E, 0x02070000, 0x11D73C2E, 0x05010000, 0x0C60091D, 0x01000002, 0x0D613840, 0x06000002, 0x16173440, 0x02080002, 0x11D73C2E, 0x05010000, 0x0C60091D, 0x03000002, 0x1BC43A40, 0x01000002, 0x252E3F40, 0x00000002, 0x2D884040, 0x06000002, 0x36FD3540, 0x06000002, 0x3F013540, 0x02000002, 0x47BA3D40, 0x00000002, 0x51DA3F40, 0x00000002, 0x5B003F40, 0x00000002, 0x65EC4040, 0x00000002, 0x6F8B3F40, 0x09000002, 0x794B3140, 0x04000002, 0x81093640, 0x00000002, 0x88B54040, 0x05010002, 0x918E091D, 0x01010002, 0x92923D3C, 0x01000002, 0x9B6E3F40, 0x09000002, 0xA5202E40, 0x00000002, 0xAAFB4040, 0x00070002, 0xB59C4032, 0x0B000002, 0xBE5A2B40, 0x07000002, 0xC5593240, 0x0E040002, 0xCBD22633, 0x070D0002, 0xCF4A3423, 0x070D0002, 0xCF4A3423, 0x04000002, 0xD24A3340, 0x0B030002, 0xDB52353A, 0x00000002, 0xE21C4040, 0x00020002, 0xEB1C403D, 0x00000002, 0xF4353F40, 0x01000002, 0xFDA43E40, 0x06010002, 0x06CF303F, 0x00080003, 0x0D1F4032, 0x01000003, 0x1567393E, 0x01000003, 0x1D513C3F, 0x01000003, 0x25D63C40, 0x00070003, 0x2E714032, 0x0A000003, 0x367F2C40, 0x08010003, 0x3D14363D, 0x00020003, 0x4563403D, 0x05010003, 0x4DB0091D, 0x06000003, 0x4EBA2E40, 0x06000003, 0x54AF3240, 0x0A000003, 0x5DA52E40, 0x01020003, 0x647B3B3C, 0x01010003, 0x6CA03B3E, 0x0A000003, 0x72512A40, 0x0A000003, 0x72512A40, 0x05010003, 0x7920091D, 0x00000003, 0x7A2A4040, 0x00000003, 0x853B4040, 0x00030003, 0x8E78403A, 0x05000003, 0x98193540, 0x05010003, 0x9FE7091D, 0x04000003, 0xA0E73740, 0x02000003, 0xA9823C40, 0x05010003, 0xB348091D, 0x0B000003, 0xB44F2D40, 0x00000003, 0xBA854040, 0x00000003, 0xC4B64040, 0x00000003, 0xCEC34040, 0x00000003, 0xD6A14040, 0x00000003, 0xE0333F40, 0x00000003, 0xE8314040, 0x07000003, 0xF1353340, 0x04000003, 0xF8BB3840, 0x02000003, 0x00DF3C40, 0x0A000004, 0x0A372D40, 0x00000004, 0x117F3F40, 0x06000004, 0x197C3240, 0x00050004, 0x21434037, 0x07000004, 0x28BA3540, 0x07000004, 0x28BA3540, 0x07000004, 0x28BA3540, 0x1A140004, 0x319A0717, 0x1A140004, 0x319A0717, 0x1D0D0004, 0x320D0725, 0x05010004, 0x32D6091D, 0x1F080004, 0x33E0082D, 0x05010004, 0x32D6091D, 0x1F080004, 0x34CF0836, 0x05020004, 0x35DC353D, 0x00000004, 0x3C133F40, 0x0C000004, 0x44112A40, 0x00050004, 0x4AB94034, 0x00000004, 0x521D3F40, 0x05010004, 0x32D6091D, 0x05010004, 0x32D6091D, 0x05010004, 0x32D6091D, 0x0F000004, 0x5B842340, 0x08000004, 0x60A22C40, 0x07010004, 0x653B293F, 0x0F000004, 0x69772340, 0x08000004, 0x60A22C40, 0x07010004, 0x653B293F, 0x06000004, 0x6E953640, 0x10010004, 0x75B1243E, 0x05010004, 0x7920091D, 0x0B000003, 0x7B2D2C40, 0x05010004, 0x7920091D, 0x05010003, 0x7920091D, 0x05010003, 0x7920091D, 0x05010003, 0x7920091D, 0x05010003, 0x7920091D, 0x090B0003, 0x80102E2B, 0x0D0E0004, 0x83F92725, 0x0A120004, 0x87D02D1C, 0x0D0E0004, 0x83F92725, 0x0A120004, 0x87D02D1C, 0x05010004, 0x32D6091D, 0x02080004, 0x8AF53D2D, 0x04100004, 0x8EF23323, 0x070A0004, 0x92F6322D, 0x11040004, 0x97E92239, 0x070D0004, 0xCF4A3423, 0x00000002, 0x9B104040, 0x00000004, 0x9B104040, 0x06070004, 0xA2933633, 0x06070004, 0xA2933633, 0x05070004, 0xA6623734, 0x05070004, 0xA6623734, 0x03060004, 0xADB23B33, 0x03060004, 0xADB23B33, 0x007E0004, 0x008C0082}
FWIRE = {}
FWIREINITCall1 = 0
FWIREINITCall2 = 0
CheckInclude_Wireframe = 0
function Include_Wireframe()
if CheckInclude_Wireframe == 0 then
	CheckInclude_Wireframe = 1

	local IncludePlayer = FixPlayer
	for i = 0, 3 do
		CVariable(IncludePlayer,FuncAlloc+i)
		table.insert(FWIRE,FuncAlloc+i)
	end
	FuncAlloc = FuncAlloc + 4

	Trigger {
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc);
		},
		flag = {Preserved}
	}
	FWIREINITCall1 = FuncAlloc
	FuncAlloc = FuncAlloc + 1

	CEPD(IncludePlayer,V(FWIRE[1]),_ReadF(0x68C1F4))
	CEPD(IncludePlayer,V(FWIRE[2]),_ReadF(0x68C1FC))
	CEPD(IncludePlayer,V(FWIRE[3]),_ReadF(0x68C204))
	DoActionsX(IncludePlayer,{
		SetCVar("X",FWIRE[1],Add,1), -- tranwireptr
		SetCVar("X",FWIRE[2],Add,1), -- grpwireptr
		SetCVar("X",FWIRE[3],Add,1) -- wireframeptr
	})

	CIfX(IncludePlayer,{TMemory(Vi(FWIRE[3],2),Exactly,0)},{SetCVar("X",FWIRE[4],SetTo,1)}) -- 64bit
		CMov(IncludePlayer,0x6509B0,V(FWIRE[1]))
		local tranwireAct = {}
		for k, v in pairs(__tranwire64) do
			table.insert(tranwireAct,SetDeaths(CurrentPlayer,SetTo,v,0))
			table.insert(tranwireAct,SetMemory(0x6509B0,Add,1))
		end	
		DoActions2(IncludePlayer,tranwireAct)

		CMov(IncludePlayer,0x6509B0,V(FWIRE[2]))
		local grpwireAct = {}
		for k, v in pairs(__grpwire64) do
			table.insert(grpwireAct,SetDeaths(CurrentPlayer,SetTo,v,0))
			table.insert(grpwireAct,SetMemory(0x6509B0,Add,1))
		end	
		DoActions2(IncludePlayer,grpwireAct)

		CMov(IncludePlayer,0x6509B0,V(FWIRE[3]))
		local wireframeAct = {}
		for k, v in pairs(__wireframe64) do
			table.insert(wireframeAct,SetDeaths(CurrentPlayer,SetTo,v,0))
			table.insert(wireframeAct,SetMemory(0x6509B0,Add,1))
		end	
		DoActions2(IncludePlayer,wireframeAct)
	CElseX({SetCVar("X",FWIRE[4],SetTo,0)}) -- 32bit
	CIfXEnd()

	Trigger {
		players = {IncludePlayer},
		conditions = {
			Label(FuncAlloc);
		},
		flag = {Preserved}
	}

	FWIREINITCall2 = FuncAlloc
	FuncAlloc = FuncAlloc + 1
end
end

function Is64Bit()
	if CheckInclude_Wireframe == 0 then
		Need_Include_Wireframe()
	end
	return CVar(FixPlayer,FWIRE[4],Exactly,1)
end

function Not64Bit()
	if CheckInclude_Wireframe == 0 then
		Need_Include_Wireframe()
	end
	return CVar(FixPlayer,FWIRE[4],Exactly,0)
end

function ChangeAllwire(PlayerID,UnitID,Tran,Grp,Frame)
	if CheckInclude_Wireframe == 0 then
		Need_Include_Wireframe()
	end
	if UnitID > 227 or Tran > 105 or Grp > 130 or Frame > 227 then
		ChangeAllwire_InputData_Error()
	end
	WireAct1 = {
		TSetMemoryX(Vi(FWIRE[3],UnitID*2,FixPlayer),SetTo,__wireframe64[Frame*2+1],0xFFFF0000);
		TSetMemory(Vi(FWIRE[3],UnitID*2+1,FixPlayer),SetTo,__wireframe64[Frame*2+2]);
		TSetMemoryX(Vi(FWIRE[3],UnitID*2+2,FixPlayer),SetTo,__wireframe64[Frame*2+3],0xFFFF);
	}
	if UnitID <= 105 then
		table.insert(WireAct1,TSetMemoryX(Vi(FWIRE[1],UnitID*2,FixPlayer),SetTo,__tranwire64[Tran*2+1],0xFFFF0000))
		table.insert(WireAct1,TSetMemory(Vi(FWIRE[1],UnitID*2+1,FixPlayer),SetTo,__tranwire64[Tran*2+2]))
		table.insert(WireAct1,TSetMemoryX(Vi(FWIRE[1],UnitID*2+2,FixPlayer),SetTo,__tranwire64[Tran*2+3],0xFFFF))
	end
	if UnitID <= 130 then
		table.insert(WireAct1,TSetMemoryX(Vi(FWIRE[2],UnitID*2,FixPlayer),SetTo,__grpwire64[Grp*2+1],0xFFFF0000))
		table.insert(WireAct1,TSetMemory(Vi(FWIRE[2],UnitID*2+1,FixPlayer),SetTo,__grpwire64[Grp*2+2]))
		table.insert(WireAct1,TSetMemoryX(Vi(FWIRE[2],UnitID*2+2,FixPlayer),SetTo,__grpwire64[Grp*2+3],0xFFFF))
	end
	CTrigger(PlayerID,{Is64Bit()},WireAct1,{Preserved})

	WireAct2 = {
		TSetMemoryX(Vi(FWIRE[3],UnitID*2,FixPlayer),SetTo,__wireframe32[Frame*2+1],0xFFFF0000);
		TSetMemory(Vi(FWIRE[3],UnitID*2+1,FixPlayer),SetTo,__wireframe32[Frame*2+2]);
		TSetMemoryX(Vi(FWIRE[3],UnitID*2+2,FixPlayer),SetTo,__wireframe32[Frame*2+3],0xFFFF);
	}
	if UnitID <= 105 then
		table.insert(WireAct2,TSetMemoryX(Vi(FWIRE[1],UnitID*2,FixPlayer),SetTo,__tranwire32[Tran*2+1],0xFFFF0000))
		table.insert(WireAct2,TSetMemory(Vi(FWIRE[1],UnitID*2+1,FixPlayer),SetTo,__tranwire32[Tran*2+2]))
		table.insert(WireAct2,TSetMemoryX(Vi(FWIRE[1],UnitID*2+2,FixPlayer),SetTo,__tranwire32[Tran*2+3],0xFFFF))
	end
	if UnitID <= 130 then
		table.insert(WireAct2,TSetMemoryX(Vi(FWIRE[2],UnitID*2,FixPlayer),SetTo,__grpwire32[Grp*2+1],0xFFFF0000))
		table.insert(WireAct2,TSetMemory(Vi(FWIRE[2],UnitID*2+1,FixPlayer),SetTo,__grpwire32[Grp*2+2]))
		table.insert(WireAct2,TSetMemoryX(Vi(FWIRE[2],UnitID*2+2,FixPlayer),SetTo,__grpwire32[Grp*2+3],0xFFFF))
	end
	CTrigger(PlayerID,{Not64Bit()},WireAct2,{Preserved})
end

function ChangeTranwire(PlayerID,UnitID,Index)
	if CheckInclude_Wireframe == 0 then
		Need_Include_Wireframe()
	end
	if UnitID > 105 or Index > 105 then
		ChangeTranwire_InputData_Error()
	end
	CTrigger(PlayerID,{Is64Bit()},{
		TSetMemoryX(Vi(FWIRE[1],UnitID*2,FixPlayer),SetTo,__tranwire64[Index*2+1],0xFFFF0000);
		TSetMemory(Vi(FWIRE[1],UnitID*2+1,FixPlayer),SetTo,__tranwire64[Index*2+2]);
		TSetMemoryX(Vi(FWIRE[1],UnitID*2+2,FixPlayer),SetTo,__tranwire64[Index*2+3],0xFFFF);
	},{Preserved})
	CTrigger(PlayerID,{Not64Bit()},{
		TSetMemoryX(Vi(FWIRE[1],UnitID*2,FixPlayer),SetTo,__tranwire32[Index*2+1],0xFFFF0000);
		TSetMemory(Vi(FWIRE[1],UnitID*2+1,FixPlayer),SetTo,__tranwire32[Index*2+2]);
		TSetMemoryX(Vi(FWIRE[1],UnitID*2+2,FixPlayer),SetTo,__tranwire32[Index*2+3],0xFFFF);
	},{Preserved})
end

function ChangeGrpwire(PlayerID,UnitID,Index)
	if CheckInclude_Wireframe == 0 then
		Need_Include_Wireframe()
	end
	if UnitID > 130 or Index > 130 then
		ChangeGrpwire_InputData_Error()
	end
	CTrigger(PlayerID,{Is64Bit()},{
		TSetMemoryX(Vi(FWIRE[2],UnitID*2,FixPlayer),SetTo,__grpwire64[Index*2+1],0xFFFF0000);
		TSetMemory(Vi(FWIRE[2],UnitID*2+1,FixPlayer),SetTo,__grpwire64[Index*2+2]);
		TSetMemoryX(Vi(FWIRE[2],UnitID*2+2,FixPlayer),SetTo,__grpwire64[Index*2+3],0xFFFF);
	},{Preserved})
	CTrigger(PlayerID,{Not64Bit()},{
		TSetMemoryX(Vi(FWIRE[2],UnitID*2,FixPlayer),SetTo,__grpwire32[Index*2+1],0xFFFF0000);
		TSetMemory(Vi(FWIRE[2],UnitID*2+1,FixPlayer),SetTo,__grpwire32[Index*2+2]);
		TSetMemoryX(Vi(FWIRE[2],UnitID*2+2,FixPlayer),SetTo,__grpwire32[Index*2+3],0xFFFF);
	},{Preserved})
end

function ChangeWireframe(PlayerID,UnitID,Index)
	if CheckInclude_Wireframe == 0 then
		Need_Include_Wireframe()
	end
	if UnitID > 227 or Index > 227 then
		ChangeWireframe_InputData_Error()
	end
	CTrigger(PlayerID,{Is64Bit()},{
		TSetMemoryX(Vi(FWIRE[3],UnitID*2,FixPlayer),SetTo,__wireframe64[Index*2+1],0xFFFF0000);
		TSetMemory(Vi(FWIRE[3],UnitID*2+1,FixPlayer),SetTo,__wireframe64[Index*2+2]);
		TSetMemoryX(Vi(FWIRE[3],UnitID*2+2,FixPlayer),SetTo,__wireframe64[Index*2+3],0xFFFF);
	},{Preserved})
	CTrigger(PlayerID,{Not64Bit()},{
		TSetMemoryX(Vi(FWIRE[3],UnitID*2,FixPlayer),SetTo,__wireframe32[Index*2+1],0xFFFF0000);
		TSetMemory(Vi(FWIRE[3],UnitID*2+1,FixPlayer),SetTo,__wireframe32[Index*2+2]);
		TSetMemoryX(Vi(FWIRE[3],UnitID*2+2,FixPlayer),SetTo,__wireframe32[Index*2+3],0xFFFF);
	},{Preserved})
end

function CreateBulletTargetX(PlayerID,Bag,Owner,UnitId,Height,Location,X,Y,Conditions,Actions,Preserve) -- XY->Angle
	if Conditions == nil then Conditions = {} end
	local Act1 = {}
	table.insert(Conditions,Memory(0x628438,AtLeast,1))
	if Preserve == 0 then
		CIfOnce2(PlayerID,Conditions)
	else
		CIf2(PlayerID,Conditions)
	end
		f_Read(PlayerID,0x628438,nil,V(NRet[16]))

		NAppend(PlayerID,Bag,V(NRet[16]))

		table.insert(Act1,SetMemory(0x66F048, SetTo, 86))

		if type(Height) == "number" then
			table.insert(Act1,SetMemoryB(0x663150+UnitId,SetTo,Height))
		elseif Height[4] == "V" then 
			table.insert(Act1,{TSetMemoryB,0x663150,UnitId,SetTo,Height})
		end

		if type(Location) == "table" then
			local X2 = Location[2]
			if type(Location[2]) == "number" then
				table.insert(Act1,SetLoc(Location[1],0,SetTo,X2))
				table.insert(Act1,SetLoc(Location[1],8,SetTo,X2))
			elseif Location[2][4] == "V" then
				table.insert(Act1,{TSetLoc,Location[1],0,SetTo,X2})
				table.insert(Act1,{TSetLoc,Location[1],8,SetTo,X2})
			end
			local Y2 = Location[3]
			if type(Location[3]) == "number" then
				table.insert(Act1,SetLoc(Location[1],4,SetTo,Y2-2))
				table.insert(Act1,SetLoc(Location[1],12,SetTo,Y2-2))
			elseif Location[3][4] == "V" then
				if Y2[5] == nil then
					Y2[5] = 0
				end
				table.insert(Act1,{TSetLoc,Location[1],4,SetTo,Vi(Y2[2],-2+Y2[5],Y2[1],Y2[3])})
				table.insert(Act1,{TSetLoc,Location[1],12,SetTo,Vi(Y2[2],-2+Y2[5],Y2[1],Y2[3])})
			end
			Location = Location[1]
		end

		if Actions ~= nil then
			for k, v in pairs(Actions) do
				table.insert(Act1,v)
			end
		end

		table.insert(Act1,CreateUnit(1,UnitId,Location,Owner))
		table.insert(Act1,SetMemoryB(0x656990+UnitId, SetTo, 0))

		table.insert(Act1,{TSetMemoryX,Vi(NRet[16],0x110/4),SetTo,12,0xFFFF})
		table.insert(Act1,{TSetMemoryX,Vi(NRet[16],0x58/4),SetTo,X,0xFFFF})
		if type(Y) == "number" then
			table.insert(Act1,{TSetMemoryX,Vi(NRet[16],0x58/4),SetTo,Y*65536,0xFFFF0000})
		elseif Y[4] == "V" then
			table.insert(Act1,{TSetMemoryX,Vi(NRet[16],0x58/4),SetTo,{_lShift,Y,16},0xFFFF0000})
		end
		table.insert(Act1,{TSetMemoryX,Vi(NRet[16],0x4C/4),SetTo,14*256,0xFF00})
		table.insert(Act1,{TSetMemoryX,Vi(NRet[16],0x20/4),SetTo,127*65536,0xFF0000})
		CDoActionsX(PlayerID,Act1)
	CIfEnd()
end

function CreateBulletTargetXEnd(PlayerID,Bag,UnitId,Angle,Speed,Time,Conditions,Actions,Preserve) -- XY->Angle
	local Cond2 = {}
	if Conditions == nil then Conditions = {} end
	for k, v in pairs(Conditions) do
		table.insert(Cond2,v)
	end

	local Act2 = {}
	if Preserve == 0 then
		CIfOnce2(PlayerID,Cond2,Actions)
	else
		CIf2(PlayerID,Cond2,Actions)
	end
		NBagLoop(PlayerID,Bag,{V(NRet[15])})
			f_Read(PlayerID,_Add(V(NRet[15]),10),V(NRet[16]))
		
			if type(Angle) == "number" then
				table.insert(Act2,SetMemoryB(0x657888+BulletTable[UnitId][1], SetTo, Angle))
			else
				table.insert(Act2,{TSetMemoryB,0x657888,BulletTable[UnitId][1], SetTo, Angle})
			end

			if type(Speed) == "number" then
				table.insert(Act2,SetMemory(0x6C9EF8+BulletTable[UnitId][2]*4,SetTo,-Speed))
			else
				table.insert(Act2,{TSetMemory,0x6C9EF8+BulletTable[UnitId][2]*4,SetTo,{_Neg,Speed}})
			end

			table.insert(Act2,SetMemoryB(0x656670+BulletTable[UnitId][1],SetTo,9))

			if type(Time) == "number" then
				table.insert(Act2,SetMemoryB(0x657040+BulletTable[UnitId][1], SetTo, Time))
			else
				table.insert(Act2,{TSetMemoryB,0x657040,BulletTable[UnitId][1], SetTo, Time})
			end

			table.insert(Act2,{TSetMemory,Vi(NRet[15],0x58/4),SetTo,V(NRet[16])})
			table.insert(Act2,{TSetMemoryX,Vi(NRet[15],0x20/4),Add,Angle,0xFF00})
			table.insert(Act2,{TSetMemoryX,Vi(NRet[15],0x4C/4),SetTo,135*256,0xFFFFFF00})
			CDoActionsX(PlayerID,Act2)
		NBagLoopEnd()
		NReset(PlayerID,Bag)
	CIfEnd()
end

--[[
function AttackGroundInitSetting(PlayerID,UnitId,HitUnitId,Weapon,Flingy,Sprite,Image,Script,Color,Cooldown,Damage,DamageUp,UpgradeID,BulletNumber,DamageType,Special,Splash,Preserve)
	local X = {Preserved}
	if Preserve == 0 then
		X = {}
	end
	if Cooldown == nil then
		Cooldown = 255
	end

	local HitUnitFlingy = HitUnitId[2]
	local HitUnitSprite = HitUnitId[3]
	local HitUnitImage = HitUnitId[4]

	local BulletUnitFlingy = UnitId[2]
	local BulletUnitSprite = UnitId[3]
	local BulletUnitImage = UnitId[4]
	local TrapAct, TrapAct2, TrapAct3

	TrapAct = SetMemory(0x664080+UnitId[1]*4, SetTo, 939524100) -- 스패셜 어빌리티
	TrapAct2 = SetMemoryB(0x660FC8+UnitId[1], SetTo, 197) -- 이동플래그
	TrapAct3 = {SetMemory(0x664080+HitUnitId[1]*4, SetTo, 4),SetMemoryB(0x660FC8+HitUnitId[1], SetTo, 0)}

	UnitId = UnitId[1]
	HitUnitId = HitUnitId[1]
	BulletTable[UnitId]={Weapon,Flingy,Sprite}

	DoActions2(PlayerID,{
		SetMemory(0x662350+HitUnitId*4,SetTo,8380000*256), -- 체력
		SetMemoryB(0x6636B8+UnitId, SetTo, Weapon), -- 지상무기
		SetMemoryB(0x6616E0+UnitId, SetTo, Weapon), -- 공중무기
		SetMemoryB(0x6636B8+HitUnitId, SetTo, 130), -- 지상무기
		SetMemoryB(0x6616E0+HitUnitId, SetTo, 130), -- 공중무기
		SetMemoryB(0x662DB8+UnitId, SetTo, 255), -- 부가사거리
		SetMemoryB(0x662DB8+HitUnitId, SetTo, 0), -- 부가사거리
		TrapAct,
		TrapAct2,
		TrapAct3,
		SetMemory(0x6617C8+UnitId*8, SetTo, 65537), -- 유닛크기
		SetMemory(0x6617CC+UnitId*8, SetTo, 0), -- 버터쿠키
		SetMemory(0x6617C8+HitUnitId*8, SetTo, 65537), -- 유닛크기
		SetMemory(0x6617CC+HitUnitId*8, SetTo, 0), -- 버터쿠키
		SetMemoryB(0x6644F8+UnitId, SetTo, BulletUnitFlingy), -- 비행정보
		SetMemoryB(0x6644F8+HitUnitId, SetTo, HitUnitFlingy), -- 비행정보
		SetMemoryB(0x6637A0+UnitId, SetTo, 2), -- 소속그룹
		SetMemoryB(0x6637A0+HitUnitId, SetTo, 2), -- 소속그룹
		SetMemoryW(0x661518+UnitId*2, SetTo, 0x1CF), -- 에디터 어빌리티
		SetMemoryW(0x661518+HitUnitId*2, SetTo, 0x1CF), -- 에디터 어빌리티
		--SetMemory(0x662860+UnitId*4, SetTo, 1), -- 생산크기
		--SetMemory(0x662860+HitUnitId*4, SetTo, 1), -- 생산크기
		SetMemoryB(0x662EA0+UnitId, SetTo, 2), -- 컴퓨터 기본 Ai
		SetMemoryB(0x662268+UnitId, SetTo, 2), -- 사람 기본 Ai
		SetMemoryB(0x664898+UnitId, SetTo, 2), -- 평상시 Ai
		SetMemoryB(0x663320+UnitId, SetTo, 10), -- 유닛공격 Ai
		SetMemoryB(0x663A50+UnitId, SetTo, 2), -- 공격과 이동 Ai
		SetMemoryB(0x662098+UnitId, SetTo, 1), -- 우클릭 행동
		SetMemoryB(0x662EA0+HitUnitId, SetTo, 23), -- 컴퓨터 기본 Ai
		SetMemoryB(0x662268+HitUnitId, SetTo, 23), -- 사람 기본 Ai
		SetMemoryB(0x664898+HitUnitId, SetTo, 23), -- 평상시 Ai
		SetMemoryB(0x663320+HitUnitId, SetTo, 23), -- 유닛공격 Ai
		SetMemoryB(0x663A50+HitUnitId, SetTo, 23), -- 공격과 이동 Ai
		SetMemoryB(0x662098+HitUnitId, SetTo, 0), -- 우클릭 행동

		SetMemory(0x6C9EF8+BulletUnitFlingy*4, SetTo, 1700), -- 최대속도
		SetMemoryW(0x6C9C78+BulletUnitFlingy*2, SetTo, 70), -- 가속도
		SetMemory(0x6C9930+BulletUnitFlingy*4, SetTo, 0), -- 멈추는거리
		SetMemoryB(0x6C9E20+BulletUnitFlingy, SetTo, 40), -- 회전반경
		SetMemoryB(0x6C9858+BulletUnitFlingy, SetTo, 0), -- 이동제어
		SetMemory(0x6C9EF8+HitUnitFlingy*4, SetTo, 0), -- 최대속도
		SetMemoryW(0x6C9C78+HitUnitFlingy*2, SetTo, 1), -- 가속도
		SetMemory(0x6C9930+HitUnitFlingy*4, SetTo, 0), -- 멈추는거리
		SetMemoryB(0x6C9E20+HitUnitFlingy, SetTo, 40), -- 회전반경
		SetMemoryB(0x6C9858+HitUnitFlingy, SetTo, 0), -- 이동제어
		SetMemoryW(0x6CA318+BulletUnitFlingy*2, SetTo, BulletUnitSprite), -- 스프라이트
		SetMemoryW(0x6CA318+HitUnitFlingy*2, SetTo, HitUnitSprite), -- 스프라이트
		SetMemoryW(0x666160+BulletUnitSprite*2, SetTo, BulletUnitImage), -- 이미지
		SetMemoryW(0x666160+HitUnitSprite*2, SetTo, HitUnitImage), -- 이미지

		SetMemoryB(0x656FB8+Weapon,SetTo,Cooldown), --  공격속도
		SetMemoryW(0x656EB0+Weapon*2,SetTo,Damage), -- 데미지
		SetMemoryW(0x657678+Weapon*2,SetTo,DamageUp), -- 추가데미지
		SetMemoryB(0x6564E0+Weapon, SetTo, BulletNumber), -- 총알갯수
		SetMemoryB(0x6571D0+Weapon, SetTo, UpgradeID), -- 업그레이드
		SetMemoryB(0x657258+Weapon, SetTo, DamageType), -- 데미지형식
		SetMemoryB(0x6566F8+Weapon, SetTo, Special), -- 폭발형
		SetMemoryW(0x656888+Weapon*2, SetTo, Splash[1]), -- 스플안쪽
		SetMemoryW(0x6570C8+Weapon*2, SetTo, Splash[2]), -- 스플중간
		SetMemoryW(0x657780+Weapon*2, SetTo, Splash[3]), -- 스플외각
		SetMemoryB(0x657888+Weapon, SetTo, 0), -- 발사회전값 
		SetMemory(0x656A18+Weapon*4, SetTo, 0), -- 최소사거리
		SetMemory(0x657470+Weapon*4, SetTo, 65536), -- 최대사거리
		SetMemory(0x656CA8+Weapon*4, SetTo, Flingy), -- 무기 비행정보
		SetMemoryB(0x657910+Weapon, SetTo, 0), -- 발사위치X
		SetMemoryB(0x656C20+Weapon, SetTo, 0), -- 발사위치Y
		SetMemoryB(0x656990+Weapon, SetTo, 0), -- 공격 가능 각도

		SetMemoryW(0x6CA318+Flingy*2, SetTo, Sprite), -- 스프라이트
		SetMemoryW(0x6C9C78+Flingy*2, SetTo, 50000), -- 가속도
		SetMemory(0x6C9930+Flingy*4, SetTo, 0), -- 멈추는거리
		SetMemoryB(0x6C9E20+Flingy, SetTo, 127), -- 회전반경
		SetMemoryB(0x6C9858+Flingy, SetTo, 0), -- 이동제어

		SetMemoryW(0x666160+Sprite*2, SetTo, Image), -- 이미지

		SetMemoryB(0x669E28+Image, SetTo, Color), -- 화면출력
		SetMemory(0x66EC48+Image*4,SetTo,Script), -- 스크립트
	},X)
end

function AttackGround(PlayerID,Owner,UnitId,HitUnitId,Height,Speed,Time,RemoveTime,FireType,Start,End,Conditions,Actions,Preserve)
	local PointToDir = 1
	if RemoveTime == nil then
		RemoveTime = 16
	end
	local Act = {}
	if Conditions == nil then Conditions = {} end
	table.insert(Conditions,Memory(0x628438,AtLeast,1))
	if Preserve == 0 then
		CIfOnce2(PlayerID,Conditions)
	else
		CIf2(PlayerID,Conditions)
	end
		f_Read(PlayerID,0x628438,nil,V(NRet[16]))

		if type(Height) == "number" then -- 쏘는 유닛에게만 적용
			table.insert(Act,SetMemoryB(0x663150+UnitId,SetTo,Height))
		elseif Height[4] == "V" then 
			table.insert(Act,{TSetMemoryB,0x663150,UnitId,SetTo,Height})
		end

		local StartLoc, EndLoc 

		if type(Start) == "table" then
			local X = Start[2]
			if type(Start[2]) == "number" then
				table.insert(Act,SetLoc(Start[1],0,SetTo,X))
				table.insert(Act,SetLoc(Start[1],8,SetTo,X))
			elseif Start[2][4] == "V" then
				table.insert(Act,{TSetLoc,Start[1],0,SetTo,X})
				table.insert(Act,{TSetLoc,Start[1],8,SetTo,X})
			end
			local Y = Start[3]
			if type(Start[3]) == "number" then
				table.insert(Act,SetLoc(Start[1],4,SetTo,Y))
				table.insert(Act,SetLoc(Start[1],12,SetTo,Y))
			elseif Start[3][4] == "V" then
				if Y[5] == nil then
					Y[5] = 0
				end
				table.insert(Act,{TSetLoc,Start[1],4,SetTo,Y})
				table.insert(Act,{TSetLoc,Start[1],12,SetTo,Y})
			end
			StartLoc = Start[1]
		else
			StartLoc = Start
		end

		if type(End) == "table" then
			local X = End[2]
			if type(End[2]) == "number" then
				table.insert(Act,SetLoc(End[1],0,SetTo,X))
				table.insert(Act,SetLoc(End[1],8,SetTo,X))
			elseif End[2][4] == "V" then
				table.insert(Act,{TSetLoc,End[1],0,SetTo,X})
				table.insert(Act,{TSetLoc,End[1],8,SetTo,X})
			end
			local Y = End[3]
			if type(End[3]) == "number" then
				table.insert(Act,SetLoc(End[1],4,SetTo,Y))
				table.insert(Act,SetLoc(End[1],12,SetTo,Y))
			elseif End[3][4] == "V" then
				if Y[5] == nil then
					Y[5] = 0
				end
				table.insert(Act,{TSetLoc,End[1],4,SetTo,Y})
				table.insert(Act,{TSetLoc,End[1],12,SetTo,Y})
			end
			EndLoc = End[1]
		else
			EndLoc = End
		end


		if PointToDir == 1 then
			table.insert(Act,SetMemoryB(0x657888+BulletTable[UnitId][1],SetTo,0))
		else
			table.insert(Act,SetMemoryB(0x657888+BulletTable[UnitId][1],SetTo,128))
		end

		table.insert(Act,SetMemoryB(0x656670+BulletTable[UnitId][1],SetTo,FireType))

		if Actions ~= nil then
			for k, v in pairs(Actions) do
				table.insert(Act,v)
			end
		end

		if PointToDir == 1 then
			if type(Speed) == "number" then
				table.insert(Act,SetMemory(0x6C9EF8+BulletTable[UnitId][2]*4,SetTo,-Speed))
			else
				table.insert(Act,{TSetMemory,0x6C9EF8+BulletTable[UnitId][2]*4,SetTo,{_Neg,Speed}})
			end
			--table.insert(Act,SetMemoryW(0x6C9C78+BulletTable[UnitId][2]*2,SetTo,50000))
			--table.insert(Act,SetMemoryB(0x6C9E20+BulletTable[UnitId][2],SetTo,127))
			--table.insert(Act,SetMemory(0x6C9930+BulletTable[UnitId][2]*4,SetTo,0))
		else
			if type(Speed) == "number" then
				table.insert(Act,SetMemory(0x6C9EF8+BulletTable[UnitId][2]*4,SetTo,Speed))
			else
				table.insert(Act,{TSetMemory,0x6C9EF8+BulletTable[UnitId][2]*4,SetTo,Speed})
			end

			if type(Acceleration) == "number" then
				table.insert(Act,SetMemoryW(0x6C9C78+BulletTable[UnitId][2]*2,SetTo,Acceleration))
			else
				table.insert(Act,{TSetMemoryW,0x6C9C78+BulletTable[UnitId][2]*2,SetTo,Acceleration})
			end

			if type(TurnRadius) == "number" then
				table.insert(Act,SetMemoryB(0x6C9E20+BulletTable[UnitId][2],SetTo,TurnRadius))
			else
				table.insert(Act,{TSetMemoryB,0x6C9E20+BulletTable[UnitId][2],SetTo,TurnRadius})
			end

			if type(Halt) == "number" then
				table.insert(Act,SetMemory(0x6C9930+BulletTable[UnitId][2]*4,SetTo,Halt))
			else
				table.insert(Act,{TSetMemory,0x6C9930+BulletTable[UnitId][2]*4,SetTo,Halt})
			end

		end

		if type(Time) == "number" then
			table.insert(Act,SetMemoryB(0x657040+BulletTable[UnitId][1], SetTo, Time))
		else
			table.insert(Act,{TSetMemoryB,0x657040,BulletTable[UnitId][1], SetTo, Time})
		end

		if type(Owner) == "number" then
			Owner = {Owner,Owner}
		end

		table.insert(Act,CreateUnit(1,UnitId,StartLoc,Owner[1]))

		CDoActionsX(PlayerID,Act)

		CIfX(PlayerID,Memory(0x628438,AtLeast,1))
			f_Read(PlayerID,0x628438,V(NRet[14]),V(NRet[15]))

			if RemoveTime == "X" then
				CDoActions(PlayerID,{
					CreateUnit(1,HitUnitId,EndLoc,Owner[2]),
					TSetMemory(Vi(NRet[16],0x5C/4),SetTo,V(NRet[14])),
					TSetMemoryX(Vi(NRet[16],0x4C/4),SetTo,10*256,0xFF00),
				})
			else
				CDoActions(PlayerID,{
					CreateUnit(1,HitUnitId,EndLoc,Owner[2]),
					TSetMemory(Vi(NRet[16],0x5C/4),SetTo,V(NRet[14])),
					TSetMemoryX(Vi(NRet[16],0x4C/4),SetTo,10*256,0xFF00),
					TSetMemoryX(Vi(NRet[16],0x110/4),SetTo,RemoveTime,0xFFFF),
					TSetMemoryX(Vi(NRet[15],0x110/4),SetTo,RemoveTime,0xFFFF),
				})
			end
		CElseX()
			CDoActions(PlayerID,{
				TSetMemoryX(Vi(NRet[16],0x110/4),SetTo,1,0xFFFF),
			})
		CIfXEnd()
	CIfEnd()
end
]]--